(self.webpackChunkbibliotecaArtemisa=self.webpackChunkbibliotecaArtemisa||[]).push([[179],{801:(Xn,He,Q)=>{"use strict";Q.d(He,{lIc:()=>Di,hG5:()=>ja,LEp:()=>O1,Bc6:()=>Je,dT$:()=>gr,mh3:()=>gi,zkM:()=>br,JHj:()=>V2,Xj:()=>o2,J9Y:()=>Nr,sqG:()=>F,X8G:()=>Ci,AGO:()=>E3,qLl:()=>q3,tU6:()=>H8,r8p:()=>a0,o4t:()=>l0,Psp:()=>W3,QRb:()=>g0,wn1:()=>Go,I3c:()=>_0,EvU:()=>U4,B3e:()=>C7,Jw3:()=>Z4,lEy:()=>$4,kWN:()=>Y4});var Di={prefix:"fas",iconName:"binoculars",icon:[512,512,[],"f1e5","M416 48c0-8.84-7.16-16-16-16h-64c-8.84 0-16 7.16-16 16v48h96V48zM63.91 159.99C61.4 253.84 3.46 274.22 0 404v44c0 17.67 14.33 32 32 32h96c17.67 0 32-14.33 32-32V288h32V128H95.84c-17.63 0-31.45 14.37-31.93 31.99zm384.18 0c-.48-17.62-14.3-31.99-31.93-31.99H320v160h32v160c0 17.67 14.33 32 32 32h96c17.67 0 32-14.33 32-32v-44c-3.46-129.78-61.4-150.16-63.91-244.01zM176 32h-64c-8.84 0-16 7.16-16 16v48h96V48c0-8.84-7.16-16-16-16zm48 256h64V128h-64v160z"]},ja={prefix:"fas",iconName:"chalkboard-teacher",icon:[640,512,[],"f51c","M208 352c-2.39 0-4.78.35-7.06 1.09C187.98 357.3 174.35 360 160 360c-14.35 0-27.98-2.7-40.95-6.91-2.28-.74-4.66-1.09-7.05-1.09C49.94 352-.33 402.48 0 464.62.14 490.88 21.73 512 48 512h224c26.27 0 47.86-21.12 48-47.38.33-62.14-49.94-112.62-112-112.62zm-48-32c53.02 0 96-42.98 96-96s-42.98-96-96-96-96 42.98-96 96 42.98 96 96 96zM592 0H208c-26.47 0-48 22.25-48 49.59V96c23.42 0 45.1 6.78 64 17.8V64h352v288h-64v-64H384v64h-76.24c19.1 16.69 33.12 38.73 39.69 64H592c26.47 0 48-22.25 48-49.59V49.59C640 22.25 618.47 0 592 0z"]},O1={prefix:"fas",iconName:"check",icon:[512,512,[],"f00c","M173.898 439.404l-166.4-166.4c-9.997-9.997-9.997-26.206 0-36.204l36.203-36.204c9.997-9.998 26.207-9.998 36.204 0L192 312.69 432.095 72.596c9.997-9.997 26.207-9.997 36.204 0l36.203 36.204c9.997 9.997 9.997 26.206 0 36.204l-294.4 294.401c-9.998 9.997-26.207 9.997-36.204-.001z"]},Je={prefix:"fas",iconName:"chevron-circle-right",icon:[512,512,[],"f138","M256 8c137 0 248 111 248 248S393 504 256 504 8 393 8 256 119 8 256 8zm113.9 231L234.4 103.5c-9.4-9.4-24.6-9.4-33.9 0l-17 17c-9.4 9.4-9.4 24.6 0 33.9L285.1 256 183.5 357.6c-9.4 9.4-9.4 24.6 0 33.9l17 17c9.4 9.4 24.6 9.4 33.9 0L369.9 273c9.4-9.4 9.4-24.6 0-34z"]},gr={prefix:"fas",iconName:"code",icon:[640,512,[],"f121","M278.9 511.5l-61-17.7c-6.4-1.8-10-8.5-8.2-14.9L346.2 8.7c1.8-6.4 8.5-10 14.9-8.2l61 17.7c6.4 1.8 10 8.5 8.2 14.9L293.8 503.3c-1.9 6.4-8.5 10.1-14.9 8.2zm-114-112.2l43.5-46.4c4.6-4.9 4.3-12.7-.8-17.2L117 256l90.6-79.7c5.1-4.5 5.5-12.3.8-17.2l-43.5-46.4c-4.5-4.8-12.1-5.1-17-.5L3.8 247.2c-5.1 4.7-5.1 12.8 0 17.5l144.1 135.1c4.9 4.6 12.5 4.4 17-.5zm327.2.6l144.1-135.1c5.1-4.7 5.1-12.8 0-17.5L492.1 112.1c-4.8-4.5-12.4-4.3-17 .5L431.6 159c-4.6 4.9-4.3 12.7.8 17.2L523 256l-90.6 79.7c-5.1 4.5-5.5 12.3-.8 17.2l43.5 46.4c4.5 4.9 12.1 5.1 17 .6z"]},gi={prefix:"fas",iconName:"code-branch",icon:[384,512,[],"f126","M384 144c0-44.2-35.8-80-80-80s-80 35.8-80 80c0 36.4 24.3 67.1 57.5 76.8-.6 16.1-4.2 28.5-11 36.9-15.4 19.2-49.3 22.4-85.2 25.7-28.2 2.6-57.4 5.4-81.3 16.9v-144c32.5-10.2 56-40.5 56-76.3 0-44.2-35.8-80-80-80S0 35.8 0 80c0 35.8 23.5 66.1 56 76.3v199.3C23.5 365.9 0 396.2 0 432c0 44.2 35.8 80 80 80s80-35.8 80-80c0-34-21.2-63.1-51.2-74.6 3.1-5.2 7.8-9.8 14.9-13.4 16.2-8.2 40.4-10.4 66.1-12.8 42.2-3.9 90-8.4 118.2-43.4 14-17.4 21.1-39.8 21.6-67.9 31.6-10.8 54.4-40.7 54.4-75.9zM80 64c8.8 0 16 7.2 16 16s-7.2 16-16 16-16-7.2-16-16 7.2-16 16-16zm0 384c-8.8 0-16-7.2-16-16s7.2-16 16-16 16 7.2 16 16-7.2 16-16 16zm224-320c8.8 0 16 7.2 16 16s-7.2 16-16 16-16-7.2-16-16 7.2-16 16-16z"]},br={prefix:"fas",iconName:"dice-one",icon:[448,512,[],"f525","M384 32H64C28.65 32 0 60.65 0 96v320c0 35.35 28.65 64 64 64h320c35.35 0 64-28.65 64-64V96c0-35.35-28.65-64-64-64zM224 288c-17.67 0-32-14.33-32-32s14.33-32 32-32 32 14.33 32 32-14.33 32-32 32z"]},V2={prefix:"fas",iconName:"gavel",icon:[512,512,[],"f0e3","M504.971 199.362l-22.627-22.627c-9.373-9.373-24.569-9.373-33.941 0l-5.657 5.657L329.608 69.255l5.657-5.657c9.373-9.373 9.373-24.569 0-33.941L312.638 7.029c-9.373-9.373-24.569-9.373-33.941 0L154.246 131.48c-9.373 9.373-9.373 24.569 0 33.941l22.627 22.627c9.373 9.373 24.569 9.373 33.941 0l5.657-5.657 39.598 39.598-81.04 81.04-5.657-5.657c-12.497-12.497-32.758-12.497-45.255 0L9.373 412.118c-12.497 12.497-12.497 32.758 0 45.255l45.255 45.255c12.497 12.497 32.758 12.497 45.255 0l114.745-114.745c12.497-12.497 12.497-32.758 0-45.255l-5.657-5.657 81.04-81.04 39.598 39.598-5.657 5.657c-9.373 9.373-9.373 24.569 0 33.941l22.627 22.627c9.373 9.373 24.569 9.373 33.941 0l124.451-124.451c9.372-9.372 9.372-24.568 0-33.941z"]},o2={prefix:"fas",iconName:"globe-americas",icon:[496,512,[],"f57d","M248 8C111.03 8 0 119.03 0 256s111.03 248 248 248 248-111.03 248-248S384.97 8 248 8zm82.29 357.6c-3.9 3.88-7.99 7.95-11.31 11.28-2.99 3-5.1 6.7-6.17 10.71-1.51 5.66-2.73 11.38-4.77 16.87l-17.39 46.85c-13.76 3-28 4.69-42.65 4.69v-27.38c1.69-12.62-7.64-36.26-22.63-51.25-6-6-9.37-14.14-9.37-22.63v-32.01c0-11.64-6.27-22.34-16.46-27.97-14.37-7.95-34.81-19.06-48.81-26.11-11.48-5.78-22.1-13.14-31.65-21.75l-.8-.72a114.792 114.792 0 0 1-18.06-20.74c-9.38-13.77-24.66-36.42-34.59-51.14 20.47-45.5 57.36-82.04 103.2-101.89l24.01 12.01C203.48 89.74 216 82.01 216 70.11v-11.3c7.99-1.29 16.12-2.11 24.39-2.42l28.3 28.3c6.25 6.25 6.25 16.38 0 22.63L264 112l-10.34 10.34c-3.12 3.12-3.12 8.19 0 11.31l4.69 4.69c3.12 3.12 3.12 8.19 0 11.31l-8 8a8.008 8.008 0 0 1-5.66 2.34h-8.99c-2.08 0-4.08.81-5.58 2.27l-9.92 9.65a8.008 8.008 0 0 0-1.58 9.31l15.59 31.19c2.66 5.32-1.21 11.58-7.15 11.58h-5.64c-1.93 0-3.79-.7-5.24-1.96l-9.28-8.06a16.017 16.017 0 0 0-15.55-3.1l-31.17 10.39a11.95 11.95 0 0 0-8.17 11.34c0 4.53 2.56 8.66 6.61 10.69l11.08 5.54c9.41 4.71 19.79 7.16 30.31 7.16s22.59 27.29 32 32h66.75c8.49 0 16.62 3.37 22.63 9.37l13.69 13.69a30.503 30.503 0 0 1 8.93 21.57 46.536 46.536 0 0 1-13.72 32.98zM417 274.25c-5.79-1.45-10.84-5-14.15-9.97l-17.98-26.97a23.97 23.97 0 0 1 0-26.62l19.59-29.38c2.32-3.47 5.5-6.29 9.24-8.15l12.98-6.49C440.2 193.59 448 223.87 448 256c0 8.67-.74 17.16-1.82 25.54L417 274.25z"]},Nr={prefix:"fas",iconName:"home",icon:[576,512,[],"f015","M280.37 148.26L96 300.11V464a16 16 0 0 0 16 16l112.06-.29a16 16 0 0 0 15.92-16V368a16 16 0 0 1 16-16h64a16 16 0 0 1 16 16v95.64a16 16 0 0 0 16 16.05L464 480a16 16 0 0 0 16-16V300L295.67 148.26a12.19 12.19 0 0 0-15.3 0zM571.6 251.47L488 182.56V44.05a12 12 0 0 0-12-12h-56a12 12 0 0 0-12 12v72.61L318.47 43a48 48 0 0 0-61 0L4.34 251.47a12 12 0 0 0-1.6 16.9l25.5 31A12 12 0 0 0 45.15 301l235.22-193.74a12.19 12.19 0 0 1 15.3 0L530.9 301a12 12 0 0 0 16.9-1.6l25.5-31a12 12 0 0 0-1.7-16.93z"]},F={prefix:"fas",iconName:"info-circle",icon:[512,512,[],"f05a","M256 8C119.043 8 8 119.083 8 256c0 136.997 111.043 248 248 248s248-111.003 248-248C504 119.083 392.957 8 256 8zm0 110c23.196 0 42 18.804 42 42s-18.804 42-42 42-42-18.804-42-42 18.804-42 42-42zm56 254c0 6.627-5.373 12-12 12h-88c-6.627 0-12-5.373-12-12v-24c0-6.627 5.373-12 12-12h12v-64h-12c-6.627 0-12-5.373-12-12v-24c0-6.627 5.373-12 12-12h64c6.627 0 12 5.373 12 12v100h12c6.627 0 12 5.373 12 12v24z"]},Ci={prefix:"fas",iconName:"lightbulb",icon:[352,512,[],"f0eb","M96.06 454.35c.01 6.29 1.87 12.45 5.36 17.69l17.09 25.69a31.99 31.99 0 0 0 26.64 14.28h61.71a31.99 31.99 0 0 0 26.64-14.28l17.09-25.69a31.989 31.989 0 0 0 5.36-17.69l.04-38.35H96.01l.05 38.35zM0 176c0 44.37 16.45 84.85 43.56 115.78 16.52 18.85 42.36 58.23 52.21 91.45.04.26.07.52.11.78h160.24c.04-.26.07-.51.11-.78 9.85-33.22 35.69-72.6 52.21-91.45C335.55 260.85 352 220.37 352 176 352 78.61 272.91-.3 175.45 0 73.44.31 0 82.97 0 176zm176-80c-44.11 0-80 35.89-80 80 0 8.84-7.16 16-16 16s-16-7.16-16-16c0-61.76 50.24-112 112-112 8.84 0 16 7.16 16 16s-7.16 16-16 16z"]},E3={prefix:"fas",iconName:"long-arrow-alt-right",icon:[448,512,[],"f30b","M313.941 216H12c-6.627 0-12 5.373-12 12v56c0 6.627 5.373 12 12 12h301.941v46.059c0 21.382 25.851 32.09 40.971 16.971l86.059-86.059c9.373-9.373 9.373-24.569 0-33.941l-86.059-86.059c-15.119-15.119-40.971-4.411-40.971 16.971V216z"]},q3={prefix:"fas",iconName:"pencil-ruler",icon:[512,512,[],"f5ae","M109.46 244.04l134.58-134.56-44.12-44.12-61.68 61.68a7.919 7.919 0 0 1-11.21 0l-11.21-11.21c-3.1-3.1-3.1-8.12 0-11.21l61.68-61.68-33.64-33.65C131.47-3.1 111.39-3.1 99 9.29L9.29 99c-12.38 12.39-12.39 32.47 0 44.86l100.17 100.18zm388.47-116.8c18.76-18.76 18.75-49.17 0-67.93l-45.25-45.25c-18.76-18.76-49.18-18.76-67.95 0l-46.02 46.01 113.2 113.2 46.02-46.03zM316.08 82.71l-297 296.96L.32 487.11c-2.53 14.49 10.09 27.11 24.59 24.56l107.45-18.84L429.28 195.9 316.08 82.71zm186.63 285.43l-33.64-33.64-61.68 61.68c-3.1 3.1-8.12 3.1-11.21 0l-11.21-11.21c-3.09-3.1-3.09-8.12 0-11.21l61.68-61.68-44.14-44.14L267.93 402.5l100.21 100.2c12.39 12.39 32.47 12.39 44.86 0l89.71-89.7c12.39-12.39 12.39-32.47 0-44.86z"]},H8={prefix:"fas",iconName:"pizza-slice",icon:[512,512,[],"f818","M158.87.15c-16.16-1.52-31.2 8.42-35.33 24.12l-14.81 56.27c187.62 5.49 314.54 130.61 322.48 317l56.94-15.78c15.72-4.36 25.49-19.68 23.62-35.9C490.89 165.08 340.78 17.32 158.87.15zm-58.47 112L.55 491.64a16.21 16.21 0 0 0 20 19.75l379-105.1c-4.27-174.89-123.08-292.14-299.15-294.1zM128 416a32 32 0 1 1 32-32 32 32 0 0 1-32 32zm48-152a32 32 0 1 1 32-32 32 32 0 0 1-32 32zm104 104a32 32 0 1 1 32-32 32 32 0 0 1-32 32z"]},a0={prefix:"fas",iconName:"plus",icon:[448,512,[],"f067","M416 208H272V64c0-17.67-14.33-32-32-32h-32c-17.67 0-32 14.33-32 32v144H32c-17.67 0-32 14.33-32 32v32c0 17.67 14.33 32 32 32h144v144c0 17.67 14.33 32 32 32h32c17.67 0 32-14.33 32-32V304h144c17.67 0 32-14.33 32-32v-32c0-17.67-14.33-32-32-32z"]},l0={prefix:"fas",iconName:"project-diagram",icon:[640,512,[],"f542","M384 320H256c-17.67 0-32 14.33-32 32v128c0 17.67 14.33 32 32 32h128c17.67 0 32-14.33 32-32V352c0-17.67-14.33-32-32-32zM192 32c0-17.67-14.33-32-32-32H32C14.33 0 0 14.33 0 32v128c0 17.67 14.33 32 32 32h95.72l73.16 128.04C211.98 300.98 232.4 288 256 288h.28L192 175.51V128h224V64H192V32zM608 0H480c-17.67 0-32 14.33-32 32v128c0 17.67 14.33 32 32 32h128c17.67 0 32-14.33 32-32V32c0-17.67-14.33-32-32-32z"]},W3={prefix:"fas",iconName:"question",icon:[384,512,[],"f128","M202.021 0C122.202 0 70.503 32.703 29.914 91.026c-7.363 10.58-5.093 25.086 5.178 32.874l43.138 32.709c10.373 7.865 25.132 6.026 33.253-4.148 25.049-31.381 43.63-49.449 82.757-49.449 30.764 0 68.816 19.799 68.816 49.631 0 22.552-18.617 34.134-48.993 51.164-35.423 19.86-82.299 44.576-82.299 106.405V320c0 13.255 10.745 24 24 24h72.471c13.255 0 24-10.745 24-24v-5.773c0-42.86 125.268-44.645 125.268-160.627C377.504 66.256 286.902 0 202.021 0zM192 373.459c-38.196 0-69.271 31.075-69.271 69.271 0 38.195 31.075 69.27 69.271 69.27s69.271-31.075 69.271-69.271-31.075-69.27-69.271-69.27z"]},g0={prefix:"fas",iconName:"school",icon:[640,512,[],"f549","M0 224v272c0 8.84 7.16 16 16 16h80V192H32c-17.67 0-32 14.33-32 32zm360-48h-24v-40c0-4.42-3.58-8-8-8h-16c-4.42 0-8 3.58-8 8v64c0 4.42 3.58 8 8 8h48c4.42 0 8-3.58 8-8v-16c0-4.42-3.58-8-8-8zm137.75-63.96l-160-106.67a32.02 32.02 0 0 0-35.5 0l-160 106.67A32.002 32.002 0 0 0 128 138.66V512h128V368c0-8.84 7.16-16 16-16h96c8.84 0 16 7.16 16 16v144h128V138.67c0-10.7-5.35-20.7-14.25-26.63zM320 256c-44.18 0-80-35.82-80-80s35.82-80 80-80 80 35.82 80 80-35.82 80-80 80zm288-64h-64v320h80c8.84 0 16-7.16 16-16V224c0-17.67-14.33-32-32-32z"]},Go={prefix:"fas",iconName:"search",icon:[512,512,[],"f002","M505 442.7L405.3 343c-4.5-4.5-10.6-7-17-7H372c27.6-35.3 44-79.7 44-128C416 93.1 322.9 0 208 0S0 93.1 0 208s93.1 208 208 208c48.3 0 92.7-16.4 128-44v16.3c0 6.4 2.5 12.5 7 17l99.7 99.7c9.4 9.4 24.6 9.4 33.9 0l28.3-28.3c9.4-9.4 9.4-24.6.1-34zM208 336c-70.7 0-128-57.2-128-128 0-70.7 57.2-128 128-128 70.7 0 128 57.2 128 128 0 70.7-57.2 128-128 128z"]},_0={prefix:"fas",iconName:"smile",icon:[496,512,[],"f118","M248 8C111 8 0 119 0 256s111 248 248 248 248-111 248-248S385 8 248 8zm80 168c17.7 0 32 14.3 32 32s-14.3 32-32 32-32-14.3-32-32 14.3-32 32-32zm-160 0c17.7 0 32 14.3 32 32s-14.3 32-32 32-32-14.3-32-32 14.3-32 32-32zm194.8 170.2C334.3 380.4 292.5 400 248 400s-86.3-19.6-114.8-53.8c-13.6-16.3 11-36.7 24.6-20.5 22.4 26.9 55.2 42.2 90.2 42.2s67.8-15.4 90.2-42.2c13.4-16.2 38.1 4.2 24.6 20.5z"]},U4={prefix:"fas",iconName:"sort-numeric-down-alt",icon:[448,512,[],"f886","M176 352h-48V48a16 16 0 0 0-16-16H80a16 16 0 0 0-16 16v304H16c-14.19 0-21.36 17.24-11.29 27.31l80 96a16 16 0 0 0 22.62 0l80-96C197.35 369.26 190.22 352 176 352zm224 64h-16V304a16 16 0 0 0-16-16h-48a16 16 0 0 0-14.29 8.83l-16 32A16 16 0 0 0 304 352h16v64h-16a16 16 0 0 0-16 16v32a16 16 0 0 0 16 16h96a16 16 0 0 0 16-16v-32a16 16 0 0 0-16-16zM330.17 34.91a79 79 0 0 0-55 54.17c-14.27 51.05 21.19 97.77 68.83 102.53a84.07 84.07 0 0 1-20.85 12.91c-7.57 3.4-10.8 12.47-8.18 20.34l9.9 20c2.87 8.63 12.53 13.49 20.9 9.91 58-24.77 86.25-61.61 86.25-132V112c-.02-51.21-48.4-91.34-101.85-77.09zM352 132a20 20 0 1 1 20-20 20 20 0 0 1-20 20z"]},C7={prefix:"fas",iconName:"table",icon:[512,512,[],"f0ce","M464 32H48C21.49 32 0 53.49 0 80v352c0 26.51 21.49 48 48 48h416c26.51 0 48-21.49 48-48V80c0-26.51-21.49-48-48-48zM224 416H64v-96h160v96zm0-160H64v-96h160v96zm224 160H288v-96h160v96zm0-160H288v-96h160v96z"]},Z4={prefix:"fas",iconName:"terminal",icon:[640,512,[],"f120","M257.981 272.971L63.638 467.314c-9.373 9.373-24.569 9.373-33.941 0L7.029 444.647c-9.357-9.357-9.375-24.522-.04-33.901L161.011 256 6.99 101.255c-9.335-9.379-9.317-24.544.04-33.901l22.667-22.667c9.373-9.373 24.569-9.373 33.941 0L257.981 239.03c9.373 9.372 9.373 24.568 0 33.941zM640 456v-32c0-13.255-10.745-24-24-24H312c-13.255 0-24 10.745-24 24v32c0 13.255 10.745 24 24 24h304c13.255 0 24-10.745 24-24z"]},$4={prefix:"fas",iconName:"text-width",icon:[448,512,[],"f035","M432 32H16A16 16 0 0 0 0 48v80a16 16 0 0 0 16 16h32a16 16 0 0 0 16-16v-16h120v112h-24a16 16 0 0 0-16 16v32a16 16 0 0 0 16 16h128a16 16 0 0 0 16-16v-32a16 16 0 0 0-16-16h-24V112h120v16a16 16 0 0 0 16 16h32a16 16 0 0 0 16-16V48a16 16 0 0 0-16-16zm-68.69 260.69C354 283.36 336 288.36 336 304v48H112v-48c0-14.31-17.31-21.32-27.31-11.31l-80 80a16 16 0 0 0 0 22.62l80 80C94 484.64 112 479.64 112 464v-48h224v48c0 14.31 17.31 21.33 27.31 11.31l80-80a16 16 0 0 0 0-22.62z"]},Y4={prefix:"fas",iconName:"trophy",icon:[576,512,[],"f091","M552 64H448V24c0-13.3-10.7-24-24-24H152c-13.3 0-24 10.7-24 24v40H24C10.7 64 0 74.7 0 88v56c0 35.7 22.5 72.4 61.9 100.7 31.5 22.7 69.8 37.1 110 41.7C203.3 338.5 240 360 240 360v72h-48c-35.3 0-64 20.7-64 56v12c0 6.6 5.4 12 12 12h296c6.6 0 12-5.4 12-12v-12c0-35.3-28.7-56-64-56h-48v-72s36.7-21.5 68.1-73.6c40.3-4.6 78.6-19 110-41.7 39.3-28.3 61.9-65 61.9-100.7V88c0-13.3-10.7-24-24-24zM99.3 192.8C74.9 175.2 64 155.6 64 144v-16h64.2c1 32.6 5.8 61.2 12.8 86.2-15.1-5.2-29.2-12.4-41.7-21.4zM512 144c0 16.1-17.7 36.1-35.3 48.8-12.5 9-26.7 16.2-41.8 21.4 7-25 11.8-53.6 12.8-86.2H512v16z"]}},8862:(Xn,He,Q)=>{"use strict";var M=Q(2313),d=Q(6435);class Ue{}const ye="*";function fe(r,a=null){return{type:2,steps:r,options:a}}function le(r){return{type:6,styles:r,offset:null}}function Dn(r){Promise.resolve(null).then(r)}class yn{constructor(a=0,e=0){this._onDoneFns=[],this._onStartFns=[],this._onDestroyFns=[],this._started=!1,this._destroyed=!1,this._finished=!1,this._position=0,this.parentPlayer=null,this.totalTime=a+e}_onFinish(){this._finished||(this._finished=!0,this._onDoneFns.forEach(a=>a()),this._onDoneFns=[])}onStart(a){this._onStartFns.push(a)}onDone(a){this._onDoneFns.push(a)}onDestroy(a){this._onDestroyFns.push(a)}hasStarted(){return this._started}init(){}play(){this.hasStarted()||(this._onStart(),this.triggerMicrotask()),this._started=!0}triggerMicrotask(){Dn(()=>this._onFinish())}_onStart(){this._onStartFns.forEach(a=>a()),this._onStartFns=[]}pause(){}restart(){}finish(){this._onFinish()}destroy(){this._destroyed||(this._destroyed=!0,this.hasStarted()||this._onStart(),this.finish(),this._onDestroyFns.forEach(a=>a()),this._onDestroyFns=[])}reset(){this._started=!1}setPosition(a){this._position=this.totalTime?a*this.totalTime:1}getPosition(){return this.totalTime?this._position/this.totalTime:1}triggerCallback(a){const e="start"==a?this._onStartFns:this._onDoneFns;e.forEach(c=>c()),e.length=0}}class ut{constructor(a){this._onDoneFns=[],this._onStartFns=[],this._finished=!1,this._started=!1,this._destroyed=!1,this._onDestroyFns=[],this.parentPlayer=null,this.totalTime=0,this.players=a;let e=0,c=0,m=0;const v=this.players.length;0==v?Dn(()=>this._onFinish()):this.players.forEach(S=>{S.onDone(()=>{++e==v&&this._onFinish()}),S.onDestroy(()=>{++c==v&&this._onDestroy()}),S.onStart(()=>{++m==v&&this._onStart()})}),this.totalTime=this.players.reduce((S,A)=>Math.max(S,A.totalTime),0)}_onFinish(){this._finished||(this._finished=!0,this._onDoneFns.forEach(a=>a()),this._onDoneFns=[])}init(){this.players.forEach(a=>a.init())}onStart(a){this._onStartFns.push(a)}_onStart(){this.hasStarted()||(this._started=!0,this._onStartFns.forEach(a=>a()),this._onStartFns=[])}onDone(a){this._onDoneFns.push(a)}onDestroy(a){this._onDestroyFns.push(a)}hasStarted(){return this._started}play(){this.parentPlayer||this.init(),this._onStart(),this.players.forEach(a=>a.play())}pause(){this.players.forEach(a=>a.pause())}restart(){this.players.forEach(a=>a.restart())}finish(){this._onFinish(),this.players.forEach(a=>a.finish())}destroy(){this._onDestroy()}_onDestroy(){this._destroyed||(this._destroyed=!0,this._onFinish(),this.players.forEach(a=>a.destroy()),this._onDestroyFns.forEach(a=>a()),this._onDestroyFns=[])}reset(){this.players.forEach(a=>a.reset()),this._destroyed=!1,this._finished=!1,this._started=!1}setPosition(a){const e=a*this.totalTime;this.players.forEach(c=>{const m=c.totalTime?Math.min(1,e/c.totalTime):1;c.setPosition(m)})}getPosition(){const a=this.players.reduce((e,c)=>null===e||c.totalTime>e.totalTime?c:e,null);return null!=a?a.getPosition():0}beforeDestroy(){this.players.forEach(a=>{a.beforeDestroy&&a.beforeDestroy()})}triggerCallback(a){const e="start"==a?this._onStartFns:this._onDoneFns;e.forEach(c=>c()),e.length=0}}const fn=!1;function mt(r){return new d.vHH(3e3,fn)}function xn(){return"undefined"!=typeof window&&void 0!==window.document}function _n(){return"undefined"!=typeof process&&"[object process]"==={}.toString.call(process)}function on(r){switch(r.length){case 0:return new yn;case 1:return r[0];default:return new ut(r)}}function ln(r,a,e,c,m={},v={}){const S=[],A=[];let H=-1,q=null;if(c.forEach(ae=>{const ze=ae.offset,Se=ze==H,Ne=Se&&q||{};Object.keys(ae).forEach(Ee=>{let Ve=Ee,Mn=ae[Ee];if("offset"!==Ee)switch(Ve=a.normalizePropertyName(Ve,S),Mn){case"!":Mn=m[Ee];break;case ye:Mn=v[Ee];break;default:Mn=a.normalizeStyleValue(Ee,Ve,Mn,S)}Ne[Ve]=Mn}),Se||A.push(Ne),q=Ne,H=ze}),S.length)throw function pi(r){return new d.vHH(3502,fn)}();return A}function sn(r,a,e,c){switch(a){case"start":r.onStart(()=>c(e&&zi(e,"start",r)));break;case"done":r.onDone(()=>c(e&&zi(e,"done",r)));break;case"destroy":r.onDestroy(()=>c(e&&zi(e,"destroy",r)))}}function zi(r,a,e){const c=e.totalTime,v=jn(r.element,r.triggerName,r.fromState,r.toState,a||r.phaseName,null==c?r.totalTime:c,!!e.disabled),S=r._data;return null!=S&&(v._data=S),v}function jn(r,a,e,c,m="",v=0,S){return{element:r,triggerName:a,fromState:e,toState:c,phaseName:m,totalTime:v,disabled:!!S}}function Nt(r,a,e){let c;return r instanceof Map?(c=r.get(a),c||r.set(a,c=e)):(c=r[a],c||(c=r[a]=e)),c}function On(r){const a=r.indexOf(":");return[r.substring(1,a),r.substr(a+1)]}let ht=(r,a)=>!1,Wt=(r,a,e)=>[],e1=null;function gt(r){const a=r.parentNode||r.host;return a===e1?null:a}(_n()||"undefined"!=typeof Element)&&(xn()?(e1=(()=>document.documentElement)(),ht=(r,a)=>{for(;a;){if(a===r)return!0;a=gt(a)}return!1}):ht=(r,a)=>r.contains(a),Wt=(r,a,e)=>{if(e)return Array.from(r.querySelectorAll(a));const c=r.querySelector(a);return c?[c]:[]});let m1=null,et=!1;function k1(r){m1||(m1=function ma(){return"undefined"!=typeof document?document.body:null}()||{},et=!!m1.style&&"WebkitAppearance"in m1.style);let a=!0;return m1.style&&!function _1(r){return"ebkit"==r.substring(1,6)}(r)&&(a=r in m1.style,!a&&et&&(a="Webkit"+r.charAt(0).toUpperCase()+r.substr(1)in m1.style)),a}const Ni=ht,Di=Wt;let r1=(()=>{class r{validateStyleProperty(e){return k1(e)}matchesElement(e,c){return!1}containsElement(e,c){return Ni(e,c)}getParentElement(e){return gt(e)}query(e,c,m){return Di(e,c,m)}computeStyle(e,c,m){return m||""}animate(e,c,m,v,S,A=[],H){return new yn(m,v)}}return r.\u0275fac=function(e){return new(e||r)},r.\u0275prov=d.Yz7({token:r,factory:r.\u0275fac}),r})(),Yi=(()=>{class r{}return r.NOOP=new r1,r})();const de="ng-enter",ee="ng-leave",xe="ng-trigger",Re=".ng-trigger",Vn="ng-animating",it=".ng-animating";function wt(r){if("number"==typeof r)return r;const a=r.match(/^(-?[\.\d]+)(m?s)/);return!a||a.length<2?0:Sn(parseFloat(a[1]),a[2])}function Sn(r,a){return"s"===a?1e3*r:r}function Zt(r,a,e){return r.hasOwnProperty("duration")?r:function x1(r,a,e){let m,v=0,S="";if("string"==typeof r){const A=r.match(/^(-?[\.\d]+)(m?s)(?:\s+(-?[\.\d]+)(m?s))?(?:\s+([-a-z]+(?:\(.+?\))?))?$/i);if(null===A)return a.push(mt()),{duration:0,delay:0,easing:""};m=Sn(parseFloat(A[1]),A[2]);const H=A[3];null!=H&&(v=Sn(parseFloat(H),A[4]));const q=A[5];q&&(S=q)}else m=r;if(!e){let A=!1,H=a.length;m<0&&(a.push(function l1(){return new d.vHH(3100,fn)}()),A=!0),v<0&&(a.push(function tn(){return new d.vHH(3101,fn)}()),A=!0),A&&a.splice(H,0,mt())}return{duration:m,delay:v,easing:S}}(r,a,e)}function $t(r,a={}){return Object.keys(r).forEach(e=>{a[e]=r[e]}),a}function M1(r,a,e={}){if(a)for(let c in r)e[c]=r[c];else $t(r,e);return e}function Ei(r,a,e){return e?a+":"+e+";":""}function Ft(r){let a="";for(let e=0;e<r.style.length;e++){const c=r.style.item(e);a+=Ei(0,c,r.style.getPropertyValue(c))}for(const e in r.style)r.style.hasOwnProperty(e)&&!e.startsWith("_")&&(a+=Ei(0,mi(e),r.style[e]));r.setAttribute("style",a)}function mn(r,a,e){r.style&&(Object.keys(a).forEach(c=>{const m=wn(c);e&&!e.hasOwnProperty(c)&&(e[c]=r.style[m]),r.style[m]=a[c]}),_n()&&Ft(r))}function bt(r,a){r.style&&(Object.keys(a).forEach(e=>{const c=wn(e);r.style[c]=""}),_n()&&Ft(r))}function Ai(r){return Array.isArray(r)?1==r.length?r[0]:fe(r):r}const Ze=new RegExp("{{\\s*(.+?)\\s*}}","g");function Gn(r){let a=[];if("string"==typeof r){let e;for(;e=Ze.exec(r);)a.push(e[1]);Ze.lastIndex=0}return a}function yt(r,a,e){const c=r.toString(),m=c.replace(Ze,(v,S)=>{let A=a[S];return a.hasOwnProperty(S)||(e.push(function tt(r){return new d.vHH(3003,fn)}()),A=""),A.toString()});return m==c?r:m}function v1(r){const a=[];let e=r.next();for(;!e.done;)a.push(e.value),e=r.next();return a}const We=/-+([a-z0-9])/g;function wn(r){return r.replace(We,(...a)=>a[1].toUpperCase())}function mi(r){return r.replace(/([a-z])([A-Z])/g,"$1-$2").toLowerCase()}function d1(r,a,e){switch(a.type){case 7:return r.visitTrigger(a,e);case 0:return r.visitState(a,e);case 1:return r.visitTransition(a,e);case 2:return r.visitSequence(a,e);case 3:return r.visitGroup(a,e);case 4:return r.visitAnimate(a,e);case 5:return r.visitKeyframes(a,e);case 6:return r.visitStyle(a,e);case 8:return r.visitReference(a,e);case 9:return r.visitAnimateChild(a,e);case 10:return r.visitAnimateRef(a,e);case 11:return r.visitQuery(a,e);case 12:return r.visitStagger(a,e);default:throw function Un(r){return new d.vHH(3004,fn)}()}}function Qn(r,a){return window.getComputedStyle(r)[a]}function Ht(r,a){const e=[];return"string"==typeof r?r.split(/\s*,\s*/).forEach(c=>function Ar(r,a,e){if(":"==r[0]){const H=function qa(r,a){switch(r){case":enter":return"void => *";case":leave":return"* => void";case":increment":return(e,c)=>parseFloat(c)>parseFloat(e);case":decrement":return(e,c)=>parseFloat(c)<parseFloat(e);default:return a.push(function $i(r){return new d.vHH(3016,fn)}()),"* => *"}}(r,e);if("function"==typeof H)return void a.push(H);r=H}const c=r.match(/^(\*|[-\w]+)\s*(<?[=-]>)\s*(\*|[-\w]+)$/);if(null==c||c.length<4)return e.push(function Lt(r){return new d.vHH(3015,fn)}()),a;const m=c[1],v=c[2],S=c[3];a.push(Da(m,S));"<"==v[0]&&!("*"==m&&"*"==S)&&a.push(Da(S,m))}(c,e,a)):e.push(r),e}const u1=new Set(["true","1"]),I1=new Set(["false","0"]);function Da(r,a){const e=u1.has(r)||I1.has(r),c=u1.has(a)||I1.has(a);return(m,v)=>{let S="*"==r||r==m,A="*"==a||a==v;return!S&&e&&"boolean"==typeof m&&(S=m?u1.has(r):I1.has(r)),!A&&c&&"boolean"==typeof v&&(A=v?u1.has(a):I1.has(a)),S&&A}}const X1=new RegExp("s*:selfs*,?","g");function K1(r,a,e,c){return new hi(r).build(a,e,c)}class hi{constructor(a){this._driver=a}build(a,e,c){const m=new ga(e);this._resetContextStyleTimingState(m);const v=d1(this,Ai(a),m);return m.unsupportedCSSPropertiesFound.size&&m.unsupportedCSSPropertiesFound.keys(),v}_resetContextStyleTimingState(a){a.currentQuerySelector="",a.collectedStyles={},a.collectedStyles[""]={},a.currentTime=0}visitTrigger(a,e){let c=e.queryCount=0,m=e.depCount=0;const v=[],S=[];return"@"==a.name.charAt(0)&&e.errors.push(function De(){return new d.vHH(3006,fn)}()),a.definitions.forEach(A=>{if(this._resetContextStyleTimingState(e),0==A.type){const H=A,q=H.name;q.toString().split(/\s*,\s*/).forEach(ae=>{H.name=ae,v.push(this.visitState(H,e))}),H.name=q}else if(1==A.type){const H=this.visitTransition(A,e);c+=H.queryCount,m+=H.depCount,S.push(H)}else e.errors.push(function ge(){return new d.vHH(3007,fn)}())}),{type:7,name:a.name,states:v,transitions:S,queryCount:c,depCount:m,options:null}}visitState(a,e){const c=this.visitStyle(a.styles,e),m=a.options&&a.options.params||null;if(c.containsDynamicStyles){const v=new Set,S=m||{};c.styles.forEach(A=>{if(Lr(A)){const H=A;Object.keys(H).forEach(q=>{Gn(H[q]).forEach(ae=>{S.hasOwnProperty(ae)||v.add(ae)})})}}),v.size&&(v1(v.values()),e.errors.push(function me(r,a){return new d.vHH(3008,fn)}()))}return{type:0,name:a.name,style:c,options:m?{params:m}:null}}visitTransition(a,e){e.queryCount=0,e.depCount=0;const c=d1(this,Ai(a.animation),e);return{type:1,matchers:Ht(a.expr,e.errors),animation:c,queryCount:e.queryCount,depCount:e.depCount,options:Oi(a.options)}}visitSequence(a,e){return{type:2,steps:a.steps.map(c=>d1(this,c,e)),options:Oi(a.options)}}visitGroup(a,e){const c=e.currentTime;let m=0;const v=a.steps.map(S=>{e.currentTime=c;const A=d1(this,S,e);return m=Math.max(m,e.currentTime),A});return e.currentTime=m,{type:3,steps:v,options:Oi(a.options)}}visitAnimate(a,e){const c=function pr(r,a){let e=null;if(r.hasOwnProperty("duration"))e=r;else if("number"==typeof r)return ea(Zt(r,a).duration,0,"");const c=r;if(c.split(/\s+/).some(v=>"{"==v.charAt(0)&&"{"==v.charAt(1))){const v=ea(0,0,"");return v.dynamic=!0,v.strValue=c,v}return e=e||Zt(c,a),ea(e.duration,e.delay,e.easing)}(a.timings,e.errors);e.currentAnimateTimings=c;let m,v=a.styles?a.styles:le({});if(5==v.type)m=this.visitKeyframes(v,e);else{let S=a.styles,A=!1;if(!S){A=!0;const q={};c.easing&&(q.easing=c.easing),S=le(q)}e.currentTime+=c.duration+c.delay;const H=this.visitStyle(S,e);H.isEmptyStep=A,m=H}return e.currentAnimateTimings=null,{type:4,timings:c,style:m,options:null}}visitStyle(a,e){const c=this._makeStyleAst(a,e);return this._validateStyleAst(c,e),c}_makeStyleAst(a,e){const c=[];Array.isArray(a.styles)?a.styles.forEach(S=>{"string"==typeof S?S==ye?c.push(S):e.errors.push(function Xe(r){return new d.vHH(3002,fn)}()):c.push(S)}):c.push(a.styles);let m=!1,v=null;return c.forEach(S=>{if(Lr(S)){const A=S,H=A.easing;if(H&&(v=H,delete A.easing),!m)for(let q in A)if(A[q].toString().indexOf("{{")>=0){m=!0;break}}}),{type:6,styles:c,easing:v,offset:a.offset,containsDynamicStyles:m,options:null}}_validateStyleAst(a,e){const c=e.currentAnimateTimings;let m=e.currentTime,v=e.currentTime;c&&v>0&&(v-=c.duration+c.delay),a.styles.forEach(S=>{"string"!=typeof S&&Object.keys(S).forEach(A=>{if(!this._driver.validateStyleProperty(A))return delete S[A],void e.unsupportedCSSPropertiesFound.add(A);const H=e.collectedStyles[e.currentQuerySelector],q=H[A];let ae=!0;q&&(v!=m&&v>=q.startTime&&m<=q.endTime&&(e.errors.push(function Ln(r,a,e,c,m){return new d.vHH(3010,fn)}()),ae=!1),v=q.startTime),ae&&(H[A]={startTime:v,endTime:m}),e.options&&function qt(r,a,e){const c=a.params||{},m=Gn(r);m.length&&m.forEach(v=>{c.hasOwnProperty(v)||e.push(function Yn(r){return new d.vHH(3001,fn)}())})}(S[A],e.options,e.errors)})})}visitKeyframes(a,e){const c={type:5,styles:[],options:null};if(!e.currentAnimateTimings)return e.errors.push(function lt(){return new d.vHH(3011,fn)}()),c;let v=0;const S=[];let A=!1,H=!1,q=0;const ae=a.steps.map(hn=>{const bn=this._makeStyleAst(hn,e);let rt=null!=bn.offset?bn.offset:function Aa(r){if("string"==typeof r)return null;let a=null;if(Array.isArray(r))r.forEach(e=>{if(Lr(e)&&e.hasOwnProperty("offset")){const c=e;a=parseFloat(c.offset),delete c.offset}});else if(Lr(r)&&r.hasOwnProperty("offset")){const e=r;a=parseFloat(e.offset),delete e.offset}return a}(bn.styles),nt=0;return null!=rt&&(v++,nt=bn.offset=rt),H=H||nt<0||nt>1,A=A||nt<q,q=nt,S.push(nt),bn});H&&e.errors.push(function Rt(){return new d.vHH(3012,fn)}()),A&&e.errors.push(function Zi(){return new d.vHH(3200,fn)}());const ze=a.steps.length;let Se=0;v>0&&v<ze?e.errors.push(function Bt(){return new d.vHH(3202,fn)}()):0==v&&(Se=1/(ze-1));const Ne=ze-1,Ee=e.currentTime,Ve=e.currentAnimateTimings,Mn=Ve.duration;return ae.forEach((hn,bn)=>{const rt=Se>0?bn==Ne?1:Se*bn:S[bn],nt=rt*Mn;e.currentTime=Ee+Ve.delay+nt,Ve.duration=nt,this._validateStyleAst(hn,e),hn.offset=rt,c.styles.push(hn)}),c}visitReference(a,e){return{type:8,animation:d1(this,Ai(a.animation),e),options:Oi(a.options)}}visitAnimateChild(a,e){return e.depCount++,{type:9,options:Oi(a.options)}}visitAnimateRef(a,e){return{type:10,animation:this.visitReference(a.animation,e),options:Oi(a.options)}}visitQuery(a,e){const c=e.currentQuerySelector,m=a.options||{};e.queryCount++,e.currentQuery=a;const[v,S]=function ar(r){const a=!!r.split(/\s*,\s*/).find(e=>":self"==e);return a&&(r=r.replace(X1,"")),r=r.replace(/@\*/g,Re).replace(/@\w+/g,e=>Re+"-"+e.substr(1)).replace(/:animating/g,it),[r,a]}(a.selector);e.currentQuerySelector=c.length?c+" "+v:v,Nt(e.collectedStyles,e.currentQuerySelector,{});const A=d1(this,Ai(a.animation),e);return e.currentQuery=null,e.currentQuerySelector=c,{type:11,selector:v,limit:m.limit||0,optional:!!m.optional,includeSelf:S,animation:A,originalSelector:a.selector,options:Oi(a.options)}}visitStagger(a,e){e.currentQuery||e.errors.push(function st(){return new d.vHH(3013,fn)}());const c="full"===a.timings?{duration:0,delay:0,easing:"full"}:Zt(a.timings,e.errors,!0);return{type:12,animation:d1(this,Ai(a.animation),e),timings:c,options:null}}}class ga{constructor(a){this.errors=a,this.queryCount=0,this.depCount=0,this.currentTransition=null,this.currentQuery=null,this.currentQuerySelector=null,this.currentAnimateTimings=null,this.currentTime=0,this.collectedStyles={},this.options=null,this.unsupportedCSSPropertiesFound=new Set}}function Lr(r){return!Array.isArray(r)&&"object"==typeof r}function Oi(r){return r?(r=$t(r)).params&&(r.params=function Ba(r){return r?$t(r):null}(r.params)):r={},r}function ea(r,a,e){return{duration:r,delay:a,easing:e}}function va(r,a,e,c,m,v,S=null,A=!1){return{type:1,element:r,keyframes:a,preStyleProps:e,postStyleProps:c,duration:m,delay:v,totalTime:m+v,easing:S,subTimeline:A}}class La{constructor(){this._map=new Map}get(a){return this._map.get(a)||[]}append(a,e){let c=this._map.get(a);c||this._map.set(a,c=[]),c.push(...e)}has(a){return this._map.has(a)}clear(){this._map.clear()}}const mr=new RegExp(":enter","g"),rr=new RegExp(":leave","g");function hr(r,a,e,c,m,v={},S={},A,H,q=[]){return(new Ga).buildKeyframes(r,a,e,c,m,v,S,A,H,q)}class Ga{buildKeyframes(a,e,c,m,v,S,A,H,q,ae=[]){q=q||new La;const ze=new na(a,e,q,m,v,ae,[]);ze.options=H,ze.currentTimeline.setStyles([S],null,ze.errors,H),d1(this,c,ze);const Se=ze.timelines.filter(Ne=>Ne.containsAnimation());if(Object.keys(A).length){let Ne;for(let Ee=Se.length-1;Ee>=0;Ee--){const Ve=Se[Ee];if(Ve.element===e){Ne=Ve;break}}Ne&&!Ne.allowOnlyTimelineStyles()&&Ne.setStyles([A],null,ze.errors,H)}return Se.length?Se.map(Ne=>Ne.buildKeyframes()):[va(e,[],[],[],0,0,"",!1)]}visitTrigger(a,e){}visitState(a,e){}visitTransition(a,e){}visitAnimateChild(a,e){const c=e.subInstructions.get(e.element);if(c){const m=e.createSubContext(a.options),v=e.currentTimeline.currentTime,S=this._visitSubInstructions(c,m,m.options);v!=S&&e.transformIntoNewTimeline(S)}e.previousNode=a}visitAnimateRef(a,e){const c=e.createSubContext(a.options);c.transformIntoNewTimeline(),this.visitReference(a.animation,c),e.transformIntoNewTimeline(c.currentTimeline.currentTime),e.previousNode=a}_visitSubInstructions(a,e,c){let v=e.currentTimeline.currentTime;const S=null!=c.duration?wt(c.duration):null,A=null!=c.delay?wt(c.delay):null;return 0!==S&&a.forEach(H=>{const q=e.appendInstructionToTimeline(H,S,A);v=Math.max(v,q.duration+q.delay)}),v}visitReference(a,e){e.updateOptions(a.options,!0),d1(this,a.animation,e),e.previousNode=a}visitSequence(a,e){const c=e.subContextCount;let m=e;const v=a.options;if(v&&(v.params||v.delay)&&(m=e.createSubContext(v),m.transformIntoNewTimeline(),null!=v.delay)){6==m.previousNode.type&&(m.currentTimeline.snapshotCurrentStyles(),m.previousNode=Vi);const S=wt(v.delay);m.delayNextStep(S)}a.steps.length&&(a.steps.forEach(S=>d1(this,S,m)),m.currentTimeline.applyStylesToKeyframe(),m.subContextCount>c&&m.transformIntoNewTimeline()),e.previousNode=a}visitGroup(a,e){const c=[];let m=e.currentTimeline.currentTime;const v=a.options&&a.options.delay?wt(a.options.delay):0;a.steps.forEach(S=>{const A=e.createSubContext(a.options);v&&A.delayNextStep(v),d1(this,S,A),m=Math.max(m,A.currentTimeline.currentTime),c.push(A.currentTimeline)}),c.forEach(S=>e.currentTimeline.mergeTimelineCollectedStyles(S)),e.transformIntoNewTimeline(m),e.previousNode=a}_visitTiming(a,e){if(a.dynamic){const c=a.strValue;return Zt(e.params?yt(c,e.params,e.errors):c,e.errors)}return{duration:a.duration,delay:a.delay,easing:a.easing}}visitAnimate(a,e){const c=e.currentAnimateTimings=this._visitTiming(a.timings,e),m=e.currentTimeline;c.delay&&(e.incrementTime(c.delay),m.snapshotCurrentStyles());const v=a.style;5==v.type?this.visitKeyframes(v,e):(e.incrementTime(c.duration),this.visitStyle(v,e),m.applyStylesToKeyframe()),e.currentAnimateTimings=null,e.previousNode=a}visitStyle(a,e){const c=e.currentTimeline,m=e.currentAnimateTimings;!m&&c.getCurrentStyleProperties().length&&c.forwardFrame();const v=m&&m.easing||a.easing;a.isEmptyStep?c.applyEmptyStep(v):c.setStyles(a.styles,v,e.errors,e.options),e.previousNode=a}visitKeyframes(a,e){const c=e.currentAnimateTimings,m=e.currentTimeline.duration,v=c.duration,A=e.createSubContext().currentTimeline;A.easing=c.easing,a.styles.forEach(H=>{A.forwardTime((H.offset||0)*v),A.setStyles(H.styles,H.easing,e.errors,e.options),A.applyStylesToKeyframe()}),e.currentTimeline.mergeTimelineCollectedStyles(A),e.transformIntoNewTimeline(m+v),e.previousNode=a}visitQuery(a,e){const c=e.currentTimeline.currentTime,m=a.options||{},v=m.delay?wt(m.delay):0;v&&(6===e.previousNode.type||0==c&&e.currentTimeline.getCurrentStyleProperties().length)&&(e.currentTimeline.snapshotCurrentStyles(),e.previousNode=Vi);let S=c;const A=e.invokeQuery(a.selector,a.originalSelector,a.limit,a.includeSelf,!!m.optional,e.errors);e.currentQueryTotal=A.length;let H=null;A.forEach((q,ae)=>{e.currentQueryIndex=ae;const ze=e.createSubContext(a.options,q);v&&ze.delayNextStep(v),q===e.element&&(H=ze.currentTimeline),d1(this,a.animation,ze),ze.currentTimeline.applyStylesToKeyframe(),S=Math.max(S,ze.currentTimeline.currentTime)}),e.currentQueryIndex=0,e.currentQueryTotal=0,e.transformIntoNewTimeline(S),H&&(e.currentTimeline.mergeTimelineCollectedStyles(H),e.currentTimeline.snapshotCurrentStyles()),e.previousNode=a}visitStagger(a,e){const c=e.parentContext,m=e.currentTimeline,v=a.timings,S=Math.abs(v.duration),A=S*(e.currentQueryTotal-1);let H=S*e.currentQueryIndex;switch(v.duration<0?"reverse":v.easing){case"reverse":H=A-H;break;case"full":H=c.currentStaggerTime}const ae=e.currentTimeline;H&&ae.delayNextStep(H);const ze=ae.currentTime;d1(this,a.animation,e),e.previousNode=a,c.currentStaggerTime=m.currentTime-ze+(m.startTime-c.currentTimeline.startTime)}}const Vi={};class na{constructor(a,e,c,m,v,S,A,H){this._driver=a,this.element=e,this.subInstructions=c,this._enterClassName=m,this._leaveClassName=v,this.errors=S,this.timelines=A,this.parentContext=null,this.currentAnimateTimings=null,this.previousNode=Vi,this.subContextCount=0,this.options={},this.currentQueryIndex=0,this.currentQueryTotal=0,this.currentStaggerTime=0,this.currentTimeline=H||new Ta(this._driver,e,0),A.push(this.currentTimeline)}get params(){return this.options.params}updateOptions(a,e){if(!a)return;const c=a;let m=this.options;null!=c.duration&&(m.duration=wt(c.duration)),null!=c.delay&&(m.delay=wt(c.delay));const v=c.params;if(v){let S=m.params;S||(S=this.options.params={}),Object.keys(v).forEach(A=>{(!e||!S.hasOwnProperty(A))&&(S[A]=yt(v[A],S,this.errors))})}}_copyOptions(){const a={};if(this.options){const e=this.options.params;if(e){const c=a.params={};Object.keys(e).forEach(m=>{c[m]=e[m]})}}return a}createSubContext(a=null,e,c){const m=e||this.element,v=new na(this._driver,m,this.subInstructions,this._enterClassName,this._leaveClassName,this.errors,this.timelines,this.currentTimeline.fork(m,c||0));return v.previousNode=this.previousNode,v.currentAnimateTimings=this.currentAnimateTimings,v.options=this._copyOptions(),v.updateOptions(a),v.currentQueryIndex=this.currentQueryIndex,v.currentQueryTotal=this.currentQueryTotal,v.parentContext=this,this.subContextCount++,v}transformIntoNewTimeline(a){return this.previousNode=Vi,this.currentTimeline=this.currentTimeline.fork(this.element,a),this.timelines.push(this.currentTimeline),this.currentTimeline}appendInstructionToTimeline(a,e,c){const m={duration:null!=e?e:a.duration,delay:this.currentTimeline.currentTime+(null!=c?c:0)+a.delay,easing:""},v=new m2(this._driver,a.element,a.keyframes,a.preStyleProps,a.postStyleProps,m,a.stretchStartingKeyframe);return this.timelines.push(v),m}incrementTime(a){this.currentTimeline.forwardTime(this.currentTimeline.duration+a)}delayNextStep(a){a>0&&this.currentTimeline.delayNextStep(a)}invokeQuery(a,e,c,m,v,S){let A=[];if(m&&A.push(this.element),a.length>0){a=(a=a.replace(mr,"."+this._enterClassName)).replace(rr,"."+this._leaveClassName);let q=this._driver.query(this.element,a,1!=c);0!==c&&(q=c<0?q.slice(q.length+c,q.length):q.slice(0,c)),A.push(...q)}return!v&&0==A.length&&S.push(function zt(r){return new d.vHH(3014,fn)}()),A}}class Ta{constructor(a,e,c,m){this._driver=a,this.element=e,this.startTime=c,this._elementTimelineStylesLookup=m,this.duration=0,this._previousKeyframe={},this._currentKeyframe={},this._keyframes=new Map,this._styleSummary={},this._pendingStyles={},this._backFill={},this._currentEmptyStepKeyframe=null,this._elementTimelineStylesLookup||(this._elementTimelineStylesLookup=new Map),this._localTimelineStyles=Object.create(this._backFill,{}),this._globalTimelineStyles=this._elementTimelineStylesLookup.get(e),this._globalTimelineStyles||(this._globalTimelineStyles=this._localTimelineStyles,this._elementTimelineStylesLookup.set(e,this._localTimelineStyles)),this._loadKeyframe()}containsAnimation(){switch(this._keyframes.size){case 0:return!1;case 1:return this.getCurrentStyleProperties().length>0;default:return!0}}getCurrentStyleProperties(){return Object.keys(this._currentKeyframe)}get currentTime(){return this.startTime+this.duration}delayNextStep(a){const e=1==this._keyframes.size&&Object.keys(this._pendingStyles).length;this.duration||e?(this.forwardTime(this.currentTime+a),e&&this.snapshotCurrentStyles()):this.startTime+=a}fork(a,e){return this.applyStylesToKeyframe(),new Ta(this._driver,a,e||this.currentTime,this._elementTimelineStylesLookup)}_loadKeyframe(){this._currentKeyframe&&(this._previousKeyframe=this._currentKeyframe),this._currentKeyframe=this._keyframes.get(this.duration),this._currentKeyframe||(this._currentKeyframe=Object.create(this._backFill,{}),this._keyframes.set(this.duration,this._currentKeyframe))}forwardFrame(){this.duration+=1,this._loadKeyframe()}forwardTime(a){this.applyStylesToKeyframe(),this.duration=a,this._loadKeyframe()}_updateStyle(a,e){this._localTimelineStyles[a]=e,this._globalTimelineStyles[a]=e,this._styleSummary[a]={time:this.currentTime,value:e}}allowOnlyTimelineStyles(){return this._currentEmptyStepKeyframe!==this._currentKeyframe}applyEmptyStep(a){a&&(this._previousKeyframe.easing=a),Object.keys(this._globalTimelineStyles).forEach(e=>{this._backFill[e]=this._globalTimelineStyles[e]||ye,this._currentKeyframe[e]=ye}),this._currentEmptyStepKeyframe=this._currentKeyframe}setStyles(a,e,c,m){e&&(this._previousKeyframe.easing=e);const v=m&&m.params||{},S=function Jr(r,a){const e={};let c;return r.forEach(m=>{"*"===m?(c=c||Object.keys(a),c.forEach(v=>{e[v]=ye})):M1(m,!1,e)}),e}(a,this._globalTimelineStyles);Object.keys(S).forEach(A=>{const H=yt(S[A],v,c);this._pendingStyles[A]=H,this._localTimelineStyles.hasOwnProperty(A)||(this._backFill[A]=this._globalTimelineStyles.hasOwnProperty(A)?this._globalTimelineStyles[A]:ye),this._updateStyle(A,H)})}applyStylesToKeyframe(){const a=this._pendingStyles,e=Object.keys(a);0!=e.length&&(this._pendingStyles={},e.forEach(c=>{this._currentKeyframe[c]=a[c]}),Object.keys(this._localTimelineStyles).forEach(c=>{this._currentKeyframe.hasOwnProperty(c)||(this._currentKeyframe[c]=this._localTimelineStyles[c])}))}snapshotCurrentStyles(){Object.keys(this._localTimelineStyles).forEach(a=>{const e=this._localTimelineStyles[a];this._pendingStyles[a]=e,this._updateStyle(a,e)})}getFinalKeyframe(){return this._keyframes.get(this.duration)}get properties(){const a=[];for(let e in this._currentKeyframe)a.push(e);return a}mergeTimelineCollectedStyles(a){Object.keys(a._styleSummary).forEach(e=>{const c=this._styleSummary[e],m=a._styleSummary[e];(!c||m.time>c.time)&&this._updateStyle(e,m.value)})}buildKeyframes(){this.applyStylesToKeyframe();const a=new Set,e=new Set,c=1===this._keyframes.size&&0===this.duration;let m=[];this._keyframes.forEach((A,H)=>{const q=M1(A,!0);Object.keys(q).forEach(ae=>{const ze=q[ae];"!"==ze?a.add(ae):ze==ye&&e.add(ae)}),c||(q.offset=H/this.duration),m.push(q)});const v=a.size?v1(a.values()):[],S=e.size?v1(e.values()):[];if(c){const A=m[0],H=$t(A);A.offset=0,H.offset=1,m=[A,H]}return va(this.element,m,v,S,this.duration,this.startTime,this.easing,!1)}}class m2 extends Ta{constructor(a,e,c,m,v,S,A=!1){super(a,e,S.delay),this.keyframes=c,this.preStyleProps=m,this.postStyleProps=v,this._stretchStartingKeyframe=A,this.timings={duration:S.duration,delay:S.delay,easing:S.easing}}containsAnimation(){return this.keyframes.length>1}buildKeyframes(){let a=this.keyframes,{delay:e,duration:c,easing:m}=this.timings;if(this._stretchStartingKeyframe&&e){const v=[],S=c+e,A=e/S,H=M1(a[0],!1);H.offset=0,v.push(H);const q=M1(a[0],!1);q.offset=w1(A),v.push(q);const ae=a.length-1;for(let ze=1;ze<=ae;ze++){let Se=M1(a[ze],!1);Se.offset=w1((e+Se.offset*c)/S),v.push(Se)}c=S,e=0,m="",a=v}return va(this.element,a,this.preStyleProps,this.postStyleProps,c,e,m,!0)}}function w1(r,a=3){const e=Math.pow(10,a-1);return Math.round(r*e)/e}class Ti{}class ji extends Ti{normalizePropertyName(a,e){return wn(a)}normalizeStyleValue(a,e,c,m){let v="";const S=c.toString().trim();if(ai[e]&&0!==c&&"0"!==c)if("number"==typeof c)v="px";else{const A=c.match(/^[+-]?[\d\.]+([a-z]*)$/);A&&0==A[1].length&&m.push(function Le(r,a){return new d.vHH(3005,fn)}())}return S+v}}const ai=(()=>function Hi(r){const a={};return r.forEach(e=>a[e]=!0),a}("width,height,minWidth,minHeight,maxWidth,maxHeight,left,top,bottom,right,fontSize,outlineWidth,outlineOffset,paddingTop,paddingLeft,paddingBottom,paddingRight,marginTop,marginLeft,marginBottom,marginRight,borderRadius,borderWidth,borderTopWidth,borderLeftWidth,borderRightWidth,borderBottomWidth,textIndent,perspective".split(",")))();function O1(r,a,e,c,m,v,S,A,H,q,ae,ze,Se){return{type:0,element:r,triggerName:a,isRemovalTransition:m,fromState:e,fromStyles:v,toState:c,toStyles:S,timelines:A,queriedElements:H,preStyleProps:q,postStyleProps:ae,totalTime:ze,errors:Se}}const Wa={};class ka{constructor(a,e,c){this._triggerName=a,this.ast=e,this._stateStyles=c}match(a,e,c,m){return function ei(r,a,e,c,m){return r.some(v=>v(a,e,c,m))}(this.ast.matchers,a,e,c,m)}buildStyles(a,e,c){const m=this._stateStyles["*"],v=this._stateStyles[a],S=m?m.buildStyles(e,c):{};return v?v.buildStyles(e,c):S}build(a,e,c,m,v,S,A,H,q,ae){const ze=[],Se=this.ast.options&&this.ast.options.params||Wa,Ee=this.buildStyles(c,A&&A.params||Wa,ze),Ve=H&&H.params||Wa,Mn=this.buildStyles(m,Ve,ze),hn=new Set,bn=new Map,rt=new Map,nt="void"===m,p1={params:Object.assign(Object.assign({},Se),Ve)},Qt=ae?[]:hr(a,e,this.ast.animation,v,S,Ee,Mn,p1,q,ze);let Vt=0;if(Qt.forEach(ui=>{Vt=Math.max(ui.duration+ui.delay,Vt)}),ze.length)return O1(e,this._triggerName,c,m,nt,Ee,Mn,[],[],bn,rt,Vt,ze);Qt.forEach(ui=>{const fi=ui.element,Ii=Nt(bn,fi,{});ui.preStyleProps.forEach(Fa=>Ii[Fa]=!0);const Yr=Nt(rt,fi,{});ui.postStyleProps.forEach(Fa=>Yr[Fa]=!0),fi!==e&&hn.add(fi)});const Kt=v1(hn.values());return O1(e,this._triggerName,c,m,nt,Ee,Mn,Qt,Kt,bn,rt,Vt)}}class Za{constructor(a,e,c){this.styles=a,this.defaultParams=e,this.normalizer=c}buildStyles(a,e){const c={},m=$t(this.defaultParams);return Object.keys(a).forEach(v=>{const S=a[v];null!=S&&(m[v]=S)}),this.styles.styles.forEach(v=>{if("string"!=typeof v){const S=v;Object.keys(S).forEach(A=>{let H=S[A];H.length>1&&(H=yt(H,m,e));const q=this.normalizer.normalizePropertyName(A,e);H=this.normalizer.normalizeStyleValue(A,q,H,e),c[q]=H})}}),c}}class Pa{constructor(a,e,c){this.name=a,this.ast=e,this._normalizer=c,this.transitionFactories=[],this.states={},e.states.forEach(m=>{this.states[m.name]=new Za(m.style,m.options&&m.options.params||{},c)}),ya(this.states,"true","1"),ya(this.states,"false","0"),e.transitions.forEach(m=>{this.transitionFactories.push(new ka(a,m,this.states))}),this.fallbackTransition=function jr(r,a,e){return new ka(r,{type:1,animation:{type:2,steps:[],options:null},matchers:[(S,A)=>!0],options:null,queryCount:0,depCount:0},a)}(a,this.states)}get containsQueries(){return this.ast.queryCount>0}matchTransition(a,e,c,m){return this.transitionFactories.find(S=>S.match(a,e,c,m))||null}matchStyles(a,e,c){return this.fallbackTransition.buildStyles(a,e,c)}}function ya(r,a,e){r.hasOwnProperty(a)?r.hasOwnProperty(e)||(r[e]=r[a]):r.hasOwnProperty(e)&&(r[a]=r[e])}const j=new La;class U{constructor(a,e,c){this.bodyNode=a,this._driver=e,this._normalizer=c,this._animations={},this._playersById={},this.players=[]}register(a,e){const c=[],v=K1(this._driver,e,c,[]);if(c.length)throw function Xi(r){return new d.vHH(3503,fn)}();this._animations[a]=v}_buildPlayer(a,e,c){const m=a.element,v=ln(0,this._normalizer,0,a.keyframes,e,c);return this._driver.animate(m,v,a.duration,a.delay,a.easing,[],!0)}create(a,e,c={}){const m=[],v=this._animations[a];let S;const A=new Map;if(v?(S=hr(this._driver,e,v,de,ee,{},{},c,j,m),S.forEach(ae=>{const ze=Nt(A,ae.element,{});ae.postStyleProps.forEach(Se=>ze[Se]=null)})):(m.push(function j1(){return new d.vHH(3300,fn)}()),S=[]),m.length)throw function Gt(r){return new d.vHH(3504,fn)}();A.forEach((ae,ze)=>{Object.keys(ae).forEach(Se=>{ae[Se]=this._driver.computeStyle(ze,Se,ye)})});const q=on(S.map(ae=>{const ze=A.get(ae.element);return this._buildPlayer(ae,{},ze)}));return this._playersById[a]=q,q.onDestroy(()=>this.destroy(a)),this.players.push(q),q}destroy(a){const e=this._getPlayer(a);e.destroy(),delete this._playersById[a];const c=this.players.indexOf(e);c>=0&&this.players.splice(c,1)}_getPlayer(a){const e=this._playersById[a];if(!e)throw function a1(r){return new d.vHH(3301,fn)}();return e}listen(a,e,c,m){const v=jn(e,"","","");return sn(this._getPlayer(a),c,v,m),()=>{}}command(a,e,c,m){if("register"==c)return void this.register(a,m[0]);if("create"==c)return void this.create(a,e,m[0]||{});const v=this._getPlayer(a);switch(c){case"play":v.play();break;case"pause":v.pause();break;case"reset":v.reset();break;case"restart":v.restart();break;case"finish":v.finish();break;case"init":v.init();break;case"setPosition":v.setPosition(parseFloat(m[0]));break;case"destroy":this.destroy(a)}}}const k="ng-animate-queued",re="ng-animate-disabled",Pt=[],s1={namespaceId:"",setForRemoval:!1,setForMove:!1,hasAnimation:!1,removedBeforeQueried:!1},Dt={namespaceId:"",setForMove:!1,setForRemoval:!1,hasAnimation:!1,removedBeforeQueried:!0},kn="__ng_removed";class c1{constructor(a,e=""){this.namespaceId=e;const c=a&&a.hasOwnProperty("value");if(this.value=function D(r){return null!=r?r:null}(c?a.value:a),c){const v=$t(a);delete v.value,this.options=v}else this.options={};this.options.params||(this.options.params={})}get params(){return this.options.params}absorbOptions(a){const e=a.params;if(e){const c=this.options.params;Object.keys(e).forEach(m=>{null==c[m]&&(c[m]=e[m])})}}}const Jn="void",h1=new c1(Jn);class V1{constructor(a,e,c){this.id=a,this.hostElement=e,this._engine=c,this.players=[],this._triggers={},this._queue=[],this._elementListeners=new Map,this._hostClassName="ng-tns-"+a,U1(e,this._hostClassName)}listen(a,e,c,m){if(!this._triggers.hasOwnProperty(e))throw function q1(r,a){return new d.vHH(3302,fn)}();if(null==c||0==c.length)throw function xt(r){return new d.vHH(3303,fn)}();if(!function je(r){return"start"==r||"done"==r}(c))throw function Mi(r,a){return new d.vHH(3400,fn)}();const v=Nt(this._elementListeners,a,[]),S={name:e,phase:c,callback:m};v.push(S);const A=Nt(this._engine.statesByElement,a,{});return A.hasOwnProperty(e)||(U1(a,xe),U1(a,xe+"-"+e),A[e]=h1),()=>{this._engine.afterFlush(()=>{const H=v.indexOf(S);H>=0&&v.splice(H,1),this._triggers[e]||delete A[e]})}}register(a,e){return!this._triggers[a]&&(this._triggers[a]=e,!0)}_getTrigger(a){const e=this._triggers[a];if(!e)throw function wa(r){return new d.vHH(3401,fn)}();return e}trigger(a,e,c,m=!0){const v=this._getTrigger(e),S=new P(this.id,e,a);let A=this._engine.statesByElement.get(a);A||(U1(a,xe),U1(a,xe+"-"+e),this._engine.statesByElement.set(a,A={}));let H=A[e];const q=new c1(c,this.id);if(!(c&&c.hasOwnProperty("value"))&&H&&q.absorbOptions(H.options),A[e]=q,H||(H=h1),q.value!==Jn&&H.value===q.value){if(!function Ye(r,a){const e=Object.keys(r),c=Object.keys(a);if(e.length!=c.length)return!1;for(let m=0;m<e.length;m++){const v=e[m];if(!a.hasOwnProperty(v)||r[v]!==a[v])return!1}return!0}(H.params,q.params)){const Ve=[],Mn=v.matchStyles(H.value,H.params,Ve),hn=v.matchStyles(q.value,q.params,Ve);Ve.length?this._engine.reportError(Ve):this._engine.afterFlush(()=>{bt(a,Mn),mn(a,hn)})}return}const Se=Nt(this._engine.playersByElement,a,[]);Se.forEach(Ve=>{Ve.namespaceId==this.id&&Ve.triggerName==e&&Ve.queued&&Ve.destroy()});let Ne=v.matchTransition(H.value,q.value,a,q.params),Ee=!1;if(!Ne){if(!m)return;Ne=v.fallbackTransition,Ee=!0}return this._engine.totalQueuedPlayers++,this._queue.push({element:a,triggerName:e,transition:Ne,fromState:H,toState:q,player:S,isFallbackTransition:Ee}),Ee||(U1(a,k),S.onStart(()=>{Ri(a,k)})),S.onDone(()=>{let Ve=this.players.indexOf(S);Ve>=0&&this.players.splice(Ve,1);const Mn=this._engine.playersByElement.get(a);if(Mn){let hn=Mn.indexOf(S);hn>=0&&Mn.splice(hn,1)}}),this.players.push(S),Se.push(S),S}deregister(a){delete this._triggers[a],this._engine.statesByElement.forEach((e,c)=>{delete e[a]}),this._elementListeners.forEach((e,c)=>{this._elementListeners.set(c,e.filter(m=>m.name!=a))})}clearElementCache(a){this._engine.statesByElement.delete(a),this._elementListeners.delete(a);const e=this._engine.playersByElement.get(a);e&&(e.forEach(c=>c.destroy()),this._engine.playersByElement.delete(a))}_signalRemovalForInnerTriggers(a,e){const c=this._engine.driver.query(a,Re,!0);c.forEach(m=>{if(m[kn])return;const v=this._engine.fetchNamespacesByElement(m);v.size?v.forEach(S=>S.triggerLeaveAnimation(m,e,!1,!0)):this.clearElementCache(m)}),this._engine.afterFlushAnimationsDone(()=>c.forEach(m=>this.clearElementCache(m)))}triggerLeaveAnimation(a,e,c,m){const v=this._engine.statesByElement.get(a),S=new Map;if(v){const A=[];if(Object.keys(v).forEach(H=>{if(S.set(H,v[H].value),this._triggers[H]){const q=this.trigger(a,H,Jn,m);q&&A.push(q)}}),A.length)return this._engine.markElementAsRemoved(this.id,a,!0,e,S),c&&on(A).onDone(()=>this._engine.processLeaveNode(a)),!0}return!1}prepareLeaveAnimationListeners(a){const e=this._elementListeners.get(a),c=this._engine.statesByElement.get(a);if(e&&c){const m=new Set;e.forEach(v=>{const S=v.name;if(m.has(S))return;m.add(S);const H=this._triggers[S].fallbackTransition,q=c[S]||h1,ae=new c1(Jn),ze=new P(this.id,S,a);this._engine.totalQueuedPlayers++,this._queue.push({element:a,triggerName:S,transition:H,fromState:q,toState:ae,player:ze,isFallbackTransition:!0})})}}removeNode(a,e){const c=this._engine;if(a.childElementCount&&this._signalRemovalForInnerTriggers(a,e),this.triggerLeaveAnimation(a,e,!0))return;let m=!1;if(c.totalAnimations){const v=c.players.length?c.playersByQueriedElement.get(a):[];if(v&&v.length)m=!0;else{let S=a;for(;S=S.parentNode;)if(c.statesByElement.get(S)){m=!0;break}}}if(this.prepareLeaveAnimationListeners(a),m)c.markElementAsRemoved(this.id,a,!1,e);else{const v=a[kn];(!v||v===s1)&&(c.afterFlush(()=>this.clearElementCache(a)),c.destroyInnerAnimations(a),c._onRemovalComplete(a,e))}}insertNode(a,e){U1(a,this._hostClassName)}drainQueuedTransitions(a){const e=[];return this._queue.forEach(c=>{const m=c.player;if(m.destroyed)return;const v=c.element,S=this._elementListeners.get(v);S&&S.forEach(A=>{if(A.name==c.triggerName){const H=jn(v,c.triggerName,c.fromState.value,c.toState.value);H._data=a,sn(c.player,A.phase,H,A.callback)}}),m.markedForDestroy?this._engine.afterFlush(()=>{m.destroy()}):e.push(c)}),this._queue=[],e.sort((c,m)=>{const v=c.transition.ast.depCount,S=m.transition.ast.depCount;return 0==v||0==S?v-S:this._engine.driver.containsElement(c.element,m.element)?1:-1})}destroy(a){this.players.forEach(e=>e.destroy()),this._signalRemovalForInnerTriggers(this.hostElement,a)}elementContainsData(a){let e=!1;return this._elementListeners.has(a)&&(e=!0),e=!!this._queue.find(c=>c.element===a)||e,e}}class H1{constructor(a,e,c){this.bodyNode=a,this.driver=e,this._normalizer=c,this.players=[],this.newHostElements=new Map,this.playersByElement=new Map,this.playersByQueriedElement=new Map,this.statesByElement=new Map,this.disabledNodes=new Set,this.totalAnimations=0,this.totalQueuedPlayers=0,this._namespaceLookup={},this._namespaceList=[],this._flushFns=[],this._whenQuietFns=[],this.namespacesByHostElement=new Map,this.collectedEnterElements=[],this.collectedLeaveElements=[],this.onRemovalComplete=(m,v)=>{}}_onRemovalComplete(a,e){this.onRemovalComplete(a,e)}get queuedPlayers(){const a=[];return this._namespaceList.forEach(e=>{e.players.forEach(c=>{c.queued&&a.push(c)})}),a}createNamespace(a,e){const c=new V1(a,e,this);return this.bodyNode&&this.driver.containsElement(this.bodyNode,e)?this._balanceNamespaceList(c,e):(this.newHostElements.set(e,c),this.collectEnterElement(e)),this._namespaceLookup[a]=c}_balanceNamespaceList(a,e){const c=this._namespaceList,m=this.namespacesByHostElement,v=c.length-1;if(v>=0){let S=!1;if(void 0!==this.driver.getParentElement){let A=this.driver.getParentElement(e);for(;A;){const H=m.get(A);if(H){const q=c.indexOf(H);c.splice(q+1,0,a),S=!0;break}A=this.driver.getParentElement(A)}}else for(let A=v;A>=0;A--)if(this.driver.containsElement(c[A].hostElement,e)){c.splice(A+1,0,a),S=!0;break}S||c.unshift(a)}else c.push(a);return m.set(e,a),a}register(a,e){let c=this._namespaceLookup[a];return c||(c=this.createNamespace(a,e)),c}registerTrigger(a,e,c){let m=this._namespaceLookup[a];m&&m.register(e,c)&&this.totalAnimations++}destroy(a,e){if(!a)return;const c=this._fetchNamespace(a);this.afterFlush(()=>{this.namespacesByHostElement.delete(c.hostElement),delete this._namespaceLookup[a];const m=this._namespaceList.indexOf(c);m>=0&&this._namespaceList.splice(m,1)}),this.afterFlushAnimationsDone(()=>c.destroy(e))}_fetchNamespace(a){return this._namespaceLookup[a]}fetchNamespacesByElement(a){const e=new Set,c=this.statesByElement.get(a);if(c){const m=Object.keys(c);for(let v=0;v<m.length;v++){const S=c[m[v]].namespaceId;if(S){const A=this._fetchNamespace(S);A&&e.add(A)}}}return e}trigger(a,e,c,m){if(W(e)){const v=this._fetchNamespace(a);if(v)return v.trigger(e,c,m),!0}return!1}insertNode(a,e,c,m){if(!W(e))return;const v=e[kn];if(v&&v.setForRemoval){v.setForRemoval=!1,v.setForMove=!0;const S=this.collectedLeaveElements.indexOf(e);S>=0&&this.collectedLeaveElements.splice(S,1)}if(a){const S=this._fetchNamespace(a);S&&S.insertNode(e,c)}m&&this.collectEnterElement(e)}collectEnterElement(a){this.collectedEnterElements.push(a)}markElementAsDisabled(a,e){e?this.disabledNodes.has(a)||(this.disabledNodes.add(a),U1(a,re)):this.disabledNodes.has(a)&&(this.disabledNodes.delete(a),Ri(a,re))}removeNode(a,e,c,m){if(W(e)){const v=a?this._fetchNamespace(a):null;if(v?v.removeNode(e,m):this.markElementAsRemoved(a,e,!1,m),c){const S=this.namespacesByHostElement.get(e);S&&S.id!==a&&S.removeNode(e,m)}}else this._onRemovalComplete(e,m)}markElementAsRemoved(a,e,c,m,v){this.collectedLeaveElements.push(e),e[kn]={namespaceId:a,setForRemoval:m,hasAnimation:c,removedBeforeQueried:!1,previousTriggersValues:v}}listen(a,e,c,m,v){return W(e)?this._fetchNamespace(a).listen(e,c,m,v):()=>{}}_buildInstruction(a,e,c,m,v){return a.transition.build(this.driver,a.element,a.fromState.value,a.toState.value,c,m,a.fromState.options,a.toState.options,e,v)}destroyInnerAnimations(a){let e=this.driver.query(a,Re,!0);e.forEach(c=>this.destroyActiveAnimationsForElement(c)),0!=this.playersByQueriedElement.size&&(e=this.driver.query(a,it,!0),e.forEach(c=>this.finishActiveQueriedAnimationOnElement(c)))}destroyActiveAnimationsForElement(a){const e=this.playersByElement.get(a);e&&e.forEach(c=>{c.queued?c.markedForDestroy=!0:c.destroy()})}finishActiveQueriedAnimationOnElement(a){const e=this.playersByQueriedElement.get(a);e&&e.forEach(c=>c.finish())}whenRenderingDone(){return new Promise(a=>{if(this.players.length)return on(this.players).onDone(()=>a());a()})}processLeaveNode(a){var e;const c=a[kn];if(c&&c.setForRemoval){if(a[kn]=s1,c.namespaceId){this.destroyInnerAnimations(a);const m=this._fetchNamespace(c.namespaceId);m&&m.clearElementCache(a)}this._onRemovalComplete(a,c.setForRemoval)}(null===(e=a.classList)||void 0===e?void 0:e.contains(re))&&this.markElementAsDisabled(a,!1),this.driver.query(a,".ng-animate-disabled",!0).forEach(m=>{this.markElementAsDisabled(m,!1)})}flush(a=-1){let e=[];if(this.newHostElements.size&&(this.newHostElements.forEach((c,m)=>this._balanceNamespaceList(c,m)),this.newHostElements.clear()),this.totalAnimations&&this.collectedEnterElements.length)for(let c=0;c<this.collectedEnterElements.length;c++)U1(this.collectedEnterElements[c],"ng-star-inserted");if(this._namespaceList.length&&(this.totalQueuedPlayers||this.collectedLeaveElements.length)){const c=[];try{e=this._flushAnimations(c,a)}finally{for(let m=0;m<c.length;m++)c[m]()}}else for(let c=0;c<this.collectedLeaveElements.length;c++)this.processLeaveNode(this.collectedLeaveElements[c]);if(this.totalQueuedPlayers=0,this.collectedEnterElements.length=0,this.collectedLeaveElements.length=0,this._flushFns.forEach(c=>c()),this._flushFns=[],this._whenQuietFns.length){const c=this._whenQuietFns;this._whenQuietFns=[],e.length?on(e).onDone(()=>{c.forEach(m=>m())}):c.forEach(m=>m())}}reportError(a){throw function $n(r){return new d.vHH(3402,fn)}()}_flushAnimations(a,e){const c=new La,m=[],v=new Map,S=[],A=new Map,H=new Map,q=new Map,ae=new Set;this.disabledNodes.forEach(Tn=>{ae.add(Tn);const Zn=this.driver.query(Tn,".ng-animate-queued",!0);for(let pt=0;pt<Zn.length;pt++)ae.add(Zn[pt])});const ze=this.bodyNode,Se=Array.from(this.statesByElement.keys()),Ne=ri(Se,this.collectedEnterElements),Ee=new Map;let Ve=0;Ne.forEach((Tn,Zn)=>{const pt=de+Ve++;Ee.set(Zn,pt),Tn.forEach(Jt=>U1(Jt,pt))});const Mn=[],hn=new Set,bn=new Set;for(let Tn=0;Tn<this.collectedLeaveElements.length;Tn++){const Zn=this.collectedLeaveElements[Tn],pt=Zn[kn];pt&&pt.setForRemoval&&(Mn.push(Zn),hn.add(Zn),pt.hasAnimation?this.driver.query(Zn,".ng-star-inserted",!0).forEach(Jt=>hn.add(Jt)):bn.add(Zn))}const rt=new Map,nt=ri(Se,Array.from(hn));nt.forEach((Tn,Zn)=>{const pt=ee+Ve++;rt.set(Zn,pt),Tn.forEach(Jt=>U1(Jt,pt))}),a.push(()=>{Ne.forEach((Tn,Zn)=>{const pt=Ee.get(Zn);Tn.forEach(Jt=>Ri(Jt,pt))}),nt.forEach((Tn,Zn)=>{const pt=rt.get(Zn);Tn.forEach(Jt=>Ri(Jt,pt))}),Mn.forEach(Tn=>{this.processLeaveNode(Tn)})});const p1=[],Qt=[];for(let Tn=this._namespaceList.length-1;Tn>=0;Tn--)this._namespaceList[Tn].drainQueuedTransitions(e).forEach(pt=>{const Jt=pt.player,pa=pt.element;if(p1.push(Jt),this.collectedEnterElements.length){const ir=pa[kn];if(ir&&ir.setForMove){if(ir.previousTriggersValues&&ir.previousTriggersValues.has(pt.triggerName)){const A2=ir.previousTriggersValues.get(pt.triggerName),Xo=this.statesByElement.get(pt.element);Xo&&Xo[pt.triggerName]&&(Xo[pt.triggerName].value=A2)}return void Jt.destroy()}}const $2=!ze||!this.driver.containsElement(ze,pa),fr=rt.get(pa),_o=Ee.get(pa),$1=this._buildInstruction(pt,c,_o,fr,$2);if($1.errors&&$1.errors.length)return void Qt.push($1);if($2)return Jt.onStart(()=>bt(pa,$1.fromStyles)),Jt.onDestroy(()=>mn(pa,$1.toStyles)),void m.push(Jt);if(pt.isFallbackTransition)return Jt.onStart(()=>bt(pa,$1.fromStyles)),Jt.onDestroy(()=>mn(pa,$1.toStyles)),void m.push(Jt);const Ps=[];$1.timelines.forEach(ir=>{ir.stretchStartingKeyframe=!0,this.disabledNodes.has(ir.element)||Ps.push(ir)}),$1.timelines=Ps,c.append(pa,$1.timelines),S.push({instruction:$1,player:Jt,element:pa}),$1.queriedElements.forEach(ir=>Nt(A,ir,[]).push(Jt)),$1.preStyleProps.forEach((ir,A2)=>{const Xo=Object.keys(ir);if(Xo.length){let $c=H.get(A2);$c||H.set(A2,$c=new Set),Xo.forEach(El=>$c.add(El))}}),$1.postStyleProps.forEach((ir,A2)=>{const Xo=Object.keys(ir);let $c=q.get(A2);$c||q.set(A2,$c=new Set),Xo.forEach(El=>$c.add(El))})});if(Qt.length){const Tn=[];Qt.forEach(Zn=>{Tn.push(function Rn(r,a){return new d.vHH(3505,fn)}())}),p1.forEach(Zn=>Zn.destroy()),this.reportError(Tn)}const Vt=new Map,Kt=new Map;S.forEach(Tn=>{const Zn=Tn.element;c.has(Zn)&&(Kt.set(Zn,Zn),this._beforeAnimationBuild(Tn.player.namespaceId,Tn.instruction,Vt))}),m.forEach(Tn=>{const Zn=Tn.element;this._getPreviousPlayers(Zn,!1,Tn.namespaceId,Tn.triggerName,null).forEach(Jt=>{Nt(Vt,Zn,[]).push(Jt),Jt.destroy()})});const ui=Mn.filter(Tn=>Ct(Tn,H,q)),fi=new Map;A1(fi,this.driver,bn,q,ye).forEach(Tn=>{Ct(Tn,H,q)&&ui.push(Tn)});const Yr=new Map;Ne.forEach((Tn,Zn)=>{A1(Yr,this.driver,new Set(Tn),H,"!")}),ui.forEach(Tn=>{const Zn=fi.get(Tn),pt=Yr.get(Tn);fi.set(Tn,Object.assign(Object.assign({},Zn),pt))});const Fa=[],l3=[],d3={};S.forEach(Tn=>{const{element:Zn,player:pt,instruction:Jt}=Tn;if(c.has(Zn)){if(ae.has(Zn))return pt.onDestroy(()=>mn(Zn,Jt.toStyles)),pt.disabled=!0,pt.overrideTotalTime(Jt.totalTime),void m.push(pt);let pa=d3;if(Kt.size>1){let fr=Zn;const _o=[];for(;fr=fr.parentNode;){const $1=Kt.get(fr);if($1){pa=$1;break}_o.push(fr)}_o.forEach($1=>Kt.set($1,pa))}const $2=this._buildAnimation(pt.namespaceId,Jt,Vt,v,Yr,fi);if(pt.setRealPlayer($2),pa===d3)Fa.push(pt);else{const fr=this.playersByElement.get(pa);fr&&fr.length&&(pt.parentPlayer=on(fr)),m.push(pt)}}else bt(Zn,Jt.fromStyles),pt.onDestroy(()=>mn(Zn,Jt.toStyles)),l3.push(pt),ae.has(Zn)&&m.push(pt)}),l3.forEach(Tn=>{const Zn=v.get(Tn.element);if(Zn&&Zn.length){const pt=on(Zn);Tn.setRealPlayer(pt)}}),m.forEach(Tn=>{Tn.parentPlayer?Tn.syncPlayerEvents(Tn.parentPlayer):Tn.destroy()});for(let Tn=0;Tn<Mn.length;Tn++){const Zn=Mn[Tn],pt=Zn[kn];if(Ri(Zn,ee),pt&&pt.hasAnimation)continue;let Jt=[];if(A.size){let $2=A.get(Zn);$2&&$2.length&&Jt.push(...$2);let fr=this.driver.query(Zn,it,!0);for(let _o=0;_o<fr.length;_o++){let $1=A.get(fr[_o]);$1&&$1.length&&Jt.push(...$1)}}const pa=Jt.filter($2=>!$2.destroyed);pa.length?ta(this,Zn,pa):this.processLeaveNode(Zn)}return Mn.length=0,Fa.forEach(Tn=>{this.players.push(Tn),Tn.onDone(()=>{Tn.destroy();const Zn=this.players.indexOf(Tn);this.players.splice(Zn,1)}),Tn.play()}),Fa}elementContainsData(a,e){let c=!1;const m=e[kn];return m&&m.setForRemoval&&(c=!0),this.playersByElement.has(e)&&(c=!0),this.playersByQueriedElement.has(e)&&(c=!0),this.statesByElement.has(e)&&(c=!0),this._fetchNamespace(a).elementContainsData(e)||c}afterFlush(a){this._flushFns.push(a)}afterFlushAnimationsDone(a){this._whenQuietFns.push(a)}_getPreviousPlayers(a,e,c,m,v){let S=[];if(e){const A=this.playersByQueriedElement.get(a);A&&(S=A)}else{const A=this.playersByElement.get(a);if(A){const H=!v||v==Jn;A.forEach(q=>{q.queued||!H&&q.triggerName!=m||S.push(q)})}}return(c||m)&&(S=S.filter(A=>!(c&&c!=A.namespaceId||m&&m!=A.triggerName))),S}_beforeAnimationBuild(a,e,c){const v=e.element,S=e.isRemovalTransition?void 0:a,A=e.isRemovalTransition?void 0:e.triggerName;for(const H of e.timelines){const q=H.element,ae=q!==v,ze=Nt(c,q,[]);this._getPreviousPlayers(q,ae,S,A,e.toState).forEach(Ne=>{const Ee=Ne.getRealPlayer();Ee.beforeDestroy&&Ee.beforeDestroy(),Ne.destroy(),ze.push(Ne)})}bt(v,e.fromStyles)}_buildAnimation(a,e,c,m,v,S){const A=e.triggerName,H=e.element,q=[],ae=new Set,ze=new Set,Se=e.timelines.map(Ee=>{const Ve=Ee.element;ae.add(Ve);const Mn=Ve[kn];if(Mn&&Mn.removedBeforeQueried)return new yn(Ee.duration,Ee.delay);const hn=Ve!==H,bn=function ia(r){const a=[];return kr(r,a),a}((c.get(Ve)||Pt).map(Vt=>Vt.getRealPlayer())).filter(Vt=>!!Vt.element&&Vt.element===Ve),rt=v.get(Ve),nt=S.get(Ve),p1=ln(0,this._normalizer,0,Ee.keyframes,rt,nt),Qt=this._buildPlayer(Ee,p1,bn);if(Ee.subTimeline&&m&&ze.add(Ve),hn){const Vt=new P(a,A,Ve);Vt.setRealPlayer(Qt),q.push(Vt)}return Qt});q.forEach(Ee=>{Nt(this.playersByQueriedElement,Ee.element,[]).push(Ee),Ee.onDone(()=>function L(r,a,e){let c;if(r instanceof Map){if(c=r.get(a),c){if(c.length){const m=c.indexOf(e);c.splice(m,1)}0==c.length&&r.delete(a)}}else if(c=r[a],c){if(c.length){const m=c.indexOf(e);c.splice(m,1)}0==c.length&&delete r[a]}return c}(this.playersByQueriedElement,Ee.element,Ee))}),ae.forEach(Ee=>U1(Ee,Vn));const Ne=on(Se);return Ne.onDestroy(()=>{ae.forEach(Ee=>Ri(Ee,Vn)),mn(H,e.toStyles)}),ze.forEach(Ee=>{Nt(m,Ee,[]).push(Ne)}),Ne}_buildPlayer(a,e,c){return e.length>0?this.driver.animate(a.element,e,a.duration,a.delay,a.easing,c):new yn(a.duration,a.delay)}}class P{constructor(a,e,c){this.namespaceId=a,this.triggerName=e,this.element=c,this._player=new yn,this._containsRealPlayer=!1,this._queuedCallbacks={},this.destroyed=!1,this.markedForDestroy=!1,this.disabled=!1,this.queued=!0,this.totalTime=0}setRealPlayer(a){this._containsRealPlayer||(this._player=a,Object.keys(this._queuedCallbacks).forEach(e=>{this._queuedCallbacks[e].forEach(c=>sn(a,e,void 0,c))}),this._queuedCallbacks={},this._containsRealPlayer=!0,this.overrideTotalTime(a.totalTime),this.queued=!1)}getRealPlayer(){return this._player}overrideTotalTime(a){this.totalTime=a}syncPlayerEvents(a){const e=this._player;e.triggerCallback&&a.onStart(()=>e.triggerCallback("start")),a.onDone(()=>this.finish()),a.onDestroy(()=>this.destroy())}_queueEvent(a,e){Nt(this._queuedCallbacks,a,[]).push(e)}onDone(a){this.queued&&this._queueEvent("done",a),this._player.onDone(a)}onStart(a){this.queued&&this._queueEvent("start",a),this._player.onStart(a)}onDestroy(a){this.queued&&this._queueEvent("destroy",a),this._player.onDestroy(a)}init(){this._player.init()}hasStarted(){return!this.queued&&this._player.hasStarted()}play(){!this.queued&&this._player.play()}pause(){!this.queued&&this._player.pause()}restart(){!this.queued&&this._player.restart()}finish(){this._player.finish()}destroy(){this.destroyed=!0,this._player.destroy()}reset(){!this.queued&&this._player.reset()}setPosition(a){this.queued||this._player.setPosition(a)}getPosition(){return this.queued?0:this._player.getPosition()}triggerCallback(a){const e=this._player;e.triggerCallback&&e.triggerCallback(a)}}function W(r){return r&&1===r.nodeType}function $e(r,a){const e=r.style.display;return r.style.display=null!=a?a:"none",e}function A1(r,a,e,c,m){const v=[];e.forEach(H=>v.push($e(H)));const S=[];c.forEach((H,q)=>{const ae={};H.forEach(ze=>{const Se=ae[ze]=a.computeStyle(q,ze,m);(!Se||0==Se.length)&&(q[kn]=Dt,S.push(q))}),r.set(q,ae)});let A=0;return e.forEach(H=>$e(H,v[A++])),S}function ri(r,a){const e=new Map;if(r.forEach(A=>e.set(A,[])),0==a.length)return e;const m=new Set(a),v=new Map;function S(A){if(!A)return 1;let H=v.get(A);if(H)return H;const q=A.parentNode;return H=e.has(q)?q:m.has(q)?1:S(q),v.set(A,H),H}return a.forEach(A=>{const H=S(A);1!==H&&e.get(H).push(A)}),e}function U1(r,a){var e;null===(e=r.classList)||void 0===e||e.add(a)}function Ri(r,a){var e;null===(e=r.classList)||void 0===e||e.remove(a)}function ta(r,a,e){on(e).onDone(()=>r.processLeaveNode(a))}function kr(r,a){for(let e=0;e<r.length;e++){const c=r[e];c instanceof ut?kr(c.players,a):a.push(c)}}function Ct(r,a,e){const c=e.get(r);if(!c)return!1;let m=a.get(r);return m?c.forEach(v=>m.add(v)):a.set(r,c),e.delete(r),!0}class Fi{constructor(a,e,c){this.bodyNode=a,this._driver=e,this._normalizer=c,this._triggerCache={},this.onRemovalComplete=(m,v)=>{},this._transitionEngine=new H1(a,e,c),this._timelineEngine=new U(a,e,c),this._transitionEngine.onRemovalComplete=(m,v)=>this.onRemovalComplete(m,v)}registerTrigger(a,e,c,m,v){const S=a+"-"+m;let A=this._triggerCache[S];if(!A){const H=[],ae=K1(this._driver,v,H,[]);if(H.length)throw function qn(r,a){return new d.vHH(3404,fn)}();A=function ba(r,a,e){return new Pa(r,a,e)}(m,ae,this._normalizer),this._triggerCache[S]=A}this._transitionEngine.registerTrigger(e,m,A)}register(a,e){this._transitionEngine.register(a,e)}destroy(a,e){this._transitionEngine.destroy(a,e)}onInsert(a,e,c,m){this._transitionEngine.insertNode(a,e,c,m)}onRemove(a,e,c,m){this._transitionEngine.removeNode(a,e,m||!1,c)}disableAnimations(a,e){this._transitionEngine.markElementAsDisabled(a,e)}process(a,e,c,m){if("@"==c.charAt(0)){const[v,S]=On(c);this._timelineEngine.command(v,e,S,m)}else this._transitionEngine.trigger(a,e,c,m)}listen(a,e,c,m,v){if("@"==c.charAt(0)){const[S,A]=On(c);return this._timelineEngine.listen(S,e,A,v)}return this._transitionEngine.listen(a,e,c,m,v)}flush(a=-1){this._transitionEngine.flush(a)}get players(){return this._transitionEngine.players.concat(this._timelineEngine.players)}whenRenderingDone(){return this._transitionEngine.whenRenderingDone()}}let Pr=(()=>{class r{constructor(e,c,m){this._element=e,this._startStyles=c,this._endStyles=m,this._state=0;let v=r.initialStylesByElement.get(e);v||r.initialStylesByElement.set(e,v={}),this._initialStyles=v}start(){this._state<1&&(this._startStyles&&mn(this._element,this._startStyles,this._initialStyles),this._state=1)}finish(){this.start(),this._state<2&&(mn(this._element,this._initialStyles),this._endStyles&&(mn(this._element,this._endStyles),this._endStyles=null),this._state=1)}destroy(){this.finish(),this._state<3&&(r.initialStylesByElement.delete(this._element),this._startStyles&&(bt(this._element,this._startStyles),this._endStyles=null),this._endStyles&&(bt(this._element,this._endStyles),this._endStyles=null),mn(this._element,this._initialStyles),this._state=3)}}return r.initialStylesByElement=new WeakMap,r})();function gr(r){let a=null;const e=Object.keys(r);for(let c=0;c<e.length;c++){const m=e[c];gi(m)&&(a=a||{},a[m]=r[m])}return a}function gi(r){return"display"===r||"position"===r}class X2{constructor(a,e,c,m){this.element=a,this.keyframes=e,this.options=c,this._specialStyles=m,this._onDoneFns=[],this._onStartFns=[],this._onDestroyFns=[],this._initialized=!1,this._finished=!1,this._started=!1,this._destroyed=!1,this.time=0,this.parentPlayer=null,this.currentSnapshot={},this._duration=c.duration,this._delay=c.delay||0,this.time=this._duration+this._delay}_onFinish(){this._finished||(this._finished=!0,this._onDoneFns.forEach(a=>a()),this._onDoneFns=[])}init(){this._buildPlayer(),this._preparePlayerBeforeStart()}_buildPlayer(){if(this._initialized)return;this._initialized=!0;const a=this.keyframes;this.domPlayer=this._triggerWebAnimation(this.element,a,this.options),this._finalKeyframe=a.length?a[a.length-1]:{},this.domPlayer.addEventListener("finish",()=>this._onFinish())}_preparePlayerBeforeStart(){this._delay?this._resetDomPlayerState():this.domPlayer.pause()}_triggerWebAnimation(a,e,c){return a.animate(e,c)}onStart(a){this._onStartFns.push(a)}onDone(a){this._onDoneFns.push(a)}onDestroy(a){this._onDestroyFns.push(a)}play(){this._buildPlayer(),this.hasStarted()||(this._onStartFns.forEach(a=>a()),this._onStartFns=[],this._started=!0,this._specialStyles&&this._specialStyles.start()),this.domPlayer.play()}pause(){this.init(),this.domPlayer.pause()}finish(){this.init(),this._specialStyles&&this._specialStyles.finish(),this._onFinish(),this.domPlayer.finish()}reset(){this._resetDomPlayerState(),this._destroyed=!1,this._finished=!1,this._started=!1}_resetDomPlayerState(){this.domPlayer&&this.domPlayer.cancel()}restart(){this.reset(),this.play()}hasStarted(){return this._started}destroy(){this._destroyed||(this._destroyed=!0,this._resetDomPlayerState(),this._onFinish(),this._specialStyles&&this._specialStyles.destroy(),this._onDestroyFns.forEach(a=>a()),this._onDestroyFns=[])}setPosition(a){void 0===this.domPlayer&&this.init(),this.domPlayer.currentTime=a*this.time}getPosition(){return this.domPlayer.currentTime/this.time}get totalTime(){return this._delay+this._duration}beforeDestroy(){const a={};if(this.hasStarted()){const e=this._finalKeyframe;Object.keys(e).forEach(c=>{"offset"!=c&&(a[c]=this._finished?e[c]:Qn(this.element,c))})}this.currentSnapshot=a}triggerCallback(a){const e="start"==a?this._onStartFns:this._onDoneFns;e.forEach(c=>c()),e.length=0}}class Y2{validateStyleProperty(a){return k1(a)}matchesElement(a,e){return!1}containsElement(a,e){return Ni(a,e)}getParentElement(a){return gt(a)}query(a,e,c){return Di(a,e,c)}computeStyle(a,e,c){return window.getComputedStyle(a)[e]}animate(a,e,c,m,v,S=[]){const H={duration:c,delay:m,fill:0==m?"both":"forwards"};v&&(H.easing=v);const q={},ae=S.filter(Se=>Se instanceof X2);(function n1(r,a){return 0===r||0===a})(c,m)&&ae.forEach(Se=>{let Ne=Se.currentSnapshot;Object.keys(Ne).forEach(Ee=>q[Ee]=Ne[Ee])}),e=function J1(r,a,e){const c=Object.keys(e);if(c.length&&a.length){let v=a[0],S=[];if(c.forEach(A=>{v.hasOwnProperty(A)||S.push(A),v[A]=e[A]}),S.length)for(var m=1;m<a.length;m++){let A=a[m];S.forEach(function(H){A[H]=Qn(r,H)})}}return a}(a,e=e.map(Se=>M1(Se,!1)),q);const ze=function b1(r,a){let e=null,c=null;return Array.isArray(a)&&a.length?(e=gr(a[0]),a.length>1&&(c=gr(a[a.length-1]))):a&&(e=gr(a)),e||c?new Pr(r,e,c):null}(a,e);return new X2(a,e,H,ze)}}var Hn=Q(9808);let h2=(()=>{class r extends Ue{constructor(e,c){super(),this._nextAnimationId=0,this._renderer=e.createRenderer(c.body,{id:"0",encapsulation:d.ifc.None,styles:[],data:{animation:[]}})}build(e){const c=this._nextAnimationId.toString();this._nextAnimationId++;const m=Array.isArray(e)?fe(e):e;return O(this._renderer,null,c,"register",[m]),new _a(c,this._renderer)}}return r.\u0275fac=function(e){return new(e||r)(d.LFG(d.FYo),d.LFG(Hn.K0))},r.\u0275prov=d.Yz7({token:r,factory:r.\u0275fac}),r})();class _a extends class Oe{}{constructor(a,e){super(),this._id=a,this._renderer=e}create(a,e){return new g2(this._id,a,e||{},this._renderer)}}class g2{constructor(a,e,c,m){this.id=a,this.element=e,this._renderer=m,this.parentPlayer=null,this._started=!1,this.totalTime=0,this._command("create",c)}_listen(a,e){return this._renderer.listen(this.element,`@@${this.id}:${a}`,e)}_command(a,...e){return O(this._renderer,this.element,this.id,a,e)}onDone(a){this._listen("done",a)}onStart(a){this._listen("start",a)}onDestroy(a){this._listen("destroy",a)}init(){this._command("init")}hasStarted(){return this._started}play(){this._command("play"),this._started=!0}pause(){this._command("pause")}restart(){this._command("restart")}finish(){this._command("finish")}destroy(){this._command("destroy")}reset(){this._command("reset"),this._started=!1}setPosition(a){this._command("setPosition",a)}getPosition(){var a,e;return null!==(e=null===(a=this._renderer.engine.players[+this.id])||void 0===a?void 0:a.getPosition())&&void 0!==e?e:0}}function O(r,a,e,c,m){return r.setProperty(a,`@@${e}:${c}`,m)}const Z="@",Y="@.disabled";let ne=(()=>{class r{constructor(e,c,m){this.delegate=e,this.engine=c,this._zone=m,this._currentId=0,this._microtaskId=1,this._animationCallbacksBuffer=[],this._rendererCache=new Map,this._cdRecurDepth=0,this.promise=Promise.resolve(0),c.onRemovalComplete=(v,S)=>{const A=null==S?void 0:S.parentNode(v);A&&S.removeChild(A,v)}}createRenderer(e,c){const v=this.delegate.createRenderer(e,c);if(!(e&&c&&c.data&&c.data.animation)){let ae=this._rendererCache.get(v);return ae||(ae=new ve("",v,this.engine),this._rendererCache.set(v,ae)),ae}const S=c.id,A=c.id+"-"+this._currentId;this._currentId++,this.engine.register(A,e);const H=ae=>{Array.isArray(ae)?ae.forEach(H):this.engine.registerTrigger(S,A,e,ae.name,ae)};return c.data.animation.forEach(H),new Pe(this,A,v,this.engine)}begin(){this._cdRecurDepth++,this.delegate.begin&&this.delegate.begin()}_scheduleCountTask(){this.promise.then(()=>{this._microtaskId++})}scheduleListenerCallback(e,c,m){e>=0&&e<this._microtaskId?this._zone.run(()=>c(m)):(0==this._animationCallbacksBuffer.length&&Promise.resolve(null).then(()=>{this._zone.run(()=>{this._animationCallbacksBuffer.forEach(v=>{const[S,A]=v;S(A)}),this._animationCallbacksBuffer=[]})}),this._animationCallbacksBuffer.push([c,m]))}end(){this._cdRecurDepth--,0==this._cdRecurDepth&&this._zone.runOutsideAngular(()=>{this._scheduleCountTask(),this.engine.flush(this._microtaskId)}),this.delegate.end&&this.delegate.end()}whenRenderingDone(){return this.engine.whenRenderingDone()}}return r.\u0275fac=function(e){return new(e||r)(d.LFG(d.FYo),d.LFG(Fi),d.LFG(d.R0b))},r.\u0275prov=d.Yz7({token:r,factory:r.\u0275fac}),r})();class ve{constructor(a,e,c){this.namespaceId=a,this.delegate=e,this.engine=c,this.destroyNode=this.delegate.destroyNode?m=>e.destroyNode(m):null}get data(){return this.delegate.data}destroy(){this.engine.destroy(this.namespaceId,this.delegate),this.delegate.destroy()}createElement(a,e){return this.delegate.createElement(a,e)}createComment(a){return this.delegate.createComment(a)}createText(a){return this.delegate.createText(a)}appendChild(a,e){this.delegate.appendChild(a,e),this.engine.onInsert(this.namespaceId,e,a,!1)}insertBefore(a,e,c,m=!0){this.delegate.insertBefore(a,e,c),this.engine.onInsert(this.namespaceId,e,a,m)}removeChild(a,e,c){this.engine.onRemove(this.namespaceId,e,this.delegate,c)}selectRootElement(a,e){return this.delegate.selectRootElement(a,e)}parentNode(a){return this.delegate.parentNode(a)}nextSibling(a){return this.delegate.nextSibling(a)}setAttribute(a,e,c,m){this.delegate.setAttribute(a,e,c,m)}removeAttribute(a,e,c){this.delegate.removeAttribute(a,e,c)}addClass(a,e){this.delegate.addClass(a,e)}removeClass(a,e){this.delegate.removeClass(a,e)}setStyle(a,e,c,m){this.delegate.setStyle(a,e,c,m)}removeStyle(a,e,c){this.delegate.removeStyle(a,e,c)}setProperty(a,e,c){e.charAt(0)==Z&&e==Y?this.disableAnimations(a,!!c):this.delegate.setProperty(a,e,c)}setValue(a,e){this.delegate.setValue(a,e)}listen(a,e,c){return this.delegate.listen(a,e,c)}disableAnimations(a,e){this.engine.disableAnimations(a,e)}}class Pe extends ve{constructor(a,e,c,m){super(e,c,m),this.factory=a,this.namespaceId=e}setProperty(a,e,c){e.charAt(0)==Z?"."==e.charAt(1)&&e==Y?this.disableAnimations(a,c=void 0===c||!!c):this.engine.process(this.namespaceId,a,e.substr(1),c):this.delegate.setProperty(a,e,c)}listen(a,e,c){if(e.charAt(0)==Z){const m=function Fe(r){switch(r){case"body":return document.body;case"document":return document;case"window":return window;default:return r}}(a);let v=e.substr(1),S="";return v.charAt(0)!=Z&&([v,S]=function Be(r){const a=r.indexOf(".");return[r.substring(0,a),r.substr(a+1)]}(v)),this.engine.listen(this.namespaceId,m,v,S,A=>{this.factory.scheduleListenerCallback(A._data||-1,c,A)})}return this.delegate.listen(a,e,c)}}let An=(()=>{class r extends Fi{constructor(e,c,m){super(e.body,c,m)}ngOnDestroy(){this.flush()}}return r.\u0275fac=function(e){return new(e||r)(d.LFG(Hn.K0),d.LFG(Yi),d.LFG(Ti))},r.\u0275prov=d.Yz7({token:r,factory:r.\u0275fac}),r})();const Tt=new d.OlP("AnimationModuleType"),Yt=[{provide:Ue,useClass:h2},{provide:Ti,useFactory:function dt(){return new ji}},{provide:Fi,useClass:An},{provide:d.FYo,useFactory:function ft(r,a,e){return new ne(r,a,e)},deps:[M.se,Fi,d.R0b]}],z1=[{provide:Yi,useFactory:()=>new Y2},{provide:Tt,useValue:"BrowserAnimations"},...Yt],oi=[{provide:Yi,useClass:r1},{provide:Tt,useValue:"NoopAnimations"},...Yt];let Y1=(()=>{class r{static withConfig(e){return{ngModule:r,providers:e.disableAnimations?oi:z1}}}return r.\u0275fac=function(e){return new(e||r)},r.\u0275mod=d.oAB({type:r}),r.\u0275inj=d.cJS({providers:z1,imports:[M.b2]}),r})();var N1=Q(4182),vi=Q(1086),qi=Q(2916),aa=Q(1406),Ia=Q(2198),R1=Q(4850);class D1{}class bi{}class It{constructor(a){this.normalizedNames=new Map,this.lazyUpdate=null,a?this.lazyInit="string"==typeof a?()=>{this.headers=new Map,a.split("\n").forEach(e=>{const c=e.indexOf(":");if(c>0){const m=e.slice(0,c),v=m.toLowerCase(),S=e.slice(c+1).trim();this.maybeSetNormalizedName(m,v),this.headers.has(v)?this.headers.get(v).push(S):this.headers.set(v,[S])}})}:()=>{this.headers=new Map,Object.keys(a).forEach(e=>{let c=a[e];const m=e.toLowerCase();"string"==typeof c&&(c=[c]),c.length>0&&(this.headers.set(m,c),this.maybeSetNormalizedName(e,m))})}:this.headers=new Map}has(a){return this.init(),this.headers.has(a.toLowerCase())}get(a){this.init();const e=this.headers.get(a.toLowerCase());return e&&e.length>0?e[0]:null}keys(){return this.init(),Array.from(this.normalizedNames.values())}getAll(a){return this.init(),this.headers.get(a.toLowerCase())||null}append(a,e){return this.clone({name:a,value:e,op:"a"})}set(a,e){return this.clone({name:a,value:e,op:"s"})}delete(a,e){return this.clone({name:a,value:e,op:"d"})}maybeSetNormalizedName(a,e){this.normalizedNames.has(e)||this.normalizedNames.set(e,a)}init(){this.lazyInit&&(this.lazyInit instanceof It?this.copyFrom(this.lazyInit):this.lazyInit(),this.lazyInit=null,this.lazyUpdate&&(this.lazyUpdate.forEach(a=>this.applyUpdate(a)),this.lazyUpdate=null))}copyFrom(a){a.init(),Array.from(a.headers.keys()).forEach(e=>{this.headers.set(e,a.headers.get(e)),this.normalizedNames.set(e,a.normalizedNames.get(e))})}clone(a){const e=new It;return e.lazyInit=this.lazyInit&&this.lazyInit instanceof It?this.lazyInit:this,e.lazyUpdate=(this.lazyUpdate||[]).concat([a]),e}applyUpdate(a){const e=a.name.toLowerCase();switch(a.op){case"a":case"s":let c=a.value;if("string"==typeof c&&(c=[c]),0===c.length)return;this.maybeSetNormalizedName(a.name,e);const m=("a"===a.op?this.headers.get(e):void 0)||[];m.push(...c),this.headers.set(e,m);break;case"d":const v=a.value;if(v){let S=this.headers.get(e);if(!S)return;S=S.filter(A=>-1===v.indexOf(A)),0===S.length?(this.headers.delete(e),this.normalizedNames.delete(e)):this.headers.set(e,S)}else this.headers.delete(e),this.normalizedNames.delete(e)}}forEach(a){this.init(),Array.from(this.normalizedNames.keys()).forEach(e=>a(this.normalizedNames.get(e),this.headers.get(e)))}}class e2{encodeKey(a){return n2(a)}encodeValue(a){return n2(a)}decodeKey(a){return decodeURIComponent(a)}decodeValue(a){return decodeURIComponent(a)}}const xo=/%(\d[a-f0-9])/gi,Co={40:"@","3A":":",24:"$","2C":",","3B":";","2B":"+","3D":"=","3F":"?","2F":"/"};function n2(r){return encodeURIComponent(r).replace(xo,(a,e)=>{var c;return null!==(c=Co[e])&&void 0!==c?c:a})}function t2(r){return`${r}`}class E1{constructor(a={}){if(this.updates=null,this.cloneFrom=null,this.encoder=a.encoder||new e2,a.fromString){if(a.fromObject)throw new Error("Cannot specify both fromString and fromObject.");this.map=function Yo(r,a){const e=new Map;return r.length>0&&r.replace(/^\?/,"").split("&").forEach(m=>{const v=m.indexOf("="),[S,A]=-1==v?[a.decodeKey(m),""]:[a.decodeKey(m.slice(0,v)),a.decodeValue(m.slice(v+1))],H=e.get(S)||[];H.push(A),e.set(S,H)}),e}(a.fromString,this.encoder)}else a.fromObject?(this.map=new Map,Object.keys(a.fromObject).forEach(e=>{const c=a.fromObject[e];this.map.set(e,Array.isArray(c)?c:[c])})):this.map=null}has(a){return this.init(),this.map.has(a)}get(a){this.init();const e=this.map.get(a);return e?e[0]:null}getAll(a){return this.init(),this.map.get(a)||null}keys(){return this.init(),Array.from(this.map.keys())}append(a,e){return this.clone({param:a,value:e,op:"a"})}appendAll(a){const e=[];return Object.keys(a).forEach(c=>{const m=a[c];Array.isArray(m)?m.forEach(v=>{e.push({param:c,value:v,op:"a"})}):e.push({param:c,value:m,op:"a"})}),this.clone(e)}set(a,e){return this.clone({param:a,value:e,op:"s"})}delete(a,e){return this.clone({param:a,value:e,op:"d"})}toString(){return this.init(),this.keys().map(a=>{const e=this.encoder.encodeKey(a);return this.map.get(a).map(c=>e+"="+this.encoder.encodeValue(c)).join("&")}).filter(a=>""!==a).join("&")}clone(a){const e=new E1({encoder:this.encoder});return e.cloneFrom=this.cloneFrom||this,e.updates=(this.updates||[]).concat(a),e}init(){null===this.map&&(this.map=new Map),null!==this.cloneFrom&&(this.cloneFrom.init(),this.cloneFrom.keys().forEach(a=>this.map.set(a,this.cloneFrom.map.get(a))),this.updates.forEach(a=>{switch(a.op){case"a":case"s":const e=("a"===a.op?this.map.get(a.param):void 0)||[];e.push(t2(a.value)),this.map.set(a.param,e);break;case"d":if(void 0===a.value){this.map.delete(a.param);break}{let c=this.map.get(a.param)||[];const m=c.indexOf(t2(a.value));-1!==m&&c.splice(m,1),c.length>0?this.map.set(a.param,c):this.map.delete(a.param)}}}),this.cloneFrom=this.updates=null)}}class $a{constructor(){this.map=new Map}set(a,e){return this.map.set(a,e),this}get(a){return this.map.has(a)||this.map.set(a,a.defaultValue()),this.map.get(a)}delete(a){return this.map.delete(a),this}has(a){return this.map.has(a)}keys(){return this.map.keys()}}function Qo(r){return"undefined"!=typeof ArrayBuffer&&r instanceof ArrayBuffer}function Bi(r){return"undefined"!=typeof Blob&&r instanceof Blob}function Oa(r){return"undefined"!=typeof FormData&&r instanceof FormData}class br{constructor(a,e,c,m){let v;if(this.url=e,this.body=null,this.reportProgress=!1,this.withCredentials=!1,this.responseType="json",this.method=a.toUpperCase(),function L2(r){switch(r){case"DELETE":case"GET":case"HEAD":case"OPTIONS":case"JSONP":return!1;default:return!0}}(this.method)||m?(this.body=void 0!==c?c:null,v=m):v=c,v&&(this.reportProgress=!!v.reportProgress,this.withCredentials=!!v.withCredentials,v.responseType&&(this.responseType=v.responseType),v.headers&&(this.headers=v.headers),v.context&&(this.context=v.context),v.params&&(this.params=v.params)),this.headers||(this.headers=new It),this.context||(this.context=new $a),this.params){const S=this.params.toString();if(0===S.length)this.urlWithParams=e;else{const A=e.indexOf("?");this.urlWithParams=e+(-1===A?"?":A<e.length-1?"&":"")+S}}else this.params=new E1,this.urlWithParams=e}serializeBody(){return null===this.body?null:Qo(this.body)||Bi(this.body)||Oa(this.body)||function Ir(r){return"undefined"!=typeof URLSearchParams&&r instanceof URLSearchParams}(this.body)||"string"==typeof this.body?this.body:this.body instanceof E1?this.body.toString():"object"==typeof this.body||"boolean"==typeof this.body||Array.isArray(this.body)?JSON.stringify(this.body):this.body.toString()}detectContentTypeHeader(){return null===this.body||Oa(this.body)?null:Bi(this.body)?this.body.type||null:Qo(this.body)?null:"string"==typeof this.body?"text/plain":this.body instanceof E1?"application/x-www-form-urlencoded;charset=UTF-8":"object"==typeof this.body||"number"==typeof this.body||"boolean"==typeof this.body?"application/json":null}clone(a={}){var e;const c=a.method||this.method,m=a.url||this.url,v=a.responseType||this.responseType,S=void 0!==a.body?a.body:this.body,A=void 0!==a.withCredentials?a.withCredentials:this.withCredentials,H=void 0!==a.reportProgress?a.reportProgress:this.reportProgress;let q=a.headers||this.headers,ae=a.params||this.params;const ze=null!==(e=a.context)&&void 0!==e?e:this.context;return void 0!==a.setHeaders&&(q=Object.keys(a.setHeaders).reduce((Se,Ne)=>Se.set(Ne,a.setHeaders[Ne]),q)),a.setParams&&(ae=Object.keys(a.setParams).reduce((Se,Ne)=>Se.set(Ne,a.setParams[Ne]),ae)),new br(c,m,S,{params:ae,headers:q,context:ze,reportProgress:H,responseType:v,withCredentials:A})}}var C1=(()=>((C1=C1||{})[C1.Sent=0]="Sent",C1[C1.UploadProgress=1]="UploadProgress",C1[C1.ResponseHeader=2]="ResponseHeader",C1[C1.DownloadProgress=3]="DownloadProgress",C1[C1.Response=4]="Response",C1[C1.User=5]="User",C1))();class Xa{constructor(a,e=200,c="OK"){this.headers=a.headers||new It,this.status=void 0!==a.status?a.status:e,this.statusText=a.statusText||c,this.url=a.url||null,this.ok=this.status>=200&&this.status<300}}class a2 extends Xa{constructor(a={}){super(a),this.type=C1.ResponseHeader}clone(a={}){return new a2({headers:a.headers||this.headers,status:void 0!==a.status?a.status:this.status,statusText:a.statusText||this.statusText,url:a.url||this.url||void 0})}}class Q2 extends Xa{constructor(a={}){super(a),this.type=C1.Response,this.body=void 0!==a.body?a.body:null}clone(a={}){return new Q2({body:void 0!==a.body?a.body:this.body,headers:a.headers||this.headers,status:void 0!==a.status?a.status:this.status,statusText:a.statusText||this.statusText,url:a.url||this.url||void 0})}}class J2 extends Xa{constructor(a){super(a,0,"Unknown Error"),this.name="HttpErrorResponse",this.ok=!1,this.message=this.status>=200&&this.status<300?`Http failure during parsing for ${a.url||"(unknown url)"}`:`Http failure response for ${a.url||"(unknown url)"}: ${a.status} ${a.statusText}`,this.error=a.error||null}}function So(r,a){return{body:a,headers:r.headers,context:r.context,observe:r.observe,params:r.params,reportProgress:r.reportProgress,responseType:r.responseType,withCredentials:r.withCredentials}}let T2=(()=>{class r{constructor(e){this.handler=e}request(e,c,m={}){let v;if(e instanceof br)v=e;else{let H,q;H=m.headers instanceof It?m.headers:new It(m.headers),m.params&&(q=m.params instanceof E1?m.params:new E1({fromObject:m.params})),v=new br(e,c,void 0!==m.body?m.body:null,{headers:H,context:m.context,params:q,reportProgress:m.reportProgress,responseType:m.responseType||"json",withCredentials:m.withCredentials})}const S=(0,vi.of)(v).pipe((0,aa.b)(H=>this.handler.handle(H)));if(e instanceof br||"events"===m.observe)return S;const A=S.pipe((0,Ia.h)(H=>H instanceof Q2));switch(m.observe||"body"){case"body":switch(v.responseType){case"arraybuffer":return A.pipe((0,R1.U)(H=>{if(null!==H.body&&!(H.body instanceof ArrayBuffer))throw new Error("Response is not an ArrayBuffer.");return H.body}));case"blob":return A.pipe((0,R1.U)(H=>{if(null!==H.body&&!(H.body instanceof Blob))throw new Error("Response is not a Blob.");return H.body}));case"text":return A.pipe((0,R1.U)(H=>{if(null!==H.body&&"string"!=typeof H.body)throw new Error("Response is not a string.");return H.body}));default:return A.pipe((0,R1.U)(H=>H.body))}case"response":return A;default:throw new Error(`Unreachable: unhandled observe type ${m.observe}}`)}}delete(e,c={}){return this.request("DELETE",e,c)}get(e,c={}){return this.request("GET",e,c)}head(e,c={}){return this.request("HEAD",e,c)}jsonp(e,c){return this.request("JSONP",e,{params:(new E1).append(c,"JSONP_CALLBACK"),observe:"body",responseType:"json"})}options(e,c={}){return this.request("OPTIONS",e,c)}patch(e,c,m={}){return this.request("PATCH",e,So(m,c))}post(e,c,m={}){return this.request("POST",e,So(m,c))}put(e,c,m={}){return this.request("PUT",e,So(m,c))}}return r.\u0275fac=function(e){return new(e||r)(d.LFG(D1))},r.\u0275prov=d.Yz7({token:r,factory:r.\u0275fac}),r})();class Or{constructor(a,e){this.next=a,this.interceptor=e}handle(a){return this.interceptor.intercept(a,this.next)}}const j2=new d.OlP("HTTP_INTERCEPTORS");let K2=(()=>{class r{intercept(e,c){return c.handle(e)}}return r.\u0275fac=function(e){return new(e||r)},r.\u0275prov=d.Yz7({token:r,factory:r.\u0275fac}),r})();const Mo=/^\)\]\}',?\n/;let b2=(()=>{class r{constructor(e){this.xhrFactory=e}handle(e){if("JSONP"===e.method)throw new Error("Attempted to construct Jsonp request without HttpClientJsonpModule installed.");return new qi.y(c=>{const m=this.xhrFactory.build();if(m.open(e.method,e.urlWithParams),e.withCredentials&&(m.withCredentials=!0),e.headers.forEach((Ne,Ee)=>m.setRequestHeader(Ne,Ee.join(","))),e.headers.has("Accept")||m.setRequestHeader("Accept","application/json, text/plain, */*"),!e.headers.has("Content-Type")){const Ne=e.detectContentTypeHeader();null!==Ne&&m.setRequestHeader("Content-Type",Ne)}if(e.responseType){const Ne=e.responseType.toLowerCase();m.responseType="json"!==Ne?Ne:"text"}const v=e.serializeBody();let S=null;const A=()=>{if(null!==S)return S;const Ne=m.statusText||"OK",Ee=new It(m.getAllResponseHeaders()),Ve=function Ko(r){return"responseURL"in r&&r.responseURL?r.responseURL:/^X-Request-URL:/m.test(r.getAllResponseHeaders())?r.getResponseHeader("X-Request-URL"):null}(m)||e.url;return S=new a2({headers:Ee,status:m.status,statusText:Ne,url:Ve}),S},H=()=>{let{headers:Ne,status:Ee,statusText:Ve,url:Mn}=A(),hn=null;204!==Ee&&(hn=void 0===m.response?m.responseText:m.response),0===Ee&&(Ee=hn?200:0);let bn=Ee>=200&&Ee<300;if("json"===e.responseType&&"string"==typeof hn){const rt=hn;hn=hn.replace(Mo,"");try{hn=""!==hn?JSON.parse(hn):null}catch(nt){hn=rt,bn&&(bn=!1,hn={error:nt,text:hn})}}bn?(c.next(new Q2({body:hn,headers:Ne,status:Ee,statusText:Ve,url:Mn||void 0})),c.complete()):c.error(new J2({error:hn,headers:Ne,status:Ee,statusText:Ve,url:Mn||void 0}))},q=Ne=>{const{url:Ee}=A(),Ve=new J2({error:Ne,status:m.status||0,statusText:m.statusText||"Unknown Error",url:Ee||void 0});c.error(Ve)};let ae=!1;const ze=Ne=>{ae||(c.next(A()),ae=!0);let Ee={type:C1.DownloadProgress,loaded:Ne.loaded};Ne.lengthComputable&&(Ee.total=Ne.total),"text"===e.responseType&&!!m.responseText&&(Ee.partialText=m.responseText),c.next(Ee)},Se=Ne=>{let Ee={type:C1.UploadProgress,loaded:Ne.loaded};Ne.lengthComputable&&(Ee.total=Ne.total),c.next(Ee)};return m.addEventListener("load",H),m.addEventListener("error",q),m.addEventListener("timeout",q),m.addEventListener("abort",q),e.reportProgress&&(m.addEventListener("progress",ze),null!==v&&m.upload&&m.upload.addEventListener("progress",Se)),m.send(v),c.next({type:C1.Sent}),()=>{m.removeEventListener("error",q),m.removeEventListener("abort",q),m.removeEventListener("load",H),m.removeEventListener("timeout",q),e.reportProgress&&(m.removeEventListener("progress",ze),null!==v&&m.upload&&m.upload.removeEventListener("progress",Se)),m.readyState!==m.DONE&&m.abort()}})}}return r.\u0275fac=function(e){return new(e||r)(d.LFG(Hn.JF))},r.\u0275prov=d.Yz7({token:r,factory:r.\u0275fac}),r})();const wo=new d.OlP("XSRF_COOKIE_NAME"),or=new d.OlP("XSRF_HEADER_NAME");class _r{}let Hr=(()=>{class r{constructor(e,c,m){this.doc=e,this.platform=c,this.cookieName=m,this.lastCookieString="",this.lastToken=null,this.parseCount=0}getToken(){if("server"===this.platform)return null;const e=this.doc.cookie||"";return e!==this.lastCookieString&&(this.parseCount++,this.lastToken=(0,Hn.Mx)(e,this.cookieName),this.lastCookieString=e),this.lastToken}}return r.\u0275fac=function(e){return new(e||r)(d.LFG(Hn.K0),d.LFG(d.Lbi),d.LFG(wo))},r.\u0275prov=d.Yz7({token:r,factory:r.\u0275fac}),r})(),xr=(()=>{class r{constructor(e,c){this.tokenService=e,this.headerName=c}intercept(e,c){const m=e.url.toLowerCase();if("GET"===e.method||"HEAD"===e.method||m.startsWith("http://")||m.startsWith("https://"))return c.handle(e);const v=this.tokenService.getToken();return null!==v&&!e.headers.has(this.headerName)&&(e=e.clone({headers:e.headers.set(this.headerName,v)})),c.handle(e)}}return r.\u0275fac=function(e){return new(e||r)(d.LFG(_r),d.LFG(or))},r.\u0275prov=d.Yz7({token:r,factory:r.\u0275fac}),r})(),Rr=(()=>{class r{constructor(e,c){this.backend=e,this.injector=c,this.chain=null}handle(e){if(null===this.chain){const c=this.injector.get(j2,[]);this.chain=c.reduceRight((m,v)=>new Or(m,v),this.backend)}return this.chain.handle(e)}}return r.\u0275fac=function(e){return new(e||r)(d.LFG(bi),d.LFG(d.zs3))},r.\u0275prov=d.Yz7({token:r,factory:r.\u0275fac}),r})(),x=(()=>{class r{static disable(){return{ngModule:r,providers:[{provide:xr,useClass:K2}]}}static withOptions(e={}){return{ngModule:r,providers:[e.cookieName?{provide:wo,useValue:e.cookieName}:[],e.headerName?{provide:or,useValue:e.headerName}:[]]}}}return r.\u0275fac=function(e){return new(e||r)},r.\u0275mod=d.oAB({type:r}),r.\u0275inj=d.cJS({providers:[xr,{provide:j2,useExisting:xr,multi:!0},{provide:_r,useClass:Hr},{provide:wo,useValue:"XSRF-TOKEN"},{provide:or,useValue:"X-XSRF-TOKEN"}]}),r})(),_=(()=>{class r{}return r.\u0275fac=function(e){return new(e||r)},r.\u0275mod=d.oAB({type:r}),r.\u0275inj=d.cJS({providers:[T2,{provide:D1,useClass:Rr},b2,{provide:bi,useExisting:b2}],imports:[[x.withOptions({cookieName:"XSRF-TOKEN",headerName:"X-XSRF-TOKEN"})]]}),r})();var G=Q(4366),te=Q(8896),se=Q(5529),Ie=Q(6688),In=Q(7043);function un(r,a,e,c){return(0,In.m)(e)&&(c=e,e=void 0),c?un(r,a,e).pipe((0,R1.U)(m=>(0,Ie.k)(m)?c(...m):c(m))):new qi.y(m=>{Kn(r,a,function v(S){m.next(arguments.length>1?Array.prototype.slice.call(arguments):S)},m,e)})}function Kn(r,a,e,c,m){let v;if(function ra(r){return r&&"function"==typeof r.addEventListener&&"function"==typeof r.removeEventListener}(r)){const S=r;r.addEventListener(a,e,m),v=()=>S.removeEventListener(a,e,m)}else if(function S1(r){return r&&"function"==typeof r.on&&"function"==typeof r.off}(r)){const S=r;r.on(a,e),v=()=>S.off(a,e)}else if(function _t(r){return r&&"function"==typeof r.addListener&&"function"==typeof r.removeListener}(r)){const S=r;r.addListener(a,e),v=()=>S.removeListener(a,e)}else{if(!r||!r.length)throw new TypeError("Invalid event target");for(let S=0,A=r.length;S<A;S++)Kn(r[S],a,e,c,m)}c.add(v)}var Ya=Q(6686);const Cr=new(Q(2268).v)(Ya.o);function y2(r){return!(0,Ie.k)(r)&&r-parseFloat(r)+1>=0}var Fr=Q(2866);function uc(r){const{index:a,period:e,subscriber:c}=r;if(c.next(a),!c.closed){if(-1===e)return c.complete();r.index=a+1,this.schedule(r,e)}}var ti=Q(3009),Vs=Q(826),fc=Q(448);function pc(...r){if(1===r.length){if(!(0,Ie.k)(r[0]))return r[0];r=r[0]}return(0,ti.n)(r,void 0).lift(new u3)}class u3{call(a,e){return e.subscribe(new Xc(a))}}class Xc extends Vs.L{constructor(a){super(a),this.hasFirst=!1,this.observables=[],this.subscriptions=[]}_next(a){this.observables.push(a)}_complete(){const a=this.observables,e=a.length;if(0===e)this.destination.complete();else{for(let c=0;c<e&&!this.hasFirst;c++){const v=(0,fc.D)(this,a[c],void 0,c);this.subscriptions&&this.subscriptions.push(v),this.add(v)}this.observables=null}}notifyNext(a,e,c){if(!this.hasFirst){this.hasFirst=!0;for(let m=0;m<this.subscriptions.length;m++)if(m!==c){let v=this.subscriptions[m];v.unsubscribe(),this.remove(v)}this.subscriptions=null}this.destination.next(e)}}Q(591),Q(6053);var ns=Q(7876);new qi.y(ns.Z);var P2=Q(3489),I2=Q(5430),_2=Q(1177);function xa(...r){const a=r[r.length-1];return"function"==typeof a&&r.pop(),(0,ti.n)(r,void 0).lift(new St(a))}class St{constructor(a){this.resultSelector=a}call(a,e){return e.subscribe(new yi(a,this.resultSelector))}}class yi extends P2.L{constructor(a,e,c=Object.create(null)){super(a),this.resultSelector=e,this.iterators=[],this.active=0,this.resultSelector="function"==typeof e?e:void 0}_next(a){const e=this.iterators;(0,Ie.k)(a)?e.push(new qr(a)):e.push("function"==typeof a[I2.hZ]?new x2(a[I2.hZ]()):new No(this.destination,this,a))}_complete(){const a=this.iterators,e=a.length;if(this.unsubscribe(),0!==e){this.active=e;for(let c=0;c<e;c++){let m=a[c];m.stillUnsubscribed?this.destination.add(m.subscribe()):this.active--}}else this.destination.complete()}notifyInactive(){this.active--,0===this.active&&this.destination.complete()}checkIterators(){const a=this.iterators,e=a.length,c=this.destination;for(let S=0;S<e;S++){let A=a[S];if("function"==typeof A.hasValue&&!A.hasValue())return}let m=!1;const v=[];for(let S=0;S<e;S++){let A=a[S],H=A.next();if(A.hasCompleted()&&(m=!0),H.done)return void c.complete();v.push(H.value)}this.resultSelector?this._tryresultSelector(v):c.next(v),m&&c.complete()}_tryresultSelector(a){let e;try{e=this.resultSelector.apply(this,a)}catch(c){return void this.destination.error(c)}this.destination.next(e)}}class x2{constructor(a){this.iterator=a,this.nextResult=a.next()}hasValue(){return!0}next(){const a=this.nextResult;return this.nextResult=this.iterator.next(),a}hasCompleted(){const a=this.nextResult;return Boolean(a&&a.done)}}class qr{constructor(a){this.array=a,this.index=0,this.length=0,this.length=a.length}[I2.hZ](){return this}next(a){const e=this.index++;return e<this.length?{value:this.array[e],done:!1}:{value:null,done:!0}}hasValue(){return this.array.length>this.index}hasCompleted(){return this.array.length===this.index}}class No extends _2.Ds{constructor(a,e,c){super(a),this.parent=e,this.observable=c,this.stillUnsubscribed=!0,this.buffer=[],this.isComplete=!1}[I2.hZ](){return this}next(){const a=this.buffer;return 0===a.length&&this.isComplete?{value:null,done:!0}:{value:a.shift(),done:!1}}hasValue(){return this.buffer.length>0}hasCompleted(){return 0===this.buffer.length&&this.isComplete}notifyComplete(){this.buffer.length>0?(this.isComplete=!0,this.parent.notifyInactive()):this.destination.complete()}notifyNext(a){this.buffer.push(a),this.parent.checkIterators()}subscribe(){return(0,_2.ft)(this.observable,new _2.IY(this))}}var Rs=Q(1221);function G1(r){return a=>a.lift(new Qc(r))}class Qc{constructor(a){this.notifier=a}call(a,e){const c=new Fs(a),m=(0,_2.ft)(this.notifier,new _2.IY(c));return m&&!c.seenValue?(c.add(m),e.subscribe(c)):c}}class Fs extends _2.Ds{constructor(a){super(a),this.seenValue=!1}notifyNext(){this.seenValue=!0,this.complete()}notifyComplete(){}}var Sr=Q(2986);Q(1059);var mc=Q(7545),ts=Q(2994);function is(...r){return a=>{let e;return"function"==typeof r[r.length-1]&&(e=r.pop()),a.lift(new Jc(r,e))}}class Jc{constructor(a,e){this.observables=a,this.project=e}call(a,e){return e.subscribe(new p3(a,this.observables,this.project))}}class p3 extends Vs.L{constructor(a,e,c){super(a),this.observables=e,this.project=c,this.toRespond=[];const m=e.length;this.values=new Array(m);for(let v=0;v<m;v++)this.toRespond.push(v);for(let v=0;v<m;v++)this.add((0,fc.D)(this,e[v],void 0,v))}notifyNext(a,e,c){this.values[c]=e;const m=this.toRespond;if(m.length>0){const v=m.indexOf(c);-1!==v&&m.splice(v,1)}}notifyComplete(){}_next(a){if(0===this.toRespond.length){const e=[a,...this.values];this.project?this._tryProject(e):this.destination.next(e)}}_tryProject(a){let e;try{e=this.project.apply(this,a)}catch(c){return void this.destination.error(c)}this.destination.next(e)}}var e4=Q(1737);class ca{constructor(a,e,c){this.kind=a,this.value=e,this.error=c,this.hasValue="N"===a}observe(a){switch(this.kind){case"N":return a.next&&a.next(this.value);case"E":return a.error&&a.error(this.error);case"C":return a.complete&&a.complete()}}do(a,e,c){switch(this.kind){case"N":return a&&a(this.value);case"E":return e&&e(this.error);case"C":return c&&c()}}accept(a,e,c){return a&&"function"==typeof a.next?this.observe(a):this.do(a,e,c)}toObservable(){switch(this.kind){case"N":return(0,vi.of)(this.value);case"E":return(0,e4._)(this.error);case"C":return(0,te.c)()}throw new Error("unexpected notification kind value")}static createNext(a){return void 0!==a?new ca("N",a):ca.undefinedValueNotification}static createError(a){return new ca("E",void 0,a)}static createComplete(){return ca.completeNotification}}ca.completeNotification=new ca("C"),ca.undefinedValueNotification=new ca("N",void 0);class as{constructor(a,e){this.delay=a,this.scheduler=e}call(a,e){return e.subscribe(new rs(a,this.delay,this.scheduler))}}class rs extends P2.L{constructor(a,e,c){super(a),this.delay=e,this.scheduler=c,this.queue=[],this.active=!1,this.errored=!1}static dispatch(a){const e=a.source,c=e.queue,m=a.scheduler,v=a.destination;for(;c.length>0&&c[0].time-m.now()<=0;)c.shift().notification.observe(v);if(c.length>0){const S=Math.max(0,c[0].time-m.now());this.schedule(a,S)}else this.unsubscribe(),e.active=!1}_schedule(a){this.active=!0,this.destination.add(a.schedule(rs.dispatch,this.delay,{source:this,destination:this.destination,scheduler:a}))}scheduleNotification(a){if(!0===this.errored)return;const e=this.scheduler,c=new os(e.now()+this.delay,a);this.queue.push(c),!1===this.active&&this._schedule(e)}_next(a){this.scheduleNotification(ca.createNext(a))}_error(a){this.errored=!0,this.queue=[],this.destination.error(a),this.unsubscribe()}_complete(){this.scheduleNotification(ca.createComplete()),this.unsubscribe()}}class os{constructor(a,e){this.time=a,this.notification=e}}var gc={left:"right",right:"left",bottom:"top",top:"bottom"};function Eo(r){return r.replace(/left|right|bottom|top/g,function(a){return gc[a]})}function Qa(r){return r.split("-")[0]}var t4={start:"end",end:"start"};function vc(r){return r.replace(/start|end/g,function(a){return t4[a]})}var vt="top",Va="bottom",Br="right",Ja="left",O2="auto",r2=[vt,Va,Br,Ja],C2="start",Ao="end",io="viewport",Ur="popper",cs=r2.reduce(function(r,a){return r.concat([a+"-"+C2,a+"-"+Ao])},[]),bc=[].concat(r2,[O2]).reduce(function(r,a){return r.concat([a,a+"-"+C2,a+"-"+Ao])},[]),To=["beforeRead","read","afterRead","beforeMain","main","afterMain","beforeWrite","write","afterWrite"];function Mr(r){if(null==r)return window;if("[object Window]"!==r.toString()){var a=r.ownerDocument;return a&&a.defaultView||window}return r}function ds(r){return r instanceof Mr(r).Element||r instanceof Element}function lr(r){return r instanceof Mr(r).HTMLElement||r instanceof HTMLElement}function o2(r){return"undefined"!=typeof ShadowRoot&&(r instanceof Mr(r).ShadowRoot||r instanceof ShadowRoot)}function dr(r){return((ds(r)?r.ownerDocument:r.document)||window.document).documentElement}var Ka=Math.max,jo=Math.min,wr=Math.round;function ko(r,a){void 0===a&&(a=!1);var e=r.getBoundingClientRect(),c=1,m=1;if(lr(r)&&a){var v=r.offsetHeight,S=r.offsetWidth;S>0&&(c=wr(e.width)/S||1),v>0&&(m=wr(e.height)/v||1)}return{width:e.width/c,height:e.height/m,top:e.top/m,right:e.right/c,bottom:e.bottom/m,left:e.left/c,x:e.left/c,y:e.top/m}}function yc(r){var a=Mr(r);return{scrollLeft:a.pageXOffset,scrollTop:a.pageYOffset}}function r4(r){return ko(dr(r)).left+yc(r).scrollLeft}function zr(r){return Mr(r).getComputedStyle(r)}function Gr(r){return r?(r.nodeName||"").toLowerCase():null}function us(r){return"html"===Gr(r)?r:r.assignedSlot||r.parentNode||(o2(r)?r.host:null)||dr(r)}function s2(r){var a=zr(r);return/auto|scroll|overlay|hidden/.test(a.overflow+a.overflowY+a.overflowX)}function _c(r){return["html","body","#document"].indexOf(Gr(r))>=0?r.ownerDocument.body:lr(r)&&s2(r)?r:_c(us(r))}function Po(r,a){var e;void 0===a&&(a=[]);var c=_c(r),m=c===(null==(e=r.ownerDocument)?void 0:e.body),v=Mr(c),S=m?[v].concat(v.visualViewport||[],s2(c)?c:[]):c,A=a.concat(S);return m?A:A.concat(Po(us(S)))}function h3(r){return["table","td","th"].indexOf(Gr(r))>=0}function s4(r){return lr(r)&&"fixed"!==zr(r).position?r.offsetParent:null}function _i(r){for(var a=Mr(r),e=s4(r);e&&h3(e)&&"static"===zr(e).position;)e=s4(e);return e&&("html"===Gr(e)||"body"===Gr(e)&&"static"===zr(e).position)?a:e||function g3(r){var a=-1!==navigator.userAgent.toLowerCase().indexOf("firefox");if(-1!==navigator.userAgent.indexOf("Trident")&&lr(r)&&"fixed"===zr(r).position)return null;for(var m=us(r);lr(m)&&["html","body"].indexOf(Gr(m))<0;){var v=zr(m);if("none"!==v.transform||"none"!==v.perspective||"paint"===v.contain||-1!==["transform","perspective"].indexOf(v.willChange)||a&&"filter"===v.willChange||a&&v.filter&&"none"!==v.filter)return m;m=m.parentNode}return null}(r)||a}function Wr(r,a){var e=a.getRootNode&&a.getRootNode();if(r.contains(a))return!0;if(e&&o2(e)){var c=a;do{if(c&&r.isSameNode(c))return!0;c=c.parentNode||c.host}while(c)}return!1}function oo(r){return Object.assign({},r,{left:r.x,top:r.y,right:r.x+r.width,bottom:r.y+r.height})}function c2(r,a){return a===io?oo(function Ui(r){var a=Mr(r),e=dr(r),c=a.visualViewport,m=e.clientWidth,v=e.clientHeight,S=0,A=0;return c&&(m=c.width,v=c.height,/^((?!chrome|android).)*safari/i.test(navigator.userAgent)||(S=c.offsetLeft,A=c.offsetTop)),{width:m,height:v,x:S+r4(r),y:A}}(r)):ds(a)?function fs(r){var a=ko(r);return a.top=a.top+r.clientTop,a.left=a.left+r.clientLeft,a.bottom=a.top+r.clientHeight,a.right=a.left+r.clientWidth,a.width=r.clientWidth,a.height=r.clientHeight,a.x=a.left,a.y=a.top,a}(a):oo(function o4(r){var a,e=dr(r),c=yc(r),m=null==(a=r.ownerDocument)?void 0:a.body,v=Ka(e.scrollWidth,e.clientWidth,m?m.scrollWidth:0,m?m.clientWidth:0),S=Ka(e.scrollHeight,e.clientHeight,m?m.scrollHeight:0,m?m.clientHeight:0),A=-c.scrollLeft+r4(r),H=-c.scrollTop;return"rtl"===zr(m||e).direction&&(A+=Ka(e.clientWidth,m?m.clientWidth:0)-v),{width:v,height:S,x:A,y:H}}(dr(r)))}function Zr(r){return r.split("-")[1]}function ps(r){return["top","bottom"].indexOf(r)>=0?"x":"y"}function xc(r){var H,a=r.reference,e=r.element,c=r.placement,m=c?Qa(c):null,v=c?Zr(c):null,S=a.x+a.width/2-e.width/2,A=a.y+a.height/2-e.height/2;switch(m){case vt:H={x:S,y:a.y-e.height};break;case Va:H={x:S,y:a.y+a.height};break;case Br:H={x:a.x+a.width,y:A};break;case Ja:H={x:a.x-e.width,y:A};break;default:H={x:a.x,y:a.y}}var q=m?ps(m):null;if(null!=q){var ae="y"===q?"height":"width";switch(v){case C2:H[q]=H[q]-(a[ae]/2-e[ae]/2);break;case Ao:H[q]=H[q]+(a[ae]/2-e[ae]/2)}}return H}function ms(r){return Object.assign({},{top:0,right:0,bottom:0,left:0},r)}function so(r,a){return a.reduce(function(e,c){return e[c]=r,e},{})}function Gs(r,a){void 0===a&&(a={});var c=a.placement,m=void 0===c?r.placement:c,v=a.boundary,S=void 0===v?"clippingParents":v,A=a.rootBoundary,H=void 0===A?io:A,q=a.elementContext,ae=void 0===q?Ur:q,ze=a.altBoundary,Se=void 0!==ze&&ze,Ne=a.padding,Ee=void 0===Ne?0:Ne,Ve=ms("number"!=typeof Ee?Ee:so(Ee,r2)),hn=r.rects.popper,bn=r.elements[Se?ae===Ur?"reference":Ur:ae],rt=function b3(r,a,e){var c="clippingParents"===a?function v3(r){var a=Po(us(r)),c=["absolute","fixed"].indexOf(zr(r).position)>=0&&lr(r)?_i(r):r;return ds(c)?a.filter(function(m){return ds(m)&&Wr(m,c)&&"body"!==Gr(m)}):[]}(r):[].concat(a),m=[].concat(c,[e]),S=m.reduce(function(A,H){var q=c2(r,H);return A.top=Ka(q.top,A.top),A.right=jo(q.right,A.right),A.bottom=jo(q.bottom,A.bottom),A.left=Ka(q.left,A.left),A},c2(r,m[0]));return S.width=S.right-S.left,S.height=S.bottom-S.top,S.x=S.left,S.y=S.top,S}(ds(bn)?bn:bn.contextElement||dr(r.elements.popper),S,H),nt=ko(r.elements.reference),p1=xc({reference:nt,element:hn,strategy:"absolute",placement:m}),Qt=oo(Object.assign({},hn,p1)),Vt=ae===Ur?Qt:nt,Kt={top:rt.top-Vt.top+Ve.top,bottom:Vt.bottom-rt.bottom+Ve.bottom,left:rt.left-Vt.left+Ve.left,right:Vt.right-rt.right+Ve.right},ui=r.modifiersData.offset;if(ae===Ur&&ui){var fi=ui[m];Object.keys(Kt).forEach(function(Ii){var Yr=[Br,Va].indexOf(Ii)>=0?1:-1,Fa=[vt,Va].indexOf(Ii)>=0?"y":"x";Kt[Ii]+=fi[Fa]*Yr})}return Kt}const er={name:"flip",enabled:!0,phase:"main",fn:function c4(r){var a=r.state,e=r.options,c=r.name;if(!a.modifiersData[c]._skip){for(var m=e.mainAxis,v=void 0===m||m,S=e.altAxis,A=void 0===S||S,H=e.fallbackPlacements,q=e.padding,ae=e.boundary,ze=e.rootBoundary,Se=e.altBoundary,Ne=e.flipVariations,Ee=void 0===Ne||Ne,Ve=e.allowedAutoPlacements,Mn=a.options.placement,hn=Qa(Mn),rt=H||(hn!==Mn&&Ee?function co(r){if(Qa(r)===O2)return[];var a=Eo(r);return[vc(r),a,vc(a)]}(Mn):[Eo(Mn)]),nt=[Mn].concat(rt).reduce(function($1,Ps){return $1.concat(Qa(Ps)===O2?function Sc(r,a){void 0===a&&(a={});var m=a.boundary,v=a.rootBoundary,S=a.padding,A=a.flipVariations,H=a.allowedAutoPlacements,q=void 0===H?bc:H,ae=Zr(a.placement),ze=ae?A?cs:cs.filter(function(Ee){return Zr(Ee)===ae}):r2,Se=ze.filter(function(Ee){return q.indexOf(Ee)>=0});0===Se.length&&(Se=ze);var Ne=Se.reduce(function(Ee,Ve){return Ee[Ve]=Gs(r,{placement:Ve,boundary:m,rootBoundary:v,padding:S})[Qa(Ve)],Ee},{});return Object.keys(Ne).sort(function(Ee,Ve){return Ne[Ee]-Ne[Ve]})}(a,{placement:Ps,boundary:ae,rootBoundary:ze,padding:q,flipVariations:Ee,allowedAutoPlacements:Ve}):Ps)},[]),p1=a.rects.reference,Qt=a.rects.popper,Vt=new Map,Kt=!0,ui=nt[0],fi=0;fi<nt.length;fi++){var Ii=nt[fi],Yr=Qa(Ii),Fa=Zr(Ii)===C2,l3=[vt,Va].indexOf(Yr)>=0,d3=l3?"width":"height",Tn=Gs(a,{placement:Ii,boundary:ae,rootBoundary:ze,altBoundary:Se,padding:q}),Zn=l3?Fa?Br:Ja:Fa?Va:vt;p1[d3]>Qt[d3]&&(Zn=Eo(Zn));var pt=Eo(Zn),Jt=[];if(v&&Jt.push(Tn[Yr]<=0),A&&Jt.push(Tn[Zn]<=0,Tn[pt]<=0),Jt.every(function($1){return $1})){ui=Ii,Kt=!1;break}Vt.set(Ii,Jt)}if(Kt)for(var $2=function(Ps){var Dl=nt.find(function(ir){var A2=Vt.get(ir);if(A2)return A2.slice(0,Ps).every(function(Xo){return Xo})});if(Dl)return ui=Dl,"break"},fr=Ee?3:1;fr>0&&"break"!==$2(fr);fr--);a.placement!==ui&&(a.modifiersData[c]._skip=!0,a.placement=ui,a.reset=!0)}},requiresIfExists:["offset"],data:{_skip:!1}};function Oo(r,a,e){return Ka(r,jo(a,e))}function lo(r){var a=ko(r),e=r.offsetWidth,c=r.offsetHeight;return Math.abs(a.width-e)<=1&&(e=a.width),Math.abs(a.height-c)<=1&&(c=a.height),{x:r.offsetLeft,y:r.offsetTop,width:e,height:c}}const Tl={name:"preventOverflow",enabled:!0,phase:"main",fn:function Ll(r){var a=r.state,e=r.options,c=r.name,m=e.mainAxis,v=void 0===m||m,S=e.altAxis,A=void 0!==S&&S,Se=e.tether,Ne=void 0===Se||Se,Ee=e.tetherOffset,Ve=void 0===Ee?0:Ee,Mn=Gs(a,{boundary:e.boundary,rootBoundary:e.rootBoundary,padding:e.padding,altBoundary:e.altBoundary}),hn=Qa(a.placement),bn=Zr(a.placement),rt=!bn,nt=ps(hn),p1=function Io(r){return"x"===r?"y":"x"}(nt),Qt=a.modifiersData.popperOffsets,Vt=a.rects.reference,Kt=a.rects.popper,ui="function"==typeof Ve?Ve(Object.assign({},a.rects,{placement:a.placement})):Ve,fi="number"==typeof ui?{mainAxis:ui,altAxis:ui}:Object.assign({mainAxis:0,altAxis:0},ui),Ii=a.modifiersData.offset?a.modifiersData.offset[a.placement]:null,Yr={x:0,y:0};if(Qt){if(v){var Fa,l3="y"===nt?vt:Ja,d3="y"===nt?Va:Br,Tn="y"===nt?"height":"width",Zn=Qt[nt],pt=Zn+Mn[l3],Jt=Zn-Mn[d3],pa=Ne?-Kt[Tn]/2:0,$2=bn===C2?Vt[Tn]:Kt[Tn],fr=bn===C2?-Kt[Tn]:-Vt[Tn],_o=a.elements.arrow,$1=Ne&&_o?lo(_o):{width:0,height:0},Ps=a.modifiersData["arrow#persistent"]?a.modifiersData["arrow#persistent"].padding:{top:0,right:0,bottom:0,left:0},Dl=Ps[l3],ir=Ps[d3],A2=Oo(0,Vt[Tn],$1[Tn]),Xo=rt?Vt[Tn]/2-pa-A2-Dl-fi.mainAxis:$2-A2-Dl-fi.mainAxis,$c=rt?-Vt[Tn]/2+pa+A2+ir+fi.mainAxis:fr+A2+ir+fi.mainAxis,El=a.elements.arrow&&_i(a.elements.arrow),Qg=null!=(Fa=null==Ii?void 0:Ii[nt])?Fa:0,T_=Zn+$c-Qg,Jg=Oo(Ne?jo(pt,Zn+Xo-Qg-(El?"y"===nt?El.clientTop||0:El.clientLeft||0:0)):pt,Zn,Ne?Ka(Jt,T_):Jt);Qt[nt]=Jg,Yr[nt]=Jg-Zn}if(A){var Kg,Al=Qt[p1],Df="y"===p1?"height":"width",ev=Al+Mn["x"===nt?vt:Ja],nv=Al-Mn["x"===nt?Va:Br],Nh=-1!==[vt,Ja].indexOf(hn),tv=null!=(Kg=null==Ii?void 0:Ii[p1])?Kg:0,iv=Nh?ev:Al-Vt[Df]-Kt[Df]-tv+fi.altAxis,av=Nh?Al+Vt[Df]+Kt[Df]-tv-fi.altAxis:nv,rv=Ne&&Nh?function Mc(r,a,e){var c=Oo(r,a,e);return c>e?e:c}(iv,Al,av):Oo(Ne?iv:ev,Al,Ne?av:nv);Qt[p1]=rv,Yr[p1]=rv-Al}a.modifiersData[c]=Yr}},requiresIfExists:["offset"]},wc={name:"arrow",enabled:!0,phase:"main",fn:function Zs(r){var a,e=r.state,c=r.name,m=r.options,v=e.elements.arrow,S=e.modifiersData.popperOffsets,A=Qa(e.placement),H=ps(A),ae=[Ja,Br].indexOf(A)>=0?"height":"width";if(v&&S){var ze=function(a,e){return ms("number"!=typeof(a="function"==typeof a?a(Object.assign({},e.rects,{placement:e.placement})):a)?a:so(a,r2))}(m.padding,e),Se=lo(v),Ne="y"===H?vt:Ja,Ee="y"===H?Va:Br,Ve=e.rects.reference[ae]+e.rects.reference[H]-S[H]-e.rects.popper[ae],Mn=S[H]-e.rects.reference[H],hn=_i(v),bn=hn?"y"===H?hn.clientHeight||0:hn.clientWidth||0:0,Qt=bn/2-Se[ae]/2+(Ve/2-Mn/2),Vt=Oo(ze[Ne],Qt,bn-Se[ae]-ze[Ee]);e.modifiersData[c]=((a={})[H]=Vt,a.centerOffset=Vt-Qt,a)}},effect:function $s(r){var a=r.state,c=r.options.element,m=void 0===c?"[data-popper-arrow]":c;null!=m&&("string"==typeof m&&!(m=a.elements.popper.querySelector(m))||!Wr(a.elements.popper,m)||(a.elements.arrow=m))},requires:["popperOffsets"],requiresIfExists:["preventOverflow"]};function u4(r,a,e){void 0===e&&(e=!1);var c=lr(a),m=lr(a)&&function d4(r){var a=r.getBoundingClientRect(),e=wr(a.width)/r.offsetWidth||1,c=wr(a.height)/r.offsetHeight||1;return 1!==e||1!==c}(a),v=dr(a),S=ko(r,m),A={scrollLeft:0,scrollTop:0},H={x:0,y:0};return(c||!c&&!e)&&(("body"!==Gr(a)||s2(v))&&(A=function y3(r){return r!==Mr(r)&&lr(r)?function l4(r){return{scrollLeft:r.scrollLeft,scrollTop:r.scrollTop}}(r):yc(r)}(a)),lr(a)?((H=ko(a,!0)).x+=a.clientLeft,H.y+=a.clientTop):v&&(H.x=r4(v))),{x:S.left+A.scrollLeft-H.x,y:S.top+A.scrollTop-H.y,width:S.width,height:S.height}}function f4(r){var a=new Map,e=new Set,c=[];function m(v){e.add(v.name),[].concat(v.requires||[],v.requiresIfExists||[]).forEach(function(A){if(!e.has(A)){var H=a.get(A);H&&m(H)}}),c.push(v)}return r.forEach(function(v){a.set(v.name,v)}),r.forEach(function(v){e.has(v.name)||m(v)}),c}function zc(r){var a;return function(){return a||(a=new Promise(function(e){Promise.resolve().then(function(){a=void 0,e(r())})})),a}}var hs={placement:"bottom",modifiers:[],strategy:"absolute"};function p4(){for(var r=arguments.length,a=new Array(r),e=0;e<r;e++)a[e]=arguments[e];return!a.some(function(c){return!(c&&"function"==typeof c.getBoundingClientRect)})}function si(r){void 0===r&&(r={});var e=r.defaultModifiers,c=void 0===e?[]:e,m=r.defaultOptions,v=void 0===m?hs:m;return function(A,H,q){void 0===q&&(q=v);var ae={placement:"bottom",orderedModifiers:[],options:Object.assign({},hs,v),modifiersData:{},elements:{reference:A,popper:H},attributes:{},styles:{}},ze=[],Se=!1,Ne={state:ae,setOptions:function(hn){var bn="function"==typeof hn?hn(ae.options):hn;Ve(),ae.options=Object.assign({},v,ae.options,bn),ae.scrollParents={reference:ds(A)?Po(A):A.contextElement?Po(A.contextElement):[],popper:Po(H)};var rt=function _3(r){var a=f4(r);return To.reduce(function(e,c){return e.concat(a.filter(function(m){return m.phase===c}))},[])}(function Vo(r){var a=r.reduce(function(e,c){var m=e[c.name];return e[c.name]=m?Object.assign({},m,c,{options:Object.assign({},m.options,c.options),data:Object.assign({},m.data,c.data)}):c,e},{});return Object.keys(a).map(function(e){return a[e]})}([].concat(c,ae.options.modifiers)));return ae.orderedModifiers=rt.filter(function(Ii){return Ii.enabled}),function Ee(){ae.orderedModifiers.forEach(function(Mn){var bn=Mn.options,nt=Mn.effect;if("function"==typeof nt){var p1=nt({state:ae,name:Mn.name,instance:Ne,options:void 0===bn?{}:bn});ze.push(p1||function(){})}})}(),Ne.update()},forceUpdate:function(){if(!Se){var hn=ae.elements,bn=hn.reference,rt=hn.popper;if(p4(bn,rt)){ae.rects={reference:u4(bn,_i(rt),"fixed"===ae.options.strategy),popper:lo(rt)},ae.reset=!1,ae.placement=ae.options.placement,ae.orderedModifiers.forEach(function(Ii){return ae.modifiersData[Ii.name]=Object.assign({},Ii.data)});for(var p1=0;p1<ae.orderedModifiers.length;p1++)if(!0!==ae.reset){var Qt=ae.orderedModifiers[p1],Vt=Qt.fn,Kt=Qt.options;"function"==typeof Vt&&(ae=Vt({state:ae,options:void 0===Kt?{}:Kt,name:Qt.name,instance:Ne})||ae)}else ae.reset=!1,p1=-1}}},update:zc(function(){return new Promise(function(Mn){Ne.forceUpdate(),Mn(ae)})}),destroy:function(){Ve(),Se=!0}};if(!p4(A,H))return Ne;function Ve(){ze.forEach(function(Mn){return Mn()}),ze=[]}return Ne.setOptions(q).then(function(Mn){!Se&&q.onFirstUpdate&&q.onFirstUpdate(Mn)}),Ne}}var Xs={passive:!0},Nc={top:"auto",right:"auto",bottom:"auto",left:"auto"};function v4(r){var a,e=r.popper,c=r.popperRect,m=r.placement,v=r.variation,S=r.offsets,A=r.position,H=r.gpuAcceleration,q=r.adaptive,ae=r.roundOffsets,ze=r.isFixed,Se=S.x,Ne=void 0===Se?0:Se,Ee=S.y,Ve=void 0===Ee?0:Ee,Mn="function"==typeof ae?ae({x:Ne,y:Ve}):{x:Ne,y:Ve};Ne=Mn.x,Ve=Mn.y;var hn=S.hasOwnProperty("x"),bn=S.hasOwnProperty("y"),rt=Ja,nt=vt,p1=window;if(q){var Qt=_i(e),Vt="clientHeight",Kt="clientWidth";Qt===Mr(e)&&"static"!==zr(Qt=dr(e)).position&&"absolute"===A&&(Vt="scrollHeight",Kt="scrollWidth"),Qt=Qt,(m===vt||(m===Ja||m===Br)&&v===Ao)&&(nt=Va,Ve-=(ze&&p1.visualViewport?p1.visualViewport.height:Qt[Vt])-c.height,Ve*=H?1:-1),m!==Ja&&(m!==vt&&m!==Va||v!==Ao)||(rt=Br,Ne-=(ze&&p1.visualViewport?p1.visualViewport.width:Qt[Kt])-c.width,Ne*=H?1:-1)}var Fa,Ii=Object.assign({position:A},q&&Nc),Yr=!0===ae?function g4(r){var e=r.y,m=window.devicePixelRatio||1;return{x:wr(r.x*m)/m||0,y:wr(e*m)/m||0}}({x:Ne,y:Ve}):{x:Ne,y:Ve};return Ne=Yr.x,Ve=Yr.y,Object.assign({},Ii,H?((Fa={})[nt]=bn?"0":"",Fa[rt]=hn?"0":"",Fa.transform=(p1.devicePixelRatio||1)<=1?"translate("+Ne+"px, "+Ve+"px)":"translate3d("+Ne+"px, "+Ve+"px, 0)",Fa):((a={})[nt]=bn?Ve+"px":"",a[rt]=hn?Ne+"px":"",a.transform="",a))}var _4=si({defaultModifiers:[{name:"eventListeners",enabled:!0,phase:"write",fn:function(){},effect:function Ys(r){var a=r.state,e=r.instance,c=r.options,m=c.scroll,v=void 0===m||m,S=c.resize,A=void 0===S||S,H=Mr(a.elements.popper),q=[].concat(a.scrollParents.reference,a.scrollParents.popper);return v&&q.forEach(function(ae){ae.addEventListener("scroll",e.update,Xs)}),A&&H.addEventListener("resize",e.update,Xs),function(){v&&q.forEach(function(ae){ae.removeEventListener("scroll",e.update,Xs)}),A&&H.removeEventListener("resize",e.update,Xs)}},data:{}},{name:"popperOffsets",enabled:!0,phase:"read",fn:function S3(r){var a=r.state;a.modifiersData[r.name]=xc({reference:a.rects.reference,element:a.rects.popper,strategy:"absolute",placement:a.placement})},data:{}},{name:"computeStyles",enabled:!0,phase:"beforeWrite",fn:function M3(r){var a=r.state,e=r.options,c=e.gpuAcceleration,m=void 0===c||c,v=e.adaptive,S=void 0===v||v,A=e.roundOffsets,H=void 0===A||A,ae={placement:Qa(a.placement),variation:Zr(a.placement),popper:a.elements.popper,popperRect:a.rects.popper,gpuAcceleration:m,isFixed:"fixed"===a.options.strategy};null!=a.modifiersData.popperOffsets&&(a.styles.popper=Object.assign({},a.styles.popper,v4(Object.assign({},ae,{offsets:a.modifiersData.popperOffsets,position:a.options.strategy,adaptive:S,roundOffsets:H})))),null!=a.modifiersData.arrow&&(a.styles.arrow=Object.assign({},a.styles.arrow,v4(Object.assign({},ae,{offsets:a.modifiersData.arrow,position:"absolute",adaptive:!1,roundOffsets:H})))),a.attributes.popper=Object.assign({},a.attributes.popper,{"data-popper-placement":a.placement})},data:{}},{name:"applyStyles",enabled:!0,phase:"write",fn:function Ho(r){var a=r.state;Object.keys(a.elements).forEach(function(e){var c=a.styles[e]||{},m=a.attributes[e]||{},v=a.elements[e];!lr(v)||!Gr(v)||(Object.assign(v.style,c),Object.keys(m).forEach(function(S){var A=m[S];!1===A?v.removeAttribute(S):v.setAttribute(S,!0===A?"":A)}))})},effect:function Gi(r){var a=r.state,e={popper:{position:a.options.strategy,left:"0",top:"0",margin:"0"},arrow:{position:"absolute"},reference:{}};return Object.assign(a.elements.popper.style,e.popper),a.styles=e,a.elements.arrow&&Object.assign(a.elements.arrow.style,e.arrow),function(){Object.keys(a.elements).forEach(function(c){var m=a.elements[c],v=a.attributes[c]||{},A=Object.keys(a.styles.hasOwnProperty(c)?a.styles[c]:e[c]).reduce(function(H,q){return H[q]="",H},{});!lr(m)||!Gr(m)||(Object.assign(m.style,A),Object.keys(v).forEach(function(H){m.removeAttribute(H)}))})}},requires:["computeStyles"]}]});const C4=["*"],Ge=["dialog"];function xs(r){return null!=r}function fo(r){return(r||document.body).getBoundingClientRect()}"undefined"!=typeof Element&&!Element.prototype.closest&&(Element.prototype.closest=function(r){let a=this;if(!document.documentElement.contains(a))return null;do{if(a.matches(r))return a;a=a.parentElement||a.parentNode}while(null!==a&&1===a.nodeType);return null});const z4={animation:!0,transitionTimerDelayMs:5},po=()=>{},{transitionTimerDelayMs:j3}=z4,Ks=new Map,Sa=(r,a,e,c)=>{let m=c.context||{};const v=Ks.get(a);if(v)switch(c.runningTransition){case"continue":return te.E;case"stop":r.run(()=>v.transition$.complete()),m=Object.assign(v.context,m),Ks.delete(a)}const S=e(a,c.animation,m)||po;if(!c.animation||"none"===window.getComputedStyle(a).transitionProperty)return r.run(()=>S()),(0,vi.of)(void 0).pipe(function w2(r){return a=>new qi.y(e=>a.subscribe({next:S=>r.run(()=>e.next(S)),error:S=>r.run(()=>e.error(S)),complete:()=>r.run(()=>e.complete())}))}(r));const A=new se.xQ,H=new se.xQ,q=A.pipe(function Yc(...r){return a=>(0,Rs.z)(a,(0,vi.of)(...r))}(!0));Ks.set(a,{transition$:A,complete:()=>{H.next(),H.complete()},context:m});const ae=function w8(r){const{transitionDelay:a,transitionDuration:e}=window.getComputedStyle(r);return 1e3*(parseFloat(a)+parseFloat(e))}(a);return r.runOutsideAngular(()=>{const ze=un(a,"transitionend").pipe(G1(q),(0,Ia.h)(({target:Ne})=>Ne===a));pc(function eo(r=0,a,e){let c=-1;return y2(a)?c=Number(a)<1?1:Number(a):(0,Fr.K)(a)&&(e=a),(0,Fr.K)(e)||(e=Cr),new qi.y(m=>{const v=y2(r)?r:+r-e.now();return e.schedule(uc,v,{index:0,period:c,subscriber:m})})}(ae+j3).pipe(G1(q)),ze,H).pipe(G1(q)).subscribe(()=>{Ks.delete(a),r.run(()=>{S(),A.next(),A.complete()})})}),A.asObservable()},Zl=(r,a,e)=>{let{direction:c,maxHeight:m}=e;const{classList:v}=r;function S(){v.add("collapse"),"show"===c?v.add("show"):v.remove("show")}if(a)return m||(m=function Wl(r){if("undefined"==typeof navigator)return"0px";const{classList:a}=r,e=a.contains("show");e||a.add("show"),r.style.height="";const c=r.getBoundingClientRect().height+"px";return e||a.remove("show"),c}(r),e.maxHeight=m,r.style.height="show"!==c?m:"0px",v.remove("collapse"),v.remove("collapsing"),v.remove("show"),fo(r),v.add("collapsing")),r.style.height="show"===c?m:"0px",()=>{S(),v.remove("collapsing"),r.style.height=""};S()};let qo=(()=>{class r{constructor(){this.animation=z4.animation}}return r.\u0275fac=function(e){return new(e||r)},r.\u0275prov=d.Yz7({token:r,factory:r.\u0275fac,providedIn:"root"}),r})(),I3=(()=>{class r{}return r.\u0275fac=function(e){return new(e||r)},r.\u0275mod=d.oAB({type:r}),r.\u0275inj=d.cJS({imports:[[Hn.ez]]}),r})(),O3=(()=>{class r{}return r.\u0275fac=function(e){return new(e||r)},r.\u0275mod=d.oAB({type:r}),r.\u0275inj=d.cJS({imports:[[Hn.ez]]}),r})(),E8=(()=>{class r{}return r.\u0275fac=function(e){return new(e||r)},r.\u0275mod=d.oAB({type:r}),r.\u0275inj=d.cJS({}),r})(),L4=(()=>{class r{}return r.\u0275fac=function(e){return new(e||r)},r.\u0275mod=d.oAB({type:r}),r.\u0275inj=d.cJS({imports:[[Hn.ez]]}),r})(),T8=(()=>{class r{constructor(e){this._ngbConfig=e}get animation(){return void 0===this._animation?this._ngbConfig.animation:this._animation}set animation(e){this._animation=e}}return r.\u0275fac=function(e){return new(e||r)(d.LFG(qo))},r.\u0275prov=d.Yz7({token:r,factory:r.\u0275fac,providedIn:"root"}),r})(),Uo=(()=>{class r{constructor(e,c,m){this._element=e,this._zone=m,this.collapsed=!1,this.ngbCollapseChange=new d.vpe,this.shown=new d.vpe,this.hidden=new d.vpe,this.animation=c.animation}ngOnInit(){this._runTransition(this.collapsed,!1)}ngOnChanges({collapsed:e}){e.firstChange||this._runTransitionWithEvents(this.collapsed,this.animation)}toggle(e=this.collapsed){this.collapsed=!e,this.ngbCollapseChange.next(this.collapsed),this._runTransitionWithEvents(this.collapsed,this.animation)}_runTransition(e,c){return Sa(this._zone,this._element.nativeElement,Zl,{animation:c,runningTransition:"stop",context:{direction:e?"hide":"show"}})}_runTransitionWithEvents(e,c){this._runTransition(e,c).subscribe(()=>{e?this.hidden.emit():this.shown.emit()})}}return r.\u0275fac=function(e){return new(e||r)(d.Y36(d.SBq),d.Y36(T8),d.Y36(d.R0b))},r.\u0275dir=d.lG2({type:r,selectors:[["","ngbCollapse",""]],inputs:{animation:"animation",collapsed:["ngbCollapse","collapsed"]},outputs:{ngbCollapseChange:"ngbCollapseChange",shown:"shown",hidden:"hidden"},exportAs:["ngbCollapse"],features:[d.TTD]}),r})(),F3=(()=>{class r{}return r.\u0275fac=function(e){return new(e||r)},r.\u0275mod=d.oAB({type:r}),r.\u0275inj=d.cJS({}),r})();var Ma=(()=>{return(r=Ma||(Ma={}))[r.Tab=9]="Tab",r[r.Enter=13]="Enter",r[r.Escape=27]="Escape",r[r.Space=32]="Space",r[r.PageUp=33]="PageUp",r[r.PageDown=34]="PageDown",r[r.End=35]="End",r[r.Home=36]="Home",r[r.ArrowLeft=37]="ArrowLeft",r[r.ArrowUp=38]="ArrowUp",r[r.ArrowRight=39]="ArrowRight",r[r.ArrowDown=40]="ArrowDown",Ma;var r})();const ec=(r,a)=>!!a&&a.some(e=>e.contains(r)),B3=(r,a)=>!a||null!=function Gl(r,a){return a&&void 0!==r.closest?r.closest(a):null}(r,a),q8="undefined"!=typeof navigator&&!!navigator.userAgent&&(/iPad|iPhone|iPod/.test(navigator.userAgent)||/Macintosh/.test(navigator.userAgent)&&navigator.maxTouchPoints&&navigator.maxTouchPoints>2||/Android/.test(navigator.userAgent));function U8(r,a,e,c,m,v,S,A){e&&r.runOutsideAngular((r=>q8?()=>setTimeout(()=>r(),100):r)(()=>{const q=un(a,"keydown").pipe(G1(m),(0,Ia.h)(Se=>Se.which===Ma.Escape),(0,ts.b)(Se=>Se.preventDefault())),ae=un(a,"mousedown").pipe((0,R1.U)(Se=>{const Ne=Se.target;return 2!==Se.button&&!ec(Ne,S)&&("inside"===e?ec(Ne,v)&&B3(Ne,A):"outside"===e?!ec(Ne,v):B3(Ne,A)||!ec(Ne,v))}),G1(m)),ze=un(a,"mouseup").pipe(is(ae),(0,Ia.h)(([Se,Ne])=>Ne),function m3(r,a=Cr){const c=function Kc(r){return r instanceof Date&&!isNaN(+r)}(r)?+r-a.now():Math.abs(r);return m=>m.lift(new as(c,a))}(0),G1(m));pc([q.pipe((0,R1.U)(Se=>0)),ze.pipe((0,R1.U)(Se=>1))]).subscribe(Se=>r.run(()=>c(Se)))}))}const U3=["a[href]","button:not([disabled])",'input:not([disabled]):not([type="hidden"])',"select:not([disabled])","textarea:not([disabled])","[contenteditable]",'[tabindex]:not([tabindex="-1"])'].join(", ");function r0(r){const a=Array.from(r.querySelectorAll(U3)).filter(e=>-1!==e.tabIndex);return[a[0],a[a.length-1]]}const G8=/\s+/,W8=/  +/gi,s0=/^start/,c0=/^end/,Z8=/-(top|left)$/,U2=/-(bottom|right)$/,$8=/^left/,l0=/^right/,Fu=/^start/,d0=/^end/;function u0({placement:r,baseClass:a}){let e=Array.isArray(r)?r:r.split(G8),m=e.findIndex(H=>"auto"===H);m>=0&&["top","bottom","start","end","top-start","top-end","bottom-start","bottom-end","start-top","start-bottom","end-top","end-bottom"].forEach(function(H){null==e.find(q=>-1!==q.search("^"+H))&&e.splice(m++,1,H)});const v=e.map(H=>function G3(r){return r.replace(s0,"left").replace(c0,"right").replace(Z8,"-start").replace(U2,"-end")}(H));return{placement:v.shift(),modifiers:[{name:"bootstrapClasses",enabled:!!a,phase:"write",fn({state:H}){const q=new RegExp(a+"-[a-z]+","gi"),ae=H.elements.popper,ze=H.placement;let Se=ae.className;Se=Se.replace(q,""),Se+=` ${function X8(r,a){let[e,c]=a.split("-");const m=e.replace($8,"start").replace(l0,"end");let v=[m];if(c){let S=c;("left"===e||"right"===e)&&(S=S.replace(Fu,"top").replace(d0,"bottom")),v.push(`${m}-${S}`)}return r&&(v=v.map(S=>`${r}-${S}`)),v.join(" ")}(a,ze)}`,Se=Se.trim().replace(W8," "),ae.className=Se}},er,Tl,wc,{enabled:!0,name:"flip",options:{fallbackPlacements:v}},{enabled:!0,name:"preventOverflow",phase:"main",fn:function(){}}]}}function W3(r){return r}new Date(1882,10,12),new Date(2174,10,25);let tl=(()=>{class r{}return r.\u0275fac=function(e){return new(e||r)},r.\u0275mod=d.oAB({type:r}),r.\u0275inj=d.cJS({imports:[[Hn.ez,N1.u5]]}),r})(),a7=(()=>{class r{constructor(){this.autoClose=!0,this.placement=["bottom-start","bottom-end","top-start","top-end"]}}return r.\u0275fac=function(e){return new(e||r)},r.\u0275prov=d.Yz7({token:r,factory:r.\u0275fac,providedIn:"root"}),r})(),f2=(()=>{class r{}return r.\u0275fac=function(e){return new(e||r)},r.\u0275dir=d.lG2({type:r,selectors:[["",8,"navbar"]]}),r})(),d5=(()=>{class r{constructor(e){this.elementRef=e,this._disabled=!1}set disabled(e){this._disabled=""===e||!0===e}get disabled(){return this._disabled}}return r.\u0275fac=function(e){return new(e||r)(d.Y36(d.SBq))},r.\u0275dir=d.lG2({type:r,selectors:[["","ngbDropdownItem",""]],hostAttrs:[1,"dropdown-item"],hostVars:2,hostBindings:function(e,c){2&e&&d.ekj("disabled",c.disabled)},inputs:{disabled:"disabled"}}),r})(),b0=(()=>{class r{constructor(e,c){this.dropdown=e,this.placement="bottom",this.isOpen=!1,this.nativeElement=c.nativeElement}}return r.\u0275fac=function(e){return new(e||r)(d.Y36((0,d.Gpc)(()=>ac)),d.Y36(d.SBq))},r.\u0275dir=d.lG2({type:r,selectors:[["","ngbDropdownMenu",""]],contentQueries:function(e,c,m){if(1&e&&d.Suo(m,d5,4),2&e){let v;d.iGM(v=d.CRH())&&(c.menuItems=v)}},hostVars:5,hostBindings:function(e,c){1&e&&d.NdJ("keydown.ArrowUp",function(v){return c.dropdown.onKeyDown(v)})("keydown.ArrowDown",function(v){return c.dropdown.onKeyDown(v)})("keydown.Home",function(v){return c.dropdown.onKeyDown(v)})("keydown.End",function(v){return c.dropdown.onKeyDown(v)})("keydown.Enter",function(v){return c.dropdown.onKeyDown(v)})("keydown.Space",function(v){return c.dropdown.onKeyDown(v)})("keydown.Tab",function(v){return c.dropdown.onKeyDown(v)})("keydown.Shift.Tab",function(v){return c.dropdown.onKeyDown(v)}),2&e&&(d.uIk("data-popper",c.placement),d.ekj("dropdown-menu",!0)("show",c.dropdown.isOpen()))}}),r})(),Rc=(()=>{class r{constructor(e,c){this.dropdown=e,this.nativeElement=c.nativeElement}}return r.\u0275fac=function(e){return new(e||r)(d.Y36((0,d.Gpc)(()=>ac)),d.Y36(d.SBq))},r.\u0275dir=d.lG2({type:r,selectors:[["","ngbDropdownAnchor",""]],hostAttrs:[1,"dropdown-toggle"],hostVars:1,hostBindings:function(e,c){2&e&&d.uIk("aria-expanded",c.dropdown.isOpen())}}),r})(),il=(()=>{class r extends Rc{constructor(e,c){super(e,c)}}return r.\u0275fac=function(e){return new(e||r)(d.Y36((0,d.Gpc)(()=>ac)),d.Y36(d.SBq))},r.\u0275dir=d.lG2({type:r,selectors:[["","ngbDropdownToggle",""]],hostAttrs:[1,"dropdown-toggle"],hostVars:1,hostBindings:function(e,c){1&e&&d.NdJ("click",function(){return c.dropdown.toggle()})("keydown.ArrowUp",function(v){return c.dropdown.onKeyDown(v)})("keydown.ArrowDown",function(v){return c.dropdown.onKeyDown(v)})("keydown.Home",function(v){return c.dropdown.onKeyDown(v)})("keydown.End",function(v){return c.dropdown.onKeyDown(v)})("keydown.Tab",function(v){return c.dropdown.onKeyDown(v)})("keydown.Shift.Tab",function(v){return c.dropdown.onKeyDown(v)}),2&e&&d.uIk("aria-expanded",c.dropdown.isOpen())},features:[d._Bn([{provide:Rc,useExisting:(0,d.Gpc)(()=>r)}]),d.qOj]}),r})(),ac=(()=>{class r{constructor(e,c,m,v,S,A,H){this._changeDetector=e,this._document=m,this._ngZone=v,this._elementRef=S,this._renderer=A,this._closed$=new se.xQ,this._bodyContainer=null,this._positioning=function Z3(){let r=null;return{createPopper(a){if(!r){let c=(a.updatePopperOptions||W3)(u0(a));r=_4(a.hostElement,a.targetElement,c)}},update(){r&&r.update()},setOptions(a){if(r){let c=(a.updatePopperOptions||W3)(u0(a));r.setOptions(c)}},destroy(){r&&(r.destroy(),r=null)}}}(),this._open=!1,this.openChange=new d.vpe,this.placement=c.placement,this.container=c.container,this.autoClose=c.autoClose,this.display=H?"static":"dynamic",this._zoneSubscription=v.onStable.subscribe(()=>{this._positionMenu()})}ngAfterContentInit(){this._ngZone.onStable.pipe((0,Sr.q)(1)).subscribe(()=>{this._applyPlacementClasses(),this._open&&this._setCloseHandlers()})}ngOnChanges(e){if(e.container&&this._open&&this._applyContainer(this.container),e.placement&&!e.placement.firstChange&&(this._positioning.setOptions({hostElement:this._anchor.nativeElement,targetElement:this._bodyContainer||this._menu.nativeElement,placement:this.placement,appendToBody:"body"===this.container}),this._applyPlacementClasses()),e.dropdownClass){const{currentValue:c,previousValue:m}=e.dropdownClass;this._applyCustomDropdownClass(c,m)}}isOpen(){return this._open}open(){this._open||(this._open=!0,this._applyContainer(this.container),this.openChange.emit(!0),this._setCloseHandlers(),this._anchor&&(this._anchor.nativeElement.focus(),"dynamic"===this.display&&this._ngZone.onStable.pipe((0,Sr.q)(1)).subscribe(()=>{this._positioning.createPopper({hostElement:this._anchor.nativeElement,targetElement:this._bodyContainer||this._menu.nativeElement,placement:this.placement,appendToBody:"body"===this.container}),this._applyPlacementClasses()})))}_setCloseHandlers(){U8(this._ngZone,this._document,this.autoClose,e=>{this.close(),0===e&&this._anchor.nativeElement.focus()},this._closed$,this._menu?[this._menu.nativeElement]:[],this._anchor?[this._anchor.nativeElement]:[],".dropdown-item,.dropdown-divider")}close(){this._open&&(this._open=!1,this._positioning.destroy(),this._resetContainer(),this._closed$.next(),this.openChange.emit(!1),this._changeDetector.markForCheck())}toggle(){this.isOpen()?this.close():this.open()}ngOnDestroy(){this._resetContainer(),this._closed$.next(),this._zoneSubscription.unsubscribe()}onKeyDown(e){const c=e.which,m=this._getMenuElements();let v=-1,S=null;const A=this._isEventFromToggle(e);if(!A&&m.length&&m.forEach((H,q)=>{H.contains(e.target)&&(S=H),H===this._document.activeElement&&(v=q)}),c!==Ma.Space&&c!==Ma.Enter){if(c!==Ma.Tab){if(A||S){if(this.open(),m.length){switch(c){case Ma.ArrowDown:v=Math.min(v+1,m.length-1);break;case Ma.ArrowUp:if(this._isDropup()&&-1===v){v=m.length-1;break}v=Math.max(v-1,0);break;case Ma.Home:v=0;break;case Ma.End:v=m.length-1}m[v].focus()}e.preventDefault()}}else if(e.target&&this.isOpen()&&this.autoClose){if(this._anchor.nativeElement===e.target)return void("body"!==this.container||e.shiftKey?e.shiftKey&&this.close():(this._renderer.setAttribute(this._menu.nativeElement,"tabindex","0"),this._menu.nativeElement.focus(),this._renderer.removeAttribute(this._menu.nativeElement,"tabindex")));if("body"===this.container){const H=this._menu.nativeElement.querySelectorAll(U3);e.shiftKey&&e.target===H[0]?(this._anchor.nativeElement.focus(),e.preventDefault()):!e.shiftKey&&e.target===H[H.length-1]&&(this._anchor.nativeElement.focus(),this.close())}else un(e.target,"focusout").pipe((0,Sr.q)(1)).subscribe(({relatedTarget:H})=>{this._elementRef.nativeElement.contains(H)||this.close()})}}else S&&(!0===this.autoClose||"inside"===this.autoClose)&&un(S,"click").pipe((0,Sr.q)(1)).subscribe(()=>this.close())}_isDropup(){return this._elementRef.nativeElement.classList.contains("dropup")}_isEventFromToggle(e){return this._anchor.nativeElement.contains(e.target)}_getMenuElements(){const e=this._menu;return null==e?[]:e.menuItems.filter(c=>!c.disabled).map(c=>c.elementRef.nativeElement)}_positionMenu(){const e=this._menu;this.isOpen()&&e&&("dynamic"===this.display?(this._positioning.update(),this._applyPlacementClasses()):this._applyPlacementClasses(this._getFirstPlacement(this.placement)))}_getFirstPlacement(e){return Array.isArray(e)?e[0]:e.split(" ")[0]}_resetContainer(){const e=this._renderer;this._menu&&e.appendChild(this._elementRef.nativeElement,this._menu.nativeElement),this._bodyContainer&&(e.removeChild(this._document.body,this._bodyContainer),this._bodyContainer=null)}_applyContainer(e=null){if(this._resetContainer(),"body"===e){const c=this._renderer,m=this._menu.nativeElement,v=this._bodyContainer=this._bodyContainer||c.createElement("div");c.setStyle(v,"position","absolute"),c.setStyle(m,"position","static"),c.setStyle(v,"z-index","1050"),c.appendChild(v,m),c.appendChild(this._document.body,v)}this._applyCustomDropdownClass(this.dropdownClass)}_applyCustomDropdownClass(e,c){const m="body"===this.container?this._bodyContainer:this._elementRef.nativeElement;m&&(c&&this._renderer.removeClass(m,c),e&&this._renderer.addClass(m,e))}_applyPlacementClasses(e){const c=this._menu;if(c){e||(e=this._getFirstPlacement(this.placement));const m=this._renderer,v=this._elementRef.nativeElement;m.removeClass(v,"dropup"),m.removeClass(v,"dropdown"),c.placement="static"===this.display?null:e;const S=-1!==e.search("^top")?"dropup":"dropdown";m.addClass(v,S);const A=this._bodyContainer;A&&(m.removeClass(A,"dropup"),m.removeClass(A,"dropdown"),m.addClass(A,S))}}}return r.\u0275fac=function(e){return new(e||r)(d.Y36(d.sBO),d.Y36(a7),d.Y36(Hn.K0),d.Y36(d.R0b),d.Y36(d.SBq),d.Y36(d.Qsj),d.Y36(f2,8))},r.\u0275dir=d.lG2({type:r,selectors:[["","ngbDropdown",""]],contentQueries:function(e,c,m){if(1&e&&(d.Suo(m,b0,5),d.Suo(m,Rc,5)),2&e){let v;d.iGM(v=d.CRH())&&(c._menu=v.first),d.iGM(v=d.CRH())&&(c._anchor=v.first)}},hostVars:2,hostBindings:function(e,c){2&e&&d.ekj("show",c.isOpen())},inputs:{autoClose:"autoClose",dropdownClass:"dropdownClass",_open:["open","_open"],placement:"placement",container:"container",display:"display"},outputs:{openChange:"openChange"},exportAs:["ngbDropdown"],features:[d.TTD]}),r})(),u5=(()=>{class r{}return r.\u0275fac=function(e){return new(e||r)},r.\u0275mod=d.oAB({type:r}),r.\u0275inj=d.cJS({}),r})();class Zo{constructor(a,e,c){this.nodes=a,this.viewRef=e,this.componentRef=c}}let f5=(()=>{class r{constructor(e,c){this._el=e,this._zone=c}ngOnInit(){this._zone.onStable.asObservable().pipe((0,Sr.q)(1)).subscribe(()=>{Sa(this._zone,this._el.nativeElement,(e,c)=>{c&&fo(e),e.classList.add("show")},{animation:this.animation,runningTransition:"continue"})})}hide(){return Sa(this._zone,this._el.nativeElement,({classList:e})=>e.remove("show"),{animation:this.animation,runningTransition:"stop"})}}return r.\u0275fac=function(e){return new(e||r)(d.Y36(d.SBq),d.Y36(d.R0b))},r.\u0275cmp=d.Xpm({type:r,selectors:[["ngb-modal-backdrop"]],hostAttrs:[2,"z-index","1050"],hostVars:6,hostBindings:function(e,c){2&e&&(d.Tol("modal-backdrop"+(c.backdropClass?" "+c.backdropClass:"")),d.ekj("show",!c.animation)("fade",c.animation))},inputs:{animation:"animation",backdropClass:"backdropClass"},decls:0,vars:0,template:function(e,c){},encapsulation:2}),r})();class R4{close(a){}dismiss(a){}}class p5{constructor(a,e,c,m){this._windowCmptRef=a,this._contentRef=e,this._backdropCmptRef=c,this._beforeDismiss=m,this._closed=new se.xQ,this._dismissed=new se.xQ,this._hidden=new se.xQ,a.instance.dismissEvent.subscribe(v=>{this.dismiss(v)}),this.result=new Promise((v,S)=>{this._resolve=v,this._reject=S}),this.result.then(null,()=>{})}get componentInstance(){if(this._contentRef&&this._contentRef.componentRef)return this._contentRef.componentRef.instance}get closed(){return this._closed.asObservable().pipe(G1(this._hidden))}get dismissed(){return this._dismissed.asObservable().pipe(G1(this._hidden))}get hidden(){return this._hidden.asObservable()}get shown(){return this._windowCmptRef.instance.shown.asObservable()}close(a){this._windowCmptRef&&(this._closed.next(a),this._resolve(a),this._removeModalElements())}_dismiss(a){this._dismissed.next(a),this._reject(a),this._removeModalElements()}dismiss(a){if(this._windowCmptRef)if(this._beforeDismiss){const e=this._beforeDismiss();!function x8(r){return r&&r.then}(e)?!1!==e&&this._dismiss(a):e.then(c=>{!1!==c&&this._dismiss(a)},()=>{})}else this._dismiss(a)}_removeModalElements(){const a=this._windowCmptRef.instance.hide(),e=this._backdropCmptRef?this._backdropCmptRef.instance.hide():(0,vi.of)(void 0);a.subscribe(()=>{const{nativeElement:c}=this._windowCmptRef.location;c.parentNode.removeChild(c),this._windowCmptRef.destroy(),this._contentRef&&this._contentRef.viewRef&&this._contentRef.viewRef.destroy(),this._windowCmptRef=null,this._contentRef=null}),e.subscribe(()=>{if(this._backdropCmptRef){const{nativeElement:c}=this._backdropCmptRef.location;c.parentNode.removeChild(c),this._backdropCmptRef.destroy(),this._backdropCmptRef=null}}),xa(a,e).subscribe(()=>{this._hidden.next(),this._hidden.complete()})}}var Ss=(()=>{return(r=Ss||(Ss={}))[r.BACKDROP_CLICK=0]="BACKDROP_CLICK",r[r.ESC=1]="ESC",Ss;var r})();let m5=(()=>{class r{constructor(e,c,m){this._document=e,this._elRef=c,this._zone=m,this._closed$=new se.xQ,this._elWithFocus=null,this.backdrop=!0,this.keyboard=!0,this.dismissEvent=new d.vpe,this.shown=new se.xQ,this.hidden=new se.xQ}dismiss(e){this.dismissEvent.emit(e)}ngOnInit(){this._elWithFocus=this._document.activeElement,this._zone.onStable.asObservable().pipe((0,Sr.q)(1)).subscribe(()=>{this._show()})}ngOnDestroy(){this._disableEventHandling()}hide(){const{nativeElement:e}=this._elRef,c={animation:this.animation,runningTransition:"stop"},S=xa(Sa(this._zone,e,()=>e.classList.remove("show"),c),Sa(this._zone,this._dialogEl.nativeElement,()=>{},c));return S.subscribe(()=>{this.hidden.next(),this.hidden.complete()}),this._disableEventHandling(),this._restoreFocus(),S}_show(){const e={animation:this.animation,runningTransition:"continue"};xa(Sa(this._zone,this._elRef.nativeElement,(v,S)=>{S&&fo(v),v.classList.add("show")},e),Sa(this._zone,this._dialogEl.nativeElement,()=>{},e)).subscribe(()=>{this.shown.next(),this.shown.complete()}),this._enableEventHandling(),this._setFocus()}_enableEventHandling(){const{nativeElement:e}=this._elRef;this._zone.runOutsideAngular(()=>{un(e,"keydown").pipe(G1(this._closed$),(0,Ia.h)(m=>m.which===Ma.Escape)).subscribe(m=>{this.keyboard?requestAnimationFrame(()=>{m.defaultPrevented||this._zone.run(()=>this.dismiss(Ss.ESC))}):"static"===this.backdrop&&this._bumpBackdrop()});let c=!1;un(this._dialogEl.nativeElement,"mousedown").pipe(G1(this._closed$),(0,ts.b)(()=>c=!1),(0,mc.w)(()=>un(e,"mouseup").pipe(G1(this._closed$),(0,Sr.q)(1))),(0,Ia.h)(({target:m})=>e===m)).subscribe(()=>{c=!0}),un(e,"click").pipe(G1(this._closed$)).subscribe(({target:m})=>{e===m&&("static"===this.backdrop?this._bumpBackdrop():!0===this.backdrop&&!c&&this._zone.run(()=>this.dismiss(Ss.BACKDROP_CLICK))),c=!1})})}_disableEventHandling(){this._closed$.next()}_setFocus(){const{nativeElement:e}=this._elRef;if(!e.contains(document.activeElement)){const c=e.querySelector("[ngbAutofocus]"),m=r0(e)[0];(c||m||e).focus()}}_restoreFocus(){const e=this._document.body,c=this._elWithFocus;let m;m=c&&c.focus&&e.contains(c)?c:e,this._zone.runOutsideAngular(()=>{setTimeout(()=>m.focus()),this._elWithFocus=null})}_bumpBackdrop(){"static"===this.backdrop&&Sa(this._zone,this._elRef.nativeElement,({classList:e})=>(e.add("modal-static"),()=>e.remove("modal-static")),{animation:this.animation,runningTransition:"continue"})}}return r.\u0275fac=function(e){return new(e||r)(d.Y36(Hn.K0),d.Y36(d.SBq),d.Y36(d.R0b))},r.\u0275cmp=d.Xpm({type:r,selectors:[["ngb-modal-window"]],viewQuery:function(e,c){if(1&e&&d.Gf(Ge,7),2&e){let m;d.iGM(m=d.CRH())&&(c._dialogEl=m.first)}},hostAttrs:["role","dialog","tabindex","-1"],hostVars:7,hostBindings:function(e,c){2&e&&(d.uIk("aria-modal",!0)("aria-labelledby",c.ariaLabelledBy)("aria-describedby",c.ariaDescribedBy),d.Tol("modal d-block"+(c.windowClass?" "+c.windowClass:"")),d.ekj("fade",c.animation))},inputs:{animation:"animation",ariaLabelledBy:"ariaLabelledBy",ariaDescribedBy:"ariaDescribedBy",backdrop:"backdrop",centered:"centered",keyboard:"keyboard",scrollable:"scrollable",size:"size",windowClass:"windowClass",modalDialogClass:"modalDialogClass"},outputs:{dismissEvent:"dismiss"},ngContentSelectors:C4,decls:4,vars:2,consts:[["role","document"],["dialog",""],[1,"modal-content"]],template:function(e,c){1&e&&(d.F$t(),d.TgZ(0,"div",0,1)(2,"div",2),d.Hsn(3),d.qZA()()),2&e&&d.Tol("modal-dialog"+(c.size?" modal-"+c.size:"")+(c.centered?" modal-dialog-centered":"")+(c.scrollable?" modal-dialog-scrollable":"")+(c.modalDialogClass?" "+c.modalDialogClass:""))},styles:["ngb-modal-window .component-host-scrollable{display:flex;flex-direction:column;overflow:hidden}\n"],encapsulation:2}),r})();const h5=()=>{};let _0=(()=>{class r{constructor(e){this._document=e}compensate(){const e=this._getWidth();return this._isPresent(e)?this._adjustBody(e):h5}_adjustBody(e){const c=this._document.body,m=c.style.paddingRight,v=parseFloat(window.getComputedStyle(c)["padding-right"]);return c.style["padding-right"]=`${v+e}px`,()=>c.style["padding-right"]=m}_isPresent(e){const c=this._document.body.getBoundingClientRect();return window.innerWidth-(c.left+c.right)>=e-.1*e}_getWidth(){const e=this._document.createElement("div");e.className="modal-scrollbar-measure";const c=this._document.body;c.appendChild(e);const m=e.getBoundingClientRect().width-e.clientWidth;return c.removeChild(e),m}}return r.\u0275fac=function(e){return new(e||r)(d.LFG(Hn.K0))},r.\u0275prov=d.Yz7({token:r,factory:r.\u0275fac,providedIn:"root"}),r})(),g5=(()=>{class r{constructor(e,c,m,v,S,A){this._applicationRef=e,this._injector=c,this._document=m,this._scrollBar=v,this._rendererFactory=S,this._ngZone=A,this._activeWindowCmptHasChanged=new se.xQ,this._ariaHiddenValues=new Map,this._backdropAttributes=["animation","backdropClass"],this._modalRefs=[],this._windowAttributes=["animation","ariaLabelledBy","ariaDescribedBy","backdrop","centered","keyboard","scrollable","size","windowClass","modalDialogClass"],this._windowCmpts=[],this._activeInstances=new d.vpe,this._activeWindowCmptHasChanged.subscribe(()=>{if(this._windowCmpts.length){const H=this._windowCmpts[this._windowCmpts.length-1];((r,a,e,c=!1)=>{this._ngZone.runOutsideAngular(()=>{const m=un(a,"focusin").pipe(G1(e),(0,R1.U)(v=>v.target));un(a,"keydown").pipe(G1(e),(0,Ia.h)(v=>v.which===Ma.Tab),is(m)).subscribe(([v,S])=>{const[A,H]=r0(a);(S===A||S===a)&&v.shiftKey&&(H.focus(),v.preventDefault()),S===H&&!v.shiftKey&&(A.focus(),v.preventDefault())}),c&&un(a,"click").pipe(G1(e),is(m),(0,R1.U)(v=>v[1])).subscribe(v=>v.focus())})})(0,H.location.nativeElement,this._activeWindowCmptHasChanged),this._revertAriaHidden(),this._setAriaHidden(H.location.nativeElement)}})}open(e,c,m,v){const S=v.container instanceof HTMLElement?v.container:xs(v.container)?this._document.querySelector(v.container):this._document.body,A=this._rendererFactory.createRenderer(null,null),H=this._scrollBar.compensate(),q=()=>{this._modalRefs.length||(A.removeClass(this._document.body,"modal-open"),this._revertAriaHidden())};if(!S)throw new Error(`The specified modal container "${v.container||"body"}" was not found in the DOM.`);const ae=new R4,ze=this._getContentRef(e,v.injector||c,m,ae,v);let Se=!1!==v.backdrop?this._attachBackdrop(e,S):void 0,Ne=this._attachWindowComponent(e,S,ze),Ee=new p5(Ne,ze,Se,v.beforeDismiss);return this._registerModalRef(Ee),this._registerWindowCmpt(Ne),Ee.result.then(H,H),Ee.result.then(q,q),ae.close=Ve=>{Ee.close(Ve)},ae.dismiss=Ve=>{Ee.dismiss(Ve)},this._applyWindowOptions(Ne.instance,v),1===this._modalRefs.length&&A.addClass(this._document.body,"modal-open"),Se&&Se.instance&&(this._applyBackdropOptions(Se.instance,v),Se.changeDetectorRef.detectChanges()),Ne.changeDetectorRef.detectChanges(),Ee}get activeInstances(){return this._activeInstances}dismissAll(e){this._modalRefs.forEach(c=>c.dismiss(e))}hasOpenModals(){return this._modalRefs.length>0}_attachBackdrop(e,c){let v=e.resolveComponentFactory(f5).create(this._injector);return this._applicationRef.attachView(v.hostView),c.appendChild(v.location.nativeElement),v}_attachWindowComponent(e,c,m){let S=e.resolveComponentFactory(m5).create(this._injector,m.nodes);return this._applicationRef.attachView(S.hostView),c.appendChild(S.location.nativeElement),S}_applyWindowOptions(e,c){this._windowAttributes.forEach(m=>{xs(c[m])&&(e[m]=c[m])})}_applyBackdropOptions(e,c){this._backdropAttributes.forEach(m=>{xs(c[m])&&(e[m]=c[m])})}_getContentRef(e,c,m,v,S){return m?m instanceof d.Rgc?this._createFromTemplateRef(m,v):function Ul(r){return"string"==typeof r}(m)?this._createFromString(m):this._createFromComponent(e,c,m,v,S):new Zo([])}_createFromTemplateRef(e,c){const v=e.createEmbeddedView({$implicit:c,close(S){c.close(S)},dismiss(S){c.dismiss(S)}});return this._applicationRef.attachView(v),new Zo([v.rootNodes],v)}_createFromString(e){const c=this._document.createTextNode(`${e}`);return new Zo([[c]])}_createFromComponent(e,c,m,v,S){const A=e.resolveComponentFactory(m),H=d.zs3.create({providers:[{provide:R4,useValue:v}],parent:c}),q=A.create(H),ae=q.location.nativeElement;return S.scrollable&&ae.classList.add("component-host-scrollable"),this._applicationRef.attachView(q.hostView),new Zo([[ae]],q.hostView,q)}_setAriaHidden(e){const c=e.parentElement;c&&e!==this._document.body&&(Array.from(c.children).forEach(m=>{m!==e&&"SCRIPT"!==m.nodeName&&(this._ariaHiddenValues.set(m,m.getAttribute("aria-hidden")),m.setAttribute("aria-hidden","true"))}),this._setAriaHidden(c))}_revertAriaHidden(){this._ariaHiddenValues.forEach((e,c)=>{e?c.setAttribute("aria-hidden",e):c.removeAttribute("aria-hidden")}),this._ariaHiddenValues.clear()}_registerModalRef(e){const c=()=>{const m=this._modalRefs.indexOf(e);m>-1&&(this._modalRefs.splice(m,1),this._activeInstances.emit(this._modalRefs))};this._modalRefs.push(e),this._activeInstances.emit(this._modalRefs),e.result.then(c,c)}_registerWindowCmpt(e){this._windowCmpts.push(e),this._activeWindowCmptHasChanged.next(),e.onDestroy(()=>{const c=this._windowCmpts.indexOf(e);c>-1&&(this._windowCmpts.splice(c,1),this._activeWindowCmptHasChanged.next())})}}return r.\u0275fac=function(e){return new(e||r)(d.LFG(d.z2F),d.LFG(d.zs3),d.LFG(Hn.K0),d.LFG(_0),d.LFG(d.FYo),d.LFG(d.R0b))},r.\u0275prov=d.Yz7({token:r,factory:r.\u0275fac,providedIn:"root"}),r})(),F4=(()=>{class r{constructor(e){this._ngbConfig=e,this.backdrop=!0,this.keyboard=!0}get animation(){return void 0===this._animation?this._ngbConfig.animation:this._animation}set animation(e){this._animation=e}}return r.\u0275fac=function(e){return new(e||r)(d.LFG(qo))},r.\u0275prov=d.Yz7({token:r,factory:r.\u0275fac,providedIn:"root"}),r})(),vo=(()=>{class r{constructor(e,c,m,v){this._moduleCFR=e,this._injector=c,this._modalStack=m,this._config=v}open(e,c={}){const m=Object.assign(Object.assign(Object.assign({},this._config),{animation:this._config.animation}),c);return this._modalStack.open(this._moduleCFR,this._injector,e,m)}get activeInstances(){return this._modalStack.activeInstances}dismissAll(e){this._modalStack.dismissAll(e)}hasOpenModals(){return this._modalStack.hasOpenModals()}}return r.\u0275fac=function(e){return new(e||r)(d.LFG(d._Vd),d.LFG(d.zs3),d.LFG(g5),d.LFG(F4))},r.\u0275prov=d.Yz7({token:r,factory:r.\u0275fac,providedIn:"root"}),r})(),x0=(()=>{class r{}return r.\u0275fac=function(e){return new(e||r)},r.\u0275mod=d.oAB({type:r}),r.\u0275inj=d.cJS({providers:[vo]}),r})(),zs=(()=>{class r{}return r.\u0275fac=function(e){return new(e||r)},r.\u0275mod=d.oAB({type:r}),r.\u0275inj=d.cJS({imports:[[Hn.ez]]}),r})(),al=(()=>{class r{}return r.\u0275fac=function(e){return new(e||r)},r.\u0275mod=d.oAB({type:r}),r.\u0275inj=d.cJS({imports:[[Hn.ez]]}),r})(),ol=(()=>{class r{}return r.\u0275fac=function(e){return new(e||r)},r.\u0275mod=d.oAB({type:r}),r.\u0275inj=d.cJS({imports:[[Hn.ez]]}),r})(),D0=(()=>{class r{}return r.\u0275fac=function(e){return new(e||r)},r.\u0275mod=d.oAB({type:r}),r.\u0275inj=d.cJS({imports:[[Hn.ez]]}),r})(),E0=(()=>{class r{}return r.\u0275fac=function(e){return new(e||r)},r.\u0275mod=d.oAB({type:r}),r.\u0275inj=d.cJS({imports:[[Hn.ez]]}),r})(),js=(()=>{class r{}return r.\u0275fac=function(e){return new(e||r)},r.\u0275mod=d.oAB({type:r}),r.\u0275inj=d.cJS({imports:[[Hn.ez]]}),r})(),j0=(()=>{class r{}return r.\u0275fac=function(e){return new(e||r)},r.\u0275mod=d.oAB({type:r}),r.\u0275inj=d.cJS({imports:[[Hn.ez]]}),r})(),k0=(()=>{class r{}return r.\u0275fac=function(e){return new(e||r)},r.\u0275mod=d.oAB({type:r}),r.\u0275inj=d.cJS({}),r})();new d.OlP("live announcer delay",{providedIn:"root",factory:function P0(){return 100}});let A5=(()=>{class r{}return r.\u0275fac=function(e){return new(e||r)},r.\u0275mod=d.oAB({type:r}),r.\u0275inj=d.cJS({imports:[[Hn.ez]]}),r})();const Bc=[I3,O3,E8,L4,F3,tl,u5,x0,zs,al,ol,D0,E0,js,j0,k0,A5];let V0=(()=>{class r{}return r.\u0275fac=function(e){return new(e||r)},r.\u0275mod=d.oAB({type:r}),r.\u0275inj=d.cJS({imports:[Bc,I3,O3,E8,L4,F3,tl,u5,x0,zs,al,ol,D0,E0,js,j0,k0,A5]}),r})(),cl=(()=>{class r{constructor(){}}return r.\u0275fac=function(e){return new(e||r)},r.\u0275cmp=d.Xpm({type:r,selectors:[["ng-component"]],decls:4,vars:0,consts:[[1,"card"],[1,"card-body"],[1,"card-title"]],template:function(e,c){1&e&&(d.TgZ(0,"div",0)(1,"div",1)(2,"h4",2),d._uU(3,"Acerca de la Biblioteca Artemisa y sus servicios"),d.qZA()()())},encapsulation:2}),r})();var G4=function(){function r(a,e,c){this.el=a,this.vcr=e,this.renderer=c,this.dtOptions={}}return r.prototype.ngOnInit=function(){var a=this;this.dtTrigger?this.dtTrigger.subscribe(function(e){a.displayTable(e)}):this.displayTable(null)},r.prototype.ngOnDestroy=function(){this.dtTrigger&&this.dtTrigger.unsubscribe(),this.dt&&this.dt.destroy(!0)},r.prototype.displayTable=function(a){var e=this;a&&(this.dtOptions=a),this.dtInstance=new Promise(function(c,m){Promise.resolve(e.dtOptions).then(function(v){0===Object.keys(v).length&&0===$("tbody tr",e.el.nativeElement).length?m("Both the table and dtOptions cannot be empty"):setTimeout(function(){var A={rowCallback:function(H,q,ae){if(v.columns){var ze=v.columns;e.applyNgPipeTransform(H,ze),e.applyNgRefTemplate(H,ze,q)}v.rowCallback&&v.rowCallback(H,q,ae)}};A=Object.assign({},v,A),e.dt=$(e.el.nativeElement).DataTable(A),c(e.dt)})})})},r.prototype.applyNgPipeTransform=function(a,e){e.filter(function(m){return m.ngPipeInstance&&!m.ngTemplateRef}).forEach(function(m){var v=m.ngPipeInstance,S=e.findIndex(function(ae){return ae.data===m.data}),A=a.childNodes.item(S),H=$(A).text(),q=v.transform(H);$(A).text(q)})},r.prototype.applyNgRefTemplate=function(a,e,c){var m=this;e.filter(function(S){return S.ngTemplateRef&&!S.ngPipeInstance}).forEach(function(S){var A=S.ngTemplateRef,H=A.ref,q=A.context,ae=e.findIndex(function(Ee){return Ee.data===S.data}),ze=a.childNodes.item(ae);$(ze).html("");var Se=Object.assign({},q,null==q?void 0:q.userData,{adtData:c}),Ne=m.vcr.createEmbeddedView(H,Se);m.renderer.appendChild(ze,Ne.rootNodes[0])})},r.\u0275fac=function(e){return new(e||r)(d.Y36(d.SBq),d.Y36(d.s_b),d.Y36(d.Qsj))},r.\u0275dir=d.lG2({type:r,selectors:[["","datatable",""]],inputs:{dtOptions:"dtOptions",dtTrigger:"dtTrigger"}}),r}(),L5=function(){function r(){}return r.forRoot=function(){return{ngModule:r}},r.\u0275fac=function(e){return new(e||r)},r.\u0275mod=d.oAB({type:r}),r.\u0275inj=d.cJS({imports:[[Hn.ez]]}),r}();const W4=JSON.parse('[{"ID":258,"supergrupo":"Teoria","tema":"Reglas b\xe1sicas","texto":"Durante las competencias, dependiendo de la modalidad de la misma, existen ciertas reglas que se deben cumplir para mantener la igualdad entre los competidores y evitar cualquier tipo de trampas.\\nCompetencias presenciales:\\n\u2022 Durante las competencias est\xe1 prohibido el uso de elementos electr\xf3nicos tales como celulares, dispositivos de almacenamiento extra\xedbles, reproductores de m\xfasica, auriculares, entre otros. De ser encontrado con alguno de estos, el participante ser\xe1 retirado del recinto y perder\xe1 el derecho a continuar en la competencia por intento de fraude.\\n\u2022 El ingreso a p\xe1ginas web distintas a la plataforma oficial de la competencia ser\xe1 penalizado con la descalificaci\xf3n inmediata de la competencia.\\n\u2022 El consumo de bebidas y alimentos dentro de las aulas no est\xe1 permitido.\\n\u2022 Durante la competencia los equipos no podr\xe1n hablar ni intercambiar material entre ellos. De ser sorprendidos por primera vez incumpliendo esta normal, se les har\xe1 una advertencia pero si ya es la segunda vez ser\xe1n descalificados  de la competencia. \\n\u2022 La copia de c\xf3digo de fuentes externas como p\xe1ginas  web o redes sociales se  considera plagio.\\n\u2022 Est\xe1  permitido el uso de material como libros de texto, c\xf3digos impresos, textos matem\xe1ticos, diccionarios, entre otros.\\n\u2022 Cada equipo tendr\xe1 a su disposici\xf3n una sola m\xe1quina durante la competencia.\\n\u2022 En la competencia los equipos ser\xe1n conformados por m\xe1ximo tres competidores. \\nCompetencias virtuales:\\n\u2022 Durante la competencia los equipos no podr\xe1n hablar ni intercambiar material entre ellos. De ser sorprendidos por primera vez incumpliendo esta normal, se les har\xe1 una advertencia pero si ya es la segunda vez ser\xe1n descalificados  de la competencia. \\n\u2022 En la competencia los equipos ser\xe1n conformados por m\xe1ximo tres competidores. \\n\u2022 La copia de c\xf3digo de fuentes externas como p\xe1ginas  web o redes sociales se  considera plagio.\\n\u2022 No se admite cualquier tipo de ataques inform\xe1ticos que intenten vulnerar la integridad de los sistemas usados en las competencias.\\n\\nDurante la mayor\xeda de las competencias, la forma de entrada y salida de informaci\xf3n de cada ejercicio se realiza por medio de la consola (STDIN/STDOUT), aunque algunas competencias si utilizan entornos gr\xe1ficos y entornos web (Uva Online Judge, 2012).\\n","complejidad_tiempo":null,"java":null,"cpp":null,"py":null,"orden":0,"suborden":99,"fecha_creacion":"2020-12-06 20:56:39","fecha_modificacion":"2020-12-06 20:59:24"},{"ID":259,"supergrupo":"Teoria","tema":"\xbfQu\xe9 es la programaci\xf3n competitiva?","texto":"Dentro de las iniciativas en el \xe1rea de las ciencias de la computaci\xf3n, un tema que a\xf1o con a\xf1o cobra m\xe1s auge es la programaci\xf3n competitiva; el cual se evidencia en torneos en los cuales varios grupos de personas intentan resolver un problema a trav\xe9s de c\xf3digo y algoritmos.\\nEl trabajo en equipo, pensamiento cr\xedtico y actuar bajo presi\xf3n, adem\xe1s de otras actividades, son desarrolladas e impulsadas a trav\xe9s de estas competencias. Se trata de un deporte mental en el que participan e impulsan compa\xf1\xedas multinacionales de software como Google, IBM y Facebook.\\nEl desarrollo de las habilidades de programaci\xf3n de algoritmos se potencia a trav\xe9s de la colaboraci\xf3n, es por ello que colegios y universidades de todo el mundo buscan que los alumnos participen en este tipo de torneos.\\nA su vez, el impulso de talento es crucial para actividades cada vez m\xe1s demandantes y demandadas, como es la programaci\xf3n. De ah\xed que empresas de gran relevancia nacional e internacional este interesadas en egresados de carreras relacionadas.\\n","complejidad_tiempo":null,"java":null,"cpp":null,"py":null,"orden":0,"suborden":99,"fecha_creacion":"2020-12-06 20:56:39","fecha_modificacion":"2020-12-06 20:59:24"},{"ID":260,"supergrupo":"Teoria","tema":"\xbfQu\xe9 es un problema de programaci\xf3n competitiva?","texto":"Un problema de programaci\xf3n competitiva es un peque\xf1o ejercicio de programaci\xf3n que puede abordar cualquier tema de la vida cotidiana, ciencias puras como la matem\xe1tica o la f\xedsica, un juego de mesa como el ajedrez o un rompecabezas.\\nUtilizando la programaci\xf3n se pueden resolver estos ejercicios y buscar una soluci\xf3n \xf3ptima al mismo utilizando matem\xe1tica, algoritmos matem\xe1ticos especializados o incluso l\xf3gica b\xe1sica.\\n","complejidad_tiempo":null,"java":null,"cpp":null,"py":null,"orden":0,"suborden":99,"fecha_creacion":"2020-12-06 20:56:40","fecha_modificacion":"2020-12-06 20:59:24"},{"ID":261,"supergrupo":"Teoria","tema":"Estructura de un problema de programaci\xf3n competitiva","texto":"Un problema se encuentra conformado de 4 partes principales:\\n1. T\xedtulo: Contiene el nombre del problema, com\xfanmente da una vaga aproximaci\xf3n al tema del problema\\n2. Descripci\xf3n: Contiene toda la informaci\xf3n del problema, puede ser una historia, un evento, algo que le pasando a alguien y quiere que usted lo ayude a resolverlo. Puede contener algunas pistas de c\xf3mo resolver el ejercicio, variables que se pueden usar y de qu\xe9 tipo pueden ser.\\n3. Variables y restricciones: muestra el o los tipos de datos que entraran y el o los tipos de datos que deben salir, adem\xe1s del tama\xf1o que puede tener la entrada.\\n4. Ejemplo de entrada y salida: Muestra uno de todos los posibles casos de prueba que pueden evaluarse en el ejercicio, tener en cuenta que los ejemplos en los textos de ejercicio nunca ser\xe1n los \xfanicos, se debe usar la parte de variables para calcular cual ser\xe1 el caso m\xe1s f\xe1cil, un caso intermedio y el caso m\xe1s dif\xedcil.\\n","complejidad_tiempo":null,"java":null,"cpp":null,"py":null,"orden":0,"suborden":99,"fecha_creacion":"2020-12-06 20:56:40","fecha_modificacion":"2020-12-06 20:59:24"},{"ID":262,"supergrupo":"Teoria","tema":"Como abordar un problema","texto":"Com\xfanmente todos los ejercicios tienen dos o m\xe1s formas de ser solucionados, utilizando diversos tipos de algoritmos o metodolog\xedas matem\xe1ticas de resoluci\xf3n de problemas, a continuaci\xf3n nombraremos algunas de las formas existentes para abordar un problema:\\n- F\xf3rmulas matem\xe1ticas\\n- Fuerza bruta\\n- Aproximaciones de ra\xedces \\n- Procesamiento de Strings \\n- B\xfasqueda de patrones\\n- Uso de estructuras de datos especializadas\\n- Algoritmos predise\xf1ados modificados\\n- Enfoque geom\xe9trico\\n- Algoritmos ingenuos\\n- Uso de estructuras geometr\xedas avanzadas\\n- B\xfasquedas \\n- Ordenamientos\\nAl leer toda la informaci\xf3n de nuestro ejercicio, su deber como es identificar cual es la metodolog\xeda m\xe1s adecuada para la resoluci\xf3n de estos ejercicios, podemos apoyarnos de material previamente consultado. Entre cada metodolog\xeda de resoluci\xf3n varia el uso de memoria, tiempo de ejecuci\xf3n y forma de entrada de la informaci\xf3n a procesar, por lo que conocer los puntos fuertes y d\xe9biles de cada uno es crucial. \\nPor lo general las metodolog\xedas matem\xe1ticas son las m\xe1s r\xe1pidas pero tambi\xe9n suelen ser las m\xe1s complicadas de implementar, ya que se basan en la b\xfasqueda de sistemas de ecuaciones o el uso de teoremas matem\xe1ticos que son complicados y abstractos de entender, las metodolog\xedas de fuerza bruta son las m\xe1s lentas pero las m\xe1s seguras a la hora de encontrar una soluci\xf3n a un problema debido a que usan gran cantidad de recursos para asegurarse de dar con la respuesta, adem\xe1s de obtener las dem\xe1s respuestas posibles a un problema cuando sus variables cambian. \\nLos desarrolladores y estudiantes resuelven muchas preguntas de codificaci\xf3n de estructuras de datos y algoritmos, pero la mayor\xeda de ellos no comprende la importancia de esto. Muchos de ellos tambi\xe9n tienen la opini\xf3n de que las estructuras de datos y los algoritmos solo ayudan en las entrevistas y despu\xe9s de eso, no hay uso de todas esas cosas complicadas en los trabajos diarios.\\nEs importante estar contento con aprender un nuevo lenguaje o framework y crear algunas aplicaciones con eso, pero una vez que ingrese a la industria del mundo real, se dar\xe1 cuenta de que su trabajo no es solo escribir el c\xf3digo y hacer que las cosas funcionen. Su verdadero trabajo es escribir la cantidad correcta de buen c\xf3digo, lo que significa que debe ser eficiente y robusto, y aqu\xed viene el papel de las estructuras de datos y los algoritmos. Las estructuras de datos y los algoritmos no solo ayudan a obtener la l\xf3gica de su programa, sino que tambi\xe9n ayudan a escribir el c\xf3digo eficiente para su software. Ya sea que hablemos sobre la complejidad del tiempo o la administraci\xf3n de la memoria, la refactorizaci\xf3n del c\xf3digo o la reutilizaci\xf3n del c\xf3digo, comprender\xe1 su valor en cada parte de su aplicaci\xf3n.\\nEn proyectos del mundo real, su cerebro deber\xeda ser capaz de escribir una soluci\xf3n r\xe1pida y eficiente para desaf\xedos complicados, y solo puede hacerlo cuando haya practicado mucha programaci\xf3n. Comprenda que el lenguaje y los frameworks son solo herramientas, no le ense\xf1ar\xe1n habilidades para resolver problemas. Se desarrolla habilidad para resolver problemas cuando se practica mucha programaci\xf3n.\\nCada desarrollador tiene sus propios trucos y siguen su propio patr\xf3n para resolver problemas de codificaci\xf3n, pero cuando se trata de nuevos desarrolladores, siempre tienen dudas sobre d\xf3nde comenzar. Muchos de ellos entienden los problemas, la l\xf3gica y los conceptos b\xe1sicos de la sintaxis, tambi\xe9n entienden los c\xf3digos de otras personas y pueden seguirlos, pero cuando se trata de resolver las preguntas por su cuenta, se atascan. No entienden c\xf3mo convertir sus pensamientos en c\xf3digo a pesar de que entienden la sintaxis o la l\xf3gica. Estos son algunos pasos simples que lo ayudar\xe1n a abordar una pregunta de codificaci\xf3n dentro de una competencia o dentro de una entrevista de trabajo.\\nComprender y analizar el problema\\nNo importa si ha visto el ejercicio que est\xe1 realizando en el pasado o no, lea la pregunta varias veces y comprenda por completo. Ahora, piense en la pregunta y anal\xedcela cuidadosamente. A veces leemos algunas l\xedneas y asumimos el resto de las cosas por nuestra cuenta, pero un ligero cambio en su pregunta puede cambiar muchas cosas en su c\xf3digo, as\xed que tenga cuidado al respecto. Ahora tome un papel y escriba todo. \xbfQu\xe9 se proporciona (entrada) y qu\xe9 necesita averiguar (salida)? \\nMientras se debe realizar las siguientes preguntas...\\n1. \xbfEntendi\xf3 el problema completamente?\\n2. \xbfSer\xeda capaz de explicar esta pregunta a otra persona?\\n3. \xbfQu\xe9 y cu\xe1ntas entradas se requieren?\\n4. \xbfCu\xe1l ser\xeda la salida para esas entradas?\\n5. \xbfNecesita separar algunos m\xf3dulos o partes del problema?\\n6. \xbfTiene suficiente informaci\xf3n para resolver esa pregunta? De lo contrario, lea nuevamente la pregunta.\\nPor ejemplo: si se le da un vector y necesita devolver el vector que contiene solo n\xfameros pares, primero analice el problema cuidadosamente. Mientras analiza el problema, debe hacerse algunas preguntas antes de saltar a la soluci\xf3n.\\n1. \xbfC\xf3mo identificar un n\xfamero par? Divida ese n\xfamero entre 2 y vea si su residuo es 0.\\n2. \xbfQu\xe9 debo pasar a esta funci\xf3n? Un vector\\n3. \xbfQu\xe9 contendr\xe1 ese vector? Uno o m\xe1s n\xfameros\\n4. \xbfCu\xe1les son los tipos de datos de los elementos en el vector? N\xfameros\\n5. \xbfCu\xe1l es el objetivo final? El objetivo es devolver el vector de n\xfameros pares. Si no hay n\xfameros pares, devuelve un vector vac\xedo.\\nRevise los datos de muestra y los ejemplos a fondo\\nCuando intente comprender el problema, tome algunas entradas de muestra e intente analizar la salida. Tomar algunas entradas de muestra lo ayudar\xe1 a comprender el problema de una mejor manera. Tambi\xe9n obtendr\xe1 la claridad de cu\xe1ntos casos puede manejar su c\xf3digo y cu\xe1les pueden ser la salida o el rango de salida posibles. \\n\u2022 Considere algunas entradas o datos simples y analice la salida.\\n\u2022 Considere algunos aportes complejos y m\xe1s grandes e identifique cu\xe1l ser\xe1 el resultado y cu\xe1ntos casos debe tomar para resolver el problema.\\n\u2022 Considere tambi\xe9n los casos extremos. Analice cu\xe1l ser\xeda la salida si no hay entrada o si proporciona alguna entrada no v\xe1lida.\\n\\nRomper el problema\\nCuando vea un problema de programaci\xf3n que es complejo o grande, en lugar de tener miedo y confundirse acerca de c\xf3mo resolver esa pregunta, divida el problema en fragmentos m\xe1s peque\xf1os y luego intente resolver cada parte del problema. A continuaci\xf3n se detallan algunos pasos que debe seguir para resolver las complejas preguntas de codificaci\xf3n:\\n\u2022 Haga un diagrama de flujo para el problema en cuesti\xf3n.\\n\u2022 Divida el problema en subproblemas o fragmentos m\xe1s peque\xf1os.\\n\u2022 Resuelva los subproblemas. Haga funciones independientes para cada subproblema.\\n\u2022 Conecte las soluciones de cada subproblema llam\xe1ndolos en el orden requerido o seg\xfan sea necesario.\\n\u2022 Donde sea necesario, use clases y objetos \\nEscribir pseudoc\xf3digo\\nAntes de saltar a la soluci\xf3n, siempre es bueno escribir un pseudoc\xf3digo para su problema. B\xe1sicamente, el pseudoc\xf3digo define la estructura de su c\xf3digo y le ayudar\xe1 a escribir cada l\xednea de c\xf3digo que necesite para resolver el problema. Leer el pseudoc\xf3digo da una idea clara de lo que su c\xf3digo debe hacer. Muchas personas o programadores experimentados omiten este paso, pero cuando escribe pseudoc\xf3digo, el proceso de escribir el c\xf3digo final se vuelve m\xe1s f\xe1cil para usted. Al final, solo tendr\xe1 que traducir cada l\xednea de pseudoc\xf3digo en c\xf3digo real. As\xed que escriba cada paso y l\xf3gica en su pseudoc\xf3digo. \\nReemplazar pseudoc\xf3digo con c\xf3digo real\\nUna vez que haya escrito el pseudoc\xf3digo, es hora de traducirlo al c\xf3digo real. Reemplace cada l\xednea de su pseudoc\xf3digo en c\xf3digo real en el idioma en el que est\xe1 trabajando. Si ha dividido su problema en subproblemas, anote el c\xf3digo de cada subproblema. Mientras escribe el c\xf3digo, tenga en cuenta tres cosas:\\n\u2022 El punto donde comenz\xf3\\n\u2022 \xbfD\xf3nde est\xe1 ahora mismo?\\n\u2022 \xbfCu\xe1l es su destino (resultado final)?\\nNo olvide probar su c\xf3digo con conjuntos de datos de muestra (paso 2) para verificar si la salida real es igual a la salida esperada. Una vez que haya terminado con la codificaci\xf3n, puede deshacerse del pseudoc\xf3digo\\n\\nCuando se encuentre dentro de una entrevista de trabajo, escriba el c\xf3digo, vaya dici\xe9ndole al entrevistador c\xf3mo est\xe1 abordando el problema.\\n\u2022 D\xedgale al entrevistador c\xf3mo est\xe1 tratando de comenzar.\\n\u2022 Cu\xe9ntele al entrevistador acerca de su enfoque para resolver el problema.\\n\u2022 Discuta con el entrevistador sobre la parte m\xe1s dif\xedcil que enfrenta en su problema.\\n\u2022 Informe al entrevistador sobre el enfoque para resolver cada subproblema para obtener el resultado final.\\n\u2022 Discuta los datos de la muestra o los casos de prueba con el entrevistador.\\n\u2022 Discuta sobre la mejor soluci\xf3n con el entrevistador.\\nSimplifique y Optimice su C\xf3digo\\nIntenta siempre mejorar su c\xf3digo. Mire hacia atr\xe1s, anal\xedcelo una vez m\xe1s e intente encontrar una soluci\xf3n mejor o alternativa. Se ha mencionado anteriormente que siempre debe intentar escribir la cantidad correcta de c\xf3digo correcto, as\xed que siempre busque la soluci\xf3n alternativa que sea m\xe1s eficiente que la anterior. Escribir la soluci\xf3n correcta a su problema no es lo \xfaltimo que debe hacer. Explore el problema completamente con todas las soluciones posibles y luego escriba la soluci\xf3n m\xe1s eficiente u optimizada para su c\xf3digo. Entonces, una vez que haya terminado de escribir la soluci\xf3n para su c\xf3digo, hay algunas preguntas que debe hacerse.\\n\u2022 \xbfSe ejecuta este c\xf3digo para cada entrada posible, incluidos los casos l\xedmite?\\n\u2022 \xbfExiste una soluci\xf3n alternativa para el mismo problema?\\n\u2022 \xbfEs eficiente el c\xf3digo? \xbfPuede ser m\xe1s eficiente o se puede mejorar el rendimiento?\\n\u2022 \xbfDe qu\xe9 otra forma puede hacer que el c\xf3digo sea m\xe1s legible?\\n\u2022 \xbfHay m\xe1s pasos o funciones adicionales que pueda realizar?\\n","complejidad_tiempo":null,"java":null,"cpp":null,"py":null,"orden":0,"suborden":99,"fecha_creacion":"2020-12-06 20:56:40","fecha_modificacion":"2020-12-06 20:59:24"},{"ID":263,"supergrupo":"Teoria","tema":"Casos de prueba y tipos de casos de prueba","texto":null,"complejidad_tiempo":null,"java":null,"cpp":null,"py":null,"orden":0,"suborden":99,"fecha_creacion":"2020-12-06 20:56:40","fecha_modificacion":"2020-12-06 20:59:24"},{"ID":264,"supergrupo":"Teoria","tema":"10 pasos para resolver cualquier problema","texto":"1. Lea el problema completamente al menos dos o tres veces (o la cantidad de veces que sean que te hagan sentir c\xf3modo)\\n2. Identifique el tema al que pertenece el problema. \xbfEs un problema de ordenamiento o coincidencia de patrones? \xbfPuede usar la teor\xeda de grafos? \xbfEst\xe1 relacionado con la teor\xeda de n\xfameros? etc.\\n3. Intente resolver el problema manualmente considerando 3 o 4 sets de datos de prueba.\\n4. Luego conc\xe9ntrese en optimizar los pasos manuales. Intente hacerlo lo m\xe1s simple posible.\\n5. Escriba el pseudoc\xf3digo y comentarios, adem\xe1s del c\xf3digo de cada paso. Una cosa que puede hacer es verificar despu\xe9s de escribir cada funci\xf3n. Use un buen IDE con un depurador, si es posible. No es necesario pensar mucho en la sintaxis. Solo conc\xe9ntrese en la l\xf3gica y los pasos. \\n6. Reemplace los comentarios o pseudoc\xf3digo con c\xf3digo real. Siempre verifique si los valores y el c\xf3digo se comportan como se esperaba antes de pasar a la nueva l\xednea de pseudoc\xf3digo.\\n7. Luego optimice el c\xf3digo real.\\n8. Cuide tambi\xe9n las condiciones de restricci\xf3n de cada variable.\\n9. Obtenga comentarios de sus compa\xf1eros de equipo, profesores y otros desarrolladores y, si es posible, haga su pregunta en StackOverflow. Intente aprender de las pautas de los dem\xe1s y de lo que est\xe1n manejando esos problemas. Un problema puede resolverse de varias maneras. Por lo tanto, no se decepcione si no puede pensar como un experto. Debe atenerse al problema y gradualmente ser\xe1 mejor y m\xe1s r\xe1pido para resolver problemas como los dem\xe1s.\\n10. Practique, practique y practique.\\n","complejidad_tiempo":null,"java":null,"cpp":null,"py":null,"orden":0,"suborden":99,"fecha_creacion":"2020-12-06 20:56:41","fecha_modificacion":"2020-12-06 20:59:24"},{"ID":265,"supergrupo":"Teoria","tema":"Resultados y veredictos de los jueces en l\xednea","texto":"Luego de enviar su programa al juez en l\xednea, se compilar\xe1 y ejecutar\xe1 en ese sistema, y el juez autom\xe1tico lo probar\xe1 con algunas entradas y salidas, o quiz\xe1s con una herramienta de juez espec\xedfica. Pasados unos segundos o minutos, recibir\xe1 una de estas respuestas:\\nIn Queue (QU): El juez est\xe1 ocupado y no puede atender su presentaci\xf3n. Ser\xe1 juzgado lo antes posible.\\nAccepted o Correct (AC): \xa1OK! \xa1Su programa es correcto! Produjo la respuesta correcta en un tiempo razonable y dentro del l\xedmite de uso de memoria. \xa1Felicidades!\\nPresentation Error (PE): las salidas de su programa son correctas pero no se presentan de la manera correcta. Buscar espacios, justificar, saltos de l\xednea...\\nWrong Answer (WA): No se alcanz\xf3 la soluci\xf3n correcta para las entradas. Las entradas y salidas que usan los jueces en l\xednea para probar los programas no son p\xfablicas, por lo que tendr\xe1 que detectar el error por usted mismo. \\nCompile Error (CE): El compilador no pudo compilar su programa. Los mensajes de salida del compilador se le informan para que solucione el problema.\\nRuntime Error (RE): Su programa fall\xf3 durante la ejecuci\xf3n (error de segmentaci\xf3n, excepci\xf3n de punto flotante, mal lectura de datos, desbordamiento de variables\u2026 entre otros). La causa exacta no se informa al usuario para evitar el plagio. Aseg\xfarese de que su programa devuelva un c\xf3digo 0 (Ejecuci\xf3n correcta) al shell. Si est\xe1 utilizando Java, siga todas las especificaciones de env\xedo.\\nTime Limit Exceeded (TLE): Su programa intent\xf3 ejecutarse durante demasiado tiempo; este error no le permite saber si su programa alcanzar\xeda la soluci\xf3n correcta al problema o no.\\nMemory Limit Exceeded (MLE): Su programa intent\xf3 usar m\xe1s memoria de la que permite el juez.\\nOutput Limit Exceeded (OL): Su programa intent\xf3 escribir demasiada informaci\xf3n. Esto suele ocurrir si entra en un bucle infinito.\\nSubmission Error o Submit Failed (SE): El env\xedo no se realiz\xf3 correctamente. Esto se debe a alg\xfan error durante el proceso de env\xedo o corrupci\xf3n de datos.\\nRestricted Function (RF): Su programa est\xe1 intentando utilizar una funci\xf3n que se  considera perjudicial para el sistema del juez en l\xednea. Si obtiene este veredicto, probablemente sepa por qu\xe9... (Est\xe1 haciendo trampa o intentando hacer da\xf1o al juez).\\nCan\'t Be Judged (CJ): El juez no tiene entradas y salidas de prueba para el problema seleccionado. Al elegir un problema, aseg\xfarese de que el juez pueda juzgarlo.\\n","complejidad_tiempo":null,"java":null,"cpp":null,"py":null,"orden":0,"suborden":99,"fecha_creacion":"2020-12-06 20:56:41","fecha_modificacion":"2020-12-06 20:59:24"},{"ID":266,"supergrupo":"Teoria","tema":"Diferencias generales de los lenguajes","texto":"Debido a la metodolog\xeda de ejecuci\xf3n de los diferentes lenguajes de programaci\xf3n, la cantidad de librer\xedas, utilidades est\xe1ndar de cada lenguaje y su dificultad al entender la sintaxis de las l\xedneas de c\xf3digo, se evidencia que cada lenguaje tiene pros y contras en su utilizaci\xf3n al momento de resolver ejercicios de programaci\xf3n competitiva, hay que recordar que Java es un lenguaje que utiliza una m\xe1quina virtual para su ejecuci\xf3n y que Python es un lenguaje interpretado, estas dos generan que ambos lenguajes sean ligeramente m\xe1s lentos al ejecutarse.\\nOtra idea a tener en cuenta es el hecho de que Python no tiene problemas de desbordamiento de variables, debido a que todos los objetos que se crean dentro del c\xf3digo se les asigna memoria de forma din\xe1mica y autom\xe1tica, lo que le permite realizar c\xe1lculos con n\xfameros muy grandes, pero sacrificando rendimiento.\\nJava contiene una gran cantidad de librer\xedas est\xe1ndar para uso dentro de la programaci\xf3n competitiva, lo que le permite reducir l\xedneas de c\xf3digo y agregar funcionalidades que optimicen diversas operaciones dentro de la ejecuci\xf3n del c\xf3digo.\\nTeniendo estas ideas en cuenta se puede realizar la siguiente comparaci\xf3n:\\nVelocidad de ejecuci\xf3n\\nPYTHON<JAVA<C++\\nCantidad de librer\xedas \\nJAVA>PYTHON>C++\\nDificultad de c\xf3digo\\nPYTHON<JAVA<C++\\nNota: estas conclusiones solo aplican cuando los lenguajes se utilizan en ejercicios de programaci\xf3n competitiva.\\n\\nPython es m\xe1s lento en tiempo de ejecuci\xf3n que Java, y Java es m\xe1s lento que C++, por lo que C++ es el lenguaje m\xe1s r\xe1pido.  Java tiene muchas m\xe1s librer\xedas est\xe1ndar que Python, y Python tiene muchas m\xe1s librer\xedas que C++, permitiendo que Java sea el lenguaje m\xe1s polivalente, por \xfaltimo la dificultad de la sintaxis de Python es mucho menor a la de Java, y la dificultad de Java es mayor a la de C++, permitiendo que Python sea el lenguaje m\xe1s sencillo de comprender al ser le\xeddo.\\nUn buen programador competitivo tiene conocimiento de estos tres lenguajes de programaci\xf3n de tal manera que al abordar un ejercicio pueda el decidir cu\xe1l de los tres lenguajes es el m\xe1s adecuado para darle soluci\xf3n al mismo. \\n","complejidad_tiempo":null,"java":null,"cpp":null,"py":null,"orden":0,"suborden":99,"fecha_creacion":"2020-12-06 20:56:41","fecha_modificacion":"2020-12-06 20:59:24"},{"ID":267,"supergrupo":"Teoria","tema":"Consejos y trucos para programadores competitivos","texto":"\xbfQu\xe9 lenguaje usar? Esta es una pregunta frecuente frente a en qu\xe9 idioma se debe preferir ser eficiente en la programaci\xf3n competitiva. Es algo de lo que uno no deber\xeda preocuparse, ya que lo que importa es la l\xf3gica, no el lenguaje. La mayor\xeda de los lenguajes son m\xe1s o menos iguales, pero hasta ahora el lenguaje m\xe1s utilizado es C ++, a continuaci\xf3n se presenta un resumen de las ventajas y desventajas de cada lenguaje.\\nPython\\n\u2022 Simple y f\xe1cil: Python es simple, f\xe1cil de escribir (se necesita escribir menos) y tiene una gran colecci\xf3n de m\xf3dulos con casi todas las funciones que pueda imaginar.\\n\u2022 Tipos de datos: generalmente se prefiere Python, ya que no tiene ning\xfan l\xedmite superior en la memoria de los enteros. Adem\xe1s, no es necesario especificar qu\xe9 tipo de datos es y cosas como esta hacen que sea m\xe1s f\xe1cil de codificar, pero al mismo tiempo dificultan la compilaci\xf3n (en referencia al tiempo necesario para la compilaci\xf3n).\\n\u2022 Lento en la ejecuci\xf3n: los programas de Python son generalmente m\xe1s lentos en comparaci\xf3n con Java. Python est\xe1 pr\xe1cticamente descartado en el inicio debido a su alto tiempo de ejecuci\xf3n.\\n\u2022 Python no est\xe1 permitido en todas partes: Python no est\xe1 permitido en concursos en varios portales de programaci\xf3n competitivos populares en l\xednea.\\nAhora nos quedamos principalmente con Java, C, C ++, ahora aqu\xed se hace dif\xedcil comparar y depende principalmente del usuario, aqu\xed se presentan los puntos buenos y malos de cada uno de ellos.\\nJava\\n\u2022 STL vs contenedores: STL en C ++ est\xe1 muy bien dise\xf1ado, mientras que algunas personas aman Java Containers m\xe1s que nada. Hay pocas situaciones en las que STL no tiene una soluci\xf3n directa. Por ejemplo, priority_queue en STL no admite la operaci\xf3n de tecla de disminuci\xf3n que se requiere para las implementaciones del algoritmo de ruta m\xe1s corto de Dijkstra y el algoritmo de Prim\\n\u2022 El manejo de excepciones en Java es incomparable: el c\xf3digo Java proporciona un manejo de excepciones m\xe1s fuerte en comparaci\xf3n con C ++. Por ejemplo, es m\xe1s f\xe1cil rastrear una excepci\xf3n ArrayIndexOutOfBound o una falla de segmentaci\xf3n en Java. C ++ / C puede darle respuestas incorrectas, pero Java es seguramente confiable en este contexto.\\n\u2022 El l\xedmite de tiempo excede: es posible que obtenga TLE debido a que Java es un poco m\xe1s lento en el lado del l\xedmite de tiempo\\n\u2022 Grandes enteros y expresiones regulares: Java tiene algunas pocas ventajas con respecto a los concursos de programaci\xf3n. Biginteger, Expresiones regulares y biblioteca de geometr\xeda son algunas de ellas.\\nC++ y C \\n\u2022 La velocidad de C ++ es comparable a C: muchos programas de C tambi\xe9n son programas de C ++ v\xe1lidos, y dichos programas de C se ejecutan a una velocidad id\xe9ntica cuando se compilan\\n\u2022 C ++ no fuerza la programaci\xf3n orientada a objetos: el lenguaje C ++ contiene algunas extensiones de lenguaje que facilitan la programaci\xf3n orientada a objetos y C ++ no fuerza el dise\xf1o orientado a objetos en ninguna parte, simplemente lo permite.\\n\\n\u2022 Una biblioteca est\xe1ndar m\xe1s grande: C ++ permite el uso completo de la biblioteca est\xe1ndar C, as\xed como C ++ incluye sus propias bibliotecas, incluida la Biblioteca de plantillas est\xe1ndar. El STL contiene una serie de plantillas \xfatiles, como la rutina de ordenamiento anterior. Incluye \xfatiles estructuras de datos comunes como listas, mapas, conjuntos, etc. Al igual que la rutina de ordenamiento, las otras rutinas STL y estructuras de datos est\xe1n \\"adaptadas\\" a las necesidades espec\xedficas que tiene el programador; todo lo que el programador tiene que hacer es completar los tipos.\\nPor ejemplo, si necesitamos implementar Binary Search para un problema, tendremos que escribir nuestra propia funci\xf3n, mientras que en C ++ Binary Search, la rutina STL se define como\\n\u2022 binary_search (startaddress, endaddress, valuetofind)\\nC ++ vs Java\\n\u2022 Los c\xf3digos Java son m\xe1s largos, un programador necesita escribir m\xe1s cuando programa en Java\\n\u2022 Java es detallado: en C ++, Entrada Salida es m\xe1s simple simplemente escribiendo scanf / printf. En Java,  a veces se necesita la clase BufferedReader, tediosa de programar.\\n\u2022 C ++ STL vs Java Containers: a la mayor\xeda de los programadores les resulta m\xe1s f\xe1cil usar STL.\\n\u2022 C ++ es m\xe1s popular: ya sea el a\xf1o de origen o la comodidad de uso, pero C ++ destaca a Java en t\xe9rminos de cantidad de usuarios que usan el lenguaje.\\n\u2022 C ++ ahorra tiempo: es un hecho bien conocido que Java es m\xe1s lento que C ++. Generalmente necesitamos compilar y ejecutar programas muchas veces para probarlos. Lleva relativamente menos tiempo en C ++. \\nEn resumen, C ++ es hasta la fecha el lenguaje m\xe1s preferido seguido de Java cuando se trata de concursos de programaci\xf3n, pero siempre debe elegir un idioma con el que se sienta c\xf3modo. Tener confianza en cualquier idioma es lo m\xe1s importante. Nunca elija un idioma que haya \\"aprendido\\" recientemente o con el cual tenga poca experiencia, ya que ser\xe1 dif\xedcil expresarse en ese idioma.\\n","complejidad_tiempo":null,"java":null,"cpp":null,"py":null,"orden":0,"suborden":99,"fecha_creacion":"2020-12-06 20:56:42","fecha_modificacion":"2020-12-06 20:59:24"},{"ID":268,"supergrupo":"Teoria","tema":"\xbfC\xf3mo llegar a ser un maestro en programaci\xf3n competitiva?","texto":"Las competencias de programaci\xf3n a nivel internacional son desarrolladas para medir la capacidad de los estudiantes de programaci\xf3n de las distintas universidades y entes estudiantiles, entre ellas se permite utilizar todo tipo de medios escritos en los cuales basarse para el desarrollo de diferentes soluciones a problemas de la vida real que requieren un algoritmo eficiente.\\nGrandes empresas de desarrollo como Google, Microsoft, IBM entre otras utilizan estas competencias como principal medio de reclutamiento de personal, por lo que se hace evidente la necesidad de participaci\xf3n en ellas.\\nHay muchas personas para quienes la programaci\xf3n es como un sue\xf1o embrujado. La programaci\xf3n no es m\xe1s que un arte de hablar con las m\xe1quinas y decirles qu\xe9 hacer, cu\xe1ndo hacerlo y por qu\xe9 hacerlo. La mayor\xeda de los estudiantes escuchan esta palabra en el colegio. Para muchos de ellos, la programaci\xf3n comienza con \\"C\\" y termina en \\"C\\". \\nLa programaci\xf3n competitiva es una forma avanzada de programaci\xf3n que se ocupa de problemas del mundo real. Aqu\xed vemos nuestro c\xf3digo gobernando el mundo. Pero escribir dicho c\xf3digo requiere destreza con pasi\xf3n.\\nSe tiene claro que un c\xf3digo es b\xe1sicamente nuestra l\xf3gica detr\xe1s de cualquier problema en lenguaje de alto nivel. Pero la l\xf3gica por s\xed sola no es suficiente para escribir un c\xf3digo perfecto. Requiere una comprensi\xf3n m\xe1s profunda de t\xe9rminos t\xe9cnicos como complejidad, sintaxis y el arte de crear grandes soluciones a trav\xe9s de los c\xf3digos m\xe1s cortos posibles. Todo esto solo se puede lograr a trav\xe9s de la pr\xe1ctica. Pero si la pr\xe1ctica se fusiona con una buena gu\xeda, se puede llegar al dominio. Este objetivo se puede lograr a trav\xe9s de los siguientes pasos: \\n1. Obtenga una comprensi\xf3n profunda\\nEn primer lugar, estudie todos los conceptos del lenguaje de programaci\xf3n profundamente. Siempre use libros est\xe1ndar. Hoy en d\xeda, hay muchas plataformas en l\xednea disponibles donde los competidores de todo el mundo comparten sus conocimientos e intentan facilitar los conceptos.\\n2. Seguir un enfoque jer\xe1rquico\\nIntente comenzar a codificar utilizando problemas m\xe1s simples. Antes de escribir directamente el c\xf3digo, primero haga un diagrama de flujo de la l\xf3gica que se est\xe1 utilizando. Esto aumentar\xe1 la cantidad de c\xf3digos correctos que no solo agudizar\xe1n tus habilidades sino que tambi\xe9n aumentar\xe1n tu confianza.\\n3. Implementaci\xf3n en la vida real\\nUna vez que se acostumbre a los c\xf3digos y la programaci\xf3n b\xe1sica, intente crear c\xf3digos que resuelvan tus problemas de la vida diaria. Estos pueden incluir la libreta de calificaciones de cualquier estudiante, el sistema de reserva de boletos, el sistema de administraci\xf3n de la biblioteca, etc. De esta manera obtendr\xe1 confianza.\\n4. Simplificar el c\xf3digo\\nAhora el siguiente paso es acortar el c\xf3digo. Suponga que crea un c\xf3digo simple para el sistema de administraci\xf3n de una biblioteca. Ahora intente abreviarlo de tal manera que la misma tarea se pueda lograr de una manera mucho m\xe1s simple y m\xe1s corta. Primero puede ver el problema y crear su propio c\xf3digo. Ahora vea la soluci\xf3n \xf3ptima para aprender c\xf3mo se puede reducir. Esta es la fase m\xe1s importante y la transici\xf3n de la programaci\xf3n b\xe1sica a la programaci\xf3n competitiva.\\n5. No se rinda, l\xe1ncese a los leones\\nAhora comience a participar en competencias de codificaci\xf3n. Las competiciones pueden ser en su escuela, en l\xednea o a nivel nacional. Aqu\xed encontrara personas igual que usted compitiendo y ret\xe1ndose unos con otros. Aqu\xed, debe escribir la soluci\xf3n \xf3ptima y eso tambi\xe9n en el menor tiempo posible. Obviamente, dado que es una competencia, es la supervivencia del m\xe1s apto. Un entorno competitivo amistoso hace que la tasa de aprendizaje sea m\xe1s r\xe1pida e implica aprender mediante un mecanismo divertido. Adem\xe1s de esto, tambi\xe9n obtendr\xe1 una calificaci\xf3n de acuerdo con sus presentaciones exitosas del c\xf3digo y las competiciones que gane, lo que mejora su perfil profesional.\\n6. Comience a difundir su conocimiento\\nUna vez que se convierta en un maratonista, no se guarde los conocimientos. Exti\xe9ndalos. Comp\xe1rtalos con sus estudiantes o aprendices, sus compa\xf1eros y a trav\xe9s del mundo. Su conocimiento aumenta m\xe1s si lo comparte con otros.\\n","complejidad_tiempo":null,"java":null,"cpp":null,"py":null,"orden":0,"suborden":99,"fecha_creacion":"2020-12-06 20:56:42","fecha_modificacion":"2020-12-06 20:59:24"},{"ID":269,"supergrupo":"Teoria","tema":"Operadores matem\xe1ticos, l\xf3gicos y comparativos","texto":"\xbfQu\xe9 es un operador l\xf3gico?\\nLos operadores l\xf3gicos, utilizados en Inform\xe1tica, l\xf3gica proposicional y \xe1lgebra booleana, entre otras disciplinas, nos proporcionan un resultado a partir de que se cumpla o no una cierta condici\xf3n, producen un resultado booleano, y sus operandos son tambi\xe9n valores l\xf3gicos o asimilables a ellos (los valores num\xe9ricos son asimilados a verdadero o falso seg\xfan su valor sea cero o distinto de cero). Esto genera una serie de valores que, en los casos m\xe1s sencillos, pueden ser parametrizados con los valores num\xe9ricos 0 y 1. La combinaci\xf3n de dos o m\xe1s operadores l\xf3gicos conforma una funci\xf3n l\xf3gica.\\nLos operadores l\xf3gicos son tres, dos de ellos son binarios, el \xfaltimo (negaci\xf3n) es unario. Tienen una doble posibilidad de representaci\xf3n depende el lenguaje: \\n- \\"Y\\" l\xf3gico -> && -> AND\\n- \\"O\\" l\xf3gico -> || -> OR\\n- Negaci\xf3n l\xf3gica  -> ! -> NOT\\nLas expresiones conectadas con los operadores && y || se eval\xfaan de izquierda a derecha, y la evaluaci\xf3n se detiene tan pronto como el resultado verdadero o falso es conocido.\\n\xbfQu\xe9 es una operaci\xf3n matem\xe1tica?\\nUna operaci\xf3n matem\xe1tica es un proceso mediante el cual se logra la transformaci\xf3n de una o m\xe1s cantidades en otra cantidad llamada resultado.\\nToda operaci\xf3n matem\xe1tica tiene unos valores de entrada, y presenta una regla de definici\xf3n que se\xf1ala el tipo de proceso que se debe realizar para llegar al resultado.\\nJunto con los valores de entrada se coloca un s\xedmbolo que se denomina operador matem\xe1tico.\\nHay operaciones matem\xe1ticas que nos son muy conocidas, cuyos operadores tambi\xe9n lo son: por ejemplo, el + que se\xf1ala una suma, la rayita   ?  que indica una resta, y los operadores de multiplicaci\xf3n *, divisi\xf3n / y residuo %.\\n\xbfQu\xe9 es un operador comparativo?\\nLos operadores de comparaci\xf3n comparan dos expresiones y devuelven un valor booleano que representa la relaci\xf3n de sus valores. Existen operadores para comparar valores num\xe9ricos, operadores para comparar cadenas y operadores para comparar objetos.\\n","complejidad_tiempo":null,"java":null,"cpp":null,"py":null,"orden":0,"suborden":99,"fecha_creacion":"2020-12-06 20:56:42","fecha_modificacion":"2020-12-06 20:59:24"},{"ID":270,"supergrupo":"Teoria","tema":"Tipos de variables b\xe1sicas","texto":"En programaci\xf3n, las variables son espacios reservados en la memoria que, como su nombre indica, pueden cambiar de contenido a lo largo de la ejecuci\xf3n de un programa. Una variable corresponde a un \xe1rea reservada en la memoria principal del ordenador.\\nPor buenas pr\xe1cticas, el identificador de la variable (Nombre de la variable) debe ser mnemot\xe9cnico, es decir que debe reflejar el uso dentro del programa de la misma.\\nEl tipo de dato inform\xe1tico es un atributo de una parte de los datos que indica al ordenador (y al programador) algo sobre la clase de datos sobre los que se va a procesar. Esto incluye imponer restricciones en los datos, como qu\xe9 valores pueden tomar y qu\xe9 operaciones se pueden realizar. Tipos de datos comunes son: enteros, cadenas alfanum\xe9ricas, fechas, horas, colores, coches o cualquier cosa que se nos ocurra. Por ejemplo, el tipo \\"int\\" representa un conjunto de enteros. \xc9ste es un concepto propio de la inform\xe1tica, m\xe1s espec\xedficamente de los lenguajes de programaci\xf3n, aunque tambi\xe9n se encuentra relacionado con nociones similares de las matem\xe1ticas y la l\xf3gica.\\nDebido a que las variables contienen o apuntan a valores de tipos determinados, las operaciones sobre las mismas y el dominio de sus propios valores est\xe1n determinadas por el tipo de datos en cuesti\xf3n.\\nTipo de dato l\xf3gico:\\nEl tipo de dato l\xf3gico o booleano es en computaci\xf3n aquel que puede representar valores de l\xf3gica binaria, esto es 2 valores, que normalmente representan falso o verdadero. Se utiliza normalmente en la programaci\xf3n, estad\xedstica, electr\xf3nica, matem\xe1ticas (\xe1lgebra booleana) y otras.\\nTipo de dato entero:\\nEl tipo de dato entero en computaci\xf3n se usa para representar un subconjunto finito de los n\xfameros enteros. El mayor n\xfamero que se puede representar depende del tama\xf1o del espacio usado por el dato y la posibilidad (o no) de representar n\xfameros negativos. Los tipos de dato entero disponibles y su tama\xf1o dependen del lenguaje de programaci\xf3n usado as\xed como la arquitectura en cuesti\xf3n.\\nTipo de dato car\xe1cter:\\nEn terminolog\xeda inform\xe1tica y de telecomunicaciones, un car\xe1cter es un s\xedmbolo que representa cada car\xe1cter de un lenguaje natural. Un ejemplo de car\xe1cter es una letra, un n\xfamero o un signo de puntuaci\xf3n.\\nCadena de caracteres:\\nEn programaci\xf3n, una cadena de caracteres o frase (string en ingl\xe9s) es una secuencia ordenada de longitud arbitraria (aunque finita) de elementos que pertenecen a un cierto alfabeto. En general, una cadena de caracteres es una sucesi\xf3n de caracteres (letras, n\xfameros u otros signos o s\xedmbolos).\\nDesde el punto de vista de la programaci\xf3n, si no se ponen restricciones al alfabeto, una cadena podr\xe1 estar formada por cualquier combinaci\xf3n finita de todo el juego de caracteres disponibles (las letras de la \'a\' a la \'z\' y de la \'A\' a la \'Z\', los n\xfameros del \'0\' al \'9\', el espacio en blanco \' \', s\xedmbolos diversos \'!\', \'@\', \'%\', entre otros). Un caso especial de cadena es la que contiene cero caracteres, a esta cadena se le llama cadena vac\xeda.\\n","complejidad_tiempo":null,"java":null,"cpp":null,"py":null,"orden":0,"suborden":99,"fecha_creacion":"2020-12-06 20:56:43","fecha_modificacion":"2020-12-06 20:59:24"},{"ID":271,"supergrupo":"Teoria","tema":"Lectura e impresi\xf3n","texto":"Las lecturas e impresiones de nuestros ejercicios de programaci\xf3n competitiva, sus algoritmos base y sus modificaciones se realizan por la consola (STDIN, STDOUT), por lo que por lo general la programaci\xf3n de entornos gr\xe1ficos para nuestros c\xf3digos no es v\xe1lida, los siguientes c\xf3digos muestran ejemplos de c\xf3mo se realizan las entradas y salidas de diferentes tipos de variables.","complejidad_tiempo":"Ejemplo de entrada\\n6555\\n73653736353\\n463553\\n345543234\\na\\nholamundo\\n101\\n","java":"import java.io.BufferedReader;\\nimport java.io.IOException;\\nimport java.io.InputStreamReader;\\nimport java.util.Scanner;\\n\\npublic class LecturaEscritura {\\n    //Variables Globales\\n    static int numeroentero;\\n    static long numeroenterolargo;\\n    static float numerodecimal;\\n    static double numerodecimallargo;\\n    static char caracter;\\n    static String cadena;\\n    static byte bits;\\n\\n    public static void main(String[] args) throws IOException {\\n        System.out.println(\\"Lectura\\\\n\\");\\n        lecturaLenta();\\n        lecturaRapida();\\n        System.out.println(\\"\\");\\n        System.out.println(\\"Impresi\xf3n \\\\n\\");\\n        impresionNormal();\\n        impresionConFormato();\\n    }\\n\\n    static void lecturaLenta() {\\n        //Objeto lector\\n        Scanner sc = new Scanner(System.in);\\n        //Lectura con tipo especificado\\n        numeroentero = sc.nextInt();\\n        numeroenterolargo = sc.nextLong();\\n        numerodecimal = sc.nextFloat();\\n        numerodecimallargo = sc.nextDouble();\\n        caracter = sc.next().charAt(0);\\n        cadena = sc.next();\\n        bits = sc.nextByte();\\n    }\\n    static void lecturaRapida() throws IOException {\\n        //Objeto lector\\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\\n        //Lectura como cadena y conversi\xf3n a tipo\\n        numeroentero = Integer.parseInt(br.readLine());\\n        numeroenterolargo = Long.parseLong(br.readLine());\\n        numerodecimal = Float.parseFloat(br.readLine());\\n        numerodecimallargo = Double.parseDouble(br.readLine());\\n        caracter = br.readLine().charAt(0);\\n        cadena = br.readLine();\\n        bits = Byte.parseByte(br.readLine());\\n    }\\n\\n    static void impresionNormal() {\\n        System.out.println(numeroentero);\\n        System.out.println(numeroenterolargo);\\n        System.out.println(numerodecimal);\\n        System.out.println(numerodecimallargo);\\n        System.out.println(caracter);\\n        System.out.println(cadena);\\n        System.out.println(bits);\\n    }\\n\\n    static void impresionConFormato() {\\n        //Se especifica el tipo de dato o la forma en que se imprimira\\n        System.out.printf(\\"%d \\\\n\\", numeroentero);\\n        System.out.printf(\\"%d \\\\n\\", numeroenterolargo);\\n        System.out.printf(\\"%f \\\\n\\", numerodecimal);\\n        System.out.printf(\\"%e \\\\n\\", numerodecimal);\\n        System.out.printf(\\"%f \\\\n\\", numerodecimallargo);\\n        System.out.printf(\\"%e \\\\n\\", numerodecimallargo);\\n        System.out.printf(\\"%s \\\\n\\", caracter);\\n        System.out.printf(\\"%s \\\\n\\", cadena);\\n        System.out.printf(\\"%s \\\\n\\", bits);\\n    }\\n}\\n","cpp":"//Unicas 2 librerias que se usan en c++ (Contienen todas)\\n#include<bits/stdc++.h>\\n#include<cstdlib>\\nusing namespace std;\\n//variables globales\\nint numeroentero;\\nlong numeroenterolargo;\\nfloat numerodecimal;\\ndouble numerodecimallargo;\\nchar caracter;\\nstring cadena;\\n\\nvoid lecturaLenta() {\\n        //Lectura con tipo especificado\\n        cin>>numeroentero;\\n        cin>>numeroenterolargo;\\n        cin>>numerodecimal;\\n        cin>>numerodecimallargo;\\n        cin>>caracter;\\n        cin>>cadena;\\n}\\nvoid lecturaRapida() {\\n        //Lectura como cadena y conversi\xf3n a tipo (En c++ & es necesario)\\n        scanf(\\"%d\\",&numeroentero);\\n        scanf(\\"%lld\\",&numeroenterolargo);\\n        scanf(\\"%f\\",&numerodecimal);\\n        scanf(\\"%lf\\",&numerodecimallargo);\\n        scanf(\\"%s\\",&caracter);\\n        scanf(\\"%s\\",cadena.c_str());\\n}\\nvoid impresionNormal() {\\n        cout<<numeroentero<<endl;\\n        cout<<numeroenterolargo<<endl;\\n        cout<<numerodecimal<<endl;\\n        cout<<numerodecimallargo<<endl;\\n        cout<<caracter<<endl;\\n        cout<<cadena<<endl;\\n}\\n void impresionConFormato() {\\n        //Se especifica el tipo de dato o la forma en que se imprimira\\n        printf(\\"%d \\\\n\\",numeroentero);\\n        printf(\\"%lld \\\\n\\",numeroenterolargo);\\n        printf(\\"%f \\\\n\\",numerodecimal);\\n        printf(\\"%e \\\\n\\",numerodecimal);\\n        printf(\\"%lf \\\\n\\",numerodecimallargo);\\n        printf(\\"%e \\\\n\\",numerodecimallargo);\\n        printf(\\"%c \\\\n\\",caracter);\\n        printf(\\"%s \\\\n\\",cadena.c_str());\\n}\\n        \\nint main (int argc, char *argv[]) {\\n        cout<<\\"Lectura\\\\n\\"<<endl;\\n        lecturaLenta();\\n        cout<<\\"Impresi\xf3n \\\\n\\"<<endl;\\n        impresionNormal();\\n        cout<<endl;\\n        cout<<\\"Lectura\\\\n\\"<<endl;\\n        lecturaRapida();\\n        cout<<\\"Impresi\xf3n \\\\n\\"<<endl;\\n        impresionConFormato();\\n        return 0;\\n}     \\n","py":"#Los comentarios en Python se usa el # (Numeral)\\n#variables globales\\n#la identaci\xf3n define el orden\\nnumeroentero = int(0)\\nnumeroenterolargo = int(0)\\nnumerodecimal = float(0)\\nnumerodecimallargo = float(0)\\ncaracter = \'\'\\ncadena = \\"\\"\\nprint(\\"Lectura\\")\\n#Lectura con tipo especificado\\nnumeroentero = int(input())\\nnumeroenterolargo = int(input())\\nnumerodecimal = float(input())\\nnumerodecimallargo = float(input())\\ncaracter = input()\\ncadena = str(input())\\nprint(\\"Impresi\xf3n\\")\\nprint(numeroentero)\\nprint(numeroenterolargo)\\nprint(numerodecimal)\\nprint(numerodecimallargo)\\nprint(caracter)\\nprint(cadena)\\nprint(\\"Impresi\xf3n formateada\\")\\n#Se especifica el tipo de dato o la forma en que se imprimira\\n#obligatorio usar el % \\nprint(\\"%d\\" % numeroentero)\\nprint(\\"%d\\" % numeroenterolargo)\\nprint(\\"%f\\" % numerodecimal)\\nprint(\\"%e\\" % numerodecimal)\\nprint(\\"%f\\" % numerodecimallargo)\\nprint(\\"%e\\" % numerodecimallargo)\\nprint(\\"%c\\" % caracter)\\nprint(\\"%s\\" % cadena)\\n","orden":0,"suborden":99,"fecha_creacion":"2020-12-06 20:56:43","fecha_modificacion":"2020-12-06 20:59:24"},{"ID":272,"supergrupo":"Teoria","tema":"Condicionales y ciclos","texto":"Un condicional, como su nombre lo indica, es una condici\xf3n para discernir entre una opci\xf3n u otra, y en el proceso mental normalmente se manifiesta con un \u201cSi\u201d; por ejemplo: Si va a llover, coja el paraguas. Sint\xe1cticamente, IF es la palabra reservada para desencadenar el poder de los condicionales en el c\xf3digo. ELSE expresa \u201cen el caso contrario\u201d. Siguiendo con el ejemplo anterior de la lluvia: if va a llover coja el paraguas else coja el vestido de ba\xf1o.\\n\\nUn bucle o ciclo, en programaci\xf3n, es una secuencia que ejecuta repetidas veces un trozo de c\xf3digo, hasta que la condici\xf3n asignada a dicho bucle deja de cumplirse. Los tres bucles m\xe1s utilizados en programaci\xf3n son el bucle while, el bucle for y el bucle do-while.\\n","complejidad_tiempo":"Ejemplo de entrada\\n5\\n","java":"import java.util.Scanner;\\n\\npublic class CondicionalesCiclos {\\n\\n    public static void main(String[] args) {\\n        Scanner sc = new Scanner(System.in);\\n        //Lectura \\n        int numero = sc.nextInt();\\n        //Estructura de un condicional\\n        //Dentro el parentesis va la condicion a revisar\\n        //Si se cumple se realiza las siguientes lineas\\n        //En caso contrario pasa al else \\n        //y se realiza las lineas siguientes del else\\n        if (numero % 2 == 0) {\\n            System.out.println(\\"Es par\\");\\n        } else {\\n            System.out.println(\\"Es impar\\");\\n        }\\n        System.out.println(\\"\\");\\n        System.out.println(\\"Ciclo for \\");\\n        // variable iteradora, condicion , acumulador\\n        for (int i = 0; i < 10; i++) {\\n            System.out.println(i);\\n        }\\n        System.out.println(\\"Ciclo while\\");\\n        //Variable, condicion, al final acumulador\\n        int acumulador = 0;\\n        while (acumulador < 10) {\\n            System.out.println(acumulador);\\n            acumulador++;\\n\\n        }\\n        System.out.println(\\"Ciclo do while\\");\\n        //Haga hasta que una condici\xf3n se cumpla\\n        acumulador = 0;\\n        do {\\n            System.out.println(acumulador);\\n            acumulador++;\\n        } while (acumulador < 10);\\n        System.out.println(\\"Ciclo for each\\");\\n        //Iterar entre todos los elementos que tenga una estructura\\n        //Sin importar el tama\xf1o \\n        int numeros[] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 0};\\n        for (int o : numeros) {\\n            System.out.println(o);\\n        }\\n\\n    }\\n\\n}\\n","cpp":"#include<bits/stdc++.h>\\n#include<cstdlib>\\nusing namespace std;\\n\\nint main(int argc, char *argv[]) {\\n    int n\xfamero;\\n    cin>>n\xfamero;\\n    //Estructura de un condicional\\n    //Dentro el parentesis va la condicion a revisar\\n    //Si se cumple se realiza las siguientes lineas\\n    //En caso contrario pasa al else \\n    //y se realiza las lineas siguientes del else\\n    if (n\xfamero % 2 == 0) {\\n        cout << \\"Es par\\" << endl;\\n    } else {\\n        cout << \\"Es impar\\" << endl;\\n    }\\n    cout << endl;\\n    cout << \\"Ciclo for \\" << endl;\\n    // variable iteradora, condicion , acumulador\\n    for (int i = 0; i < 10; i++) {\\n        cout << i << endl;\\n    }\\n    cout << \\"Ciclo while\\" << endl;\\n    //Variable, condicion, al final acumulador\\n    int acumulador = 0;\\n    while (acumulador < 10) {\\n        cout << acumulador << endl;\\n        acumulador++;\\n    }\\n    cout << \\"Ciclo do while\\" << endl;\\n    //Haga hasta que una condici\xf3n se cumpla\\n    acumulador = 0;\\n    do {\\n        cout << acumulador << endl;\\n        acumulador++;\\n    } while (acumulador < 10);\\n    cout << \\"Ciclo for each\\" << endl;\\n    //Iterar entre todos los elementos que tenga una estructura\\n    //Sin importar el tama\xf1o \\n    int n\xfameros[] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 0};\\n    for (int o : n\xfameros) {\\n        cout << o << endl;\\n    }\\n    return 0;\\n}\\n","py":"numero = 0;\\nnumero = int(input())\\n#Estructura de un condicional\\n#Dentro el parentesis va la condicion a revisar\\n#Si se cumple se realiza las siguientes lineas\\n#En caso contrario pasa al else \\n#y se realiza las lineas siguientes del else\\nif (numero % 2 == 0):\\n    print(\\"Es par\\")\\nelse: \\n    print(\\"Es impar\\")\\nprint(\\"Ciclo for \\")\\n#variable iteradora, rango inicio,final\\nfor i in range (0, 10):\\n    print(i)\\nprint(\\"Ciclo while\\")\\n#Variable, condicion, al final acumulador\\nacumulador = 0;\\nwhile (acumulador < 10):\\n    print(acumulador)\\n    acumulador = acumulador + 1;\\nprint(\\"Ciclo for each\\")\\n#Iterar entre todos los elementos que tenga una estructura\\n#Sin importar el tama\xf1o \\nnumeros = [1, 2, 3, 4, 5, 6, 7, 8, 9, 0]\\nfor o in numeros:\\n    print(o)\\n","orden":0,"suborden":99,"fecha_creacion":"2020-12-06 20:56:43","fecha_modificacion":"2020-12-06 20:59:24"},{"ID":273,"supergrupo":"Teoria","tema":"Conversiones, parseos, y casteos de variables","texto":"El casting consiste en la conversi\xf3n de tipos de datos similares (compatibles) entre s\xed, generalmente a trav\xe9s de la herencia.\\nPor otra parte, el parsing consiste en analizar el formato de una sentencia de texto, y obtener informaci\xf3n si el formato es correcto.\\n","complejidad_tiempo":null,"java":"import java.math.BigDecimal;\\nimport java.math.BigInteger;\\n\\npublic class Main {\\n\\n    public static void main(String[] args) {\\n        int enteropequenio = 5;\\n        long enterogrande = 100L;\\n        float decimalpequenio = 3.4f;\\n        double decimalgrande = 3.4;\\n        String cadena = \\"125\\";\\n        char numerosolitario = \'7\';\\n        boolean booleano = true;\\n        // conversi\xf3n a string\\n        System.out.println(\\"------------A String----------\\");\\n        System.out.println(Integer.toString(enteropequenio));\\n        System.out.println(Long.toString(enterogrande));\\n        System.out.println(Float.toString(decimalpequenio));\\n        System.out.println(Double.toString(decimalgrande));\\n        System.out.println(Character.toString(numerosolitario));\\n        System.out.println(Boolean.toString(booleano));\\n        // parseo de string a entero\\n        System.out.println(\\"------------A n\xfameros----------\\");\\n        int basedeentrada = 10;\\n        System.out.println(Integer.parseInt(cadena, basedeentrada));\\n        System.out.println(Long.parseLong(cadena, basedeentrada));\\n        System.out.println(Float.parseFloat(cadena));\\n        System.out.println(Double.parseDouble(cadena));\\n        System.out.println(Character.valueOf(cadena.charAt(0)));\\n        System.out.println(Boolean.parseBoolean(\\"true\\"));\\n        // casteo a entero\\n        System.out.println(\\"------------A int----------\\");\\n        System.out.println((int) enterogrande);\\n        System.out.println((int) decimalpequenio);\\n        System.out.println((int) decimalgrande);\\n        System.out.println((int) numerosolitario);\\n        System.out.println((int) (booleano ? 1 : 0));\\n        //casteo a long\\n        System.out.println(\\"------------A long----------\\");\\n        System.out.println((long) enteropequenio);\\n        System.out.println((long) decimalpequenio);\\n        System.out.println((long) decimalgrande);\\n        System.out.println((long) numerosolitario);\\n        System.out.println((long) (booleano ? 1 : 0));\\n        // casteo a float\\n        System.out.println(\\"------------A float----------\\");\\n        System.out.println((float) enteropequenio);\\n        System.out.println((float) enterogrande);\\n        System.out.println((float) decimalgrande);\\n        System.out.println((float) numerosolitario);\\n        System.out.println((float) (booleano ? 1 : 0));\\n        // casteo a double\\n        System.out.println(\\"------------A double----------\\");\\n        System.out.println((double) enteropequenio);\\n        System.out.println((double) enterogrande);\\n        System.out.println((double) decimalpequenio);\\n        System.out.println((double) numerosolitario);\\n        System.out.println((double) (booleano ? 1 : 0));\\n        // casteo a char \\n        System.out.println(\\"------------A char----------\\");\\n        System.out.println((char) enteropequenio);\\n        System.out.println((char) enterogrande);\\n        System.out.println((char) decimalpequenio);\\n        System.out.println((char) numerosolitario);\\n        System.out.println((char) (booleano ? 1 : 0));\\n        //biginteger y big decimal (SOLO JAVA)\\n        System.out.println(\\"------------bigdecimal y big integer----------\\");\\n        BigInteger numeroenorme = new BigInteger(cadena);\\n        //mientras quepa en la variable\\n        int cambio = numeroenorme.intValue();\\n        BigDecimal decimalenorme = new BigDecimal(cadena);\\n        //mientras quepa en la variable\\n        double cambio2 = decimalenorme.doubleValue();\\n        System.out.println(cambio);\\n        System.out.println(cambio2);\\n    }\\n}\\n","cpp":"#include<bits/stdc++.h>\\nusing namespace std;\\ntypedef long long int ll;\\n\\nint main() {\\n    int enteropequenio = 5;\\n    ll enterogrande = 100LL;\\n    float decimalpequenio = 3.4f;\\n    double decimalgrande = 3.4;\\n    string cadena = \\"125\\";\\n    char numerosolitario = \'7\';\\n    bool booleano = true;\\n    string cast;\\n    // conversi\xf3n a string\\n    printf(\\"------------A String----------\\\\n\\");\\n    cast.push_back(numerosolitario);\\n    printf(\\"%s\\\\n\\", to_string(enteropequenio).c_str());\\n    printf(\\"%s\\\\n\\", to_string(enterogrande).c_str());\\n    printf(\\"%s\\\\n\\", to_string(decimalpequenio).c_str());\\n    printf(\\"%s\\\\n\\", to_string(decimalgrande).c_str());\\n    printf(\\"%s\\\\n\\", cast.c_str());\\n    printf(\\"%s\\\\n\\", to_string(booleano).c_str());\\n    printf(\\"------------A Numero----------\\\\n\\");\\n    printf(\\"%d\\\\n\\", stoi(cadena));\\n    printf(\\"%lld\\\\n\\", stoll(cadena));\\n    printf(\\"%f\\\\n\\", stof(cadena));\\n    printf(\\"%f\\\\n\\", stof(cadena));\\n    printf(\\"%c\\\\n\\", (cadena[0]));\\n    printf(\\"%d\\\\n\\", stoi(to_string(booleano).c_str()));\\n    printf(\\"------------A int----------\\\\n\\");\\n    printf(\\"%d\\\\n\\", (int) enterogrande);\\n    printf(\\"%d\\\\n\\", (int) decimalpequenio);\\n    printf(\\"%d\\\\n\\", (int) decimalgrande);\\n    printf(\\"%d\\\\n\\", (int) numerosolitario);\\n    printf(\\"%d\\\\n\\", (int) (booleano ? 1 : 0));\\n    printf(\\"------------A Long----------\\\\n\\");\\n    printf(\\"%lld\\\\n\\", (ll) enteropequenio);\\n    printf(\\"%lld\\\\n\\", (ll) decimalpequenio);\\n    printf(\\"%lld\\\\n\\", (ll) decimalgrande);\\n    printf(\\"%lld\\\\n\\", (ll) numerosolitario);\\n    printf(\\"%lld\\\\n\\", (ll) (booleano ? 1 : 0));\\n    printf(\\"------------A Float----------\\\\n\\");\\n    printf(\\"%f\\\\n\\", (float) enteropequenio);\\n    printf(\\"%f\\\\n\\", (float) enteropequenio);\\n    printf(\\"%f\\\\n\\", (float) decimalgrande);\\n    printf(\\"%f\\\\n\\", (float) numerosolitario);\\n    printf(\\"%f\\\\n\\", (float) (booleano ? 1 : 0));\\n    // casteo a char\\n    printf(\\"------------A char----------\\\\n\\");\\n    printf(\\"%c\\\\n\\", (char) enteropequenio);\\n    printf(\\"%c\\\\n\\", (char) enterogrande);\\n    printf(\\"%c\\\\n\\", (char) decimalpequenio);\\n    printf(\\"%c\\\\n\\", (char) numerosolitario);\\n    printf(\\"%c\\\\n\\", (char) (booleano ? 1 : 0));\\n}\\n","py":"entero = 5\\ndecimal = 3.4\\ncadena = \'125\'\\nnumsolitario = \'7\'\\nbooleano = True\\n\\n\\n# Conversion a Cadena\\nprint(\'-------------- A String -------------\')\\nprint(str(entero))\\nprint(str(decimal))\\nprint(str(numsolitario))\\nprint(str(booleano))\\n\\n# Conversion Cadena a Numero\\nprint(\'---------- Cadena a Numero ----------\')\\nprint(int(cadena))\\nprint(int(cadena[0]))\\nprint(float(cadena))\\nprint(bool(booleano))\\n\\n# Conversion a Entero\\nprint(\'--------------- A Int ---------------\')\\nprint(int(decimal))\\nprint(ord(numsolitario))\\nprint(int(booleano))\\n\\n# Conversion a Decimal\\nprint(\'-------------- A Float --------------\')\\nprint(float(entero))\\nprint(float(cadena))\\nprint(float(numsolitario))\\nprint(float(booleano))\\n\\n# Conversion a Caracter\\nprint(\'-------------- A Char ---------------\')\\nprint(chr(65))\\nprint(chr(100))\\n","orden":0,"suborden":99,"fecha_creacion":"2020-12-06 20:56:44","fecha_modificacion":"2020-12-06 20:59:24"},{"ID":274,"supergrupo":"Teoria","tema":"String Matching y expresiones regulares","texto":"Una expresi\xf3n regular, o expresi\xf3n racional, es una secuencia de caracteres que conforma un patr\xf3n de b\xfasqueda. Tambi\xe9n son conocidas como regex por su contracci\xf3n de las palabras inglesas regular expression. Son principalmente utilizadas para la b\xfasqueda de patrones de cadenas de caracteres u operaciones de sustituciones.\\nL\xf3gicos: \\n\u2022 x|y: x o y\\n\u2022 xy: x seguido de y\\n\u2022 (): Agrupaci\xf3n \\nIntervalos de caracteres:\\n\u2022 [abc]: Cualquiera de los caracteres entre corchetes. Pueden especificarse rangos, por ejemplo ([a-d] que equivale a [abcd]).\\n\u2022 [^abc]: Cualquier car\xe1cter que no est\xe9 entre los corchetes.\\n\u2022 [a-zA-Z]: a a la z o A a la Z (Rango).\\n\u2022 [a-z&&[def]]: d,e, o f (Intersecci\xf3n)\\n\u2022 [a-b&&[^bc]]: (Substracci\xf3n)\\nIntervalos de caracteres predefinidos:\\n\u2022 .: Cualquier car\xe1cter individual, salvo el de salto de l\xednea\\n\u2022 \\\\d: Cualquier car\xe1cter de digito, equivalente a [0-9]\\n\u2022 \\\\D: Cualquier car\xe1cter que no sea del digito, equivalente a [^0-9]\\n\u2022 \\\\s: Cualquier car\xe1cter individual de espacio en blanco (Espacios, tabulaciones, saltos de p\xe1gina o saltos de l\xednea)\\n\u2022 \\\\S: Cualquier car\xe1cter individual que no sea un espacio en blanco\\n\u2022 \\\\w: Cualquier car\xe1cter alfanum\xe9rico\\n\u2022 \\\\W: Cualquier car\xe1cter que no sea alfanum\xe9rico\\n","complejidad_tiempo":null,"java":null,"cpp":null,"py":null,"orden":0,"suborden":99,"fecha_creacion":"2020-12-06 20:56:44","fecha_modificacion":"2020-12-06 20:59:24"},{"ID":275,"supergrupo":"Teoria","tema":"Lectura especializada y alta velocidad de procesamiento","texto":"Existen ejercicios dentro de programaci\xf3n competitiva en los cuales la cantidad de entradas es tan grande que usar los medios convencionales de lectura el algoritmo no es lo suficientemente r\xe1pido, retornando un Time Limit Exceeded (Tiempo l\xedmite excedido), es decir la soluci\xf3n no se encuentra lo suficientemente optimizada o no es lo suficientemente r\xe1pida, en este cap\xedtulo presentamos nuevas formas de lectura y procesamiento de entradas que pueden ayudarnos a resolver este problema.","complejidad_tiempo":null,"java":"JAVA Fast Reader\\n// FastReader (Lectura rapida con tokenizer)\\nimport java.io.BufferedReader;\\nimport java.io.IOException;\\nimport java.io.InputStreamReader;\\nimport java.util.StringTokenizer;\\n\\npublic class Main {\\n\\n    static class FastReader {\\n\\n        BufferedReader br;\\n        StringTokenizer st;\\n\\n        public FastReader() {\\n            br = new BufferedReader(new InputStreamReader(System.in));\\n        }\\n\\n        String next() {\\n            while (st == null || !st.hasMoreElements()) {\\n                try {\\n                    st = new StringTokenizer(br.readLine());\\n                } catch (IOException e) {\\n                    e.printStackTrace();\\n                }\\n            }\\n            return st.nextToken();\\n        }\\n\\n        int nextInt() {\\n            return Integer.parseInt(next());\\n        }\\n\\n        long nextLong() {\\n            return Long.parseLong(next());\\n        }\\n\\n        double nextDouble() {\\n            return Double.parseDouble(next());\\n        }\\n\\n        String nextLine() {\\n            String str = \\"\\";\\n            try {\\n                str = br.readLine();\\n            } catch (IOException e) {\\n                e.printStackTrace();\\n            }\\n            return str;\\n        }\\n    }\\n\\n    public static void main(String[] args) {\\n        FastReader s = new FastReader();\\n        int n = s.nextInt();\\n        int k = s.nextInt();\\n        int count = 0;\\n        while (n-- > 0) {\\n            int x = s.nextInt();\\n            if (x % k == 0) {\\n                count++;\\n            }\\n        }\\n        System.out.println(count);\\n    }\\n}\\nJAVA UltraReader\\n(Puede fallar en algunos juzgadores)\\n// UltraReader (Lectura ultra rapida usando streams y buffers)\\n\\nimport java.io.DataInputStream;\\nimport java.io.FileInputStream;\\nimport java.io.IOException;\\n\\npublic class Main {\\n\\n    static class UltraReader {\\n\\n        final private int BUFFER_SIZE = 1 << 16;\\n        private DataInputStream din;\\n        private byte[] buffer;\\n        private int bufferPointer, bytesRead;\\n\\n        public UltraReader() {\\n            din = new DataInputStream(System.in);\\n            buffer = new byte[BUFFER_SIZE];\\n            bufferPointer = bytesRead = 0;\\n        }\\n\\n        public UltraReader(String file_name) throws IOException {\\n            din = new DataInputStream(new FileInputStream(file_name));\\n            buffer = new byte[BUFFER_SIZE];\\n            bufferPointer = bytesRead = 0;\\n        }\\n\\n        public String readLine() throws IOException {\\n            byte[] buf = new byte[64]; // line length \\n            int cnt = 0, c;\\n            while ((c = read()) != -1) {\\n                if (c == \'\\\\n\') {\\n                    break;\\n                }\\n                buf[cnt++] = (byte) c;\\n            }\\n            return new String(buf, 0, cnt);\\n        }\\n\\n        public int nextInt() throws IOException {\\n            int ret = 0;\\n            byte c = read();\\n            while (c <= \' \') {\\n                c = read();\\n            }\\n            boolean neg = (c == \'-\');\\n            if (neg) {\\n                c = read();\\n            }\\n            do {\\n                ret = ret * 10 + c - \'0\';\\n            } while ((c = read()) >= \'0\' && c <= \'9\');\\n\\n            if (neg) {\\n                return -ret;\\n            }\\n            return ret;\\n        }\\n\\n        public long nextLong() throws IOException {\\n            long ret = 0;\\n            byte c = read();\\n            while (c <= \' \') {\\n                c = read();\\n            }\\n            boolean neg = (c == \'-\');\\n            if (neg) {\\n                c = read();\\n            }\\n            do {\\n                ret = ret * 10 + c - \'0\';\\n            } while ((c = read()) >= \'0\' && c <= \'9\');\\n            if (neg) {\\n                return -ret;\\n            }\\n            return ret;\\n        }\\n\\n        public double nextDouble() throws IOException {\\n            double ret = 0, div = 1;\\n            byte c = read();\\n            while (c <= \' \') {\\n                c = read();\\n            }\\n            boolean neg = (c == \'-\');\\n            if (neg) {\\n                c = read();\\n            }\\n\\n            do {\\n                ret = ret * 10 + c - \'0\';\\n            } while ((c = read()) >= \'0\' && c <= \'9\');\\n\\n            if (c == \'.\') {\\n                while ((c = read()) >= \'0\' && c <= \'9\') {\\n                    ret += (c - \'0\') / (div *= 10);\\n                }\\n            }\\n\\n            if (neg) {\\n                return -ret;\\n            }\\n            return ret;\\n        }\\n\\n        private void fillBuffer() throws IOException {\\n            bytesRead = din.read(buffer, bufferPointer = 0, BUFFER_SIZE);\\n            if (bytesRead == -1) {\\n                buffer[0] = -1;\\n            }\\n        }\\n\\n        private byte read() throws IOException {\\n            if (bufferPointer == bytesRead) {\\n                fillBuffer();\\n            }\\n            return buffer[bufferPointer++];\\n        }\\n\\n        public void close() throws IOException {\\n            if (din == null) {\\n                return;\\n            }\\n            din.close();\\n        }\\n    }\\n\\n    public static void main(String[] args) throws IOException {\\n        UltraReader s = new UltraReader();\\n        int n = s.nextInt();\\n        int k = s.nextInt();\\n        int count = 0;\\n        while (n-- > 0) {\\n            int x = s.nextInt();\\n            if (x % k == 0) {\\n                count++;\\n            }\\n        }\\n        System.out.println(count);\\n    }\\n}\\n","cpp":"C++ cin optimizado\\n#include <bits/stdc++.h> \\nusing namespace std; \\n  \\nint main() \\n{ \\n    // Se agregan las dos lineas de abajo permitiendo que CIN tenga la\\n    //velocidad de SCANF\\n    ios_base::sync_with_stdio(false); \\n    cin.tie(NULL);     \\n    int n, k, t; \\n    int cnt = 0; \\n    cin >> n >> k; \\n    for (int i=0; i<n; i++) \\n    { \\n        cin >> t; \\n        if (t % k == 0) \\n            cnt++; \\n    } \\n    cout << cnt << \\"\\\\n\\"; \\n    return 0; \\n} \\nC++ INT FastScan\\n//Lectura rapida de numeros enteros (Solo valido para int)\\n#include <bits/stdc++.h> \\nusing namespace std;\\n\\nvoid fastscan(int &number) {\\n    //Variable para indicar el signo del n\xfamero\\n    bool negative = false;\\n    register int c;\\n    number = 0;\\n    // Extraer el caracter actual de buffer\\n    c = getchar();\\n    if (c == \'-\') {\\n        // El numero es negativo\\n        negative = true;\\n        //Extraer el siguiente caracter del buffer\\n        c = getchar();\\n    }\\n    //se sigue extrayendo caracteres si son enteros\\n    // es decir su valor de ASCII esta entre \'0\'(48) y \'9\' (57)  \\n    for (; (c > 47 && c < 58); c = getchar())\\n        number = number * 10 + c - 48;\\n    //si la entrada escaneada tiene signo negativo\\n    //se niega el valor del numero \\n    if (negative)\\n        number *= -1;\\n}\\n\\nint main() {\\n    int number;\\n    fastscan(number);\\n    cout << number << \\"\\\\n\\";\\n    return 0;\\n} \\n","py":"PYTHON FastInOut\\n# Se importa los modulos de lectura y escritura estandar \\nfrom sys import stdin\\nfrom sys import stdout\\n# Entrada de toda la linea\\nn = stdin.readline() \\n# Llenando una lista por medio de entrada de toda la linea\\narr = [int(x) for x in stdin.readline().split()] \\n#Inicializamos variable\\nsummation = 0\\n# Calcular sum\\nfor x in arr: \\n    summation += x \\n# imprimir respuesta a trav\xe9s de write, \\n# el m\xe9todo write escribe solo strings\\n# por lo que necesitamos convertir cualquier \\n# dato en string para usarlo\\nstdout.write(str(summation)) \\nPYTHON n\xfameros en una sola l\xednea\\n#Lectura de multiples numeros que estan en una misma linea\\nimport sys \\ndef get_ints(): return map(int, sys.stdin.readline().strip().split()) \\na,b,c,d = get_ints() \\n\\n","orden":0,"suborden":99,"fecha_creacion":"2020-12-06 20:56:44","fecha_modificacion":"2020-12-06 20:59:24"},{"ID":276,"supergrupo":"Teoria","tema":"Importancia de las pruebas en la programaci\xf3n competitiva","texto":"Aunque la pr\xe1ctica es la \xfanica forma de garantizar un mayor rendimiento en los concursos de programaci\xf3n, tener algunos trucos bajo la manga garantiza la optimizaci\xf3n y una depuraci\xf3n r\xe1pida.\\nMuchas veces al resolver problemas, enfrentamos problemas como el Tiempo l\xedmite excedido (Time limit Exceeded), la soluci\xf3n incorrecta (Wrong answer), el error de tiempo de ejecuci\xf3n (Runtime Error) y el l\xedmite de memoria excedido (Memory limit exceded) porque despu\xe9s de dise\xf1ar el algoritmo no probamos la eficiencia, la correcci\xf3n, la complejidad del tiempo y la ejecuci\xf3n del algoritmo en un gran conjunto de entradas para fines de prueba.\\nAqu\xed es donde las pruebas de estr\xe9s vienen al rescate. La prueba de esfuerzo es la forma com\xfan de encontrar el error en un algoritmo.\\nLas pruebas de esfuerzo ayudan a encontrar un algoritmo eficiente y a corregir los problemas que puedan presentar los algoritmos, pero tambi\xe9n ven por qu\xe9 ciertos enfoques no funcionan. En particular, es f\xe1cil esbozar soluciones codiciosas intuitivas a cualquier problema, pero tales soluciones a menudo no funcionan en la realidad.\\n\u2022 Busque el caso m\xe1s sencillo del ejercicio y pru\xe9belo\\n\u2022 Busque un caso intermedio y pru\xe9belo\\n\u2022 Busque el caso m\xe1s grande (Seg\xfan las restricciones del ejercicio) y pru\xe9belo.\\n\u2022 Compruebe si los resultados son los correctos, en caso de que no, realice una depuraci\xf3n paso a paso para verificar en que l\xednea de c\xf3digo ha fallado el algoritmo.\\n\u2022 Si luego de estos pasos no logra resolver el problema, pruebe otro enfoque desde el principio\\n\u2022 No se desespere si no logra encontrar el error, la paciencia permite mejor flujo de ideas.\\n","complejidad_tiempo":null,"java":null,"cpp":null,"py":null,"orden":0,"suborden":99,"fecha_creacion":"2020-12-06 20:56:45","fecha_modificacion":"2020-12-06 20:59:24"},{"ID":277,"supergrupo":"Teoria","tema":"Ejercicios iniciales ","texto":"Aqu\xed podremos encontrar ejercicios de programaci\xf3n competitiva de nivel b\xe1sico, real\xedcelos con el fin de familiarizarse con ellos, puede usar traductor para entenderlos, pero procure realizarlos por m\xe9rito propio, luego de varios intentos, puede investigar la soluci\xf3n de los mismos en su buscador de confianza.\\nPara buscar la p\xe1gina de los ejercicios de CodeChef, utilice el siguiente link y cambie los \u201c???\u201d por el alias del ejercicio:\\n\\n \\nhttps://www.codechef.com/problems/???\\n \\n1. FLOW002 \\n2. FLOW006 \\n3. START01 \\n4. FLOW001 \\n5. INTEST \\n","complejidad_tiempo":null,"java":null,"cpp":null,"py":null,"orden":0,"suborden":99,"fecha_creacion":"2020-12-06 20:56:45","fecha_modificacion":"2020-12-06 20:59:24"},{"ID":1,"supergrupo":"B\xfasquedas","tema":"Binary Search","texto":"<div style=\\"text-align: justify;\\"><span style=\\"font-size: 10pt;\\">La b\xfasqueda binaria, tambi\xe9n conocida como b\xfasqueda de intervalo medio o b\xfasqueda logar\xedtmica, es un algoritmo de b\xfasqueda que encuentra la posici\xf3n de un valor en un arreglo ordenado. Compara el valor con el elemento en el medio del arreglo, si no son iguales, la mitad en la cual el valor no puede estar es eliminada y la b\xfasqueda sigue en la mitad restante hasta que el valor se encuentre.&nbsp;</span></div><div style=\\"text-align: justify;\\"><span style=\\"font-size: 10pt;\\"><br></span></div><div style=\\"text-align: justify;\\"><span style=\\"font-size: 10pt;\\">La b\xfasqueda binaria es computada en el peor de los casos en un tiempo logar\xedtmico, realizando  O (log n)  comparaciones, donde n es el n\xfamero de elementos del arreglo y log es el logaritmo.</span></div>","complejidad_tiempo":"Mejor caso :    O(1)            Peor caso :      O(log n)             Promedio: O(log n)","java":"// Implementaci\xf3n Java de una b\xfasqueda binaria recursiva \\n\\npublic class BinarySearch {\\n    /*Retorna el indice de x si se encuentra presente\\n    en arr[1,2,....r]*, si no retorna -1*/\\n    static int binarySearch(int arr[], int l, int r, int x) {\\n        if (r >= l) {\\n            int mid = l + (r - l) / 2;\\n            /*Si el elemento esta presente en el medio*/\\n            if (arr[mid] == x) {\\n                return mid;\\n            }\\n            /*Si el elemento es m\xe1s peque\xf1o que la mitad\\n            entonces solo puede estar presente en el \\n            subarreglo izquierdo*/\\n            if (arr[mid] > x) {\\n                return binarySearch(arr, l, mid - 1, x);\\n            }\\n            //Si no el elemento solo pued estar presente \\n            //en el subarreglo derecho \\n            return binarySearch(arr, mid + 1, r, x);\\n        }\\n        //Si llegamos aqui, el elemento no esta presente\\n        //en el arreglo\\n        return -1;\\n    }\\n\\n    public static void main(String args[]) {\\n        int arr[] = {2, 3, 4, 10, 40};\\n        int n = arr.length;\\n        int x = 10;\\n        int result = binarySearch(arr, 0, n - 1, x);\\n        if (result == -1) {\\n            System.out.println(\\"Elemento no presente\\");\\n        } else {\\n            System.out.println(\\"Element encontrado en la posici\xf3n \\" + result);\\n        }\\n    }\\n}\\n","cpp":"#include <bits/stdc++.h>\\n#include <cstdlib>\\n\\nint binarysearch(int arr[], int l, int r, int x) {\\n    if (r >= l) {\\n        int mid = l + (r - 1) / 2;\\n        if (arr[mid] == x) {\\n            return mid;\\n        }\\n        if (arr[mid] > x) {\\n            return binarysearch(arr, l, mid - 1, x);\\n        } else {\\n            return binarysearch(arr, mid + 1, r, x);\\n        }\\n    }\\n    return -1;\\n}\\n\\nint main() {\\n    int arr[] = {2, 3, 4, 5, 6};\\n    int n = sizeof (arr) / sizeof (arr[0]);\\n    int x = 5;\\n    int resultado = binarysearch(arr, 0, n - 1, x);\\n    if (resultado == -1) {\\n        printf(\\"elemento no presente\\");\\n    } else {\\n        printf(\\"elemento encontrado en el indice: %d\\", resultado);\\n    }\\n    return 0;\\n}\\n","py":"def BinarySearch(arr, inicio, fin, numerobuscado):\\n    if(fin >= inicio):\\n        medio = int(inicio + (fin-1) / 2)\\n        if(arr[medio] == numerobuscado):\\n            return medio\\n        if(arr[medio] > numerobuscado):\\n            return BinarySearch(arr, inicio, medio-1, numerobuscado)\\n        else:\\n            return BinarySearch(arr, medio + 1, fin, numerobuscado)\\n    return -1\\n\\narr = [1, 2, 3, 4, 5, 6]\\ntam = len(arr)\\nnumerobuscado = 5\\nresultado = int (BinarySearch(arr, 0, tam-1, numerobuscado))\\nif(resultado == -1):\\n    print(\\"Elemento no encontrado\\")\\nelse:\\n    print(\\"Elemento encontrado en la posicion\\", resultado)\\n","orden":2,"suborden":0,"fecha_creacion":"2020-12-02 17:30:29","fecha_modificacion":"2020-12-06 22:47:01"},{"ID":2,"supergrupo":"B\xfasquedas","tema":"Exponential Search","texto":"<div style=\\"text-align: justify;\\"><span style=\\"font-size: 10pt;\\">El nombre de este algoritmo de b\xfasqueda puede ser enga\xf1oso, ya que funciona en tiempo O (Log n).&nbsp;</span></div><div style=\\"text-align: justify; font-weight: normal;\\">El nombre proviene de la forma en que busca un elemento. La b\xfasqueda binaria exponencial es particularmente \xfatil para b\xfasquedas ilimitadas, donde el tama\xf1o del vector es infinito.&nbsp;</div><div style=\\"text-align: justify; \\"><span style=\\"font-weight: bold;\\"><br></span></div><div style=\\"text-align: justify; \\"><span style=\\"font-weight: bold;\\">La b\xfasqueda exponencial implica dos pasos:&nbsp;</span></div><div style=\\"text-align: justify; font-weight: normal;\\"><br></div><div style=\\"text-align: justify; font-weight: normal;\\"><span style=\\"white-space:pre\\">\\t</span>1)  Encuentra el rango donde el elemento est\xe1 presente&nbsp;</div><div style=\\"text-align: justify; font-weight: normal;\\"><span style=\\"white-space:pre\\">\\t</span>2)  Hacer una b\xfasqueda binaria en el rango encontrado arriba.&nbsp;</div><div style=\\"text-align: justify; font-weight: normal;\\"><br></div><div style=\\"text-align: justify; font-weight: normal;\\">La idea es comenzar con el tama\xf1o del subarreglo 1, comparar su \xfaltimo elemento con x, luego probar el tama\xf1o 2, luego el 4 y as\xed sucesivamente hasta que el \xfaltimo elemento de un subconjunto no sea mayor que el tama\xf1o del vector.\\r\\nUna vez que encontramos un \xedndice i (despu\xe9s de duplicar repetidamente i), sabemos que el elemento debe estar presente entre i / 2 - i, i / 2 porque se encontr\xf3 un valor mayor en la iteraci\xf3n anterior.&nbsp;</div><div style=\\"text-align: justify; font-weight: normal;\\"><br></div><div style=\\"text-align: justify; \\"><span style=\\"font-weight: bold;\\">Podemos tener en cuenta que:&nbsp;</span></div><div style=\\"text-align: justify; font-weight: normal;\\"><br></div><div style=\\"text-align: justify; font-weight: normal;\\"><span style=\\"white-space:pre\\">\\t</span>- La b\xfasqueda binaria exponencial es particularmente \xfatil para b\xfasquedas ilimitadas, donde el tama\xf1o del vector es infinito.&nbsp;</div><div style=\\"text-align: justify; font-weight: normal;\\"><span style=\\"white-space:pre\\">\\t</span>- Funciona mejor que la B\xfasqueda binaria para vectores limitados, y tambi\xe9n cuando el elemento a buscar est\xe1 m\xe1s cerca del primer elemento.\\r\\n</div>","complejidad_tiempo":"Mejor caso :    O(1)            Peor caso :      O(log n)             Promedio: O(log n)             ","java":"//Programa Java para encontrar un elemento\\n//x en un array ordenado usando Exponential Search\\n\\nimport java.util.Arrays;\\n\\npublic class ExponentialSearch {\\n\\n    /* Retorna posici\xf3n de la primerra ocurrencia \\n    de x en un arreglo*/\\n    static int exponentialSearch(int arr[],int n, int x) {\\n        // Si z esta presente en la primera localizaci\xf3n en si misma\\n        if (arr[0] == x) {\\n            return 0;\\n        }\\n        /*Encuentra ranfo para la busqueda binaria\\n        por repetidos dobles*/\\n        int i = 1;\\n        while (i < n && arr[i] <= x) {\\n            i = i * 2;\\n        }\\n        //llama la busqueda binaria para el rango encontrado \\n        return Arrays.binarySearch(arr, i / 2,\\n                Math.min(i, n), x);\\n    }\\n\\n    public static void main(String args[]) {\\n        int arr[] = {2, 3, 4, 10, 40};\\n        int x = 10;\\n        int result = exponentialSearch(arr, arr.length, x);\\n        System.out.println((result < 0)\\n                ? \\"El elemento no esta presente en el array\\"\\n                : \\"Elemento encontrado en : \\"\\n                + result);\\n    }\\n}\\n","cpp":"#include <bits/stdc++.h>\\n#include <cstdlib>\\nusing namespace std;\\n\\nint binarySearch(int arr[], int l, int r, int x) {\\n    if (r >= l) {\\n        int mid = l + (r - l) / 2;\\n        if (arr[mid] == x) {\\n            return mid;\\n        }\\n        if (arr[mid] > x) {\\n            return binarySearch(arr, l, mid - 1, x);\\n        } else {\\n            return binarySearch(arr, mid + 1, r, x);\\n        }\\n    }\\n\\n    return -1;\\n}\\n\\nint exponentialSearch(int arr[], int n, int x) {\\n    if (arr[0] == x) {\\n        return 0;\\n    }\\n    int i = 1;\\n    while (i < n && arr[i] <= x) {\\n        i = i * 2;\\n    }\\n    return binarySearch(arr, i / 2, min(i, n), x);\\n}\\n\\nint main(int argc, char const *argv[]) {\\n    int arr[] = {1, 2, 3, 4, 5};\\n    int n = sizeof (arr) / sizeof (arr[0]);\\n    int x = 5;\\n    int result = exponentialSearch(arr, n, x);\\n    if (result < 0) {\\n        cout << \\"El resultado no esta presente en el Array\\" << endl;\\n    } else {\\n        cout << \\"Elemento encontrado en el indice \\" << result << endl;\\n    }\\n\\n    return 0;\\n}\\n","py":"def BinarySearch(arr, inicio, fin, numerobuscado):\\n    if(fin>inicio):\\n        medio = int((inicio+(fin-1))/2)\\n        if(arr[medio] == numerobuscado):\\n            return medio\\n        if(arr[medio] > numerobuscado):\\n            return BinarySearch(arr,inicio,medio-1,numerobuscado)\\n        else:\\n            return BinarySearch(arr,medio+1,fin,numerobuscado)\\n    return -1\\n\\ndef exponentialSearch(arr,tam,buscado):\\n    if(arr[0] == buscado):\\n        return 0\\n    i = int(1)\\n    while (i<tam and arr[i]<=buscado):\\n        i = i*2\\n    return BinarySearch(arr,i//2,min(i,tam),buscado)\\n\\nlista = [1,2,3,4,5,6]\\nbuscado = int(9)\\nresultado = int(exponentialSearch(lista, len(lista), buscado))\\nif(resultado < 0):\\n    print (\\"El elemento no se encuentra dentro del arreglo\\")\\nelse:\\n    print(\\"El elemento esta en la posicion:\\",resultado)","orden":2,"suborden":1,"fecha_creacion":"2020-12-02 17:30:29","fecha_modificacion":"2020-12-07 02:20:34"},{"ID":3,"supergrupo":"B\xfasquedas","tema":"Array Max/Min Search","texto":"Tenemos un Array en donde queremos buscar el valor m\xe1s peque\xf1o y el valor m\xe1s grande del mismo de forma eficiente haciendo la menor cantidad de comparaciones, para resolver este problema podemos emplear la siguiente aproximaci\xf3n.","complejidad_tiempo":"Mejor caso :    O(n)            Peor caso :      O(n)             Promedio: O(n)             ","java":"/* Programa Java que busca el m\xe1ximo y el m\xednimo\\nen un array*/\\npublic class ArrayMaxMinSearch {\\n    /*Clase Pair es usada para retornar\\n    dos valores de getMinMax()*/\\n    static class Pair {\\n        int min;\\n        int max;\\n    }\\n\\n    static Pair getMinMax(int arr[], int n) {\\n        Pair minmax = new Pair();\\n        int i;\\n        /*Si es el unico elemento, lo retorna como min y max*/\\n        if (n == 1) {\\n            minmax.max = arr[0];\\n            minmax.min = arr[0];\\n            return minmax;\\n        }\\n        /*Si hay m\xe1s de un elemento, \\n        entones inicializa min y m\xe1s*/\\n        if (arr[0] > arr[1]) {\\n            minmax.max = arr[0];\\n            minmax.min = arr[1];\\n        } else {\\n            minmax.max = arr[1];\\n            minmax.min = arr[0];\\n        }\\n        for (i = 2; i < n; i++) {\\n            if (arr[i] > minmax.max) {\\n                minmax.max = arr[i];\\n            } else if (arr[i] < minmax.min) {\\n                minmax.min = arr[i];\\n            }\\n        }\\n        return minmax;\\n    }\\n\\n    public static void main(String args[]) {\\n        int arr[] = {1000, 11, 445, 1, 330, 3000};\\n        int arr_size = 6;\\n        Pair minmax = getMinMax(arr, arr_size);\\n        System.out.printf(\\"\\\\nEl minimo elemento es %d\\", minmax.min);\\n        System.out.printf(\\"\\\\nEl maximo elemento es %d\\", minmax.max);\\n    }\\n\\n}\\n","cpp":"#include <bits/stdc++.h>\\n#include <cstdlib>\\nusing namespace std;\\n\\nstruct pairMaxMin {\\n    int min;\\n    int max;\\n};\\n\\nstatic pairMaxMin getMinMax(int arr[], int n) {\\n    pairMaxMin minmax;\\n    int i;\\n\\n    if (n == 1) {\\n        minmax.max = arr[0];\\n        minmax.min = arr[0];\\n        return minmax;\\n    }\\n    if (arr[0] > arr[1]) {\\n        minmax.max = arr[0];\\n        minmax.min = arr[1];\\n    } else {\\n        minmax.max = arr[1];\\n        minmax.min = arr[0];\\n    }\\n    for (i = 2; i < n; i++) {\\n        if (arr[i] > minmax.max) {\\n            minmax.max = arr[i];\\n        } else if (arr[i] < minmax.min) {\\n            minmax.min = arr[i];\\n        }\\n    }\\n\\n    return minmax;\\n}\\n\\nint main(int argc, char** argv) {\\n    int arr[] = {12, 3, 4, 345, 65, 43};\\n    int len = sizeof (arr) / sizeof (arr[0]);\\n    pairMaxMin minmax = getMinMax(arr, len);\\n    printf(\\"el minimo elemento es %d\\\\n\\", minmax.min);\\n    printf(\\"el maximo elemento es %d\\\\n\\", minmax.max);\\n    return 0;\\n}\\n","py":"class Pair:\\n    max,min = int(),int()\\n\\ndef  getmaxmin(lista,n):\\n    maxmin = Pair()\\n    i = int()\\n    if n==1:\\n        maxmin.max = lista[0]\\n        maxmin.max = lista[0]\\n        return maxmin\\n    if lista[0]>lista[1]:\\n        maxmin.max = lista[0]\\n        maxmin.min = lista[1]\\n    else:\\n        maxmin.max = lista[1]\\n        maxmin.min = lista[0]\\n    for i in range(2,n):\\n        if lista[i]>maxmin.max:\\n            maxmin.max = lista[i]\\n        elif lista[i]<maxmin.min:\\n            maxmin.min = lista[i]\\n    return maxmin\\n\\nlista = [1, 422, 789, 2333, 2444]\\nn = len(lista)\\nresultado = getmaxmin(lista,n)\\nprint(\\"El minimo es \\",resultado.min)\\nprint(\\"El maximo es \\",resultado.max)\\n","orden":2,"suborden":2,"fecha_creacion":"2020-12-02 17:30:29","fecha_modificacion":"2020-12-06 20:04:14"},{"ID":4,"supergrupo":"B\xfasquedas","tema":"Fibonacci Search","texto":"<div style=\\"text-align: justify;\\"><span style=\\"font-size: 10pt;\\">La b\xfasqueda de Fibonacci es una t\xe9cnica basada en la comparaci\xf3n que utiliza los n\xfameros de Fibonacci para buscar un elemento en un array ordenado.&nbsp;</span></div><div style=\\"text-align: justify; \\"><span style=\\"font-weight: bold;\\">Similitudes con la b\xfasqueda binaria:&nbsp;</span></div><div style=\\"text-align: justify; font-weight: normal;\\"><span style=\\"white-space:pre\\">\\t</span>- Trabaja con arrays ordenados.</div><div style=\\"text-align: justify; font-weight: normal;\\"><span style=\\"white-space:pre\\">\\t</span>- Es un algoritmo de dividir y conquistar.</div><div style=\\"text-align: justify; font-weight: normal;\\"><span style=\\"white-space:pre\\">\\t</span>- Tiene una complejidad de registro y tiempo.&nbsp;</div><div style=\\"text-align: justify; \\"><span style=\\"font-weight: bold;\\"><br></span></div><div style=\\"text-align: justify; \\"><span style=\\"font-weight: bold;\\">Diferencias con la b\xfasqueda binaria:&nbsp;</span></div><div style=\\"text-align: justify; font-weight: normal;\\"><span style=\\"white-space:pre\\">\\t</span>- La b\xfasqueda de Fibonacci divide un array dado en partes desiguales&nbsp;</div><div style=\\"text-align: justify; font-weight: normal;\\"><span style=\\"white-space:pre\\">\\t</span>- La b\xfasqueda binaria usa el operador de divisi\xf3n para dividir el rango.&nbsp;</div><div style=\\"text-align: justify; font-weight: normal;\\"><br></div><div style=\\"text-align: justify; \\"><span style=\\"font-weight: bold;\\">Puntos importantes:</span></div><div style=\\"text-align: justify; font-weight: normal;\\"><span style=\\"white-space:pre\\">\\t</span>- La b\xfasqueda de Fibonacci no usa /, pero usa + y -. El operador de la divisi\xf3n puede ser costoso en algunas CPU.&nbsp;</div><div style=\\"text-align: justify; font-weight: normal;\\"><span style=\\"white-space:pre\\">\\t</span>- La b\xfasqueda de Fibonacci examina elementos relativamente m\xe1s cercanos en pasos subsiguientes. Por lo tanto, cuando el vector de entrada es grande y no cabe en la memoria cach\xe9 de la <span style=\\"white-space:pre\\">\\t</span>&nbsp; CPU o incluso en la RAM, la b\xfasqueda de Fibonacci puede ser \xfatil.&nbsp;</div><div style=\\"text-align: justify; font-weight: normal;\\"><span style=\\"white-space:pre\\">\\t</span>- La idea es encontrar primero el n\xfamero de Fibonacci m\xe1s peque\xf1o que sea mayor o igual a la longitud del vector dado.\\r\\n</div>","complejidad_tiempo":null,"java":"// Programa Java para Fibonacci Search  \\npublic class FibonacciSearch {\\n\\n    //Funci\xf3n de utilidad para biscar el minimo\\n    //de dos elementos\\n    public static int min(int x, int y) {\\n        return (x <= y) ? x : y;\\n    }\\n\\n    /* Regresa el indice de x si esta presente, si no retorna -1*/\\n    public static int fibonacciSearch(int arr[],\\n            int x, int n) {\\n        /* Inicializa los n\xfameros fibonacci*/\\n        int fibMMm2 = 0; // (m-2)esimo n\xfamero fibonacci. \\n        int fibMMm1 = 1; // (m-1)esimo n\xfamero fibonacci. \\n        int fibM = fibMMm2 + fibMMm1; // mesimo fibonacci.\\n        /* FibM va a ser almacenado como el m\xe1s peque\xf1o\\n        fibonacci m\xe1s grande o igual a n*/\\n        while (fibM < n) {\\n            fibMMm2 = fibMMm1;\\n            fibMMm1 = fibM;\\n            fibM = fibMMm2 + fibMMm1;\\n        }\\n        // Marca el rango eliminado del frente\\n        int offset = -1;\\n        /* Si bien hay elementos a inspeccionar.\\n        Tenga en cuenta que comparamos arr [fibMm2] con x.\\n        Cuando fibM se convierte en 1, fibMm2 se convierte en 0 */\\n        while (fibM > 1) {\\n            //Revisa si fibMm2 es una ubicaci\xf3n valida\\n            int i = min(offset + fibMMm2, n - 1);\\n            /*Si x es m\xe1s grande que el valor\\n            en el indice fibMm2, fuera del subarray\\n            desde offset a i*/\\n            if (arr[i] < x) {\\n                fibM = fibMMm1;\\n                fibMMm1 = fibMMm2;\\n                fibMMm2 = fibM - fibMMm1;\\n                offset = i;\\n            } \\n            /*Si x es m\xe1s grande que el valor en indice \\n            fibMm2, corta el subarreglo despues de i+1*/ \\n           else if (arr[i] > x) {\\n                fibM = fibMMm2;\\n                fibMMm1 = fibMMm1 - fibMMm2;\\n                fibMMm2 = fibM - fibMMm1;\\n            } /* Elemento encontrado, retorna indice*/ \\n     else {\\n                return i;\\n            }\\n        }\\n        /* Comparando el ultimo elemento con x*/\\n        if (fibMMm1 == 1 && arr[offset + 1] == x) {\\n            return offset + 1;\\n        }\\n        /*Elemento no encontrado, retorna -1*/\\n        return -1;\\n    }\\n\\n    public static void main(String[] args) {\\n        int arr[] = {10, 22, 35, 40, 45, 50,\\n            80, 82, 85, 90, 100};\\n        int n = 11;\\n        int x = 85;\\n        System.out.println(\\"Found at index: \\"\\n                + fibonacciSearch(arr, x, n));\\n    }\\n}\\n","cpp":"#include <bits/stdc++.h>\\n#include <cstdlib>\\nusing namespace std;\\n\\nstatic int fibonacciSearch(int arr[], int x, int n) {\\n    int fibMMm2 = 0;\\n    int fibMMm1 = 1;\\n    int fibM = fibMMm2 + fibMMm1;\\n    while (fibM < n) {\\n        fibMMm2 = fibMMm1;\\n        fibMMm1 = fibM;\\n        fibM = fibMMm2 + fibMMm1;\\n    }\\n    int offset = -1;\\n    while (fibM > 1) {\\n        int i = std::min(offset + fibMMm2, n - 1);\\n        if (arr[i] < x) {\\n            fibM = fibMMm1;\\n            fibMMm1 = fibMMm2;\\n            fibMMm2 = fibM - fibMMm1;\\n            offset = i;\\n        } else if (arr[i] > x) {\\n            fibM = fibMMm2;\\n            fibMMm1 -= fibMMm2;\\n            fibMMm2 = fibM - fibMMm1;\\n        } else {\\n            return i;\\n        }\\n    }\\n    if (fibM == 1 && arr[offset + 1] == x) {\\n        return offset + 1;\\n    }\\n    return -1;\\n}\\n\\nint main(int argc, char** argv) {\\n    //\\n    int arr[] = {10, 22, 35, 40, 45, 50, 80, 82, 85, 90, 100};\\n    int n = sizeof (arr) / sizeof (arr[0]);\\n    int x = 85;\\n    printf(\\"Encontrado en la posicion %d\\", fibonacciSearch(arr, x, n));\\n    return 0;\\n}\\n","py":"def menor(x, y):\\n    return min(x, y)\\n\\ndef FibonacciSearch(lista, x, n):\\n    if x > lista[n-1]:\\n        return -1\\n    Fm2 = int(0)\\n    Fm1 = int(1)\\n    Fms = int(Fm2 + Fm1)\\n    while Fms < n:\\n        Fm2 = Fm1\\n        Fm1 = Fms\\n        Fms = int(Fm2 + Fm1)\\n    offset = int(-1)\\n    while Fms > 1:\\n        i = int(menor(offset + Fm2, n - 1))\\n        if lista[i] < x:\\n            Fms = Fm1\\n            Fm1 = Fm2\\n            Fm2 = Fms - Fm1\\n            offset = i\\n        elif lista[i] > x:\\n            Fms = Fm2\\n            Fm1 = Fm1 - Fm2\\n            Fm2 = Fms - Fm1\\n        else:\\n            return i\\n\\n    if Fm1 == 1 and lista[offset + 1] == x:\\n        return offset + 1\\n    else:\\n        return -1\\n\\n\\nlista = [10, 22, 33, 45, 89, 99, 100]\\nn = int(len(lista))\\nx = int(input())\\nif FibonacciSearch(lista, x, n) != -1:\\n    print(\\"Encontrado en la poscion \\", FibonacciSearch(lista, x, n))\\nelse:\\n    print(\\"No encontrado\\")\\n","orden":2,"suborden":3,"fecha_creacion":"2020-12-02 17:30:29","fecha_modificacion":"2020-12-07 02:20:50"},{"ID":5,"supergrupo":"B\xfasquedas","tema":"Jump Search","texto":"<div style=\\"text-align: justify;\\"><span style=\\"font-size: 10pt;\\">Al igual que Binary Search, Jump Search es un algoritmo de b\xfasqueda para vectores ordenados.&nbsp;</span></div><div style=\\"text-align: justify; font-weight: normal;\\">La idea b\xe1sica es verificar menos elementos (que la b\xfasqueda lineal) saltando hacia delante con pasos fijos u salteando algunos elementos en lugar de buscar todos los elementos.\\r\\nEn el peor de los casos, tenemos que realizar saltos de n / m y, si el \xfaltimo valor verificado es mayor que el elemento a buscar, realizamos comparaciones de m-1 m\xe1s para la b\xfasqueda lineal.&nbsp;</div><div style=\\"text-align: justify; font-weight: normal;\\"><br></div><div style=\\"text-align: justify; font-weight: normal;\\">Por lo tanto, el n\xfamero total de comparaciones en el peor de los casos ser\xe1 ((n / m) + m-1). El valor de la funci\xf3n ((n / m) + m-1) ser\xe1 m\xednimo cuando m = ?n. Por lo tanto, el mejor tama\xf1o de paso es m = ?n.</div><div style=\\"text-align: justify; font-weight: normal;\\"><br></div><div style=\\"text-align: justify; \\"><span style=\\"font-weight: bold;\\">Puntos importantes:&nbsp;\\r\\n</span></div><div style=\\"text-align: justify; font-weight: normal;\\"><br></div><div style=\\"text-align: justify; font-weight: normal;\\"><span style=\\"white-space:pre\\">\\t</span>- Trabaja solo arreglos ordenados.&nbsp;</div><div style=\\"text-align: justify; font-weight: normal;\\"><span style=\\"white-space:pre\\">\\t</span>- El tama\xf1o \xf3ptimo de un bloque a saltar es (? n).&nbsp;</div><div style=\\"text-align: justify; font-weight: normal;\\"><br></div><div style=\\"text-align: justify; font-weight: normal;\\">Esto hace que la complejidad del tiempo de Jump Search O (? n).&nbsp;</div><div style=\\"text-align: justify; font-weight: normal;\\"><br></div><div style=\\"text-align: justify; font-weight: normal;\\">- La complejidad temporal de la b\xfasqueda por salto es entre la b\xfasqueda lineal ((O (n)) y la b\xfasqueda binaria (O (Log n)).&nbsp;</div><div style=\\"text-align: justify; font-weight: normal;\\">- La b\xfasqueda binaria es mejor que la b\xfasqueda por salto, pero la b\xfasqueda por salto tiene la ventaja de que retrocedemos solo una vez (la b\xfasqueda binaria puede requerir saltos O (Log n), considere una situaci\xf3n en la que el elemento a buscar es el elemento m\xe1s peque\xf1o o m\xe1s peque\xf1o que el m\xe1s peque\xf1o). Entonces, en un sistema donde el salto hacia atr\xe1s es costoso, usamos Jump Search.\\r\\n</div>","complejidad_tiempo":"Mejor caso :    O(? n)            Peor caso :      O(? n)             Promedio: O(? n)             ","java":"public class JumpSearch {\\n\\n    public static int jumpSearch(int[] arr, int x) {\\n        int n = arr.length;\\n        //Buscando el tama\xf1o del bloque que sera\\n        //saltado\\n        int step = (int) Math.floor(Math.sqrt(n));\\n        /* Buscando el bloque donde el elemento\\n        esta presente (Si esta presente)*/\\n        int prev = 0;\\n        while (arr[Math.min(step, n) - 1] < x) {\\n            prev = step;\\n            step += (int) Math.floor(Math.sqrt(n));\\n            if (prev >= n) {\\n                return -1;\\n            }\\n        }\\n        /*Realizando una busqueda linear para x en \\n        el bloque empezando con prev*/\\n        while (arr[prev] < x) {\\n            prev++;\\n            /*Si nosotros alcanzamos el siguiente bloque\\n            o el fin del array el elemento no esta presente*/\\n            if (prev == Math.min(step, n)) {\\n                return -1;\\n            }\\n        }\\n        // Si el elemento fue encontrado\\n        if (arr[prev] == x) {\\n            return prev;\\n        }\\n        return -1;\\n    }\\n\\n    public static void main(String[] args) {\\n        int arr[] = {0, 1, 1, 2, 3, 5, 8, 13, 21,\\n            34, 55, 89, 144, 233, 377, 610};\\n        int x = 55;\\n        //Encontrar el indice de \'x\' usando Jump Search\\n        int index = jumpSearch(arr, x);\\n        // Imprime el indice donde x fue encontrado\\n        System.out.println(\\"\\\\nN\xfamero \\" + x\\n                + \\" esta en el indice \\" + index);\\n    }\\n}\\n","cpp":"#include <bits/stdc++.h>\\n#include <cstdlib>\\nusing namespace std;\\n\\nstatic int jumpSearch(int arr[], int x, int n) {\\n    int step = int(std::floor(std::sqrt(n)));\\n    int prev = 0;\\n    while (arr[std::min(step, n) - 1] < x) {\\n        prev = step;\\n        step += int(std::floor(std::sqrt(n)));\\n        if (prev >= n) {\\n            return -1;\\n        }\\n    }\\n    while (arr[prev] < x) {\\n        prev++;\\n        if (prev == std::min(step, n)) {\\n            return -1;\\n        }\\n    }\\n    if (arr[prev] == x) {\\n        return prev;\\n    }\\n    return -1;\\n\\n}\\n\\nint main(int argc, char const *argv[]) {\\n    int arr[] = {1, 2, 3, 4, 5};\\n    int n = sizeof (arr) / sizeof (arr[0]);\\n    int x = 5;\\n    int result = jumpSearch(arr, x, n);\\n    if (result < 0) {\\n        cout << \\"El elemento no esta presente en el Array\\" << endl;\\n    } else {\\n        cout << \\"Elemento encontrado en el indice \\" << result << endl;\\n    }\\n\\n    return 0;\\n}\\n","py":"import math\\n\\ndef jumpSearch(lista, x):\\n    tamanio = len(lista)\\n    salto = int(math.floor(math.sqrt(tamanio)))\\n    previo = int(0)\\n    while(lista[min(salto, tamanio)-1] < x):\\n        previo = salto\\n        salto = salto + int(math.floor(math.sqrt(tamanio)))\\n        if(previo >= tamanio):\\n            return -1\\n    while(lista[previo] < x):\\n        previo = previo + 1\\n        if(previo == min(salto, tamanio)):\\n            return -1\\n    if(lista[previo] == x):\\n        return previo\\n    return -1\\n\\nlista = [0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144]\\nnumeroabuscar = int(input())\\nresultado = jumpSearch(lista, numeroabuscar)\\nif(resultado == -1):\\n    print(\'No encontrado\')\\nelse:\\n    print(\'Encontrado en el indice \', resultado)\\n","orden":2,"suborden":4,"fecha_creacion":"2020-12-02 17:30:29","fecha_modificacion":"2020-12-07 02:20:57"},{"ID":6,"supergrupo":"B\xfasquedas","tema":"Minimum Absolute Sum Pair","texto":"<div style=\\"text-align: justify;\\"><span style=\\"font-size: 10pt;\\">Teniendo un vector de n\xfameros, se buscan dos elementos cuya suma es la m\xe1s cercana a cero.&nbsp;</span></div><div style=\\"text-align: justify;\\">Para cada elemento de dicho vector encuentre la suma con cada otro elemento del mismo vector y compare las sumas.&nbsp;</div><div style=\\"text-align: justify;\\"><br></div><div style=\\"text-align: justify;\\">Por \xfaltimo, devolver la suma m\xednima encontrada.</div>","complejidad_tiempo":"Mejor caso :    O(n2)            Peor caso :      O(n2)             Promedio: O(n2","java":"//Programa JAVA que busque el par de n\xfameros\\n//que sumados de la minima suma absoluta\\n\\npublic class MinAbsSumPair {\\n//funci\xf3n que busca el par \\n\\n    static void minAbsSumPair(int arr[], int arr_size) {\\n        int l, r, min_sum, sum, min_l, min_r;\\n        /*El array debe tener al menos 2 elementos*/\\n        if (arr_size < 2) {\\n            System.out.println(\\"Invalid Input\\");\\n            return;\\n        }\\n        /* Inicializaci\xf3n de los valores*/\\n        min_l = 0;\\n        min_r = 1;\\n        min_sum = arr[0] + arr[1];\\n        for (l = 0; l < arr_size - 1; l++) {\\n            for (r = l + 1; r < arr_size; r++) {\\n                sum = arr[l] + arr[r];\\n                if (Math.abs(min_sum) > Math.abs(sum)) {\\n                    min_sum = sum;\\n                    min_l = l;\\n                    min_r = r;\\n                }\\n            }\\n        }\\n        System.out.println(\\" Los dos elementos los cuales \\"\\n                + \\"tienen la suma minima son \\"\\n                + arr[min_l] + \\" y \\" + arr[min_r]);\\n    }\\n\\n    public static void main(String[] args) {\\n        int arr[] = {1, 60, -10, 70, -80, 85};\\n        minAbsSumPair(arr, 6);\\n    }\\n}\\n","cpp":"#include <bits/stdc++.h>\\n#include <cstdlib>\\nusing namespace std;\\n\\nvoid minAbsSumPair(int arr[], int n) {\\n    int l, r, min_sum, sum, min_l, min_r;\\n    if (n < 2) {\\n        printf(\\"Entrada no valida\\");\\n    }\\n    min_l = 0;\\n    min_r = 1;\\n    min_sum = arr[0] + arr[1];\\n    for (l = 0; l < n - 1; ++l) {\\n        for (r = l + 1; r < n; ++r) {\\n            sum = arr[l] + arr[r];\\n            if (std::abs(min_sum) > std::abs(sum)) {\\n                min_sum = sum;\\n                min_l = l;\\n                min_r = r;\\n            }\\n        }\\n    }\\n    printf(\\"Los numero que tienen la minima suma son %d %d\\", arr[min_l], arr[min_r]);\\n}\\n\\nint main(int argc, char const *argv[]) {\\n    int arr[] = {1, -2, -10, 70, -80, 85};\\n    int n = sizeof (arr) / sizeof (arr[0]);\\n    minAbsSumPair(arr, n);\\n    return 0;\\n}\\n","py":"def minAbsSumPair(arr,n):\\n    l,r,min_sum,sum,min_l,min_r = int(),int(),int(),int(),int(),int()\\n    if n<2:\\n        print(\\"Array no tiene suficientes valores\\")\\n        return\\n    min_l = int(0)\\n    min_r = int (1)\\n    min_sum = arr[0]+arr[1]\\n    for l in range(n-1):\\n        for r in range(l+1,n):\\n            sum = arr[l]+arr[r]\\n            if abs(min_sum)>abs(sum):\\n                min_sum=sum\\n                min_l=l\\n                min_r=r\\n    print(f\\"la minima suma es: {arr[min_l]} y {arr[min_r]}\\")\\n\\narr = [1,60,-10,70,-80,85]\\nminAbsSumPair(arr,len(arr))\\n","orden":2,"suborden":5,"fecha_creacion":"2020-12-02 17:30:29","fecha_modificacion":"2020-12-06 20:04:16"},{"ID":7,"supergrupo":"B\xfasquedas","tema":"Missing Number Search","texto":"<div style=\\"text-align: justify;\\"><span style=\\"font-size: 10pt;\\">Se le da una lista de n-1 enteros y estos enteros est\xe1n en el rango de 1 a n. No hay duplicados en la lista pero nos falta uno de los enteros en la lista.\\r\\nLos pasos para resolver este problema son los siguientes:\\r\\n1) XOR todos los elementos del array, que el resultado de XOR sea X1.\\r\\n2) XOR todos los n\xfameros del 1 al n, sea XOR sea X2.\\r\\n3) XOR de X1 y X2 da el n\xfamero que falta, es decir el resultado.</span></div>","complejidad_tiempo":"Mejor caso :    O(n)            Peor caso :      O(n)             Promedio: O(n)             ","java":"public class MissingNo {\\n\\n    public static void main(String[] args) {\\n        int[] arr = {1,2,3,5,6,7,8};\\n        int missed = getMissingNo(arr, arr.length);\\n        System.out.println(\\"el numero que falta es: \\"+ missed);\\n    }\\n\\n    static int getMissingNo(int a[], int n) {\\n        int x1 = a[0];\\n        int x2 = 1;\\n        for (int i = 1; i < n; i++) {\\n            x1 ^= a[i];\\n        }\\n        for (int i = 2; i <= n + 1; i++) {\\n            x2 ^= i;\\n        }\\n        return x1 ^ x2;\\n    }\\n\\n}\\n","cpp":"#include <bits/stdc++.h>\\n#include <cstdlib>\\nusing namespace std;\\n\\nstatic int MissingNoSearch(int arr[], int n) {\\n    int x1 = arr[0];\\n    int x2 = 1;\\n    for (int i = 1; i < n; ++i) {\\n        x1 = x1^arr[i];\\n    }\\n    for (int i = 2; i <= n + 1; ++i) {\\n        x2 = x2^i;\\n    }\\n    return (x1^x2);\\n}\\n\\nint main(int argc, char const *argv[]) {\\n    int arr[] = {1, 3, 4, 5, 6, 7};\\n    int n = sizeof (arr) / sizeof (arr[0]);\\n    printf(\\"El numero faltante es : %d\\", MissingNoSearch(arr, n));\\n    return 0;\\n}\\n","py":"def getMissingNo(a,n):\\n    x1 = a[0]\\n    x2 = int(1)\\n    for i in range(1,n):\\n        x1^=a[i]\\n    for i in range(2,n+2):\\n        x2^=i\\n    return x1^x2\\n\\nlista = [1,2,3,4,5,7,8]\\nmissed = getMissingNo(lista,len(lista))\\nprint(\\"Numero perdido: \\"+ str(missed))\\n","orden":2,"suborden":6,"fecha_creacion":"2020-12-02 17:30:29","fecha_modificacion":"2020-12-07 02:21:15"},{"ID":8,"supergrupo":"B\xfasquedas","tema":"Difference Pair Search","texto":"<div style=\\"text-align: justify;\\"><span style=\\"font-size: 10pt;\\">Dado un vector sin orden y un n\xfamero n, busque si existe un par de elementos en el vector cuya diferencia es n.&nbsp;</span></div><div style=\\"text-align: justify;\\">El m\xe9todo m\xe1s simple es ejecutar dos bucles, el bucle externo selecciona el primer elemento (elemento m\xe1s peque\xf1o) y el bucle interno busca el elemento seleccionado por el bucle externo m\xe1s n.&nbsp;<span style=\\"font-size: 10pt;\\">La complejidad del tiempo de este m\xe9todo es O (n ^ 2).&nbsp;\\r\\n</span></div><div style=\\"text-align: justify;\\"><span style=\\"font-size: 10pt;\\"><br></span></div><div style=\\"text-align: justify;\\"><span style=\\"font-size: 10pt;\\">Podemos usar el ordenamiento y la b\xfasqueda binaria para mejorar la complejidad del tiempo a O (nLogn). El primer paso es ordenar el array en orden ascendente. Una vez que el array est\xe9 ordenado, recorra el array de izquierda a derecha y, para cada elemento arr [i], la b\xfasqueda binaria de arr [i] + n en arr [i + 1...n-1].&nbsp;</span></div><div style=\\"text-align: justify;\\"><span style=\\"font-size: 10pt;\\"><br></span></div><div style=\\"text-align: justify;\\"><span style=\\"font-size: 10pt;\\">Si se encuentra el elemento, devuelva el par.\\r\\nTanto el primer como el segundo paso toman O (nLogn). As\xed que la complejidad global es O (nLogn).\\r\\n\\r\\nEl segundo paso del algoritmo anterior se puede mejorar a O (n). El primer paso sigue siendo el mismo.&nbsp;</span></div><div style=\\"text-align: justify;\\"><span style=\\"font-size: 10pt;\\"><br></span></div><div style=\\"text-align: justify;\\"><span style=\\"font-size: 10pt;\\">La idea para el segundo paso es tomar dos variables de \xedndice i y j, inicializarlas como 0 y 1 respectivamente. Ahora ejecuta un bucle lineal. Si arr [j] - arr [i] es m\xe1s peque\xf1o que n, debemos buscar un arr mayor [j], as\xed que aumente j. Si arr [j] - arr [i] es mayor que n, debemos buscar un arr mayor [i], entonces incremente i.</span></div>","complejidad_tiempo":"Mejor caso :    O(nLog(n))            Peor caso :      O(nLog(n))             Promedio: O(nLog(n))  ","java":"// Programa Java para buscar un par\\n// Dada una diferencia\\n\\npublic class PairDifferenceSearch {\\n    //La funci\xf3n asume que el array esta ordenado\\n    static boolean findPair(int arr[], int n) {\\n        int size = arr.length;\\n        // Inicializa la posici\xf3n de dos elementos\\n        int i = 0, j = 1;\\n        // Busca por el par\\n        while (i < size && j < size) {\\n            if (i != j && arr[j] - arr[i] == n) {\\n                System.out.print(\\"Par Encontrado: \\"\\n                        + \\"( \\" + arr[i] + \\", \\" + arr[j] + \\" )\\");\\n                return true;\\n            } else if (arr[j] - arr[i] < n) {\\n                j++;\\n            } else {\\n                i++;\\n            }\\n        }\\n        //No encuentra el par\\n        System.out.print(\\"No hay tal par\\");\\n        return false;\\n    }\\n\\n    public static void main(String[] args) {\\n        int arr[] = {1, 8, 30, 40, 100};\\n        int n = 60;\\n        findPair(arr, n);\\n    }\\n}\\n","cpp":"#include <bits/stdc++.h>\\n#include <cstdlib>\\nusing namespace std;\\n\\nstatic bool findPair(int arr[], int n, int size) {\\n    int i = 0, j = 1;\\n    while (i < size && j < size) {\\n        if (i != j && arr[j] - arr[i] == n) {\\n            printf(\\"par encontrado (%d %d)\\", arr[i], arr[j]);\\n            return true;\\n        } else if (arr[j] - arr[i] < n) {\\n            j++;\\n        } else {\\n            i++;\\n        }\\n    }\\n    printf(\\"no hay par que de el numero\\");\\n    return false;\\n}\\n\\nint main(int argc, char const *argv[]) {\\n    int arr[] = {1, 8, 30, 40, 100};\\n    int n = 7;\\n    int size = sizeof (arr) / sizeof (arr[0]);\\n    findPair(arr, n, size);\\n    return 0;\\n}\\n","py":"def FindPair(arr,x):\\n    size = len(arr)\\n    i,j = 0,1\\n    while i<size and j<size:\\n        if i != j and arr[j] - arr[i] == x:\\n            print(f\\"par encontrado en: ({arr[i]} - {arr[j]})\\")\\n            return True\\n        elif arr[j]-arr[i]<x:\\n            j+=1\\n        else:\\n            i+=1\\n    print(\\"No existe el par que cumpla la suma de n\\")\\n    return False\\n\\narr = [1,8,30,40,100]\\nx = int(60)\\nFindPair(arr,x)\\n","orden":2,"suborden":7,"fecha_creacion":"2020-12-02 17:30:29","fecha_modificacion":"2020-12-06 20:04:17"},{"ID":9,"supergrupo":"B\xfasquedas","tema":"Ternary Search","texto":"<div style=\\"text-align: justify;\\"><span style=\\"font-size: 10pt;\\">La b\xfasqueda ternaria es un algoritmo de dividir y conquistar que se puede usar para encontrar un elemento en un array. Es similar a la b\xfasqueda binaria donde dividimos el array en dos partes pero en este algoritmo dividimos el array dado en tres partes y determinamos cu\xe1l tiene la clave (elemento buscado).&nbsp;</span></div><div style=\\"text-align: justify;\\">Podemos dividir el array en tres partes tomando mid1 y mid2, que se pueden calcular como se muestra a continuaci\xf3n.\\r\\nmid1 = l + (r-l) / 3\\r\\nmid2 = r - (r-l) / 3\\r\\nInicialmente, l y r ser\xe1n iguales a 0 y n-1 respectivamente, donde n es la longitud de la matriz.&nbsp;</div><div style=\\"text-align: justify;\\"><br></div><div style=\\"text-align: justify;\\">El array debe ordenarse para realizar una b\xfasqueda ternaria en ella.\\r\\n</div>","complejidad_tiempo":"Mejor caso :    O(nLog(n))            Peor caso :      O(nLog(n))             Promedio: O(nLog(n))             ","java":"//Programa Java para ilustrar \\n//recursivamente la aproximaci\xf3n\\n//de una b\xfasqueda ternaria\\n\\npublic class TernarySearch {\\n    //Funci\xf3n que realiza la busqueda ternaria\\n    static int ternarySearch(int l, int r, int key, int ar[]) {\\n        if (r >= l) {\\n            //encontrar el mid1 y mid 2\\n            int mid1 = l + (r - l) / 3;\\n            int mid2 = r - (r - l) / 3;\\n            //Verificar si la key esta presente en algun medio\\n            if (ar[mid1] == key) {\\n                return mid1;\\n            }\\n            if (ar[mid2] == key) {\\n                return mid2;\\n            }\\n            /*Desde que la key no este presente en el mid\\n            verifica en cada region si esta presente\\n            luego repite la operaci\xf3n de busqueda\\n            en esa regi\xf3n*/\\n            if (key < ar[mid1]) {\\n                //La key yace entre 1 y mid1\\n                return ternarySearch(l, mid1 - 1, key, ar);\\n            } else if (key > ar[mid2]) {\\n                //La key yace entre mid2 y r\\n                return ternarySearch(mid2 + 1, r, key, ar);\\n            } else {\\n                //La key  yace entre mid 1 y mid 2\\n                return ternarySearch(mid1 + 1, mid2 - 1, key, ar);\\n            }\\n        }\\n        // key no encontrada\\n        return -1;\\n    }\\n\\n    public static void main(String args[]) {\\n        int l, r, p, key;\\n        //Cree el array y ordenelo si no lo est\xe1\\n        int ar[] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};\\n        // Indice inicial\\n        l = 0;\\n        // Tama\xf1o del arreglo \\n        r = 9;\\n        // Buscando por el 5\\n        // key que va a ser buscada en el array\\n        key = 5;\\n        // Busca usando Ternary Search\\n        p = ternarySearch(l, r, key, ar);\\n        // Imprime el resultado\\n        System.out.println(\\"Indice de \\" + key + \\" es \\" + p);\\n        // Buscando por el 50\\n        // Key a ser buscada en el array\\n        key = 50;\\n        // Buscar usando Ternary Search\\n        p = ternarySearch(l, r, key, ar);\\n        // Imprime el resultado \\n        System.out.println(\\"Index of \\" + key + \\" is \\" + p);\\n    }\\n}\\n","cpp":"#include <bits/stdc++.h>\\n#include <cstdlib>\\nusing namespace std;\\n\\nstatic int ternarySearch(int left, int r, int key, int arr[]) {\\n    if (r >= left) {\\n        int mid1 = left + (r - left) / 3;\\n        int mid2 = r - (r - left) / 3;\\n        if (arr[mid1] == key) {\\n            return mid1;\\n        }\\n        if (arr[mid2] == key) {\\n            return mid2;\\n        }\\n        if (key < arr[mid1]) {\\n            return ternarySearch(left, mid1 - 1, key, arr);\\n        } else if (key > arr[mid2]) {\\n            return ternarySearch(mid2 + 1, r, key, arr);\\n        } else {\\n            return ternarySearch(mid1 + 1, mid2 - 1, key, arr);\\n        }\\n\\n    }\\n    return -1;\\n}\\n\\nint main() {\\n    int arr[] = {1, 2, 3, 4, 5, 6, 7, 8, 9};\\n    int n = sizeof (arr) / sizeof (arr[0]);\\n    int l = 0;\\n    int r = 9;\\n    int x = 5;\\n    int result = ternarySearch(l, r, x, arr);\\n    if (result < 0) {\\n        printf(\\"el numero %d no se encuentra en el array\\\\n\\", x);\\n    } else {\\n        printf(\\"indice encontrado en la posicion %d\\\\n\\", result);\\n    }\\n    return 0;\\n}\\n","py":"def TernarySearch(l,r,key,arr):\\n    if r >= l:\\n        mid1 = l+(r-l)//3\\n        mid2 = r-(r-l)//3\\n        if arr[mid1]==key:\\n            return mid1\\n        if arr[mid2] == key:\\n            return mid2\\n        if key<arr[mid1]:\\n            return TernarySearch(l,mid1-1,key,arr)\\n        elif key>arr[mid2]:\\n            return TernarySearch(mid2+1,r,key,arr)\\n        else:\\n            return TernarySearch(mid1+1,mid2-1,key,arr)\\n\\n    return -1\\n\\nl,r,resultado,key = int(),int(),int(),int()\\narr = [1,2,3,4,5,6,7,8,9,10]\\nl = int(0)\\nr = len(arr)-1\\nkey = 7\\nresultado=TernarySearch(l,r,key,arr)\\nif resultado==-1:\\n    print(\\"No existe el dato en el arreglo\\")\\nelse:\\n    print(\\"Encontrado en el indice: \\"+str(resultado))\\n","orden":2,"suborden":8,"fecha_creacion":"2020-12-02 17:30:29","fecha_modificacion":"2020-12-07 02:21:35"},{"ID":10,"supergrupo":"Ordenamientos","tema":"Bubble Sort","texto":"<div style=\\"text-align: justify;\\"><span style=\\"font-size: 10pt;\\">Ordenamiento burbuja es el algoritmo de ordenamiento m\xe1s simple que existe, funciona intercambiando repetidamente los elementos adyacentes si est\xe1n en orden incorrecto.\\r\\nSi existen demasiadas recursiones puede llegar a ser demasiado demorado o resultar en un error en tiempo de ejecuci\xf3n.</span></div>","complejidad_tiempo":"Mejor caso :    O(n)            Peor caso :      O(n2)             Promedio: O(n2)","java":"\\n//Programa java que realiza Bubble Sort Recursivo\\n\\nimport java.util.Arrays;\\n\\npublic class RecursiveBubbleSort {\\n\\n    static void bubbleSort(int arr[], int n) {\\n        // Caso base\\n        if (n == 1) {\\n            return;\\n        }\\n        //Un paso de Bubble Sort, luego de este\\n        //paso, el elemento m\xe1s largo es movido\\n        //  hasta el final\\n        for (int i = 0; i < n - 1; i++) {\\n            if (arr[i] > arr[i + 1]) {   //intercambia arr[i], arr[i+1] \\n                int temp = arr[i];\\n                arr[i] = arr[i + 1];\\n                arr[i + 1] = temp;\\n            }\\n        }\\n        bubbleSort(arr, n - 1);\\n    }\\n\\n    public static void main(String[] args) {\\n        int arr[] = {64, 34, 25, 12, 22, 11, 90};\\n        bubbleSort(arr, arr.length);\\n        System.out.println(\\"Array ordenado : \\");\\n        System.out.println(Arrays.toString(arr));\\n    }\\n}\\n","cpp":"#include <bits/stdc++.h>\\n#include <cstdlib>\\nusing namespace std;\\ntypedef long long int ll;\\n\\nvoid bubble_sort(int arr[], int len) {\\n    if (len == 1) {\\n        return;\\n    }\\n    for (int j = 0; j < len; j++) {\\n        for (int i = 0; i < len - 1; i++) {\\n            if (arr[i] > arr[i + 1]) {\\n                int temp = arr[i];\\n                arr[i] = arr[i + 1];\\n                arr[i + 1] = temp;\\n            }\\n        }\\n    }\\n}\\n\\nint main() {\\n    int arr[] = {9, 7, 6, 4, 3, 2, 1, 7, 8, 43, 43, 4, 54, 54, 3, 234, 1, 23};\\n    int len = sizeof (arr) / sizeof (arr[0]);\\n    bubble_sort(arr, len);\\n    for (int i = 0; i < len; ++i) {\\n        printf(\\"%d \\", arr[i]);\\n    }\\n    return 0;\\n}\\n","py":"def BubbleSort(arr, n):\\n    if n == 1:\\n        return\\n    for i in range(n-1):\\n        if arr[i] > arr[i + 1]:\\n            temp = arr[i]\\n            arr[i] = arr[i + 1]\\n            arr[i + 1] = temp\\n    BubbleSort(arr, n-1)\\narr = [4,5,8,9,10,2]\\nBubbleSort(arr, len(arr))\\nprint(arr)\\n","orden":3,"suborden":0,"fecha_creacion":"2020-12-02 17:30:29","fecha_modificacion":"2020-12-07 02:21:44"},{"ID":11,"supergrupo":"Ordenamientos","tema":"Merge Sort","texto":"<div style=\\"text-align: justify;\\"><span style=\\"font-size: 10pt;\\">Al igual que Quick Sort, Merge Sort es un algoritmo de Dividir y Conquistar.&nbsp;</span></div><div style=\\"text-align: justify;\\">Divide el arreglo de entrada en dos mitades, se llama a s\xed misma para las dos mitades y luego combina las dos mitades clasificadas. La funci\xf3n merge () se usa para fusionar dos mitades.\\r\\n\\r\\nEl merge (arr, l, m, r) es un proceso clave que asume que arr [l...m] y arr [m + 1...r] est\xe1n ordenados y combina los dos subarreglos ordenados en uno solo.&nbsp;\\r\\n</div><div style=\\"text-align: justify;\\"><br></div><div style=\\"text-align: justify;\\">Merge Sort es \xfatil para ordenar listas enlazadas en tiempo O (nLogn). En el caso de listas enlazadas, el caso es diferente principalmente debido a la diferencia en la asignaci\xf3n de memoria de los arrays y las listas enlazadas. A diferencia de los arrays, los nodos de listas enlazadas pueden no estar adyacentes en la memoria. A diferencia del array, en la lista enlazada, podemos insertar elementos en el medio en O (1) espacio adicional y O (1) tiempo.&nbsp;<span style=\\"font-size: 10pt;\\">Por lo tanto, la operaci\xf3n de fusi\xf3n de merge sort se puede implementar sin espacio adicional para las listas vinculadas.\\r\\n\\r\\nEn arrays, podemos hacer acceso aleatorio ya que los elementos son continuos en la memoria.</span></div>","complejidad_tiempo":"Mejor caso :    O(nlog(n))            Peor caso :      O(nlog(n))             Promedio: O(nlog(n))","java":"/*Programa java para Merge Sort*/\\npublic class MergeSort {\\n\\n    /*Une dos subarrays de arr[]\\n    Primer subarray es arr[1...m]\\n    Segundo subarray es arr[m+1..r]*/\\n    static void merge(int arr[], int l, int m, int r) {\\n        //Encuentra tama\xf1os de dos subarrays a ser unidos\\n        int n1 = m - l + 1;\\n        int n2 = r - m;\\n        /* Crear arrays temporales */\\n        int L[] = new int[n1];\\n        int R[] = new int[n2];\\n        /*Copia datos en los arrays temporales*/\\n        for (int i = 0; i < n1; ++i) {\\n            L[i] = arr[l + i];\\n        }\\n        for (int j = 0; j < n2; ++j) {\\n            R[j] = arr[m + 1 + j];\\n        }\\n        /*Une los arreglos temporales*/\\n        // Indices iniciales del los dos subarrays\\n        int i = 0, j = 0;\\n        //indice inicial de array unido\\n        int k = l;\\n        while (i < n1 && j < n2) {\\n            if (L[i] <= R[j]) {\\n                arr[k] = L[i];\\n                i++;\\n            } else {\\n                arr[k] = R[j];\\n                j++;\\n            }\\n            k++;\\n        }\\n        /*Copia los elementos restanes de L[] si hay*/\\n        while (i < n1) {\\n            arr[k] = L[i];\\n            i++;\\n            k++;\\n        }\\n        //Copia los elementos restanes de R[] si hay\\n        while (j < n2) {\\n            arr[k] = R[j];\\n            j++;\\n            k++;\\n        }\\n    }\\n\\n    static void sort(int arr[], int l, int r) {\\n        if (l < r) {\\n            //Encuentra el punto medio\\n            int m = (l + r) / 2;\\n            // Ordena los dos subarrays\\n            sort(arr, l, m);\\n            sort(arr, m + 1, r);\\n            // Une los subarrays\\n            merge(arr, l, m, r);\\n        }\\n    }\\n\\n    //Imprimir array\\n    static void printArray(int arr[]) {\\n        int n = arr.length;\\n        for (int i = 0; i < n; ++i) {\\n            System.out.print(arr[i] + \\" \\");\\n        }\\n        System.out.println();\\n    }\\n\\n    public static void main(String args[]) {\\n        int arr[] = {12, 11, 13, 5, 6, 7};\\n        System.out.println(\\"Array dado\\");\\n        printArray(arr);\\n        sort(arr, 0, arr.length - 1);\\n        System.out.println(\\"\\\\nArray ordenado\\");\\n        printArray(arr);\\n    }\\n}\\n","cpp":"#include <bits/stdc++.h>\\n#include <cstdlib>\\nusing namespace std;\\n\\nvoid merge(int arr[], int l, int m, int r) {\\n    int n1 = m - l + 1;\\n    int n2 = r - m;\\n    int L[n1];\\n    int R[n2];\\n    for (int i = 0; i < n1; ++i) {\\n        L[i] = arr[l + i];\\n        for (int j = 0; j < n2; j++) {\\n            R[j] = arr[m + 1 + j];\\n        }\\n    }\\n    int i = 0, j = 0;\\n    int k = l;\\n    while (i < n1 && j < n2) {\\n        if (L[i] <= R[j]) {\\n            arr[k] = L[i];\\n            i++;\\n        } else {\\n            arr[k] = R[j];\\n            j++;\\n        }\\n        k++;\\n    }\\n    while (i < n1) {\\n        arr[k] = L[i];\\n        i++;\\n        k++;\\n    }\\n    while (j < n2) {\\n        arr[k] = R[j];\\n        j++;\\n        k++;\\n    }\\n}\\n\\nvoid printArray(int arr[], int n) {\\n    for (int i = 0; i < n; i++) {\\n        printf(\\"%d \\", arr[i]);\\n    }\\n    cout << \\"\\\\n\\";\\n}\\n\\nvoid sort(int arr[], int l, int r) {\\n    if (l < r) {\\n        int m = (l + r) / 2;\\n        sort(arr, l, m);\\n        sort(arr, m + 1, r);\\n        merge(arr, l, m, r);\\n    }\\n}\\n\\nint main() {\\n \\n    /*\\n    int arr[]={3,41,1,34,41,2,4,0};\\n    int n=sizeof(arr)/sizeof(arr[0]);\\n    sort(arr,0,n-1);\\n    printArray(arr,n);\\n     */\\n    //Mediante lectura\\n    string str;\\n    getline(cin, str);\\n    string intermediate;\\n    vector<int> vec;\\n    stringstream check1(str);\\n    while (getline(check1, intermediate, \' \')) {\\n        vec.push_back(atoi(intermediate.c_str()));\\n    }\\n    int arr[vec.size()];\\n    for (int i = 0; i < vec.size(); ++i) {\\n        arr[i] = vec[i];\\n    }\\n    sort(arr, 0, vec.size() - 1);\\n    printArray(arr, vec.size());\\n    return 0;\\n}\\n","py":"def merge(arr, left, mid, right):\\n    n1 = mid - left + 1\\n    n2 = right - mid\\n    L, R = [], []\\n    for i in range(n1):\\n        L.append(arr[left + i])\\n    for i in range(n2):\\n        R.append(arr[mid + 1 + i])\\n    i, j = int(0), int(0)\\n    k = left\\n    while i < n1 and j < n2:\\n        if L[i] <= R[j]:\\n            arr[k] = L[i]\\n            i += 1\\n        else:\\n            arr[k] = R[j]\\n            j += 1\\n        k += 1\\n    while i < n1:\\n        arr[k] = L[i]\\n        i += 1\\n        k += 1\\n    while j < n2:\\n        arr[k] = R[j]\\n        j += 1\\n        k += 1\\n        \\ndef mergeSort(arr, left, right):\\n    if left < right:\\n        m = (left + right) // 2\\n        mergeSort(arr, left, m)\\n        mergeSort(arr, m + 1, right)\\n        merge(arr, left, m, right)\\n        \\narr = [int(x) for x in input().split()]\\nmergeSort(arr, 0, len(arr)-1)\\nprint(arr)\\n","orden":3,"suborden":1,"fecha_creacion":"2020-12-02 17:30:29","fecha_modificacion":"2020-12-06 20:05:43"},{"ID":12,"supergrupo":"Ordenamientos","tema":"Binary Insertion Sort","texto":"<div style=\\"text-align: justify;\\"><span style=\\"font-size: 10pt;\\">Podemos usar la b\xfasqueda binaria para reducir el n\xfamero de comparaciones en el ordenamiento de inserci\xf3n normal. El ordenamiento de inserci\xf3n binaria utiliza la b\xfasqueda binaria para encontrar la ubicaci\xf3n adecuada para insertar el elemento seleccionado en cada iteraci\xf3n.&nbsp;</span></div><div style=\\"text-align: justify;\\">En el ordenamiento de inserci\xf3n normal, se necesitan comparaciones O(n) (en la iteraci\xf3n n) en el peor de los casos. Podemos reducirlo a O (log n) mediante la b\xfasqueda binaria.\\r\\nEl algoritmo en su conjunto a\xfan tiene un tiempo de ejecuci\xf3n en el peor de los casos de O (n^2) debido a la serie de intercambios necesarios para cada inserci\xf3n.\\r\\n</div>","complejidad_tiempo":"Mejor caso :    O(n)            Peor caso :      O(n2)             Promedio: O(n2)","java":"// Programa java implementando\\n// Binary Insertion Sort\\n\\nimport java.util.Arrays;\\n\\npublic class BinaryInsertionSort {\\n\\n    public static void main(String[] args) {\\n        int[] arr = {37, 23, 0, 17, 12, 72, 31,\\n            46, 100, 88, 54};\\n        sort(arr);\\n        for (int i = 0; i < arr.length; i++) {\\n            System.out.print(arr[i] + \\" \\");\\n        }\\n    }\\n\\n    static void sort(int array[]) {\\n        for (int i = 1; i < array.length; i++) {\\n            int x = array[i];\\n            // Encontrar ubicaci\xf3n para insertar usando\\n            // Binary Search\\n            int j = Math.abs(Arrays.binarySearch(array, 0, i, x) + 1);\\n            System.arraycopy(array, j, array, j + 1, i - j);\\n            // Colocar elemento en su correcta localizaci\xf3n\\n            array[j] = x;\\n        }\\n    }\\n}\\n","cpp":"#include <iostream>\\n\\nusing namespace std;\\n\\nint binarySearch(int arr[], int i, int low, int high) {\\n    if (high <= low) {\\n        return (i > arr[low]) ? (low + 1) : low;\\n    }\\n    int mid = (low + high) / 2;\\n    if (i == arr[mid]) {\\n        return mid + 1;\\n    }\\n    if (i > arr[mid]) {\\n        return binarySearch(arr, i, mid + 1, high);\\n    }\\n    return binarySearch(arr, i, low, mid - 1);\\n}\\n\\nvoid insertionSort(int arr[], int n) {\\n    int i, loc, j, selected;\\n    for (i = 1; i < n; ++i) {\\n        j = i - 1;\\n        selected = arr[i];\\n        loc = binarySearch(arr, selected, 0, j);\\n        while (j >= loc) {\\n            arr[j + 1] = arr[j];\\n            j--;\\n        }\\n        arr[j + 1] = selected;\\n    }\\n}\\n\\nint main() {\\n    int arr[] = {-63, 8, -7, -15, -19, 17, 19, 110};\\n    int n = sizeof (arr) / sizeof (arr[0]);\\n    insertionSort(arr, n);\\n    cout << \\"Arreglo ordenado:\\" << endl;\\n    for (int i = 0; i < n; i++) {\\n        if (i == n - 1) {\\n            cout << arr[i] << endl;\\n            break;\\n        }\\n        cout << arr[i] << \\" \\";\\n    }\\n    return 0;\\n}\\n","py":"def partition(arr, low, high):\\n    pivot = arr[high]\\n    i = low - 1\\n    for j in range(low, high):\\n        if(arr[j] < pivot):\\n            i = i + 1\\n            temp = arr[i]\\n            arr[i] = arr[j]\\n            arr[j] = temp\\n    temp = arr[i + 1]\\n    arr[i + 1] = arr[high]\\n    arr[high] = temp\\n    return i + 1\\n\\n\\ndef quickSort(arr, low, high):\\n    if(low < high):\\n        pivot = partition(arr, low, high)\\n        quickSort(arr, low, pivot-1)\\n        quickSort(arr, pivot + 1, high)\\n\\n\\nlista = [int(x) for x in input().split()]\\nquickSort(lista, 0, len(lista)-1)\\nprint(*lista)","orden":3,"suborden":2,"fecha_creacion":"2020-12-02 17:30:29","fecha_modificacion":"2020-12-06 20:05:44"},{"ID":13,"supergrupo":"Ordenamientos","tema":"Quick Sort","texto":"Quick Sort es un algoritmo de Dividir y Conquistar. Selecciona un elemento como pivote y divide el array dado alrededor del pivote seleccionado.&nbsp;<div style=\\"font-weight: normal;\\"><br></div><div style=\\"\\"><span style=\\"font-weight: bold;\\">Hay muchas versiones diferentes de quick Sort que seleccionan pivote de diferentes maneras.\\r\\n&nbsp;</span></div><div style=\\"font-weight: normal;\\"><span style=\\"white-space:pre\\">\\t</span>- Elije siempre el primer elemento como pivote.&nbsp;</div><div style=\\"font-weight: normal;\\"><span style=\\"white-space:pre\\">\\t</span>- Siempre elije el \xfaltimo elemento como pivote.&nbsp;</div><div style=\\"font-weight: normal;\\"><span style=\\"white-space:pre\\">\\t</span>- Elige un elemento aleatorio como pivote.&nbsp;</div><div style=\\"font-weight: normal;\\"><span style=\\"white-space:pre\\">\\t</span>- Elije la mediana como pivote.&nbsp;</div><div style=\\"font-weight: normal;\\"><br></div><div style=\\"font-weight: normal;\\">El proceso clave en quick Sort es partition (). El destino de las particiones es, dada un array y un elemento x del array como pivote, coloca x en su posici\xf3n correcta en el array ordenado y coloca todos los elementos m\xe1s peque\xf1os (m\xe1s peque\xf1os que x) antes de x, y coloca todos los elementos mayores (mayores que x) despu\xe9s de X. Todo esto debe hacerse en tiempo lineal.\\r\\n</div>","complejidad_tiempo":"Mejor caso :    O(nlog(n))            Peor caso :      O(n2)             Promedio: O(nlog(n))","java":"// Programa java para la implementaci\xf3n de QuickSort\\n\\npublic class QuickSort {\\n\\n    /* Esta funci\xf3n toma el ultimo elemento como\\n    pivote, coloca el pivote en la posici\xf3n correcta\\n    en el array ordenado, y coloca todos los m\xe1s \\n    peque\xf1ps (M\xe1s peque\xf1os que el pivote) a la izquierda\\n    del pivote, y todos los m\xe1s grandes a la derecha del\\n    pivote*/\\n    static int partition(int arr[], int low, int high) {\\n        int pivot = arr[high];\\n        int i = (low - 1); // Indice del elemento m\xe1s peque\xf1o\\n        for (int j = low; j < high; j++) {\\n            /*Si el actual elemento es m\xe1s peque\xf1o\\n            p igual que el pivote*/\\n            if (arr[j] <= pivot) {\\n                i++;\\n                //intercambia arr[i] y arr[j] \\n                int temp = arr[i];\\n                arr[i] = arr[j];\\n                arr[j] = temp;\\n            }\\n        }\\n        // Intercambia arr[i+1] y arr[high] (o pivote) \\n        int temp = arr[i + 1];\\n        arr[i + 1] = arr[high];\\n        arr[high] = temp;\\n\\n        return i + 1;\\n    }\\n\\n    /*arr[] --\x3e Array que sera ordenado, \\n      low  --\x3e indice inicial, \\n      high  --\x3e indice final */\\n    static void sort(int arr[], int low, int high) {\\n        if (low < high) {\\n            /* pi esta particionando indices, arr[pi] is  \\n              now at right place */\\n            int pi = partition(arr, low, high);\\n            // Recursivamente ordena elementos antes de \\n            // la partici\xf3n y despues de la partici\xf3n\\n            sort(arr, low, pi - 1);\\n            sort(arr, pi + 1, high);\\n        }\\n    }\\n    /* Imprimir array */\\n    static void printArray(int arr[]) {\\n        int n = arr.length;\\n        for (int i = 0; i < n; ++i) {\\n            System.out.print(arr[i] + \\" \\");\\n        }\\n        System.out.println();\\n    }\\n\\n    public static void main(String args[]) {\\n        int arr[] = {10, 7, 8, 9, 1, 5};\\n        int n = arr.length;\\n        sort(arr, 0, n - 1);\\n        System.out.println(\\"Array ordenado\\");\\n        printArray(arr);\\n    }\\n}\\n","cpp":"#include <bits/stdc++.h>\\n#include <cstdlib>\\nusing namespace std;\\n\\nint partition(int arr[], int low, int high) {\\n    int pivot = arr[high];\\n    int i = (low - 1);\\n\\n    for (int j = low; j <= high - 1; j++) {\\n        if (arr[j] <= pivot) {\\n            i++;\\n            int temp = arr[i];\\n            arr[i] = arr[j];\\n            arr[j] = temp;\\n        }\\n    }\\n    int temp = arr[i + 1];\\n    arr[i + 1] = arr[high];\\n    arr[high] = temp;\\n    return (i + 1);\\n}\\n\\nvoid quickSort(int arr[], int low, int high) {\\n    if (low < high) {\\n\\n        int pi = partition(arr, low, high);\\n\\n        quickSort(arr, low, pi - 1);\\n        quickSort(arr, pi + 1, high);\\n    }\\n}\\n\\nvoid print(int arr[], int n) {\\n    for (int i = 0; i < n; ++i) {\\n        printf(\\"%d \\", arr[i]);\\n    }\\n    cout << \\"\\\\n\\";\\n}\\n\\nint main(int argc, char const *argv[]) {\\n    int arr[] = {9, 8, 7, 6, 5, 4, 3, 2, 1, 0};\\n    int n = sizeof (arr) / sizeof (arr[0]);\\n    quickSort(arr, 0, n - 1);\\n    print(arr, n);\\n    return 0;\\n}\\n","py":"def Partition(arr, low, high):\\n    pivot = arr[high]\\n    i = low-1\\n    for j in range(low, high):\\n        if arr[j] <= pivot:\\n            i += 1\\n            temp = arr[i]\\n            arr[i] = arr[j]\\n            arr[j] = temp\\n    temp = arr[i + 1]\\n    arr[i + 1] = arr[high]\\n    arr[high] = temp\\n    return i + 1\\n\\ndef QuickSort(arr, low, high):\\n    if low < high:\\n        pivot = Partition(arr, low, high)\\n        QuickSort(arr, low, pivot-1)\\n        QuickSort(arr, pivot + 1, high)\\narr = [int(x) for x in input().split()]\\nQuickSort(arr, 0, len(arr)-1)\\nprint(arr)\\n","orden":3,"suborden":3,"fecha_creacion":"2020-12-02 17:30:29","fecha_modificacion":"2020-12-07 01:55:14"},{"ID":14,"supergrupo":"Ordenamientos","tema":"Radix Sort","texto":"Radix sort es un algoritmo de ordenamiento que clasifica los n\xfameros seg\xfan las posiciones de sus d\xedgitos.&nbsp;<span style=\\"font-size: 10pt;\\">B\xe1sicamente, utiliza el valor posicional de los d\xedgitos en un n\xfamero.&nbsp;</span><div><span style=\\"font-size: 10pt;\\"><br></span></div><div><span style=\\"font-size: 10pt;\\">A diferencia de la mayor\xeda de los otros algoritmos de ordenamiento, como Merge Sort, Insertion Sort y burbuja, no compara los n\xfameros.\\r\\n\\r\\nRadix sort utiliza un algoritmo de ordenamiento estable como subrutina para ordenar los d\xedgitos. Aqu\xed hemos usado una variaci\xf3n de conteo como una subrutina que usa la ra\xedz para ordenar los d\xedgitos en cada posici\xf3n.&nbsp;</span></div><div><span style=\\"font-size: 10pt;\\"><br></span></div><div><span style=\\"font-size: 10pt;\\">El ordenamiento radix es un algoritmo de ordenamiento estable y funciona bien en la pr\xe1ctica.\\r\\n\\r\\nLa clasificaci\xf3n por radix funciona clasificando los d\xedgitos del d\xedgito menos significativo al d\xedgito m\xe1s significativo. \\r\\n\\r\\nSi tenemos bits log2n para cada d\xedgito, el tiempo de ejecuci\xf3n de Radix parece ser mejor que Quick Sort para una amplia gama de n\xfameros de entrada. Los factores constantes ocultos en la notaci\xf3n asint\xf3tica son mayores para Radix Sort y Quick-Sort usa cach\xe9s de hardware de manera m\xe1s efectiva.</span></div>","complejidad_tiempo":"Mejor caso :    O(d\xedgitos*n)            Peor caso :     O(d\xedgitos*n)             Promedio: O(d\xedgitos*n)","java":"//Implementaci\xf3n java de Radix Sort\\n\\nimport java.util.*;\\n\\npublic class RadixSort {\\n\\n    // Una funci\xf3n de utilidad que obtiene\\n    //El maximo valor en arr[] \\n    static int getMax(int arr[], int n) {\\n        int mx = arr[0];\\n        for (int i = 1; i < n; i++) {\\n            if (arr[i] > mx) {\\n                mx = arr[i];\\n            }\\n        }\\n        return mx;\\n    }\\n\\n    /*Una funci\xf3n que realiza conteo de ordenamiento en \\n    arr[] de acuerdo al digito\\n    representado como exp*/\\n    static void countSort(int arr[], int n, int exp) {\\n        int output[] = new int[n]; // Array de salida\\n        int i;\\n        int count[] = new int[10];\\n        Arrays.fill(count, 0);\\n        // Almacena el conteo de las ocurrencias en count[]\\n        for (i = 0; i < n; i++) {\\n            count[(arr[i] / exp) % 10]++;\\n        }\\n        // cambia count[i] de tal manera que ahora\\n        //contenga la actual posicion de este digito en\\n        //output[]\\n        for (i = 1; i < 10; i++) {\\n            count[i] += count[i - 1];\\n        }\\n        //Contruye el array de salida\\n        for (i = n - 1; i >= 0; i--) {\\n            output[count[(arr[i] / exp) % 10] - 1] = arr[i];\\n            count[(arr[i] / exp) % 10]--;\\n        }\\n        // copia el array de salida a arr[], ahora arr[] \\n        // contiene los n\xfameros ordenados de acuerdo al digito\\n        //actual \\n        for (i = 0; i < n; i++) {\\n            arr[i] = output[i];\\n        }\\n    }\\n\\n    static void radixsort(int arr[], int n) {\\n        // Encuentra el maximo n\xfamero para conocer el n\xfamero \\n        // de digitos\\n        int m = getMax(arr, n);\\n        for (int exp = 1; m / exp > 0; exp *= 10) {\\n            countSort(arr, n, exp);\\n        }\\n    }\\n\\n    //Imprimir el array\\n    static void print(int arr[], int n) {\\n        for (int i = 0; i < n; i++) {\\n            System.out.print(arr[i] + \\" \\");\\n        }\\n    }\\n\\n    public static void main(String[] args) {\\n        int arr[] = {170, 45, 75, 90, 802, 24, 2, 66};\\n        int n = arr.length;\\n        radixsort(arr, n);\\n        print(arr, n);\\n    }\\n}\\n","cpp":"#include <bits/stdc++.h>\\n#include <cstdlib>\\nusing namespace std;\\n\\nint getMax(int arr[], int n) {\\n    int mx = arr[0];\\n    for (int i = 1; i < n; ++i) {\\n        if (arr[i] > mx) {\\n            mx = arr[i];\\n        }\\n    }\\n    return mx;\\n}\\n\\nvoid countSort(int arr[], int n, int exp) {\\n    int output[n];\\n    int count[10];\\n    memset(count, 0, sizeof (count));\\n    for (int i = 0; i < n; ++i) {\\n        count[(arr[i] / exp) % 10]++;\\n    }\\n    for (int i = 0; i < 10; ++i) {\\n        count[i] += count[i - 1];\\n    }\\n    for (int i = n - 1; i >= 0; --i) {\\n        output[count[(arr[i] / exp) % 10] - 1] = arr[i];\\n        count[(arr[i] / exp) % 10]--;\\n    }\\n    for (int i = 0; i < n; ++i) {\\n        arr[i] = output[i];\\n    }\\n}\\n\\nvoid radixSort(int arr[], int n) {\\n    int m = getMax(arr, n);\\n    for (int exp = 1; m / exp > 0; exp *= 10) {\\n        countSort(arr, n, exp);\\n    }\\n}\\n\\nvoid printArray(int arr[], int n) {\\n    for (int i = 0; i < n; ++i) {\\n        printf(\\"%d \\", arr[i]);\\n    }\\n    cout << \\"\\\\n\\";\\n}\\n\\nint main(int argc, char const *argv[]) {\\n    int arr[] = {9, 78, 6, 5, 32, 1, 1, 4, 5, 45};\\n    int n = sizeof (arr) / sizeof (arr[0]);\\n    radixSort(arr, n);\\n    printArray(arr, n);\\n    return 0;\\n}\\n","py":"# Solo con Numeros Positivos\\n\\ndef getMax(arr, n):\\n    maxim = arr[0]\\n    for i in range(1, n):\\n        if(arr[i] > maxim):\\n            maxim = arr[i]\\n    return maxim\\n\\n\\ndef countSort(arr, n, exp):\\n    output = [0 for x in range(n)]\\n    count = [0 for x in range(10)]\\n    i = 0\\n    for i in range(0, n):\\n        count[(arr[i] // exp) % 10] += 1\\n    for i in range(1, 10):\\n        count[i] += count[i-1]\\n    for i in range(n-1, -1, -1):\\n        output[count[(arr[i] // exp) % 10]-1] = arr[i]\\n        count[(arr[i] // exp) % 10] -= 1\\n    for i in range(0, n):\\n        arr[i] = output[i]\\n\\n\\ndef radixSort(arr, n):\\n    m = getMax(arr, n)\\n    exp = 1\\n    while m // exp > 0:\\n        countSort(arr, n, exp)\\n        exp *= 10\\n\\n\\nlista = [int(x) for x in input().split()]\\nradixSort(lista, len(lista))\\nprint(*lista)\\n","orden":3,"suborden":4,"fecha_creacion":"2020-12-02 17:30:29","fecha_modificacion":"2020-12-07 01:56:47"},{"ID":15,"supergrupo":"Ordenamientos","tema":"Shell Sort","texto":"Shell Sort es principalmente una variaci\xf3n de Insertion Sort.&nbsp;<div><br></div><div>En el ordenamiento por inserci\xf3n, movemos los elementos solo una posici\xf3n adelante. Cuando un elemento tiene que moverse mucho m\xe1s adelante, hay muchos movimientos involucrados. La idea de shell Sort es permitir el intercambio de elementos lejanos. En shell Sort, hacemos el array para un gran valor de h. Continuamos reduciendo el valor de h hasta que se convierte en 1. Se dice que un array est\xe1 ordenado por h si todas las sublistas de cada elemento h est\xe1n ordenadas.&nbsp;</div><div><br></div><div>&nbsp;La complejidad de tiempo de la implementaci\xf3n de shell Sort es O (n^2). En la implementaci\xf3n la brecha se reduce a la mitad en cada iteraci\xf3n.\\r\\n</div>","complejidad_tiempo":"Mejor caso :    O(nlog(n))            Peor caso :     O(n2)             Promedio: O(nlog(n))","java":"// Implementaci\xf3n java de ShellSort\\n\\npublic class ShellSort {\\n\\n    /*Imprimir el array */\\n    static void printArray(int arr[]) {\\n        int n = arr.length;\\n        for (int i = 0; i < n; ++i) {\\n            System.out.print(arr[i] + \\" \\");\\n        }\\n        System.out.println();\\n    }\\n    //Funci\xf3n ordenadora Shell Sort\\n    static void sort(int arr[]) {\\n        int n = arr.length;\\n        //Inicia con un gran salto, luego reduce el salto\\n        for (int gap = n / 2; gap > 0; gap /= 2) {   \\n     //Realiza un insertion sort con salto\\n            // Los primeros elementros del sato a[0..gap-1]\\n            // estan ya en un orden de salto que sigue agregando\\n            //un elemento m\xe1s hasta que el array entero este ordenado\\n            for (int i = gap; i < n; i += 1) {\\n                //Agrega a[i] a los elementos que estan en el ordenamiento\\n                // con salto\\n                int temp = arr[i];\\n                int j;\\n                for (j = i; j >= gap && arr[j - gap] > temp; j -= gap) {\\n                    arr[j] = arr[j - gap];\\n                }\\n                arr[j] = temp;\\n            }\\n        }\\n        \\n    }\\n\\n    public static void main(String args[]) {\\n        int arr[] = {12, 34, 54, 2, 3};\\n        System.out.println(\\"Array antes de ordenar\\");\\n        printArray(arr);\\n        sort(arr);\\n        System.out.println(\\"Array despues de ordenar\\");\\n        printArray(arr);\\n    }\\n}\\n","cpp":"#include <bits/stdc++.h>\\n#include <cstdlib>\\ntypedef long long int ll;\\nusing namespace std;\\n\\nvoid printArray(vector <int> myvec, int n) {\\n    for (int i = 0; i < n; ++i) {\\n        printf(\\"%d \\", myvec[i]);\\n    }\\n}\\n\\nint sort(vector <int> myvec, int n) {\\n    for (int gap = n / 2; gap > 0; gap /= 2) {\\n        for (int i = gap; i < n; i += 1) {\\n            int temp = myvec[i];\\n            int j;\\n            for (j = i; j >= gap && myvec[j - gap] > temp; j -= gap) {\\n                myvec[j] = myvec[j - gap];\\n            }\\n            myvec[j] = temp;\\n        }\\n    }\\n    printArray(myvec, n);\\n    return 0;\\n}\\n\\nint main(int argc, char** argv) {\\n    int arr[] = {3, 4, 1, 3, 54, 6, 6, 4, 3, 2, 3, 1, 21};\\n    int n = sizeof (arr) / sizeof (arr[0]);\\n    vector<int> myvec;\\n    myvec.insert(myvec.begin(), arr, arr + n);\\n    sort(myvec, n);\\n    return 0;\\n}\\n","py":"def ShellSort(arr):\\n    n = len(arr)\\n    grap = n // 2\\n    while grap > 0:\\n        i = grap\\n        while i < n:\\n            temp = arr[i]\\n            j = i\\n            while j >= grap and arr[j-grap] > temp:\\n                arr[j] = arr[j-grap]\\n                j -= grap\\n            arr[j] = temp\\n            i += 1\\n        grap //= 2\\n        \\narr = [12, 56, 89, 47, 89, 23]\\nShellSort(arr)\\nprint(*arr)\\n","orden":3,"suborden":5,"fecha_creacion":"2020-12-02 17:30:29","fecha_modificacion":"2020-12-07 01:57:07"},{"ID":16,"supergrupo":"Ordenamientos","tema":"Tim Sort","texto":"<p class=\\"MsoNormalCxSpFirst\\" style=\\"margin:0cm;margin-bottom:.0001pt;mso-add-space:\\r\\nauto\\">TimSort es un algoritmo de ordenamiento basado en Insertion Sort y Merge\\r\\nSort.<o:p></o:p></p>\\r\\n\\r\\n<p class=\\"MsoNormalCxSpLast\\" style=\\"margin:0cm;margin-bottom:.0001pt;mso-add-space:\\r\\nauto\\"><o:p>&nbsp;</o:p></p>\\r\\n\\r\\n<p class=\\"MsoListParagraphCxSpFirst\\" style=\\"margin-top:0cm;margin-right:0cm;\\r\\nmargin-bottom:0cm;margin-left:36.0pt;margin-bottom:.0001pt;mso-add-space:auto;\\r\\ntext-indent:-18.0pt;mso-list:l0 level1 lfo1\\">\x3c!--[if !supportLists]--\x3e<span style=\\"mso-ascii-font-family:Calibri;mso-fareast-font-family:Calibri;\\r\\nmso-hansi-font-family:Calibri;mso-bidi-font-family:Calibri\\"><span style=\\"mso-list:Ignore\\">-<span style=\\"font:7.0pt &quot;Times New Roman&quot;\\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\\r\\n</span></span></span>Es un algoritmo de ordenamiento estable\\r\\nfunciona en tiempo O (n Log n)<o:p></o:p></p>\\r\\n\\r\\n<p class=\\"MsoListParagraphCxSpMiddle\\" style=\\"margin-top:0cm;margin-right:0cm;\\r\\nmargin-bottom:0cm;margin-left:36.0pt;margin-bottom:.0001pt;mso-add-space:auto;\\r\\ntext-indent:-18.0pt;mso-list:l0 level1 lfo1\\">\x3c!--[if !supportLists]--\x3e<span style=\\"mso-ascii-font-family:Calibri;mso-fareast-font-family:Calibri;\\r\\nmso-hansi-font-family:Calibri;mso-bidi-font-family:Calibri\\"><span style=\\"mso-list:Ignore\\">-<span style=\\"font:7.0pt &quot;Times New Roman&quot;\\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\\r\\n</span></span></span>\x3c!--[endif]--\x3eSe utiliza en Arrays.sort () de Java, as\xed como\\r\\nen Python sorted() y C++ sort()<o:p></o:p></p>\\r\\n\\r\\n<p class=\\"MsoListParagraphCxSpLast\\" style=\\"margin-top:0cm;margin-right:0cm;\\r\\nmargin-bottom:0cm;margin-left:36.0pt;margin-bottom:.0001pt;mso-add-space:auto;\\r\\ntext-indent:-18.0pt;mso-list:l0 level1 lfo1\\">\x3c!--[if !supportLists]--\x3e<span style=\\"mso-ascii-font-family:Calibri;mso-fareast-font-family:Calibri;\\r\\nmso-hansi-font-family:Calibri;mso-bidi-font-family:Calibri\\"><span style=\\"mso-list:Ignore\\">-<span style=\\"font:7.0pt &quot;Times New Roman&quot;\\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\\r\\n</span></span></span>\x3c!--[endif]--\x3ePrimero clasifica las piezas peque\xf1as utilizando\\r\\nel ordenamiento de Inserci\xf3n, luego fusiona las piezas utilizando ordenamiento\\r\\npor fusi\xf3n (Merge Sort).<o:p></o:p></p>\\r\\n\\r\\n<p class=\\"MsoNormal\\" style=\\"margin:0cm;margin-bottom:.0001pt\\"><o:p>&nbsp;</o:p></p>\\r\\n\\r\\n<p class=\\"MsoNormalCxSpMiddle\\" style=\\"margin:0cm;margin-bottom:.0001pt;\\r\\nmso-add-space:auto\\">Dividimos el array en bloques conocidos como Run. Ordenamos\\r\\nesas ejecuciones utilizando el ordenamiento por inserci\xf3n una por una y luego\\r\\nlas combinamos utilizando la funci\xf3n de combinaci\xf3n utilizada en Merge Sort. Si\\r\\nel tama\xf1o del array es menor que run, entonces el array se clasifica\\r\\nsimplemente utilizando el ordenamiento de inserci\xf3n.<o:p></o:p></p>\\r\\n\\r\\n<p class=\\"MsoNormalCxSpMiddle\\" style=\\"margin:0cm;margin-bottom:.0001pt;\\r\\nmso-add-space:auto\\"><o:p>&nbsp;</o:p></p>\\r\\n\\r\\n<p class=\\"MsoNormalCxSpMiddle\\" style=\\"margin:0cm;margin-bottom:.0001pt;\\r\\nmso-add-space:auto\\">El tama\xf1o de run puede variar de 32 a 64, dependiendo del\\r\\ntama\xf1o del array. Tenga en cuenta que la funci\xf3n de combinaci\xf3n funciona bien\\r\\ncuando los arreglos secundarios de tama\xf1o son potencias de 2. La idea se basa\\r\\nen el hecho de que el ordenamiento por inserci\xf3n funciona bien para arreglos\\r\\npeque\xf1os.<o:p></o:p></p>","complejidad_tiempo":"Mejor caso :    O(n)            Peor caso :     O(nlog(n))             Promedio: O(nlog(n))","java":"// Programa Java que realiza TimSort\\n\\npublic class TimSort {\\n\\n    static int RUN = 32;\\n    // esta funci\xf3n ordena el arreglo \\n    //desde el \xedndice izquierdo hasta\\n    //a la derecha el \xedndice que es de tama\xf1o m\xe1s alto RUN \\n    public static void insertionSort(int[] arr, int left, int right) {\\n        for (int i = left + 1; i <= right; i++) {\\n            int temp = arr[i];\\n            int j = i - 1;\\n            while (arr[j] > temp && j >= left) {\\n                arr[j + 1] = arr[j];\\n                j--;\\n  if (j < 0) {\\n                    break;\\n                }\\n\\n            }\\n            arr[j + 1] = temp;\\n        }\\n    }\\n\\n    public static void merge(int[] arr, int l, int m, int r) {\\n        //Array original esta separado en dos partes\\n        // array derecho e izquierdo \\n        int len1 = m - l + 1, len2 = r - m;\\n        int[] left = new int[len1];\\n        int[] right = new int[len2];\\n        for (int x = 0; x < len1; x++) {\\n            left[x] = arr[l + x];\\n        }\\n        for (int x = 0; x < len2; x++) {\\n            right[x] = arr[m + 1 + x];\\n        }\\n        int i = 0;\\n        int j = 0;\\n        int k = l;\\n        // despues de comparar, \\n        // after comparing,unimos los dos array  \\n        // en un subarray m\xe1s largo\\n        while (i < len1 && j < len2) {\\n            if (left[i] <= right[j]) {\\n                arr[k] = left[i];\\n                i++;\\n            } else {\\n                arr[k] = right[j];\\n                j++;\\n            }\\n            k++;\\n        }\\n        //Copia los elementos restates de la izquiera, si hay\\n        while (i < len1) {\\n            arr[k] = left[i];\\n            k++;\\n            i++;\\n        }\\n        // Copia los elementos restates de la derecha, si hay\\n        while (j < len2) {\\n            arr[k] = right[j];\\n            k++;\\n            j++;\\n        }\\n    }\\n\\n    public static void timSort(int[] arr, int n) {\\n        //Ordena individualmente los subarrays de \\n        //tama\xf1o RUN\\n        for (int i = 0; i < n; i += RUN) {\\n            insertionSort(arr, i, Math.min((i + 31), (n - 1)));\\n        }\\n        //Comienza a unir de tama\xf1o run, luego\\n        //podra unir de tama\xf1o 64, 128, 256 y asi...\\n        for (int size = RUN; size < n; size = 2 * size) {\\n            // Toma un punto inicial del subarray izquierdo\\n            // nosotros vamos a unir arr[left..left+size-1] y\\n            //arr[left+size, left+2*size-1], luego de cada union\\n            // nosotros incrementamos izquiera en  2*size  \\n            for (int left = 0; left < n; left += 2 * size) {\\n                //Encontramos punto de finalizacion de\\n                // el subarray izquierdo, mid+1\\n                // mid+1 es el punto inicial del \\n                //subarray derecho  \\n                int mid = Math.min((left + size - 1), (n - 1));\\n                int right = Math.min((left + 2 * size - 1), (n - 1));\\n                // une sub array arr[left.....mid] y  \\n                // arr[mid+1....right]  \\n                merge(arr, left, mid, right);\\n            }\\n        }\\n    }\\n\\n    // Imprimir el array\\n    public static void printArray(int[] arr, int n) {\\n        for (int i = 0; i < n; i++) {\\n            System.out.print(arr[i] + \\" \\");\\n        }\\n        System.out.print(\\"\\\\n\\");\\n    }\\n\\n    public static void main(String[] args) {\\n        int[] arr = {5, 21, 7, 23, 19};\\n        int n = arr.length;\\n        System.out.print(\\"El array dado es\\\\n\\");\\n        printArray(arr, n);\\n        timSort(arr, n);\\n        System.out.print(\\"Array ordenado\\\\n\\");\\n        printArray(arr, n);\\n    }\\n}\\n","cpp":"#include <bits/stdc++.h>\\n#include <cstdlib>\\n#define MAX 256\\ntypedef long long int ll;\\nusing namespace std;\\nint RUN = 32;\\n\\nvoid printArray(int arr[], int n) {\\n    for (int i = 0; i < n; i++) {\\n        printf(\\"%d \\", arr[i]);\\n    }\\n}\\n\\nvoid insertionSort(int arr[], int left, int rigth) {\\n    for (int i = left + 1; i <= rigth; ++i) {\\n        int temp = arr[i];\\n        int j = i - 1;\\n        while (arr[j] > temp && j >= left) {\\n            arr[j + 1] = arr[j];\\n            j--;\\n        }\\n        arr[j + 1] = temp;\\n    }\\n}\\n\\nvoid merge(int arr[], int l, int m, int r) {\\n    int len1 = m - l + 1, len2 = r - m;\\n    int left[len1];\\n    int rigth[len2];\\n    for (int x = 0; x < len1; ++x) {\\n        left[x] = arr[l + x];\\n    }\\n    for (int x = 0; x < len2; ++x) {\\n        rigth[x] = arr[m + 1 + x];\\n    }\\n    int i = 0, j = 0, k = l;\\n    while (i < len1 && j < len2) {\\n        if (left[i] <= rigth[j]) {\\n            arr[k] = left[i];\\n            i++;\\n        } else {\\n            arr[k] = rigth[j];\\n            j++;\\n        }\\n        k++;\\n    }\\n    while (i < len1) {\\n        arr[k] = left[i];\\n        k++;\\n        i++;\\n    }\\n    while (j < len2) {\\n        arr[k] = rigth[j];\\n        k++;\\n        j++;\\n    }\\n}\\n\\nvoid timSort(int arr[], int n) {\\n    for (int i = 0; i < n; i += RUN) {\\n        insertionSort(arr, i, std::min((i + 31), (n - 1)));\\n    }\\n    for (int size = RUN; size < n; size = 2 * size) {\\n        for (int left = 0; left < n; left += 2 * size) {\\n            int mid = std::min((left + size - 1), (n - 1));\\n            int rigth = std::min((left + 2 * size - 1), (n - 1));\\n            merge(arr, left, mid, rigth);\\n        }\\n    }\\n    printArray(arr, n);\\n}\\n\\nint main(int argc, char** argv) {\\n    int arr[] = {3, 4, 5, 6, 3, 1, 1, 23, 5, 546, 34, 3, 2, 2};\\n    int len = sizeof (arr) / sizeof (arr[0]);\\n    timSort(arr, len);\\n    return 0;\\n}\\n","py":"from sys import stdout\\nwr = stdout.write\\n\\nRUN = 32\\ndef insertionSort(arr, left, right):\\n    for i in range(left + 1, right + 1):\\n        temp = arr[i]\\n        j = i - 1\\n        while j >= left and arr[j] > temp:\\n            arr[j + 1] = arr[j]\\n            j -= 1\\n        arr[j + 1] = temp\\n\\n\\ndef merge(arr, l, m, r):\\n    len1 = m - l + 1\\n    len2 = r - m\\n    left = [0 for x in range(len1)]\\n    right = [0 for x in range(len2)]\\n    for i in range(len1):\\n        left[x] = arr[l + x]\\n    for i in range(len2):\\n        right[x] = arr[m + 1 + x]\\n    i = 0\\n    j = 0\\n    k = l\\n    while i < len1 and j < len2:\\n        if left[i] <= right[i]:\\n            arr[k] = left[i]\\n            i += 1\\n        else:\\n            arr[k] = right[j]\\n            j += 1\\n        k += 1\\n    while i < len1:\\n        arr[k] = left[i]\\n        k += 1\\n        i += 1\\n    while j < len2:\\n        arr[k] = right[j]\\n        k += 1\\n        j += 1\\n\\n\\ndef timSort(arr, n):\\n    i = 0\\n    while i < n:\\n        insertionSort(arr, i, min((i + 31), (n - 1)))\\n        i += RUN\\n    size = RUN\\n    while size < n:\\n        left = 0\\n        while left < 2:\\n                        mid = min ((left + size - 1), (n - 1))\\n            right = min((left + 2 * size - 1), (n - 1))\\n            merge(arr, left, mid, right)\\n            left += 2 * size\\n        size = 2 * size\\n\\n\\ndef printArray(arr, n):\\n    for i in range(n):\\n        wr(f\'{arr[i]} \')\\n    wr(\'\\\\n\')\\n\\narr = [int(x) for x in input().split()]\\nn = len(arr)\\ntimSort(arr, n)\\nprintArray(arr, n)\\n","orden":3,"suborden":6,"fecha_creacion":"2020-12-04 20:09:36","fecha_modificacion":"2020-12-07 01:58:30"},{"ID":17,"supergrupo":"Ordenamientos","tema":"Tree Sort","texto":"<div style=\\"text-align: justify;\\"><span style=\\"font-size: 10pt;\\">Ordenamiento \xe1rbol es un algoritmo de clasificaci\xf3n que se basa en la estructura de datos del Binary Search Tree (\xc1rbol de b\xfasqueda binaria).&nbsp;</span></div><div style=\\"text-align: justify;\\"><span style=\\"font-size: 10pt;\\"><br></span></div><div style=\\"text-align: justify; font-weight: normal;\\">Primero crea un \xe1rbol de b\xfasqueda binario a partir de los elementos de la lista de entrada o un array luego realiza un recorrido inorden en el \xe1rbol de b\xfasqueda binario creado para obtener los elementos ordenados.&nbsp;</div><div style=\\"text-align: justify; font-weight: normal;\\"><br></div><div style=\\"text-align: justify; \\"><span style=\\"font-weight: bold;\\">Para recorrer un \xe1rbol binario no vac\xedo en inorden, hay que realizar las siguientes operaciones recursivamente en cada nodo:&nbsp;</span></div><div style=\\"text-align: justify; font-weight: normal;\\"><span style=\\"white-space:pre\\">\\t</span>1. Atraviese el sub-\xe1rbol o nodo izquierdo&nbsp;</div><div style=\\"text-align: justify; font-weight: normal;\\"><span style=\\"white-space:pre\\">\\t</span>2. Visite la raiz&nbsp;</div><div style=\\"text-align: justify; font-weight: normal;\\"><span style=\\"white-space:pre\\">\\t</span>3. Atraviese el sub-\xe1rbol o nodo derecho\\r\\n</div>","complejidad_tiempo":"Mejor caso :    O(nlog(n))            Peor caso :     O(n2)             Promedio: O(nlog(n))","java":"//C\xf3digo java que implementa Tree Sort \\n\\npublic class TreeSort {\\n    \\n    //Clase conteniendo hijo izquierdo\\n    //y derecho del nodo actual, y \\n    // el valor del nodo (Key)\\n    static class Node {\\n        int key;\\n        Node left, right;\\n        public Node(int item) {\\n            key = item;\\n            left = right = null;\\n        }\\n    }\\n    // Raiz del arbol de busqueda\\n    //binaria\\n    static Node root;\\n    static void init() {\\n        root = null;\\n    }\\n    static void insert(int key) {\\n        root = insertRec(root, key);\\n    }\\n\\n    /*Una funci\xf3n recursiva que inserta \\n    nuevos valores al arbol de busqueda binaria*/\\n    static Node insertRec(Node root, int key) {\\n        /*Si el arbol esta vacio\\n        Retorne un nuevo nodo*/\\n        if (root == null) {\\n            root = new Node(key);\\n            return root;\\n        }\\n        /*De otra forma, baja por el arbol*/\\n        if (key < root.key) {\\n            root.left = insertRec(root.left, key);\\n        } else if (key > root.key) {\\n            root.right = insertRec(root.right, key);\\n        }\\n        /*Retorna la raiz*/\\n        return root;\\n    }\\n\\n    /*Una funci\xf3n que realiza recorrido\\n    inorden atraves del arbol*/\\n    static void inorderRec(Node root) {\\n        if (root != null) {\\n            inorderRec(root.left);\\n            System.out.print(root.key + \\" \\");\\n            inorderRec(root.right);\\n        }\\n    }\\n\\n    static void treeins(int arr[]) {\\n        for (int i = 0; i < arr.length; i++) {\\n            insert(arr[i]);\\n        }\\n    }\\n\\n    public static void main(String[] args) {\\n        int arr[] = {5, 4, 7, 2, 11};\\n        treeins(arr);\\n        inorderRec(root);\\n    }\\n}\\n","cpp":"#include <bits/stdc++.h>\\n#include <cstdlib>\\nusing namespace std;\\n\\nstruct Node {\\n    int key;\\n    struct Node *left, *right;\\n};\\n\\nstruct Node *newNode(int item) {\\n    struct Node *temp = new Node;\\n    temp->key = item;\\n    temp->left = temp->right = NULL;\\n    return temp;\\n}\\n\\nvoid storeSorted(Node *root, int arr[], int &i) {\\n    if (root != NULL) {\\n        storeSorted(root->left, arr, i);\\n        arr[i++] = root->key;\\n        storeSorted(root->right, arr, i);\\n    }\\n}\\n\\nNode* insert(Node* node, int key) {\\n    if (node == NULL) {\\n        return newNode(key);\\n    }\\n    if (key < node->key) {\\n        node->left = insert(node->left, key);\\n    } else if (key > node->key) {\\n        node->right = insert(node->right, key);\\n    }\\n    return node;\\n}\\n\\nvoid printArray(int arr[], int n) {\\n    for (int i = 0; i < n; ++i) {\\n        printf(\\"%d \\", arr[i]);\\n    }\\n}\\n\\nvoid treeSort(int arr[], int n) {\\n    struct Node *root = NULL;\\n\\n    root = insert(root, arr[0]);\\n    for (int i = 1; i < n; i++)\\n        root = insert(root, arr[i]);\\n\\n    int i = 0;\\n    storeSorted(root, arr, i);\\n    printArray(arr, n);\\n}\\n \\nint main() {\\n    /*\\n    int arr[]={2,3,5,1,32,4,50};\\n    int n = sizeof(arr)/sizeof(arr[0]);\\n    treeSort(arr,n);\\n     */\\n    string str;\\n    getline(cin, str);\\n    string intermediate;\\n    vector<int> vec;\\n    stringstream check1(str);\\n    while (getline(check1, intermediate, \' \')) {\\n        vec.push_back(atoi(intermediate.c_str()));\\n    }\\n    int arr[vec.size()];\\n    for (int i = 0; i < vec.size(); ++i) {\\n        arr[i] = vec[i];\\n    }\\n    treeSort(arr, vec.size());\\n    return 0;\\n}\\n","py":"from sys import stdin\\nfrom sys import stdout\\nrl = stdin.readline\\nwr = stdout.write\\n\\n\\nclass Hoja:\\n\\n    def __init__(self, item=None):\\n        self.key = item\\n        self.right = None\\n        self.left = None\\n        \\nroot = Hoja()\\n\\ndef init():\\n    global root\\n    root = None\\n\\ndef insert(key):\\n    global root\\n    root = insertRec(root, key)\\n\\ndef insertRec(raiz, key):\\n   \\n    if raiz == None:\\n        raiz = Hoja(key)\\n        return raiz\\n\\n    if key < raiz.key:\\n        raiz.left = insertRec(raiz.left, key)\\n    elif key >= raiz.key:\\n        raiz.right = insertRec(raiz.right, key)\\n\\n    return raiz\\n\\ndef inOrder(actual):\\n    if actual != None:\\n        inOrder(actual.left)\\n        wr(f\'{actual.key} \')\\n        inOrder(actual.right)\\n\\n       \\ndef insertInTree(arr):\\n    for i in range(len(arr)):\\n        insert(arr[i])\\n\\narr = list(map(int, rl().split()))\\ninit()\\ninsertInTree(arr)\\ninOrder(root)\\nwr(\'\\\\n\')\\n","orden":3,"suborden":7,"fecha_creacion":"2020-12-04 20:09:36","fecha_modificacion":"2020-12-06 20:05:47"},{"ID":18,"supergrupo":"Ordenamientos","tema":"Bitonic Sort","texto":"Bitonic Sort es un algoritmo cl\xe1sico para ordenamiento.\\r\\nEl ordenamiento bit\xf3nico hace comparaciones O (n Log 2n).\\r\\nEl n\xfamero de comparaciones realizadas por Bitonic Sort son m\xe1s que los algoritmos de clasificaci\xf3n populares como Merge Sort [hace O (nLogn) comparaciones], pero Bitonic es mejor para la implementaci\xf3n en paralelo porque siempre comparamos elementos en una secuencia predefinida y la secuencia de comparaci\xf3n no. Depende de los datos. Por lo tanto, es adecuado para la implementaci\xf3n en hardware y array de procesado paralelo&nbsp;<div><br></div><div>Para entender el ordenamiento bit\xf3nico, primero debemos entender qu\xe9 es la secuencia bit\xf3nica y c\xf3mo hacer una secuencia dada bit\xf3nica.\\r\\nUna secuencia es bit\xf3nica si primero aumenta, luego disminuye. En otras palabras, una matriz arr [0...n-i] es bitonica si existe un \xedndice i donde&nbsp;</div><div><br></div><div style=\\"text-align: center;\\">0 &lt;= i &lt;= n-1 tal que\\r\\nx0 &lt;= x1 ... .. &lt;= xi y xi&gt; = xi + 1 ... ..&gt; = xn-1&nbsp;</div><div><br></div><div>Para formar una secuencia ordenada de longitud n a partir de dos secuencias ordenadas de longitud n / 2, se requieren comparaciones de log (n) (por ejemplo: log (8) = 3 cuando el tama\xf1o de la secuencia. Por lo tanto, el n\xfamero de comparaciones T (n) de la clasificaci\xf3n completa est\xe1 dada por:\\r\\nT (n) = log (n) + T (n / 2) la soluci\xf3n de esta ecuaci\xf3n de recurrencia es&nbsp;</div><div><br></div><div style=\\"text-align: center;\\">T (n) = log (n) + log (n) -1 + log (n) -2 +\u2026 + 1 = log (n) \xb7 (log (n) +1) / 2&nbsp;</div><div>&nbsp;</div><div>Cada etapa de la red de ordenamiento consiste en n / 2 comparaciones. Por lo tanto un total de O (n log2n) comparaciones.\\r\\n</div>","complejidad_tiempo":"Mejor caso :    O(log2(n))            Peor caso :     O(log2(n))             Promedio: O(log2(n))","java":"/* Programa java para Bitonic Sort*/\\n/* Nota: Este programa solo funciona si el tama\xf1o\\nde la entrada es una potencia de 2*/\\npublic class BitonicSort {\\n\\n    /* El par\xe1metro dir indica la direcci\xf3n de ordenamiento,\\n       ASCENDIENDO o DESCENDIENDO; si (a [i]> a [j]) est\xe1 de acuerdo\\n       con la direcci\xf3n, entonces a[i] y a[j] son\\n        intercambiados*/\\n    static void compAndSwap(int a[], int i, int j, int dir) {\\n        if ((a[i] > a[j] && dir == 1)\\n                || (a[i] < a[j] && dir == 0)) {\\n            // intercambiando elementos\\n            int temp = a[i];\\n            a[i] = a[j];\\n            a[j] = temp;\\n        }\\n    }\\n\\n    static void bitonicMerge(int a[], int low, int cnt, int dir) {\\n        if (cnt > 1) {\\n            int k = cnt / 2;\\n            for (int i = low; i < low + k; i++) {\\n                compAndSwap(a, i, i + k, dir);\\n            }\\n            bitonicMerge(a, low, k, dir);\\n            bitonicMerge(a, low + k, k, dir);\\n        }\\n    }\\n\\n    static void bitonicSort(int a[], int low, int cnt, int dir) {\\n        if (cnt > 1) {\\n            int k = cnt / 2;\\n            // Ordena en orden ascendente, dir es 1 \\n            bitonicSort(a, low, k, 1);\\n            // ordena en orden descendente, dir es 0\\n            bitonicSort(a, low + k, k, 0);\\n            // une toda la secuencia en orden ascendente\\n            bitonicMerge(a, low, cnt, dir);\\n        }\\n    }\\n\\n    static void sort(int a[], int N, int up) {\\n        bitonicSort(a, 0, N, up);\\n    }\\n\\n    /*Imprimir array */\\n    static void printArray(int arr[]) {\\n        int n = arr.length;\\n        for (int i = 0; i < n; ++i) {\\n            System.out.print(arr[i] + \\" \\");\\n        }\\n        System.out.println();\\n    }\\n\\n    public static void main(String args[]) {\\n        int a[] = {3, 7, 4, 8, 6, 2, 1, 5};\\n        int up = 1;\\n        sort(a, a.length, up);\\n        System.out.println(\\"\\\\nArray ordenado\\");\\n        printArray(a);\\n    }\\n} \\n","cpp":"#include <iostream>\\n\\nusing namespace std;\\n\\nvoid compAndSwap(int arr[], int i, int j, int dir) {\\n    if ((arr[i] > arr[j] && dir == 1) || (arr[i] < arr[j] && dir == 0)) {\\n        swap(arr[i], arr[j]);\\n    }\\n}\\n\\nvoid bitonicMerge(int arr[], int low, int cnt, int dir) {\\n    if (cnt > 1) {\\n        int k = cnt / 2;\\n        for (int i = low; i < low + k; i++) {\\n            compAndSwap(arr, i, i + k, dir);\\n        }\\n        bitonicMerge(arr, low, k, dir);\\n        bitonicMerge(arr, low + k, k, dir);\\n    }\\n}\\n\\nvoid bitonicSort(int arr[], int low, int cnt, int dir) {\\n    if (cnt > 1) {\\n        int k = cnt / 2;\\n        bitonicSort(arr, low, k, 1);\\n        bitonicSort(arr, low + k, k, 0);\\n        bitonicMerge(arr, low, cnt, dir);\\n    }\\n}\\n\\nvoid sorted(int arr[], int N, int up) {\\n    bitonicSort(arr, 0, N, up);\\n}\\n\\nvoid printArray(int arr[], int n) {\\n    for (int i = 0; i < n; ++i) {\\n        if (i == n - 1) {\\n            cout << arr[i] << endl;\\n            break;\\n        }\\n        cout << arr[i] << \\" \\";\\n    }\\n}\\n\\nint main() {\\n    int arr[] = {-5, -6, -1, -4, 8, 100, -90, -15, 35};\\n    int up = 1;\\n    int tam = sizeof (arr) / sizeof (arr[0]);\\n    sorted(arr, tam, up);\\n    cout << \\"Array ordenado\\" << endl;\\n    printArray(arr, tam);\\n    return 0;\\n}\\n","py":"from sys import stdin, stdout\\nrl = stdin.readline\\nwr = stdout.write\\n\\ndef compAndSwap(arr, i, j, direc):\\n    if (arr[i] > arr[j] and direc == 1) or (arr[i] < arr[j] and direc == 0):\\n        arr[i], arr[j] = arr[j], arr[i]\\n\\ndef bitonicMerge(arr, low, cnt, direc):\\n    if cnt > 1:\\n        k = cnt // 2\\n        for i in range(low, low+k):\\n            compAndSwap(arr, i, i+k, direc)\\n\\n        bitonicMerge(arr, low, k, direc)\\n        bitonicMerge(arr, low+k, k, direc)\\n\\n\\ndef bitonicSort(arr, low, cnt, direc):\\n\\n    if cnt > 1:\\n        k = cnt // 2\\n        bitonicSort(arr, low, k, 1)\\n        bitonicSort(arr, low+k, k, 0)\\n        bitonicMerge(arr, low, cnt, direc)\\n\\n\\ndef sortB(arr, n, up):\\n    bitonicSort(arr, 0, n, up)\\n\\n\\ndef printArray(arr):\\n    for i in arr:\\n        wr(f\'{i} \')\\n    wr(\'\\\\n\')\\n\\n\\narr = list(map(int, rl().split()))\\nup = 1  # 0 = Mayor a Menor\\nprintArray(arr)\\nsortB(arr, len(arr), up)\\nprintArray(arr)\\n","orden":3,"suborden":8,"fecha_creacion":"2020-12-04 20:09:36","fecha_modificacion":"2020-12-07 02:01:08"},{"ID":19,"supergrupo":"Ordenamientos","tema":"Cocktail Sort","texto":"Cocktail Sort es una variaci\xf3n de Bubble Sort.&nbsp;<div><br></div><div>El algoritmo de ordenamiento de burbuja siempre atraviesa elementos de la izquierda y mueve el elemento m\xe1s grande a su posici\xf3n correcta en la primera iteraci\xf3n y el segundo m\xe1s grande en la segunda iteraci\xf3n, y as\xed sucesivamente. El ordenamiento de c\xf3ctel atraviesa un vector dado en ambas direcciones alternativamente.&nbsp;</div><div><br></div><div>Las complejidades de tiempo son iguales, pero Cocktail se desempe\xf1a mejor que Bubble Sort. Por lo general, el c\xf3ctel es menos de dos veces m\xe1s r\xe1pido que el tipo burbuja. Considere el ejemplo (2, 3, 4, 5, 1). La clasificaci\xf3n de burbuja requiere cuatro recorridos de matriz para este ejemplo, mientras que la clasificaci\xf3n de c\xf3ctel requiere solo dos recorridos.\\r\\n</div>","complejidad_tiempo":"Mejor caso :    O(n)            Peor caso :     O(n2)             Promedio: O(n2)","java":"// Programa java implementando Cocktail sort\\n\\npublic class CocktailSort {\\n\\n    static void cocktailSort(int a[]) {\\n        boolean swapped = true;\\n        int start = 0;\\n        int end = a.length;\\n        while (swapped == true) {\\n            // Resetea la bandera intercambiada al entrar\\n            // en el ciclo, porque puede ser true de la\\n            // anterior iteraci\xf3n\\n            swapped = false;\\n            // Ciclo del fondo a encima igual\\n            // que bubble sort\\n            for (int i = start; i < end - 1; ++i) {\\n                if (a[i] > a[i + 1]) {\\n                    int temp = a[i];\\n                    a[i] = a[i + 1];\\n                    a[i + 1] = temp;\\n                    swapped = true;\\n                }\\n            }\\n            // Si nada fue movido, array esta ordenado\\n            if (swapped == false) {\\n                break;\\n            }\\n            // de otra forma, resetea la bandera intercambiada\\n            // de tal forma que pueda ser usada en el \\n            //siguiente proceso\\n            swapped = false;\\n            // Mueve el punto final atras en uno, porque\\n            // el item al final esta en la derecha completa\\n            end = end - 1;\\n            // from top to bottom, doing the \\n            // same comparison as in the previous stage \\n            for (int i = end - 1; i >= start; i--) {\\n                if (a[i] > a[i + 1]) {\\n                    int temp = a[i];\\n                    a[i] = a[i + 1];\\n                    a[i + 1] = temp;\\n                    swapped = true;\\n                }\\n            }\\n            // Incrementa el punto inicial, por que\\n            // la ultima fase pudo haber movido el siguiente\\n            // m\xe1s peque\xf1o n\xfamero en la derecha completa\\n            start = start + 1;\\n        }\\n    }\\n    /* Imprime el array*/\\n    static void printArray(int a[]) {\\n        int n = a.length;\\n        for (int i = 0; i < n; i++) {\\n            System.out.print(a[i] + \\" \\");\\n        }\\n        System.out.println();\\n    }\\n    public static void main(String[] args) {\\n        int a[] = {5, 1, 4, 2, 8, 0, 2};\\n        cocktailSort(a);\\n        System.out.println(\\"Arreglo ordenado\\");\\n        printArray(a);\\n    }\\n}\\n","cpp":"#include <iostream>\\n\\nusing namespace std;\\n\\nvoid cocktailSort(int arr[], int n) {\\n    bool swapped = true;\\n    int start = 0;\\n    int ended = n;\\n    while (swapped == true) {\\n        swapped = false;\\n        for (int i = start; i < ended - 1; ++i) {\\n            if (arr[i] > arr[i + 1]) {\\n                int temp = arr[i];\\n                arr[i] = arr[i + 1];\\n                arr[i + 1] = temp;\\n                swapped = true;\\n            }\\n        }\\n        if (swapped == false) {\\n            break;\\n        }\\n        swapped = false;\\n        ended = ended - 1;\\n        for (int i = ended - 1; i >= start; i--) {\\n            if (arr[i] > arr[i + 1]) {\\n                int temp = arr[i];\\n                arr[i] = arr[i + 1];\\n                arr[i + 1] = temp;\\n                swapped = true;\\n            }\\n        }\\n        start += 1;\\n    }\\n}\\n\\nvoid printArray(int arr[], int n) {\\n    for (int i = 0; i < n; i++) {\\n        if (i == n - 1) {\\n            cout << arr[i] << endl;\\n            break;\\n        }\\n        cout << arr[i] << \\" \\";\\n    }\\n}\\n\\nint main() {\\n    int arr[] = {-5, -90, 5, 9, 7, -15, 8, 2, -8, 0, 1, 32, -35};\\n    int tam = sizeof (arr) / sizeof (arr[0]);\\n    cocktailSort(arr, tam);\\n    cout << \\"Arreglo ordenado\\" << endl;\\n    printArray(arr, tam);\\n    return 0;\\n}\\n","py":"from sys import stdin, stdout\\nrl = stdin.readline\\nwr = stdout.write\\n\\ndef cocktailSort(arr):\\n    swapped = True\\n    start = 0\\n    end = len(arr)\\n    while swapped:  # Sort Izq a Der\\n        swapped = False\\n        for i in range(start, end-1):\\n            if arr[i] > arr[i+1]:  # Cambiar < o >\\n                arr[i], arr[i+1] = arr[i+1], arr[i]\\n                swapped = True\\n        if not swapped:\\n            break\\n\\n    swapped = False\\n    end -= 1\\n    for i in range(end-1, start-1, -1):  # Sort Der a Izq\\n        if arr[i] > arr[i+1]:  # Cambiar < o >\\n            arr[i], arr[i+1] = arr[i+1], arr[i]\\n            swapped = True\\n\\n    start += 1\\n\\n\\ndef printArray(arr):\\n    for i in arr:\\n        wr(f\'{i} \')\\n    wr(\'\\\\n\')\\n\\n\\narr = list(map(int, rl().split()))\\nprintArray(arr)\\ncocktailSort(arr)\\nprintArray(arr)\\n","orden":3,"suborden":9,"fecha_creacion":"2020-12-04 20:09:36","fecha_modificacion":"2020-12-07 02:04:41"},{"ID":20,"supergrupo":"Ordenamientos","tema":"Comb Sort","texto":"Comb Sort es principalmente una mejora sobre Bubble Sort. El ordenamiento de burbuja siempre compara valores adyacentes. As\xed que todas las inversiones se eliminan una por una. Comb Sort mejora en Bubble Sort usando un espacio de tama\xf1o mayor que 1. El espacio comienza con un gran valor y se reduce en un factor de 1.3 en cada iteraci\xf3n hasta que alcanza el valor 1.&nbsp;<div><br></div><div>Por lo tanto, Comb Sort funciona mejor que Bubble Sort.\\r\\nAunque funciona mejor que Bubble Sort en promedio, el peor de los casos sigue siendo O (n^2).\\r\\n</div>","complejidad_tiempo":"Mejor caso :    O(nlog(n))            Peor caso :     O(n2)             Promedio: O(n2/2incrementos)","java":"// Programa java implementando Comb Sort\\n\\npublic class CombSort {\\n\\n    // Para buscar espacio entre elementos\\n    static int getNextGap(int gap) {\\n        gap = (gap * 10) / 13;\\n        if (gap < 1) {\\n            return 1;\\n        }\\n        return gap;\\n    }\\n\\n    static void sort(int arr[]) {\\n        int n = arr.length;\\n        // Inicializa espacio\\n        int gap = n;\\n        boolean swapped = true;\\n        /*Mantiene ejecutando mientras gap es m\xe1s que 1 y la \\n        ultima iteraci\xf3n causa un intercambio*/\\n        while (gap != 1 || swapped == true) {\\n            gap = getNextGap(gap);\\n            /*Inicializa swapped como falso, aso \\n            podemos verificar si el intercambio paso\\n            o no*/\\n            swapped = false;\\n            //Compara todos los elementos con el espacio actual \\n            for (int i = 0; i < n - gap; i++) {\\n                if (arr[i] > arr[i + gap]) {\\n                    //Intercambia arr[i] y arr[i+gap]\\n                    int temp = arr[i];\\n                    arr[i] = arr[i + gap];\\n                    arr[i + gap] = temp;\\n                    // Se intercambi\xf3\\n                    swapped = true;\\n                }\\n            }\\n        }\\n    }\\n\\n    public static void main(String args[]) {\\n        int arr[] = {8, 4, 1, 56, 3, -44, 23, -6, 28, 0};\\n        sort(arr);\\n        System.out.println(\\"Array ordenado\\");\\n        for (int i = 0; i < arr.length; ++i) {\\n            System.out.print(arr[i] + \\" \\");\\n        }\\n    }\\n}\\n","cpp":"#include <iostream>\\n\\nusing namespace std;\\n\\nint getNextGap(int gap) {\\n    gap = (gap * 10) / 13;\\n    if (gap < 1) {\\n        return 1;\\n    }\\n    return gap;\\n}\\n\\nvoid sorted(int arr[], int n) {\\n    int gap = n;\\n    bool swapped = true;\\n    while (gap != 1 || swapped == true) {\\n        gap = getNextGap(gap);\\n        swapped = false;\\n        for (int i = 0; i < n - gap; i++) {\\n            if (arr[i] > arr[i + gap]) {\\n                int temp = arr[i];\\n                arr[i] = arr[i + gap];\\n                arr[i + gap] = temp;\\n                swapped = true;\\n            }\\n        }\\n    }\\n}\\n\\nint main() {\\n    int arr[] = {8, 4, 1, 56, 3, -44, 23, -6, 28, 0, -10};\\n    int tam = sizeof (arr) / sizeof (arr[0]);\\n    sorted(arr, tam);\\n    cout << \\"Array ordenado\\" << endl;\\n    for (int i = 0; i < tam; i++) {\\n        if (i == tam - 1) {\\n            cout << arr[i] << endl;\\n            break;\\n        }\\n        cout << arr[i] << \\" \\";\\n    }\\n    return 0;\\n}\\n\\n","py":"from sys import stdin,stdout\\nrl = stdin.readline\\nwr = stdout.write\\n\\ndef getNextGap(gap):\\n    gap = (gap * 10) // 13\\n    if gap < 1:\\n        return 1\\n    return gap\\n\\ndef combSort(arr, n):\\n\\n    gap = n\\n    swapped = True\\n    \\n    while gap != 1 or swapped:\\n        gap = getNextGap(gap)\\n        swapped = False\\n        for i in range(n-gap):\\n            if arr[i] > arr[i+gap]:\\n                arr[i], arr[i+gap] = arr[i+gap], arr[i]\\n                swapped = True\\n\\narr = list(map(int, rl().split()))\\ncombSort(arr, len(arr))\\nprint(*arr)\\n","orden":3,"suborden":10,"fecha_creacion":"2020-12-04 20:09:36","fecha_modificacion":"2020-12-07 02:07:11"},{"ID":21,"supergrupo":"Ordenamientos","tema":"Counting Sort","texto":"El ordenamiento por conteo es una t\xe9cnica de ordenamiento basada en claves entre un rango espec\xedfico. Funciona contando el n\xfamero de objetos que tienen valores clave distintos (un tipo de hashing). Luego, hacer algo de aritm\xe9tica para calcular la posici\xf3n de cada objeto en la secuencia de salida.\\r\\n&nbsp;<div><br></div><div>1. El ordenamiento de conteo es eficiente si el rango de datos de entrada no es significativamente mayor que el n\xfamero de objetos a clasificar. &nbsp;</div><div>2. No es una comparaci\xf3n basada en la clasificaci\xf3n. La complejidad del tiempo de ejecuci\xf3n es O (n) con espacio proporcional al rango de datos.&nbsp;</div><div>3. A menudo se usa como una sub-rutina para otro algoritmo de clasificaci\xf3n como la clasificaci\xf3n por radix.&nbsp;</div><div>4. EL ordenamiento de conteo usa un hashing parcial para contar la ocurrencia del objeto de datos en O (1).&nbsp;</div><div style=\\"text-align: justify;\\">5. El ordenamiento de conteo tambi\xe9n se puede extender para que funcione con entradas negativas.\\r\\n</div>","complejidad_tiempo":"Mejor caso :    O(n+k)            Peor caso :     O(n+k)             Promedio: O(n+k)","java":"// Implementaci\xf3n java de Counting Sort\\n\\npublic class CountingSort {\\n\\n    static void sort(char arr[]) {\\n        int n = arr.length;\\n        // El array de caracteres que sera el array \\n        // ordenado de salida\\n        char output[] = new char[n];\\n        // Crea un array de conteo para almacenar \\n        // conteo individual de caracteres e inicializar\\n        // array de conteo en 0\\n        int count[] = new int[256];\\n        for (int i = 0; i < 256; ++i) {\\n            count[i] = 0;\\n        }\\n        // Almacena el conteo de cada caracter\\n        for (int i = 0; i < n; ++i) {\\n            ++count[arr[i]];\\n        }\\n        // Cambian count[i] de forma que ahora contenga la \\n        //posici\xf3n actual de este caracter en el array de saliday \\n        for (int i = 1; i <= 255; ++i) {\\n            count[i] += count[i - 1];\\n        }\\n        // Construye el array de caracteres de salida\\n        // Para hacerlo estable lo hacemos en orden inverso\\n        for (int i = n - 1; i >= 0; i--) {\\n            output[count[arr[i]] - 1] = arr[i];\\n            --count[arr[i]];\\n        }\\n        //Copia el array de salida a arr, asi arr ahora\\n        // contiene los caracteres ordenados \\n        for (int i = 0; i < n; ++i) {\\n            arr[i] = output[i];\\n        }\\n    }\\n\\n    public static void main(String args[]) {\\n        char arr[] = {\'g\', \'e\', \'e\', \'k\', \'s\', \'f\', \'o\',\\n            \'r\', \'g\', \'e\', \'e\', \'k\', \'s\'};\\n        sort(arr);\\n        System.out.print(\\"array de caracteres ordenado: \\");\\n        for (int i = 0; i < arr.length; ++i) {\\n            System.out.print(arr[i]);\\n        }\\n    }\\n}\\n","cpp":"#include <iostream>\\n#include <string.h>\\n\\nusing namespace std;\\n\\nvoid sorted(char arr[], int n) {\\n    char output[n];\\n    int counting[256];\\n    memset(counting, 0, sizeof (counting));\\n    for (int i = 0; i < n; i++) {\\n        ++counting[arr[i]];\\n    }\\n    for (int i = 1; i <= 255; ++i) {\\n        counting[i] += counting[i - 1];\\n    }\\n    for (int i = n - 1; i >= 0; i--) {\\n        output[counting[arr[i]] - 1] = arr[i];\\n        --counting[arr[i]];\\n    }\\n    for (int i = 0; i < n; ++i) {\\n        arr[i] = output[i];\\n    }\\n}\\n\\nint main() {\\n    string entrada = \\"alkjslkjkdjaskjdkasjddf\\";\\n    char arr[entrada.size()];\\n    strcpy(arr, entrada.c_str());\\n    int tam = sizeof (arr) / sizeof (arr[0]);\\n    sorted(arr, tam);\\n    cout << \\"Array de caracteres ordenado: \\" << endl;\\n    for (int i = 0; i < tam; i++) {\\n        if (i == tam - 1) {\\n            cout << arr[i] << endl;\\n            break;\\n        }\\n        cout << arr[i] << \\" \\";\\n    }\\n    return 0;\\n}\\n","py":"from sys import stdin, stdout\\nrl = stdin.readline\\nwl = stdout.write\\n\\n\\ndef countSort(arr, n):\\n\\n    output = [\'\'] * n\\n    count = [0] * 256\\n\\n    for i in arr:\\n        count[ord(i)] += 1\\n\\n    for i in range(1, 256):\\n        count[i] += count[i-1]\\n\\n    for i in range(n-1, -1, -1):\\n        output[count[ord(arr[i])]-1] = arr[i]\\n        count[ord(arr[i])] -= 1\\n\\n    for i in range(n):\\n        arr[i] = output[i]\\n\\n\\narr = list(map(str, rl().split()))\\ncountSort(arr, len(arr))\\nprint(*arr)\\n","orden":3,"suborden":11,"fecha_creacion":"2020-12-04 20:09:36","fecha_modificacion":"2020-12-07 02:09:54"},{"ID":22,"supergrupo":"Ordenamientos","tema":"Cycle Sort","texto":"<div style=\\"text-align: justify;\\"><span style=\\"font-size: 10pt;\\">El ordenamiento por ciclos es un algoritmo de ordenamiento en el lugar, un ordenamiento de comparaci\xf3n que es te\xf3ricamente \xf3ptima en t\xe9rminos del n\xfamero total de escrituras en el array original.&nbsp;\\r\\n</span></div><div style=\\"text-align: justify;\\"><span style=\\"font-size: 10pt;\\"><br></span></div><div style=\\"text-align: justify;\\"><span style=\\"font-size: 10pt;\\">Es \xf3ptimo en t\xe9rminos de cantidad de escrituras de memoria. Minimiza el n\xfamero de escrituras de memoria para ordenar (cada valor se escribe cero veces, si ya est\xe1 en su posici\xf3n correcta, o se escribe una vez en su posici\xf3n correcta).</span></div>","complejidad_tiempo":"Mejor caso :    O(n2)            Peor caso :     O(n2)             Promedio: O(n2)","java":"//Programa java implementando Cycle sort\\n\\npublic class CycleSort {\\n\\n    public static void cycleSort(int arr[], int n) {   \\n  //Contador de escrituras en memoria\\n        int writes = 0;\\n        //Pasar poe los elementros del array\\n        //y ponerlos en el lugar correcto \\n        for (int cycle_start = 0; cycle_start <= n - 2; cycle_start++) {\\n            // Inicializa item como punto inicial\\n            int item = arr[cycle_start];\\n            // Encuentra posicion donde nosotros pondremos el item\\n            // Basicamente contamos todos los elementos m\xe1s peque\xf1os\\n            //a la derecha del item\\n            int pos = cycle_start;\\n            for (int i = cycle_start + 1; i < n; i++) {\\n                if (arr[i] < item) {\\n                    pos++;\\n                }\\n            }\\n            //Si item esta ya en la posicion correcta\\n            if (pos == cycle_start) {\\n                continue;\\n            }\\n            //Ignorar todos los elementos duplicados\\n            while (item == arr[pos]) {\\n                pos += 1;\\n            }\\n            //Ponemos el item en su posici\xf3n correcta\\n            if (pos != cycle_start) {\\n                int temp = item;\\n                item = arr[pos];\\n                arr[pos] = temp;\\n                writes++;\\n            }\\n            //Rota el resto del ciclo\\n            while (pos != cycle_start) {\\n                pos = cycle_start;\\n                // Encuentra posicion donde poner el elemento \\n                for (int i = cycle_start + 1; i < n; i++) {\\n                    if (arr[i] < item) {\\n                        pos += 1;\\n                    }\\n                }\\n                //Ignora todos los duplicados\\n                while (item == arr[pos]) {\\n                    pos += 1;\\n                }\\n                // Ponemos el item en su posici\xf3n correcta\\n                if (item != arr[pos]) {\\n                    int temp = item;\\n                    item = arr[pos];\\n                    arr[pos] = temp;\\n                    writes++;\\n                }\\n            }\\n        }\\n    }\\n\\n    public static void main(String[] args) {\\n        int arr[] = {1, 8, 3, 9, 10, 10, 2, 4};\\n        int n = arr.length;\\n        cycleSort(arr, n);\\n        System.out.println(\\"Luego de ordenar : \\");\\n        for (int i = 0; i < n; i++) {\\n            System.out.print(arr[i] + \\" \\");\\n        }\\n    }\\n}\\n","cpp":"#include <iostream>\\n\\nusing namespace std;\\n\\nvoid cycleSort(int arr[], int n) {\\n    int writes = 0;\\n    for (int cycle_start = 0; cycle_start <= n - 2; cycle_start++) {\\n        int item = arr[cycle_start];\\n        int pos = cycle_start;\\n        for (int i = cycle_start + 1; i < n; i++) {\\n            if (arr[i] < item) {\\n                pos++;\\n            }\\n        }\\n        if (pos == cycle_start) {\\n            continue;\\n        }\\n        while (item == arr[pos]) {\\n            pos += 1;\\n        }\\n        if (pos != cycle_start) {\\n            int temp = item;\\n            item = arr[pos];\\n            arr[pos] = temp;\\n            writes++;\\n        }\\n        while (pos != cycle_start) {\\n            pos = cycle_start;\\n            for (int i = cycle_start + 1; i < n; i++) {\\n                if (arr[i] < item) {\\n                    pos += 1;\\n                }\\n            }\\n            while (item == arr[pos]) {\\n                pos += 1;\\n            }\\n            if (item != arr[pos]) {\\n                int temp = item;\\n                item = arr[pos];\\n                arr[pos] = temp;\\n                writes++;\\n            }\\n        }\\n    }\\n}\\n\\nint main() {\\n    ios_base::sync_with_stdio(false);\\n    cout.tie(NULL);\\n    int arr[] = {1, 8, 3, 9, 10, -10, -5, -4, -8, -90, 90, 80};\\n    int n = sizeof (arr) / sizeof (arr[0]);\\n    cycleSort(arr, n);\\n    cout << \\"Luego de ordenar:\\" << endl;\\n    for (int i = 0; i < n; i++) {\\n        if (i == n - 1) {\\n            cout << arr[i] << endl;\\n            break;\\n        }\\n        cout << arr[i] << \\" \\";\\n    }\\n    return 0;\\n}\\n","py":"from sys import stdin, stdout\\nrl = stdin.readline\\nwr = stdout.write\\n\\n\\ndef cycleSort(arr, n):\\n\\n    writes = 0\\n    for cyclestart in range(n-2):\\n        item = arr[cyclestart]\\n        pos = cyclestart\\n\\n        for i in range(cyclestart+1, n):\\n            if arr[i] < item:\\n                pos += 1\\n\\n        if pos == cyclestart:\\n            continue\\n\\n        while item == arr[pos]:\\n            pos += 1\\n\\n        if pos != cyclestart:\\n            item, arr[pos] = arr[pos], item\\n            writes += 1\\n\\n        while pos != cyclestart:\\n            pos = cyclestart\\n            for i in range(cyclestart+1, n):\\n                if arr[i] < item:\\n                    pos += 1\\n            while item == arr[pos]:\\n                pos += 1\\n            if item != arr[pos]:\\n                item, arr[pos] = arr[pos], item\\n                writes += 1\\n\\n\\narr = list(map(int, rl().split()))\\ncycleSort(arr, len(arr))\\nprint(*arr)\\n","orden":3,"suborden":12,"fecha_creacion":"2020-12-04 20:09:36","fecha_modificacion":"2020-12-07 02:10:17"},{"ID":23,"supergrupo":"Ordenamientos","tema":"3 Way Merge Sort","texto":"Merge sort envuelve separaci\xf3n recursiva del array en dos partes, ordenamiento y finalmente uni\xf3n de las mismas. Una variante de merge sort es llamado merge sort de tres v\xedas donde en vez de separar el array en dos partes se separa en tres. Merge sort recursivamente rompe los arrays en arrays de tama\xf1o medio, Merge de tres v\xedas hace lo mismo en arrays de tama\xf1o de un tercio.\\nComplejidad de tiempo: En caso de Merge Sort se tiene la ecuaci\xf3n T(n) = 2T(n/2) + O(n). Igualmente en caso de Merge de tres v\xedas se tiene la ecuaci\xf3n(n) = 3T(n/3) + O(n) por lo que la aproximaci\xf3n m\xe1s cercana de su complejidad es: O(n log 3n).\\n","complejidad_tiempo":"Mejor caso :    O(nlog3n)            Peor caso :     O(nlog3n)             Promedio: O(nlog3n)","java":"//Programa java que realiza Merge Sort de tres vias\\n\\npublic class MergeSort3Way {\\n\\n    public static void mergeSort3Way(Integer[] gArray) {   \\n        //Si el arrat tiene tama\xf1o 0, retorna null\\n        if (gArray == null) {\\n            return;\\n        }\\n        //Creando duplicado del array dado\\n        Integer[] fArray = new Integer[gArray.length];\\n        //Copiando elementos del array dado al\\n        //array duplicado\\n        System.arraycopy(gArray, 0, fArray, 0, fArray.length);\\n        mergeSort3WayRec(fArray, 0, gArray.length, gArray);\\n        //Copiando elementos del array duplicado al\\n        //array dado\\n        System.arraycopy(fArray, 0, gArray, 0, fArray.length);\\n    }\\n\\n    /*Realizando el algoritmo Merge Sort en el array\\n    dado para los valores en el rando de los indices \\n    [low,high], low es el menor y high es el mayor\\n    Exclusivo*/\\n    public static void mergeSort3WayRec(Integer[] gArray,\\n            int low, int high, Integer[] destArray) {\\n        //Si el array tiene tama\xf1o 1 no haga nada\\n        if (high - low < 2) {\\n            return;\\n        }\\n        // Separando el array en tres partes\\n        int mid1 = low + ((high - low) / 3);\\n        int mid2 = low + 2 * ((high - low) / 3) + 1;\\n        // Ordenando las tres partes recursivamente\\n        mergeSort3WayRec(destArray, low, mid1, gArray);\\n        mergeSort3WayRec(destArray, mid1, mid2, gArray);\\n        mergeSort3WayRec(destArray, mid2, high, gArray);\\n        // Uniendo las tres partes\\n        merge(destArray, low, mid1, mid2, high, gArray);\\n    }\\n\\n    /*Une los rangos ordenados (low, mid1),(mid1,mid2)\\n    y (mid2, high), mid 1 es el primer indice punto \\n    medio en todo el rando para unir mid2 es segundo*/\\n    public static void merge(Integer[] gArray, int low,\\n            int mid1, int mid2, int high,\\n            Integer[] destArray) {\\n        int i = low, j = mid1, k = mid2, l = low;\\n        // escoje el m\xe1s peque\xf1o de los m\xe1s peque\xf1os en los\\n        //tres rangos\\n        while ((i < mid1) && (j < mid2) && (k < high)) {\\n            if (gArray[i].compareTo(gArray[j]) < 0) {\\n                if (gArray[i].compareTo(gArray[k]) < 0) {\\n                    destArray[l++] = gArray[i++];\\n                } else {\\n                    destArray[l++] = gArray[k++];\\n                }\\n            } else {\\n                if (gArray[j].compareTo(gArray[k]) < 0) {\\n                    destArray[l++] = gArray[j++];\\n                } else {\\n                    destArray[l++] = gArray[k++];\\n                }\\n            }\\n        }\\n        while ((i < mid1) && (j < mid2)) {\\n            if (gArray[i].compareTo(gArray[j]) < 0) {\\n                destArray[l++] = gArray[i++];\\n            } else {\\n                destArray[l++] = gArray[j++];\\n            }\\n        }\\n        while ((j < mid2) && (k < high)) {\\n            if (gArray[j].compareTo(gArray[k]) < 0) {\\n                destArray[l++] = gArray[j++];\\n            } else {\\n                destArray[l++] = gArray[k++];\\n            }\\n        }\\n        while ((i < mid1) && (k < high)) {\\n            if (gArray[i].compareTo(gArray[k]) < 0) {\\n                destArray[l++] = gArray[i++];\\n            } else {\\n                destArray[l++] = gArray[k++];\\n            }\\n        }\\n        while (i < mid1) {\\n            destArray[l++] = gArray[i++];\\n        }\\n        while (j < mid2) {\\n            destArray[l++] = gArray[j++];\\n        }\\n        while (k < high) {\\n            destArray[l++] = gArray[k++];\\n        }\\n    }\\n\\n    public static void main(String args[]) {\\n        Integer[] data = new Integer[]{45, -2, -45, 78,\\n            30, -42, 10, 19, 73, 93};\\n        mergeSort3Way(data);\\n        System.out.println(\\"Despues de merge sort de 3 vias: \\");\\n        for (int i = 0; i < data.length; i++) {\\n            System.out.print(data[i] + \\" \\");\\n        }\\n    }\\n}\\n","cpp":"#include<bits/stdc++.h>\\n#include<cstdlib>\\nusing namespace std;\\n\\nvoid mergeArr(int gArray[], int low, int mid1, int mid2, int high, int arrdest[]) {\\n    int i = low, j = mid1, k = mid2, l = low;\\n    while ((i < mid1) && (j < mid2) && (k < high)) {\\n        if (gArray[i] < gArray[j]) {\\n            if (gArray[i] < gArray[k]) {\\n                arrdest[l++] = gArray[i++];\\n            } else {\\n                arrdest[l++] = gArray[k++];\\n            }\\n        } else {\\n            if (gArray[j] < gArray[k]) {\\n                arrdest[l++] = gArray[j++];\\n            } else {\\n                arrdest[l++] = gArray[k++];\\n            }\\n        }\\n    }\\n    while ((i < mid1) && (j < mid2)) {\\n        if (gArray[i] < gArray[j]) {\\n            arrdest[l++] = gArray[i++];\\n        } else {\\n            arrdest[l++] = gArray[j++];\\n        }\\n    }\\n    while ((j < mid2) && (k < high)) {\\n        if (gArray[j] < gArray[k]) {\\n            arrdest[l++] = gArray[j++];\\n        } else {\\n            arrdest[l++] = gArray[k++];\\n        }\\n    }\\n    while ((i < mid1) && (k < high)) {\\n        if (gArray[i] < gArray[k]) {\\n            arrdest[l++] = gArray[i++];\\n        } else {\\n            arrdest[l++] = gArray[k++];\\n        }\\n    }\\n    while (i < mid1) {\\n        arrdest[l++] = gArray[i++];\\n    }\\n    while (j < mid2) {\\n        arrdest[l++] = gArray[j++];\\n    }\\n    while (k < high) {\\n        arrdest[l++] = gArray[k++];\\n    }\\n}\\n\\nvoid mergeSort3wayRec(int arr[], int low, int high, int arrdest[]) {\\n    if (high - low < 2) {\\n        return;\\n    }\\n    int mid1 = low + ((high - low) / 3);\\n    int mid2 = low + 2 * ((high - low) / 3) + 1;\\n    mergeSort3wayRec(arrdest, low, mid1, arr);\\n    mergeSort3wayRec(arrdest, mid1, mid2, arr);\\n    mergeSort3wayRec(arrdest, mid2, high, arr);\\n\\n    mergeArr(arrdest, low, mid1, mid2, high, arr);\\n}\\n\\nvoid mergeSort3way(int arr[], int n) {\\n    if (n == 0) {\\n        return;\\n    }\\n    int farr[n];\\n    for (int i = 0; i < n; i++) {\\n        farr[i] = arr[i];\\n    }\\n    mergeSort3wayRec(farr, 0, n, arr);\\n    for (int i = 0; i < n; i++) {\\n        arr[i] = farr[i];\\n    }\\n}\\n\\nvoid printArr(int arr[], int n) {\\n    for (int i = 0; i < n; i++) {\\n        cout << arr[i] << \\" \\";\\n    }\\n    cout << endl;\\n}\\n\\nint main() {\\n    int arr[] = {1, 3, 54, 255, 2, 5, 3, 1, 5, 7, 4, 299, 3, 54, 64, 73};\\n    int N = sizeof (arr) / sizeof (arr[0]);\\n    mergeSort3way(arr, N);\\n    cout << \\"arreglo ordenados\\" << endl;\\n    printArr(arr, N);\\n} \\n","py":null,"orden":3,"suborden":13,"fecha_creacion":"2020-12-04 20:09:36","fecha_modificacion":"2020-12-06 20:05:51"},{"ID":24,"supergrupo":"Ordenamientos","tema":"Pigeon Hole Sort","texto":"Ordenamiento nido de Paloma es un algoritmo de ordenamiento que es adecuado para ordenar listas de elementos donde el n\xfamero de elementos y el n\xfamero de valores de los mismos son aproximadamente lo mismo.\\r\\nEste requiere un tiempo de  O(n + Rango) donde n es el n\xfamero de elementos en el array de entrada y Rango es el n\xfamero de posibles valores en el array. Este algoritmo es similar a Counting sort, pero difiere en la forma en que mueve los datos, dos veces.\\r\\n","complejidad_tiempo":"Mejor caso :    O(N+n)            Peor caso :     O(N+n)             Promedio: O(N+n)\\nN=rango \\n","java":"/*Programa java que implementa Pigeonhole Sort*/\\nimport java.util.*;\\n\\npublic class PigeonholeSort {\\n\\n    static void pigeonhole_sort(int arr[],int n) {\\n        int min = arr[0];\\n        int max = arr[0];\\n        int range, i, j, index;\\n        for (int a = 0; a < n; a++) {\\n            if (arr[a] > max) {\\n                max = arr[a];\\n            }\\n            if (arr[a] < min) {\\n                min = arr[a];\\n            }\\n        }\\n        range = max - min + 1;\\n        int[] phole = new int[range];\\n        Arrays.fill(phole, 0);\\n        for (i = 0; i < n; i++) {\\n            phole[arr[i] - min]++;\\n        }\\n        index = 0;\\n        for (j = 0; j < range; j++) {\\n            while (phole[j]-- > 0) {\\n                arr[index++] = j + min;\\n            }\\n        }\\n    }\\n\\n    public static void main(String[] args) {\\n        int[] arr = {8, 3, 2, 7, 4, 6, 8};\\n        System.out.print(\\"Array ordenado : \\");\\n        pigeonhole_sort(arr, arr.length);\\n        for (int i = 0; i < arr.length; i++) {\\n            System.out.print(arr[i] + \\" \\");\\n        }\\n    }\\n}\\n","cpp":"#include <iostream>\\n#include <string.h>\\n#include <vector>\\n\\nusing namespace std;\\n\\nvoid pigeonHoleSort(int arr[], int n) {\\n    int minim = arr[0];\\n    int maxim = arr[0];\\n    int range, i;\\n    for (int a = 0; a < n; a++) {\\n        if (arr[a] > maxim) {\\n            maxim = arr[a];\\n        }\\n        if (arr[a] < minim) {\\n            minim = arr[a];\\n        }\\n    }\\n    range = maxim - minim + 1;\\n\\n    //Crear un arreglo de vectores de tamamio range.\\n    //Cada vector representa un agujero que estara\\n    //para contener los elementos que coincidentes\\n    vector<int> pHole[range];\\n    memset(pHole, 0, range);\\n\\n    //Atravesar el arreglo de entrada y colocar cada elemento\\n    //en su respectivo agujero\\n    for (i = 0; i < n; i++) {\\n        pHole[arr[i] - minim].push_back(arr[i]);\\n    }\\n\\n    //Recorrer todos los agujeros uno a uno.\\n    //Para cada agujero, se toma sus elementos y se\\n    //colocan en el arreglo dado.\\n    int index = 0;\\n    for (i = 0; i < range; i++) {\\n        for (int k : pHole[i]) {\\n            arr[index++] = k;\\n        }\\n    }\\n}\\n\\nint main() {\\n    ios_base::sync_with_stdio(false);\\n    cout.tie(NULL);\\n    int arr[] = {-8, 4, -5, 8, -6, 90, 70, -95, -100, 105, 97, -1000};\\n    cout << \\"Arreglo ordenado:\\" << endl;\\n    int n = sizeof (arr) / sizeof (arr[0]);\\n    pigeonHoleSort(arr, n);\\n    for (int i = 0; i < n; i++) {\\n        if (i == n - 1) {\\n            cout << arr[i] << endl;\\n            break;\\n        }\\n        cout << arr[i] << \\" \\";\\n    }\\n    return 0;\\n}\\n","py":"from sys import stdin\\nfrom sys import stdout\\n\\nin_, out = stdin.readline, stdout.write\\n\\ndef gen(arr): yield from arr\\n\\ndatos_int = lambda: list(map(int, in_().strip().split()))\\n\\n\\ndef pigeonSort(arr, n):\\n    mn = arr[0]\\n    mx = arr[0]\\n    for k in range(n):\\n        if arr[k] > mx:\\n            mx = arr[k]\\n        if arr[k] < mn:\\n            mn = arr[k]\\n    range_ = mx - mn + 1\\n    phole = [0] * range_\\n    for i in range(n):\\n        phole[arr[i] - mn] += 1\\n    index = 0\\n    for j in range(range_):\\n        while phole[j]:\\n            arr[index] = j + mn\\n            index += 1\\n            phole[j] -= 1\\n\\nlista = datos_int()\\nn = len(lista)\\npigeonSort(lista, n)\\nfor i in gen(lista):\\n    out(f\\"{i} \\")\\nprint()\\n","orden":3,"suborden":14,"fecha_creacion":"2020-12-04 20:09:36","fecha_modificacion":"2020-12-07 02:10:52"},{"ID":25,"supergrupo":"Strings","tema":"Algoritmo de Knuth-Morris-Pratt ","texto":"<div style=\\"font-weight: normal; text-align: justify;\\"><span style=\\"font-size: 10pt;\\">Dado un texto txt[0\u2026n-1] y un patr\xf3n pat[0...m-1] busque todas las ocurrencias de pat en txt e impr\xedmalas, asuma que n es mayor que m.&nbsp;</span></div><div style=\\"font-weight: normal; text-align: justify;\\"><span style=\\"font-size: 10pt;\\"><br></span></div><div style=\\"font-weight: normal; text-align: justify;\\">El algoritmo KMP usa la propiedad de degeneraci\xf3n (Usar los subpatrones que se puedan crear a partir del patr\xf3n) del patr\xf3n y mejora el peor caso de complejidad de O(n). La idea b\xe1sica detr\xe1s de KMP es: Cuando detectemos una no coincidencia (luego de algunas coincidencias), ya sabemos algunos de los caracteres en el texto de la siguiente ventana. Tomamos ventaja de esta informaci\xf3n para evadir coincidencias de caracteres que sabemos que de todas maneras coincidir\xe1n.&nbsp;</div><div style=\\"font-weight: normal; text-align: justify;\\"><br></div><div style=\\"text-align: justify;\\"><span style=\\"font-weight: bold;\\">Revisi\xf3n del preprocesado:</span>\\r\\nKMP preprocesa pat[] y construye un lps[] auxiliar de tama\xf1o m (El mismo tama\xf1o que el patr\xf3n) el cual es usado para saltar caracteres mientras se coteja.\\r\\nEl nombre lps indica el prefijo propio m\xe1s largo el cual es tambi\xe9n sufijo. Un prefijo propio es un prefijo  con todo el string no permitido. Por ejemplo, prefijos de \u201cABC\u201d son \u201c\u201d,\u201dA\u201d,\u201dAB\u201d Y \u201cABC\u201d, prefijos propios son \u201c\u201d, \u201cA\u201d y \u201cAB\u201d. Sufijos del string son \u201c\u201d, \u201cC\u201d,\u201dBC\u201d y \u201cABC\u201d.\\r\\nBuscamos por lps en subpatrones. M\xe1s claramente nos enfocamos en los subsring de patrones que son prefijos y sufijos. Por cada subpatron pat[0...i] donde i=0 hasta m-1, lps[i] almacena la longitud del m\xe1ximo prefijo propio coincidente el cual tambi\xe9n es sufijo del subpatron pat[0...i].\\r\\nAlgoritmo de b\xfasqueda:\\r\\nA diferencia de los algoritmos ingenuos, donde deslizamos el patr\xf3n uno por uno y comparamos todos los caracteres en cada movimientos, usamos un valor de lps[] para decidir los nuevos caracteres que ser\xe1n cotejados, la idea es no cotejar un car\xe1cter que sabemos que va a aparecer.&nbsp;</div><div style=\\"text-align: justify;\\"><span style=\\"font-weight: bold;\\"><br></span></div><div style=\\"text-align: justify;\\"><span style=\\"font-weight: bold;\\">\xbfC\xf3mo usamos lps [] para decidir las siguientes posiciones o n\xfamero de caracteres que ser\xe1n saltadas?&nbsp;</span></div><div style=\\"text-align: justify;\\"><span style=\\"font-size: 10pt;\\"><br></span></div><div style=\\"text-align: justify;\\"><span style=\\"font-size: 10pt;\\">Comenzamos la comparaci\xf3n de pat [j] con j=0 con los caracteres de la actual ventana de texto. Seguimos cotejando caracteres de txt[i] y pat [j] y seguimos incrementando i y j mientras pat[j] y txt [i] sigan coincidiendo.\\r\\nCuando vemos una no coincidencia, sabemos que los caracteres pat[0\u2026j-1] coinciden con txt[i-j\u2026..i-1] (N\xf3tese que j inicia en 0 e incrementa solo cuando hay una coincidencia). Tambi\xe9n sabemos que lps[j-1] est\xe1 contando los caracteres de pat[o\u2026j-1] que son prefijo propio y sufijo.\\r\\nDe estos puntos podemos concluir que nosotros no necesitaremos cotejar estos lps[j-1] caracteres con txt porque sabemos que de todas formas esos caracteres coincidir\xe1n.</span></div>","complejidad_tiempo":"Mejor caso :    On)            Peor caso :     O(n+m)             Promedio: O(m+n)","java":"/* Programa java implementando el algoritmo \\nde busqueda KMP*/\\npublic class KMPStringMatching {\\n\\n    static void KMPSearch(String pat, String txt) {\\n        int M = pat.length();\\n        int N = txt.length();\\n        // Crea lps[] el cual podra mantener el\\n        // m\xe1s largo prefijo sufijo para patr\xf3n\\n        int lps[] = new int[M];\\n        int j = 0; // indice de pat[] \\n        // Preprocesa el patr\xf3n (Calcula lps[]) \\n        computeLPSArray(pat, M, lps);\\n        int i = 0; // indice para txt[] \\n        while (i < N) {\\n            if (pat.charAt(j) == txt.charAt(i)) {\\n                j++;\\n                i++;\\n            }\\n            if (j == M) {\\n                System.out.println(\\"Encontrado patr\xf3n \\"\\n                        + \\"en indice \\" + (i - j));\\n                j = lps[j - 1];\\n            } // no coincide luego de j veces\\n            else if (i < N && pat.charAt(j) != txt.charAt(i)) {\\n                /*No coincide lps[0..lps[j-1]] caracteres\\n                ellos coincidiran de todos modos*/\\n                if (j != 0) {\\n                    j = lps[j - 1];\\n                } else {\\n                    i = i + 1;\\n                }\\n            }\\n        }\\n    }\\n\\n    static void computeLPSArray(String pat, int M, int lps[]) {\\n        // Longitus del anterior prefijo sufijo m\xe1s largo\\n        int len = 0;\\n        int i = 1;\\n        lps[0] = 0; // lps[0] es siempre 0\\n        // el ciclo calcula lps[i] para i = 1 hasta M-1 \\n        while (i < M) {\\n            if (pat.charAt(i) == pat.charAt(len)) {\\n                len++;\\n                lps[i] = len;\\n                i++;\\n            } else // (pat[i] != pat[len])  \\n            {\\n                // Esto es dificl, considere el ejemplo\\n                // AAACAAAA y i = 7. la idea es similar\\n                // el paso de busqueda\\n                if (len != 0) {\\n                    len = lps[len - 1];\\n                    // Tambien, note que no incrementamos \\n                    //i aqui\\n                } else {\\n                    // if (len == 0) \\n                    lps[i] = len;\\n                    i++;\\n                }\\n            }\\n        }\\n    }\\n\\n    public static void main(String args[]) {\\n        String txt = \\"ABABDABACDABABCABAB\\";\\n        String pat = \\"ABABCABAB\\";\\n        KMPSearch(pat, txt);\\n    }\\n}\\n","cpp":"#include<bits/stdc++.h>\\n#include<cstdlib>\\nusing namespace std;\\n\\nvoid computeLPSArray(string pat, int M, int lps[]) {\\n    int len = 0;\\n    int i = 1;\\n    lps[0] = 0;\\n    while (i < M) {\\n        if (pat[i] == pat[len]) {\\n            len++;\\n            lps[i] = len;\\n            i++;\\n        } else {\\n            if (len != 0) {\\n                len = lps[len - 1];\\n            } else {\\n                lps[i] = len;\\n                i++;\\n            }\\n        }\\n    }\\n}\\n\\nvoid KMPsearch(string pat, string txt) {\\n    int M = pat.size();\\n    int N = txt.size();\\n    int lps[M];\\n    int j = 0;\\n    computeLPSArray(pat, M, lps);\\n    int i = 0;\\n    while (i < N) {\\n        if (pat[j] == txt[i]) {\\n            j++;\\n            i++;\\n        }\\n        if (j == M) {\\n            cout << \\"Patron encontrado en el indice \\" << (i - j) << endl;\\n            j = lps[j - 1];\\n        } else if (i < N && pat[j] != txt[i]) {\\n            if (j != 0) {\\n                j = lps[j - 1];\\n            } else {\\n                i++;\\n            }\\n        }\\n    }\\n}\\n\\nint main() {\\n    string txt = \\"lalalalalala\\";\\n    string pat = \\"lal;\\n    KMPsearch(pat, txt);\\n}\\n","py":"def KMPsearch(pat, txt):\\n    M = len(pat)\\n    N = len(txt)\\n    lps = [None for x in range(M)]\\n    j = 0\\n    computeLPSArray(pat, M, lps)\\n    i = 0\\n    while i < N:\\n        if pat[j] == txt[i]:\\n            i += 1\\n            j += 1\\n        if j == M:\\n            print(\\"Encontrado patr\xc3\xb3n (\\", pat, \\") en el indice \\", (i - j), \\"-\\", ((i - j) + M - 1))\\n            j = lps[j - 1]\\n        elif i < N and pat[j] != txt[i]:\\n            if j != 0:\\n                j = lps[j-1]\\n            else:\\n                i += 1\\n\\ndef computeLPSArray(pat, M, lps):\\n    leng = 0\\n    i = 1\\n    lps[0] = 0\\n    while i < M:\\n        if pat[i] == pat[leng]:\\n            leng += 1\\n            lps[i] = leng\\n            i += 1\\n        else:\\n            if leng != 0:\\n                leng = lps[leng-1]\\n            else:\\n                lps[i] = leng\\n                i += 1\\n\\ndef variasB\xfasquedas(arr, txt):\\n    for i in range(len(arr)):\\n        KMPsearch(arr[i], txt)\\n\\ntxt = \\"lalalalalalalalalalala\\"\\narr = [\\"la\\", \\"lal\\", \\"lala\\"]\\nvariasB\xfasquedas(arr, txt)\\n","orden":5,"suborden":99,"fecha_creacion":"2020-12-04 20:09:36","fecha_modificacion":"2020-12-07 02:13:00"},{"ID":26,"supergrupo":"Strings","tema":"Algoritmo de Rabin-Karp ","texto":"<div style=\\"font-weight: normal; text-align: justify;\\"><span style=\\"font-size: 10pt;\\">Dado un texto txt[0...n-1] y un patr\xf3n pat[0...m-1] busque todas las ocurrencias de pat en txt e impr\xedmalas, asuma que n es mayor que m.&nbsp;</span></div><div style=\\"font-weight: normal; text-align: justify;\\"><span style=\\"font-size: 10pt;\\"><br></span></div><div style=\\"font-weight: normal; text-align: justify;\\"><span style=\\"font-size: 10pt;\\">Como los algoritmos ingenuos, Rabin-Karp tambi\xe9n desliza el patr\xf3n uno por uno, pero a diferencia de este, RK coteja el valor hash del patr\xf3n con el valor hash del actual substring de texto y su los valores hash coinciden entonces solo empieza a cotejar caracteres individuales, entonces RK necesita calcular los valores hash de los siguientes strings.&nbsp;</span></div><div style=\\"font-weight: normal; text-align: justify;\\"><span style=\\"font-size: 10pt;\\"><br></span></div><div style=\\"font-weight: normal; text-align: justify;\\"><span style=\\"font-size: 10pt;\\">1) El string patr\xf3n&nbsp;</span></div><div style=\\"font-weight: normal; text-align: justify;\\"><span style=\\"font-size: 10pt;\\">2) Todos los substrings del texto de tama\xf1o m.&nbsp;</span></div><div style=\\"font-weight: normal; text-align: justify;\\"><span style=\\"font-size: 10pt;\\"><br></span></div><div style=\\"font-weight: normal; text-align: justify;\\"><span style=\\"font-size: 10pt;\\">Desde que necesitamos calcular eficientemente los valores hash de todos los substrings de tama\xf1o m del texto, debemos tener una funci\xf3n hash la cual tenga la siguiente propiedad.\\r\\nEl hash del siguiente cambio debe ser eficientemente calculable desde el hash actual y el siguiente car\xe1cter en el texto o podemos decir hashtxt[s+1\u2026.. s+m])= rehash (txt[s+m], hash(txt[s\u2026.s+m-1]) y rehash debe ser una operaci\xf3n O(1).&nbsp;</span></div><div style=\\"font-weight: normal; text-align: justify;\\"><span style=\\"font-size: 10pt;\\"><br></span></div><div style=\\"font-weight: normal; text-align: justify;\\"><span style=\\"font-size: 10pt;\\">La funci\xf3n hash sugerida por Rabin y Karp calcula un valor entero, el valor entero para  un string es un valor n\xfamero de un string, por ejemplo el n\xfamero si todos los posibles caracteres son de 1 a 10, el valor n\xfamero de \u201c122\u201d seria 122. El n\xfamero de posibles caracteres es mayor que 10 (256 en general) y la longitud el patr\xf3n puede ser larga. Entonces los valores num\xe9ricos no pueden ser pr\xe1cticamente almacenados como un entero. Sin embargo el valor n\xfamero es calculado usando matem\xe1tica modular para asegurar que los valores hash pueden ser almacenados en una variable entra (puede caber en palabras de memoria).&nbsp;</span></div><div style=\\"font-weight: normal; text-align: justify;\\"><span style=\\"font-size: 10pt;\\"><br></span></div><div style=\\"font-weight: normal; text-align: justify;\\"><span style=\\"font-size: 10pt;\\">Para hacer rehashing, necesitamos tomar el m\xe1s significante digito y a\xf1adirlo nuestro nuevo digito significante para el valor hash, el rehashing se realiza con la siguiente formula\\r\\n- hash( txt[s+1 .. s+m] ) = ( d ( hash( txt[s .. s+m-1]) \u2013 txt[s]*h ) + txt[s + m] ) mod q\\r\\n- hash( txt[s .. s+m-1] ) :  Valor hash en cambio s.\\r\\n- hash( txt[s+1 .. s+m] ) : Valor has en nuevo cambio ( cambio s+1)\\r\\n- d:N\xfamero de caracteres en el alfabeto\\r\\n- q: Un n\xfamero primo\\r\\n- h: d^(m-1)\\r\\nEsto es matem\xe1tica simple, calculamos el valor decimal de la actual ventana desde la ventana anterior.\\r\\nPor ejemplo el tama\xf1o del patr\xf3n es 3 y el string es \u201c23456\u201d\\r\\nSe calcula el valor de la primera ventana el cual es 234 (String ventana es \u201c234\u201d).&nbsp;</span></div><div style=\\"font-weight: normal; text-align: justify;\\"><span style=\\"font-size: 10pt;\\"><br></span></div><div style=\\"text-align: justify;\\"><span style=\\"font-size: 10pt; font-weight: bold;\\">\xbfC\xf3mo puedes calcular el valor de la siguiente ventana \u201c345\u201d?&nbsp;</span></div><div style=\\"font-weight: normal; text-align: justify;\\"><span style=\\"font-size: 10pt;\\"><br></span></div><div style=\\"font-weight: normal; text-align: justify;\\"><span style=\\"font-size: 10pt;\\">se puede hacer (234 \u2013 2*100)*10 + 5 y obtener 345.\\r\\nEl promedio y mejor tiempo de ejecuci\xf3n en un caso de RK es de O(n+m) pero su peor caso es O(nm). El peor caso de Rabin-Karp ocurre cuando todos los caracteres del patr\xf3n y el texto tienen los mismos valores hash de todos los substrings de txt, por ejemplo pat[]=\u201dAAA\u201d  y txt[]=\u201dAAAAAAA\u201d.</span></div>","complejidad_tiempo":"Mejor caso :    O(m+n)            Peor caso :     O(n*m)             Promedio: O(n*m)","java":"/*Implementaci\xf3n java del algoritmo de \\nRabin Karp*/\\npublic class RabinKarp {   \\n// d es eln\xfamero de caracteres en el alfabeto de entrada\\n\\n    public final static int d = 256;\\n\\n    /* pat -> patr\xf3n \\n        txt -> texto\\n        q -> Un n\xfamero primo\\n     */\\n    static void search(String pat, String txt, int q) {\\n        int M = pat.length();\\n        int N = txt.length();\\n        int i, j;\\n        int p = 0; // valor hash  del patr\xf3n\\n        int t = 0; // valor hash  del txt \\n        int h = 1;\\n        // el valor de h debe ser \\"pow(d, M-1)%q\\"\\n        for (i = 0; i < M - 1; i++) {\\n            h = (h * d) % q;\\n        }\\n        /*Calcula el valor hash del patron y primera \\n        ventana de texto*/\\n        for (i = 0; i < M; i++) {\\n            p = (d * p + pat.charAt(i)) % q;\\n            t = (d * t + txt.charAt(i)) % q;\\n        }\\n        //Desliza el patr\xf3n por encima del texto uno por uno\\n        for (i = 0; i <= N - M; i++) {\\n            /*Verifica los valores hash de la actual ventana de text\\n            y patr\xf3n. Si el valor hash coincide entonces solo revisa \\n            los caratceres uno por uno*/\\n            if (p == t) {\\n                /*Revisa por caracteres uno por uno*/\\n                for (j = 0; j < M; j++) {\\n                    if (txt.charAt(i + j) != pat.charAt(j)) {\\n                        break;\\n                    }\\n                }\\n                // Si p==t y pat[0...M-1] = txt[i, i+1, ...i+M-1] \\n                if (j == M) {\\n                    System.out.println(\\"Patron encontrado en el indice \\" + i);\\n                }\\n            }\\n            // Calcula el valor hash de la siguiente ventana de texto\\n            // Remueve el digito lider, y final\\n            if (i < N - M) {\\n                t = (d * (t - txt.charAt(i) * h) + txt.charAt(i + M)) % q;\\n                /*Nosotros obtendremos un valor negativo de t\\n                convirtiendolo a positivo*/\\n                if (t < 0) {\\n                    t = (t + q);\\n                }\\n            }\\n        }\\n    }\\n\\n    public static void main(String[] args) {\\n        String txt = \\"EQUIPO ARTEMIS\\";\\n        String pat = \\"ARTE\\";\\n        int q = 101; // un n\xfamero primo\\n        search(pat, txt, q);\\n    }\\n}\\n","cpp":"using namespace std;\\n#include<bits/stdc++.h>\\n#include<cstdlib>\\n#define FAST ios_base::sync_with_stdio(false);cin.tie(NULL);cout.tie(0);cout<<setprecision(25);\\nint d = 256;\\n\\nvoid rabinKarp(string pat, string txt, int q) {\\n    int M = pat.size();\\n    int N = txt.size();\\n    int i, j; //indices\\n    int p = 0;\\n    int t = 0;\\n    int h = 1; //tamanio del hash\\n    for (i = 0; i < M - 1; i++) {\\n        h = (h * d) % q;\\n    }\\n    for (i = 0; i < M; i++) {\\n        p = (d * p + pat[i]) % q;\\n        t = (d * i + txt[i]) % q;\\n    }\\n    for (i = 0; i <= N - M; i++) {\\n        if (p == t) {\\n            for (j = 0; j < M; j++) {\\n                if (txt[i + j] != pat[j]) {\\n                    break;\\n                }\\n            }\\n            if (j == M) {\\n                cout << \\"Patron encontrado en el indice \\" << i << \\" \\" << (i + M - 1) << endl;\\n            }\\n        }\\n        if (i < N - M) {\\n            t = (d * (t - txt[i] * h) + txt[i + M]) % q;\\n            if (t < 0) {\\n                t = (t + q);\\n            }\\n        }\\n    }\\n}\\n\\nint main() {\\n    FAST\\n    string txt = \\"anita lava la tina\\";\\n    string pat = \\"la\\";\\n    rabinKarp(pat, txt, d);\\n}\\n","py":"from sys import stdin\\nfrom sys import stdout\\nd = 256\\n\\n\\ndef rabinKarp(pat, txt, q):\\n    M = len(pat)\\n    N = len(txt)\\n    i, j, p, t, h = int(0), int(0), int(0), int(0), int(1)\\n    for i in range(M-1):\\n        h = (h * d) % q\\n    for i in range(M):\\n        p = (d * p + ord(pat[i])) % q\\n        t = (d * t + ord(txt[i])) % q\\n    for i in range(N-M + 1):\\n        if p == t:\\n            for j in range(M):\\n                if txt[i + j] != pat[j]:\\n                    break\\n            j += 1\\n            if j == M:\\n                stdout.write(f\'Patron en {str(i)} - {str(i+M-1)}\\\\n\')\\n        if i < N-M:\\n            t = (d * (t-ord(txt[i]) * h) + ord(txt[i + M])) % q\\n            if t < 0:\\n                t = t + q\\n\\n\\ntxt = \'Anita lava la tina\'\\npat = \'la\'\\nrabinKarp(pat, txt, d)\\n\\n","orden":5,"suborden":99,"fecha_creacion":"2020-12-04 20:09:36","fecha_modificacion":"2020-12-07 02:14:48"},{"ID":27,"supergrupo":"Strings","tema":"Algoritmo de Boyer-Moore ","texto":"<div style=\\"font-weight: normal; text-align: justify;\\"><span style=\\"font-size: 10pt;\\">Cuando realizamos una b\xfasqueda de un string en Notepad, Word, buscador o una base de datos, los algoritmos de b\xfasquedas de patrones son usados para buscar los resultados.&nbsp;</span></div><div style=\\"font-weight: normal; text-align: justify;\\"><span style=\\"font-size: 10pt;\\"><br></span></div><div style=\\"font-weight: normal; text-align: justify;\\"><span style=\\"font-size: 10pt;\\">Un enunciado de este problema podr\xeda ser:\\r\\nDado un texto txt[0\u2026n-1] y un patr\xf3n pat[0...m-1] busque una funci\xf3n que imprima todas las ocurrencias de pat en txt, se asume que n es mayor que m.&nbsp;</span></div><div style=\\"font-weight: normal; text-align: justify;\\"><span style=\\"font-size: 10pt;\\"><br></span></div><div style=\\"font-weight: normal; text-align: justify;\\"><span style=\\"font-size: 10pt;\\">Como KMP y Boyer Moore tambi\xe9n preprocesa el patr\xf3n, Boyer Moore es la combinaci\xf3n de las siguientes dos aproximaciones:\\r\\n1) Heur\xedstica de caracteres malos\\r\\n2) Heur\xedstica de buenos sufijos\\r\\nAmbas de las dos heur\xedsticas de arriba pueden tambi\xe9n ser usadas independientemente para buscar un patr\xf3n en un texto. Primero entendamos como estas dos aproximaciones trabajan juntos en Boyer Moore. Si tomamos un vistazo a cualquier algoritmo ingenuo, desliza el patr\xf3n sobre el texto car\xe1cter por car\xe1cter. KMP hace preprocesado sobre el patr\xf3n de tal forma que el patr\xf3n puede ser cambiado m\xe1s de una vez.&nbsp;</span></div><div style=\\"font-weight: normal; text-align: justify;\\"><span style=\\"font-size: 10pt;\\"><br></span></div><div style=\\"font-weight: normal; text-align: justify;\\"><span style=\\"font-size: 10pt;\\">El algoritmo de Boyer Moore hace preprocesado por la misma raz\xf3n. Este procesa el patr\xf3n y crea arrays diferentes para cada heur\xedstica. En cada paso desliza el patr\xf3n por el m\xe1ximo de deslices sugeridos por las dos heur\xedsticas, entonces usa la mejor de las dos heur\xedsticas en cada paso.\\r\\nA diferencia de los anteriores algoritmos de b\xfasqueda de patrones, Boyer Moore comienza el cotejamiento desde el \xfaltimo car\xe1cter del patr\xf3n.&nbsp;</span></div><div style=\\"font-weight: normal; text-align: justify;\\"><span style=\\"font-size: 10pt;\\"><br></span></div><div style=\\"text-align: justify;\\"><span style=\\"font-size: 10pt; font-weight: bold;\\">Heur\xedstica de caracteres malos&nbsp;</span></div><div style=\\"font-weight: normal; text-align: justify;\\"><span style=\\"font-size: 10pt;\\">La idea de esta heur\xedstica es simple. El car\xe1cter del texto que no coincida con el car\xe1cter actual del patr\xf3n es llamado un car\xe1cter malo. Con esta no coincidencia nosotros movemos el patr\xf3n hasta:&nbsp;</span></div><div style=\\"font-weight: normal; text-align: justify;\\"><span style=\\"font-size: 10pt;\\"><br></span></div><div style=\\"font-weight: normal; text-align: justify;\\"><span style=\\"font-size: 10pt;\\"><span style=\\"white-space:pre\\">\\t</span>1) La no coincidencia se convierta en un cotejamiento positivo.&nbsp;</span></div><div style=\\"font-weight: normal; text-align: justify;\\"><span style=\\"font-size: 10pt;\\"><span style=\\"white-space:pre\\">\\t</span>2) Patr\xf3n P se mueve despu\xe9s del car\xe1cter no coincidente.&nbsp;</span></div><div style=\\"font-weight: normal; text-align: justify;\\"><span style=\\"font-size: 10pt;\\"><br></span></div><div style=\\"font-weight: normal; text-align: justify;\\"><span style=\\"font-size: 10pt;\\">Caso 1: No coincidencia se convierte en una coincidencia\\r\\nBuscamos la posici\xf3n de la \xfaltima ocurrencia del car\xe1cter no coincidente en el patr\xf3n y si el car\xe1cter no coincidente existe en el patr\xf3n, entones movemos el patr\xf3n de tal manera que quede alineado con el car\xe1cter no coincidente en el texto T.&nbsp;</span></div><div style=\\"font-weight: normal; text-align: justify;\\"><span style=\\"font-size: 10pt;\\"><br></span></div><div style=\\"font-weight: normal; text-align: justify;\\"><span style=\\"font-size: 10pt;\\">Caso 2: El patr\xf3n se mueve pasado el car\xe1cter no coincidente\\r\\nNosotros buscamos la posici\xf3n de la \xfaltima ocurrencia del car\xe1cter no coincidente en el patr\xf3n y si el car\xe1cter no existe deber\xedamos mover el patr\xf3n pasado ese car\xe1cter.</span></div>","complejidad_tiempo":"Mejor caso :    O(n)            Peor caso :     O(3n)             Promedio: O(n)","java":"/*Programa java para heuristica de malos caracteres\\nusando el algoritmo de Boyer Moore*/\\n\\npublic class BoyerMoore {\\n\\n    static int NO_OF_CHARS = 256;\\n    //Una funci\xf3n de utilidad para obtener el maximo de\\n    //dos enteros\\n    static int max(int a, int b) {\\n        return (a > b) ? a : b;\\n    }\\n    //El preprocesado del algoritmo\\n    static void badCharHeuristic(char[] str, int size, int badchar[]) {\\n        int i;\\n        // Inicializa todas las ocurrencias en  -1 \\n        for (i = 0; i < NO_OF_CHARS; i++) {\\n            badchar[i] = -1;\\n        }\\n        /*Llena el actual valor de la ultima ocurrencia\\n        de un caracter*/\\n        for (i = 0; i < size; i++) {\\n            badchar[(int) str[i]] = i;\\n        }\\n    }\\n\\n    /* Una funci\xf3n de busqueda de patr\xf3n que usa \\n     la heuristica de mal caracter*/\\n    static void search(char txt[], char pat[]) {\\n        int m = pat.length;\\n        int n = txt.length;\\n        int badchar[] = new int[NO_OF_CHARS];\\n        /* Llena el arreglo de malos caracteres llamando\\n        la funci\xf3n de preprocesado para el patr\xf3n dado*/\\n        badCharHeuristic(pat, m, badchar);\\n        int s = 0;  // s  es cambiado del patron con respecto al texto  \\n        while (s <= (n - m)) {\\n            int j = m - 1;\\n            /* Mantiene reduciento el indice j para el patr\xf3n\\n            mientras los caracteres del patr\xf3n y el texto \\n            estan coincidiendo en s*/\\n            while (j >= 0 && pat[j] == txt[s + j]) {\\n                j--;\\n            }\\n            /*Si el patr\xf3n esta presente en el actual\\n            cambio, entonces el indice j se convertira en -1\\n            luego del ciclo de arriba*/\\n            if (j < 0) {\\n                System.out.println(\\"Patr\xf3n encontrado en cambio = \\" + s);\\n                s += (s + m < n) ? m - badchar[txt[s + m]] : 1;\\n            } else {\\n                s += max(1, j - badchar[txt[s + j]]);\\n            }\\n        }\\n    }\\n    public static void main(String[] args) {\\n        char txt[] = \\"ABAAABCDABCABC\\".toCharArray();\\n        char pat[] = \\"ABC\\".toCharArray();\\n        search(txt, pat);\\n    }\\n}\\n","cpp":"#include<bits/stdc++.h>\\n#include<cstdlib>\\nusing namespace std;\\nconst int NO_OF_CHARS = 256;\\n\\nint MAX(int a, int b) {\\n    return a > b ? a : b;\\n}\\n\\nvoid badCharHeuristic(char str[], int siz, int badchar[]) {\\n    int i;\\n    memset(badchar, -1, sizeof badchar);\\n    for (i = 0; i < siz; i++) {\\n        badchar[(int) str[i]] = i;\\n    }\\n}\\n\\nvoid boyerMoore(char txt[], char pat[]) {\\n    int m = strlen(pat);\\n    int n = strlen(txt);\\n    int badchar[NO_OF_CHARS];\\n    badCharHeuristic(pat, m, badchar);\\n    int s = 0;\\n    while (s <= (n - m)) {\\n        int j = m - 1;\\n        while (j <= 0 && pat[j] == txt[s + j]) {\\n            j--;\\n        }\\n        if (j > 0) {\\n            cout << \\"Patron encontrado encontrado en salto \\" << s << endl;\\n            s += (s + m < m) ? badchar[txt[s + m]] : 1;\\n        } else {\\n            s += MAX(1, j - badchar[txt[s + j]]);\\n        }\\n    }\\n}\\n\\nint main() {\\n    char txt[] = \\"lalalalalalalala\\";\\n    char pat[] = \\"lala\\";\\n    boyerMoore(txt, pat);\\n}\\n","py":"\\nfrom sys import stdout\\nwr = stdout.write\\n\\nNO_OF_CHARS = 256\\n\\ndef badChar(string, size, badchar):\\n    for i in range(size):\\n        badchar[ord(string[i])] = i\\n\\n\\ndef BMsearch(txt, pat):\\n\\n    M = len(pat)\\n    N = len(txt)\\n    badchar = [0] * NO_OF_CHARS\\n    badChar(pat, M, badchar)\\n    s = 0\\n\\n    while s <= N-M:\\n        j = M-1\\n        while j >= 0 and pat[j] == txt[s+j]:\\n            j -= 1\\n        if j < 0:\\n            wr(f\'\\"{\\"\\".join(txt[s:s+M])}\\" encontrado en el indice ({s} - {s+M-1})\\\\n\')\\n            s += M - badchar[ord(txt[s+M])] if s + M < N else 1\\n        else:\\n            s += max(1, j - badchar[ord(txt[s+j])])\\n\\n\\ntxt = \'anitalavalatina\'\\npat = \'al\'\\nBMsearch(txt, pat)\\n","orden":5,"suborden":0,"fecha_creacion":"2020-12-04 20:09:36","fecha_modificacion":"2020-12-07 02:17:36"},{"ID":28,"supergrupo":"Strings","tema":"Patr\xf3n en anagramas","texto":"Dado un texto txt [0...n-1] y un patr\xf3n pat [0...m-11], use una funci\xf3n que imprima todas las ocurrencias de pat [] y sus permutaciones (o anagramas) en txt [], se asume que n es menor que m.&nbsp;<div style=\\"font-weight: normal;\\"><br></div><div style=\\"font-weight: normal;\\">La complejidad de tiempo esperada es de O(n).\\r\\nEste problema es ligeramente diferente a la b\xfasqueda de patrones est\xe1ndar, aqu\xed necesitamos buscar por anagramas tambi\xe9n. Por lo tanto no podemos aplicar directamente la b\xfasqueda de patrones est\xe1ndar de algoritmos como KMP, Rabin Karp o Boyer Moore.\\r\\nPodemos conseguir una complejidad de tiempo de O(n) asumiendo que el tama\xf1o del alfabeto est\xe1 arreglado en los 256 caracteres ASCII.&nbsp;</div><div style=\\"font-weight: normal;\\"><br></div><div style=\\"\\"><span style=\\"font-weight: bold;\\">La idea es usar dos arrays de conteo:&nbsp;</span></div><div style=\\"font-weight: normal;\\"><span style=\\"white-space:pre\\">\\t</span>1) El primer array de conteo almacena la frecuencia de los caracteres en el patr\xf3n.&nbsp;</div><div style=\\"font-weight: normal;\\"><span style=\\"white-space:pre\\">\\t</span>2) El Segundo array de conteo almacena la frecuencia en la actual ventana de texto.&nbsp;</div><div style=\\"font-weight: normal;\\"><br></div><div style=\\"font-weight: normal;\\">Una cosa importante a tener en cuenta es, la complejidad de tiempo de comparar dos arrays de conteo es O(1) como el n\xfamero de elementos en ellos.&nbsp;</div><div style=\\"font-weight: normal;\\"><br></div><div style=\\"\\"><span style=\\"font-weight: bold;\\">Estos son los pasos de este algoritmo:&nbsp;</span></div><div style=\\"font-weight: normal;\\"><span style=\\"white-space:pre\\">\\t</span>1) Almacena conteos de frecuencia del patr\xf3n en el primer array de conteo countP []. Tambi\xe9n almacena conteo de frecuencias de la primera ventana de texto en el array countTW[].&nbsp;</div><div style=\\"font-weight: normal;\\"><span style=\\"font-size: 10pt;\\"><span style=\\"white-space:pre\\">\\t</span>2) Ahora ejecuta un ciclo de i=M hasta N-1 haciendo lo siguiente en cada ciclo:&nbsp;</span></div><div style=\\"font-weight: normal;\\"><span style=\\"font-size: 10pt;\\"><span style=\\"white-space:pre\\">\\t\\t</span>a) Si los dos arrays de conteo son id\xe9nticos, hemos encontrado una ocurrencia.&nbsp;</span></div><div style=\\"font-weight: normal;\\"><span style=\\"font-size: 10pt;\\"><span style=\\"white-space:pre\\">\\t\\t</span>b) Incrementa el conteo del actual car\xe1cter del texto en countTW[]\\r\\nc) Decrementa conteo del primer car\xe1cter en la ventana anterior en countWT[]\\r\\n3) La \xfaltima ventana no es revisada por&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; este ciclo, se revisa expl\xedcitamente</span></div>","complejidad_tiempo":"Mejor caso :    O(n)            Peor caso :     O(n)             Promedio: O(n)","java":"// Programa java que busca todos los anagram\xe1s\\n// de un patr\xf3n en un texto \\n\\npublic class AnagramsPattern {\\n\\n    static final int MAX = 256;\\n    // Esta funci\xf3n retorna true si los contenidos\\n    // de arr1[] y arr2[] son iguales, de otra forma es falso\\n\\n    static boolean compare(char arr1[], char arr2[]) {\\n        for (int i = 0; i < MAX; i++) {\\n            if (arr1[i] != arr2[i]) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n    // Esta funci\xf3n busca todas las permutaciones de \\n    // pat[] en txt[]\\n\\n    static void search(String pat, String txt) {\\n        int M = pat.length();\\n        int N = txt.length();\\n        // countP[]:  Almacena el conteo de todos\\n        // los caracteres del patr\xf3n\\n        // countTW[]: Almacena el conteo de los caracteres\\n        // la ventana de texto\\n        char[] countP = new char[MAX];\\n        char[] countTW = new char[MAX];\\n        for (int i = 0; i < M; i++) {\\n            (countP[pat.charAt(i)])++;\\n            (countTW[txt.charAt(i)])++;\\n        }\\n        //Atravesar atravez de los caracteres restantes de patr\xf3n\\n        for (int i = M; i < N; i++) {   //Compara conteos de la ventana actual\\n            // de texto con los conteos de pattern[]\\n            if (compare(countP, countTW)) {\\n                System.out.println(\\"Encontrado en indice \\"\\n                        + (i - M));\\n            }\\n            // Agreca el actual caracter a la ventana actual\\n            (countTW[txt.charAt(i)])++;\\n            // Remueve el primer caracter de la anterior ventana\\n            countTW[txt.charAt(i - M)]--;\\n        }\\n        // Revisa por la ultima ventana en el texto\\n        if (compare(countP, countTW)) {\\n            System.out.println(\\"Encontrado en indice \\"\\n                    + (N - M));\\n        }\\n    }\\n\\n    public static void main(String args[]) {\\n        String txt = \\"BACDGABCDA\\";\\n        String pat = \\"ABCD\\";\\n        search(pat, txt);\\n    }\\n}\\n","cpp":"#include <iostream>\\n#include <string.h>\\n\\nusing namespace std;\\n\\nconst int MAX = 256;\\n\\nbool compare(char arr1[], char arr2[]){\\n    for(int i = 0; i < MAX; i++){\\n        if(arr1[i] != arr2[i]){\\n            return false;\\n        }\\n    }\\n    return true;\\n}\\n\\nvoid anagramsSearch(string pat, string txt){\\n    int M = pat.size();\\n    int N = txt.size();\\n    char countP[MAX];\\n    char countTX[MAX];\\n    memset(countP,0 , MAX);\\n    memset(countTX, 0, MAX);\\n    for(int i = 0; i < M; i++){\\n        countP[pat[i]]++;\\n        countTX[txt[i]]++;\\n    }\\n    for(int i = M; i < N; i++){\\n        if(compare(countP, countTX)){\\n            cout << \\"Encontrado en el indice \\"<<(i - M)<<\\" Anagrama: \\"<<txt.substr(i - M, M)<<endl;\\n        }\\n        countTX[txt[i]]++;\\n        countTX[txt[i - M]]--;\\n    }\\n    if(compare(countP, countTX)){\\n        cout<<\\"Encontrado en el indice \\"<<(N - M) <<\\" Anagrama: \\"<< txt.substr(N - M, N) << endl;\\n    }\\n}\\n\\nint main()\\n{\\n    string txt = \\"anitalavalatinaanilegustviajarnitatani\\";\\n    string pat = \\"anita\\";\\n    anagramsSearch(pat, txt);\\n    return 0;\\n}\\n","py":"from sys import stdout\\nwr = stdout.write\\n\\nMAX = 256\\n\\ndef anagramsSearch(pat, txt):\\n\\n    M = len(pat)\\n    N = len(txt)\\n    countP = [0] * MAX\\n    countTW = [0] * MAX\\n\\n    for i in range(M):\\n        countP[ord(pat[i])] += 1\\n        countTW[ord(txt[i])] += 1\\n    for i in range(M, N):\\n        if countP == countTW:\\n            wr(f\'\\"{txt[i-M:i]}\\" encontrado en el indice ({i-M} - {i-1})\\\\n\')\\n        countTW[ord(txt[i])] += 1\\n        countTW[ord(txt[i-M])] -= 1\\n    if countP == countTW:\\n        wr(f\'\\"{txt[N-M:N]}\\" encontrado en el indice ({N-M} - {N-1})\\\\n\')\\n\\n\\ntxt = \'BACDGABCDAABDCDBA\'\\npat = \'ABDC\'\\nanagramsSearch(pat, txt)\\n","orden":5,"suborden":1,"fecha_creacion":"2020-12-04 20:09:36","fecha_modificacion":"2020-12-07 02:18:52"},{"ID":29,"supergrupo":"Strings","tema":"Wildcard","texto":"Dado un texto y un patr\xf3n de wildcards, se debe implementar un algoritmo que encuentre si el patr\xf3n wildcard concuerda con el texto, el cotejamiento debe cubrir todo el texto.&nbsp;<div style=\\"font-weight: normal;\\"><br></div><div style=\\"font-weight: normal;\\">El patr\xf3n wildcard puede incluir los caracteres \u2018?\u2019 y \u2018*\u2019:\\r\\n\u2018?\u2019 \u2013 Coteja cualquier car\xe1cter solitario.\\r\\n\u2018*\u2019 \u2013 Coteja cualquier secuencia de caracteres (Incluyendo una secuencia vac\xeda).\\r\\nCada ocurrencia de \u2018?\u2019 en el patr\xf3n wildcard puede ser reemplazado con cualquier otro car\xe1cter y cada ocurrencia de \u2018*\u2019 con una secuencia de caracteres tales que el patr\xf3n de wildcard se convierta en id\xe9ntico al string de entrada luego del reemplazo.&nbsp;</div><div style=\\"font-weight: normal;\\"><br></div><div style=\\"font-weight: normal;\\">Consideremos cualquier car\xe1cter en el patr\xf3n.&nbsp;</div><div style=\\"font-weight: normal;\\"><br></div><div style=\\"\\"><span style=\\"font-weight: bold;\\">Caso 1: El car\xe1cter es \u2018*\u2019&nbsp;</span></div><div style=\\"font-weight: normal;\\"><br></div><div style=\\"font-weight: normal;\\">Aqu\xed dos cosas pueden pasar:\\r\\n- Podemos ignorar el car\xe1cter \u2018*\u2019 y movernos al siguiente car\xe1cter del patr\xf3n.\\r\\n- El car\xe1cter \u2018*\u2019 coincide con uno o m\xe1s caracteres en el texto, aqu\xed podemos movernos al car\xe1cter siguiente en el string.&nbsp;</div><div style=\\"font-weight: normal;\\"><br></div><div style=\\"\\"><span style=\\"font-weight: bold;\\">Caso 2: El car\xe1cter es \u2018?\u2019:&nbsp;</span></div><div style=\\"font-weight: normal;\\"><br></div><div style=\\"font-weight: normal;\\">Podemos ignorar el actual car\xe1cter en el texto y movernos al siguiente car\xe1cter en el patr\xf3n y texto.&nbsp;</div><div style=\\"font-weight: normal;\\"><br></div><div style=\\"\\"><span style=\\"font-weight: bold;\\">Caso 3: El car\xe1cter no es un car\xe1cter wildcard&nbsp;</span></div><div style=\\"font-weight: normal;\\"><br></div><div style=\\"font-weight: normal;\\">Si el car\xe1cter actual en el texto coincide con el actual car\xe1cter en el patr\xf3n, podemos movernos al siguiente car\xe1cter en el patr\xf3n y el texto, si no concuerdan, el patr\xf3n wildcard y el texto.</div>","complejidad_tiempo":"Mejor caso :    O(n*m)            Peor caso :     O(n*m)             Promedio: O(n*m)","java":"//Programa java que implementa el cotejamiento\\n// de patrones con Wildcard\\n\\nimport java.util.Arrays;\\n\\npublic class WildcardPattern {\\n    //Funci\xf3n que coteja str con el patron wildcard\\n\\n    static boolean strmatch(String str, String pattern,\\n            int n, int m) {\\n        // Patron vacio colo puede coincidir \\n        // con string vacio\\n        if (m == 0) {\\n            return (n == 0);\\n        }\\n        // Tabla de busqueda para almacenar resultados\\n        // de subproblem\xe1s\\n        boolean[][] lookup = new boolean[n + 1][m + 1];\\n        //Inicializa la tabla en falso\\n        for (int i = 0; i < n + 1; i++) {\\n            Arrays.fill(lookup[i], false);\\n        }\\n        lookup[0][0] = true;\\n        //Solo \'*\' puede coincidri con string vacio\\n        for (int j = 1; j <= m; j++) {\\n            if (pattern.charAt(j - 1) == \'*\') {\\n                lookup[0][j] = lookup[0][j - 1];\\n            }\\n        }\\n        // Llena la tabla \\n        for (int i = 1; i <= n; i++) {\\n            for (int j = 1; j <= m; j++) {\\n                /*Dos casos que podemos ver de \'*\'\\n                a) Ignoramos \'*\' y pasamos al siguiente\\n                caracter en el patr\xf3n\\n                b) \'*\' coincide con un iesimo\\n                caracter en una entrada*/\\n\\n                if (pattern.charAt(j - 1) == \'*\') {\\n                    lookup[i][j] = lookup[i][j - 1]\\n                            || lookup[i - 1][j];\\n                } /*Actuales caracteres son considerados \\n                como coincidentes en dos casos\\n                a) actual caracter de patron es \'?\'\\n                b) caracteres actuales coinciden*/ \\n                else if (pattern.charAt(j - 1) == \'?\'\\n                        || str.charAt(i - 1) == pattern.charAt(j - 1)) {\\n                    lookup[i][j] = lookup[i - 1][j - 1];\\n                } // Si el caracter no coincide\\n                else {\\n                    lookup[i][j] = false;\\n                }\\n            }\\n        }\\n        return lookup[n][m];\\n    }\\n\\n    public static void main(String args[]) {\\n        String str = \\"baaabab\\";\\n        String pattern = \\"*****ba*****ab\\";\\n        //Casos de prueba \\n        // String pattern = \\"ba*****ab\\";\\n        // String pattern = \\"ba*ab\\";\\n        // String pattern = \\"a*ab\\";\\n        // String pattern = \\"a*****ab\\";\\n        // String pattern = \\"*a*****ab\\";\\n        // String pattern = \\"ba*ab****\\";\\n        // String pattern = \\"****\\";\\n        // String pattern = \\"*\\";\\n        // String pattern = \\"aa?ab\\";\\n        // String pattern = \\"b*b\\";\\n        // String pattern = \\"a*a\\";\\n        // String pattern = \\"baaabab\\";\\n        // String pattern = \\"?baaabab\\";\\n        // String pattern = \\"*baaaba*\\"; \\n\\n        if (strmatch(str, pattern, str.length(),\\n                pattern.length())) {\\n            System.out.println(\\"Si\\");\\n        } else {\\n            System.out.println(\\"No\\");\\n        }\\n    }\\n}\\n","cpp":"using namespace std;\\n#include<bits/stdc++.h>\\n#include<cstdlib>\\n#define FAST ios_base::sync_with_stdio(false);cin.tie(NULL);cout.tie(0);\\n#define Afill(x,y) memset(x,y,sizeof x)\\nbool strMatch(string str,string pat,int n,int m){\\n    if(m==0){\\n        return n==0;\\n    }\\n    bool lookup[n+1][m+1];\\n    for(int i=0;i<n+1;i++){\\n        Afill(lookup[i],false);\\n    }\\n    lookup[0][0]=true;\\n    for(int j=1;j<=m;j++){\\n        if(pat[j-1]==\'*\'){\\n            lookup[0][j]=lookup[0][j-1];\\n        }\\n    }\\n    for(int i=1;i<=n;i++){\\n        for(int j=1;j<=m;j++){\\n            if(pat[j-1]==\'*\'){\\n                lookup[i][j]=lookup[i][j-1]||lookup[i-1][j];\\n            }else if(pat[j-1]==\'?\' || str[i-1]==pat[j-1]){\\n                lookup[i][j]=lookup[i-1][j-1];\\n            }else{\\n                lookup[i][j]=false;\\n            }\\n        }\\n    }\\n    return lookup[n][m];\\n}\\nint main() {\\n    FAST\\n    string str=\\"baaaaababa\\";\\n    string pat=\\"ba*******?\\";\\n    if(strMatch(str,pat,str.size(),pat.size())){\\n        cout<<\\"Si\\"<<endl;\\n    }else{\\n        cout<<\\"No\\"<<endl;\\n    }\\n}\\n","py":"from sys import stdin, stdout\\nrl = stdin.readline\\nwr = stdout.write\\n\\n\\ndef wildCardStrMatch(strn, pat, n, m):\\n\\n    if m == 0:\\n        return n == 0\\n\\n    lookup = [[False for x in range(m+1)] for x in range(n+1)]\\n    lookup[0][0] = True\\n\\n    for i in range(1, m+1):\\n        if pat[i-1] == \'*\':\\n            lookup[0][i] = lookup[0][i-1]\\n\\n    for i in range(1, n+1):\\n        for j in range(1, m+1):\\n            if pat[j-1] == \'*\':\\n                lookup[i][j] = lookup[i][j-1] or lookup[i-1][j]\\n            elif pat[j-1] == \'?\' or strn[i-1] == pat[j-1]:\\n                lookup[i][j] = lookup[i-1][j-1]\\n            else:\\n                lookup[i][j] = False\\n\\n    return lookup[n][m]\\n\\n\\ntxt = \'anitalavalatina\'\\npat = \'?nit?lava*\'\\n\\nif wildCardStrMatch(txt, pat, len(txt), len(pat)):\\n    wr(\'Iguales\\\\n\')\\nelse:\\n    wr(\'Diferentes\\\\n\')\\n","orden":5,"suborden":2,"fecha_creacion":"2020-12-04 20:09:36","fecha_modificacion":"2020-12-07 02:19:43"},{"ID":30,"supergrupo":"Strings","tema":"Algoritmo de Manacher","texto":"<div style=\\"text-align: justify;\\"><span style=\\"font-size: 10pt;\\">Dado un string, encuentre el substring m\xe1s largo que sea pal\xedndromo.&nbsp;</span></div><div style=\\"text-align: justify;\\">Si el string dado es \u201cabaaba\u201d la salida deber\xe1 ser \u201cabaaba\u201d&nbsp;</div><div style=\\"text-align: justify;\\"><br></div><div style=\\"text-align: justify;\\">Vamos a considerar el string \u201cabababa\u201d.\\r\\nAqu\xed el centro del string es el 4to car\xe1cter con \xedndice 3, si cotejamos m\xe1s caracteres en la izquierda y derecha del centro todos los caracteres coinciden y el string es pal\xedndromo.\\r\\nConsidere el string \u201cabaaba\u201d de tama\xf1o par. Este string es pal\xedndromo alrededor de la posici\xf3n entre el 3er y 4to car\xe1cter.&nbsp;</div><div style=\\"text-align: justify;\\"><br></div><div style=\\"text-align: justify;\\">Para encontrar el substring m\xe1s largo pal\xedndromo de un string de tama\xf1o N, una v\xeda es tomar cada posible 2*N+1 centros (las N posiciones de caracteres, N-1 entre dos caracteres y dos posiciones en los fines de derecha e izquierda), haga que el car\xe1cter coincida en ambas direcciones en cada 2*N+1 centros y siga rastreando por LPS (Longest palindromic string).&nbsp;</div><div style=\\"text-align: justify;\\"><br></div><div style=\\"text-align: justify;\\">Si el string dado es \u201cabababa\u201d la salida debe ser \u201cabababa\u201d&nbsp;</div><div style=\\"text-align: justify;\\"><span style=\\"font-size: 10pt;\\"><br></span></div><div style=\\"text-align: justify;\\"><span style=\\"font-size: 10pt;\\">Si el string dado es \u201cabcbabcbabcba\u201d la salida debe ser \u201cabcbabcba\u201d</span></div>","complejidad_tiempo":"Mejor caso :    O(n)            Peor caso :     O(n)             Promedio: O(n)","java":"// Programa java implementando el algoritmo de Manacher\\n// LPS: longest palindrome string\\n\\npublic class ManacherAlgorithm {\\n\\n    static char text[];\\n\\n    public static void main(String[] args) {\\n        text = \\"babcbabcbaccba\\".toCharArray();\\n        findLongestPalindromicString();\\n        text = \\"abaaba\\".toCharArray();\\n        findLongestPalindromicString();\\n        text = \\"abababa\\".toCharArray();\\n        findLongestPalindromicString();\\n        text = \\"abcbabcbabcba\\".toCharArray();\\n        findLongestPalindromicString();\\n        text = \\"caba\\".toCharArray();\\n        findLongestPalindromicString();\\n        text = \\"abacdfgdcaba\\".toCharArray();\\n        findLongestPalindromicString();\\n        text = \\"abacdfgdcabba\\".toCharArray();\\n        findLongestPalindromicString();\\n        text = \\"abacdedcaba\\".toCharArray();\\n        findLongestPalindromicString();\\n    }\\n\\n    static int min(int a, int b) {\\n        int res = a;\\n        if (b < a) {\\n            res = b;\\n        }\\n        return res;\\n    }\\n\\n    static void findLongestPalindromicString() {\\n        int N = text.length;\\n        if (N == 0) {\\n            return;\\n        }\\n        N = 2 * N + 1; //Conteo de posici\xf3n\\n        int L[] = new int[N]; //LPS tama\xf1o de array\\n        L[0] = 0;\\n        L[1] = 1;\\n        int C = 1; //Posici\xf3n central\\n        int R = 2; //posici\xf3n Centro derecho\\n        int i = 0; //Posici\xf3n actual derecho\\n        int iMirror; //Posici\xf3n actual izquierda\\n        int maxLPSLength = 0;\\n        int maxLPSCenterPosition = 0;\\n        int start = -1;\\n        int end = -1;\\n        int diff = -1;\\n        //Descomentar para imprimir tama\xf1o del arreglo LPS\\n        //printf(\\"%d %d \\", L[0], L[1]); \\n        for (i = 2; i < N; i++) {\\n            iMirror = 2 * C - i;\\n            L[i] = 0;\\n            diff = R - i;\\n            if (diff > 0) {\\n                L[i] = min(L[iMirror], diff);\\n            }\\n            /*Intente expandir pal\xedndromo centrado en currentRightPosition i\\n            Aqu\xed para posiciones impares, comparamos caracteres y\\n            si coinciden, aumente la longitud de LPS en UNO\\n            Si la posici\xf3n es igual, solo incrementamos LPS en UNO sin*/\\n            try {\\n                while (((i + L[i]) < N && (i - L[i]) > 0)\\n                        && (((i + L[i] + 1) % 2 == 0)\\n                        || (text[(i + L[i] + 1) / 2] == text[(i - L[i] - 1) / 2]))) {\\n                    L[i]++;\\n                }\\n            } catch (Exception e) {\\n            }\\n            //Comparaci\xf3n de cualquier caracter\\n            if (L[i] > maxLPSLength) {\\n                maxLPSLength = L[i];\\n                maxLPSCenterPosition = i;\\n            }\\n            if (i + L[i] > R) {\\n                C = i;\\n                R = i + L[i];\\n            }\\n            //Descomentar para imprimir tama\xf1o del arreglo LPS\\n            //printf(\\"%d \\", L[i]); \\n        }\\n        start = (maxLPSCenterPosition - maxLPSLength) / 2;\\n        end = start + maxLPSLength - 1;\\n        System.out.println(\\"LPS del string es \\" + String.copyValueOf(text) + \\": \\");\\n        for (i = start; i <= end; i++) {\\n            System.out.printf(\\"%c\\", text[i]);\\n        }\\n        System.out.println(\\"\\");\\n    }\\n}\\n","cpp":"using namespace std;\\n#include<bits/stdc++.h>\\n#include<cstdlib>\\n#define FAST ios_base::sync_with_stdio(false);cin.tie(NULL);\\n#define string_valueof(x) puts(x);\\n\\nvoid findLPS(char text[], int N) {\\n    if (N == 0) {\\n        return;\\n    } \\n    N = 2 * N + 1;\\n    int L[N];\\n    L[0] = 0;\\n    L[1] = 1;\\n    int C = 1;\\n    int R = 2;\\n    int i_mirror;\\n    int max_LPS_len = 0;\\n    int max_LPS_centerPos = 0;\\n    int start = -1, endLPS = -1, diff = -1;\\n    for (int i = 2; i < N; i++) {\\n        i_mirror = 2 * C - i;\\n        L[i] = 0;\\n        diff = R - i;\\n        if (diff > 0) {\\n            L[i] = std::min(L[i_mirror], diff);\\n        }\\n        try {\\n            while (((i + L[i]) < N and (i - L[i]) > 0) and (((i + L[i] + 1) % 2 == 0) || text[(i + L[i] + 1) / 2] == text[(i - L[i] - 1) / 2])) {\\n                L[i]++;\\n            }\\n        } catch (exception& e) {\\n        }\\n        if (L[i] > max_LPS_len) {\\n            max_LPS_len = L[i];\\n            max_LPS_centerPos = i;\\n        }\\n        if (i + L[i] > R) {\\n            C = i;\\n            R = i + L[i];\\n        }\\n    }\\n    start = (max_LPS_centerPos - max_LPS_len) / 2;\\n    endLPS = start + max_LPS_len - 1;\\n    cout << \\"LPS del string es \\";\\n    string_valueof(text);\\n    cout << \\" : \\";\\n    for (int j = start; j <= endLPS; j++) {\\n        cout << text[j];\\n    }\\n    cout << endl;\\n    /*\\n    cout<<\\"inicio : \\"<<start<<\\"    -    final : \\"<<endLPS<<endl;\\n    for(int j=0;j<N;j++){\\n        cout<<L[j]<<\\" \\";\\n    }\\n     */\\n}\\n\\nint main() {\\n    FAST;\\n    char text[1000];\\n    gets(text);\\n    int N = strlen(text);\\n    findLPS(text, N);\\n}\\n","py":"from sys import stdin, stdout\\nrl = stdin.readline\\nwr = stdout.write\\n\\n\\ndef findLPS():\\n\\n    N = len(text)\\n    if N == 0:\\n        return\\n\\n    N = 2 * N + 1\\n    L = [0] * N\\n    L[0] = 0\\n    L[1] = 1\\n    C, R = 1, 2\\n    iMirror = maxLPSlen = maxLPScenterPos = 0\\n    start = end = diff = -1\\n\\n    for i in range(2, N):\\n        iMirror = 2 * C - i\\n        L[i] = 0\\n        diff = R - i\\n        if diff > 0:\\n            L[i] = min(L[iMirror], diff)\\n        try:\\n            while ((i + L[i]) < N and (i - L[i]) > 0) and (((i + L[i] + 1) % 2 == 0) or (text[(i + L[i] + 1) // 2] == text[(i - L[i] - 1) // 2])):\\n                L[i] += 1\\n        except:\\n            pass\\n\\n        if L[i] > maxLPSlen:\\n            maxLPSlen = L[i]\\n            maxLPScenterPos = i\\n\\n        if i + L[i] > R:\\n            C = i\\n            R = i + L[i]\\n\\n    start = (maxLPScenterPos - maxLPSlen) // 2\\n    end = start + maxLPSlen - 1\\n\\n    wr(f\'LPS del string {\\"\\".join(text)}:\\\\n\')\\n    for i in range(start, end+1):\\n        wr(f\'{text[i]}\')\\n    wr(\'\\\\n\')\\n\\n\\ntext = [x for x in \'OABAABAOBO\']\\nfindLPS()\\n","orden":5,"suborden":3,"fecha_creacion":"2020-12-04 20:09:36","fecha_modificacion":"2020-12-07 02:20:21"},{"ID":31,"supergrupo":"Strings","tema":"Algoritmo de Aho-Corasick ","texto":"<div style=\\"font-size: 13.3333px; text-align: justify;\\"><span style=\\"font-size: 10pt;\\">Dada una entrada de texto y un array de k palabras, arr[], encontrar todas las ocurrencias de todas las palabras en el texto de entrada.&nbsp;</span></div><div style=\\"font-size: 13.3333px; text-align: justify;\\"><span style=\\"font-size: 10pt;\\"><br></span></div><div style=\\"font-size: 13.3333px; text-align: justify;\\"><span style=\\"font-size: 10pt;\\">Sea n la longitud del texto y m sea el n\xfamero total de caracteres en todas las palabras, por ejemplo: m = length (arr [0]) + length (arr [1]) +\u2026 + length (arr [k-1]).&nbsp;</span></div><div style=\\"font-size: 13.3333px; text-align: justify;\\"><span style=\\"font-size: 10pt;\\"><br></span></div><div style=\\"font-size: 13.3333px; text-align: justify;\\"><span style=\\"font-size: 10pt;\\">Si usamos un algoritmo de tiempo linear como KMP, entonces necesitaremos una b\xfasqueda uno por uno de todas las palabras en text[]. Esto nos da un total de complejidad de tiempo de O(n + length(word[0]) + O(n + length(word[1]) + O(n + length(word[2]) + \u2026 O(n + length(word[k-1]). Esta complejidad de tiempo puede ser escrita como O(n*k + m). Aho-corasick encuentra todas las palabras en tiempo O(n+m+z) donde z es el n\xfamero total de ocurrencias de las palabras en el texto, este algoritmo forma las bases del comando original de Unix fgrep.&nbsp;</span></div><div style=\\"font-size: 13.3333px; text-align: justify;\\"><span style=\\"font-size: 10pt;\\"><br></span></div><div style=\\"font-size: 13.3333px; text-align: justify;\\"><span style=\\"font-size: 10pt; font-weight: bold;\\">Este algoritmo tiene dos pasos principales:&nbsp;</span></div><div style=\\"font-size: 13.3333px; text-align: justify;\\"><span style=\\"font-size: 10pt;\\"><span style=\\"white-space: pre;\\">\\t</span>- Preprocesado: Construye un automaton de todas las palabras en arr[].&nbsp;</span></div><div style=\\"font-size: 13.3333px; text-align: justify;\\"><span style=\\"font-size: 10pt;\\"><span style=\\"white-space: pre;\\">\\t</span>- Cotejamiento: Atraviesa el texto dado sobre el automaton formado para encontrar las palabras a cotejar.&nbsp;</span></div><div style=\\"font-size: 13.3333px; text-align: justify;\\"><span style=\\"font-size: 10pt;\\"><br></span></div><div style=\\"font-size: 13.3333px; text-align: justify;\\"><span style=\\"font-size: 10pt;\\">Por un estado s, los \xedndices de todas las palabras terminados en s son almacenadas. Estos \xedndices son almacenados en un map de BitWise (Haciendo OR a lo valores. Esto tambi\xe9n computa usando b\xfasqueda primera en anchura con fallo. Construimos un aut\xf3mata para este conjunto de cadenas. Ahora procesaremos el texto letra por letra, haciendo la transici\xf3n durante los diferentes estados. Inicialmente estamos en la ra\xedz del trie. Si estamos en cualquier momento en el estado v, y la siguiente letra es c, entonces hacemos la transici\xf3n al siguiente estado con go (v, c), aumentando as\xed la longitud de la subcadena de coincidencia actual en 1, o disminuy\xe9ndola siguiendo Un enlace de sufijo.</span></div><div style=\\"font-size: 13.3333px; text-align: justify;\\"><span style=\\"font-size: 10pt; font-weight: bold;\\"><br></span></div><div style=\\"font-size: 13.3333px; text-align: justify;\\"><span style=\\"font-size: 10pt; font-weight: bold;\\">\xbfC\xf3mo podemos encontrar un estado v, si hay coincidencias con cadenas para el conjunto?&nbsp;</span></div><div style=\\"font-size: 13.3333px; text-align: justify;\\"><span style=\\"font-size: 10pt;\\"><br></span></div><div style=\\"font-size: 13.3333px; text-align: justify;\\"><span style=\\"font-size: 10pt;\\">Primero, est\xe1 claro que si nos paramos en un v\xe9rtice de la hoja, entonces la cadena correspondiente al v\xe9rtice termina en esta posici\xf3n en el texto. Sin embargo, este no es el \xfanico caso posible de lograr una coincidencia: si podemos alcanzar uno o m\xe1s v\xe9rtices de hojas movi\xe9ndonos a lo largo de los enlaces de sufijo, entonces tambi\xe9n habr\xe1 una coincidencia correspondiente a cada v\xe9rtice de hoja encontrado.&nbsp;</span></div><div style=\\"font-size: 13.3333px; text-align: justify;\\"><span style=\\"font-size: 10pt;\\"><br></span></div><div style=\\"font-size: 13.3333px; text-align: justify;\\"><span style=\\"font-size: 10pt;\\">Un ejemplo simple que demuestra esta situaci\xf3n puede ser crear usando el conjunto de cadenas {dabce, abc, bc} y el texto dabc. Por lo tanto, si almacenamos en cada v\xe9rtice de la hoja el \xedndice de la cadena correspondiente (o la lista de \xedndices si aparecen cadenas duplicadas en el conjunto), entonces podemos encontrar en O (n) tiempo los \xedndices de todas las cadenas que coinciden con la actual estado, simplemente siguiendo los enlaces de sufijo desde el v\xe9rtice actual hasta la ra\xedz. Sin embargo, esta no es la soluci\xf3n m\xe1s eficiente, ya que nos da una complejidad O (n len) en total. Sin embargo, esto se puede optimizar calculando y almacenando el v\xe9rtice de la hoja m\xe1s cercano al que se puede acceder mediante enlaces de sufijo (esto a veces se denomina enlace de salida). Este valor lo podemos calcular perezosamente en tiempo lineal. Por lo tanto, para cada v\xe9rtice podemos avanzar en tiempo O (1) al siguiente v\xe9rtice marcado en la ruta de enlace del sufijo, es decir, a la siguiente coincidencia. Por lo tanto, para cada partido pasamos O (1) tiempo, y por lo tanto alcanzamos la complejidad O (len + ans). Si solo desea contar las ocurrencias y no encontrar los \xedndices, puede calcular el n\xfamero de v\xe9rtices marcados en la ruta de enlace del sufijo para cada v\xe9rtice v.&nbsp;</span></div><div style=\\"font-size: 13.3333px; text-align: justify;\\"><span style=\\"font-size: 10pt;\\"><br></span></div><div style=\\"font-size: 13.3333px; text-align: justify;\\"><span style=\\"font-size: 10pt;\\"><br></span></div><div style=\\"font-size: 13.3333px; text-align: justify;\\"><span style=\\"font-size: 10pt;\\">Esto se puede calcular en O (n) en total. Por lo tanto, podemos resumir todas las coincidencias en O (len).&nbsp;</span></div><div style=\\"font-size: 13.3333px; text-align: justify;\\"><span style=\\"font-size: 10pt;\\"><br></span></div><div style=\\"font-size: 13.3333px; text-align: justify;\\"><span style=\\"font-size: 10pt; font-weight: bold;\\">Utilidades de este algoritmo:&nbsp;</span></div><div style=\\"font-size: 13.3333px; text-align: justify;\\"><span style=\\"font-size: 10pt;\\">1) Encontrar la cadena lexicogr\xe1fica m\xe1s peque\xf1a de una longitud dada que no coincide con ninguna cadena dada Se da un conjunto de cuerdas y una longitud L. Tenemos que encontrar una cadena de longitud L, que no contiene ninguna de las cadenas, y derivar la cadena lexicogr\xe1fica m\xe1s peque\xf1a de tales cadenas. Podemos construir el aut\xf3mata para el conjunto de cadenas. Recordemos que los v\xe9rtices desde los cuales podemos alcanzar el v\xe9rtice de una hoja son los estados, en los cuales tenemos una coincidencia con una cadena del conjunto. Como en esta tarea debemos evitar las coincidencias, no se nos permite ingresar a dichos estados. Por otro lado, podemos ingresar todos los dem\xe1s v\xe9rtices. Por lo tanto, eliminamos todos los v\xe9rtices \\"malos\\" de la m\xe1quina, y en el gr\xe1fico restante del aut\xf3mata encontramos la ruta lexicogr\xe1fica m\xe1s peque\xf1a de longitud L. Esta tarea se puede resolver en O (L), por ejemplo, mediante la b\xfasqueda en profundidad. &nbsp;</span></div><div style=\\"font-size: 13.3333px; text-align: justify;\\"><span style=\\"font-size: 10pt;\\"><br></span></div><div style=\\"font-size: 13.3333px; text-align: justify;\\"><span style=\\"font-size: 10pt;\\">2) Encontrar la cadena m\xe1s corta que contiene todas las cadenas dadas Aqu\xed usamos las mismas ideas. Para cada v\xe9rtice almacenamos una m\xe1scara que denota las cadenas que coinciden en este estado. Entonces el problema puede reformularse de la siguiente manera: inicialmente estando en el estado (v = ra\xedz, m\xe1scara = 0), queremos llegar al estado (v, m\xe1scara = 2n - 1), donde n es el n\xfamero de cadenas en el conjunto . Cuando hacemos la transici\xf3n de un estado a otro usando una letra, actualizamos la m\xe1scara en consecuencia. Al ejecutar una b\xfasqueda de respiraci\xf3n primero podemos encontrar una ruta al estado (v, m\xe1scara = 2n - 1) con la longitud m\xe1s peque\xf1a. 3) Encontrar la cadena lexicogr\xe1fica m\xe1s peque\xf1a de longitud L que contiene k cadenas Como en el problema anterior, calculamos para cada v\xe9rtice el n\xfamero de coincidencias que le corresponden (es decir, el n\xfamero de v\xe9rtices marcados a los que se puede acceder mediante enlaces de sufijo). Reformulamos el problema: el estado actual est\xe1 determinado por un triple de n\xfameros (v, len, cnt), y queremos llegar desde el estado (ra\xedz, 0, 0) al estado (v, L, k), donde v puede ser cualquier v\xe9rtice Por lo tanto, podemos encontrar dicha ruta utilizando la b\xfasqueda en profundidad primero (y si la b\xfasqueda mira los bordes en su orden natural, entonces la ruta encontrada ser\xe1 autom\xe1ticamente la m\xe1s peque\xf1a lexicogr\xe1fica).</span></div>","complejidad_tiempo":"Mejor caso :    O(n + m + ocurrencias) Peor caso : O(n + m + ocurrencias)   \\n Promedio: O(n + m + ocurrencias)         \\n","java":"import java.util.Arrays;\\nimport java.util.LinkedList;\\nimport java.util.Queue;\\n\\n//Programa JAVA implementando Aho Corasick\\n//para matching de strings\\npublic class Main {\\n\\n    //Maximo numero de estados en la maquina de cotejamiento\\n    //debe ser igual a la suma del tama\xf1o de todas las palablas clave\\n    static final int MAXS = 500;\\n    //numero maximo de caracteres en el alfabeto de entrada\\n    static final int MAXC = 26;\\n    //La funcion Output esta implementada usando out[]\\n    // bit i de esta mascara es uno si la palabra en el \\n    // indice i aparece cuando la maquina entra en este estado\\n    static int out[] = new int[MAXS];\\n    //funci\xf3n de fallo \\n    static int f[] = new int[MAXS];\\n    //implementaci\xf3n de las tries\\n    static int g[][] = new int[MAXS][MAXC];\\n\\n    // Construye la maquina de cotejado\\n    /* \\"out[state] & (1 << i)\\" es > 0 si encontramos la\\n    palabra de word[i] en el texto\\n    arr-> vector de palabras, el incide de cada palabla clave\\n    es importante */\\n    // retorna el numero de estados que la maquina tiene construidos\\n    // los estados estan numerados desde 0 hasta el valor de retorno - 1\\n    static int buildMatchingMachine(String arr[], int k) {\\n        //Inicializar todos los valores de out en 0. \\n        Arrays.fill(out, 0);\\n        // Inicializar todos los valores de g en -1.\\n        for (int i = 0; i < MAXS; i++) {\\n            Arrays.fill(g[i], -1);\\n        }\\n        // Inicialmente tenemos 0 estados \\n        int states = 1;\\n        //Esto es lo mismo que construir un Trie para arr[] \\n        for (int i = 0; i < k; ++i) {\\n            String word = arr[i];\\n            int currentState = 0;\\n            // Insertar todos los caracteres de la palabra actual\\n            // en arr[]\\n            for (int j = 0; j < word.length(); ++j) {\\n                int ch = word.charAt(j) - \'a\';\\n                // crea un nuevo nodo (estado) si un nodo\\n                // para ch no existe\\n                if (g[currentState][ch] == -1) {\\n                    g[currentState][ch] = states++;\\n                }\\n                currentState = g[currentState][ch];\\n            }\\n            // agrega la palabra actual a la funci\xf3n de salida\\n            out[currentState] |= (1 << i);\\n        }\\n        // para todos los caracteres que no tengan un camino desde\\n        // la raiz (El estado 0) en el trie, agregar un camino\\n        // hacia el estado 0 mismo\\n        for (int ch = 0; ch < MAXC; ++ch) {\\n            if (g[0][ch] == -1) {\\n                g[0][ch] = 0;\\n            }\\n        }\\n        //Inicializamos los valores en la funcion de fallo\\n        Arrays.fill(f, -1);\\n        // Se usa BFS y una cola para calcular los fallos\\n        Queue<Integer> q = new LinkedList<>();\\n        // Se itera por lo que se encuentre\\n        for (int ch = 0; ch < MAXC; ++ch) {\\n            // Todos los nodos de profundidad 1 tienen una funcion de fallo\\n            // como 0.\\n            if (g[0][ch] != 0) {\\n                f[g[0][ch]] = 0;\\n                q.offer((g[0][ch]));\\n            }\\n        }\\n        while (!q.isEmpty()) {\\n            // Tomamos el nodo o estado del frente de la cola\\n            int state = q.poll();\\n            // Se busca la funcion de fallo de todos los caracteres del estado\\n            // removido para cuales funcion g no esta definido\\n            for (int ch = 0; ch < MAXC; ++ch) {\\n                if (g[state][ch] != -1) {\\n                    //Encontrar el valor de la funcion de fallo\\n                    int failure = f[state];\\n                    // encuentra el nodo mas profundo con el sufijo\\n                    // apropiado del string desde el nodo raiz al estado actual\\n                    while (g[failure][ch] == -1) {\\n                        failure = f[failure];\\n                    }\\n                    failure = g[failure][ch];\\n                    f[g[state][ch]] = failure;\\n                    //Junta los valores de salida\\n                    out[g[state][ch]] |= out[failure];\\n                    //Inserta el nodo del siguiente nivel del trie\\n                    q.offer(g[state][ch]);\\n                }\\n            }\\n        }\\n\\n        return states;\\n    }\\n    // currentState - El estado actual de la maquina \\n    //                 entre 0 y el total de estados -1  \\n    // nextInput - El siguiente caracter que entra en la maquina. \\n\\n    static int findNextState(int currentState, char nextInput) {\\n        int answer = currentState;\\n        int ch = nextInput - \'a\';\\n        // Si g no esta definido, use la funcion de fallo \\n        while (g[answer][ch] == -1) {\\n            answer = f[answer];\\n        }\\n        return g[answer][ch];\\n    }\\n\\n    //Funci\xf3n que busca las ocurrencias en el texto\\n    static void searchWords(String arr[], int k, String text) {\\n        // Preprocesar patrones\\n        // Construir los tries como una maquina de estado finito\\n        buildMatchingMachine(arr, k);\\n        // Inicializar los estados\\n        int currentState = 0;\\n        //Atravesamos el texto buscando las ocurrencias\\n        for (int i = 0; i < text.length(); ++i) {\\n            currentState = findNextState(currentState, text.charAt(i));\\n            // Si no se encuentra cotejado, pasa al siguiente estado\\n            if (out[currentState] == 0) {\\n                continue;\\n            }\\n            // cotejado encontrado, imprimir todas las palabras de \\n            // arr[] que se encontraron \\n            for (int j = 0; j < k; ++j) {\\n                int aux = (out[currentState] & (1 << j));\\n                if (aux > 0) {\\n                    System.out.println(\\"La palabra \\" + arr[j] + \\" aparece de \\"\\n                            + (i - arr[j].length() + 1) + \\" a \\" + i);\\n                }\\n            }\\n        }\\n    }\\n\\n    public static void main(String[] args) {\\n        String arr[] = {\\"he\\", \\"she\\", \\"hers\\", \\"his\\"};\\n        String text = \\"ahishers\\";\\n        int k = arr.length;\\n        searchWords(arr, k, text);\\n    }\\n}\\n","cpp":"using namespace std;\\n#include <bits/stdc++.h> \\n\\nconst int MAXS = 500;\\nconst int MAXC = 26;\\nint out[MAXS];\\nint f[MAXS];\\nint g[MAXS][MAXC];\\n\\nint buildMatchingMachine(string arr[], int k) {\\n    memset(out, 0, sizeof out);\\n    memset(g, -1, sizeof g);\\n    int states = 1;\\n    for (int i = 0; i < k; ++i) {\\n        const string &word = arr[i];\\n        int currentState = 0;\\n        for (int j = 0; j < word.size(); ++j) {\\n            int ch = word[j] - \'a\';\\n            if (g[currentState][ch] == -1)\\n                g[currentState][ch] = states++;\\n            currentState = g[currentState][ch];\\n        }\\n        out[currentState] |= (1 << i);\\n    }\\n    for (int ch = 0; ch < MAXC; ++ch)\\n        if (g[0][ch] == -1)\\n            g[0][ch] = 0;\\n    memset(f, -1, sizeof f);\\n    queue<int> q;\\n    for (int ch = 0; ch < MAXC; ++ch) {\\n        if (g[0][ch] != 0) {\\n            f[g[0][ch]] = 0;\\n            q.push(g[0][ch]);\\n        }\\n    }\\n\\n    while (q.size()) {\\n        int state = q.front();\\n        q.pop();\\n        for (int ch = 0; ch <= MAXC; ++ch) {\\n            if (g[state][ch] != -1) {\\n                int failure = f[state];\\n                while (g[failure][ch] == -1)\\n                    failure = f[failure];\\n                failure = g[failure][ch];\\n                f[g[state][ch]] = failure;\\n                out[g[state][ch]] |= out[failure];\\n                q.push(g[state][ch]);\\n            }\\n        }\\n    }\\n    return states;\\n}\\n\\nint findNextState(int currentState, char nextInput) {\\n    int answer = currentState;\\n    int ch = nextInput - \'a\';\\n    while (g[answer][ch] == -1)\\n        answer = f[answer];\\n    return g[answer][ch];\\n}\\n\\nvoid searchWords(string arr[], int k, string text) {\\n    buildMatchingMachine(arr, k);\\n    int currentState = 0;\\n    for (int i = 0; i < text.size(); ++i) {\\n        currentState = findNextState(currentState, text[i]);\\n        if (out[currentState] == 0)\\n            continue;\\n        for (int j = 0; j < k; ++j) {\\n            int aux = out[currentState] & (1 << j);\\n            if (aux) {\\n                cout << \\"Word \\" << arr[j] << \\" appears from \\"\\n                        << i - arr[j].size() + 1 << \\" to \\" << i << endl;\\n            }\\n        }\\n    }\\n}\\n\\nint main() {\\n    string arr[] = {\\"he\\", \\"she\\", \\"hers\\", \\"his\\"};\\n    string text = \\"ahishers\\";\\n    int k = sizeof (arr) / sizeof (arr[0]);\\n\\n    searchWords(arr, k, text);\\n\\n    return 0;\\n} \\n","py":"from collections import deque\\nMAXS = 500\\nMAXC = 26\\nout = []\\nf = []\\ng = []\\n\\ndef buildMatchingMachine(arr, k):\\n    global MAXS\\n    global MAXC\\n    global out\\n    global g\\n    global f\\n    out = [0 for x in range(MAXS)]\\n    g = [[-1 for y in range(MAXC)] for x in range(MAXS)]\\n    states = 1\\n    for i in range(k):\\n        word = arr[i]\\n        currentState = 0\\n        for j in range(len(word)):\\n            ch = ord(word[j]) - ord(\'a\')\\n            if g[currentState][ch] == -1:\\n                states = states + 1\\n                g[currentState][ch] = states\\n            currentState = g[currentState][ch]\\n        out[currentState] |= (1 << i)\\n    for ch in range(MAXC):\\n        if g[0][ch] == -1:\\n            g[0][ch] = 0\\n    f = [-1 for x in range(MAXS)]\\n    q = deque()\\n    for ch in range(MAXC):\\n        if g[0][ch] != 0:\\n            f[g[0][ch]] = 0\\n            q.append((g[0][ch]))\\n    while not len(q) == 0:\\n        state = q.pop()\\n        for ch in range(MAXC):\\n            if g[state][ch] != -1:\\n                failure = f[state]\\n                while g[failure][ch] == -1:\\n                    failure = f[failure]\\n                failure = g[failure][ch]\\n                f[g[state][ch]] = failure\\n                out[g[state][ch]] |= out[failure]\\n                q.append(g[state][ch])\\n    return states\\n\\ndef findNextState(currentState, nextInput):\\n    global MAXS\\n    global MAXC\\n    global out\\n    global g\\n    global f\\n    answer = currentState\\n    ch = int(ord(nextInput) - ord(\'a\'))\\n    while g[answer][ch] == -1:\\n        answer = f[answer]\\n    return g[answer][ch]\\n\\ndef searchWords(arr, k, text):\\n    global MAXS\\n    global MAXC\\n    global out\\n    global g\\n    global f\\n    buildMatchingMachine(arr, k)\\n    currentState = 0\\n    for i in range(len(text)):\\n        currentState = findNextState(currentState, text[i])\\n        if out[currentState] == 0:\\n            continue\\n        for j in range(k):\\n            aux = (out[currentState] & (1 << j))\\n            if aux > 0:\\n                print(\\"la palabra \\", arr[j], \\" aparece de \\", ((i - len(arr[j])) + 1), \\" a \\", i)\\n\\n\\narr = [\\"he\\", \\"she\\", \\"hers\\", \\"his\\"]\\ntext = \\"ahishers\\"\\nk = len(arr)\\nsearchWords(arr, k, text)\\n","orden":5,"suborden":4,"fecha_creacion":"2020-12-04 20:09:36","fecha_modificacion":"2020-12-07 02:36:10"},{"ID":32,"supergrupo":"Strings","tema":"Finite Automata","texto":"<div style=\\"text-align: justify;\\"><span style=\\"font-size: 10pt;\\">Dado un texto txt[0...n-1] y un patr\xf3n pat[0...m-1], busque todas las ocurrencias de pat en txt e impr\xedmalas, asuma que n es mayor que m.&nbsp;</span></div><div style=\\"text-align: justify;\\"><span style=\\"font-size: 10pt;\\"><br></span></div><div style=\\"text-align: justify;\\"><span style=\\"font-size: 10pt;\\">En el algoritmo basado en Finite aut\xf3mata, nosotros preprocesamos el patr\xf3n y construimos un array de dos dimensiones que represente un aut\xf3mata finito. Construcci\xf3n del FA es la parte complicada de este algoritmo. Una vez el FA este construido, la b\xfasqueda es simple, En la b\xfasqueda nosotros simplemente necesitamos iniciar desde el primer estado del aut\xf3mata y el primer car\xe1cter del texto. En cada paso, consideramos el siguiente car\xe1cter del texto, miramos por el siguiente estado en el FA construido y nos movemos a un nuevo estado. Si alcanzamos el estado final, entonces el patr\xf3n fue encontrado en el texto.</span></div>","complejidad_tiempo":"Mejor caso :    O(n)        Peor caso : O(n)       Promedio: O(n)         ","java":"// Programa java para el algoritmo\\n// Finite Automata de busqueda de patrones\\n\\npublic class FiniteAutomata {\\n\\n    static int NO_OF_CHARS = 256;\\n\\n    static int getNextState(char[] pat, int M,\\n            int state, int x) {\\n        // Si el caracter c es el mismo como el \\n        // siguiente en patr\xf3n, simplemente incrementa\\n        // state\\n        if (state < M && x == pat[state]) {\\n            return state + 1;\\n        }\\n        // ns almacena el resultado el cual es \\n        // el siguiente state\\n        int ns, i;\\n        /* ns finalmente contiene el prefijo m\xe1s largo\\n        el cual tambien es sufijo en \\"pat[0..state-1]c\\"\\n        Empieza desde el valor m\xe1s largo posible \\n        y se detiene cuando se encuentra un prefijo el cual\\n        es tambien sufijo*/\\n        for (ns = state; ns > 0; ns--) {\\n            if (pat[ns - 1] == x) {\\n                for (i = 0; i < ns - 1; i++) {\\n                    if (pat[i] != pat[state - ns + 1 + i]) {\\n                        break;\\n                    }\\n                }\\n                if (i == ns - 1) {\\n                    return ns;\\n                }\\n            }\\n        }\\n        return 0;\\n    }\\n\\n    /*Esta funci\xf3n construye la tabla TF la cual\\n    representa Finite Automata del patr\xf3n dado*/\\n    static void computeTF(char[] pat, int M, int TF[][]) {\\n        int state, x;\\n        for (state = 0; state <= M; ++state) {\\n            for (x = 0; x < NO_OF_CHARS; ++x) {\\n                TF[state][x] = getNextState(pat, M, state, x);\\n            }\\n        }\\n    }\\n\\n    /* Imprime todas las ocurrencuas de pat en txt*/\\n    static void search(char[] pat, char[] txt) {\\n        int M = pat.length;\\n        int N = txt.length;\\n        int[][] TF = new int[M + 1][NO_OF_CHARS];\\n        computeTF(pat, M, TF);\\n        // Procesa txt sobre FA.\\n        int i, state = 0;\\n        for (i = 0; i < N; i++) {\\n            state = TF[state][txt[i]];\\n            if (state == M) {\\n                System.out.println(\\"Patr\xf3n encontrado \\"\\n                        + \\"en indice \\" + (i - M + 1));\\n            }\\n        }\\n    }\\n\\n    public static void main(String[] args) {\\n        char[] txt = \\"AABAACAADAABAAABAA\\".toCharArray();\\n        char[] pat = \\"AABA\\".toCharArray();\\n        search(pat, txt);\\n    }\\n}\\n","cpp":"#include <cstdlib>\\n#include <bits/stdc++.h>\\nusing namespace std;\\n#define NO_OF_CHARS 256\\n\\nint getNextState(char pat[], int M, int state, int x) {\\n    if (state < M && x == pat[state]) {\\n        return state + 1;\\n    }\\n    int ns, i;\\n    for (ns = state; ns > 0; ns--) {\\n        if (pat[ns - 1] == x) {\\n            for (i = 0; i < ns - 1; i++) {\\n                if (pat[i] != pat[state - ns + 1 + i]) {\\n                    break;\\n                }\\n            }\\n            if (i == ns - 1) {\\n                return ns;\\n            }\\n        }\\n    }\\n    return 0;\\n}\\n\\nvoid computeTF(char pat[], int M, int TF[NO_OF_CHARS][NO_OF_CHARS]) {\\n    int state, x;\\n    for (state = 0; state <= M; state++) {\\n        for (x = 0; x < NO_OF_CHARS; x++) {\\n            TF[state][x] = getNextState(pat, M, state, x);\\n        }\\n    }\\n}\\n\\nvoid finiteAutomata(char pat[], char txt[]) {\\n    int M = strlen(pat);\\n    int N = strlen(txt);\\n    int TF[M + 1][NO_OF_CHARS];\\n    computeTF(pat, M, TF);\\n    int i, state = 0;\\n    for (i = 0; i < N; i++) {\\n        state = TF[state][txt[i]];\\n        if (state == M) {\\n            cout << \\"Patron encontrado en indice \\" << i - M + 1 << \\" - \\" << i << endl;\\n        }\\n    }\\n}\\n\\nint main(int argc, char const *argv[]) {\\n    char pat[] = {\\"looloolo\\"};\\n    char txt[] = {\\"olo\\"};\\n    finiteAutomata(txt, pat);\\n    return 0;\\n}\\n","py":"from sys import stdin\\nfrom sys import stdout\\nrl = stdin.readline\\nwr = stdout.write\\n\\nNO_OF_CHARS = 256\\n\\n\\ndef getNextState(pat, M, state, x):\\n\\n    if state < M and x == ord(pat[state]):\\n        return state + 1\\n\\n    i = 0\\n    for ns in range(state, 0, -1):\\n        if ord(pat[ns-1]) == x:\\n            for i in range(ns-1):\\n                if pat[i] != pat[state-ns + 1 + i]:\\n                    break\\n                i += 1\\n            if i == ns - 1:\\n                return ns\\n\\n    return 0\\n\\n\\ndef computeTF(pat, M, TF):\\n    for state in range(M + 1):\\n        for x in range(NO_OF_CHARS):\\n            TF[state][x] = getNextState(pat, M, state, x)\\n\\n\\ndef finiteAutomataSearch(pat, txt):\\n\\n    M = len(pat)\\n    N = len(txt)\\n    TF = [[0 for x in range(NO_OF_CHARS)] for x in range(M + 1)]\\n    computeTF(pat, M, TF)\\n    state = 0\\n    for i in range(N):\\n        state = TF[state][ord(txt[i])]\\n        if state == M:\\n            wr(f\'\\"{\\"\\".join(pat)}\\" encontrado en indices ({i-M+1} - {i})\\\\n\')\\n\\n\\ntxt = \'AABAACAADAABAABA\'\\npat = \'AABA\'\\nfiniteAutomataSearch(pat, txt)\\n","orden":5,"suborden":5,"fecha_creacion":"2020-12-04 20:09:36","fecha_modificacion":"2020-12-07 02:37:59"},{"ID":33,"supergrupo":"Matem\xe1tica","tema":"GCD/LCM","texto":"<div style=\\"text-align: justify;\\"><span style=\\"font-size: 10pt;\\">El m\xe1ximo com\xfan divisor (MCD o GCD) de dos o m\xe1s n\xfameros naturales o enteros (no n\xfameros con decimales) es el n\xfamero m\xe1s grande que les divide.\\r\\nEl m\xednimo com\xfan m\xfaltiplo (MCM o LCM) de dos n\xfameros a y b es el n\xfamero m\xe1s peque\xf1o que es m\xfaltiplo de a y m\xfaltiplo de b.</span></div>","complejidad_tiempo":"Mejor caso :    O(log(n))        Peor caso : O(log(n))       Promedio: O(log(n))         ","java":"//Programa java que realiza\\n//Maximo comun divisor y minimo comun multiplo\\n\\npublic class GCDLCM {\\n\\n    public static void main(String[] args) {\\n        int a = 8, b = 12;\\n        System.out.println(\\"GCD de a y b es :\\" + gcd(a, b));\\n        System.out.println(\\"LCM de a y b es :\\" + lcm(a, b));\\n    }\\n    //Maximo Comun Divisor\\n    public static int gcd(int a, int b) {\\n        return b == 0 ? a : gcd(b, a % b);\\n    }\\n    //Minimo Comun Multiplo\\n    public static int lcm(int a, int b) {\\n        return a * (b / gcd(a, b));\\n    }\\n}\\n","cpp":"#include<bits/stdc++.h>\\n#include<cstdlib>\\n//---------------//\\nusing namespace std;\\n\\nint GCD(int a, int b) {\\n    return b == 0 ? a : GCD(b, a % b);\\n}\\n\\nint LCM(int a, int b) {\\n    return a * (b / GCD(a, b));\\n}\\n\\nint main() {\\n    int a = 8;\\n    int b = 12;\\n    cout << \\"GCD de a y b es: \\" << GCD(a, b) << endl;\\n    cout << \\"LCM de a y b es: \\" << LCM(a, b) << endl;\\n}\\n","py":"from sys import stdout\\n\\ndef GCD(a, b):\\n    return a if b == 0 else GCD(b, a % b)\\n\\ndef LCM(a, b):\\n    return a * (b // GCD(a, b))\\n\\ndef main():\\n    a = int(8)\\n    b = int(12)\\n    stdout.write(f\\"GCD de a y b es : {GCD(a,b)}\\\\n\\")\\n    stdout.write(f\\"LCM de a y b es : {LCM(a,b)}\\\\n\\")\\n\\nmain()\\n","orden":6,"suborden":0,"fecha_creacion":"2020-12-04 22:01:06","fecha_modificacion":"2020-12-07 02:42:29"},{"ID":34,"supergrupo":"Matem\xe1tica","tema":"Multiple GCD","texto":"<div style=\\"text-align: justify;\\"><span style=\\"font-size: 10pt;\\">Dado un array de n\xfameros, encontrar GCD del array de elementos.\\r\\nEl GCD de tres o m\xe1s n\xfameros es igual que el producto de los factores primos comunes de todos los n\xfameros, pero puede tambi\xe9n ser calculado tomando repetidamente el GCD de los pares de n\xfameros.</span></div>","complejidad_tiempo":"Mejor caso :    O(nlog(n))        Peor caso : O(nlog(n))       Promedio: O(nlog(n))","java":"// Programa java que encuentra\\n// el maximo comun divisor de 2 o m\xe1s \\n//n\xfameros\\n\\npublic class GCDMultiple {\\n    // Funcion que retorna gcd de a y b\\n    static int gcd(int a, int b) {\\n        if (a == 0) {\\n            return b;\\n        }\\n        return gcd(b % a, a);\\n    }\\n    // Funci\xf3n que encuentra gcd de un arreglo de n\xfameros\\n    static int findGCD(int arr[], int n) {\\n        int result = arr[0];\\n        for (int i = 1; i < n; i++) {\\n            result = gcd(arr[i], result);\\n        }\\n\\n        return result;\\n    }\\n    public static void main(String[] args) {\\n        int arr[] = {2, 4, 6, 8, 16};\\n        int n = arr.length;\\n        System.out.println(findGCD(arr, n));\\n    }\\n} \\n","cpp":null,"py":null,"orden":6,"suborden":1,"fecha_creacion":"2020-12-04 22:01:06","fecha_modificacion":"2020-12-07 02:42:37"},{"ID":35,"supergrupo":"Matem\xe1tica","tema":"GCD de n\xfameros flotantes","texto":"<div style=\\"font-family: Arial, Verdana; font-size: 10pt; font-style: normal; font-variant-ligatures: normal; font-variant-caps: normal; font-weight: normal; text-align: justify;\\"><span style=\\"font-size: 10pt;\\">Una aproximaci\xf3n simple para realizar GCD a n\xfameros flotantes es:&nbsp;</span></div><div style=\\"font-family: Arial, Verdana; font-size: 10pt; font-style: normal; font-variant-ligatures: normal; font-variant-caps: normal; font-weight: normal; text-align: justify;\\">- a=1.20&nbsp;</div><div style=\\"font-family: Arial, Verdana; font-size: 10pt; font-style: normal; font-variant-ligatures: normal; font-variant-caps: normal; font-weight: normal; text-align: justify;\\">- b=22.5&nbsp;</div><div style=\\"\\"><div style=\\"text-align: justify;\\"><span style=\\"font-family: Arial, Verdana; font-size: 13.3333px;\\"><br></span></div><div style=\\"text-align: justify; font-family: Arial, Verdana; font-size: 10pt; font-style: normal; font-variant-ligatures: normal; font-variant-caps: normal; font-weight: normal;\\">Expresando cada uno de los n\xfameros sin decimales como el producto de los primos obtenemos:\\r\\n- 120=2^3*3*5\\r\\n- 2250=2*3^2*5^3\\r\\nGCD de 120 y 2250 = 2*3*5=30\\r\\nPor lo tanto, el GCD de 1.20 y 22.5=0.30 (Tomando 2 d\xedgitos decimales).\\r\\nPodemos hacer esto usando el algoritmo de Euclides, Este algoritmo indica si el n\xfamero m\xe1s peque\xf1o es restado del n\xfamero m\xe1s largo, el GCD de dos n\xfameros no cambia.\\r\\n</div></div>","complejidad_tiempo":"Mejor caso :    O(log(n))        Peor caso : O(log(n))       Promedio: O(log(n))         ","java":"// Programa java que encuentra el GCD de dos\\n// n\xfameros flotantes\\n\\npublic class FloatGCD {\\n    // Funcion recursiva que retorna gcd de a y b  \\n    static double gcd(double a, double b) {\\n        if (a < b) {\\n            return gcd(b, a);\\n        }\\n        // Caso base\\n        if (Math.abs(b) < 0.001) {\\n            return a;\\n        } else {\\n            return (gcd(b, a - Math.floor(a / b) * b));\\n        }\\n    }\\n\\n    public static void main(String args[]) {\\n        double a = 1.20, b = 22.5;\\n        System.out.printf(\\"%.1f\\", gcd(a, b));\\n    }\\n}\\n","cpp":"include<bits/stdc++.h>\\n#include<cstdlib>\\n//---------------//\\nusing namespace std;\\n\\ndouble GCD(double a, double b) {\\n    if (a < b) {\\n        return GCD(b, a);\\n    }\\n    if (std::fabs(b) < 0.001) {\\n        return a;\\n    } else {\\n        return (GCD(b, a - (std::floor(a / b) * b)));\\n    }\\n}\\n\\nint main() {\\n    double a = 1.20, b = 22.5;\\n    printf(\\"%.2f\\\\n\\", (GCD(a, b)));\\n} \\n\\n","py":null,"orden":6,"suborden":2,"fecha_creacion":"2020-12-04 22:01:06","fecha_modificacion":"2020-12-07 02:43:07"},{"ID":36,"supergrupo":"Matem\xe1tica","tema":"LCM en un vector","texto":"<div style=\\"font-weight: normal; text-align: justify;\\"><span style=\\"font-size: 10pt;\\">Dado un array de n n\xfameros, encontrar el LCM de ellos.&nbsp;\\r\\n</span></div><div style=\\"font-weight: normal; text-align: justify;\\"><span style=\\"font-size: 10pt;\\"><br></span></div><div style=\\"font-weight: normal; text-align: justify;\\"><span style=\\"font-size: 10pt;\\">La idea es extender nuestra relaci\xf3n de m\xe1s de dos n\xfameros, se tiene un array arr[] que contiene n elementos de los cuales se necesita calcular su LCM.&nbsp;</span></div><div style=\\"font-weight: normal; text-align: justify;\\"><span style=\\"font-size: 10pt;\\"><br></span></div><div style=\\"text-align: justify;\\"><span style=\\"font-size: 10pt; font-weight: bold;\\">Los pasos principales del algoritmo son:&nbsp;</span></div><div style=\\"font-weight: normal; text-align: justify;\\"><span style=\\"font-size: 10pt;\\">1) Inicializa ans = arr[0]&nbsp;</span></div><div style=\\"font-weight: normal; text-align: justify;\\"><span style=\\"font-size: 10pt;\\">2) Iterar sobre todos los elementos del array, por ejemplo desde i=1 a i= n-1, en la iesima iteraci\xf3n ans= LCM(arr[0],arr[1],\u2026\u2026., arr[i-1]). Esto puede ser f\xe1cilmente hecho como LCM(arr[0], arr[1], \u2026., arr[i]) = LCM(ans, arr[i]). Entonces en la iesima iteraci\xf3n tenemos que hacer ans = LCM(ans, arr[i]) = ans x arr[i] / gcd(ans, arr[i])</span></div>","complejidad_tiempo":"Mejor caso :    O(nlog(n))        Peor caso : O(nlog(n))       Promedio: O(nlog(n))         ","java":"// Programa java que calcula el minimo com\xfan multiplo\\n// de n elementos\\n\\npublic class Lcmofarrayelements {\\n\\n    public static long lcm_of_array_elements(int[] element_array) {\\n        long lcm_of_array_elements = 1;\\n        int divisor = 2;\\n        while (true) {\\n            int counter = 0;\\n            boolean divisible = false;\\n            for (int i = 0; i < element_array.length; i++) {\\n\\n                // lcm_of_array_elements (n1, n2, ... 0) = 0. \\n                // Para cada n\xfamero negativo lo convertimos\\n                // En positivo y calculamos lcm_of_array_elements. \\n                if (element_array[i] == 0) {\\n                    return 0;\\n                } else if (element_array[i] < 0) {\\n                    element_array[i] = element_array[i] * (-1);\\n                }\\n                if (element_array[i] == 1) {\\n                    counter++;\\n                }\\n                /* Divide element_array por diviser si completa\\n                divisi\xf3n */\\n                if (element_array[i] % divisor == 0) {\\n                    divisible = true;\\n                    element_array[i] = element_array[i] / divisor;\\n                }\\n            }\\n            /*Si el divisor es capaz de dividir completamente cualquier n\xfamero.\\n            de la matriz multiplicar con lcm_of_array_elements\\n            y almacenar en lcm_of_array_elements y continuar\\n            al mismo divisor para encontrar el siguiente factor.\\n            si no incrementar divisor*/\\n\\n            if (divisible) {\\n                lcm_of_array_elements = lcm_of_array_elements * divisor;\\n            } else {\\n                divisor++;\\n            }\\n            //Verifica si todo element_Array es 1 indicando\\n            // encontramos todos los factores y terminamos el ciclo\\n            if (counter == element_array.length) {\\n                return lcm_of_array_elements;\\n            }\\n        }\\n    }\\n\\n    public static void main(String[] args) {\\n        int[] element_array = {2, 7, 3, 9, 4};\\n        System.out.println(lcm_of_array_elements(element_array));\\n    }\\n}\\n","cpp":"#include<bits/stdc++.h>\\n#include<cstdlib>\\n//---------------//\\nusing namespace std;\\n\\nlong lcm_array(int arr[], int len) {\\n    long lcm = 1;\\n    int divisor = 2;\\n    while (true) {\\n        int counter = 0;\\n        bool divisible = false;\\n        for (int i = 0; i < len; i++) {\\n            if (arr[i] == 0) {\\n                return 0;\\n            } else if (arr[i] < 0) {\\n                arr[i] = arr[i]*(-1);\\n            }\\n            if (arr[i] == 1) {\\n                counter++;\\n            }\\n            if (arr[i] % divisor == 0) {\\n                divisible = true;\\n                arr[i] = arr[i] / divisor;\\n            }\\n        }\\n        if (divisible) {\\n            lcm = lcm*divisor;\\n        } else {\\n            divisor++;\\n        }\\n        if (counter == len) {\\n            return lcm;\\n        }\\n    }\\n}\\n\\nint main() {\\n    int arr[] = {2, 7, 3, 9, 4};\\n    int len = sizeof arr / sizeof arr[0];\\n    cout << lcm_array(arr, len);\\n} \\n","py":null,"orden":6,"suborden":3,"fecha_creacion":"2020-12-04 22:01:06","fecha_modificacion":"2020-12-07 02:43:55"},{"ID":37,"supergrupo":"Matem\xe1tica","tema":"Test de primalidad","texto":"<div style=\\"text-align: justify;\\"><span style=\\"font-size: 10pt;\\">Un n\xfamero primo es un n\xfamero natural mayor que 1 que tiene \xfanicamente dos divisores distintos: \xe9l mismo y el 1. Por el contrario, los n\xfameros compuestos son los n\xfameros naturales que tienen alg\xfan divisor natural aparte de s\xed mismos y del 1, y, por lo tanto, pueden factorizarse. El n\xfamero 1, por convenio, no se considera ni primo ni compuesto.&nbsp;</span></div><div style=\\"text-align: justify;\\"><span style=\\"font-size: 10pt;\\"><br></span></div><div style=\\"text-align: justify;\\"><span style=\\"font-size: 10pt;\\">La propiedad de ser n\xfamero primo se denomina primalidad. El estudio de los n\xfameros primos es una parte importante de la teor\xeda de n\xfameros, rama de las matem\xe1ticas que trata las propiedades, b\xe1sicamente aritm\xe9ticas, de los n\xfameros enteros.\\r\\nEl teorema fundamental de la aritm\xe9tica establece que todo n\xfamero natural tiene una representaci\xf3n \xfanica como producto de factores primos, salvo el orden. Un mismo factor primo puede aparecer varias veces. El 1 se representa entonces como un producto vac\xedo.</span></div>","complejidad_tiempo":"Mejor caso :    O(vn)        Peor caso : O(vn)       Promedio: O(vn)","java":"//Programa java que verifica si un n\xfamero\\n// es primo o no\\n\\npublic class PrimalityTest {\\n\\n    public static void main(String[] args) {\\n        boolean isprime = false;\\n        int n = 5;\\n        if (isPrime(n)) {\\n            System.out.println(\\"Es primo\\");\\n        } else {\\n            System.out.println(\\"No es primo\\");\\n        }\\n    }\\n\\n    //Prueba de primalidad\\n    public static boolean isPrime(int x) {\\n        if (x < 2) {\\n            return false;\\n        }\\n        if (x == 2) {\\n            return true;\\n        }\\n        if (x % 2 == 0) {\\n            return false;\\n        }\\n        for (int i = 2; i * i <= x; i++) {\\n            if (x % i == 0) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n","cpp":"#include<bits/stdc++.h>\\n#include<cstdlib>\\n//---------------//\\nusing namespace std;\\n\\nbool isPrime(int x) {\\n    if (x < 2) {\\n        return false;\\n    }\\n    if (x == 2) {\\n        return true;\\n    }\\n    for (int i = 2; i * i <= x; i++) {\\n        if (x % i == 0) {\\n            return false;\\n        }\\n    }\\n    return true;\\n}\\n\\nint main() {\\n    int n = 25;\\n    if (isPrime(n)) {\\n        cout << n << \\" es primo\\" << endl;\\n    } else {\\n        cout << n << \\" no es primo\\" << endl;\\n    }\\n}\\n","py":"from sys import stdout\\n\\ndef isPrime(x):\\n    if (x % 2 == 0 and x > 2) or x < 2:\\n        return False\\n    if x == 2:\\n        return True\\n    i = 3\\n    while i * i <= x:\\n        if x % i == 0:\\n            return False\\n        i += 1\\n    return True\\n\\ndef main():\\n    n = int(13)\\n    if isPrime(n):\\n        stdout.write(\\"es primo\\")\\n    else:\\n        stdout.write(\\"no es primo\\")\\n\\nmain()\\n","orden":6,"suborden":4,"fecha_creacion":"2020-12-04 22:01:06","fecha_modificacion":"2020-12-07 02:44:15"},{"ID":38,"supergrupo":"Matem\xe1tica","tema":"Factores primos","texto":"<div style=\\"text-align: justify;\\"><span style=\\"font-size: 10pt;\\">Los factores primos de un n\xfamero entero son los n\xfameros primos divisores exactos de ese n\xfamero entero.&nbsp;</span></div><div style=\\"text-align: justify;\\"><span style=\\"font-size: 10pt;\\"><br></span></div><div style=\\"text-align: justify;\\">El proceso de b\xfasqueda de esos divisores se denomina factorizaci\xf3n de enteros, o factorizaci\xf3n en n\xfameros primos.\\r\\nDeterminar el n\xfamero de factores primos de un n\xfamero es un ejemplo de problema matem\xe1tico frecuentemente empleado para asegurar la seguridad de los sistemas criptogr\xe1ficos: se cree que este problema requiere un tiempo superior al tiempo polin\xf3mico en el n\xfamero de d\xedgitos implicados; de hecho, es relativamente sencillo construir un problema que precisar\xeda m\xe1s tiempo que la Edad del Universo si se intentase calcular con los ordenadores actuales utilizando algoritmos actuales.\\r\\n</div>","complejidad_tiempo":"Mejor caso :    O(vn)        Peor caso : O(vn)       Promedio: O(vn)         ","java":"//Programa que descompone un n\xfamero n\\n// en sus factores primos\\n\\npublic class PrimeFactors {\\n\\n    public static void main(String[] args) {\\n        primeFactors(12);\\n    }\\n    //Descomposicion en factores primos\\n    public static void primeFactors(int N) {\\n        for (long p = 2; p * p <= N; ++p) {\\n            while (N % p == 0) {\\n                System.out.println(p);\\n                N /= p;\\n            }\\n        }\\n        if (N > 1) {\\n            System.out.println(N);\\n        }\\n    }\\n}\\n","cpp":"#include<bits/stdc++.h>\\n#include<cstdlib>\\n//---------------//\\nusing namespace std;\\ntypedef long long int ll;\\n\\nvoid primeFactors(ll n) {\\n    for (ll p = 2; p * p <= n; p++) {\\n        while (n % p == 0) {\\n            cout << p << \\" \\";\\n            n /= p;\\n        }\\n    }\\n    if (n > 1) {\\n        cout << n << endl;\\n    }\\n}\\n\\nint main() {\\n    ll n = 20;\\n    primeFactors(n);\\n}","py":"from sys import stdout\\n\\ndef PrimeFactors(n):\\n    i = int(2)\\n    while i**2 <= n:\\n        while n % i == 0:\\n            stdout.write(str(i)+\\"\\\\n\\")\\n            n //= i\\n        i+=1\\n    if n>1:\\n        stdout.write(str(n))\\n\\ndef main():\\n    PrimeFactors(20)\\n\\nmain()","orden":6,"suborden":5,"fecha_creacion":"2020-12-04 22:01:06","fecha_modificacion":"2020-12-07 02:44:34"},{"ID":39,"supergrupo":"Matem\xe1tica","tema":"Divisibilidad de un n\xfamero","texto":"<div style=\\"text-align: justify;\\"><span style=\\"font-size: 10pt;\\">Los criterios de divisibilidad son reglas que sirven para saber si un n\xfamero es divisible por otro sin necesidad de realizar la divisi\xf3n, a continuaci\xf3n se presentan los criterios de divisibilidad para los n\xfameros mas conocidos.</span></div>","complejidad_tiempo":"Mejor caso :    O(n)        Peor caso : O(n)       Promedio: O(n)         ","java":"//Programa que verifica la divisibilidad de un \\n// n\xfamero entre los n\xfameros 1 a 12\\n\\npublic class DivisibilityBySmallNumbers {\\n\\n    public static void main(String[] args) {\\n        boolean[] res = divisility(12);\\n        for (int i = 0; i < res.length; i++) {\\n            System.out.println(i + \\" : \\" + res[i]);\\n        }\\n    }\\n\\n    static public boolean[] divisility(int num) {\\n        String M = String.valueOf(num);\\n        int n = M.length();\\n        boolean[] isMultipleOf = new boolean[13];\\n        int sum = 0;\\n        for (char c : M.toCharArray()) {\\n            sum += c - \'0\';\\n        }\\n        int lastDigit = M.charAt(n - 1) - \'0\';\\n        //Divisibilidad entre 1\\n        isMultipleOf[1] = true;\\n        //Divisibilidad entre 2\\n        isMultipleOf[2] = lastDigit % 2 == 0;\\n        //Divisibilidad entre 3\\n        isMultipleOf[3] = sum % 3 == 0;\\n        //Divisibilidad entre 4\\n        if (n > 1) {\\n            isMultipleOf[4] = Integer.parseInt(M.substring(n - 2, n)) % 4 == 0;\\n        } else {\\n            isMultipleOf[4] = lastDigit % 4 == 0;\\n        }\\n        //Divisibilidad entre 5\\n        isMultipleOf[5] = lastDigit == 0 || lastDigit == 5;\\n        //Divisibilidad entre 6\\n        isMultipleOf[6] = isMultipleOf[2] && isMultipleOf[3];\\n        int altSum = 0;\\n        int[] pattern = {1, 3, 2, -1, -3, -2};\\n        int j = 0;\\n        for (int i = n - 1; i >= 0; i--) {\\n            altSum += pattern[j] * (M.charAt(i) - \'0\');\\n            j = (j + 1) % 6;\\n        }\\n        //Divisibilidad entre 7\\n        isMultipleOf[7] = Math.abs(altSum) % 7 == 0;\\n        //Divisibilidad entre 8\\n        if (n > 2) {\\n            isMultipleOf[8] = Integer.parseInt(M.substring(n - 3, n)) % 8 == 0;\\n        } else {\\n            isMultipleOf[8] = Integer.parseInt(M) % 8 == 0;\\n        }\\n        //Divisibilidad entre 9\\n        isMultipleOf[9] = sum % 9 == 0;\\n        //Divisibilidad entre 10\\n        isMultipleOf[10] = lastDigit == 0;\\n        altSum = 0;\\n        int s = 1;\\n        for (int i = n - 1; i >= 0; i--) {\\n            altSum += s * (M.charAt(i) - \'0\');\\n            s = -s;\\n        }\\n        //Divisibilidad entre 11\\n        isMultipleOf[11] = Math.abs(altSum) % 11 == 0;\\n        //Divisibilidad entre 12\\n        isMultipleOf[12] = isMultipleOf[3] && isMultipleOf[4];\\n        return isMultipleOf;\\n    }\\n}\\n","cpp":"#include<bits/stdc++.h>\\n#include<cstdlib>\\n//---------------//\\nusing namespace std;\\n\\nvoid print(bool arr[]) {\\n    for (int i = 0; i < 13; i++) {\\n        cout << i << \\": \\" << arr[i] << endl;\\n    }\\n}\\n\\nvoid divisibility(int num) {\\n    stringstream ss;\\n    ss << num;\\n    string M;\\n    ss>>M;\\n    int n = M.size();\\n    bool isMultipleof[13];\\n    memset(isMultipleof, false, sizeof isMultipleof);\\n    int sum = 0;\\n    for (int i = 0; i < n; i++) {\\n        sum += (M[i] - \'0\');\\n    }\\n    int lastDigit = M[n - 1] - \'0\';\\n    isMultipleof[0] = false;\\n    isMultipleof[1] = true;\\n    isMultipleof[2] = lastDigit % 2 == 0;\\n    isMultipleof[3] = sum % 3 == 0;\\n    if (n > 1) {\\n        isMultipleof[4] = stoi(M.substr(n - 2, n)) % 4 == 0;\\n    } else {\\n        isMultipleof[4] = lastDigit % 4 == 0;\\n    }\\n    isMultipleof[5] = lastDigit == 0 || lastDigit == 5;\\n    isMultipleof[6] = isMultipleof[2] && isMultipleof[3];\\n    int altsum = 0;\\n    int pattern[] = {1, 3, 2, -1, -3, -2};\\n    int j = 0;\\n    for (int i = n - 1; i>-0; i--) {\\n        altsum += pattern[j]*(M[i] - \'0\');\\n        j = (j + 1) % 6;\\n    }\\n    isMultipleof[7] = std::abs(altsum) % 7 == 0;\\n    if (n > 2) {\\n        isMultipleof[8] = stoi(M.substr(n - 3, n)) % 8 == 0;\\n    } else {\\n        isMultipleof[8] = stoi(M) % 8 == 0;\\n    }\\n    isMultipleof[9] = sum % 8 == 0;\\n    isMultipleof[10] - lastDigit == 0;\\n    altsum = 0;\\n    int s = 1;\\n    for (int i = n - 1; i >= 0; i--) {\\n        altsum += s * (M[i] - \'0\');\\n        s = -s;\\n    }\\n    isMultipleof[11] = std::abs(altsum) % 11 == 0;\\n    isMultipleof[12] = isMultipleof[2] && isMultipleof[4];\\n    print(isMultipleof);\\n}\\n\\nint main() {\\n    divisibility(33);\\n}\\n","py":"from sys import stdout\\n\\n\\ndef divisibility(num):\\n    M = str(num)\\n    n = len(M)\\n    isMultipleOf = [False for x in range(13)]\\n    suma = 0\\n    for c in M:\\n        suma += ord(c) - ord(\\"0\\")\\n\\n    lastDigit = ord(M[n - 1]) - ord(\\"0\\")\\n    isMultipleOf[1] = True\\n    isMultipleOf[2] = lastDigit % 2 == 0\\n    isMultipleOf[3] = suma % 3 == 0\\n\\n    if n > 1:\\n        isMultipleOf[4] = int(M[n - 2:n]) % 4 == 0\\n    else:\\n        isMultipleOf[4] = lastDigit % 4 == 0\\n\\n    isMultipleOf[5] = lastDigit == 0 or lastDigit == 5\\n    isMultipleOf[6] = isMultipleOf[2] and isMultipleOf[3]\\n\\n    altsum = 0\\n    pattern = [1, 3, 2, -1, -3, -2]\\n    j = 0\\n    for i in range(n - 1, -1, -1):\\n        altsum = pattern[j] * (ord(M[i]) - ord(\\"0\\"))\\n        j = (j + 1) % 6\\n    isMultipleOf[7] = abs(altsum) % 7 == 0\\n    if n > 2:\\n        isMultipleOf[8] = int(M[n - 3:n]) % 8 == 0\\n    else:\\n        isMultipleOf[8] = int(M) % 8 == 0\\n\\n    isMultipleOf[9] = suma % 8 == 0\\n    isMultipleOf[10] = lastDigit == 0\\n    altsum = 0\\n    s = 1\\n    for i in range(n-1, -1, -1):\\n        altsum += s * (ord(M[i]) - ord(\\"0\\"))\\n        s = -s\\n\\n    isMultipleOf[11] = abs(altsum) % 11 == 0\\n    isMultipleOf[12] = isMultipleOf[4] and isMultipleOf[13]\\n    return isMultipleOf\\n\\n\\nres = divisibility(123)\\nfor i in range(len(res)):\\n    stdout.write(f\\"{i} : {res[i]}\\\\n\\")\\n","orden":6,"suborden":6,"fecha_creacion":"2020-12-04 22:01:06","fecha_modificacion":"2020-12-07 02:44:50"},{"ID":40,"supergrupo":"Matem\xe1tica","tema":"Numero de divisores","texto":"<div style=\\"text-align: justify;\\"><span style=\\"font-size: 10pt;\\">Los divisores de un n\xfamero son aquellos valores que dividen al n\xfamero en partes exactas. As\xed, dado un n\xfamero a, si la divisi\xf3n a/b es exacta (el resto es cero), entonces se dice que b es divisor de a. Tambi\xe9n se puede decir que a es divisible por b o que a es un m\xfaltiplo de b.&nbsp;</span></div><div style=\\"text-align: justify;\\"><span style=\\"font-size: 10pt;\\"><br></span></div><div style=\\"text-align: justify;\\">Esto resulta \xfatil, por ejemplo, a la hora de agrupar una cantidad de objetos en partes iguales sin que nos sobre ninguno.\\r\\nL\xf3gicamente, el 1 siempre es divisor de cualquier n\xfamero, porque siempre podemos hacer paquetes individuales y no nos sobrar\xe1 ninguno. De igual forma, todo n\xfamero es divisible por s\xed mismo, lo que equivaldr\xeda a hacer un \xfanico paquete.\\r\\n</div>","complejidad_tiempo":"Mejor caso :    O(vn)        Peor caso : O(vn)       Promedio: O(vn)         ","java":"//Programa java que cuenta el n\xfamero\\n// de divisores de x\\n\\npublic class NumberOfDivisors {\\n\\n    public static void main(String[] args) {\\n        System.out.println(divisors(56));\\n    }\\n\\n    //Todos los divisores de un n\xfamero\\n    public static int divisors(int x) {\\n        int nDiv = 1;\\n        for (int p = 2; p * p <= x; ++p) {\\n            int cnt = 0;\\n            while (x % p == 0) {\\n                ++cnt; \\n                x /= p;\\n            }\\n            nDiv *= cnt + 1;\\n        }\\n        if (x > 1) {\\n            nDiv *= 2;\\n        }\\n        return nDiv;\\n    }\\n}\\n","cpp":"#include<bits/stdc++.h>\\n#include<cstdlib>\\n//---------------//\\nusing namespace std;\\n\\nint divisors(int x) {\\n    int nDiv = 1;\\n    for (int i = 2; i * i <= x; i++) {\\n        int cnt = 0;\\n        while (x % i == 0) {\\n            ++cnt;\\n            x /= i;\\n        }\\n        nDiv *= cnt + 1;\\n    }\\n    if (x > 1) {\\n        nDiv *= 2;\\n    }\\n    return nDiv;\\n}\\n\\nint main() {\\n    cout << divisors(10);\\n}\\n","py":"from sys import stdout\\n\\n\\ndef divisors(x):\\n    nDiv = 1\\n    i = 2\\n    while i ** 2 <= x:\\n        cnt = 0\\n        while x % i == 0:\\n            cnt += 1\\n            x //= i\\n        nDiv *= cnt + 1\\n        i += 1\\n    if x > 1:\\n        nDiv *= 2\\n    return nDiv\\n\\nstdout.write(str(divisors(10)))\\n","orden":6,"suborden":7,"fecha_creacion":"2020-12-04 22:01:06","fecha_modificacion":"2020-12-07 02:45:29"},{"ID":41,"supergrupo":"Matem\xe1tica","tema":"Criba de Erat\xf3stenes","texto":"Criba de Erat\xf3stenes es un algoritmo que permite hallar todos los n\xfameros primos menores que un n\xfamero natural dado n. Se forma una tabla con todos los n\xfameros naturales comprendidos entre 2 y n, y se van tachando los n\xfameros que no son primos de la siguiente manera: \\nComenzando por el 2, se tachan todos sus m\xfaltiplos; comenzando de nuevo, cuando se encuentra un n\xfamero entero que no ha sido tachado, ese n\xfamero es declarado primo, y se procede a tachar todos sus m\xfaltiplos, as\xed sucesivamente. El proceso termina cuando el cuadrado del siguiente n\xfamero confirmado como primo es mayor que n.\\n","complejidad_tiempo":"Mejor caso :    O(nlog(log(n)))     Peor caso : O(nlog(log(n)))       Promedio: O(nlog(log(n)))         ","java":"//Programa java que encuentra todos los n\xfameros \\n//primos bajo N\\n\\nimport java.util.Arrays;\\n\\npublic class PrimeNumbers {\\n\\n    public static void main(String[] args) {\\n        boolean[] res = sieveEratostenes(100);\\n        for (int i = 0; i < res.length; i++) {\\n            System.out.println(i + \\" : \\" + res[i]);\\n        }\\n    }\\n\\n    //Criba de Eratostenes (Todos los primos bajo un n\xfamero)\\n    public static boolean[] sieveEratostenes(int N) {\\n        boolean[] prime = new boolean[N + 1];\\n        Arrays.fill(prime, true);\\n        prime[0] = prime[1] = false;\\n        for (int p = 2; p * p <= N; p++) {\\n            if (prime[p]) {\\n                for (int i = p * p; i <= N; i += p) {\\n                    prime[i] = false;\\n                }\\n            }\\n        }\\n        return prime;\\n    }\\n}\\n","cpp":"#include <bits/stdc++.h>\\n#define FAST ios_base::sync_with_stdio(false);cin.tie(NULL);\\nusing namespace std;\\n\\nvoid print(bool arr[], int n) {\\n    for (int i = 0; i <= n; i++) {\\n        cout << i << \\": \\" << arr[i] << endl;\\n    }\\n}\\n\\nvoid sieveErathostenes(int N) {\\n    bool prime[N + 1];\\n    memset(prime, true, sizeof prime);\\n    prime[0] = prime[1] = false;\\n    for (int p = 2; p * p <= N; p++) {\\n        if (prime[p]) {\\n            for (int i = p * p; i <= N; i += p) {\\n                prime[i] = false;\\n            }\\n        }\\n    }\\n    print(prime, N);\\n}\\n\\nint main() {\\n    FAST;\\n    sieveErathostenes(1000);\\n    return 0;\\n}\\n","py":"from sys import stdout\\n\\n\\ndef sieveErathostenes(n):\\n    prime = [True for x in range(n + 1)]\\n    prime[0] = False\\n    prime[1] = False\\n    p = 2\\n    while p ** 2 <= n:\\n        if prime[p]:\\n            i = p ** 2\\n            while i <= n:\\n                prime[i] = False\\n                i += p\\n        p += 1\\n    return prime\\n\\nres = sieveErathostenes(100)\\n\\nfor i in range(len(res)):\\n    stdout.write(str(i) + \\" \\" + str(res[i])+ \\"\\\\n\\")\\n\\n","orden":6,"suborden":8,"fecha_creacion":"2020-12-04 22:01:06","fecha_modificacion":"2020-12-06 20:23:02"},{"ID":42,"supergrupo":"Matem\xe1tica","tema":"Criba de Erat\xf3stenes O(n)","texto":"La cl\xe1sica criba de Erat\xf3stenes toma O(Nlog (logN))  para encontrar todos los n\xfameros primos  menores a N, este c\xf3digo es una versi\xf3n modificada de esta criba que tiene una complejidad de tiempo de O(N).","complejidad_tiempo":"Mejor caso :    O(n)        Peor caso : O(n)       Promedio: O(n)         ","java":"/*Programa java que genera todos los n\xfameros primos\\nmenores a N en O(N) Eratostenes Optimizado*/\\nimport java.util.ArrayList;\\n\\npublic class SieveofEratosthenesOptimizated {\\n\\n    static final int MAX_SIZE = 1000001;\\n    // isPrime[] : isPrime[i] es true si el n\xfamero es primo  \\n    // prime[] : Almacena todos los n\xfameros primos menores a N \\n    // SPF[] Almacena los factores primos m\xe1s peque\xf1os de un n\xfamero \\n    // [Por ejemplo : factor primo m\xe1s peque\xf1o que \'8\' y \'16\' es  \\n    //  \'2\' entonces nosotros ponemos SPF[8]=2 , SPF[16]=2 ] \\n    static ArrayList<Boolean> isprime = new ArrayList<>(MAX_SIZE);\\n    static ArrayList<Integer> prime = new ArrayList<>();\\n    static ArrayList<Integer> SPF = new ArrayList<>(MAX_SIZE);\\n    // Metodo que genera todos los factores primos menores de N\\n\\n    static void manipulated_seive(int N) {   // 0 y 1 no son primos\\n        isprime.set(0, false);\\n        isprime.set(1, false);\\n\\n        // llena el resto de las entradas\\n        for (int i = 2; i < N; i++) {\\n            // si isPrime[i] == True entonces i es  \\n            // n\xfamero primo\\n            if (isprime.get(i)) {\\n                // pone i dentro de prime[]  \\n                prime.add(i);\\n                // un n\xfamero primo es su propio factor primo\\n                // m\xe1s peque\xf1o\\n                SPF.set(i, i);\\n            }\\n            /*Eliminar todos los m\xfaltiplos de i * prime [j] que son\\n            no primos haciendo isPrime [i * prime [j]] = false\\n            y ponga el factor primo m\xe1s peque\xf1o de i * Prime [j] como prime [j]\\n            [Por ejemplo: dejemos i = 5, j = 0, prime[j] = 2 [i * prime [j] =           10]\\n            por lo que el factor primo m\xe1s peque\xf1o de \'10\' es \'2\' que es prime          [j]]\\n            este bucle se ejecuta solo una vez para el n\xfamero que no es primo*/\\n\\n            for (int j = 0;\\n                    j < prime.size()\\n                    && i * prime.get(j) < N && prime.get(j) <= SPF.get(i);\\n                    j++) {\\n                isprime.set(i * prime.get(j), false);\\n                // Pone el factor primo m\xe1s peque\xf1o de i*prime[j] \\n                SPF.set(i * prime.get(j), prime.get(j));\\n            }\\n        }\\n    }\\n\\n    public static void main(String args[]) {\\n        int N = 13; //Debe ser menor que  MAX_SIZE        \\n        // inicializando isprime y SPF\\n        for (int i = 0; i < MAX_SIZE; i++) {\\n            isprime.add(true);\\n            SPF.add(2);\\n        }\\n        manipulated_seive(N);\\n        //Imprima todos los n\xfameros primos menores que n \\n        for (int i = 0; i < prime.size() && prime.get(i) <= N; i++) {\\n            System.out.print(prime.get(i) + \\" \\");\\n        }\\n    }\\n}\\n","cpp":"#include <bits/stdc++.h>\\n#define FAST ios_base::sync_with_stdio(false);cin.tie(NULL);\\n#define MAX_SIZE 1000001\\nusing namespace std;\\ntypedef long long int ll;\\nvector<int>prime;\\n\\nvoid manipule(ll N) {\\n    bool arr[N + 1];\\n    ll SPF[N + 1];\\n    memset(arr, true, sizeof arr);\\n    memset(SPF, 2, sizeof SPF);\\n    arr[0] = false;\\n    arr[1] = false;\\n    for (ll i = 2; i < N; i++) {\\n        if (arr[i]) {\\n            prime.push_back(i);\\n            SPF[i] = i;\\n        }\\n        for (ll j = 0; j < prime.size() && i * prime[j] < N && prime[j] <= SPF[i]; j++) {\\n            arr[i * prime[j]] = false;\\n            SPF[i * prime[j]] = prime[j];\\n        }\\n    }\\n    for (ll i = 0; i < prime.size(); i++) {\\n        cout << prime[i] << \\" \\";\\n    }\\n}\\n\\nint main() {\\n    manipule(1000);\\n}\\n","py":"from sys import stdin\\nfrom sys import stdout\\n\\nwr = stdout.write\\n\\nMAX_SIZE = 1000001\\n\\nisprime = [True for x in range(MAX_SIZE)]\\n\\nprime = []\\n\\nSPF = [int for x in range(MAX_SIZE)]\\n\\ndef manipuledSieve(N):\\n    global isprime\\n    global prime\\n    global SPF\\n    isprime[0] = False\\n    isprime[1] = False\\n    for i in range(2, N):\\n        if isprime[i]:\\n            prime.append(i)\\n            SPF[i] = i\\n        j = 0\\n        while j < len(prime) and i * prime[j] < N and prime[j] <= SPF[i]:\\n            isprime[i * prime[j]] = False\\n            SPF[i * prime[j]] = prime[j]\\n            j += 1\\n\\nN = 100\\nfor i in range(MAX_SIZE):\\n    # isprime.append(True)\\n    SPF.append(2)\\nmanipuledSieve(N)\\nfor i in range(len(prime)):\\n    wr(f\\"{prime[i]}  \\")\\n\\nwr(\\"\\\\n\\")\\n\\nfor i in range(2, N):\\n    wr(f\\"{i} : {SPF[i]} \\\\n\\")\\n","orden":6,"suborden":9,"fecha_creacion":"2020-12-04 22:01:06","fecha_modificacion":"2020-12-06 20:23:03"},{"ID":43,"supergrupo":"Matem\xe1tica","tema":"Ultimo digito de un Fibonacci","texto":"La sucesi\xf3n o serie de Fibonacci es una sucesi\xf3n infinita de n\xfameros naturales: 0 1 1 2 3 58 21 34 55 89....\\nLa sucesi\xf3n comienza con los n\xfameros 0 y 1, y a partir de estos, cada t\xe9rmino es la suma de los dos anteriores.\\nLos n\xfameros de esta sucesi\xf3n pueden llegar a ser muy grandes y calcular su \xfaltimo digito se hace complicado en m\xe1quinas.\\nUsando fib, multiply y power se puede calcular de forma optimizada un numero de Fibonacci, pero hay que tener en cuenta de no desbordar la variable o el resultado podr\xeda no ser correcto.\\n","complejidad_tiempo":"O(1)        Peor caso : O(1)       Promedio: O(1)         ","java":"// Programa java que encuentra el ultimo digito \\n// de un nesimo n\xfamero fibonacci\\n\\npublic class FibonacciLastDigit {\\n    //Funcion que retona el nesimo\\n    // N\xfamero de fibonacci\\n    static long fib(long n) {\\n        long F[][] = new long[][]{{1, 1}, {1, 0}};\\n        if (n == 0) {\\n            return 0;\\n        }\\n        power(F, n - 1);\\n        return F[0][0];\\n    }\\n    //Funci\xf3n que multiplica dos\\n    // matrices y almacera el resultado en la primera\\n    static void multiply(long F[][], long M[][]) {\\n        long x = F[0][0] * M[0][0]\\n                + F[0][1] * M[1][0];\\n        long y = F[0][0] * M[0][1]\\n                + F[0][1] * M[1][1];\\n        long z = F[1][0] * M[0][0]\\n                + F[1][1] * M[1][0];\\n        long w = F[1][0] * M[0][1]\\n                + F[1][1] * M[1][1];\\n        F[0][0] = x;\\n        F[0][1] = y;\\n        F[1][0] = z;\\n        F[1][1] = w;\\n    }\\n\\n    static void power(long F[][], long n) {\\n        if (n == 0 || n == 1) {\\n            return;\\n        }\\n        long M[][] = new long[][]{{1, 1}, {1, 0}};\\n        power(F, n / 2);\\n        multiply(F, F);\\n        if (n % 2 != 0) {\\n            multiply(F, M);\\n        }\\n    }\\n    // Retorna el ultimo digito \\n    // nesimo n\xfamero fibonacci\\n    public static long findLastDigit(long n) {\\n        return (fib(n) % 10);\\n    }\\n    public static void main(String[] args) {\\n        int n;\\n        n = 1;\\n        System.out.println(findLastDigit(n));\\n        n = 61;\\n        System.out.println(findLastDigit(n));\\n        n = 7;\\n        System.out.println(findLastDigit(n));\\n        n = 67;\\n        System.out.println(findLastDigit(n));\\n    }\\n}\\n","cpp":"#include <bits/stdc++.h>\\nusing namespace std;\\ntypedef long long int ll;\\n\\nvoid multiply(ll F[][2], ll M[][2]) {\\n    ll x = F[0][0] * M[0][0] + F[0][1] * M[1][0];\\n    ll y = F[0][0] * M[0][1] + F[0][1] * M[1][1];\\n    ll z = F[1][0] * M[0][0] + F[1][1] * M[1][0];\\n    ll w = F[1][0] * M[0][1] + F[1][1] * M[1][1];\\n    F[0][0] = x;\\n    F[0][1] = y;\\n    F[1][0] = z;\\n    F[1][1] = w;\\n}\\n\\nvoid power(ll F[][2], ll n) {\\n    if (n == 0 || n == 1) {\\n        return;\\n    }\\n    ll M[][2] = {\\n        {1, 1},\\n        {1, 0}};\\n    power(F, n / 2);\\n    multiply(F, F);\\n    if (n % 2 != 0) {\\n        multiply(F, M);\\n    }\\n}\\n\\nll fib(ll n) {\\n    ll F [][2] = {\\n        {1, 1},\\n        {1, 0}};\\n    if (n == 0) {\\n        return 0;\\n    }\\n    power(F, n - 1);\\n    return F[0][0];\\n}\\n\\nll findLastDigit(ll n) {\\n    return (fib(n) % 10);\\n}\\n\\nint main() {\\n    ios_base::sync_with_stdio(false);\\n    cin.tie(NULL);\\n    cout << fib(83) << \\" : \\" << findLastDigit(83);\\n    return 0;\\n}\\n","py":"from sys import stdout\\nwr = stdout.write\\n\\n\\ndef multiply(F, M):\\n    x = F[0][0] * M[0][0] + F[0][1] * M[1][0]\\n    y = F[0][0] * M[0][1] + F[0][1] * M[1][1]\\n    z = F[1][0] * M[0][0] + F[1][1] * M[1][0]\\n    w = F[1][0] * M[0][1] + F[1][1] * M[1][1]\\n    F[0][0] = x\\n    F[0][1] = y\\n    F[1][0] = z\\n    F[1][1] = w\\n\\n\\ndef power(F, n):\\n    if n == 0 or n == 1:\\n        return\\n    M = [[1, 1], [1, 0]]\\n    power(F, n // 2)\\n    multiply(F, F)\\n    if n % 2 != 0:\\n        multiply(F, M)\\n\\ndef fib(n):\\n    F = [[1, 1], [1, 0]]\\n    if n == 0:\\n        return 0\\n    power(F, n - 1)\\n    return F[0][0]\\n\\ndef findLastDigit(n):\\n    return fib(n) % 10\\n\\nwr(f\'{fib(20)} : {findLastDigit(20)}\')\\n","orden":6,"suborden":10,"fecha_creacion":"2020-12-04 22:01:06","fecha_modificacion":"2020-12-06 20:23:04"},{"ID":44,"supergrupo":"Matem\xe1tica","tema":"Fibonacci largos","texto":"Ciertos ejercicios demandar realizar el c\xe1lculo de n\xfameros de la secuencia de Fibonacci los cuales son demasiado grandes,  para ciertos lenguajes el tama\xf1o de las variables es un impedimento para realizar esta acci\xf3n por lo que se debe usar librer\xedas que permitan realizar operaciones con n\xfameros incre\xedblemente grandes, pero hay que tener en cuenta que entre m\xe1s grande el numero, el tiempo de ejecuci\xf3n va a ser mayor.","complejidad_tiempo":"Mejor caso :    O(n)        Peor caso : O(n)       Promedio: O(n)         ","java":"//Porgrama java que busca el nesimo n\xfamero\\n// de fibonacci cuando n puede ser muy largo\\n\\nimport java.math.*;\\n\\npublic class LongFibonacci {\\n\\n    static BigInteger fib(int n) {\\n        BigInteger a = BigInteger.valueOf(0);\\n        BigInteger b = BigInteger.valueOf(1);\\n        BigInteger c = BigInteger.valueOf(1);\\n        for (int j = 2; j <= n; j++) {\\n            c = a.add(b);\\n            a = b;\\n            b = c;\\n        }\\n        return (a);\\n    }\\n\\n    public static void main(String[] args) {\\n        int n = 1000;\\n        System.out.println(\\"Fibonacci de  \\" + n\\n                + \\" termino\\" + \\" \\" + \\"es\\" + \\" \\" + fib(n));\\n    }\\n} \\n","cpp":null,"py":null,"orden":6,"suborden":11,"fecha_creacion":"2020-12-04 22:01:06","fecha_modificacion":"2020-12-06 20:23:04"},{"ID":45,"supergrupo":"Matem\xe1tica","tema":"Test de numero de Fibonacci","texto":"Teniendo cualquier n\xfamero entero n, se necesita verificar si este hace parte de la secuencia de los n\xfameros de Fibonacci de forma optimizada.","complejidad_tiempo":"Mejor caso :    O(log(n))        Peor caso : O(log(n))       Promedio: O(log(n))         ","java":"// Programa que verifica si x es n\xfamero fibonacci\\n\\npublic class IsFiboNumber {   \\n    // Funci\xf3n que retorna si x es cuadrado perfecto\\n    static boolean isPerfectSquare(int x) {\\n        int s = (int) Math.sqrt(x);\\n        return (s * s == x);\\n    }\\n    //Funci\xf3n que verifica si es n\xfamero fibonacci\\n    static boolean isFibonacci(int n) {   \\n        // N es fibinacci si uno de 5*n*n+4 o or 5*n*n - 4\\n        // o ambos son cuadrados perfectos\\n        return isPerfectSquare(5 * n * n + 4)\\n                || isPerfectSquare(5 * n * n - 4);\\n    }\\n\\n    public static void main(String[] args) {\\n        for (int i = 1; i <= 10; i++) {\\n            System.out.println(isFibonacci(i) ? i + \\" Es un n\xfamero de fibonacci\\"\\n                    : i + \\" No es un n\xfamero de fibonacci\\");\\n        }\\n    }\\n}\\n","cpp":"#include<bits/stdc++.h>\\n#include<cstdlib>\\nusing namespace std;\\n\\nbool isPerfectSquare(int x) {\\n    int s = (int) sqrt(x);\\n    return (s * s == x);\\n}\\n\\nbool isFibonacci(int n) {\\n    return isPerfectSquare(5 * n * n + 4) || isPerfectSquare(5 * n * n - 4);\\n}\\n\\nint main() {\\n    for (int i = 0; i < 10; i++) {\\n        isFibonacci(i) ? cout << i << \\"Es Fibonacci\\" << endl : cout << i << \\"No es fibonacci\\" << endl;\\n    }\\n} \\n","py":null,"orden":6,"suborden":12,"fecha_creacion":"2020-12-04 22:01:06","fecha_modificacion":"2020-12-06 20:23:05"},{"ID":46,"supergrupo":"Matem\xe1tica","tema":"Fibonacci Golden Ratio\\n","texto":"Existen diferentes m\xe9todos para encontrar el en\xe9simo n\xfamero de Fibonacci, una simple manera de encontrarlo es usando el ratio dorado.\\nGolden ratio (Ratio dorado):\\nf=(1+v5)/2=1.6180339887\u2026.\\nGolden ratio nos puede dar una respuesta incorrecta.\\nPodemos obtener la respuesta correcta si redondeamos hacia arriba el resultado de cada punto.\\nEste m\xe9todo puede calcular los primeros 34 n\xfameros de Fibonacci correctamente, luego de esto puede haber diferencia con el valor correcto.\\n","complejidad_tiempo":"Mejor caso :    O(vn)        Peor caso : O(vn)       Promedio: O(vn)         ","java":"// Programa java que encuentra el \\n// nesimo n\xfamero fibonacci\\n\\npublic class FiboGoldenRatio {   //Valor aproximado del golden ratio\\n    // Approximate value of golden ratio \\n    static double PHI = 1.6180339;\\n    // N\xfameros fibonacci hasta 5\\n    static int f[] = {0, 1, 1, 2, 3, 5};\\n    // Funci\xf3n que encuentra nesimo\\n    // n\xfamero fibonacci\\n    static int fib(int n) {   // N\xfameros fibonacci menores a 6\\n        if (n < 6) {\\n            return f[n];\\n        }\\n        // Si no comience conteo desde el quinto\\n        int t = 5;\\n        int fn = 5;\\n        while (t < n) {\\n            fn = (int) Math.round(fn * PHI);\\n            t++;\\n        }\\n        return fn;\\n    }\\n\\n    public static void main(String[] args) {\\n        int n = 9;\\n        System.out.println(n + \\" n\xfamero fibonacci= \\"\\n                + fib(n));\\n    }\\n}\\n","cpp":"#include<bits/stdc++.h>\\n#include<cstdlib>\\nusing namespace std;\\nconst double phi = 1.6180339;\\nint f[] = {0, 1, 1, 2, 3, 5};\\n\\nint fib(int n) {\\n    if (n < 6) {\\n        return f[n];\\n    }\\n    int t = 5;\\n    int fn = 5;\\n    while (t < n) {\\n        fn = (int) round(fn * phi);\\n        t++;\\n    }\\n    return fn;\\n}\\n\\nint main() {\\n    for (int i = 0; i < 10; i++) {\\n        cout << fib(i) << endl;\\n    }\\n} \\n","py":null,"orden":6,"suborden":13,"fecha_creacion":"2020-12-04 22:01:06","fecha_modificacion":"2020-12-06 20:23:05"},{"ID":47,"supergrupo":"Matem\xe1tica","tema":"Permutaciones","texto":"Una permutaci\xf3n es la variaci\xf3n del orden o posici\xf3n de los elementos de un conjunto ordenado o una tupla, hay dos tipos de permutaciones:\\nSe permite repetir: una cerradura de combinaci\xf3n de tres numeros, podr\xeda ser \\"333\\".\\nSin repetici\xf3n: Los tres primeros puestos en una carrera. No puedes quedar primero y segundo a la vez.\\n\\n Permutaciones con repetici\xf3n\\nSon las m\xe1s f\xe1ciles de calcular. Si tiene n cosas para elegir y elige r de ellas, las permutaciones posibles son:\\n n \xd7 n \xd7 ... (r veces) = nr\\n(Porque hay n posibilidades para la primera elecci\xf3n, luego hay n posibilidades para la segunda elecci\xf3n, y as\xed.)\\nPor ejemplo en un candado de combinacion de 3 numeros, hay 10 n\xfameros para elegir (0,1,...,9) y se elige 3 de ellos:\\n 10 \xd7 10 \xd7 ... (3 veces) = 10^3 = 1000 permutaciones\\n\\nAs\xed que la f\xf3rmula es simplemente:\\n n*r\\ndonde n es el n\xfamero de cosas que puede elegir, y elige r de ellas, dentro de estas permutaciones se puede repetir y el orden importa.\\n\\n2. Permutaciones sin repetici\xf3n\\nEn este caso, se reduce el n\xfamero de opciones en cada paso.\\n\xbfc\xf3mo se puede ordenar 16 bolas de billar?\\nDespu\xe9s de elegir por ejemplo la \\"14\\" no puede elegirla otra vez, as\xed que la primera elecci\xf3n tiene 16 posibilidades, y la siguiente elecci\xf3n tiene 15 posibilidades, despu\xe9s 14, 13, hasta 1 Y el total de permutaciones ser\xeda:\\n 16 \xd7 15 \xd7 14 \xd7 13 ... = 20.922.789.888.000\\nPero a lo mejor no quiere elegirlas todas, s\xf3lo 3 de ellas, as\xed que ser\xeda solamente:\\n 16 \xd7 15 \xd7 14 = 3360\\nEs decir, hay 3.360 maneras diferentes de elegir 3 bolas de billar de entre 16.\\nLa funci\xf3n factorial \u201c!\u201d significa que se multiplican n\xfameros descendentes, varios ejemplos de factoriales son:\\n 4! = 4 \xd7 3 \xd7 2 \xd7 1 = 24\\n 7! = 7 \xd7 6 \xd7 5 \xd7 4 \xd7 3 \xd7 2 \xd7 1 = 5040\\n 1! = 1\\n 16! = 20.922.789.888.000\\nPero si s\xf3lo quiere elegir 3, tiene que dejar de multiplicar despu\xe9s de 14. \\n\xbfC\xf3mo se puede escribir esto? Se divide entre 13!...\\n 16x15x14x13\u2026.. /13x12x11\u2026. \\n 16! / 13! = 16 \xd7 15 \xd7 14\\nLa f\xf3rmula se escribe:\\n n!/(n-r)!\\ndonde n es el n\xfamero de cosas que puede elegir, y elige r de ellas, dentro de este tipo e permutaciones no se puede repetir y  el orden importa.\\n","complejidad_tiempo":"Mejor caso :    O(ecuaci\xf3n aplicable)        Peor caso : O(ecuaci\xf3n aplicable)      \\n Promedio: O(ecuaci\xf3n aplicable)         \\n","java":"//Programa java que imprime todas las permutaciones\\n// con o sin repetici\xf3n, r modifica el tama\xf1o de las permutaciones\\nimport java.util.Arrays;\\nimport java.util.HashSet;\\nimport java.util.Iterator;\\nimport java.util.Set;\\n\\npublic class Permutations {\\n\\n    static Set<String> permutations;\\n    static Set<String> result = new HashSet<>();\\n    static int cont = 0;\\n\\n    static void permWithRepUtil(String str, char[] data,\\n            int last, int index) {\\n        int length = str.length();\\n        for (int i = 0; i < length; i++) {\\n            data[index] = str.charAt(i);\\n            if (index == last) {\\n                System.out.println(new String(data));\\n                cont++;\\n            } else {\\n                permWithRepUtil(str, data, last,\\n                        index + 1);\\n            }\\n        }\\n    }\\n\\n    static void permWithRep(String str) {\\n        int length = str.length();\\n        char[] data = new char[length + 1];\\n        char[] temp = str.toCharArray();\\n        Arrays.sort(temp);\\n        str = new String(temp);\\n        permWithRepUtil(str, data, length - 1, 0);\\n    }\\n\\n    static void shuffle(char c) {\\n        if (permutations.isEmpty()) {\\n            permutations.add(String.valueOf(c));\\n        } else {\\n            Iterator<String> it = permutations.iterator();\\n            for (int i = 0; i < permutations.size(); i++) {\\n                String temp1;\\n                while (it.hasNext()) {\\n                    temp1 = it.next();\\n                    for (int k = 0; k < temp1.length() + 1; k++) {\\n                        StringBuilder sb = new StringBuilder(temp1);\\n                        sb.insert(k, c);\\n                        result.add(sb.toString());\\n                    }\\n                }\\n            }\\n            permutations = result;\\n            result = new HashSet<>();\\n        }\\n    }\\n\\n    static Set<String> permutation(String string) {\\n        permutations = new HashSet<>();\\n        int n = string.length();\\n        for (int i = n - 1; i >= 0; i--) {\\n            shuffle(string.charAt(i));\\n        }\\n        Set<String> aux = new HashSet<>();\\n        Iterator<String> it = permutations.iterator();\\n        while (it.hasNext()) {\\n            String aux2 = it.next();\\n            //Entre mas aumente r, mas peque\xf1as seran las permutations\\n            int r = 0;\\n            aux.add(aux2.substring(0, aux2.length() - 0));\\n        }\\n        return aux;\\n\\n    }\\n\\n    public static void main(String[] args) {\\n        String entrada = \\"1234\\";\\n        Set<String> res = permutation(entrada);\\n        System.out.println(\\"Hay en total \\" + res.size() + \\" permutations sin repetici\xf3n de \\" + entrada);\\n        Iterator<String> it = res.iterator();\\n        while (it.hasNext()) {\\n            System.out.println(it.next());\\n        }\\n        String entrada2 = \\"ABC\\";\\n permWithRep(entrada2);\\n        System.out.println(\\"Hay en total \\" + cont + \\" permutations con repetici\xf3n de \\" + entrada2);\\n        \\n    }\\n}\\n","cpp":"#include <iostream>\\n#include <set>\\n#include <string.h>\\n#include <algorithm>\\n\\nusing namespace std;\\n\\nint cont1 = 0;\\nint cont2 = 0;\\n\\nvoid permWithOutRepetition(string str) {\\n    char ayuda[str.size()];\\n    strcpy(ayuda, str.c_str());\\n    do {\\n        ++cont1;\\n        cout << ayuda << endl;\\n    } while (next_permutation(ayuda, ayuda + str.size()));\\n}\\n\\nvoid permWithRepUtil(string str, char data [], int last, int index) {\\n    int length = str.size();\\n    for (int i = 0; i < length; i++) {\\n        data[index] = str[i];\\n        if (index == last) {\\n            cont2++;\\n            string ayuda = data;\\n            cout << ayuda << endl;\\n        } else {\\n            permWithRepUtil(str, data, last, index + 1);\\n        }\\n    }\\n}\\n\\nvoid permWithRep(string str) {\\n    int length = str.size();\\n    char data[length + 1];\\n    char temp[length];\\n    strcpy(temp, str.c_str());\\n    sort(temp, temp + length);\\n    str = temp;\\n    permWithRepUtil(str, data, length - 1, 0);\\n}\\n\\nint main() {\\n    ios_base::sync_with_stdio(false);\\n    cout.tie(NULL);\\n    cin.tie(NULL);\\n    string entrada = \\"Terry\\";\\n    permWithOutRepetition(entrada);\\n    cout << \\"Hay en total \\" << cont1 << \\" permutaciones sin repeticion de \\" << entrada << endl;\\n    cout << \\"\\\\n\\\\n\\" << endl;\\n    permWithRep(entrada);\\n    cout << \\"Hay en total \\" << cont2 << \\" permutaciones con repeticion de \\" << entrada << endl;\\n} \\n","py":null,"orden":6,"suborden":14,"fecha_creacion":"2020-12-04 22:01:06","fecha_modificacion":"2020-12-06 20:23:06"},{"ID":48,"supergrupo":"Matem\xe1tica","tema":"Combinatorias","texto":"La Combinatoria es la parte de las Matem\xe1ticas que estudia las diversas formas de realizar agrupaciones con los elementos de un conjunto, form\xe1ndolas y calculando su n\xfamero.\\nExisten distintas formas de realizar estas agrupaciones, seg\xfan se repitan los elementos o no, seg\xfan se puedan tomar todos los elementos de que disponemos o no y si influye o no el orden de colocaci\xf3n de los elementos.\\nEl orden NO es importante. La notaci\xf3n para las combinaciones es C(n,r) que es la cantidad de combinaciones de \u201cn\u201d elementos seleccionados, \u201cr\u201d a la vez. Es igual a la cantidad de permutaciones de \u201cn\u201d elementos tomados \u201cr\u201d a la vez dividido por \u201cr\u201d factorial. \\n- P(n,r)/r!.\\n\\nEjemplo: Si se seleccionan cinco cartas de un grupo de nueve, \xbfcuantas combinaciones de cinco cartas habr\xeda?\\nLa cantidad de combinaciones posibles ser\xeda:\\n-  P(9,5)/5! = (9*8*7*6*5)/(5*4*3*2*1) = 126 combinaciones posibles.\\n","complejidad_tiempo":"Mejor caso :    O(ecuaci\xf3n aplicable)        Peor caso : O(ecuaci\xf3n aplicable)      \\n Promedio: O(ecuaci\xf3n aplicable)         \\n","java":"//Programa java que imprime todas las combinaciones con o sin repetici\xf3n\\n// de tama\xf1o r en un arreglo de tama\xf1o n\\n\\npublic class Combinations {\\n\\n    static void combinationUtil(int arr[], int data[], int start,\\n            int end, int index, int r) {\\n        if (index == r) {\\n            for (int j = 0; j < r; j++) {\\n                System.out.print(data[j] + \\" \\");\\n            }\\n            System.out.println(\\"\\");\\n            return;\\n        }\\n\\n        for (int i = start; i <= end && end - i + 1 >= r - index; i++) {\\n            data[index] = arr[i];\\n            combinationUtil(arr, data, i + 1, end, index + 1, r);\\n        }\\n    }\\n\\n    static void combination(int arr[], int n, int r) {\\n        int data[] = new int[r];\\n        combinationUtil(arr, data, 0, n - 1, 0, r);\\n    }\\n\\n    static void CombinationRepetitionUtil(int chosen[], int arr[],\\n            int index, int r, int start, int end) {\\n        if (index == r) {\\n            for (int i = 0; i < r; i++) {\\n                System.out.printf(\\"%d \\", arr[chosen[i]]);\\n            }\\n            System.out.printf(\\"\\\\n\\");\\n            return;\\n        }\\n        for (int i = start; i < end; i++) {\\n            chosen[index] = i;\\n            CombinationRepetitionUtil(chosen, arr, index + 1,\\n                    r, i, end);\\n        }\\n        \\n    }\\n\\n    static void CombinationRepetition(int arr[], int n, int r) {\\n        int chosen[] = new int[r + 1];\\n        CombinationRepetitionUtil(chosen, arr, 0, r, 0, n - 1);\\n    }\\n\\n    public static void main(String[] args) {\\n        //Sin repetici\xf3n\\n        int arr[] = {1, 2, 3, 4, 5};\\n        int r = 3;\\n        int n = arr.length;\\n        combination(arr, n, r);\\n        //Con repetici\xf3n\\n        int arr2[] = {1, 2, 3, 4};\\n        int n2 = arr.length;\\n        int r2 = 2;\\n        CombinationRepetition(arr2, n2, r2);\\n\\n    }\\n}\\n","cpp":"#include <cstdlib>\\n#include <bits/stdc++.h>\\nusing namespace std;\\n\\nvoid combinationUtil(int arr[], int data[], int start, int end, int index, int r) {\\n    if (index == r) {\\n        for (int j = 0; j < r; j++) {\\n            cout << data[j] << \\" \\";\\n        }\\n        cout << endl;\\n        return;\\n    }\\n    for (int i = start; i <= end && end - i + 1 >= r - index; i++) {\\n        data[index] = arr[i];\\n        combinationUtil(arr, data, i + 1, end, index + 1, r);\\n    }\\n}\\n\\nvoid combination(int arr[], int n, int r) {\\n    int data[r];\\n    combinationUtil(arr, data, 0, n - 1, 0, r);\\n}\\n\\nvoid combinationRepetitionUtil(int chosen[], int arr[], int index, int r, int start, int end) {\\n    if (index == r) {\\n        for (int i = 0; i < r; i++) {\\n            cout << arr[chosen[i]] << \\" \\";\\n        }\\n        cout << endl;\\n        return;\\n    }\\n    for (int i = start; i < end; i++) {\\n        chosen[index] = i;\\n        combinationRepetitionUtil(chosen, arr, index + 1, r, i, end);\\n    }\\n    return;\\n}\\n\\nvoid combinationRepetition(int arr[], int n, int r) {\\n    int chosen[r + 1];\\n    combinationRepetitionUtil(chosen, arr, 0, r, 0, n - 1);\\n}\\n\\nint main(int argc, char const *argv[]) {\\n    cout << \\"Sin Repeticion\\" << endl;\\n    int arr[] = {1, 2, 3, 4, 5};\\n    int r = 3;\\n    int n = sizeof (arr) / sizeof (arr[0]);\\n    combination(arr, n, r);\\n    cout << \\"Con Repeticion\\" << endl;\\n    int arr2[] = {1, 2, 3, 4};\\n    int n2 = sizeof (arr2) / sizeof (arr2[0]);\\n    int r2 = 2;\\n    combinationRepetition(arr2, n2, r2);\\n    return 0;\\n}\\n","py":"from sys import stdout\\nwr = stdout.write\\n\\ncont1 = 0\\ncont2 = 0\\n\\ndef combUtil(arr, data, start, end, index, r):\\n    global cont1\\n    if index == r:\\n        for j in range(r):\\n            wr(f\'{data[j]} \')\\n        wr(\'\\\\n\')\\n        cont1 += 1\\n        return\\n    i = start\\n    while i <= end and end - i + 1 >= r - index:\\n        data[index] = arr[i]\\n        combUtil(arr, data, i+1, end, index+1, r)\\n        i += 1\\n\\ndef combinationRepetitionUtil(chosen, arr, index, r, start, end):\\n    global cont2\\n    if index == r:\\n        for i in range(r):\\n            wr(f\'{arr[chosen[i]]} \')\\n        wr(\'\\\\n\')\\n        cont2 += 1\\n        return\\n    for i in range(start, end):\\n        chosen[index] = i\\n        combinationRepetitionUtil(chosen, arr, index+1, r, i, end)\\n    return\\n\\ndef printComb(arr, n, r):\\n    data = [0 for x in range(r)]\\n    combUtil(arr, data, 0, n-1, 0, r)\\n\\ndef combinationRepetition(arr, n, r):\\n    chosen = [0 for x in range(r+1)]\\n    combinationRepetitionUtil(chosen, arr, 0, r, 0, n-1)\\n\\narrint1 = [1, 2, 3, 4, 5]\\nr1 = 3\\nn1 = len(arrint1)\\nprintComb(arrint1, n1, r1)\\nwr(f\'Hay {str(cont1)} Combinaciones Sin Repetici\xf3n\\\\n\')\\n\\narrint2 = [1, 2, 3, 4, 5]\\nr2 = 2\\nn2 = len(arrint2)\\ncombinationRepetition(arrint2, n2, r2)\\nwr(f\'Hay {str(cont2)} Combinaciones Con Repetici\xf3n\')\\n","orden":6,"suborden":15,"fecha_creacion":"2020-12-04 22:01:06","fecha_modificacion":"2020-12-06 20:23:07"},{"ID":49,"supergrupo":"Matem\xe1tica","tema":"Combinatorias compuestas","texto":"Teniendo la teor\xeda anterior clara, se puede modificar el algoritmo de tal forma que calcule las composiciones compuestas tal y como deseemos.","complejidad_tiempo":"Mejor caso :    O(ecuaci\xf3n aplicable)        Peor caso : O(ecuaci\xf3n aplicable)      \\n Promedio: O(ecuaci\xf3n aplicable)         \\n","java":"//Programa java que imprime todas\\n//las combinaciones que pueden componer un n\xfamero dado\\n\\npublic class CombinationsCompose {\\n    //Funci\xf3n imprime todas las combinaciones de n\xfameros 1, 2, ...MAX_POINT\\n    // que su suma resulte  n\\n    // i es usado en recursion para mantener revisi\xf3n del indice\\n    // en arr[] donde el siguiente elemento sera a\xf1adido\\n    // Valor inicial de i debe ser pasado como 0\\n\\n    static void printCompositions(int arr[], int n, int i) {\\n        int MAX_POINT = 3;\\n        if (n == 0) {\\n            printArray(arr, i);\\n        } else if (n > 0) {\\n            for (int k = 1; k <= MAX_POINT; k++) {\\n                arr[i] = k;\\n                printCompositions(arr, n - k, i + 1);\\n            }\\n        }\\n    }\\n\\n    // Imprime array\\n    static void printArray(int arr[], int m) {\\n        for (int i = 0; i < m; i++) {\\n            System.out.print(arr[i] + \\" \\");\\n        }\\n        System.out.println();\\n    }\\n\\n    public static void main(String[] args) {\\n        int n = 5;\\n        int size = 100;\\n        int[] arr = new int[size];\\n        System.out.println(\\"Diferentes composiciones formadas por \\"\\n                + \\"1, 2 y 3 de \\" + n + \\" son \\");\\n        printCompositions(arr, n, 0);\\n    }\\n}\\n","cpp":"#include<bits/stdc++.h>\\n#include<cstdlib>\\nusing namespace std;\\n\\nvoid printArr(int arr[], int n) {\\n    for (int i = 0; i < n; i++) {\\n        cout << arr[i] << \\" \\";\\n    }\\n    cout << endl;\\n}\\n\\nvoid printCompositions(int arr[], int n, int i) {\\n    int MAX_POINT = 3;\\n    if (n == 0) {\\n        printArr(arr, i);\\n    } else if (n > 0) {\\n        for (int k = 1; k <= MAX_POINT; k++) {\\n            arr[i] = k;\\n            printCompositions(arr, n - k, i + 1);\\n        }\\n    }\\n}\\n\\nint main() {\\n    int n = 5;\\n    int len = 100;\\n    int arr[len];\\n    printCompositions(arr, n, 0);\\n    return 0;\\n} \\n","py":null,"orden":6,"suborden":16,"fecha_creacion":"2020-12-04 22:01:06","fecha_modificacion":"2020-12-06 20:23:07"},{"ID":50,"supergrupo":"Matem\xe1tica","tema":"Subsets de un Set (Conjuntos)","texto":"Un conjunto (set) es una colecci\xf3n de elementos con caracter\xedsticas similares considerada en s\xed misma como un objeto. Los elementos de un conjunto, pueden ser las siguientes: personas, n\xfameros, colores, letras, figuras, etc.\\nSe dice que un elemento (o miembro) pertenece al conjunto si est\xe1 definido como incluido de alg\xfan modo dentro de \xe9l.\\n","complejidad_tiempo":"Mejor caso :    O(n2n)        Peor caso : O(n2n)      Promedio: O(n2n)         ","java":"//Programa java que imprime todos los subconjuntos de \\n//un conjunto\\n\\npublic class Allsets {\\n\\n    static void printSubsets(char set[]) {\\n        int n = set.length;\\n        // Ejecuta un ciclo imprimiendo todos\\n        //  los subconjuntos 2^n uno por uno\\n        for (int i = 0; i < (1 << n); i++) {\\n            System.out.print(\\"{ \\");\\n            //Imprime el subconjunto actual\\n            for (int j = 0; j < n; j++) // (1<<j) es un n\xfamero con jesimo bit 1\\n            {\\n                if ((i & (1 << j)) > 0) {\\n                    System.out.print(set[j] + \\" \\");\\n                }\\n            }\\n            System.out.println(\\"}\\");\\n        }\\n    }\\n\\n    public static void main(String[] args) {\\n        char set[] = {\'a\', \'b\', \'c\'};\\n        printSubsets(set);\\n    }\\n}\\n","cpp":"#include<bits/stdc++.h>\\n#include<cstdlib>\\nusing namespace std;\\n\\nvoid printSubset(char sets[], int n) {\\n    for (int i = 0; i < (1 << n); i++) {\\n        cout << \\"{\\";\\n        for (int j = 0; j < n; j++) {\\n            if ((i & (1 << j))) {\\n                cout << sets[j] << \\" \\";\\n            }\\n        }\\n        cout << \\"}\\" << endl;\\n    }\\n}\\n\\nint main() {\\n    char conjunto[] = {\'a\', \'b\', \'c\'};\\n    int n = sizeof conjunto / sizeof conjunto[0];\\n    printSubset(conjunto, n);\\n}\\n","py":"from sys import stdout\\nwr = stdout.write\\n\\n\\ndef printSubsets(sset):\\n    n = len(sset)\\n    for i in range(1 << n):\\n        wr(\'{ \')\\n        for j in range(n):\\n            if (i & (1 << j)) > 0:\\n                wr(f\'{sset[j]} \')\\n        wr(\'}\\\\n\')\\n        \\n        \\nconjunto = [\'a\', \'b\', \'c\']\\nprintSubsets(conjunto)\\n","orden":6,"suborden":17,"fecha_creacion":"2020-12-04 22:01:06","fecha_modificacion":"2020-12-06 20:23:08"},{"ID":51,"supergrupo":"Matem\xe1tica","tema":"Coeficientes binomiales","texto":"Los coeficientes binomiales, n\xfameros combinatorios o combinaciones son n\xfameros estudiados en combinatoria que corresponden al n\xfamero de formas en que se puede extraer subconjuntos a partir de un conjunto dado.","complejidad_tiempo":"Mejor caso :    O(n+k)        Peor caso : O(n+k)      Promedio: O(n+k)         ","java":"// Programa java que  calcula el valor\\n// de coeficientes binomiales\\n\\npublic class BinomialCoefficients {\\n    // Retorna el valor del coeficiente binomial\\n    // C(n, k)  \\n    static int binomialCoeff(int n, int k) {\\n        // Casos base\\n        if (k == 0 || k == n) {\\n            return 1;\\n        }\\n        // Recursi\xf3n\\n        return binomialCoeff(n - 1, k - 1)\\n                + binomialCoeff(n - 1, k);\\n    }\\n\\n    public static void main(String[] args) {\\n        int n = 5, k = 2;\\n        System.out.printf(\\"Valor de C(%d, %d) is %d \\",\\n                n, k, binomialCoeff(n, k));\\n    }\\n}\\n","cpp":"#include<bits/stdc++.h>\\n#include<cstdlib>\\nusing namespace std;\\n\\nint BinomialCoeff(int n, int k) {\\n    if (k == 0 || k == n) {\\n        return 1;\\n    }\\n    return BinomialCoeff(n - 1, k - 1) + BinomialCoeff(n - 1, k);\\n}\\n\\nint main() {\\n    int n = 5, k = 2;\\n    printf(\\"valor de C(%d, %d) is %d\\", n, k, BinomialCoeff(n, k));\\n} \\n","py":null,"orden":6,"suborden":18,"fecha_creacion":"2020-12-04 22:01:06","fecha_modificacion":"2020-12-06 20:23:09"},{"ID":52,"supergrupo":"Matem\xe1tica","tema":"Torres de Hanoi","texto":"Las Torres de Han\xf3i son un rompecabezas o juego matem\xe1tico inventado en 1883 por el matem\xe1tico franc\xe9s \xc9douard Lucas. Este juego de mesa individual consiste en un n\xfamero de discos perforados de radio creciente que se apilan insert\xe1ndose en uno de los tres postes fijados a un tablero. El objetivo del juego es trasladar la pila a otro de los postes siguiendo ciertas reglas, como que no se puede colocar un disco m\xe1s grande encima de un disco m\xe1s peque\xf1o. El problema es muy conocido en la ciencia de la computaci\xf3n y aparece en muchos libros de texto como introducci\xf3n a la teor\xeda de algoritmos.\\nLa f\xf3rmula para encontrar el n\xfamero de movimientos necesarios para transferir n discos desde un poste a otro es: 2n \u2013 1.\\n","complejidad_tiempo":"Mejor caso :    O(2n)        Peor caso : O(2n)      Promedio: O(2n)         ","java":"//Programa java que calcula los movimientos\\n// necesarios para completar las torres de Hanoi\\n// Sin importar el n\xfamero de discos n\\n\\npublic class HanoiTowels {\\n\\n    public static void main(String[] args) {\\n        //N\xfamero de discos\\n        int n;\\n        n = 8;\\n        hanoi(n, \\"Primera torre\\", \\"Segunda torre\\", \\"Tercera torre\\");\\n    }\\n    static int paso = 1;\\n    //Funci\xf3n recursiva de busqueda\\n    static void hanoi(int n, String from, String temp, String to) {\\n        if (n == 0) {\\n            return;\\n        }\\n        hanoi(n - 1, from, to, temp);\\n        System.out.println(paso + \\": Mover disco \\" + n + \\n                \\" de \\" + from + \\" a \\" + to);\\n        paso++;\\n        hanoi(n - 1, temp, from, to);\\n    }\\n}\\n","cpp":"#include<bits/stdc++.h>\\n#include<cstdlib>\\nusing namespace std;\\nint paso = 1;\\n\\nvoid hanoi(int n, string from, string temp, string to) {\\n    if (n == 0) {\\n        return;\\n    }\\n    hanoi(n - 1, from, to, temp);\\n    cout << paso << \\" mover disco \\" << n << \\" de \\" << from << \\" a \\" << to << endl;\\n    paso++;\\n    hanoi(n - 1, temp, from, to);\\n}\\n\\nint main() {\\n    int n = 8;\\n    hanoi(n, \\"Primer Torre\\", \\"Segunda Torre\\", \\"Tercer Torre\\");\\n    return 0;\\n} \\n","py":null,"orden":6,"suborden":19,"fecha_creacion":"2020-12-04 22:01:06","fecha_modificacion":"2020-12-06 20:23:09"},{"ID":53,"supergrupo":"Matem\xe1tica","tema":"AX+BY=N","texto":"Dado a, b y n. Encuentre x y y  que satisfaga ax+by=n, imprima cualquiera de los x y y que cumplan la ecuaci\xf3n.\\nPodemos verificar si alguna soluci\xf3n existe o no usando ecuaciones lineales de Diofanes, pero ah\xed se necesita encontrar para esta ecuaci\xf3n, entonces se puede simplemente iterar por todos los posibles valores de 0 a n sin exceder n para esta ecuaci\xf3n. Entonces resolviendo esta ecuaci\xf3n con l\xe1piz y papel obtenemos y=(n-ax)/b y similarmente obtenemos el otro n\xfamero con x=(n-by)/a, si ninguno de los valores satisface la ecuaci\xf3n, al final imprime \u201cSin soluci\xf3n\u201d.\\n","complejidad_tiempo":"Mejor caso :    O(n)        Peor caso : O(n)      Promedio: O(n)         ","java":"//Programa que calcula la soluci\xf3n de\\n// ax + by = n \\n\\npublic class AXplusBYequalsN {\\n\\n    static void solution(int a, int b, int n) {\\n        //A traves de todos los posibles valores\\n        for (int i = 0; i * a <= n; i++) {\\n            //Verifica si se satisface la ecuaci\xf3n\\n            if ((n - (i * a)) % b == 0) {\\n                System.out.println(\\"x = \\" + i\\n                        + \\", y = \\"\\n                        + (n - (i * a)) / b);\\n                return;\\n            }\\n        }\\n        System.out.println(\\"Sin soluci\xf3n\\");\\n    }\\n\\n    public static void main(String[] args) {\\n        int a = 2, b = 3, n = 7;\\n        solution(a, b, n);\\n    }\\n}\\n","cpp":"#include <iostream>\\n\\nusing namespace std;\\n\\nvoid solution(int a, int b, int n) {\\n    for (int i = 0; i * a <= n; i++) {\\n        if ((n - (i * a)) % b == 0) {\\n            cout << \\"x: \\" << i << \\", y: \\" << ((n - (i * a)) / b) << endl;\\n            return;\\n        }\\n    }\\n    cout << \\"No hay solucion\\" << endl;\\n}\\n\\nint main() {\\n    int a = 2, b = 3, n = 16;\\n    solution(a, b, n);\\n    return 0;\\n}\\n","py":"from sys import stdout\\n\\ndef solution(a, b, n):\\n    i = 0\\n    while i * a <= n:\\n        if (n - (i * a)) % b == 0:\\n            stdout.write(f\\"x = {i} y = {(n-(i*a))/b}\\")\\n            return\\n        i += 1\\n    stdout.write(\\"No tiene soluci\xc3\xb3n \\\\n\\")\\n\\na, b, n = 2, 3, 7\\nsolution(a, b, n)\\n\\n","orden":6,"suborden":20,"fecha_creacion":"2020-12-04 22:01:06","fecha_modificacion":"2020-12-06 20:23:10"},{"ID":54,"supergrupo":"Matem\xe1tica","tema":"A%X=B","texto":"Dados dos n\xfameros a y b, encontrar todos los x que permitan a%x=b.\\nExisten tres casos:\\n- Si  a es menor que b entonces no habr\xe1 respuesta.\\n- Si a es igual que b entonces todos los n\xfameros m\xe1s grandes que a, habr\xe1 infinitas soluciones.\\n- Si a es mayor que b, supone que x es una respuesta a nuestra ecuaci\xf3n. Entonces x divide (a-b) tambi\xe9n desde a%x=b entonces b es menor que x\\n","complejidad_tiempo":"Mejor caso :    O(n)        Peor caso : O(n)      Promedio: O(n)         ","java":"/* Programa java que encuentra x tal que\\na % x es igual  b.*/\\npublic class AmodXequalB {\\n\\n    static void modularEquation(int a, int b) {\\n        // Si a es menos que b, entonces no hay soluci\xf3n\\n        if (a < b) {\\n            System.out.println(\\"No solution possible \\");\\n            return;\\n        }\\n        /*Si a es igual a b, entonces cada n\xfamero \\n        m\xe1s grande que a sera la soluci\xf3n, entonces\\n        es infinito*/\\n        if (a == b) {\\n            System.out.println(\\"Infinite Solution possible \\");\\n            return;\\n        }\\n        /*todo el n\xfamero resultante debe ser mayor\\n        que b y (a-b) deben ser divisibles\\n        por n\xfamero resultante\\n        variable count almacena el n\xfamero de\\n        valores posibles*/\\n        int count = 0;\\n        int n = a - b;\\n        int y = (int) Math.sqrt(a - b);\\n        for (int i = 1; i <= y; ++i) {\\n            if (n % i == 0) {\\n                /*Revisando por ambos divisor y \\n                cociente cual divide (a-b) completamente\\n                y mayor que b*/\\n                if (n / i > b) {\\n                    count++;\\n                }\\n                if (i > b) {\\n                    count++;\\n                }\\n            }\\n        }\\n        /* Aqui y es a\xf1adido dos veces en la\\n        ultima iterac\xf3n entonces y deberia ser decrementado\\n        para obtener la soluci\xf3n correcta*/\\n        if (y * y == n && y > b) {\\n            count--;\\n        }\\n        System.out.println(count);\\n    }\\n\\n    public static void main(String[] args) {\\n        int a = 21, b = 5;\\n        modularEquation(a, b);\\n    }\\n}\\n","cpp":"#include<bits/stdc++.h>\\n#include<cstdlib>\\nusing namespace std;\\n\\nvoid modEquation(int a, int b) {\\n    if (a < b) {\\n        cout << \\"no hay solucion\\" << endl;\\n        return;\\n    }\\n    if (a == b) {\\n        cout << \\"infinitas soluciones\\" << endl;\\n        return;\\n    }\\n    int cont = 0;\\n    int n = a - b;\\n    int y = std::sqrt(a - b);\\n\\n    for (int i = 1; i <= y; i++) {\\n        if (n % i == 0) {\\n            if (n / i > b) {\\n                cont++;\\n                cout << (n / i) << \\" \\";\\n            }\\n            if (i > b) {\\n                cont++;\\n                cout << i << \\" \\";\\n            }\\n        }\\n    }\\n    cout << endl;\\n    if (y * y == n && y > b) {\\n        cont--;\\n    }\\n    cout << cont << endl;\\n}\\n\\nint main() {\\n    //a%x=b;\\n    int a = 21, b = 5;\\n    modEquation(a, b);\\n}\\n","py":"import math\\nfrom sys import stdout\\nwr = stdout.write\\n\\n\\ndef modEquation(a, b):\\n    if a < b:\\n        wr(f\'No hay Solucion\')\\n        return\\n    if a == b:\\n        wr(f\'Infinitas Soluciones\')\\n    cont = 0\\n    n = a - b\\n    y = int(math.sqrt(a-b))\\n    for i in range(1, y + 1):\\n        if n % i == 0:\\n            if n // i > b:\\n                cont += 1\\n                wr(f\'{n//i}\\\\n\')\\n            if i > b:\\n                cont += 1\\n                wr(f\'{i}\\\\n\')\\n    if y * y == n and y > b:\\n        cont -= 1\\n    wr(f\'{cont}\')\\n\\n\\na = 21\\nb = 5\\nmodEquation(a, b)\\n","orden":6,"suborden":22,"fecha_creacion":"2020-12-04 22:01:06","fecha_modificacion":"2020-12-06 20:23:10"},{"ID":55,"supergrupo":"Matem\xe1tica","tema":"E pow X","texto":"El valor de la funci\xf3n exponencial e^x puede ser expresado usando la siguiente serie de Taylor:\\n- e^x = 1 + x/1! + x^2/2! + x^3/3! + ...... \\n\xbfC\xf3mo calcular eficientemente la suma de la serie de arriba? Puede ser escrita de la siguiente forma:\\n- e^x = 1 + (x/1) (1 + (x/2) (1 + (x/3) (........)))\\n","complejidad_tiempo":"Mejor caso :    O(n)        Peor caso : O(n)      Promedio: O(n)         ","java":"// Programa eficiente que calcula e elevado x\\n\\npublic class EpowX {\\n    // Funci\xf3n que retorna aproximado de e^x\\n    // Usando suma de los primeros n terminos\\n    // de la serie de Taylor \\n    static float exponential(int n, float x) {\\n        float sum = 1;\\n        for (int i = n - 1; i > 0; --i) {\\n            sum = 1 + x * sum / i;\\n        }\\n        return sum;\\n    }\\n\\n    public static void main(String[] args) {\\n        int n = 10;\\n        float x = 1;\\n        System.out.println(\\"e^x = \\" + exponential(n, x));\\n    }\\n}\\n","cpp":"#include <iostream>\\n#include <iomanip>\\n\\nusing namespace std;\\n\\ndouble exp(int n, double x) {\\n    double sum = 1;\\n    for (int i = n - 1; i > 0; i--) {\\n        sum = 1 + x * sum / i;\\n    }\\n    return sum;\\n}\\n\\nint main() {\\n    ios_base::sync_with_stdio(false);\\n    cout.tie(NULL);\\n    int n = 10;\\n    double x = 2;\\n    cout << \\"exp: \\" << setprecision(25) << exp(n, x) << endl;\\n    cout << \\"exp: \\" << setprecision(25) << exp(n + 10, x) << endl;\\n    return 0;\\n}\\n","py":"from sys import stdout\\nwr = stdout.write\\n\\ndef exp(n, x):\\n    suma = 1\\n    for i in range(n-1, 0, -1):\\n        suma = 1 + x * suma / i\\n    return suma\\n\\nn = 10\\nx = 2\\nwr(f\'exp = {exp(n,x)}\\\\n\')\\nwr(f\'exp = {exp(n+10,x)}\')\\n","orden":6,"suborden":23,"fecha_creacion":"2020-12-04 22:01:06","fecha_modificacion":"2020-12-06 20:23:11"},{"ID":56,"supergrupo":"Matem\xe1tica","tema":"Factorial","texto":"El factorial de un entero positivo n, el factorial de n o n factorial se define en principio como el producto de todos los n\xfameros enteros positivos desde 1 (es decir, los n\xfameros naturales) hasta n.\\nLa operaci\xf3n de factorial aparece en muchas \xe1reas de las matem\xe1ticas, particularmente en combinatoria y an\xe1lisis matem\xe1tico. De manera fundamental la factorial de n representa el n\xfamero de formas distintas de ordenar n objetos distintos (elementos sin repetici\xf3n).\\n","complejidad_tiempo":"Mejor caso :    O(n)        Peor caso : O(n)      Promedio: O(n)         ","java":"// Programa java que encuentra el \\n// factorial de un n\xfamero\\n\\npublic class Factorial {\\n\\n    static int factorial(int n) {\\n        if (n == 0) {\\n            return 1;\\n        }\\n        return n * factorial(n - 1);\\n    }\\n\\n    public static void main(String[] args) {\\n        int num = 5;\\n        System.out.println(\\"Factorial de \\" + num + \\" es \\" + factorial(5));\\n    }\\n}\\n","cpp":"#include<bits/stdc++.h>\\n#include<cstdlib>\\nusing namespace std;\\ntypedef long long int ll;\\nll factorial(ll n){\\n    if(n==0){\\n        return 1;\\n    }\\n    return n*(factorial(n-1));\\n}\\nint main() {\\n    cout<<factorial(10)<<endl;\\n}\\n","py":"from sys import stdout\\nwr = stdout.write\\n\\ndef factorial(n):\\n    if n == 0:\\n        return 1\\n    return n * factorial(n-1)\\n\\nres = 5\\nwr(f\'{factorial(res)}\')\\n","orden":6,"suborden":24,"fecha_creacion":"2020-12-04 22:01:06","fecha_modificacion":"2020-12-06 20:23:12"},{"ID":57,"supergrupo":"Matem\xe1tica","tema":"Factorial largo","texto":"Al igual que con otras secuencias num\xe9ricas, el c\xe1lculo de n\xfameros grandes puede ser un problema debido a que pueden no caber dentro de una variable en espec\xedfico, o ser muy lentas al calcularlo, el siguiente c\xf3digo presenta una forma optimizada de calcular factoriales grandes sin sacrificar tanto tiempo de ejecuci\xf3n, aunque para n\xfameros demasiado grandes puede seguir siendo demasiado lento.","complejidad_tiempo":"Mejor caso :    O(n)        Peor caso : O(n)      Promedio: O(n)         ","java":"// Programa java que calcula factoriales\\n// de n\xfameros enormes\\n\\npublic class BigFactorial {\\n\\n    static void factorial(int n) {\\n        int res[] = new int[500];\\n        res[0] = 1;\\n        int res_size = 1;\\n        // Aplicamos la formula normal de facotorial\\n        // n! = 1 * 2 * 3 * 4...*n \\n        for (int x = 2; x <= n; x++) {\\n            res_size = multiply(x, res, res_size);\\n        }\\n\\n        System.out.println(\\"Factorial del numero dado es \\");\\n        for (int i = res_size - 1; i >= 0; i--) {\\n            System.out.print(res[i]);\\n        }\\n    }\\n\\n    static int multiply(int x, int res[], int res_size) {\\n        int carry = 0; // inicializar carry\\n        // Uno por uno multiplicamos n con \\n        //los digitos individuales de res[] \\n        for (int i = 0; i < res_size; i++) {\\n            int prod = res[i] * x + carry;\\n            res[i] = prod % 10; //Almacenar ultimo digito de  \\n            // \'prod\' en res[] \\n            carry = prod / 10; // Poner el resto de carry \\n        }\\n        //Pone el carry en res e incrementa el tama\xf1o del resultadolt size \\n        while (carry != 0) {\\n            res[res_size] = carry % 10;\\n            carry = carry / 10;\\n            res_size++;\\n        }\\n        return res_size;\\n    }\\n\\n    public static void main(String args[]) {\\n        factorial(100);\\n    }\\n}\\n","cpp":"#include <iostream>\\n\\nusing namespace std;\\n\\nint multiply(int x, int res[], int res_size) {\\n    int carry = 0;\\n    for (int i = 0; i < res_size; i++) {\\n        int prod = res[i] * x + carry;\\n        res[i] = prod % 10;\\n        carry = prod / 10;\\n    }\\n    while (carry != 0) {\\n        res[res_size] = carry % 10;\\n        carry /= 10;\\n        res_size++;\\n    }\\n    return res_size;\\n}\\n\\nvoid factorial(int n) {\\n    int res[10000];\\n    res[0] = 1;\\n    int res_size = 1;\\n    for (int i = 2; i <= n; i++) {\\n        res_size = multiply(i, res, res_size);\\n    }\\n    cout << \\"Factorial del numero dado es:\\" << endl;\\n    for (int i = res_size - 1; i >= 0; i--) {\\n        cout << res[i];\\n    }\\n    cout << endl;\\n}\\n\\nint main() {\\n    factorial(100);\\n    return 0;\\n}\\n","py":"from sys import stdout\\nwr = stdout.write\\n\\ndef multilply(x, res, res_size):\\n    carry = 0\\n    for i in range(res_size):\\n        prod = res[i] * x + carry\\n        res[i] = prod % 10\\n        carry = prod // 10\\n    while carry != 0:\\n        res[res_size] = carry % 10\\n        carry //= 10\\n        res_size += 1\\n    return res_size\\n\\ndef factorial(n):\\n    res = [0 for x in range(500)]  # Maximo digitos de n\\n    res[0] = 1\\n    res_size = 1\\n    for i in range(2, n + 1):\\n        res_size = multilply(i, res, res_size)\\n    wr(f\'Factorial de {n} es: \\\\n\')\\n    for i in range(res_size-1, -1, -1):\\n        wr(f\'{res[i]}\')\\n\\nfactorial(100)\\n","orden":6,"suborden":25,"fecha_creacion":"2020-12-04 22:01:06","fecha_modificacion":"2020-12-06 20:23:12"},{"ID":58,"supergrupo":"Matem\xe1tica","tema":"Numero de d\xedgitos de un factorial","texto":"Dado un entero n, encuentre el n\xfamero de d\xedgitos que aparecen en este factorial, donde factorial es definido como, factorial(n) =1*2*3*4\u2026\u2026..*n y factorial (0) = 1\u2026\u2026\u2026\u2026\\nUna soluci\xf3n ingenua puede ser calcular n! primero y luego calcular el n\xfamero de d\xedgitos presentes en el, sin embargo el valor de n! poder ser muy largo. Se vuelve algo complicado de almacenar esta variable (A menos que est\xe9s trabajando en Python).\\nUna mejor soluci\xf3n puede ser usar las \xfatiles propiedades de los logaritmos para calcular la respuesta.\\nSabemos que:\\n- log(a*b) = log(a) + log(b)\\nPor lo tanto:\\n- log ( n!) = log (1*2*3....... * n)     = log (1) + log (2) +........ +log(n)\\nAhora, observamos que el valor piso del logaritmo base 10 incrementado 1 de cualquier n\xfamero da el n\xfamero de d\xedgitos presentes en ese n\xfamero.\\nEntonces la salida puede ser: floor (log(n!)) + 1.","complejidad_tiempo":"Mejor caso :    O(n)        Peor caso : O(n)      Promedio: O(n)         ","java":"// Programa java que encuentra n\xfamero de \\n// digitos en un factorial\\n\\npublic class FactorialNumDigits {   // Retorna el n\xfamero de digtos\\n    // en n! \\n\\n    static int findDigits(int n) {   // Factorial existe solo para n>=0 \\n        if (n < 0) {\\n            return 0;\\n        }\\n        // Caso base\\n        if (n <= 1) {\\n            return 1;\\n        }\\n        // si no itera atravez de n y calcula el valor\\n        double digits = 0;\\n        for (int i = 2; i <= n; i++) {\\n            digits += Math.log10(i);\\n        }\\n        return (int) (Math.floor(digits)) + 1;\\n    }\\n\\n    public static void main(String[] args) {\\n        System.out.println(findDigits(1));\\n        System.out.println(findDigits(5));\\n        System.out.println(findDigits(10));\\n        System.out.println(findDigits(120));\\n    }\\n}","cpp":"#include<bits/stdc++.h>\\n#include<cstdlib>\\nusing namespace std;\\n\\nint FindDigits(int n) {\\n    if (n < 0) {\\n        return 0;\\n    }\\n    if (n == 1) {\\n        return 1;\\n    }\\n    double digits = 0;\\n    for (int i = 2; i <= n; i++) {\\n        digits += (std::log10(i));\\n    }\\n    return (int) (std::floor(digits)) + 1;\\n}\\n\\nint main() {\\n    cout << FindDigits(1000) << endl;\\n    cout << FindDigits(5) << endl;\\n    cout << FindDigits(20) << endl;\\n    cout << FindDigits(100) << endl;\\n}\\n","py":"import math\\nfrom sys import stdout\\nwr = stdout.write\\n\\ndef findDigits(n):\\n    if n < 0:\\n        return 0\\n    if n <= 1:\\n        return 1\\n    digits = 0\\n    for i in range(2, n+1):\\n        digits += math.log10(i)\\n    return int(math.floor(digits)+1)\\n\\nwr(f\'{findDigits(1000000)}\')\\n","orden":6,"suborden":26,"fecha_creacion":"2020-12-04 22:01:06","fecha_modificacion":"2020-12-06 20:23:13"},{"ID":59,"supergrupo":"Matem\xe1tica","tema":"Numero de d\xedgitos de un factorial optimizado","texto":"Si la soluci\xf3n anterior no es lo suficientemente r\xe1pida, podemos usar la f\xf3rmula de Kamenetsky para obtener la respuesta.\\nSe aproxima al n\xfamero de d\xedgitos en una factorial con:\\n- f(x) =    log10( ((n/e)^n) * sqrt(2*pi*n))\\nAdem\xe1s podemos f\xe1cilmente usar las propiedades de los logaritmos para obtener:\\n- f(x) = n* log10(( n/ e)) + log10(2*pi*n)/2 \\nEsta soluci\xf3n puede manejar n\xfamero muy grandes de entrada, que pueden caber en un entero de 32 bits, e incluso m\xe1s que esto.\\n","complejidad_tiempo":"Mejor caso :    O(1)        Peor caso : O(1)      Promedio: O(1)         ","java":"// Programa java que encuentra el n\xfamero de digitos\\n// en un factorial\\n\\npublic class FactorialNumDigitsOP {\\n\\n    public static double M_E = 2.71828182845904523536;\\n    public static double M_PI = 3.141592654;\\n\\n    /* Funcion que retorna el n\xfamero de digitos presente en \\n    n! desde que el resultado sea muy largo*/\\n    static long findDigits(int n) {\\n\\n        if (n < 0) {\\n            return 0;\\n        }\\n\\n        // caso base\\n        if (n <= 1) {\\n            return 1;\\n        }\\n        // Usamos la formula de Kamenestsky para\\n        // calcular el n\xfamero de digitos\\n        double x = (n * Math.log10(n / M_E)\\n                + Math.log10(2 * M_PI * n)\\n                / 2.0);\\n\\n        return (long) Math.floor(x) + 1;\\n    }\\n\\n    public static void main(String[] args) {\\n        System.out.println(findDigits(1));\\n        System.out.println(findDigits(50000000));\\n        System.out.println(findDigits(1000000000));\\n        System.out.println(findDigits(120));\\n    }\\n}\\n","cpp":"#include<bits/stdc++.h>\\n#include<cstdlib>\\nusing namespace std;\\nconst double PI = 3.14159265358979323846;\\nconst double E = 2.71828182845904523536;\\n\\nlong FindDigitsKame(int n) {\\n    if (n < 0) {\\n        return 0;\\n    }\\n    if (n <= 1) {\\n        return 1;\\n    }\\n    double x = (n * log10(n / E)) + std::log10(2 * PI * n) / 2.0;\\n    return (long) (std::floor(x)) + 1;\\n}\\n\\nint main() {\\n    cout << FindDigitsKame(1000000) << endl;\\n}\\n","py":"import math\\nfrom sys import stdout\\nwr = stdout.write\\n\\ndef findDigits(n):\\n    if n < 0:\\n        return 0\\n    if n <= 1:\\n        return 1\\n    x = (n * math.log10(n / math.e) + math.log10(2 * math.pi * n) / 2)\\n    return int(math.floor(x) + 1)\\n\\nwr(f\'{findDigits(10000)}\')\\n","orden":6,"suborden":27,"fecha_creacion":"2020-12-04 22:01:06","fecha_modificacion":"2020-12-06 20:23:13"},{"ID":60,"supergrupo":"Matem\xe1tica","tema":"Teorema de Euclides-Euler","texto":"De acuerdo con el teorema de Euclides-Euler, un n\xfamero perfecto el cual es par, puede ser representado de la forma (2^n - 1)*(2^n / 2))) donde n es un n\xfamero primo y 2^n \u2013 1 es un n\xfamero primo de Mersenne. Este es un producto de la potencia de 2 con un primo Mersenne, este teorema establece una conexi\xf3n entre un n\xfamero primo de Mersenne y un n\xfamero par primo perfecto. Un n\xfamero perfecto es aqu\xe9l que es igual a la suma de sus divisores, exceptuando \xe9l mismo.\\nAlgunos ejemplos de n\xfameros perfectos los cuales satisfacen este teorema son:\\n- 6, 28, 496, 8128, 33550336, 8589869056, 137438691328\\nExplicaci\xf3n:\\n-  6 es un n\xfamero perfecto par.\\nEntonces puede ser escrito de la forma \\n- (2^2 - 1) * (2^ (2 - 1)) = 6\\nDonde n =2 es un n\xfamero primo y 2^n -1=3 es un n\xfamero primo de Mersenne\\nToma cada n\xfamero primo y forma un primo de Mersenne con \xe9l. El primo de Mersenne = 2^n \u2013 1 donde n es primo. Ahora se forma el n\xfamero (2^n \u2013 1)*(2^(n \u2013 1)) y verificamos si es par y perfecto.\\n","complejidad_tiempo":"Mejor caso :    O(n)        Peor caso : O(n)      Promedio: O(n)         ","java":"//Programa que verifica el teorema de Euclides Euler\\n\\nimport java.util.ArrayList;\\n\\npublic class EuclidEulerTheorem {\\n    static ArrayList<Long> power2 = new ArrayList<Long>();\\n    \\n    public static void main(String[] args) {\\n        //Almacenando potencias de 2 para acceder \\n        // en tiempo O(1) \\n        for (int i = 0; i < 62; i++) {\\n            power2.add(0L);\\n        }\\n\\n        for (int i = 0; i <= 60; i++) {\\n            power2.set(i, (1L << i));\\n        }\\n        System.out.println(\\"Generando los primeros n\xfameros que satisfacen \\"\\n                + \\"el teorema de Euclid Euler\\\\n\\");\\n        for (long i = 2; i <= 25; i++) {\\n            long no = ((power2.get((int) i) - 1L) * (power2.get((int) (i - 1))));\\n            if (isperfect(no) && (no % 2 == 0)) {\\n                System.out.println(\\"(2^\\" + i + \\" - 1) * (2^(\\" + i + \\" - 1)) = \\" \\n                        + no + \\"\\\\n\\");\\n            }\\n        }\\n    }\\n\\n    static boolean isperfect(long n) // N\xfameros perfectos\\n    {\\n        /* Verifica si n es suma perfecta de dividores\\n        excepto por el n\xfamero en si mismo*/\\n        long s = -n;\\n        for (long i = 1; i * i <= n; i++) {\\n            // es i un divisor de n\\n            if (n % i == 0) {\\n                long factor1 = i, factor2 = n / i;\\n                s += factor1 + factor2;\\n                // aqui i*i == n\\n                if (factor1 == factor2) {\\n                    s -= i;\\n                }\\n            }\\n        }\\n        return (n == s);\\n    }\\n\\n    boolean isprime(long n) {\\n        // Verifica cual n\xfamero es primo o no\\n        for (int i = 2; i * i <= n; i++) {\\n            if (n % i == 0) {\\n                return false;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n","cpp":"#include<bits/stdc++.h>\\n#include<cstdlib>\\n//---------------//\\nusing namespace std;\\ntypedef long long int ll;\\nll power2[1000];\\n\\nbool isPerfect(ll n) {\\n    ll s = -n;\\n    for (ll i = 1; i * i <= n; i++) {\\n        if (n % i == 0) {\\n            ll factor1 = i, factor2 = n / i;\\n            s += factor1 + factor2;\\n            if (factor1 == factor2) {\\n                s -= i;\\n            }\\n        }\\n    }\\n    return (n == s);\\n}\\n\\nbool isPrime(ll n) {\\n    for (ll i = 2; i * i <= n; i++) {\\n        if (n % i == 0) {\\n            return false;\\n        }\\n    }\\n    return false;\\n}\\n\\nint main() {\\n    memset(power2, 0L, sizeof power2);\\n    for (int i = 0; i < 62; i++) {\\n        power2[i] = 0L;\\n    }\\n    for (int i = 0; i <= 60; i++) {\\n        power2[i] = (1L << i);\\n    }\\n    cout << \\"Generando los primeros numeros que satiscafacen el teorema\\" << endl;\\n    for (ll i = 2; i <= 25; i++) {\\n        ll no = ((power2[(int) i] - 1L) * power2[(int) (i - 1)]);\\n        if (isPerfect(no) && (no % 2 == 0)) {\\n            cout << \\"(2^\\" << i << \\" -1 * (2^(\\" << i << \\" -1)) = \\" << no << endl;\\n        }\\n    }\\n} \\n","py":null,"orden":6,"suborden":28,"fecha_creacion":"2020-12-04 22:01:06","fecha_modificacion":"2020-12-06 20:23:14"},{"ID":61,"supergrupo":"Matem\xe1tica","tema":"Algoritmo Euclidiano","texto":"El MCD de dos n\xfameros es el n\xfamero m\xe1s grande que divide ambos. Una forma simple de encontrar este n\xfamero es factorizar ambos n\xfameros y multiplicar los factores comunes.\\nEl algoritmo se basa en lo siguiente:\\n\\n- Si resta el n\xfamero m\xe1s peque\xf1o del m\xe1s grande, MCD (GCD) no cambia, entonces si sigue restando repetidamente el m\xe1s grande dos, termina con MCD.\\n- Ahora en vez de restar, si divide el n\xfamero m\xe1s peque\xf1o, el algoritmo termina cuando se encuentra residuo 0.\\n","complejidad_tiempo":"Mejor caso :    O(Log min(a, b))  Peor caso : O(Log min(a, b))      Promedio: O(Log min(a, b))         ","java":"//Programa java que demuestra el algoritmo de Euclides  \\n\\npublic class EuclideanAlgorithm {\\n    // Algoritmo de euclides extendido\\n    public static int gcd(int a, int b) {\\n        if (a == 0) {\\n            return b;\\n        }\\n        return gcd(b % a, a);\\n    }\\n\\n    public static void main(String[] args) {\\n        int a = 10, b = 15, g;\\n        g = gcd(a, b);\\n        System.out.println(\\"GCD(\\" + a + \\" , \\" + b + \\") = \\" + g);\\n        a = 35;\\n        b = 10;\\n        g = gcd(a, b);\\n        System.out.println(\\"GCD(\\" + a + \\" , \\" + b + \\") = \\" + g);\\n        a = 31;\\n        b = 2;\\n        g = gcd(a, b);\\n        System.out.println(\\"GCD(\\" + a + \\" , \\" + b + \\") = \\" + g);\\n    }\\n}\\n","cpp":"#include<bits/stdc++.h>\\n#include<cstdlib>\\n//---------------//\\nusing namespace std;\\n\\nint GCD(int a, int b) {\\n    if (a == 0) {\\n        return b;\\n    }\\n    return GCD(b % a, a);\\n}\\n\\nint main() {\\n    int a = 10;\\n    int b = 15;\\n    cout << \\"GCD\\" << \\"(\\" << a << \\",\\" << b << \\")= \\" << GCD(a, b) << endl;\\n} \\n","py":null,"orden":6,"suborden":29,"fecha_creacion":"2020-12-04 22:01:06","fecha_modificacion":"2020-12-06 20:23:15"},{"ID":62,"supergrupo":"Matem\xe1tica","tema":"Euler Totient","texto":"La funci\xf3n totient de Euler para una entrada n es un conteo de n\xfameros desde 1 hasta n que son primos relativos con n, por ejemplo, los n\xfameros cuyo GCD (M\xe1ximo com\xfan divisor) con n es 1. Se llama primos relativos (coprimos) a cualquier par de n\xfameros enteros que no tienen ning\xfan divisor en com\xfan, excepto el 1.\\nEl criptosistema RSA es basado en este teorema.\\n","complejidad_tiempo":"Mejor caso :    O(n)  Peor caso : O(n)  Promedio: O(n) ","java":"// Programa simple que calcula el valor \\n// de la funci\xf3n  totient Euler\\n\\npublic class EulerTotient {\\n    // Funci\xf3n que retorna gcd de a y b\\n    static int gcd(int a, int b) {\\n        if (a == 0) {\\n            return b;\\n        }\\n        return gcd(b % a, a);\\n    }\\n        // Funci\xf3n que evalua funci\xf3n totient de euler\\n    static int phi(int n) {\\n        int result = 1;\\n        for (int i = 2; i < n; i++) {\\n            if (gcd(i, n) == 1) {\\n                result++;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    public static void main(String[] args) {\\n        int n;\\n        for (n = 1; n <= 10; n++) {\\n            System.out.println(\\"phi(\\" + n + \\") = \\" + phi(n));\\n        }\\n    }\\n}\\n","cpp":"#include<bits/stdc++.h>\\n#include<cstdlib>\\nusing namespace std;\\nint gcd(int a,int b){\\n    if(a==0){\\n        return b;\\n    }\\n    return gcd(b%a,a);\\n}\\nint phi(int n){\\n    int result=1;\\n    for(int i=2;i<n;i++ ){\\n        if(gcd(i,n)==1){\\n            result++;\\n        }\\n    }\\n    return result;\\n}\\nint main() {\\n    for(int i=1;i<=10;i++){\\n        printf(\\"el phi (%d) = %d\\\\n\\",i,phi(i));\\n    }\\n}\\n","py":"from sys import stdout\\nwr = stdout.write\\n\\ndef gcd(a, b):\\n    if a == 0:\\n        return b\\n    return gcd(b % a, a)\\n\\ndef phi(n):\\n    result = 1\\n    for i in range(2, n):\\n        if gcd(i, n) == 1:\\n            result += 1\\n    return result\\n\\nfor i in range(1, 11):\\n    wr(f\'Phi ({i}) = {phi(i)}\\\\n\')\\n","orden":6,"suborden":30,"fecha_creacion":"2020-12-04 22:01:06","fecha_modificacion":"2020-12-06 20:23:15"},{"ID":63,"supergrupo":"Matem\xe1tica","tema":"El peque\xf1o teorema de Fermat","texto":"El peque\xf1o teorema de Fermat dice que si p es un n\xfamero primo, entonces para cualquier entero a, el n\xfamero de p-a es un entero m\xfaltiplo de p.\\nAqu\xed p es un n\xfamero primo:\\n- a^p = a (mod p).\\nCaso especial: si a no es divisible por p, el peque\xf1o teorema de Fermat es equivalente a la sentencia que un p-1-1 es un entero m\xfaltiplo de p.\\n- a^p-1 = 1 (mod p)\\nO\\n- a^p-1 % p = 1  Aqu\xed a no es divisible por p.\\nUsos del peque\xf1o teorema de Fermat\\nSi sabemos que m es primo, entones se puede tambi\xe9n usar el peque\xf1o teorema de Fermat para buscar la inversa:\\n- a^m-1 = 1 (mod m)\\nSi nosotros multiplicamos ambos saldos con a-1, obtenemos:\\n- a^-1 = a m-2 (mod m)\\n","complejidad_tiempo":"Mejor caso :    O(n)  Peor caso : O(n)  Promedio: O(n) ","java":"/*Programa de Java para encontrar modular.\\n inverso de un m\xf3dulo bajo m\\n utilizando el peque\xf1o teorema de Fermat.\\n Este programa funciona solo si m es primo.*/\\npublic class FermatLittleTheorem {\\n\\n    static int __gcd(int a, int b) {\\n        if (b == 0) {\\n            return a;\\n        } else {\\n            return __gcd(b, a % b);\\n        }\\n    }\\n    // Computa x^y bajo modulo m\\n\\n    static int power(int x, int y, int m) {\\n        if (y == 0) {\\n            return 1;\\n        }\\n        int p = power(x, y / 2, m) % m;\\n        p = (p * p) % m;\\n        return (y % 2 == 0) ? p : (x * p) % m;\\n    }\\n    // Funci\xf3n para encontrar modular\\n    // inverso bajo un modulo m\\n    // Asumimos m es primo\\n\\n    static void modInverse(int a, int m) {\\n        if (__gcd(a, m) != 1) {\\n            System.out.print(\\"No existe inverso\\");\\n        } else {\\n            // Si a y m son primos relativos, entonces\\n            // modulo inverso es a^(m-2) mod m \\n            System.out.print(\\"Multiplicaci\xf3n modular inversa es \\"\\n                    + power(a, m - 2, m));\\n        }\\n    }\\n\\n    public static void main(String[] args) {\\n        int a = 3, m = 11;\\n        modInverse(a, m);\\n    }\\n} \\n","cpp":null,"py":null,"orden":6,"suborden":31,"fecha_creacion":"2020-12-04 22:01:06","fecha_modificacion":"2020-12-06 20:23:16"},{"ID":64,"supergrupo":"Matem\xe1tica","tema":"Producto de fracciones","texto":"Dados el numerador y el denominador de N fracciones, la tarea es encontrar el producto de N fracciones e imprimir la respuesta en forma reducida.\\nLa idea es encontrar el producto de numeradores en una variable, como new_num, ahora encontrar el producto de los denominadores en otra variable como new_den. \\nAhora para encontrar la respuesta en forma reducida, encuentre el GCD de new_num y new_den y dividir el new_num y new_den por el GCD calculado.\\nLa soluci\xf3n causa desbordamiento para n\xfameros grandes, podemos evadir esto si encontramos los factores primos de todos los numeradores y denominadores, una vez hayamos encontrado los factores, podemos cancelar los factores primos comunes.\\nCuando se solicita representar la respuesta de la forma {P \\\\veces {Q} ^ {-1}}. Primero convierta el numerador  y el denominador en forma reducible de P/Q. luego busque el multiplicativo inverso de Q con respecto a un n\xfamero primo m (Generalmente 10^9 + 7) el cual es dado como pregunta, luego de encontrar el multiplicativo inverso de Q, multiplicarlo con P y tomar el modulo con el n\xfamero primo m,  el cual nos da nuestra salida requerida.\\n","complejidad_tiempo":"Mejor caso :    O(n)  Peor caso : O(n)  Promedio: O(n) ","java":"//Programa java que encuentra el producto\\n// de N fracciones en forma reducida\\n\\npublic class Fractionsproduct {\\n    // Funci\xf3n que retorna el gcd de a y b\\n    static int gcd(int a, int b) {\\n        if (a == 0) {\\n            return b;\\n        }\\n        return gcd(b % a, a);\\n    }\\n\\n    static void productReduce(int n, int num[],\\n            int den[]) {\\n        int new_num = 1, new_den = 1;\\n        //Encontrando el producto de todos los N\\n        // numeradores y denominadores\\n        for (int i = 0; i < n; i++) {\\n            new_num *= num[i];\\n            new_den *= den[i];\\n        }\\n        // Encontrando GCD de nuevo numerados y denominador \\n        int GCD = gcd(new_num, new_den);\\n        // Convirtiendo en forma reducids\\n        new_num /= GCD;\\n        new_den /= GCD;\\n        System.out.println(new_num + \\"/\\" + new_den);\\n    }\\n\\n    public static void main(String[] args) {\\n        int n = 3;\\n        int num[] = {1, 2, 5};\\n        int den[] = {2, 1, 6};\\n        productReduce(n, num, den);\\n    }\\n}\\n","cpp":"#include<bits/stdc++.h>\\n#include<cstdlib>\\n//---------------//\\nusing namespace std;\\nint GCD(int a,int b){\\n    if(a==0){\\n        return b;\\n    }\\n    return GCD(b%a,a);\\n}\\nvoid productReduce(int n,int num[],int den[]){\\n    int new_num=1,new_den=1;\\n    for(int i=0;i<n;i++){\\n        new_num*=num[i];\\n        new_den*=den[i];\\n    }\\n    int gcd = GCD(new_num,new_den);\\n    new_num/=gcd;\\n    new_den/=gcd;\\n    cout<<new_num<<\\"/\\"<<new_den<<endl;\\n}\\nint main() {\\n    int n=3;\\n    int num[]={1,2,5};\\n    int den[]={2,1,6};\\n    productReduce(n,num,den);\\n} \\n","py":null,"orden":6,"suborden":32,"fecha_creacion":"2020-12-04 22:01:06","fecha_modificacion":"2020-12-06 20:23:17"},{"ID":65,"supergrupo":"Matem\xe1tica","tema":"Josephus","texto":"En las ciencias de la computaci\xf3n y las matem\xe1ticas, el problema Josephus (O permutaci\xf3n Josephus) es un problema teor\xe9tico el cual su enunciado es el siguiente.\\nHay n personas sentadas en c\xedrculo, esperando a ser ejecutadas. El conteo empieza en el mismo punto en el c\xedrculo y procede alrededor del c\xedrculo en direcci\xf3n horaria, en cada paso un cierto n\xfamero de personas son saltadas y la siguiente persona es ejecutada. La eliminaci\xf3n se realiza alrededor del circulo (el comienza a ser m\xe1s peque\xf1o y peque\xf1o mientras la gente es ejecutada y removida), hasta que solo quede una persona, a quien se le dar\xe1 la libertad. Dado el total de personas n y un n\xfamero k que indica que k-1 personas ser\xe1n saltadas y la kesima persona es asesinada en el c\xedrculo, la tarea es escoger el lugar en el c\xedrculo inicial de tal forma que sea la posici\xf3n de la \xfaltima persona que sobreviva.\\nPor ejemplo, si n =5 y k = 2, entonces la posici\xf3n segura es 3.  (1,2,3,4,5 y la posici\xf3n inicial es 5). Primeramente la persona en la posici\xf3n 2 es asesinada, luego la persona en la posici\xf3n 4 es asesinada, luego la persona en la posici\xf3n 1 es asesinada, finalmente la persona en la posici\xf3n 5 es asesinada dejando a la persona en la 4 posici\xf3n viva y con capacidad de disfrutar su libertad.\\nSi n=7 y k=3, entonces la posici\xf3n segura es 4, las personas en las posiciones 3,6,2,7,5,1 son asesinadas en ese orden y la 4 sobrevive. \\n","complejidad_tiempo":"Mejor caso :    O(n)  Peor caso : O(n)  Promedio: O(n) ","java":"//Implementaci\xf3n java de dos Algoritmos que realizan la\\n// busqueda josephus sabiendo n\xfamero personas y tama\xf1o\\n// de salto\\n\\npublic class Josephus {\\n\\n    public static void main(String[] args) {\\n        System.out.println(josephus(6, 2));\\n        System.out.println(josephusModular(6, 2));\\n    }\\n    //Busqueda por algoritmo voraz\\n    static int josephus(int n, int k) {\\n        int d[] = new int[n + 1];\\n        d[0] = -1;\\n        for (int i = 1; i <= n; i++) {\\n            d[i] = i;\\n        }\\n        int i = n;\\n        int a = 0;\\n        while (i != 1) {\\n            i--;\\n            a = next(a, k, d);\\n            d[a] = -1;\\n            a++;\\n        }\\n        for (i = 0; d[i] == -1; i++);\\n        return d[i];\\n    }\\n    //Calcule la posici\xf3n siguiente a caer \\n    static int next(int a, int k, int[] d) {\\n        int j = a - 1;\\n        for (int i = 0; i < k;) {\\n            j = (j + 1) % d.length;\\n            if (d[j] != -1) {\\n                i++;\\n            }\\n        }\\n        return j;\\n    }\\n    //busqueda por matematica modular\\n    static int josephusModular(int n, int k) {\\n        int f = 0;\\n        for (int i = 1; i <= n; i++) {\\n            f = (f + k) % i;\\n\\n        }\\n        return f + 1;\\n    }\\n}\\n","cpp":"#include<bits/stdc++.h>\\n#include<cstdlib>\\n//---------------//\\nusing namespace std;\\nint next(int a, int k, int d[], int n){\\n    int j = a - 1;\\n    for(int i = 0; i < k;){\\n        j = (j + 1) % n;\\n        if(d[j] != -1){\\n            i++;\\n        }\\n    }\\n    cout<<\\"next: \\"<<j<<endl;\\n    return j;\\n}\\nint josephus(int n, int k){\\n    int d[n + 1];\\n    d[0] = -1;\\n    for(int i = 1; i <= n; i++){\\n        d[i] = i;\\n    }\\n    int indice = n;\\n    int a = 0;\\n    while(indice != 1){\\n        indice--;\\n        a = next(a, k, d, n + 1);\\n        d[a] = -1;\\n        a++;\\n    }\\n    for(indice = 0; d[indice] == -1; indice++);\\n        return d[indice];\\n}\\nint main(){\\n    cout<<josephus(10, 3)<<endl;\\n    return 0;\\n}\\n\\n","py":"from sys import stdout\\nwr = stdout.write\\n\\ndef next_(a, k, d):\\n    j = a - 1\\n    i = 0\\n    while i < k:\\n        j = (j+1) % len(d)\\n        if d[j] != -1:\\n            i += 1\\n    wr(f\'Next = {j}\\\\n\')\\n    return j\\n\\ndef josephus(n, k):\\n    d = [-1 for x in range(n+1)]\\n    d[0] = -1\\n    for i in range(1, n+1):\\n        d[i] = i\\n    i = n\\n    a = 0\\n    while i != 1:\\n        i -= 1\\n        a = next_(a, k, d)\\n        d[a] = -1\\n        a += 1\\n    i = 0\\n    while d[i] == -1:\\n        i += 1\\n    return d[i]\\n\\ndef josephusModular(n, k):\\n    f = 0\\n    for i in range(1, n+1):\\n        f = (f+k) % i\\n    return f + 1\\n\\nwr(f\'{josephusModular(6,2)}\\\\n\')\\nwr(f\'{josephus(6,2)}\')\\n","orden":6,"suborden":33,"fecha_creacion":"2020-12-04 22:01:06","fecha_modificacion":"2020-12-06 20:23:17"},{"ID":66,"supergrupo":"Matem\xe1tica","tema":"N\xfameros de la forma Cardinal/Ordinal","texto":"Cuando usamos los n\xfameros naturales para contar los elementos de un determinado conjunto los llamamos n\xfameros cardinales.  \\nEn muchas ocasiones es necesario dar un orden a las cosas: las posiciones finales de una carrera o los pisos de un edificio son algunos ejemplos.  Cuando se usan los n\xfameros naturales para este ordenar los llamamos ordinales.\\nPara representar los n\xfameros ordinales se usan los n\xfameros naturales acompa\xf1ados por una peque\xf1a letra as\xed: 1\xb0a, 2\xb0o  etc.  Cuando acompa\xf1amos el n\xfamero por la letra a es para femenino, y con la letra o es para masculino.  As\xed, si queremos decir que Anita es la n\xfamero uno de la clase decimos que es la primera: 1\xb0a; y si queremos decir que Pablo ocup\xf3 el lugar n\xfamero uno en la carrera decimos que fue el primero: 1\xb0o\\n","complejidad_tiempo":"Mejor caso :    O(n)  Peor caso : O(n)  Promedio: O(n) ","java":"//Programa java que convierte n\xfameros ordinales\\n// en n\xfameros cardinales en ingles\\n\\npublic class CardinalNumbers {\\n\\n    public static void main(String[] args) {\\n        for (int i = 1; i <= 10; i++) {\\n            System.out.println(i + cardinalNumber(i));\\n        }\\n    }\\n\\n    static String cardinalNumber(int n) {\\n        if (n % 10 == 1 && n % 100 != 11) {\\n            return \\"st\\";\\n        }\\n        if (n % 10 == 2 && n % 100 != 12) {\\n            return \\"nd\\";\\n        }\\n        if (n % 10 == 3 && n % 100 != 13) {\\n            return \\"rd\\";\\n        }\\n        return \\"th\\";\\n    }\\n}\\n","cpp":"#include<bits/stdc++.h>\\n#include<cstdlib>\\n//---------------//\\nusing namespace std;\\nstring cardinalNumber(int n){\\n    if(n%10==1 && n%100!=11){\\n        return \\"st\\";\\n    }if(n%10==2 && n%100!=12){\\n        return \\"nt\\";\\n    }if(n%10==3 && n%100!=13){\\n        return \\"st\\";\\n    }\\n    return \\"th\\";\\n}\\nint main(){\\n    for(int i=1;i<=10;i++){\\n        cout<<i<<\\" : \\"<<cardinalNumber(i)<<endl;\\n    }\\n} \\n","py":null,"orden":6,"suborden":34,"fecha_creacion":"2020-12-04 22:01:06","fecha_modificacion":"2020-12-06 20:23:18"},{"ID":67,"supergrupo":"Matem\xe1tica","tema":"12.35) N\xfameros Romanos","texto":"La numeraci\xf3n romana es un sistema de numeraci\xf3n que se desarroll\xf3 en la Antigua Roma y se utiliz\xf3 en todo el Imperio romano, manteni\xe9ndose con posterioridad a su desaparici\xf3n y todav\xeda utilizado en algunos \xe1mbitos.\\n\\nEste sistema emplea algunas letras may\xfasculas como s\xedmbolos para representar ciertos valores. Los n\xfameros se escriben como combinaciones de letras. Por ejemplo, el a\xf1o 2019 se escribe como MMXIX, donde cada M representa 1000 unidades, la X representa 10 unidades m\xe1s y IX representa 9 unidades m\xe1s (al ser X, que representa el 10, precedido por I, que representa el 1).\\n","complejidad_tiempo":"Mejor caso :    O(n)  Peor caso : O(n)  Promedio: O(n) ","java":"//Implementaci\xf3n java que convierte n\xfameros decimales\\n// a n\xfameros romanos y viceversa usando matematica modular\\n\\npublic class RomanNumbers {\\n    // Arrays constantes de letras romanas\\n    static String unit[] = {\\"\\", \\"I\\", \\"II\\", \\"III\\", \\"IV\\", \\"V\\", \\"VI\\", \\"VII\\", \\"VIII\\", \\"IX\\"};\\n    static String ten[] = {\\"\\", \\"X\\", \\"XX\\", \\"XXX\\", \\"XL\\", \\"L\\", \\"LX\\", \\"LXX\\", \\"LXXX\\", \\"XC\\"};\\n    static String hnd[] = {\\"\\", \\"C\\", \\"CC\\", \\"CCC\\", \\"CD\\", \\"D\\", \\"DC\\", \\"DCC\\", \\"DCCC\\", \\"CM\\"};\\n\\n    public static void main(String[] args) {\\n        System.out.println(toRoman(122));\\n        System.out.println(toDecimal(\\"CXXII\\"));\\n    }\\n    //Funci\xf3n que convierte a romano\\n\\n    static String toRoman(int n) {\\n        //Los n\xfameros romanos no tienen letras\\n        //m\xe1s alla de los miles\\n        int a;\\n        StringBuilder sb = new StringBuilder();\\n        if (n >= 1000) {\\n            a = n / 1000;\\n            for (int i = 1; i <= a; i++) {\\n                sb.append(\\"M\\");\\n            }\\n            n %= 1000;\\n        }\\n        //Letras de las centenas\\n        sb.append(hnd[n / 100]);\\n        n = n % 100;\\n        //Letras de las decenas\\n        sb.append(ten[n / 10]);\\n        //Letras de las unidades\\n        sb.append(unit[n % 10]);\\n        return sb.toString();\\n    }\\n    //Devuelve el valor de cada letra\\n\\n    static int valor(char ch) {\\n        switch (ch) {\\n            case \'I\':\\n                return 1;\\n            case \'V\':\\n                return 5;\\n            case \'X\':\\n                return 10;\\n            case \'L\':\\n                return 50;\\n            case \'C\':\\n                return 100;\\n            case \'D\':\\n                return 500;\\n            case \'M\':\\n                return 1000;\\n        }\\n        return 0;\\n    }\\n    //Funci\xf3n que convierte a decimal\\n\\n    static int toDecimal(String num) {\\n        int sum = 0;\\n        int last = 0;\\n        int next;\\n        //Toma cada letra y verifica si esta antes o despues \\n        // suma si esta despues, resta si esta antes\\n        for (int i = num.length() - 1; i >= 0; i--) {\\n            next = valor(num.charAt(i));\\n            if (last <= next) {\\n                sum += next;\\n            } else {\\n                sum -= next;\\n            }\\n            last = next;\\n        }\\n        return sum;\\n    }\\n}\\n","cpp":"#include<bits/stdc++.h>\\n#include<cstdlib>\\n//---------------//\\nusing namespace std;\\nstring unit[]={\\"\\",\\"I\\",\\"II\\",\\"III\\",\\"IV\\",\\"V\\",\\"VI\\",\\"VII\\",\\"VIII\\",\\"IX\\"};\\nstring ten[]={\\"\\",\\"X\\",\\"XX\\",\\"XXX\\",\\"XL\\",\\"L\\",\\"LX\\",\\"LXX\\",\\"LXXX\\",\\"XC\\"};\\nstring hnd[]={\\"\\",\\"C\\",\\"CC\\",\\"CCC\\",\\"CD\\",\\"D\\",\\"DC\\",\\"DCC\\",\\"DCCC\\",\\"CM\\"};\\nint valor(char ch){\\n    switch(ch){\\n    case \'I\':\\n        return 1;\\n    case \'V\':\\n        return 5;\\n    case \'X\':\\n        return 10;\\n    case \'L\':\\n        return 50;\\n    case \'C\':\\n        return 100;\\n    case \'D\':\\n        return 500;\\n    case \'M\':\\n        return 1000;\\n    }\\n    return 0;\\n}\\nstring toRoman(int n){\\n    int a;\\n    string sb=\\"\\";\\n    if(n>=1000){\\n        a = n/1000;\\n        for(int i=1;i<=a;i++){\\n            sb+=\\"M\\";\\n        }\\n        n%=1000;\\n    }\\n    sb+=(hnd[n/100]);\\n    n%=100;\\n    sb+=(ten[n/10]);\\n    sb+=(unit[n%10]);\\n    return sb;\\n}\\nint toDecimal(string num){\\n    int sum=0;\\n    int last=0;\\n    int next;\\n    for(int i=num.size()-1;i>=0;i--){\\n        next=valor(num[i]);\\n        if(last<=next){\\n            sum+=next;\\n        }else{\\n            sum-=next;\\n        }\\n        last=next;\\n    }\\n    return sum;\\n}\\nint main(){\\n    cout<<toRoman(122)<<endl;\\n    cout<<toRoman(1)<<endl;\\n    cout<<toRoman(2323)<<endl;\\n    cout<<toRoman(343)<<endl;\\n\\n    cout<<toDecimal(\\"CXXII\\")<<endl;\\n    cout<<toDecimal(\\"I\\")<<endl;\\n    cout<<toDecimal(\\"MMCCCXXIII\\")<<endl;\\n    cout<<toDecimal(\\"CCCXLIII\\")<<endl;\\n} \\n","py":null,"orden":6,"suborden":35,"fecha_creacion":"2020-12-04 22:01:06","fecha_modificacion":"2020-12-06 20:23:18"},{"ID":68,"supergrupo":"Matem\xe1tica","tema":"Teorema de Hardy-Ramanujan ","texto":"El teorema de Hardy Ramanujan propone que el n\xfamero de factores de n debe ser aproximadamente log(log(n)) para la mayor\xeda de n\xfameros naturales n.\\n- 5192 tiene 2 factores primos distintos y log(log(5192)) = 2.1615\\n- 51242183 tiene 3 factores primos distintos y log(log(51242183)) = 2.8765\\nEste teorema es principalmente usado en algoritmos de aproximaci\xf3n y es prueba l\xedder para conceptos m\xe1s grandes de teor\xeda de la probabilidad \\n","complejidad_tiempo":"Mejor caso :    O(vn)  Peor caso : O(vn)  Promedio: O(vn) ","java":"// Programa java que cuenta todos los \\n// factores primos\\n\\npublic class HardyRamanujanTheorem {\\n    // Una funci\xf3n que cuenta factores primos de \\n    //un n\xfamero n\\n    static int exactPrimeFactorCount(int n) {\\n        int count = 0;\\n        if (n % 2 == 0) {\\n            count++;\\n            while (n % 2 == 0) {\\n                n = n / 2;\\n            }\\n        }\\n        // n debe ser impar en este punto, asi \\n        //podemos saltar un elemento (i=i+2)\\n        for (int i = 3; i <= Math.sqrt(n); i = i + 2) {\\n            if (n % i == 0) {\\n                count++;\\n                while (n % i == 0) {\\n                    n = n / i;\\n                }\\n            }\\n        }\\n        // Esta condici\xf3n es para controlar el caso\\n        // cuando n es un factor primo m\xe1s grande que 2\\n        if (n > 2) {\\n            count++;\\n        }\\n        return count;\\n    }\\n\\n    public static void main(String[] args) {\\n        int n = 51242183;\\n        System.out.println(\\"El n\xfamero de diferentes \\"\\n                + \\" factores primos es \\"\\n                + exactPrimeFactorCount(n));\\n        System.out.println(\\"El valor de (log(n))\\"\\n                + \\" es \\" + Math.log(Math.log(n)));\\n    }\\n}\\n","cpp":"#include<bits/stdc++.h>\\n#include<cstdlib>\\n//---------------//\\nusing namespace std;\\nint exactPrimeFactorCount(int n){\\n    int cont=0;\\n    if(n%2==0){\\n        cont++;\\n        while(n%2==0){\\n            n/=2;\\n        }\\n    }\\n    for(int i=3;i<=(sqrt(n));i+=2){\\n        if(n%i==0){\\n            cont++;\\n            while(n%i==0){\\n                n/=i;\\n            }\\n        }\\n    }\\n    if(n>2){\\n        cont++;\\n    }\\n    return cont;\\n}\\nint main(){\\n    int n=51242183;\\n    cout<<\\"El numero de diferentes factores primos es \\"<<exactPrimeFactorCount(n)<<endl;\\n    cout<<\\"EL valor de (log(n)) es \\"<<log(log(n))<<endl;\\n} \\n","py":null,"orden":6,"suborden":36,"fecha_creacion":"2020-12-04 22:01:06","fecha_modificacion":"2020-12-06 20:23:19"},{"ID":69,"supergrupo":"Matem\xe1tica","tema":"Hoax Number","texto":"Dado un n\xfamero n, verificar si es un n\xfamero falso o no.\\nUn n\xfamero falso es definido como un n\xfamero compuesto, cuya suma de d\xedgitos es igual a la suma de d\xedgitos de sus distintos factores primos, 1 no es considerado un n\xfamero primo, entonces no es incluido en la suma de d\xedgitos de los distintos factores primos.\\nLa definici\xf3n de un n\xfamero falso est\xe1 cerca de la de la definici\xf3n de un n\xfamero de Smith, algunos de los n\xfameros falsos son tambi\xe9n n\xfameros de Smith, es aparente que estos n\xfameros falsos no tienen factores repetidos en su descomposici\xf3n de primos.\\nImplementaci\xf3n\\n1) Primero se generan todos los distintos factores primos del n\xfamero n.\\n2) Si el n no es un n\xfamero primo, encuentre la suma de d\xedgitos de los factores obtenidos en el paso 1\\n3) Encuentre la suma de d\xedgitos de n\\n4) Verifique si la suma obtenida en  2 y 3 son iguales o no.\\n5) Si las sumas son iguales, entonces n es un n\xfamero falso.\\n","complejidad_tiempo":"Mejor caso :    O(vn)  Peor caso : O(vn)  Promedio: O(vn) ","java":"// Programa java que verifica si un n\xfamero es \\n// falso o no\\n\\nimport java.util.*;\\n\\npublic class HoaxNumber {\\n\\n    /*Funci\xf3n que encuentra distintos factores primos\\n    dado un n\xfamero n*/\\n    static List<Integer> primeFactors(int n) {\\n        List<Integer> res = new ArrayList<>();\\n        if (n % 2 == 0) {\\n            while (n % 2 == 0) {\\n                n = n / 2;\\n            }\\n            res.add(2);\\n        }\\n        /*N es impar en este punto\\n        desde que ya no sea divisible por 2\\n        entonces podemos probar solamente\\n        por n\xfameros impares, mientras sean \\n        factores de n*/\\n        for (int i = 3; i <= Math.sqrt(n);\\n                i = i + 2) {\\n            //Verifica si i es factor primo\\n            if (n % i == 0) {\\n                while (n % i == 0) {\\n                    n = n / i;\\n                }\\n                res.add(i);\\n            }\\n        }\\n        /*Esra condici\xf3n es para controlar\\n        el caso cuando n es un n\xfamero primo\\n        m\xe1s grande que 2*/\\n        if (n > 2) {\\n            res.add(n);\\n        }\\n        return res;\\n    }\\n\\n    /*Funci\xf3n que calcula suma de digitos de distintos\\n    factores primos de dado n y la suma de digitos\\n    de n\xfamero n. compara las sum\xe1s obtenidas*/\\n    static boolean isHoax(int n) {\\n        /*Distintos factores primos de n seran almacenados\\n        en vector pf*/\\n        List<Integer> pf = primeFactors(n);\\n        /* Si n es un n\xfamero primo\\n        no puede ser un n\xfamero falso*/\\n        if (pf.get(0) == n) {\\n            return false;\\n        }\\n        /*Encontrando suma de digitos de \\n        distintos factores primos de n*/\\n        int all_pf_sum = 0;\\n        for (int i = 0; i < pf.size(); i++) {\\n            // Encontramos la suma de digitos de \\n            // el actual factor primo pf[i] \\n            int pf_sum;\\n            for (pf_sum = 0; pf.get(i) > 0;\\n                    pf_sum += pf.get(i) % 10, pf.set(i, pf.get(i) / 10));\\n\\n            all_pf_sum += pf_sum;\\n        }\\n        // Encontrando suma de digitos de n\\n        int sum_n;\\n        for (sum_n = 0; n > 0; sum_n += n % 10, n /= 10);\\n        // Comparando las dos sum\xe1s calculadas\\n        return sum_n == all_pf_sum;\\n    }\\n\\n    public static void main(String args[]) {\\n        int n = 84;\\n        if (isHoax(n)) {\\n            System.out.print(\\"Un n\xfamero falso\\\\n\\");\\n        } else {\\n            System.out.print(\\"No es n\xfamero falso\\\\n\\");\\n        }\\n    }\\n} \\n\\n","cpp":null,"py":null,"orden":6,"suborden":37,"fecha_creacion":"2020-12-04 22:01:06","fecha_modificacion":"2020-12-06 20:23:20"},{"ID":70,"supergrupo":"Matem\xe1tica","tema":"Potencia m\xe1s grande que divide un factorial","texto":"Dados dos n\xfameros, fact y n, encuentre la potencia m\xe1s grande de n que divide fact! (Factorial de fact).\\nLa idea es basada en la f\xf3rmula de Legendre la cual encuentra la potencia m\xe1s grande de un n\xfamero primo que divide fact!. Encontramos todos los factores primos de n. para cada factor primo encontramos la potencia m\xe1s grande que divide fact! y finalmente retornamos el m\xednimo de todas las potencias encontradas.\\nSi hay m\xfaltiples potencias de un factor primo presentes en n, entonces se divide el conteo para obtener el valor de la m\xe1xima potencia de este factor.\\n","complejidad_tiempo":"Mejor caso :    O(vn)  Peor caso : O(vn)  Promedio: O(vn) ","java":"/* Programa java que encuentra la potencia m\xe1s larga de\\nun n\xfamero (La cual puede ser compuesta) que divide \\nfactorial*/\\npublic class LargestPowDividesFactorial {\\n\\n    /* For que encuentra la maxima potencia de n\xfamero primo\\n    p que puede dividir un n\xfamero facorial*/\\n    static int findPowerPrime(int fact, int p) {\\n        int res = 0;\\n        while (fact > 0) {\\n            res += fact / p;\\n            fact /= p;\\n        }\\n\\n        return res;\\n    }\\n\\n    // Retorna la suma de todos los factores de n\\n    static int findPowerComposite(int fact, int n) {\\n        // Para almacernar el resultado ( Potencia minima de un \\n        // factor primo que divide fact)\\n        int res = Integer.MAX_VALUE;\\n        // Atravesar atraves de todos los factores\\n        // primos de n\\n        for (int i = 2; i <= Math.sqrt(n); i++) {\\n            // contador para contar la potencia del n\xfamero primo\\n            int count = 0;\\n            if (n % i == 0) {\\n                count++;\\n                n = n / i;\\n            }\\n            if (count > 0) {\\n                // Maxima potencia de i que divide \\n                // fact, dividimos por count para \\n                // manejar multiples ocurrencias de \\n                // un factor primo\\n                int curr_pow = findPowerPrime(fact, i) / count;\\n                res = Math.min(res, curr_pow);\\n            }\\n        }\\n        // Esta condici\xf3n es para manejar \\n        // el caso cuando n es un n\xfamero primo mayor \\n        // que 2\\n        if (n >= 2) {\\n            int curr_pow = findPowerPrime(fact, n);\\n            res = Math.min(res, curr_pow);\\n        }\\n        return res;\\n    }\\n\\n    public static void main(String[] args) {\\n        int fact = 146, n = 5;\\n        System.out.println(findPowerComposite(fact, n));\\n    }\\n} \\n","cpp":null,"py":null,"orden":6,"suborden":38,"fecha_creacion":"2020-12-04 22:01:06","fecha_modificacion":"2020-12-06 20:23:20"},{"ID":71,"supergrupo":"Matem\xe1tica","tema":"Exponenciaci\xf3n modular","texto":"Dados tres n\xfameros x, y y p, calcule (x^y) % p.\\nBajo esta propiedad fundamental modular  que es usada para computaci\xf3n eficiente, calcular la potencia usando matem\xe1tica modular.\\n-  (ab) mod p = ( (a mod p) (b mod p) ) mod p \\nPor ejemplo  a = 50,  b = 100, p = 13\\n- 50  mod 13  = 11\\n- 100 mod 13  = 9\\n- (50 * 100) mod 13 = ( (50 mod 13) * (100 mod 13) ) mod 13 \\n- or (5000) mod 13 = ( 11 * 9 ) mod 13\\n- or 8 = 8\\n","complejidad_tiempo":"Mejor caso :    O(log n)  Peor caso : O(log n)  Promedio: O(log n) ","java":"// Programa iteratico que calcula \\n// potencia modular \\n\\npublic class ModularExponentiation {\\n\\n    /* Funci\xf3n iterativa que calcula\\n       (x^y)%p in O(log y) */\\n    static int power(int x, int y, int p) {\\n        // Inicializar resultado\\n        int res = 1;\\n        // Actualiza x si es m\xe1s que    \\n        // o igual a p \\n        x = x % p;\\n        while (y > 0) {   //Si y es impar, multiplica x con res\\n            if ((y & 1) == 1) {\\n                res = (res * x) % p;\\n            }\\n            // y debe ser par ahora\\n            // y = y / 2 \\n            y = y >> 1;\\n            x = (x * x) % p;\\n        }\\n        return res;\\n    }\\n\\n    public static void main(String args[]) {\\n        int x = 2;\\n        int y = 5;\\n        int p = 13;\\n        System.out.println(\\"La potencia es \\" + power(x, y, p));\\n    }\\n} \\n","cpp":null,"py":null,"orden":6,"suborden":39,"fecha_creacion":"2020-12-04 22:01:06","fecha_modificacion":"2020-12-06 20:23:21"},{"ID":72,"supergrupo":"Matem\xe1tica","tema":"Multiple Euler Totient","texto":"Funci\xf3n Totient de Euler de una entrada n es el conteo de n\xfameros  en {1,2,3,..., n} que sea primo relativo a n, por ejemplo, los n\xfameros los cuales su GCD con n es 1. \\nEn problemas donde tenemos que llamar a la funci\xf3n totient muchas veces como 10^5 veces, una soluci\xf3n simple puede retornar un TLE (time limit exceded). La idea es usar la criba de Erat\xf3stenes.\\nEncuentre todos los factores primos con limite en 10^5 usando la criba de Erat\xf3stenes.\\nPara realizar este F(n), se hace lo siguiente.\\n1) Inicializa el resultado como n.\\n2) Itera a trav\xe9s de todos los primos m\xe1s peque\xf1os o iguales que la ra\xedz cuadrada de n. Dejamos que el actual n\xfamero primo sea p, revisamos si p divide n, si lo hace, removemos todas las ocurrencias de p de n dividi\xe9ndolo repetidamente por n, tambi\xe9n reducimos nuestro resultado por n/p.\\n3) Finalmente retornamos nuestro resultado.\\n","complejidad_tiempo":"Mejor caso :    O(n2)  Peor caso : O(n2)  Promedio: O(n2) ","java":"// Programa java que eficientemente calcula valores de\\n// la formula totient de euler para multiples entradas\\n\\nimport java.util.*;\\n\\npublic class MultipleEulerTotient {\\n\\n    static int MAX = 100001;\\n    // Almacena n\xfameros primos arriba hasta MAX -1\\n    static ArrayList<Integer> p = new ArrayList<Integer>();\\n    // Encurntra los n\xfameros primos hasta MAX-1 Y\\n    // los almacena en p\\n\\n    static void sieve() {\\n        int[] isPrime = new int[MAX + 1];\\n        for (int i = 2; i <= MAX; i++) {\\n            // Si prime[i] no es marcado antes\\n            if (isPrime[i] == 0) {\\n                // Llena el vector para cada nuevo\\n                // primo encontrado\\n                p.add(i);\\n                for (int j = 2; i * j <= MAX; j++) {\\n                    isPrime[i * j] = 1;\\n                }\\n            }\\n        }\\n    }\\n    // Funci\xf3n que encuentra totient de n\\n\\n    static int phi(int n) {\\n        int res = n;\\n        // Este ciclo corre sqrt(n / ln(n)) veces\\n        for (int i = 0; p.get(i) * p.get(i) <= n; i++) {\\n            if (n % p.get(i) == 0) {\\n                // resta multiplos de p[i] de r\\n                res -= (res / p.get(i));\\n                // Remueve todas las ocurrencias de p[i] en n\\n                while (n % p.get(i) == 0) {\\n                    n /= p.get(i);\\n                }\\n            }\\n        }\\n        // cuando n es un factor primo mayor \\n        // que sqrt(n) \\n        if (n > 1) {\\n            res -= (res / n);\\n        }\\n        return res;\\n    }\\n\\n    public static void main(String[] args) {\\n        //Preprocesa todos los primos hasta 10 ^ 5  \\n        sieve();\\n        System.out.println(phi(11));\\n        System.out.println(phi(21));\\n        System.out.println(phi(31));\\n        System.out.println(phi(41));\\n        System.out.println(phi(51));\\n        System.out.println(phi(61));\\n        System.out.println(phi(91));\\n        System.out.println(phi(101));\\n    }\\n} \\n","cpp":null,"py":null,"orden":6,"suborden":40,"fecha_creacion":"2020-12-04 22:01:06","fecha_modificacion":"2020-12-06 20:23:22"},{"ID":73,"supergrupo":"Matem\xe1tica","tema":"12.41) Sumatoria de naturales coprimos","texto":"Dado N y M, la tarea es encontrar cuales n\xfameros de 1 a n pueden ser divididos en dos conjuntos los cuales su diferencia absoluta entre la suma de los dos sets es M y el GCD de la suma de los dos sets es 1.\\nDesde que tenemos 1 a N n\xfameros, sabemos que la suma de todos los n\xfameros es N*(N+1)/2. Dejamos S1 y S2 de esta manera:\\n1) sum(S1) + sum(S2) = N * (N + 1) / 2\\n2) sum(S1) \u2013 sum(S2) = M\\nResolviendo estas dos ecuaciones podemos dar la suma de ambos conjuntos. Si sum(S1) y sum(S2)  son enteros  y ellos son coprimos (Su GCD es 1), entonces ah\xed existe una forma de separar el n\xfamero en dos sets. De otra forma no hay forma de separar esos n\xfameros N.\\n","complejidad_tiempo":"Mejor caso :    O(log(n))  Peor caso : O(log(n))  Promedio: O(log(n)) ","java":"/* C\xf3digo de Java para determinar si los n\xfameros\\n1 a N se puede dividir en dos conjuntos\\ntal que la diferencia absoluta entre\\nla suma de estos dos conjuntos es M y estos\\ndos sum\xe1s son co-primos*/\\npublic class NaturalCoprimeSum {\\n\\n    static int GCD(int a, int b) {\\n        return b == 0 ? a : GCD(b, a % b);\\n    }\\n\\n    /*funci\xf3n que devuelve valor booleano\\n     sobre la base de si es posible\\n     dividir 1 a N n\xfameros en dos conjuntos\\n     Que satisfacen las condiciones dadas.*/\\n    static boolean isSplittable(int n, int m) {\\n        // Inicializando suma total de 1\\n        //a n \\n        int total_sum = (n * (n + 1)) / 2;\\n        /*desde (1) total_sum = sum_s1 + sum_s2 \\n        y (2) m = sum_s1 - sum_s2 asumiendo \\n        sum_s1> sum_s2. resolviendo estas 2 \\n        ecuaciones para obtener sum_s1 y sum_s2*/\\n        int sum_s1 = (total_sum + m) / 2;\\n        // total_sum = sum_s1 + sum_s2 \\n        // y asi \\n        int sum_s2 = total_sum - sum_s1;\\n        /*Si la suma total es menor que la \\n        diferencia absoluta, no hay forma \\n        de que podamos dividir n n\xfameros \\n        en dos conjuntos, as\xed que devuelva falso*/\\n        if (total_sum < m) {\\n            return false;\\n        }\\n        /*Compruebe si estas dos sum\xe1s son\\n        enteros y se suman a\\n        suma total y tambi\xe9n si su\\n        La diferencia absoluta es m.*/\\n        if (sum_s1 + sum_s2 == total_sum\\n                && sum_s1 - sum_s2 == m) // Ahora si las dos sum\xe1s son coprimos\\n        // Entonces retorna true, si no false\\n        {\\n            return (GCD(sum_s1, sum_s2) == 1);\\n        }\\n        /*si dos sum\xe1s no suman la suma total\\n          o si su diferencia absoluta.\\n         no es m, entonces no hay manera de\\n         dividir n n\xfameros, por lo tanto retorna false*/\\n        return false;\\n    }\\n\\n    public static void main(String args[]) {\\n        int n = 5, m = 7;\\n        if (isSplittable(n, m)) {\\n            System.out.println(\\"Si\\");\\n        } else {\\n            System.out.println(\\"No\\");\\n        }\\n\\n    }\\n} \\n\\n","cpp":null,"py":null,"orden":6,"suborden":41,"fecha_creacion":"2020-12-04 22:01:06","fecha_modificacion":"2020-12-06 20:23:22"},{"ID":74,"supergrupo":"Matem\xe1tica","tema":"N\xfameros de Leonardo","texto":"Los n\xfameros de Leonardo son una secuencia de n\xfameros con la recurrencia:\\n- L(0)=0\\n- L(1)=1\\n- L(n)=L(n-1)+l(n-2)+1 si n>1\\nLos primeros n\xfameros de Leonardo son 1, 1, 3, 5, 9, 15, 25, 41, 67, 109, 177, 287, 465, 753, 1219, 1973, 3193, 5167, 8361, \xb7\xb7\xb7\\nComplejidad de tiempo: Exponencial\\n","complejidad_tiempo":null,"java":"//Pograma java qque busca el nesimo n\xfamero\\n// de Leonardo\\n\\npublic class LeonardoNumber {\\n\\n    static int leonardo(int n) {\\n        if (n == 0 || n == 1) {\\n            return 1;\\n        }\\n        return (leonardo(n - 1) + leonardo(n - 2) + 1);\\n    }\\n    public static void main(String args[]) {\\n        System.out.println(leonardo(3));\\n    }\\n} \\n","cpp":null,"py":null,"orden":6,"suborden":42,"fecha_creacion":"2020-12-04 22:01:06","fecha_modificacion":"2020-12-06 20:23:23"},{"ID":75,"supergrupo":"Matem\xe1tica","tema":"Teorema de Zeckendorf","texto":"El teorema de Zeckendorf indica que cada posible entero puede ser escrito como la suma de distintos n\xfameros de Fibonacci no vecinos. Dos n\xfameros Fibonacci son vecinos si uno viene luego del otro en la secuencia (0, 1, 1, 2, 3, 5, ..). Por ejemplo 3 y 5 son vecinos pero 2 y 5 no lo son.\\nDado un n\xfamero, encontrar la representaci\xf3n del n\xfamero como la suma de n\xfameros de Fibonacci no consecutivos.\\n1) Sea n el n\xfamero de entrada\\n2) Mientras n >= 0\\na) Encontrar el Fibonacci m\xe1s grande que sea menor que n. Dejar que este n\xfamero sea \u2018f\u2019, e imprimir f.\\nb) n = n \u2013 f\\n","complejidad_tiempo":null,"java":"/*Programa java para el Teorema de Zeckendorf, \\nencuentra la representaci\xf3n de n como suma de \\nn\xfameros de fibonacci no vecinos*/\\npublic class ZeckendorfTheorem {\\n\\n    public static int nearestSmallerEqFib(int n) {\\n        // Casos base\\n        if (n == 0 || n == 1) {\\n            return n;\\n        }\\n        //Encuentra el mayor n\xfamero fibonacci menor que n \\n        int f1 = 0, f2 = 1, f3 = 1;\\n        while (f3 <= n) {\\n            f1 = f2;\\n            f2 = f3;\\n            f3 = f1 + f2;\\n        }\\n        return f2;\\n    }\\n    // Imprime representaci\xf3n de fibonacci  \\n\\n    public static void printFibRepresntation(int n) {\\n        while (n > 0) {\\n            // Encuentra el mayor n\xfamero fibonacci menor \\n            // o igual que n \\n            int f = nearestSmallerEqFib(n);\\n            // Imprime el n\xfamero fibonacci encontrado\\n            System.out.print(f + \\" \\");\\n            // Reduce n \\n            n = n - f;\\n        }\\n    }\\n\\n    public static void main(String[] args) {\\n        int n = 30;\\n        System.out.println(\\"Representaci\xf3n de fibonacci no vecinos \\"\\n                + \\" de  \\" + n + \\" es\\");\\n        printFibRepresntation(n);\\n    }\\n} \\n","cpp":null,"py":null,"orden":6,"suborden":43,"fecha_creacion":"2020-12-04 22:01:06","fecha_modificacion":"2020-12-06 20:23:23"},{"ID":76,"supergrupo":"Matem\xe1tica","tema":"Teorema de Rosser ","texto":"El teorema de Rosser dicta que el nesimo n\xfamero es mayor que el producto de n y el logaritmo natural de n para todos los n mayores a 1.\\nMatem\xe1ticamente: \\nPara n >= 1, si pn es el nesimo n\xfamero primo, entonces then:\\n- pn > n * (ln n)\\n Para n = 1, en\xe9simo n\xfamero primo = 2\\n-  2 > 1 * ln(1)\\n Para n = 2, en\xe9simo n\xfamero primo = 3\\n- 3 > 2 * ln(2)\\n Para n = 3, en\xe9simo n\xfamero primo = 5\\n- 5 > 3 * ln(3)\\n   Para n = 4, en\xe9simo n\xfamero primo = 7\\n- 7 > 4 * ln(4)\\n   Para n = 5, en\xe9simo n\xfamero primo = 11\\n- 11 > 5 * ln(5)\\n   Para n = 6, en\xe9simo n\xfamero primo = 13\\n- 13 > 6 * ln(6)\\n","complejidad_tiempo":null,"java":"// Programa java que verifica el Teorema de Rosser\\n\\nimport java.util.*;\\n\\npublic class RosserTheorem {\\n\\n    static ArrayList<Integer> prime = new ArrayList<Integer>();\\n    // Criba de Eratostenes\\n    static void sieve() {\\n        int n = 10000;\\n        boolean[] isprime = new boolean[n + 2];\\n        for (int i = 0; i < n; i++) {\\n            isprime[i] = true;\\n        }\\n        isprime[0] = false;\\n        isprime[1] = false;\\n        for (int i = 2; i <= n; i++) {\\n            if (isprime[i]) {\\n                for (int j = i * i; j <= n; j += i) {\\n                    isprime[j] = false;\\n                }\\n            }\\n        }\\n        //Almacena primos en prime[] \\n        for (int i = 0; i <= n; i++) {\\n            if (isprime[i]) {\\n                prime.add(i);\\n            }\\n        }\\n    }\\n\\n    // Verifica el TEOREMA DE  ROSSER para todos los n\xfameros  \\n    // Menores a n\\n    static void verifyRosser(int n) {\\n        System.out.println(\\"TEOREMA DE ROSSER: nesimo n\xfamero primo > n * (ln n)\\");\\n        for (int i = 0; i < n; i++) {\\n            if (prime.get(i) > (i + 1) * Math.log(i + 1)) {\\n                System.out.println(\\"para n = \\" + (i + 1)\\n                        + \\", nesimo n\xfamero primo = \\"\\n                        + prime.get(i) + \\"\\\\n\\\\t\\"\\n                        + prime.get(i) + \\" > \\" + (i + 1)\\n                        + \\" * ln(\\" + (i + 1) + \\")\\");\\n            }\\n        }\\n    }\\n\\n    public static void main(String[] args) {\\n        sieve();\\n        verifyRosser(20);\\n    }\\n} \\n","cpp":null,"py":null,"orden":6,"suborden":44,"fecha_creacion":"2020-12-04 22:01:06","fecha_modificacion":"2020-12-06 20:23:24"},{"ID":77,"supergrupo":"Matem\xe1tica","tema":"N\xfameros de Smith","texto":"Dado un n\xfamero n, la tarea encontrar si un n\xfamero es n\xfamero de Smith o no, un n\xfamero de Smith es un n\xfamero compuesto cuya suma de d\xedgitos es igual a la suma de los d\xedgitos en su factorizaci\xf3n prima.\\n- n = 4\\n- Factorizaci\xf3n prima = 2, 2  and 2 + 2 = 4\\n- Por lo tanto, 4 es un n\xfamero de Smith\\nLa idea es primero encontrar todos los factores primos por debajo de un l\xedmite usando la criba de Sundaram. (Esto es \xfatil para buscar y verificar varios n\xfameros de Smith). Ahora por cada entrada que ser\xe1 verificada como n\xfamero de Smith, atravesamos por todos los factores primos en \xe9l, y encontramos la suma de los d\xedgitos en cada factor primo. Tambi\xe9n buscamos la suma de los d\xedgitos en el n\xfamero dado. Finalmente comparamos las dos sumas, si son lo mismo, retornamos true.\\n","complejidad_tiempo":null,"java":"// Programa java que verifica si un n\xfamero es \\n// n\xfamero de Smith o no\\n\\nimport java.util.ArrayList;\\n\\npublic class SmithNumber {\\n\\n    static int MAX = 10000;\\n    //Array que almacena todos los primos menores o iguales\\n    // a 10^6\\n    static ArrayList<Integer> primes = new ArrayList<>();\\n    //Funci\xf3n de la criba de Sundaram\\n\\n    static void sieveSundaram() {\\n        /*En general criva de Sundaram, produce primos m\xe1s peque\xf1os.\\n        que (2 * x + 2) para un n\xfamero dado el n\xfamero x. Ya que\\n         Queremos primos m\xe1s peque\xf1os que MAX, reducimos MAX a la mitad\\n         Esta matriz se usa para separar n\xfameros del forma\\n         i + j + 2ij de otros donde 1 <= i <= j*/\\n        boolean marked[] = new boolean[MAX / 2 + 100];\\n        //L\xf3gica principal de Sundaram, marcar todos los n\xfameros\\n        // loc cuales no generan n\xfamero primo haciendo 2*i+1\\n        for (int i = 1; i <= (Math.sqrt(MAX) - 1) / 2; i++) {\\n            for (int j = (i * (i + 1)) << 1; j <= MAX / 2; j = j + 2 * i + 1) {\\n                marked[j] = true;\\n            }\\n        }\\n\\n        // 2s es n\xfamero primo\\n        primes.add(2);\\n        // Imprime los otros primos, primos restantes son de la \\n        //forma 2*i+1 de tal manera que marked[i] es falso\\n        for (int i = 1; i <= MAX / 2; i++) {\\n            if (marked[i] == false) {\\n                primes.add(2 * i + 1);\\n            }\\n        }\\n    }\\n    // Retorna true si n es un n\xfamero de Smith, si no falso \\n\\n    static boolean isSmith(int n) {\\n        int original_no = n;\\n        // Encuentra la suma de los digitos de los factores \\n        //  primos de n\\n        int pDigitSum = 0;\\n        for (int i = 0; primes.get(i) <= n / 2; i++) {\\n            while (n % primes.get(i) == 0) {   // Si primes[i] es un factor primo\\n                // agrega sus digitos a pDigitSum\\n                int p = primes.get(i);\\n                n = n / p;\\n                while (p > 0) {\\n                    pDigitSum += (p % 10);\\n                    p = p / 10;\\n                }\\n            }\\n        }\\n        /*Si n!=! entonces un primo sigue para ser sumado*/\\n        if (n != 1 && n != original_no) {\\n            while (n > 0) {\\n                pDigitSum = pDigitSum + n % 10;\\n                n = n / 10;\\n            }\\n        }\\n        // Todos los factores primos sumados \\n        // Ahora suma los digitos del n\xfamero original \\n        int sumDigits = 0;\\n        while (original_no > 0) {\\n            sumDigits = sumDigits + original_no % 10;\\n            original_no = original_no / 10;\\n        }\\n        // Si la suma de los digistos en factores primos \\n        // y la suma de digitos en el n\xfamero original son los mismos\\n        // entonces true, si no false\\n        return (pDigitSum == sumDigits);\\n    }\\n\\n    public static void main(String[] args) {   //Encuentra todos los n\xfameros primos antes del limite\\n        // estos n\xfameros son usados para encontrar factores primos\\n        sieveSundaram();\\n        System.out.println(\\"Imprimiento primeros n\xfameros de Smith\\"\\n                + \\" usando isSmith()\\");\\n        for (int i = 1; i < 500; i++) {\\n            if (isSmith(i)) {\\n                System.out.print(i + \\" \\");\\n            }\\n        }\\n    }\\n} \\n","cpp":null,"py":null,"orden":6,"suborden":45,"fecha_creacion":"2020-12-04 22:01:06","fecha_modificacion":"2020-12-06 20:23:25"},{"ID":78,"supergrupo":"Matem\xe1tica","tema":"N\xfameros esf\xe9nicos","texto":"Un n\xfamero esc\xe9nico es un entero positivo el cual es el producto de exactamente tres primos distintos, los primeros n\xfameros esf\xe9nicos son 30, 42, 66, 70, 78, 102, 105, 110, 114,\u2026\\nDado un n\xfamero n, determine si es un n\xfamero esfenico o no.\\nUn n\xfamero esfenico puede ser verificado generando los \xfaltimos factores primos de los n\xfameros hasta n.\\nLuego podemos simplemente dividir el n\xfamero por sus factores primos y luego ese n\xfamero por sus factores primos, y as\xed en Adelante, y luego verificar si el n\xfamero tiene exactamente 3 factores primos distintos.\\nComplejidad de tiempo: O (nlog(n))\\n","complejidad_tiempo":null,"java":"// Programa JAVA que verifica si un n\xfamero\\n// es esfenico o no\\n\\nimport java.util.ArrayList;\\nimport java.util.Collections;\\nimport java.util.HashSet;\\nimport java.util.Set;\\n\\npublic class SphenicNumber {\\n\\n    static final int MAX = 1000;\\n    //Crea un vector donde almacenar primos\\n    // inicializa todas las entradas en 0\\n    static ArrayList<Integer> least_pf = new ArrayList<>(MAX);\\n\\n    /* Esta funci\xf3n llena valores en least_pf[]\\n    de tal modod que el valor de least_pf[] almacene\\n    el factor primo m\xe1s peque\xf1o de i\\n    Se encuentra basado en la criba\\n    de Eratostenes*/\\n    public static void main(String[] args) {\\n        for (int i = 0; i < 1001; i++) {\\n            least_pf.add(0);\\n        }\\n        Collections.fill(least_pf, 0);\\n        leastPrimeFactor(MAX);\\n        for (int i = 1; i < 100; i++) {\\n            if (isSphenic(i)) {\\n                System.out.println(i + \\" \\");\\n            }\\n        }\\n\\n    }\\n    /*Funci\xf3n que verifica si un n\xfamero es esfenico*/\\n    static boolean isSphenic(int n) {\\n        /*Almacena tres factores primos de n\\n        tenemos al menos 3 elementos en s*/\\n        Set<Integer> s = new HashSet<>();\\n        // Siga encontrando factores primos hasta que n sea 1\\n        while (n > 1) {\\n            // Encuenta al menos un factor del actual valor de n\\n            int lpf = least_pf.get(n);\\n            // Almacenamos actual tama\xf1o de s para verificar si\\n            //algun factor primo se repite\\n            int init_size = s.size();\\n            // Inserta un valor primo al actual valor de n\\n            s.add(lpf);\\n            // si lpf repite un n\xfamero o se pasa de 3, retorna falso. \\n            if (s.size() == init_size || s.size() > 3) // El mismo primo divide\\n            // un n\xfamero m\xe1s de una vez\\n            {\\n                return false;\\n            }\\n            // dividir n en lpf\\n            n /= lpf;\\n        }\\n        // True si el tama\xf1o es 3\\n        return (s.size() == 3);\\n    }\\n\\n    static void leastPrimeFactor(int n) {\\n        // un factor primo de 1 es 1\\n        least_pf.set(1, 1);\\n        // Almacena n\xfameros primos para todos \\n        // los otros n\xfameros\\n        for (int i = 2; i <= n; i++) {\\n            // least_pf[i] == 0 significa que i es primo\\n            if (least_pf.get(i) == 0) {\\n                least_pf.set(i, i);\\n                for (int j = 2 * i; j <= n; j += i) {\\n                    if (least_pf.get(j) == 0) {\\n                        least_pf.set(j, i);\\n                    }\\n                }\\n\\n            }\\n        }\\n    }\\n} \\n","cpp":null,"py":null,"orden":6,"suborden":46,"fecha_creacion":"2020-12-04 22:01:06","fecha_modificacion":"2020-12-06 20:23:25"},{"ID":79,"supergrupo":"Matem\xe1tica","tema":"Identidad de Cassini","texto":"La identidad de Cassini y la identidad de Catalan son relaciones matem\xe1ticas ligadas con los n\xfameros de la sucesi\xf3n de Fibonacci, afirma que para cada n\xfamero n-\xe9simo de la sucesi\xf3n de Fibonacci, se cumple que:\\n- Fn-1 x Fn+1-F^2n=(-1)^n\\n","complejidad_tiempo":null,"java":"//Programa java que demuestra \\n// la identidad de Cassini\\n\\npublic class CassiniIdentity {\\n    // Retorna (-1)^n \\n    static int cassini(int n) {\\n        return (n & 1) != 0 ? -1 : 1;\\n    }\\n\\n    public static void main(String args[]) {\\n        int n = 5;\\n        System.out.println(cassini(n));\\n    }\\n}\\n","cpp":"#include<bits/stdc++.h>\\n#include<cstdlib>\\nusing namespace std;\\nint cassini(int n){\\n    return (n&1)!=0? -1 : 1;\\n}\\nint main(){\\n    int n=5;\\n    printf(\\"%d\\\\n\\",cassini(n));\\n} \\n","py":null,"orden":6,"suborden":47,"fecha_creacion":"2020-12-04 22:01:06","fecha_modificacion":"2020-12-06 20:23:26"},{"ID":80,"supergrupo":"Matem\xe1tica","tema":"N\xfameros de Catalan ","texto":"En combinatoria, los n\xfameros de Catalan forman una secuencia de n\xfameros naturales que aparece en varios problemas de conteo que habitualmente son recursivos. Obtienen su nombre del matem\xe1tico belga Eug\xe8ne Charles Catalan (1814\u20131894).\\nEl n-\xe9simo n\xfamero de Catalan se obtiene, aplicando coeficientes binomiales, a partir de la siguiente f\xf3rmula:\\nCn=  (2n)!/(n+1)!n!\\n","complejidad_tiempo":null,"java":"//Programa Java que recursivamente encuentra el\\n// nesimo n\xfamero Catalan \\n\\npublic class CatalanNumber {\\n\\n    public static int catalan(int n) {\\n        int res = 0;\\n        // Caso base\\n        if (n <= 1) {\\n            return 1;\\n        }\\n        for (int i = 0; i < n; i++) {\\n            res += catalan(i) * catalan(n - i - 1);\\n        }\\n        return res;\\n    }\\n\\n    public static void main(String[] args) {\\n        for (int i = 0; i < 10; i++) {\\n            System.out.print(catalan(i) + \\" \\");\\n        }\\n    }\\n} \\n","cpp":null,"py":null,"orden":6,"suborden":48,"fecha_creacion":"2020-12-04 22:01:06","fecha_modificacion":"2020-12-06 20:23:27"},{"ID":81,"supergrupo":"Matem\xe1tica","tema":"N\xfameros de Charmichael","texto":"Un n\xfamero n es un n\xfamero de Carmichael si satisface la siguiente condici\xf3n aritm\xe9tica modular:\\n- pow(b, n-1) MOD n = 1, \\nPara todos los b en rango de 1 a n tal que b y n son relativos primos gcd(b, n) = 1 .\\nDado un entero positivo n, encontrar si es un n\xfamero de Carmichael, estos n\xfameros tienen importancia en el m\xe9todo de Fermat para el test de primalidad.\\n","complejidad_tiempo":null,"java":"//Programa java que verifica si un n\xfamero\\n// es un n\xfamero de carmichael\\n\\npublic class CarmichaelNumbers {\\n\\n//funci\xf3n que busca el GCD de dos n\xfameros\\n    static int gcd(int a, int b) {\\n        if (a < b) {\\n            return gcd(b, a);\\n        }\\n        if (a % b == 0) {\\n            return b;\\n        }\\n        return gcd(b, a % b);\\n    }\\n    //Funci\xf3n que busca el pow(x,y)\\n    // bajo un modulo mod\\n    static int power(int x, int y, int mod) {\\n        if (y == 0) {\\n            return 1;\\n        }\\n        int temp = power(x, y / 2, mod) % mod;\\n        temp = (temp * temp) % mod;\\n        if (y % 2 == 1) {\\n            temp = (temp * x) % mod;\\n        }\\n        return temp;\\n    }\\n\\n//Funci\xf3n que verifica si un n\xfamero es n\xfamero de charmichael\\n    static int isCarmichaelNumber(int n) {\\n        for (int b = 2; b < n; b++) {\\n            // Si \'b\' es primo relativo de n\\n            if (gcd(b, n) == 1) // y pow(b, n-1)%n no es 1,\\n            // retorne falso\\n            {\\n                if (power(b, n - 1, n) != 1) {\\n                    return 0;\\n                }\\n            }\\n        }\\n        return 1;\\n    }\\n\\n    public static void main(String args[]) {\\n        System.out.println(isCarmichaelNumber(500));\\n        System.out.println(isCarmichaelNumber(561));\\n        System.out.println(isCarmichaelNumber(1105));\\n    }\\n} \\n","cpp":null,"py":null,"orden":6,"suborden":49,"fecha_creacion":"2020-12-04 22:01:06","fecha_modificacion":"2020-12-06 20:23:27"},{"ID":82,"supergrupo":"Matem\xe1tica","tema":"Secuencia Stern-Brocot","texto":"La secuencia de Stern Brocot es similar la secuencia de Fibonacci, pero es diferente en la forma en que la secuencia es generada.\\n1) Primero y segundo elemento de la secuencia es 1 y 1.\\n2) Considere el segundo miembro de la secuencia, luego sume el miembro considerado de la secuencia y su predecesor, por ejemplo (1+1=2) ahora 2 es el siguiente elemento de nuestra serie, la secuencia ser\xe1 [1,1,2].\\n3) Despu\xe9s de este elemento, nuestro siguiente elemento en la secuencia ser\xe1 considerado el elemento en nuestro segundo paso, ahora la secuencia seria [1,1,2,1].\\n4) De nuevo realizamos el paso 2, pero ahora consideramos el elemento 2 (Tercer elemento), entonces nuestro siguiente n\xfamero de la secuencia ser\xe1 la suma de los n\xfameros considerados, y su predecesor(2+1=3), la secuencia ahora ser\xe1 [1,1,2,1,3]\\n5) Como en el paso 3, el siguiente elemento ser\xe1 considerado, por ejemplo 2, la secuencia ser\xe1 [1,1,2,1,3,2]\\n6) El proceso continua, nuestro elemento considerado ser\xe1 1(Cuarto elemento).\\n","complejidad_tiempo":null,"java":"// Programa java que imprime   \\n// La secuencia de Stern Brocot\\n\\nimport java.util.*;\\n\\npublic class SternBrocotSequence {\\n\\n    static void SternSequenceFunc(ArrayList<Integer> BrocotSequence, int n) {\\n        // Ciclo que crea la secuencia\\n        for (int i = 1; BrocotSequence.size() < n; i++) {\\n            int considered_element = BrocotSequence.get(i);\\n            int precedent = BrocotSequence.get(i - 1);\\n            //Agregando la suma de los elementos considerados\\n            // y son precedentes\\n            BrocotSequence.add(considered_element + precedent);\\n            //  Agregando siguiente elemento considerado \\n            BrocotSequence.add(considered_element);\\n        }\\n        // Imprimiendo secuencia\\n        for (int i = 0; i < 15; ++i) {\\n            System.out.print(BrocotSequence.get(i) + \\" \\");\\n        }\\n    }\\n\\n    public static void main(String[] args) {\\n        int n = 15;\\n        ArrayList<Integer> BrocotSequence = new ArrayList<Integer>();\\n        // Agregando primer y segundo valor \\n        // A la secuencia\\n        BrocotSequence.add(1);\\n        BrocotSequence.add(1);\\n        SternSequenceFunc(BrocotSequence, n);\\n    }\\n} \\n","cpp":null,"py":null,"orden":6,"suborden":50,"fecha_creacion":"2020-12-04 22:01:06","fecha_modificacion":"2020-12-06 20:23:28"},{"ID":83,"supergrupo":"Matem\xe1tica","tema":"Secuencia Sylvester","texto":"El en sistema num\xe9rico, La secuencia de Sylvester es una secuencia de enteros la cual cada miembro es un producto de los n\xfameros previos, m\xe1s uno, dado un entero positivo N, imprima los primeros N miembros de la secuencia.\\nLos n\xfameros pueden ser muy largos, se usa %10^9 + 7.\\nLa idea es correr un ciclo y tomar dos variables, inicializarlos como 1 y 2, uno para almacenar el producto hasta ahora, y el otro para almacenar el n\xfamero actual el cual es el primer n\xfamero +1 y por cada paso, multiplicar ambos usando aritm\xe9tica modular, por ejemplo (a + b)%N = (a%N + b%N)%N  donde N es un n\xfamero modular.\\n","complejidad_tiempo":null,"java":"//Implementaci\xf3n java de la secuencia Sylvester  \\n\\npublic class SylvesterSequence {\\n\\n    public static void printSequence(int n) {\\n        int a = 1; // Para almacenar el producto\\n        int ans = 2; // Para almacenar el n\xfamero actual\\n        int N = 1000000007;\\n        //Ciclo hasta n\\n        for (int i = 1; i <= n; i++) {\\n            System.out.print(ans + \\" \\");\\n            ans = ((a % N) * (ans % N)) % N;\\n            a = ans;\\n            ans = (ans + 1) % N;\\n        }\\n    }\\n\\n    public static void main(String[] args) {\\n        int n = 6;\\n        printSequence(n);\\n\\n    }\\n} \\n","cpp":null,"py":null,"orden":6,"suborden":51,"fecha_creacion":"2020-12-04 22:01:06","fecha_modificacion":"2020-12-06 20:23:28"},{"ID":84,"supergrupo":"Matem\xe1tica","tema":"Secuencia Aliquot ","texto":"Dado un n\xfamero n, la tarea es imprimir su secuencia de Aliquot. La secuencia de Aliquot de un n\xfamero empieza con el mismo, t\xe9rminos restantes de la secuencia son la suma de los divisores propios del t\xe9rmino inmediatamente anterior.\\n\\nPor ejemplo, la secuencia de Aliquot de 10, es 10,8,7,1,0. La secuencia puede repetir. Por ejemplo para 6, tenemos una secuencia infinita de todos los 6, En esos casos              imprimimos el n\xfamero repetido y paramos.\\n- N\xfameros los cuales tienen una secuencia de Aliquot repetitiva de longitud 1 son llamados n\xfameros perfectos. Por ejemplo 6, suma de sus divisores propios es 6.\\n- N\xfameros  que tienen una secuencia de Aliquot repetitiva de tama\xf1o 2 son llamados n\xfameros de Amicable. Por ejemplo 220 es un n\xfamero de Amicable.\\n- N\xfameros que tienen secuencia de Aliquot repetitiva de tama\xf1o 3 son llamados n\xfameros sociales\\nPodemos generar la secuencia primero imprimiendo el n\xfamero n y luego calculando los siguientes t\xe9rminos usando la suma de los divisores propios. Cuando computemos el siguiente termino, verificamos si nosotros ya hab\xedamos visto ese t\xe9rmino o no, si el t\xe9rmino aparece de nuevo tenemos una secuencia repetida, imprimimos el mismo y rompemos el ciclo. \\n","complejidad_tiempo":null,"java":"//Implementaci\xf3n java de una apoximaci\xf3n\\n// de la secuencia Aliquot \\n\\nimport java.util.*;\\n\\npublic class AliquotSequence {\\n    // Funci\xf3n que calcula suma de \\n    // los divisores adecuados\\n    static int getSum(int n) {\\n        int sum = 0; // 1 es un divisor adecuado\\n        for (int i = 1; i <= Math.sqrt(n); i++) {\\n            if (n % i == 0) {   // Si divisores son iguales, solo toma uno \\n                if (n / i == i) {\\n                    sum = sum + i;\\n                } else // Si no tome ambos\\n                {\\n                    sum = sum + i;\\n                    sum = sum + (n / i);\\n                }\\n            }\\n        }\\n        // Calcula la suma de los divisores adecuados\\n        return sum - n;\\n    }\\n\\n    static void printAliquot(int n) {\\n        // Imprime el primer termino\\n        System.out.printf(\\"%d \\", n);\\n        TreeSet<Integer> s = new TreeSet<>();\\n        s.add(n);\\n\\n        int next = 0;\\n        while (n > 0) {   // Calcula siguiente termino desde el anterior\\n            n = getSum(n);\\n            if (s.contains(n) && n != s.last()) {\\n                System.out.print(\\"\\\\nRepeats with \\" + n);\\n                break;\\n            }\\n            //Imprimir siguiente termino\\n            System.out.print(n + \\" \\");\\n            s.add(n);\\n        }\\n    }\\n\\n    public static void main(String[] args) {\\n        printAliquot(12);\\n    }\\n} \\n","cpp":null,"py":null,"orden":6,"suborden":52,"fecha_creacion":"2020-12-04 22:01:06","fecha_modificacion":"2020-12-06 20:23:29"},{"ID":85,"supergrupo":"Matem\xe1tica","tema":"Secuencia Juggler","texto":"La secuencia de Juggles es una serie de n\xfameros enteros la cual su primer t\xe9rmino comienza con un entero positivo y los t\xe9rminos restantes son generados de los anteriores inmediatos n\xfameros.\\nLa secuencia Juggler comenzando con el n\xfamero 3: 5, 11, 36, 6, 2, 1\\nLa secuencia Juggler comenzando desde el n\xfamero 9:  9, 27, 140, 11, 36, 6, 2, 1\\nDado un n\xfamero n tenemos que imprimir la secuencia Juggler de este n\xfamero como el primer n\xfamero de la secuencia\\n- Los t\xe9rminos en la secuencia de Juggler primero crecen hasta un valor pico, y luego empiezan a decrecer.\\n- El \xfaltimo t\xe9rmino de la secuencia de Juggler es siempre 1.\\n","complejidad_tiempo":null,"java":"// Implementaci\xf3n java de la secuenca de Juggler\\n\\npublic class JugglerSequence {\\n\\n    static void printJuggler(int n) {\\n        int a = n;\\n        // Imprime el primer termino\\n        System.out.print(a + \\" \\");\\n        // Calcula terminos hasta que el ultimo no sea 1\\n        while (a != 1) {\\n            int b = 0;\\n            // Verifica si los previos terminos son pares o impares\\n            if (a % 2 == 0) // calcular siguiente termino\\n            {\\n                b = (int) Math.floor(Math.sqrt(a));\\n            } else // para impar anterior, calcular \\n            // Siguiente termino\\n            {\\n                b = (int) Math.floor(Math.sqrt(a)\\n                        * Math.sqrt(a) * Math.sqrt(a));\\n            }\\n            System.out.print(b + \\" \\");\\n            a = b;\\n        }\\n    }\\n\\n    public static void main(String[] args) {\\n        printJuggler(3);\\n        System.out.println();\\n        printJuggler(9);\\n    }\\n} \\n","cpp":null,"py":null,"orden":6,"suborden":53,"fecha_creacion":"2020-12-04 22:01:06","fecha_modificacion":"2020-12-06 20:23:30"},{"ID":86,"supergrupo":"Matem\xe1tica","tema":"Secuencia Moser de Brujin","texto":"Dado un entero n, imprima los primeros n t\xe9rminos de la secuencia de Moser de Brujin.\\nLa secuencia de Moser de Brujin es una secuencia obtenida adicionando las distintas potencias del n\xfamero 4, por ejemplo 1,4,16,6..\\nDebe notarse aqu\xed que cualquier n\xfamero el cual es la suma de potencias de 4 no distintas no son parte de la secuencia, por ejemplo 8 no es parte de la secuencia debido a que es formado de la suma de no distintas potencias de 4, que son 4 y 4.\\nPor lo tanto cualquier n\xfamero el cual no sea una potencia de 4 y est\xe1 presente en la secuencia debe ser la suma de distintas potencias de 4.\\nPor ejemplo, 21 es parte de la secuencia, incluso a trav\xe9s de que no es una potencia de 4 porque es la suma de distintas potencias de 4, que son 1,4 y 16.\\n","complejidad_tiempo":null,"java":"// Codigo java que genera los primeros n terminos\\n// de la secuencia de  Moser-de Bruijn \\n\\npublic class MoserdeBruijnSequence {\\n\\n    public static int gen(int n) {\\n        // S(0) = 0 \\n        if (n == 0) {\\n            return 0;\\n        } // S(1) = 1 \\n        else if (n == 1) {\\n            return 1;\\n        } // S(2 * n) = 4 * S(n) \\n        else if (n % 2 == 0) {\\n            return 4 * gen(n / 2);\\n        } // S(2 * n + 1) = 4 * S(n) + 1 \\n        else if (n % 2 == 1) {\\n            return 4 * gen(n / 2) + 1;\\n        }\\n        return 0;\\n    }\\n\\n    public static void moserDeBruijn(int n) {\\n        for (int i = 0; i < n; i++) {\\n            System.out.print(gen(i) + \\" \\");\\n        }\\n        System.out.println();\\n    }\\n\\n    public static void main(String args[]) {\\n        int n = 15;\\n        System.out.println(\\"Primeros \\" + n\\n                + \\" terminos de la secuencia de  \\"\\n                + \\"Moser-de Bruijn  : \\");\\n        moserDeBruijn(n);\\n    }\\n} \\n","cpp":null,"py":null,"orden":6,"suborden":54,"fecha_creacion":"2020-12-04 22:01:06","fecha_modificacion":"2020-12-06 20:23:30"},{"ID":87,"supergrupo":"Matem\xe1tica","tema":"Secuencia Newman-Conway","texto":"La secuencia de  Newman-Conway es aquella que genera la siguiente secuencia de enteros:\\n1 1 2 2 3 4 4 4 5 6 7 7\u2026\\nEn t\xe9rminos matem\xe1ticos, la secuencia P(n) de Newman-Conway es definida por la siguiente relaci\xf3n de recurrencia:\\n- P(n) = P(P(n - 1)) + P(n - P(n - 1)) with seed values P(1) = 1 and P(2) = 1\\nDado un n\xfamero n, imprima el en\xe9simo n\xfamero de la secuencia Newman-Conway\\nComplejidad de tiempo: O(n)\\n","complejidad_tiempo":null,"java":"// Programa java que encuentra el nesimo  \\n// elemento de la secuencia de  Newman-Conway\\n\\npublic class NewmanConwaySequence {\\n\\n    static int sequence(int n) {\\n        if (n == 1 || n == 2) {\\n            return 1;\\n        } else {\\n            return sequence(sequence(n - 1))\\n                    + sequence(n - sequence(n - 1));\\n        }\\n    }\\n\\n    static int sequenceDP(int n) {\\n        int f[] = new int[n + 1];\\n        int i;\\n        f[0] = 0;\\n        f[1] = 1;\\n        f[2] = 1;\\n\\n        for (i = 3; i <= n; i++) {\\n            f[i] = f[f[i - 1]] + f[i - f[i - 1]];\\n        }\\n        return f[n];\\n    }\\n\\n    public static void main(String args[]) {\\n        int n = 10;\\n        System.out.println(sequence(n));\\n    }\\n} \\n","cpp":null,"py":null,"orden":6,"suborden":55,"fecha_creacion":"2020-12-04 22:01:06","fecha_modificacion":"2020-12-06 20:23:31"},{"ID":88,"supergrupo":"Matem\xe1tica","tema":"Secuencia Padovan","texto":"La secuencia de Padovan es similar a la secuencia de Fibonacci, con una secuencia recursiva similar cuya f\xf3rmula es: \\n- P(n) = P(n-2) + P(n-3)\\n-  P(0) = P(1) = P(2) = 1 \\n","complejidad_tiempo":null,"java":"// Programa JAVA que encuentra el enesimo termino\\n// de la secuencia de Padovan\\n// usando programaci\xf3n dinamica  \\n\\npublic class PadovanSequence {\\n\\n    /* Funci\xf3n que calcula el n\xfamero de Padovan*/\\n    static int pad(int n) {   //0,1 y 2 n\xfamero de la serie es 1\\n        int pPrevPrev = 1, pPrev = 1,\\n                pCurr = 1, pNext = 1;\\n        for (int i = 3; i <= n; i++) {\\n            pNext = pPrevPrev + pPrev;\\n            pPrevPrev = pPrev;\\n            pPrev = pCurr;\\n            pCurr = pNext;\\n        }\\n        return pNext;\\n    }\\n\\n    public static void main(String args[]) {\\n        int n = 12;\\n        System.out.println(pad(n));\\n    }\\n} \\n\\n","cpp":null,"py":null,"orden":6,"suborden":56,"fecha_creacion":"2020-12-04 22:01:06","fecha_modificacion":"2020-12-06 20:23:32"},{"ID":89,"supergrupo":"Matem\xe1tica","tema":"Secuencia Recaman","texto":"Dado un entero n, imprima los primeros n elementos de la secuencia de Recaman\\nEs b\xe1sicamente una funci\xf3n con dominio y co dominio como n\xfameros naturales y 0, su recursividad se define de la siguiente manera.\\nEspec\xedficamente, dejamos a(n) denotar el (n+1)simo termino (0 ya est\xe1 ah\xed).\\nLa regla dice:\\n- a(0) = 0,\\n- Si n > 0 y el n\xfamero no est\xe1 incluido en la secuencia \\n- a(n) = a(n - 1) - n \\n- si no\\n- a(n) = a(n-1) + n. \\nComplejidad de tiempo: O(n^2)\\n","complejidad_tiempo":null,"java":"// Programa java que imprime el nesimo n\xfamero\\n// de la secuencia de Recaman\\n\\npublic class RecamanSequence {\\n\\n    static void recaman(int n) {   \\n        //Crea un array que almacenara los terminos\\n        int arr[] = new int[n];\\n        // Primer termino de la secuencia es siempre 0\\n        arr[0] = 0;\\n        System.out.print(arr[0] + \\" ,\\");\\n        // Llena terminos restantes usando formula recursiva\\n        for (int i = 1; i < n; i++) {\\n            int curr = arr[i - 1] - i;\\n            int j;\\n            for (j = 0; j < i; j++) {   \\n   // si arr[i-1] - i es negativo or ya existe \\n                if ((arr[j] == curr) || curr < 0) {\\n                    curr = arr[i - 1] + i;\\n                    break;\\n                }\\n            }\\n            arr[i] = curr;\\n            System.out.print(arr[i] + \\", \\");\\n        }\\n    }\\n\\n    public static void main(String[] args) {\\n        int n = 17;\\n        recaman(n);\\n    }\\n} \\n","cpp":null,"py":null,"orden":6,"suborden":57,"fecha_creacion":"2020-12-04 22:01:06","fecha_modificacion":"2020-12-06 20:23:32"},{"ID":90,"supergrupo":"Geometr\xeda","tema":"Longitud de arco","texto":"Un \xe1ngulo se forma cuando dos rayos se encuentran en un punto en un plano, esos rayos forman  los lados del \xe1ngulo, y el punto de encuentro es referido como el v\xe9rtice del \xe1ngulo. Hay que tener en cuenta que el plano que forma un \xe1ngulo no tiene que ser un plano Euclidiano, ahora en un c\xedrculo el largo de un arco es una porci\xf3n de la circunferencia.\\nDado un \xe1ngulo y el di\xe1metro de un c\xedrculo, podemos calcular el largo de un arco usando la f\xf3rmula:\\n- ArcLength = ( 2 * pi * radio ) * ( \xe1ngulo / 360 )\\n- Donde  pi = 22/7,\\n- Di\xe1metro = 2 * radio,\\n- El \xe1ngulo est\xe1 en grados.\\nSi el \xe1ngulo es mayor o igual a 360 grados, entonces el largo del arco no puede ser calculado desde que ning\xfan \xe1ngulo es posible.\\n","complejidad_tiempo":"Mejor caso :    O(1)  Peor caso : O(1)  Promedio: O(1) ","java":"//Programa java que calcula \\n//la longitud de un arco \\n\\npublic class ArcLength {\\n\\n    static double arcLength(double diameter,\\n            double angle) {\\n        double pi = 22.0 / 7.0;\\n        double arc;\\n        if (angle >= 360) {\\n            System.out.println(\\"Angulo no puede ser fromado\\");\\n            return 0;\\n        } else {\\n            arc = (pi * diameter) * (angle / 360.0);\\n            return arc;\\n        }\\n    }\\n\\n    public static void main(String args[]) {\\n        double diameter = 25.0;\\n        double angle = 45.0;\\n        double arc_len = arcLength(diameter, angle);\\n        System.out.println(arc_len);\\n    }\\n}\\n","cpp":"#include<bits/stdc++.h>\\n#include<cstdlib>\\n#define PI 22/7\\n//---------------//\\nusing namespace std;\\ntypedef long double ld;\\nld arcLen(ld diametro,ld angulo){\\n    ld arc;\\n    if(angulo>=360){\\n        cout<<\\"el angulo no puede ser formado\\"<<endl;\\n        return 0;\\n    }\\n    else{\\n        arc=(PI*diametro)*(angulo/360);\\n        return arc;\\n    }\\n}\\nld DegToRad(ld d){\\n    return ((d * PI )/ 180);\\n}\\nld RagToDeg(ld r){\\n    return ((r * 180 )/ PI);\\n}\\nint main() {\\n    ld d=5000;\\n    ld angle=140.5;\\n    printf(\\"%.5llf\\",arcLen(d,angle));\\n}\\n","py":"from sys import stdin, stdout\\nrl = stdin.readline\\nwr = stdout.write\\n\\ndef arclen(diametro, angulo):\\n    pi = 22 / 7\\n    arc = 0\\n    if angulo >= 360:\\n        wr(f\'Angulo no puede ser formado\')\\n        return 0\\n    else:\\n        arc = (pi * diametro) * (angulo / 360)\\n        return arc\\n\\nd = 5000\\nangle = 140.5\\nwr(f\'{arclen(d,angle)}\')\\n\\n","orden":7,"suborden":0,"fecha_creacion":"2020-12-04 23:04:25","fecha_modificacion":"2020-12-06 20:25:37"},{"ID":91,"supergrupo":"Geometr\xeda","tema":"Area de un sector circular","texto":"Un sector circular o un sector c\xedrculo, es la porci\xf3n de un disco encerrado por dos radios y un arco, donde el \xe1rea m\xe1s peque\xf1a es conocida como el sector menor y el grande como el sector mayor.\\n- Sector =(pi*r^2)*(Angulo/360)\\nEl \xe1rea de un sector es similar al c\xe1lculo del \xe1rea de un c\xedrculo, solo se le multiplica el \xe1rea de un c\xedrculo con el \xe1ngulo del sector.\\n","complejidad_tiempo":"Mejor caso :    O(1)  Peor caso : O(1)  Promedio: O(1) ","java":"// Programa java que encuentra el area de un sector circular\\n\\npublic class AreaCircularSector {\\n\\n    static void SectorArea(double radius, double angle) {\\n        if (angle >= 360) {\\n            System.out.println(\\"Angle not possible\\");\\n        } // Calculando el area\\n        else {\\n            double sector = ((22 * radius * radius) / 7)\\n                    * (angle / 360);\\n            System.out.println(sector);\\n        }\\n    }\\n\\n    public static void main(String[] args) {\\n        double radius = 9;\\n        double angle = 60;\\n        SectorArea(radius, angle);\\n    }\\n}\\n","cpp":"#include<bits/stdc++.h>\\n#include<cstdlib>\\n#define PI 22/7\\n//---------------//\\nusing namespace std;\\ntypedef long double ld;\\nvoid setCir(ld radio,ld angle){\\n    if(angle>=360){\\n        cout<<\\"el angulo no es posible\\"<<endl;\\n    }else{\\n        ld sector=((22*radio*radio)/7)*(angle/360);\\n        printf(\\"%.8llf\\\\n\\",sector);\\n    }\\n}\\nint main() {\\n    ld radio=6;\\n    ld angle=22.7;\\n    setCir(radio,angle);\\n} \\n","py":null,"orden":7,"suborden":1,"fecha_creacion":"2020-12-04 23:04:26","fecha_modificacion":"2020-12-06 20:25:38"},{"ID":92,"supergrupo":"Geometr\xeda","tema":"Circulo circunscrito en un tri\xe1ngulo equil\xe1tero","texto":"Dado el largo de los lados de un tri\xe1ngulo equil\xe1tero, necesitamos encontrar el \xe1rea de un circuncirculo del tri\xe1ngulo dado. Todos los lados del tri\xe1ngulo equil\xe1tero son de igual largo, y todos los \xe1ngulos interiores son de 60 grados.\\nLas propiedades de un circuncirculo son las siguientes:\\n- El centro del circuncirculo es el punto donde las medianas del tri\xe1ngulo equil\xe1tero se intersectan.\\n- El circulo circuncirculo de un tri\xe1ngulo equil\xe1tero es hecho a trav\xe9s de los tres v\xe9rtices de un tri\xe1ngulo equil\xe1tero.\\n- El radio de un circuncirculo de un tri\xe1ngulo equil\xe1tero es igual a (a/v3), donde \u2018a\u2019 es el largo de los lados del tri\xe1ngulo equil\xe1tero\\nLa f\xf3rmula usada para calcular el \xe1rea de un c\xedrculo circuncirculo es:\\n-  (p*a^2)/3\\nDonde a es el largo del lado del tri\xe1ngulo dado.\\nSabemos que el \xe1rea de un circulo es p*r^2, donde r es el radio del circulo dado. \\nTambi\xe9n sabemos que el radio de un circuncirculo de un tri\xe1ngulo equil\xe1tero = (Lado del tri\xe1ngulo/v3. \\nPor lo tanto, \xe1rea = p*r^2 = p*a^2/3.\\n","complejidad_tiempo":"Mejor caso :    O(1)  Peor caso : O(1)  Promedio: O(1) ","java":"// c\xf3digo Java para encontrar el \xe1rea de\\n// un c\xedrculo curcunscripto a un tri\xe1ngulo equil\xe1tero\\n\\npublic class CircumscribedCircleOfEquilateral {\\n\\n    static double PI = 3.14159265;\\n    //Funci\xf3n que encuentra el area\\n    // del circulo circumscrito\\n    public static double area_cicumscribed(double a) {\\n        return (a * a * (PI / 3));\\n    }\\n\\n    public static void main(String[] args) {\\n        double a = 6.0;\\n        System.out.println(\\"Area of circumscribed circle is :\\"\\n                + area_cicumscribed(a));\\n    }\\n}\\n","cpp":"#include<bits/stdc++.h>\\n#include<cstdlib>\\n#define PI 22/7\\n//---------------//\\nusing namespace std;\\ntypedef long double ld;\\nld areaEquilatero(ld lado){\\n    return (lado*lado*(PI/3));\\n}\\nint main() {\\n    ld a=6;\\n    printf(\\"%.8llf\\",areaEquilatero(a));\\n}\\n","py":"from sys import stdin, stdout\\nimport math\\nrl = stdin.readline\\nwr = stdout.write\\n\\ndef area_circumscribed(a):\\n    return (a * a * (math.pi / 3))\\n\\na = int(rl())\\nwr(f\'Area de circulo circunscrito: {area_circumscribed(a)}\')\\n","orden":7,"suborden":2,"fecha_creacion":"2020-12-04 23:04:26","fecha_modificacion":"2020-12-06 20:25:39"},{"ID":93,"supergrupo":"Geometr\xeda","tema":"Convex Hull (Envoltorio convexo)","texto":"Se define como la envolvente convexa, envoltura convexa o c\xe1psula convexa de un conjunto de puntos X de dimensi\xf3n n como la intersecci\xf3n de todos los conjuntos convexos que contienen a X.\\nEn el caso particular de puntos en un plano, si no todos los puntos est\xe1n alineados, entonces su envolvente convexa corresponde a un pol\xedgono convexo cuyos v\xe9rtices son algunos de los puntos del conjunto inicial de puntos.\\nUna forma intuitiva de ver la envolvente convexa de un conjunto de puntos en el plano, es imaginar una banda el\xe1stica estirada que los encierra a todos. Cuando se libere la banda el\xe1stica tomar\xe1 la forma de la envolvente convexa.\\n","complejidad_tiempo":"Mejor caso :    O(nlog(n))  Peor caso : O(n2)  Promedio: O(n*puntostomados) ","java":"// Programa java que halla el casco convexo de un set de puntos\\n\\nimport java.util.*;\\n\\npublic class ConvexHull {\\n\\n    static class Point {\\n        int x, y;\\n        Point(int x, int y) {\\n            this.x = x;\\n            this.y = y;\\n        }\\n    }\\n    // Para encontrar la orientaci\xf3n de la tripleta\\n    //la funci\xf3n retorna lo siguiente \\n    // 0 --\x3e p, q y r son colineares \\n    // 1 --\x3e Manecillas de reloj\\n    // 2 --\x3e en contra de las manecillas\\n    static int orientation(Point p, Point q, Point r) {\\n        int val = (q.y - p.y) * (r.x - q.x)\\n                - (q.x - p.x) * (r.y - q.y);\\n        if (val == 0) {\\n            return 0;  // colinear\\n        }\\n        return (val > 0) ? 1 : 2; // Manecillas\\n    }\\n    //Imprime el casco convexo del set de puntos\\n\\n    static void convexHull(Point points[], int n) {\\n        //Debe haber al menos 3 puntos\\n        if (n < 3) {\\n            return;\\n        }\\n        // Inicializar resultado\\n        ArrayList<Point> hull = new ArrayList<>();\\n        // Encuentra el punto de m\xe1s a la izquierda \\n        int l = 0;\\n        for (int i = 1; i < n; i++) {\\n            if (points[i].x < points[l].x) {\\n                l = i;\\n            }\\n        }\\n        // Comienza desde el punto m\xe1s a la izquierda, sigue movi\xe9ndose.\\n        // en sentido antihorario hasta llegar al punto de inicio\\n        // otra vez. Este ciclo corre O (h) veces donde h es\\n        // n\xfamero de puntos en resultado o salida\\n        int p = l, q;\\n        do {\\n            // Agrega el punto actual al resultado\\n            hull.add(points[p]);\\n            // Buscar un punto \'q\' tal que\\n            // la orientaci\xf3n (p, x, q) es antihorario\\n            // para todos los puntos \'x\'. La idea es mantener\\n            // pista de los \xfaltimos visitados m\xe1s contra reloj\\n            // punto en q. Si alg\xfan punto \'i\' es m\xe1s\\n            // en sentido contrario a las agujas del reloj que q, luego                         //actualiza q.\\n            q = (p + 1) % n;\\n            for (int i = 0; i < n; i++) {\\n                //Si i es m\xe1s antihorario que el actual q, actualice q\\n                if (orientation(points[p], points[i], points[q])\\n                        == 2) {\\n                    q = i;\\n                }\\n            }\\n            //Ahora q es el m\xe1s antihoriario con respecto\\n            // a p, ubica p como q para la siguiente iteraci\xf3n\\n            // asi q es agregado al casco resultado\\n            p = q;\\n        } while (p != l);\\n        // Mientras no vengamos del primer punto\\n        // Imprima resultado\\n        for (Point temp : hull) {\\n            System.out.println(\\"(\\" + temp.x + \\", \\"\\n                    + temp.y + \\")\\");\\n        }\\n    }\\n\\n    public static void main(String[] args) {\\n        Point points[] = new Point[7];\\n        points[0] = new Point(0, 3);\\n        points[1] = new Point(2, 3);\\n        points[2] = new Point(1, 1);\\n        points[3] = new Point(2, 1);\\n        points[4] = new Point(3, 0);\\n        points[5] = new Point(0, 0);\\n        points[6] = new Point(3, 3);\\n        int n = points.length;\\n        convexHull(points, n);\\n    }\\n}\\n","cpp":"#include<bits/stdc++.h>\\n#include<cstdlib>\\n#define x first\\n#define y second\\n//---------------//\\nusing namespace std;\\ntypedef pair<int, int> point;\\n\\nint orientation(point p, point q, point r) {\\n    int val = (q.y - p.y)*(r.x - q.x)-(q.x - p.x)*(r.y - q.y);\\n    if (val == 0) {\\n        return 0;\\n    }\\n    return (val > 0 ? 1 : 2);\\n}\\n\\nvoid convexHull(point po[], int n) {\\n    if (n < 3) {\\n        return;\\n    }\\n    vector<point>hull;\\n    int l = 0;\\n    for (int i = 1; i < n; i++) {\\n        if (po[i].x < po[l].x) {\\n            l = i;\\n        }\\n    }\\n    int p = l, q;\\n    do {\\n        hull.push_back(po[p]);\\n        q = (p + 1) % n;\\n        for (int i = 0; i < n; i++) {\\n            if (orientation(po[p], po[i], po[q]) == 2) {\\n                q = i;\\n            }\\n        }\\n        p = q;\\n    } while (p != l);\\n    for (point punto : hull) {\\n        printf(\\"{%d,%d}\\\\n\\", punto.x, punto.y);\\n    }\\n}\\n\\nint main() {\\n    point po[7];\\n    po[0] = make_pair(0, 3);\\n    po[1] = make_pair(2, 3);\\n    po[2] = make_pair(1, 1);\\n    po[3] = make_pair(2, 1);\\n    po[4] = make_pair(3, 0);\\n    po[5] = make_pair(0, 0);\\n    po[6] = make_pair(3, 3);\\n    convexHull(po, 7);\\n} \\n","py":null,"orden":7,"suborden":3,"fecha_creacion":"2020-12-04 23:04:26","fecha_modificacion":"2020-12-06 20:25:39"},{"ID":94,"supergrupo":"Geometr\xeda","tema":"Sumatoria de cortes","texto":"Dado el n\xfamero de cortes, encuentre el m\xe1ximo n\xfamero de posibles piezas.\\nEste problema no es m\xe1s que el problema del cartero flojo, y tiene la siguiente formula.\\nM\xe1ximo n\xfamero de piezas  = 1 + n*(n+1)/2\\n","complejidad_tiempo":"Mejor caso :    O(1)  Peor caso : O(1)  Promedio: O(1) ","java":"//Programa que calcula el maximo n\xfamero\\n// de piezas de pizza dados el n\xfamero de cortes\\n\\npublic class CutsSumatory {\\n\\n    static int findMaximumPieces(int n) {\\n        return 1 + n * (n + 1) / 2;\\n    }\\n\\n    public static void main(String arg[]) {\\n\\nSystem.out.print(findMaximumPieces(3));\\n    }\\n} \\n","cpp":"#include<bits/stdc++.h>\\n#include<cstdlib>\\n//---------------//\\nusing namespace std;\\nint findMaxSum(int n){\\n    return 1 + n* (n+1) / 2;\\n}\\nint main() {\\n    int a=5;\\n    cout<<findMaxSum(a)<<endl;\\n} \\n","py":null,"orden":7,"suborden":4,"fecha_creacion":"2020-12-04 23:04:26","fecha_modificacion":"2020-12-06 20:25:40"},{"ID":95,"supergrupo":"Geometr\xeda","tema":"Formula de Heron","texto":"En geometr\xeda plana elemental la f\xf3rmula de Her\xf3n, cuya invenci\xf3n se atribuye al matem\xe1tico griego Her\xf3n de Alejandr\xeda, da el \xe1rea de un tri\xe1ngulo conociendo las longitudes de sus tres lados a, b y c:\\nArea=v(s(s-a)(s-b)(s-c))\\n","complejidad_tiempo":"Mejor caso :    O(1)  Peor caso : O(1)  Promedio: O(1) ","java":"//Programa Java que calcula el area\\n// De un tri\xe1ngulo usando la formula de Her\xf3n\\n\\npublic class HeronFormula {\\n\\n    public static void main(String[] args) {\\n        //Enviar las coordenadas de los vertices\\n        System.out.println(heron(1, 0, -1, 0, 0, 2));\\n    }\\n    //funci\xf3n que usa la formula de Her\xf3n\\n    static double heron(double x1, double y1, double x2,\\n            double y2, double x3, double y3) {\\n        double a = Math.sqrt((x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2));\\n        double b = Math.sqrt((x1 - x3) * (x1 - x3) + (y1 - y3) * (y1 - y3));\\n        double c = Math.sqrt((x3 - x2) * (x3 - x2) + (y3 - y2) * (y3 - y2));\\n        double s = (a + b + c) / 2.0;\\n        double A = Math.sqrt(s * (s - a) * (s - b) * (s - c));\\n        return A;\\n    }\\n\\n}\\n","cpp":"#include<bits/stdc++.h>\\n#include<cstdlib>\\n#define point pair<double,double>\\n#define x first\\n#define y second\\n//---------------//\\nusing namespace std;\\n\\ndouble heron(double x1,double y1,double x2,double y2,double x3,double y3){\\n    double a =std::sqrt((x1-x2)*(x1-x2)+(y1-y2)*(y1-y2));\\n    double b =std::sqrt((x2-x3)*(x2-x3)+(y2-y3)*(y2-y3));\\n    double c =std::sqrt((x3-x1)*(x3-x1)+(y3-y1)*(y3-y1));\\n    double s=(a+b+c)/2;\\n    return (std::sqrt(s*(s-a)*(s-b)*(s-c)));\\n\\n}\\nint main() {\\n    cout<<heron(1,0,-1,0,0,2)<<endl;\\n} \\n","py":null,"orden":7,"suborden":5,"fecha_creacion":"2020-12-04 23:04:27","fecha_modificacion":"2020-12-06 20:25:41"},{"ID":96,"supergrupo":"Geometr\xeda","tema":"Area de un hex\xe1gono","texto":"Un hex\xe1gono es una figura geom\xe9trica de 6 lados, en dos dimensiones, el total de la suma de los \xe1ngulos internos de cualquier hex\xe1gono es 720\xb0. Un hex\xe1gono regular tiene 6 simetr\xedas rotacionales, y 6 simetr\xedas reflectivas, todos los \xe1ngulos internos son de 120 grados.\\nAh\xed hay principalmente 6 tri\xe1ngulos equil\xe1teros de lado n y el \xe1rea de un tri\xe1ngulo equil\xe1tero es sqrt (3)/4*n*n. Desde el hex\xe1gono, hay en total 6 tri\xe1ngulos equil\xe1teros con lado n, el \xe1rea del hex\xe1gono se convierte en (3*sqrt (3)/2) * n * n)\\n","complejidad_tiempo":"Mejor caso :    O(1)  Peor caso : O(1)  Promedio: O(1) ","java":"//Programa Java que calcula el area de un Hexagono\\n\\npublic class HexagonArea {\\n\\n    public static double hexagonArea(double s) {\\n        return ((3 * Math.sqrt(3)\\n                * (s * s)) / 2);\\n    }\\n\\n    public static void main(String[] args) {\\n        // Largo de un lado\\n        double s = 4;\\n        System.out.print(\\"Area: \\"\\n                + hexagonArea(s));\\n        System.out.println(\\"\\");\\n    }\\n}\\n","cpp":"#include<bits/stdc++.h>\\n#include<cstdlib>\\n//---------------//\\nusing namespace std;\\ndouble hexArea(double s){\\n    return (3*sqrt(3)*(s*s))/2;\\n}\\nint main() {\\n    double s=6;\\n    printf(\\"%.8f\\\\n\\",hexArea(6));\\n} \\n","py":null,"orden":7,"suborden":6,"fecha_creacion":"2020-12-04 23:04:27","fecha_modificacion":"2020-12-06 20:25:41"},{"ID":97,"supergrupo":"Geometr\xeda","tema":"Area de un pol\xedgono","texto":"Dadas ordenadamente las coordenadas de un pol\xedgono, con n v\xe9rtices, encontrar el \xe1rea del pol\xedgono. Aqu\xed ordenado significa que las coordenadas son dadas en sentido horario o anti horario, desde el primer v\xe9rtice hasta el \xfaltimo.\\n\\nPodemos dividir un pol\xedgono en tri\xe1ngulos, la f\xf3rmula del \xe1rea es derivada de tomar cada camino AB, y calcular el \xe1rea del tri\xe1ngulo ABO, con un v\xe9rtice de origen O, tomando el producto cruz (El cual da el \xe1rea de un paralelogramo) y dividiendo por 2. Mientras pasemos alrededor del pol\xedgono, estos tri\xe1ngulos con \xe1rea positiva o negativa se sobreponen, y las ares en medio del origen y el pol\xedgono pueden ser canceladas y sumadas a 0, mientras solo haya \xe1rea interna, el tri\xe1ngulo de referencia de mantiene.\\n","complejidad_tiempo":"Mejor caso :    O(nlog(n))  Peor caso : O(nlog(n))  Promedio: O(nlog(n)) ","java":"//Programa Java que calcula el area de un poligono\\n\\nimport java.awt.Point;\\nimport java.awt.Polygon;\\nimport java.util.Arrays;\\n\\npublic class AreaOfPolygon {\\n\\n    public static void main(String[] args) {\\n        //Crea el poligono con los puntos dados\\n        Polygon p = new Polygon();\\n        p.addPoint(0, 2);\\n        p.addPoint(2, 2);\\n        p.addPoint(2, 0);\\n        p.addPoint(0, 0);\\n        System.out.println(area(p));\\n    }\\n    //Por medio de tri\xe1ngulos va calculando el area completa\\n    static int signedTriangleArea(Point a, Point b, Point c) {\\n        return a.x * b.y - a.y * b.x + a.y * c.x - a.x * c.y + b.x * c.y - c.x * b.y;\\n    }\\n    static boolean ccw(Point a, Point b, Point c) {\\n        return signedTriangleArea(a, b, c) > 0;\\n    }\\n    // Verifica si los puntos son colineares\\n    static boolean collinear(Point a, Point b, Point c) {\\n        return signedTriangleArea(a, b, c) == 0;\\n    }\\n    //Calcula la distancia entre dos puntos\\n    static double distance(Point p1, Point p2) {\\n        double dx = p1.x - p2.x;\\n        double dy = p1.y - p2.y;\\n        return Math.sqrt(dx * dx + dy * dy);\\n    }\\n    //Funci\xf3n que calcula el area de cualquier poligono\\n    static double area(Polygon poly) {\\n        int N = poly.npoints;\\n        int[] x = poly.xpoints;\\n        int[] y = poly.ypoints;\\n        Point[] p = new Point[N];\\n        for (int i = 0; i < N; ++i) {\\n            p[i] = new Point(x[i], y[i]);\\n        }\\n        final Point first;\\n        int min = 0;\\n        for (int i = 1; i < N; i++) {\\n            if (p[i].y < p[min].y) {\\n                min = i;\\n            } else if (p[i].y == p[min].y) {\\n                if (p[i].x < p[min].x) {\\n                    min = i;\\n                }\\n            }\\n        }\\n        first = p[min];\\n        p[min] = p[0];\\n        p[0] = first;\\n        //Usar expresion lambda en vez de comparator\\n        Arrays.sort(p, 1, N, (Point p1, Point p2) -> {\\n            if (collinear(first, p1, p2)) {\\n                return Double.compare(distance(first, p1), distance(first, p2));\\n            }\\n            if (ccw(first, p1, p2)) {\\n                return -1;\\n            } else {\\n                return 1; \\n            }\\n        });\\n        double A = 0.0;\\n        for (int i = 0; i < N; i++) {\\n            int j = (i + 1) % N;\\n            A += p[i].x * p[j].y - p[j].x * p[i].y;\\n        }\\n        return A / 2.0;\\n\\n    }\\n} \\n","cpp":null,"py":null,"orden":7,"suborden":7,"fecha_creacion":"2020-12-04 23:04:27","fecha_modificacion":"2020-12-06 20:25:42"},{"ID":98,"supergrupo":"Geometr\xeda","tema":"Intersecci\xf3n de l\xedneas","texto":"Dados puntos A y B, correspondientes a la l\xednea AB y los puntos P y Q, correspondientes a la l\xednea PQ, encuentre el punto de intersecci\xf3n de estas l\xedneas. Los puntos est\xe1n dados en un plano 2D con sus coordenadas X y Y.\\nPrimero que todo, asumimos que tenemos dos puntos (x1,y1,) y (x2,y2). Ahora encontramos la ecuaci\xf3n de la l\xednea formada por esos puntos.\\nDejaremos que las l\xedneas dadas sean:\\n- a1x + b1y = c1\\n- a2x + b2y = c2\\nTenemos que ahora resolver estas dos ecuaciones para encontrar el punto de intersecci\xf3n, para resolver esto, multiplicamos a1 por b2 y a2 por b1, esto nos da:\\n- a1b2x + b1b2y = c1b2\\n- a2b1x + b2b1y = c2b1\\nRestando esto obtenemos:\\n- (a1b2 \u2013 a2b1) x = c1b2 \u2013 c2b1\\nEsto nos da el valor de x. similarmente podemos encontrar el valor de y, (x,y) nos da el punto de intersecci\xf3n.\\nEsto nos da el punto de intersecci\xf3n de dos l\xedneas, pero si nos dan segmentos de l\xednea en vez de l\xedneas, tenemos que revisar el punto que computado yace en ambos segmentos de l\xedneas,\\nSi el segmento de l\xednea es especificado por los puntos (x1,y2) y (x2,y2), entonces debemos verificar si (x,y) est\xe1 en el segmento que tenemos de la siguiente manera:\\n- min (x1, x2) <= x <= max (x1, x2)\\n- min (y1, y2) <= y <= max (y1, y2)\\n","complejidad_tiempo":"Mejor caso :    O(1)  Peor caso : O(1)  Promedio: O(1) ","java":"//Implementaci\xf3n Java que encuentra el punto de\\n//interseccion de dos lineas\\n\\npublic class LineLineIntersection {\\n    //Clase usada para almacenar las coordenadas X y la Y    \\n    // de un punto respectivo\\n    static class Point {\\n        double x, y;\\n        public Point(double x, double y) {\\n            this.x = x;\\n            this.y = y;\\n        }\\n        // Metodo usado para imprimir las cordenadas\\n        // X y Y de un punto\\n        static void displayPoint(Point p) {\\n            System.out.println(\\"(\\" + p.x + \\", \\" + p.y + \\")\\");\\n        }\\n    }\\n\\n    static Point lineLineIntersection(Point A, Point B, Point C, Point D) {\\n        // Linea AB representada como a1x + b1y=c1\\n        double a1 = B.y - A.y;\\n        double b1 = A.x - B.x;\\n        double c1 = a1 * (A.x) + b1 * (A.y);\\n        // Linea CD representada como a2x + b2y=c2\\n        double a2 = D.y - C.y;\\n        double b2 = C.x - D.x;\\n        double c2 = a2 * (C.x) + b2 * (C.y);\\n        double determinant = a1 * b2 - a2 * b1;\\n        if (determinant == 0) {\\n            //Las lineas son pararelas, esto es simplificado\\n            //Retornando un par de FLT_MAX\\n            return new Point(Double.MAX_VALUE, Double.MAX_VALUE);\\n        } else {\\n            double x = (b2 * c1 - b1 * c2) / determinant;\\n            double y = (a1 * c2 - a2 * c1) / determinant;\\n            return new Point(x, y);\\n        }\\n    }\\n\\n    public static void main(String args[]) {\\n        Point A = new Point(1, 1);\\n        Point B = new Point(4, 4);\\n        Point C = new Point(1, 8);\\n        Point D = new Point(2, 4);\\n        Point intersection = lineLineIntersection(A, B, C, D);\\n        if (intersection.x == Double.MAX_VALUE\\n                && intersection.y == Double.MAX_VALUE) {\\n            System.out.println(\\"la linea AB y CD son paralelas.\\");\\n        } else {\\n            System.out.print(\\"La intersecci\xf3n de las lineas AB \\"+ \\"y CD es: \\");\\n            Point.displayPoint(intersection);\\n        }\\n    }\\n} \\n","cpp":null,"py":null,"orden":7,"suborden":8,"fecha_creacion":"2020-12-04 23:04:28","fecha_modificacion":"2020-12-06 20:25:42"},{"ID":99,"supergrupo":"Geometr\xeda","tema":"Punto medio de una l\xednea","texto":"Dado dos coordenadas de una l\xednea iniciando en (x1,y1) y terminando en (x2,y2) encontrar el punto medio de una l\xednea.\\nEl punto medio de dos puntos (x1,y1) y (x2,y2) es el punto M encontrado con la siguiente f\xf3rmula:\\n- M = ((x1+x2)/2 , (y1+y2)/2)\\n","complejidad_tiempo":"Mejor caso :    O(1)  Peor caso : O(1)  Promedio: O(1) ","java":"//Programa java para buscar\\n//el punto medio de una linea\\n\\npublic class LineMidPoint {\\n\\n    static void midpoint(int x1, int x2,\\n            int y1, int y2) {\\n        System.out.print((x1 + x2) / 2\\n                + \\" , \\" + (y1 + y2) / 2);\\n    }\\n\\n    public static void main(String[] args) {\\n        int x1 = -1, y1 = 2;\\n        int x2 = 3, y2 = -6;\\n        midpoint(x1, x2, y1, y2);\\n\\n    }\\n}\\n","cpp":"#include <iostream>\\n\\nusing namespace std;\\n\\nstring midPoint(int x1, int x2, int y1, int y2){\\n    string res1 = std::to_string((x1+x2)>>1);\\n    string res2 = std::to_string((y1+y2)>>1);\\n    return (res1+\\", \\"+res2);\\n}\\n\\nint main()\\n{\\n    ios_base::sync_with_stdio(false);cin.tie(NULL);cout.tie(NULL);\\n    int x1, x2; cin>>x1>>x2;\\n    int y1, y2; cin>>y1>>y2;\\n    cout<<midPoint(x1, x2, y1, y2)<<endl;\\n    return 0;\\n}\\n","py":"from sys import stdin,stdout\\n\\n# m = ((x1+x2)/2 , (y1+y2)/2)\\n\\ndef midpoint(x1,y1,x2,y2):\\n    res = str(((x1+x2)/2))+\\" , \\"+str(((y1+y2)/2))\\n    return res\\n\\nx1,y1,x2,y2 = stdin.readline().strip().split()\\n\\nx1,y1,x2,y2 = int(x1),int(y1),int(x2),int(y2)\\n\\nmedio = midpoint(x1, y1, x2, y2)\\n\\nstdout.write(f\\"el punto medio es: {medio}\\")\\n","orden":7,"suborden":9,"fecha_creacion":"2020-12-04 23:04:28","fecha_modificacion":"2020-12-06 20:25:43"},{"ID":100,"supergrupo":"Geometr\xeda","tema":"L\xednea dados dos puntos","texto":"Dados dos puntos P(x1,y1) y Q(x2,y2), encuentre la ecuaci\xf3n de la l\xednea formada por esos dos puntos.\\nCualquier l\xednea puede ser representada como:\\n- ax + by = c\\nDejamos dos puntos que satisfagan la l\xednea dada, entonces tenemos:\\n-  ax1 + by1 = c\\n- ax2 + by2 = c\\nPodemos cambiar los siguientes valores para que la ecuaci\xf3n de mantenga verdadera:\\n- a = y2 - y1\\n- b = x1 - x2\\n- c = ax1 + by1\\n","complejidad_tiempo":"Mejor caso :    O(1)  Peor caso : O(1)  Promedio: O(1) ","java":"//Implementaci\xf3n Java para encontrar la linea\\n//que pasa atraves de dos puntos\\n\\npublic class LineThroughTwoPoints {\\n\\n    public static void main(String[] args) {\\n        Pair P = new Pair(3, 2);\\n        Pair Q = new Pair(2, 6);\\n        lineFromPoints(P, Q);\\n    }\\n\\n    static void lineFromPoints(Pair P, Pair Q) {\\n        double a = Q.second - P.second;\\n        double b = P.first - Q.first;\\n        double c = a * (P.first) + b * (P.second);\\n        if (b < 0) {\\n            System.out.println(\\"La linea que pasa a traves de \\"\\n                    + \\"los puntos P y Q es: \\"\\n                    + a + \\"x \\" + b + \\"y = \\" + c);\\n        } else {\\n            System.out.println(\\"La linea que pasa a traves de l\\"\\n            + \\"os puntos P y Q es: \\"\\n                    + a + \\"x + \\" + b + \\"y = \\" + c);\\n        }\\n    }\\n    /* Este par  es usado para almacenar la X y Y\\n    de un punto respectivamente*/\\n    static class Pair {\\n        int first;\\n        int second;\\n        public Pair(int first, int second) {\\n            this.first = first;\\n            this.second = second;\\n        }\\n    }\\n}\\n","cpp":"#include<bits/stdc++.h>\\n#include<cstdlib>\\n#define x first\\n#define y second\\nusing namespace std;\\ntypedef pair<int,int> point;\\nvoid lineFromPoints(point P,point Q){\\n    double a=Q.y-P.y;\\n    double b=P.x-Q.x;\\n    double c=a*(P.x)+b*(P.y);\\n    if(b < 0){\\n        cout<<\\"La linea que pasa a traves de los puntos P y Q es:\\"<<\\"(\\"<<a<<\\"x) * (\\"<<b<<\\"y) = \\"<<c<<endl;\\n    }else{\\n        cout << \\"La linea que pasa a traves de los punto P y Q es:\\"<<a<<\\"x + \\" << b << \\"y = \\" << c << endl;\\n    }\\n}\\nint main() {\\n    point p=make_pair(3,2);\\n    point q=make_pair(2,6);\\n    lineFromPoints(p,q);\\n} \\n","py":null,"orden":7,"suborden":10,"fecha_creacion":"2020-12-04 23:04:28","fecha_modificacion":"2020-12-06 20:25:44"},{"ID":101,"supergrupo":"Geometr\xeda","tema":"Tri\xe1ngulo de monedas ordenadas","texto":"Tenemos N monedas las cuales necesitamos ordenar en forma de tri\xe1ngulo, por ejemplo la primera fila podr\xe1 tener una moneda, la segunda fila dos monedas y as\xed en adelante, necesitamos saber la m\xe1xima altura que podemos obtener usando esas N monedas.\\nEste problema puede ser resuelto encontrando la relaci\xf3n entre la altura del tri\xe1ngulo y el n\xfamero de monedas, dejamos como la altura m\xe1xima como H, luego la suma total de monedas debe ser menos de N.\\n","complejidad_tiempo":"Mejor caso :    O(1)  Peor caso : O(1)  Promedio: O(1) ","java":"// Programa java que encuentra la maxima altura\\n// de un tri\xe1ngulo de monedas arregladas\\n\\npublic class ArrangedCoinTriangle {\\n\\n    /*Retrorna el la raiz cuadrada de n\\n    Note como la funci\xf3n lo realiza*/\\n    static float squareRoot(float n) {\\n        /*Usamos n como aproximci\xf3n inicial*/\\n        float x = n;\\n        float y = 1;\\n        // Se decide el nivel de precisi\xf3n\\n        float e = 0.000001f;\\n        while (x - y > e) {\\n            x = (x + y) / 2;\\n            y = n / x;\\n        }\\n        return x;\\n    }\\n    //Metodo que encuentra la maxima altura\\n    //del arreglo de monedas\\n    static int findMaximumHeight(int N) {\\n        //Calculando la porci\xf3n interna\\n        //de la raiz cuadrada\\n        int n = 1 + 8 * N;\\n        int maxH = (int) (-1 + squareRoot(n)) / 2;\\n        return maxH;\\n    }\\n\\n    public static void main(String[] args) {\\n        int N = 12;\\n        System.out.print(findMaximumHeight(N));\\n    }\\n}\\n","cpp":"#include <iostream>\\nusing namespace std;\\n\\nint findMaxH(int);\\nfloat squareRoot(float);\\n\\nint main() {\\n    int N = 12;\\n    cout << findMaxH(N) << endl;\\n}\\n\\nint findMaxH(int n) {\\n    int n1 = 1 + 8 * n;\\n    int maxh = (int) (-1 + squareRoot(n1) / 2);\\n    return maxh;\\n}\\n\\nfloat squareRoot(float n) {\\n    float x = n;\\n    float y = 1;\\n    float e = 0.0000001f;\\n    while (x - y > e) {\\n        x = (x + y) / 2;\\n        y = n / x;\\n    }\\n    return x;\\n}\\n","py":"from sys import stdin\\nfrom sys import stdout\\n\\ndef findMaxH(n):\\n    n1 = 1 + 8 * n\\n    maxh = int(-1 + squareRoot(n1) / 2)\\n    return maxh\\n\\ndef squareRoot(n):\\n    x = n\\n    y = 1\\n    e = 0.000001\\n    while x - y > e:\\n        x = (x + y) / 2\\n        y = n / x\\n    return x\\n\\nN = 12\\nstdout.write(f\\"{findMaxH(N)}\\")\\n","orden":7,"suborden":11,"fecha_creacion":"2020-12-04 23:04:29","fecha_modificacion":"2020-12-06 20:25:44"},{"ID":102,"supergrupo":"Geometr\xeda","tema":"Per\xedmetro usando bloques","texto":"Tenemos n bloques de tama\xf1o 1x1, necesitamos encontrar el m\xednimo per\xedmetro de una matriz hecha de estos bloques.\\n\\n\\nSi hacemos algunos ejemplos usando l\xe1piz y papel, podemos notar que el per\xedmetro se vuelve m\xednimo cuando la figura formada es m\xe1s cercana a un cuadrado. La raz\xf3n de esto es, que queremos el m\xe1ximo de lados de bloques que miren dentro de la figura, entonces el per\xedmetro de la figura se vuelve m\xednimo.\\nSi el n\xfamero de bloques es un cuadrado perfecto, entonces el per\xedmetro puede ser simplemente 4*sqrt(n).\\nPero si el n\xfamero de bloques no es una ra\xedz cuadrada perfecta, entonces nosotros calculamos el n\xfamero de filas y columnas cercanas a la ra\xedz cuadrada, luego de arreglar los bloques en un rect\xe1ngulo, y tenemos bloques restantes, simplemente podemos agregar 2 al per\xedmetro porque solo 2 lados extra faltar\xedan.\\n","complejidad_tiempo":"Mejor caso :    O(1)  Peor caso : O(1)  Promedio: O(1) ","java":"/*Codigo JAVA que permire encontrar el minimo\\nperimetro usando n bloques*/\\npublic class PerimeterUsingBlocks {\\n\\n    public static long minPerimeter(int n) {\\n        int l = (int) Math.sqrt(n);\\n        int sq = l * l;\\n        //si n es un cudrado perfeto\\n        if (sq == n) {\\n            return l * 4;\\n        } else {\\n            //N\xfamero de filas\\n            long row = n / l;\\n            //Perimetro de la matriz rectangular\\n            long perimeter\\n                    = 2 * (l + row);\\n            // Si hay bloques restantes\\n            if (n % l != 0) {\\n                perimeter += 2;\\n            }\\n            return perimeter;\\n        }\\n    }\\n\\n    public static void main(String[] args) {\\n        int n = 10;\\n        System.out.println(minPerimeter(n));\\n    }\\n}\\n","cpp":"#include <iostream>\\n#include <cmath>\\n\\nusing namespace std;\\n\\nlong minPerimeter(int n) {\\n    int x = (int) sqrt(n);\\n    int sq = x * x;\\n    if (sq == n) {\\n        return x << 2;\\n    } else {\\n        long row = n / x;\\n        long perimeter = (x + row) << 1;\\n        if (n % x != 0) {\\n            perimeter += 2;\\n        }\\n        return perimeter;\\n    }\\n}\\n\\nint main() {\\n    ios_base::sync_with_stdio(false);\\n    cin.tie(NULL);\\n    cout.tie(NULL);\\n    int n;\\n    cin>>n;\\n    cout << minPerimeter(n) << endl;\\n    return 0;\\n}\\n","py":"import math\\nfrom collections import namedtuple\\nfrom sys import stdin, stdout\\nrl = stdin.readline\\nwr = stdout.write\\n\\n\\ndef minPerimeter(n):\\n    l = int(math.sqrt(n))\\n    sq = l * l\\n    if sq == n:\\n        return l * 4\\n    else:\\n        row = n // l\\n        perimeter = 2 * (l + row)\\n        if n % l != 0:\\n            perimeter += 2\\n        return perimeter\\n\\n\\nn = int(rl())\\nwr(f\'{minPerimeter(n)}\')\\n","orden":7,"suborden":12,"fecha_creacion":"2020-12-04 23:04:29","fecha_modificacion":"2020-12-06 20:25:45"},{"ID":103,"supergrupo":"Geometr\xeda","tema":"Punto dentro de un triangulo","texto":"Dados tres puntos esquina de un tri\xe1ngulo, y un punto m\xe1s P, verifique si P yace dentro del tri\xe1ngulo o no.\\nDejaremos las coordenadas de las tres esquinas ser (x1, y1), (x2, y2) y (x3, y3), y las coordenadas de P ser (x, y). \\n1) Calcular \xe1rea del tri\xe1ngulo dado, por ejemplo el \xe1rea del tri\xe1ngulo ACB:  Area A = [ x1(y2 \u2013 y3) + x2(y3 \u2013 y1) + x3(y1-y2)]/2\\n2) Calcular el \xe1rea del tri\xe1ngulo PAB. Podemos usar la misma f\xf3rmula para esto, dejamos esta \xe1rea ser A1.\\n3) Calculamos el \xe1rea del tri\xe1ngulo PBC, dejamos esta \xe1rea ser A2.\\n4) Calcular el \xe1rea del tri\xe1ngulo PAC, dejaremos esta \xe1rea ser A3.\\n5) Si P yace dentro del tri\xe1ngulo, entonces A1+A2+A3 debe ser igual a A.\\n","complejidad_tiempo":"Mejor caso :    O(1)  Peor caso : O(1)  Promedio: O(1) ","java":"//Codigo Java que verifica cuando un punto\\n//yace dentro de un tri\xe1ngulo o no\\n\\npublic class PointInsideTriangle {\\n\\n    /* Una funci\xf3n de utilidad que calcula el \\n    area del tri\xe1ngulo formado por (x1, y1) (x2, y2) y (x3, y3)*/\\n    static double area(int x1, int y1, int x2, int y2,\\n            int x3, int y3) {\\n        return Math.abs((x1 * (y2 - y3) + x2 * (y3 - y1)\\n                + x3 * (y1 - y2)) / 2.0);\\n    }\\n\\n    /* Una funci\xf3n que verifica cu cualquier punto P(x,y)\\n    yace dentro de un tri\xe1ngulo formado por (x1, y1), \\n    B(x2, y2) and C(x3, y3) */\\n    static boolean isInside(int x1, int y1, int x2,\\n            int y2, int x3, int y3, int x, int y) {\\n        /* Calcula el area del tri\xe1ngulo ABC */\\n        double A = area(x1, y1, x2, y2, x3, y3);\\n        /* Calcula el area del tri\xe1ngulo PCB */\\n        double A1 = area(x, y, x2, y2, x3, y3);\\n        /* Calcula el area del tri\xe1ngulo PAC */\\n        double A2 = area(x1, y1, x, y, x3, y3);\\n        /* Calcula el area del tri\xe1ngulo PAB */\\n        double A3 = area(x1, y1, x2, y2, x, y);\\n        /* verifica si la suma de A1,A2 y A3 es igual a A*/\\n        return (A == A1 + A2 + A3);\\n    }\\n\\n    public static void main(String[] args) {\\n        /* Verificamos si el punto P(10,15)\\n        yace dentro del tri\xe1ngulo formado por\\n        A(0, 0), B(20, 0) and C(10, 30)*/\\n        if (isInside(0, 0, 20, 0, 10, 30, 10, 15)) {\\n            System.out.println(\\"Adentro\\");\\n        } else {\\n            System.out.println(\\"Por fuera\\");\\n        }\\n    }\\n}\\n","cpp":"#include <iostream>\\n#include <math.h>\\nusing namespace std;\\n\\n\\ndouble area(int x1, int y1, int x2, int y2, int x3, int y3) {\\n    return fabs((x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)) / 2.0);\\n}\\n\\nbool isinside(int x1, int y1, int x2, int y2, int x3, int y3, int x, int y) {\\n    double A = area(x1, y1, x2, y2, x3, y3);\\n    double A1 = area(x1, y1, x2, y2, x, y);\\n    double A2 = area(x1, y1, x3, y3, x, y);\\n    double A3 = area(x2, y2, x3, y3, x, y);\\n    return (A == A1 + A2 + A3);\\n}\\n\\nint main() {\\n    int x1 = 0, x2 = 5, x3 = 10, y1 = 0, y2 = 5, y3 = 3, puntox = 5, puntoy = 3;\\n    if (isinside(x1, y1, x2, y2, x3, y3, puntox, puntoy)) {\\n        cout << \\"Esta dentro\\" << endl;\\n    } else cout << \\"Esta fuera\\" << endl;\\n}\\n","py":"from sys import stdin\\nfrom sys import stdout\\n\\ndef Area(x1, y1, x2, y2, x3, y3):\\n    return abs((x1 * (y2-y3) + x2 * (y3-y1) + x3 * (y1-y2)) / 2)\\n\\ndef isInside(x1, y1, x2, y2, x3, y3, x, y):\\n    A = Area(x1, y1, x2, y2, x3, y3)\\n    A1 = Area(x1, y1, x2, y2, x, y)\\n    A2 = Area(x1, y1, x3, y3, x, y)\\n    A3 = Area(x2, y2, x3, y3, x, y)\\n    return (A == A1 + A2 + A3)\\n\\nx1, y1, x2, y2, x3, y3, x, y = 0, 0, 5, 5, 10, 3, 5, 3\\nif isInside(x1, y1, x2, y2, x3, y3, x, y):\\n    stdout.write(f\\"el punto ({x},{y}) esta dentro del triangulo\\")\\nelse:\\n    stdout.write(f\\"el punto ({x},{y}) no esta dentro del triangulo\\")\\n","orden":7,"suborden":13,"fecha_creacion":"2020-12-04 23:04:29","fecha_modificacion":"2020-12-06 20:25:46"},{"ID":104,"supergrupo":"Geometr\xeda","tema":"L\xednea dividida en ratios","texto":"Dadas dos coordenadas (x1, y1) y (x2, y2), y m y n, encuentre las coordenadas que dividen la l\xednea juntando (x1, y1) y (x2,y2) en el ratio m:n.\\nLa f\xf3rmula de la secci\xf3n nos dice las coordenadas del punto que divide una l\xednea segmento dada en dos partes las cuales tendr\xe1n la longitud del ratio m:n.\\n-  ((mx2+nx1/m+n),(my2+ny1/m+n))\\n","complejidad_tiempo":"Mejor caso :    O(1)  Peor caso : O(1)  Promedio: O(1) ","java":"// Programa java que encuentra el punto que divide una \\n//linea dada, dado un ratio\\n\\npublic class RatioDivideLine {\\n    static void section(double x1, double x2,\\n            double y1, double y2,\\n            double m, double n) {\\n        //Aplicando la formula de la secci\xf3n\\n        double x = ((n * x1) + (m * x2))\\n                / (m + n);\\n        double y = ((n * y1) + (m * y2))\\n                / (m + n);\\n        // Imprimiendo resultado\\n        System.out.println(\\"(\\" + x + \\", \\" + y + \\")\\");\\n    }\\n\\n    public static void main(String[] args) {\\n        double x1 = 2, x2 = 4, y1 = 4,\\n                y2 = 6, m = 2, n = 3;\\n        section(x1, x2, y1, y2, m, n);\\n    }\\n}\\n","cpp":"#include<bits/stdc++.h>\\n#include<cstdlib>\\n#define x first\\n#define y second\\nusing namespace std;\\ntypedef pair<double,double> point;\\nvoid section(point a,point b,point n){\\n    double x1 = ((n.y*a.x)+(n.x*a.y))/(n.x+n.y);\\n    double y1 = ((n.y*b.x)+(n.x*b.y))/(n.x+n.y);\\n    cout<<\\"(\\"<<x1<<\\" , \\"<<y1<<\\")\\"<<endl;\\n}\\nint main() {\\n    point a=make_pair(2,0);\\n    point b=make_pair(5,5);\\n    point n=make_pair(3,2);\\n    section(a,b,n);\\n}\\n","py":"from sys import stdin\\nfrom sys import stdout\\nrl = stdin.readline\\nwr = stdout.write\\n\\n\\n# Usando coordenadas independientes\\ndef section(x1, y1, x2, y2, m, n):\\n    x = ((n * x1) + (m * x2)) / (m + n)\\n    y = ((n * y1) + (m * y2)) / (m + n)\\n    wr(f\'({x} , {y})\')\\n\\n\\nx1, y1, x2, y2, m, n = rl().strip().split()\\nx1, y1, x2, y2, m, n = int(x1), int(y1), int(x2), int(y2), int(m), int(n)\\nsection(x1, y1, x2, y2, m, n)\\n\\n\\n# Usando NamedTuple\\nPuntos = namedtuple(\'Puntos\', [\'x\', \'y\'])\\n\\n\\ndef sectionNT(P1, P2, m, n):\\n    x = ((n * P1.x) + (m * P2.x)) / (m + n)\\n    y = ((n * P1.y) + (m * P2.y)) / (m + n)\\n    wr(f\'({x} , {y})\')\\n\\n\\nP1 = Puntos(x1, y1)\\nP2 = Puntos(x2, y2)\\nsectionNT(P1, P2, m, n)\\n","orden":7,"suborden":14,"fecha_creacion":"2020-12-04 23:04:30","fecha_modificacion":"2020-12-06 20:25:46"},{"ID":105,"supergrupo":"Geometr\xeda","tema":"Rect\xe1ngulos en NxM","texto":"Tenemos una matriz N*M, imprima el n\xfamero de rect\xe1ngulos en \xe9l.\\n- Si la matriz es 1x1, entonces habr\xe1 1 rect\xe1ngulo.\\n- Si la matriz es 2x1, entonces habr\xe1  2 +1 = 3 rect\xe1ngulos\\n- Si la matriz es 3x1, entonces habr\xe1 3+2+1=6 rect\xe1ngulo.\\nPodemos decir que para N*1 ah\xed habr\xe1 N+(N+1)+(N-2)\u2026 +1=(N)(N+1)/2 rect\xe1ngulos.\\nSi nosotros a\xf1adimos una columna m\xe1s a Nx1, primero tendr\xedamos tantos rect\xe1ngulos en la segunda columna como en la primera, y luego tendr\xedamos el mismo n\xfamero de 2xM rect\xe1ngulos, entonces Nx2=3 (N)(N+1)/2, luego de deducir esto podemos decir que:\\n- Para N*M nosotros tendr\xedamos (M)(M+1)/2 (N)(N+1)/2 = M(M+1)(N)(N+1)/4\\nEntonces la f\xf3rmula para el total de rect\xe1ngulos es:\\n- M(M+1)(N)(N+1)/4\\n","complejidad_tiempo":"Mejor caso :    O(1)  Peor caso : O(1)  Promedio: O(1) ","java":"// Codigo Java que cuenta el n\xfamero\\n// de rectangulos en una matriz N*M\\n\\npublic class RectanglesInNxM {\\n\\n    public static long rectCount(int n, int m) {\\n        return (m * n * (n + 1) * (m + 1)) / 4;\\n    }\\n\\n    public static void main(String[] args) {\\n        int n = 5, m = 4;\\n        System.out.println(rectCount(n, m));\\n    }\\n} \\n","cpp":null,"py":null,"orden":7,"suborden":15,"fecha_creacion":"2020-12-04 23:04:30","fecha_modificacion":"2020-12-06 20:25:47"},{"ID":106,"supergrupo":"Geometr\xeda","tema":"Cuadrados 2x2 en un tri\xe1ngulo","texto":"Cu\xe1l es el m\xe1ximo n\xfamero de cuadrados de tama\xf1o 2x2 unidades que pueden caber en un tri\xe1ngulo is\xf3sceles de \xe1ngulos correctos dada la base en unidades.\\nUn lado del cuadrado debe ser paralelo a la base del tri\xe1ngulo.\\nDesde que el tri\xe1ngulo es is\xf3sceles, la base dada ser\xe1 tambi\xe9n igual a la altura. Ahora en la parte diagonal, podr\xedamos siempre necesitar un largo extra de dos unidades en la altura y la base del tri\xe1ngulo para acomodar un tri\xe1ngulo. En la longitud restante de la base, podemos construir largo/2 cuadrados. Desde que cada cuadrado es de dos unidades, lo mismo puede hacerse en el caso de la altura, ah\xed no hay necesidad de calcular  eso de nuevo.\\nEntonces, para cada nivel de la longitud dada, podemos construir \u201c(largo-2)/2\u201d cuadrados. Esto nos da una base de \u201c(largo-2)\u201d encima de \xe9l. Continuando con el proceso de obtener el n\xfamero de cuadrados para toda la disponible \u201clargo/2\u201d altura, podemos calcular los cuadrados.\\nPara una forma m\xe1s eficiente, podemos usar la f\xf3rmula de la suma de AP n*(n+1)/2, donde n= largo-2.\\n","complejidad_tiempo":"Mejor caso :    O(1)  Peor caso : O(1)  Promedio: O(1) ","java":"// Programa Java que cuenta el n\xfamero de cuadros2 \\n// 2x2 que cabe en un tri\xe1ngulo isoceles\\n\\npublic class SquaresInTriangle2x2 {\\n\\n    public static int numberOfSquares(int base) {\\n        // Removiendo la parte extra  \\n        // que podamos necesitar\\n        base = (base - 2);\\n        // Desde cada cuadrado que tenga\\n        // base de tama\xf1o 2 \\n        base = base / 2;\\n        return base * (base + 1) / 2;\\n    }\\n\\n    public static void main(String args[]) {\\n        int base = 8;\\n        System.out.println(numberOfSquares(base));\\n    }\\n} \\n\\n","cpp":null,"py":null,"orden":7,"suborden":16,"fecha_creacion":"2020-12-04 23:04:30","fecha_modificacion":"2020-12-06 20:25:47"},{"ID":107,"supergrupo":"Geometr\xeda","tema":"Suma de Manhattan","texto":"Dados n coordenadas enteras, encuentre la suma de la distancia de Manhattan entre todos los pares de coordenadas.\\nLa distancia de Manhattan entre dos puntos (x1,y1) y (x2,y2) es:\\n- |x1 \u2013 x2| + |y1 \u2013 y2|\\nLa idea es recorrer dos ciclos anidados, por ejemplo cada punto, encontrar la distancia de todos los otros puntos con este.\\n","complejidad_tiempo":" O(nlog(n))  Peor caso : O(nlog(n))  Promedio: O(nlog(n)) ","java":"/*Programa Java para encontrar la suma de\\nlas distancias de Manhattan entre todos \\nlos pares de puntos dados */\\n\\npublic class SumOfManhattan {\\n\\n    /*Retorna la suma de la distancia entre todos\\n    los pares de puntos*/\\n    static int distancesum(int x[], int y[], int n) {\\n        int sum = 0;\\n        /* Por cada punto, encuentra la distancia \\n        al resto de puntos */\\n        for (int i = 0; i < n; i++) {\\n            for (int j = i + 1; j < n; j++) {\\n                sum += (Math.abs(x[i] - x[j])\\n                        + Math.abs(y[i] - y[j]));\\n            }\\n        }\\n        return sum;\\n    }\\n\\n    public static void main(String[] args) {\\n        int x[] = {-1, 1, 3, 2};\\n        int y[] = {5, 6, 5, 3};\\n        int n = x.length;\\n        System.out.println(distancesum(x, y, n));\\n    }\\n} \\n","cpp":null,"py":null,"orden":7,"suborden":17,"fecha_creacion":"2020-12-04 23:04:31","fecha_modificacion":"2020-12-06 20:25:48"},{"ID":108,"supergrupo":"Geometr\xeda","tema":"Tres puntos colineales","texto":"Dados tres puntos, verificar si estos puntos yacen en recta (colineales) o no.\\nEjemplo: (1, 1), (1, 4), (1, 5)\\nLos tres puntos yacen en una l\xednea recta.\\nTres puntos yacen en una l\xednea recta si el \xe1rea formada por un tri\xe1ngulo de estos tres puntos es cero.\\n","complejidad_tiempo":"Mejor caso :    O(1)  Peor caso : O(1)  Promedio: O(1) ","java":"/*Programa en java para verificar si\\ntres puntos son colineares\\no no usando el area del tri\xe1ngulo*/\\npublic class ThreePointsCollinear {\\n    //Funci\xf3n que verifica si un punto es colineal o no\\n    static void collinear(int x1, int y1, int x2,\\n            int y2, int x3, int y3) {\\n        /*Calcular el area del tri\xe1ngulo\\n        Debemos omitir multiplicaciones con 0.5\\n        para evitar calculos flotantes*/\\n        int a = x1 * (y2 - y3)\\n                + x2 * (y3 - y1)\\n                + x3 * (y1 - y2);\\n        if (a == 0) {\\n            System.out.println(\\"Yes\\");\\n        } else {\\n            System.out.println(\\"No\\");\\n        }\\n    }\\n\\n    public static void main(String args[]) {\\n        int x1 = 1, x2 = 1, x3 = 1,\\n                y1 = 1, y2 = 4, y3 = 5;\\n        collinear(x1, y1, x2, y2, x3, y3);\\n\\n    }\\n} \\n","cpp":null,"py":null,"orden":7,"suborden":18,"fecha_creacion":"2020-12-04 23:04:31","fecha_modificacion":"2020-12-06 20:25:49"},{"ID":109,"supergrupo":"Geometr\xeda","tema":"\xc1ngulos de un tri\xe1ngulo","texto":"Dadas las coordenadas de tres v\xe9rtices de un tri\xe1ngulo en un plano 2D, encuentre sus tres \xe1ngulos.\\n- c^2 = a^2 + b^2 - 2(a)(b)(cos beta)\\nLuego del despeje:\\n- beta = acos( ( a^2 + b^2 - c^2 ) / (2ab) )\\nEn trigonometr\xeda la ley del coseno cuenta que los largos de los lados de un tri\xe1ngulo con el coseno de uno de sus \xe1ngulos luego de un despeje nos da el \xe1ngulo.\\nPrimero calculamos el largo de todos los lados, luego aplicamos la f\xf3rmula de arriba para obtener  todos los \xe1ngulos en radianes, luego convertimos de radianes a grados.\\n","complejidad_tiempo":null,"java":"/* Codigo JAVA para encontrar todos los angulos\\nde un tri\xe1ngulos dadas las coordenadas\\nde los tres vertices*/\\nimport java.awt.Point;\\nimport static java.lang.Math.PI;\\nimport static java.lang.Math.sqrt;\\nimport static java.lang.Math.acos;\\n\\npublic class TriangleAngles {   \\n    // Regresa el cuadrado de la distancia b/w de dos puntos\\n    static int lengthSquare(Point p1, Point p2) {\\n        int xDiff = p1.x - p2.x;\\n        int yDiff = p1.y - p2.y;\\n        return xDiff * xDiff + yDiff * yDiff;\\n    }\\n\\n    static void printAngle(Point A, Point B,\\n            Point C) {\\n        //Cuadrado de los tama\xf1os de a2, b2, c2\\n        int a2 = lengthSquare(B, C);\\n        int b2 = lengthSquare(A, C);\\n        int c2 = lengthSquare(A, B);\\n        // Longitus de los lados de a, b, c \\n        float a = (float) sqrt(a2);\\n        float b = (float) sqrt(b2);\\n        float c = (float) sqrt(c2);\\n        // De la ley del coseno\\n        float alfa = (float) acos((b2 + c2 - a2) / (2 * b * c));\\n        float beta = (float) acos((a2 + c2 - b2) / (2 * a * c));\\n        float gamma = (float) acos((a2 + b2 - c2) / (2 * a * b));\\n        //Conversi\xf3n a grados\\n        alfa = (float) (alfa * 180 / PI);\\n        beta = (float) (beta * 180 / PI);\\n        gamma = (float) (gamma * 180 / PI);\\n        //Imprimiendo los angulos\\n        // printing all the angles \\n        System.out.println(\\"alfa : \\" + alfa);\\n        System.out.println(\\"beta : \\" + beta);\\n        System.out.println(\\"gamma : \\" + gamma);\\n    }\\n\\n    public static void main(String[] args) {\\n        Point A = new Point(0, 0);\\n        Point B = new Point(0, 1);\\n        Point C = new Point(1, 0);\\n        printAngle(A, B, C);\\n    }\\n} \\n","cpp":null,"py":null,"orden":7,"suborden":19,"fecha_creacion":"2020-12-04 23:04:31","fecha_modificacion":"2020-12-06 20:25:49"},{"ID":110,"supergrupo":"BitWise","tema":"BitWise b\xe1sico ","texto":"Operaciones a nivel de bits.\\nn & 1  -> Verifica si n es impar o no\\nn & (1<<k) -> Verifica si el k-esimo bit esta encendido o no\\nn | (1<<k) -> Enciende el k-esimo bit\\nn & ~(1<<k) -> Apaga el k-esimo bit\\nn ^ (1<<k) -> Invierte el k-esimo bit\\n~n  -> Invierte todos los bits\\nn & -n  -> Devuelve el bit encendido mas a la derecha\\n~n & (n+1) -> Devuelve el bit apagado mas a la derecha\\nn | (n+1) -> Enciende el bit apagado mas a la derecha\\nn & (n-1) -> Apaga el bit encendido mas a la derecha\\nOtras operaciones a nivel de bits.\\n1) Borrar todos los bits desde el bit menos significativo (LSB) hasta el bit i\\n\u2022 mask = ~((1 << i+1 ) - 1);\\n\u2022 x &= mask;\\nPara borrar todos los bits de LSB a i-\xe9simo bit, tenemos que AND X con la m\xe1scara que tiene LSB a i-\xe9simo bit 0. Para obtener dicha m\xe1scara, primero se desplaza a la izquierda 1 veces. Ahora, si sumamos 1 a partir de eso, todos los bits de 0 a i-1 se convierten en 1 y los bits restantes se convierten en 0. Ahora simplemente podemos tomar el complemento de m\xe1scara para obtener todos los primeros bits de i en 0 y permanecer en 1.\\nEjemplo:\\n\u2022 x = 29 (00011101) y queremos borrar LSB al 3er bit, total 4 bits\\n\u2022 mask -> 1 << 4 -> 16(00010000)\\n\u2022 mask -> 16 \u2013 1 -> 15(00001111)\\n\u2022 mask -> ~mask -> 11110000\\n\u2022 x & mask -> 16 (00010000)\\n2) Borrar todos los bits del bit m\xe1s significativo (MSB) al bit i-\xe9simo \\n\u2022 mask = (1 << i) - 1;\\n\u2022 x &= mask;\\nPara borrar todos los bits de MSB a i-\xe9simo bit, tenemos que AND x con la m\xe1scara que tiene MSB a i-\xe9simo bit 0. Para obtener dicha m\xe1scara, primero se desplaza a la izquierda 1 veces. Ahora, si menos 1 de eso, todos los bits de 0 a i-1 se convierten en 1 y los bits restantes se convierten en 0.\\nEjemplo:\\n\u2022 x = 215 (11010111) y queremos borrar MSB al 4to bit, total 4 bits\\n\u2022 mask -> 1 << 4 -> 16(00010000)\\n\u2022 mask -> 16 \u2013 1 -> 15(00001111)\\n\u2022 x & mask -> 7(00000111)\\n3) Dividir por 2\\n\u2022 x >>= 1;\\nCuando hacemos un desplazamiento aritm\xe9tico a la derecha, cada bit se desplaza a la derecha y la posici\xf3n en blanco se sustituye con un bit de signo de n\xfamero, 0 en caso de n\xfamero positivo y 1 en caso de n\xfamero negativo. Como cada bit es una potencia de 2, con cada cambio estamos reduciendo el valor de cada bit por un factor de 2 que es equivalente a la divisi\xf3n de x por 2.\\nEjemplo:\\n\u2022 x = 18(00010010)\\n\u2022 x >> 1 = 9 (00001001)\\n4) Multiplicar por 2\\n\u2022 x <<= 1;\\nCuando hacemos desplazamiento aritm\xe9tico a la izquierda, cada bit se desplaza a la izquierda y la posici\xf3n en blanco se sustituye por 0. Como cada bit es una potencia de 2, con cada cambio aumentamos el valor de cada bit por un factor de 2 que es equivalente a la multiplicaci\xf3n de x por 2.\\nEjemplo:\\n\u2022 x = 18(00010010)\\n\u2022 x << 1 = 36 (00100100)\\n5) Mayusculas a minusculas en el alfabeto ingles\\n\u2022 ch |= \' \';\\nLa representaci\xf3n en bits de las letras en ingl\xe9s en may\xfasculas y min\xfasculas es:\\nA -> 01000001          a -> 01100001\\nB -> 01000010          b -> 01100010\\nC -> 01000011          c -> 01100011\\n  .                               .\\n  .                               .\\nZ -> 01011010          z -> 01111010\\nComo podemos ver si establecemos el quinto bit de caracteres en may\xfasculas, se convertir\xe1 en caracteres en min\xfasculas. Tenemos que preparar una m\xe1scara que tenga el quinto bit 1 y otro 0 (00100000). Esta m\xe1scara es una representaci\xf3n en bits del car\xe1cter de espacio (\u2018\u2018). El car\xe1cter \\"ch\\" luego OR con la m\xe1scara.\\nEjemplo:\\n\u2022 ch = \u2018A\u2019 (01000001)\\n\u2022 mask = \u2018 \u2018 (00100000)\\n\u2022 ch | mask = \u2018a\u2019 (01100001)\\n6) Minusculas a mayusculas en el alfabeto ingles\\n\u2022 ch &= \'_\u2019 ;\\nLa representaci\xf3n en bits de las letras en ingl\xe9s en may\xfasculas y min\xfasculas es:\\nA -> 01000001                a -> 01100001\\nB -> 01000010                b -> 01100010\\nC -> 01000011                c -> 01100011\\n.                               .\\n.                               .\\nZ -> 01011010                z -> 01111010\\nComo podemos ver si borramos el quinto bit de caracteres en min\xfasculas, se convertir\xe1 en caracteres en may\xfasculas. Tenemos que preparar una m\xe1scara que tenga el quinto bit 0 y otro 1 (10111111). Esta m\xe1scara es una representaci\xf3n en bits del car\xe1cter de subrayado (\u2018_\u2018). El car\xe1cter \\"ch\\" luego AND con la m\xe1scara.\\nEjemplo:\\nch = \u2018a\u2019 (01100001)\\nmask = \u2018_ \u2018 (11011111)\\nch & mask = \u2018A\u2019 (01000001)\\n7) Cuenta los bits establecidos en un entero \\nint countSetBits(int x) {\\n    int count = 0;\\n    while (x) {\\n        x &= (x - 1);\\n        count++;\\n    }\\n    return count;\\n}\\nSe realiza esta operacion basado en el algoritmo de Brian Kernighan.\\n8) Encuentra la log base 2 de un entero de 32 bits\\nint log2(int x) {\\n    int res = 0;\\n    while (x >>= 1)\\n        res++;\\n    return res;\\n}\\nDesplazamos a la derecha x repetidamente hasta que se convierte en 0, mientras tanto, contamos con la operaci\xf3n de desplazamiento. Este valor de conteo es el log2 (x).\\n9) Comprobando si un entero de 32 bits es una potencia de 2\\nint isPowerof2(int x) {\\n    return (x && !(x & x - 1));\\n}\\nToda la potencia de 2 tiene solo un bit establecido, p. 16 (00010000). Si menos 1 de esto, todos los bits de LSB para establecer el bit se alternan, es decir, 16-1 = 15 (00001111). Ahora si realizamos AND x con (x-1) y el resultado es 0, entonces podemos decir que x es una potencia de 2, de lo contrario no. Tenemos que tener mucho cuidado cuando x = 0.\\nEjemplo:\\n\u2022 x = 16(000100000)\\n\u2022 x \u2013 1 = 15(00001111)\\n\u2022 x & (x-1) = 0\\n\u2022 Entonces 16 es potencia de 2\\n\\n\\n10) C\xf3mo establecer un bit en el n\xfamero \\"num\\":\\nSi queremos establecer un bit en la en\xe9sima posici\xf3n en el n\xfamero \\"num\\", se puede hacer usando el operador \\"OR\\" (|).\\n\u2022 Primero dejamos el desplazamiento \\"1\\" a la posici\xf3n n a trav\xe9s de (1 << n)\\n\u2022 Luego, use el operador \\"OR\\" para establecer el bit en esa posici\xf3n. El operador \\"OR\\" se usa porque establecer\xe1 el bit incluso si el bit no se ha establecido previamente en la representaci\xf3n binaria del n\xfamero \\"num\\".\\nC++\\n#include<iostream> \\nusing namespace std;\\n//num es el numero y pos es la posici\xf3n \\n//del bit que queremos activar\\n\\nvoid set(int & num, int pos) {\\n    //Primer paso es correr \'1\',\\n    //Segundo paso es realizar OR\\n    num |= (1 << pos);\\n}\\n\\nint main() {\\n    int num = 4, pos = 1;\\n    set(num, pos);\\n    cout << (int) (num) << endl;\\n    return 0;\\n}\\nSalida:\\n6\\n11)  C\xf3mo desestablecer un bit en el n\xfamero \\"num\\":\\nSupongamos que queremos desarmar un poco en la en\xe9sima posici\xf3n en el n\xfamero \\"num\\", entonces tenemos que hacer esto con la ayuda del operador \\"AND\\" (&).\\n\u2022 Primero dejamos el desplazamiento \u20181\u2019 a la posici\xf3n n mediante (1 << n) que usamos el operador NOT bit a bit \u2018~\u2019 para desactivar este desplazamiento sh 1 \u2019.\\n\u2022 Ahora, despu\xe9s de despejar esta izquierda desplazada \u20181\u2019, es decir, llegar a \u20180\u2019, \u2018AND \'(&) con el n\xfamero\u2018 num \u2019que desarmar\xe1 el bit en la en\xe9sima posici\xf3n.\\nC++\\n#include <iostream> \\nusing namespace std;\\n\\nvoid unset(int &num, int pos) {\\n    num &= (~(1 << pos));\\n}\\n\\nint main() {\\n    int num = 7;\\n    int pos = 1;\\n    unset(num, pos);\\n    cout << num << endl;\\n    return 0;\\n}\\nSalida:\\n5\\n12)  Alternar un bit en la en\xe9sima posici\xf3n:\\nAlternar significa activar el bit \'on\' (1) si estaba \'off\' (0) y desactivar \'(0) si estaba\' on \'(1) anteriormente. Usaremos el operador\' XOR \'aqu\xed que es esto \'^\' La raz\xf3n detr\xe1s del operador \\"XOR\\" se debe a sus propiedades.\\n\u2022 Propiedades de operador XOR.\\n\u2022 1^1 = 0\\n\u2022 0^0 = 0\\n\u2022 1^0 = 1\\n\u2022 0^1 = 1\\n\u2022 Si dos bits son diferentes, el operador \\"XOR\\" devuelve un bit establecido (1) de lo contrario, devuelve un bit no establecido (0).\\n\\nC++\\n#include <iostream> \\nusing namespace std;\\n\\nvoid toggle(int &num, int pos) {\\n    num ^= (1 << pos);\\n}\\n\\nint main() {\\n    int num = 4;\\n    int pos = 1;\\n    toggle(num, pos);\\n    cout << num << endl;\\n    return 0;\\n}\\nSalida:\\n6\\n13) Comprobando si el bit en la en\xe9sima posici\xf3n est\xe1 activado o desactivado:\\nEs bastante f\xe1cil de hacer con el operador \\"AND\\".\\n\u2022 Desplazar a la izquierda \'1\' a la posici\xf3n dada y luego \'Y\' (\'y\').#include <iostream> \\n\u2022 using namespace std; \\nC++\\nbool at_position(int num, int pos) {\\n    bool bit = num & (1 << pos);\\n    return bit;\\n}\\n\\nint main() {\\n    int num = 5;\\n    int pos = 0;\\n    bool bit = at_position(num, pos);\\n    cout << bit << endl;\\n    return 0;\\n}\\nSalida:\\n1\\nObserve que primero hemos dejado \\"1\\" desplazado y luego hemos usado el operador \\"Y\\" para obtener el bit en esa posici\xf3n. Entonces, si hay \'1\' en la posici\xf3n \'pos\' en \'num\', luego de \'AND\' nuestra variable \'bit\' almacenar\xe1 \'1\' m\xe1s si hay \'0\' en la posici\xf3n \'pos\' en el n\xfamero \'num\' que despu\xe9s de \'Y\' nuestro bit variable almacenar\xe1 \'0\'.\\n14) Invertir cada bit de un numero a un numero con complement a 1\\nSi queremos invertir cada bit de un n\xfamero, es decir, cambiar el bit \\"0\\" a \\"1\\" y el bit \\"1\\" a \\"0\\". Podemos hacerlo con la ayuda del operador \\"~\\". Por ejemplo: si n\xfamero es num = 00101100 (representaci\xf3n binaria), entonces \u2018~ num\u2019 ser\xe1 \u201811010011\u2019.\\nEste es tambi\xe9n el \\"complemento de n\xfamero 1\\".\\nC++\\n#include <iostream> \\nusing namespace std;\\n\\nint main() {\\n    int num = 4;\\n    // Invertir cada bit del numero\\n    cout << (~num);\\n    return 0;\\n}\\nSalida:\\n -5\\n15) Complemento a dos del n\xfamero\\nEntonces, formalmente podemos tener el complemento de 2 al encontrar el complemento de 1 y agregar 1 al resultado, es decir (~ num + 1) o qu\xe9 m\xe1s podemos hacer es usar el operador \u2018-\u2018.\\n\\nC++\\n#include <iostream> \\nusing namespace std;\\n\\nint main() {\\n    int num = 4;\\n    int twos_complement = -num;\\n    cout << \\"complemento a 2 \\" << twos_complement << endl;\\n    cout << \\"Tambien complemento a 2  \\" << (~num + 1) << endl;\\n    return 0;\\n}\\nSalida:\\nComplemento a 2 -4\\nTambien complemento a 2 -4\\n16) Eliminando el bit activo m\xe1s bajo:\\nEn muchas situaciones, queremos quitar el bit establecido m\xe1s bajo, por ejemplo, en la estructura de datos de \xe1rbol indexado binario, contando el n\xfamero de bit establecido en un n\xfamero.\\nHacemos algo como esto:\\nX = X & (X-1)\\nVeamos esto tomando un ejemplo, sea X = 1100. \\n(X-1) invierte todos los bits hasta que encuentre el conjunto m\xe1s bajo \'1\' y tambi\xe9n invierte ese conjunto m\xe1s bajo \'1\'.\\nX-1 se convierte en 1011. Despu\xe9s de realizar \'AND\' X con X-1 obtenemos el bit de ajuste m\xe1s bajo despojado.\\nC++\\n#include <iostream> \\nusing namespace std;\\n\\nvoid strip_last_set_bit(int &num) {\\n    num = num & (num - 1);\\n}\\n\\nint main() {\\n    int num = 7;\\n    strip_last_set_bit(num);\\n    cout << num << endl;\\n    return 0;\\n}\\nSalida:\\n6\\n17) Obtener el bit activo mas bajo de un numero:\\nEsto se hace usando la expresi\xf3n \'X & (- X)\'. Veamos esto tomando un ejemplo: Sea X = 00101100. Entonces ~ X (complemento de 1) ser\xe1 \'11010011\' y el complemento de 2 ser\xe1 (~ X + 1 o -X), es decir, \'11010100\'. Entonces, si \'AND\' el n\xfamero original \'X\' con su complemento de dos que es \'-X\', obtenemos el bit de ajuste m\xe1s bajo.\\n00101100\\n& 11010100\\n-----------\\n00000100\\n\\nC++\\n#include <iostream> \\nusing namespace std;\\n\\nint lowest_set_bit(int num) {\\n    int ret = num & (-num);\\n    return ret;\\n}\\n\\nint main() {\\n    int num = 10;\\n    int ans = lowest_set_bit(num);\\n    cout << ans << endl;\\n    return 0;\\n}\\nSalida:\\n2\\n\\n","complejidad_tiempo":null,"java":null,"cpp":null,"py":null,"orden":4,"suborden":0,"fecha_creacion":"2020-12-04 23:04:32","fecha_modificacion":"2020-12-06 20:11:13"},{"ID":111,"supergrupo":"BitWise","tema":"Suma uno","texto":"Sume uno a un n\xfamero dado, el uso de los operadores como \u2018+\u2019, \u2018-\u2018,\u2019*\u2019,\u2019/\u2019,\u2019++\u2019,\u2019\u2014\u2018\u2026. Entre otros no est\xe1 permitido.\\nLa respuesta se consigue con algo de magia de bits.\\nPara agregar 1 a un n\xfamero x(como 0011000111), voltee todos los bits luego del cero de m\xe1s a la derecha (bit 0) (obtenemos 0011000000) finalmente, voltee el cero de m\xe1s a la derecha tambi\xe9n (obtenemos 0011001000) para obtener la respuesta.\\n","complejidad_tiempo":"Mejor caso :    O(1)  Peor caso : O(1)  Promedio: O(1) ","java":"// Programa Java en donde se agrega uno a\\n// un n\xfamero dado\\n\\npublic class AddOne {\\n\\n    static int addOne(int x) {\\n        return -(~x);\\n    }\\n\\n    public static void main(String[] args) {\\n        System.out.println(addOne(13));\\n    }\\n}\\n","cpp":"#include <iostream>\\nusing namespace std;\\n\\nstring decToBin(int n) {\\n    if (n == 0)\\n        return \\"0\\";\\n    string bin = \\"\\";\\n    int ayuda = n;\\n    n = abs(n);\\n    while (n > 0) {\\n        bin = ((n & 1) == 0 ? \'0\' : \'1\') + bin;\\n        n >>= 1;\\n    }\\n\\n    return (ayuda < 0 ? bin = \'-\' + bin : bin);\\n}\\n\\nint addOne(int x) {\\n    return (-(~x));\\n}\\n\\nint main() {\\n    int a = 13;\\n    cout << a << \\" --\x3e \\" << decToBin(a) << endl;\\n    a = addOne(a);\\n    cout << a << \\" --\x3e \\" << decToBin(a) << endl;\\n    return 0;\\n}\\n","py":"from sys import stdin, stdout\\nrl = stdin.readline\\nwr = stdout.write\\n\\ndef addOne(n):\\n    wr(f\'{n} -> {bin(n)[2:]}\\\\n\')\\n    n = (-(~n))\\n    wr(f\'{n} -> {bin(n)[2:]}\\\\n\')\\n\\nn = int(rl())\\naddOne(n)\\n","orden":4,"suborden":1,"fecha_creacion":"2020-12-04 23:04:32","fecha_modificacion":"2020-12-06 20:11:13"},{"ID":112,"supergrupo":"BitWise","tema":"Comparaci\xf3n de signos","texto":"Dado dos enteros con signo, retorne true si los signos de los enteros dados son diferentes, de otra forma retorne falso, por ejemplo la funci\xf3n debe retornar true en -1 y +100, y debe retornar falso para -200 y -100. La funci\xf3n no debe usar ning\xfan operador aritm\xe9tico.\\nDejaremos los enteros dados ser x y y, el bit de signo es 1 en n\xfameros negativos, y 0 en n\xfameros positivos, El XOR de x y y puede tener el bit de signo en 1 si ellos tiene signos opuestos, en otras palabras, XOR de x y y ser\xe1 un n\xfamero negativo si x y y tienen signos opuestos.\\n","complejidad_tiempo":"Mejor caso :    O(1)  Peor caso : O(1)  Promedio: O(1) ","java":"//Programa Java para detectar si dos enteros\\n//tienen signos opuestos\\n\\npublic class OppositeSigns {\\n\\n    static boolean oppositeSigns(int x, int y) {\\n        return ((x ^ y) < 0);\\n    }\\n\\n    public static void main(String[] args) {\\n        int x = 100, y = -100;\\n        if (oppositeSigns(x, y) == true) {\\n            System.out.println(\\"Signos opuestos\\");\\n        } else {\\n            System.out.println(\\"Signos no opuestos\\");\\n        }\\n        x = 100;\\n        y = 100;\\n        if (oppositeSigns(x, y) == true) {\\n            System.out.println(\\"Signos son opuestos\\");\\n        } else {\\n            System.out.println(\\"Signos no son opuestos\\");\\n        }\\n    }\\n}\\n","cpp":"#include <iostream>\\n\\nusing namespace std;\\n\\nbool opposite(int a, int b) {\\n    return (a ^ b) < 0;\\n}\\n\\nint main() {\\n    int a = 123;\\n    int b = -123;\\n    if (opposite(a, b)) {\\n        cout << \\"Distintos signos\\" << endl;\\n    } else {\\n        cout << \\"Iguales signos\\" << endl;\\n    }\\n    return 0;\\n}\\n","py":"from sys import stdin, stdout\\nrl = stdin.readline\\nwr = stdout.write\\n\\ndef opposite(n, m):\\n    res = (n ^ m) < 0\\n    if res:\\n        wr(f\'Distintos\\\\n\')\\n    else:\\n        wr(f\'Iguales\\\\n\')\\n\\nn = 30\\nm = -100\\nopposite(n, m)\\n","orden":4,"suborden":2,"fecha_creacion":"2020-12-04 23:04:32","fecha_modificacion":"2020-12-06 20:11:14"},{"ID":113,"supergrupo":"BitWise","tema":"Multiplicaci\xf3n b\xe1sica","texto":"Podemos multiplicar un n\xfamero por 7 usando operadores BitWise, primero hacemos corrimiento izquierdo del n\xfamero de 3 bits (Se obtendr\xe1 8n) luego se resta la forma original del n\xfamero corrido y se retorna la diferencia (8n-n).\\nComplejidad de tiempo: O(1).\\nFunciona solo para enteros positivos.\\nEl mismo concepto puede ser usado para  multiplicaci\xf3n r\xe1pida por 9 u otros n\xfameros cambiando la formula bitwise.\\nPor ejemplo:\\n\u2022 (n << 1)  = x2\\n\u2022 ((n << 1) + n) = x3\\n\u2022 (n << 2) = x4\\n\u2022 ((n << 2) + n) = x5\\n\u2022 ((n << 3) - (n << 1)) = x6\\n\u2022 ((n << 3) - n) = x7\\n\u2022 (n << 3) = x8\\n\u2022 ((n << 3)+n) = x9\\n\u2022 (n << 3)+(n<<1) = x10\\n","complejidad_tiempo":"Mejor caso :    O(1)  Peor caso : O(1)  Promedio: O(1) ","java":"public class Multiply_2_to_10 {\\n\\n    public static void main(String[] args) {\\n        int a = 18;\\n        System.out.println(multiplyByTwo(a));\\n        System.out.println(multiplyByThree(a));\\n        System.out.println(multiplyByFour(a));\\n        System.out.println(multiplyByFive(a));\\n        System.out.println(multiplyBySix(a));\\n        System.out.println(multiplyBySeven(a));\\n        System.out.println(multiplyByEight(a));\\n        System.out.println(multiplyByNine(a));\\n        System.out.println(multiplyByTen(a));\\n    }\\n\\n    static int multiplyByTwo(int n) {\\n        return (n << 1);\\n    }\\n\\n    static int multiplyByThree(int n) {\\n        return ((n << 1) + n);\\n    }\\n\\n    static int multiplyByFour(int n) {\\n        return (n << 2);\\n    }\\n\\n    static int multiplyByFive(int n) {\\n        return ((n << 2) + n);\\n    }\\n\\n    static int multiplyBySix(int n) {\\n        return ((n << 3) - (n << 1));\\n    }\\n\\n    static int multiplyBySeven(int n) {\\n        return ((n << 3) - n);\\n    }\\n\\n    static int multiplyByEight(int n) {\\n        return (n << 3);\\n    }\\n\\n    static int multiplyByNine(int n) {\\n        return ((n << 3) + n);\\n    }\\n\\n    static int multiplyByTen(int n) {\\n        return (n << 3) + (n << 1);\\n    }\\n}\\n","cpp":"#include <iostream>\\n//-------------//\\n#define FAST ios_base::sync_with_stdio(false);cout.tie(NULL);\\n\\nusing namespace std;\\n\\nint multiplyByTwo(int n) {\\n    return (n << 1);\\n}\\n\\nint multiplyByThree(int n) {\\n    return ((n << 1) + n);\\n}\\n\\nint multiplyByFour(int n) {\\n    return (n << 2);\\n}\\n\\nint multiplyByFive(int n) {\\n    return ((n << 2) + n);\\n}\\n\\nint multiplyBySix(int n) {\\n    return ((n << 3) - (n << 1));\\n}\\n\\nint multiplyBySeven(int n) {\\n    return ((n << 3) - n);\\n}\\n\\nint multiplyByEight(int n) {\\n    return (n << 3);\\n}\\n\\nint multiplyByNine(int n) {\\n    return ((n << 3) + n);\\n}\\n\\nint multiplyByTen(int n) {\\n    return (n << 3) + (n << 1);\\n}\\n\\nint main() {\\n    FAST;\\n    int a = 9;\\n    cout << multiplyByTwo(a) << endl;\\n    cout << multiplyByThree(a) << endl;\\n    cout << multiplyByFour(a) << endl;\\n    cout << multiplyByFive(a) << endl;\\n    cout << multiplyBySix(a) << endl;\\n    cout << multiplyBySeven(a) << endl;\\n    cout << multiplyByEight(a) << endl;\\n    cout << multiplyByNine(a) << endl;\\n    cout << multiplyByTen(a) << endl;\\n    return 0;\\n}\\n","py":"from sys import stdin, stdout\\nrl = stdin.readline\\nwr = stdout.write\\n\\ndef multiplyZero(n):\\n    res = (n << 0) - n\\n    wr(f\'{n} x 0 = {res}\\\\n\')\\n\\ndef multiplyOne(n):\\n    res = (n << 1) - n\\n    wr(f\'{n} x 1 = {res}\\\\n\')\\n\\ndef multiplyTwo(n):\\n    res = (n << 1)\\n    wr(f\'{n} x 2 = {res}\\\\n\')\\n\\ndef multiplyThree(n):\\n    res = (n << 1)+n\\n    wr(f\'{n} x 3 = {res}\\\\n\')\\n\\ndef multiplyFour(n):\\n    res = (n << 2)\\n    wr(f\'{n} x 4 = {res}\\\\n\')\\n\\ndef multiplyFive(n):\\n    res = (n << 2)+n\\n    wr(f\'{n} x 5 = {res}\\\\n\')\\n\\ndef multiplySix(n):\\n    res = (n << 3)-(n << 1)\\n    wr(f\'{n} x 6 = {res}\\\\n\')\\n\\ndef multiplySeven(n):\\n    res = (n << 3)-n\\n    wr(f\'{n} x 7 = {res}\\\\n\')\\n\\ndef multiplyEight(n):\\n    res = (n << 3)\\n    wr(f\'{n} x 8 = {res}\\\\n\')\\n\\ndef multiplyNine(n):\\n    res = (n << 3)+n\\n    wr(f\'{n} x 9 = {res}\\\\n\')\\n\\ndef multiplyTen(n):\\n    res = (n << 3)+(n << 1)\\n    wr(f\'{n} x 10 = {res}\\\\n\')\\n\\nn = int(rl())\\nmultiplyZero(n)\\nmultiplyOne(n)\\nmultiplyTwo(n)\\nmultiplyThree(n)\\nmultiplyFour(n)\\nmultiplyFive(n)\\nmultiplySix(n)\\nmultiplySeven(n)\\nmultiplyEight(n)\\nmultiplyNine(n)\\nmultiplyTen(n)\\n","orden":4,"suborden":3,"fecha_creacion":"2020-12-04 23:04:33","fecha_modificacion":"2020-12-06 20:11:15"},{"ID":114,"supergrupo":"BitWise","tema":"Cuadrado de N sin usar pow","texto":"Dado un entero n, calcular el cuadrado de un n\xfamero sin usar *,/ y pow().\\nPodemos hacerlo en tiempo O(Logn) usando operadores de BitWise, la idea est\xe1 basada en el siguiente hecho:\\n- square(n) = 0 if n == 0\\n  Si n es par \\n-   square(n) = 4*square(n/2) \\n  Si n es impar\\n-    square(n) = 4*square(floor(n/2)) + 4*floor(n/2) + 1 \\nPor ejemplo:\\n- square(6) = 4*square(3)\\n- square(3) = 4*(square(1)) + 4*1 + 1 = 9\\n- square(7) = 4*square(3) + 4*3 + 1 = 4*9 + 4*3 + 1 = 49\\nSi n es par, puede ser escrito como:\\n-   n = 2*x \\n-   n^2 = (2*x)2 = 4*x2\\nSi n es impar, puede ser escrito como: \\n- n = 2*x + 1\\n-  n^2 = (2*x + 1)2 = 4*x2 + 4*x + 1\\nfloor(n/2)  puede ser calculado usando el operados de BitWise corrimiento derecho.\\n","complejidad_tiempo":"Mejor caso :    O(1)  Peor caso : O(1)  Promedio: O(1) ","java":"// Programa en java para calcular el cuadrado\\n// Sin usar * ni Pow()\\n\\npublic class NSquareNoPow {\\n\\n    static int square(int n) {\\n        // Caso base\\n        if (n == 0) {\\n            return 0;\\n        }\\n        if (n < 0) {\\n            n = -n;\\n        }\\n        // Obtener floor(n/2) usando\\n        // right shift \\n        int x = n >> 1;\\n        // si n es par\\n        ;\\n        if (n % 2 != 0) {\\n            return ((square(x) << 2)\\n                    + (x << 2) + 1);\\n        } else// si n es impar\\n        {\\n            return (square(x) << 2);\\n        }\\n    }\\n\\n    public static void main(String args[]) {\\n        for (int n = 1; n <= 5; n++) {\\n            System.out.println(\\"n = \\" + n\\n                    + \\" n^2 = \\"\\n                    + square(n));\\n        }\\n    }\\n}\\n","cpp":"#include<bits/stdc++.h>\\n#include<cstdlib>\\n#define c(x) cout<<x<<endl;\\n#define cn(x) cout<<x;\\n#define l(c) cin>>t;\\nusing namespace std;\\nint square(int n){\\n    if(n==0){\\n        return 0;\\n    }\\n    if(n<0){\\n        n=-n;\\n    }\\n    int x=n>>1;\\n    if((n&1)>0){\\n        return ((square(x)<<2)+(x<<2)+1);\\n    }else{\\n        return (square(x)<<2);\\n    }\\n}\\nint main() {\\n    for(int i=0;i<10;i++){\\n        c(square(i));\\n    }\\n}\\n\\n","py":"from sys import stdin\\nfrom sys import stdout\\nrl = stdin.readline\\nwr = stdout.write\\n\\ndef square(n):\\n    if n == 0:\\n        return 0\\n    if n < 0:\\n        n = -n\\n    x = n >> 1\\n    if n & 1:\\n        return (square(x) << 2) + (x << 2) + 1\\n    else:\\n        return (square(x) << 2)\\n\\nfor i in range(11):\\n    wr(f\'{i} -> {square(i)}\\\\n\')\\n","orden":4,"suborden":4,"fecha_creacion":"2020-12-04 23:04:33","fecha_modificacion":"2020-12-06 20:11:15"},{"ID":115,"supergrupo":"BitWise","tema":"Pal\xedndromo binario","texto":"Encuentre el n\xfamero cuya representaci\xf3n binaria es un pal\xedndromo. No se consideran los ceros iniciales, Mientras se considera la representaci\xf3n binaria, considere el primer n\xfamero cuya representaci\xf3n binaria es pal\xedndroma como 1, en vez de 0.\\nUna aproximaci\xf3n ingenua puede ser atravesar a trav\xe9s de todos los enteros desde 1 hasta 2^31-1 e incrementar el conteo pal\xedndromo, si el n\xfamero es pal\xedndromo, cuando el conteo pal\xedndromo alcanza el n requerido, rompe el ciclo y retorna el actual entero.\\nLa complejidad de tiempo de esta soluci\xf3n es O(x) donde x es el n\xfamero resultado. Note que el valor de x es generalmente m\xe1s grande que n.\\n","complejidad_tiempo":"Mejor caso :    O(x)  Peor caso : O(x)  Promedio: O(x) ","java":"/* Programa Java para buscar el Nesimo n\xfamero el cual\\nsu binario es un pal\xedndromo*/\\npublic class BinaryPalindromeN {\\n\\n    static int INT_MAX = 2147483647;\\n    /*Busca si el kesimo bit esta \\n    puesto en la representaci\xf3n binaria*/\\n    static int isKthBitSet(int x, int k) {\\n        return ((x & (1\\n                << (k - 1))) > 0) ? 1 : 0;\\n    }\\n\\n    /*Retorna la posicion de m\xe1s a la izquierda\\n    el set de bits en la representacion binaria*/\\n    static int leftmostSetBit(int x) {\\n        int count = 0;\\n        while (x > 0) {\\n            count++;\\n            x = x >> 1;\\n        }\\n        return count;\\n    }\\n\\n    /*Encuentra cuales sean los enteros en binario\\n    siendo plindromos o no*/\\n    static int isBinPalindrome(int x) {\\n        int l = leftmostSetBit(x);\\n        int r = 1;\\n        //Uno a uno se comparan los bits\\n        while (l > r) {\\n        //Comprara bits de izquierda y derecha\\n        // y converge \\n            if (isKthBitSet(x, l)\\n                    != isKthBitSet(x, r)) {\\n                return 0;\\n            }\\n            l--;\\n            r++;\\n        }\\n        return 1;\\n    }\\n\\n    static int findNthPalindrome(int n) {\\n        int pal_count = 0;\\n        /*Comienza desde 1, atravieza por todos los\\n        enteros*/\\n        int i = 0;\\n        for (i = 1; i <= INT_MAX; i++) {\\n            if (isBinPalindrome(i) > 0) {\\n                pal_count++;\\n            }\\n            /*Si nosotros llegamos n \\n            rompe el ciclo*/\\n            if (pal_count == n) {\\n                break;\\n            }\\n        }\\n        return i;\\n    }\\n\\n    public static void main(String[] args) {\\n        int n = 9;\\n        System.out.println(findNthPalindrome(n));\\n    }\\n} \\n","cpp":null,"py":"from sys import maxsize\\nfrom sys import stdin\\nfrom sys import stdout\\nrl = stdin.readline\\nwr = stdout.write\\n\\ndef iskthBitSet(x, k):\\n    return 1 if (x & (1 << (k-1))) > 0 else 0\\n\\ndef leftMostSetBit(x):\\n    cont = 0\\n    while x > 0:\\n        cont += 1\\n        x = x >> 1\\n    return cont\\n\\ndef isBinPal(x):\\n    l = leftMostSetBit(x)\\n    r = 1\\n    while l > r:\\n        if iskthBitSet(x, 1) != iskthBitSet(x, r):\\n            return 0\\n        l -= 1\\n        r += 1\\n    return 1\\n\\ndef findNthPal(n):\\n    pal_cont = 0\\n    i = 0\\n    for i in range(maxsize):\\n        if isBinPal(i) > 0:\\n            pal_cont += 1\\n        if pal_cont == n:\\n            break\\n    return i\\n\\nstring = rl()\\nn = int(string, 16)\\nres = findNthPal(n)\\nwr(f\'{res} -> {bin(res)[2:]}\')\\n","orden":4,"suborden":5,"fecha_creacion":"2020-12-04 23:04:33","fecha_modificacion":"2020-12-06 20:11:16"},{"ID":116,"supergrupo":"BitWise","tema":"N\xfamero m\xe1s cercano con los mismos bits","texto":"Dado un entero positivo n, imprimir el siguiente m\xe1s peque\xf1o y el previo m\xe1s largo que tiene el mismo n\xfamero de bits 1 en su representaci\xf3n binaria.\\nAproximaci\xf3n por fuerza bruta:\\nUna simple aproximaci\xf3n es contar el n\xfamero de 1 en n, y luego incrementar o decrementar hasta que encontremos un n\xfamero con el mismo n\xfamero de 1.\\nAproximaci\xf3n optimizada:\\nVamos a inicial con el c\xf3digo de getNext, y luego nos movemos a getPrev.\\nAproximaci\xf3n de manipulaci\xf3n de bits para obtenci\xf3n del siguiente n\xfamero:\\nSi pensamos acerca cual ser\xe1 el siguiente n\xfamero, podemos observar lo siguiente, dado el n\xfamero 13948, su representaci\xf3n binaria es:\\n1   1   0   1   1  0  0  1  1  1  1  1  0  0\\n13  12  11  10  9  8  7  6  5  4  3  2  1  0\\nBuscamos hacer este n\xfamero m\xe1s grande, pero no muy grande, tambi\xe9n necesitamos mantener el mismo n\xfamero de unos.\\nNota: Dado un n\xfamero N y dos localizaciones de bits i y j, suponga que volteamos bit i desde 1 a 0, y bit j desde 0 a 1, si i>j, entonces n podr\xe1 decrementarse, si i<j entonces n podr\xe1 incrementarse.\\nSabemos lo siguiente:\\n- Si volteamos un cero a un uno, debemos voltear un uno a un cero.\\n- El n\xfamero (Luego de dos volteretas) podr\xeda ser m\xe1s grande si y solo si el bit cero a uno fue el izquierdo del bit uno a cero.\\nNosotros queremos hacer el n\xfamero m\xe1s grande, pero no necesariamente m\xe1s grande, por lo tanto necesitamos voltear el cero de m\xe1s a la derecha el cual tiene unos en el derecho de \xe9l.\\nPara pone resto en una forma diferente, nosotros estamos volteando el cero no final de m\xe1s a la derecho, esto es usando el ejemplo de abajo, los ceros finales son en la primera y cero posici\xf3n. El cero no final de m\xe1s a la derecha es un bit 7, vamos a llamar esta posici\xf3n p.\\n- p -> posici\xf3n de m\xe1s a la derecha que no sea cero final.\\nPaso 1: volteamos el cero m\xe1s a la derecha no final.\\n- 1    1   0   1  1  0  1  1  1  1  1  1  0  0\\n- 13  12  11  10  9  8  7  6  5  4  3  2  1  0\\nCon este cambio, hemos incrementado el n\xfamero de unos en n, podemos encojer el n\xfamero reordenando todos los bits de la derecha del bit p tales que los ceros est\xe1n en la izquierda y los unos est\xe1n a la derecha, cuando se hace esto, se busca reemplazar uno  de los unos con cero.\\nUna forma relativamente f\xe1cil de hacer esto es contando cuantos unos est\xe1n a la derecha de p, despejar todos los bits desde 0 hasta p, y luego agregar de nuevo en c1-1 unos. Dejar c1 ser el n\xfamero de unos de la derecha de p y c0 el n\xfamero de ceros de la derecha de p.\\nVamos a verificar esto con un ejemplo:\\n- c1-> N\xfamero de unos de la derecho de p\\n- c0-> N\xfamero de ceros de la derecho de p\\n- p = c0 + c1\\nPaso 2: despejar los bits de la derecha de p, como antes c0 = 2. c1 = 5. p = 7.\\n- 1    1   0   1  1  0  1  0  0  0  0  0  0  0\\n- 13  12  11  10  9  8  7  6  5  4  3  2  1  0\\nPara despejar estos bits, necesitamos crear una m\xe1scara que sea una secuencia de unos, seguido por p ceros, podemos hacer esto de la siguiente forma:\\nTodos los ceros excepto por un 1 en la posici\xf3n p.\\n- a = 1 << p; \\nTodos los ceros, seguidos por p unos. \\n- b = a - 1;                       \\nTodos los unos, seguidos por p ceros.\\n- mask = ~b;                       \\nDespeja los p bits de m\xe1s a la derecha.\\n- n = n & mask;                \\nO m\xe1s concisamente, hacemos: \\n- n &= ~ ((1 << p) - 1).\\nPaso 3: Agrega un c1=1 unos.\\n- 1   1   0   1   1  0  1  0  0  0  1  1  1  1\\n- 13  12  11  10  9  8  7  6  5  4  3  2  1  0\\nPara insertar c1-1 unos a la derecha, se realiza:\\nCeros con un uno en la posici\xf3n c1\u2013 1\\n- a = 1 << (c1 - 1);    \\nCeros con unos en posiciones cero a trav\xe9s de c1-1\\n- b = a - 1;                \\nInserta unos en las posiciones 0 a trav\xe9s de c1-1\\n- n = n | b;                \\nO m\xe1s concisamente:\\n- n | = (1 << (c1 - 1)) - 1;  \\n","complejidad_tiempo":"Mejor caso :    O(n)  Peor caso : O(n)  Promedio: O(n) ","java":"/* Programa JAVA de busqueda del siguiente n\xfamero con \\nla misma cantidad de 1 que algun anterior*/\\npublic class ClosestNumbersSamebits {\\n\\n    static int getNext(int n) {\\n        // Computa c0 y c1\\n        int c = n;\\n        int c0 = 0;\\n        int c1 = 0;\\n        while (((c & 1) == 0)\\n                && (c != 0)) {\\n            c0++;\\n            c >>= 1;\\n        }\\n        while ((c & 1) == 1) {\\n            c1++;\\n            c >>= 1;\\n        }\\n        /*Si no hay n\xfamero m\xe1s grande \\n        con el n\xfamero de 1 buscado*/\\n        if (c0 + c1 == 31\\n                || c0 + c1 == 0) {\\n            return -1;\\n        }\\n        //Posicion de el m\xe1s derecho cero \\n        int p = c0 + c1;\\n        //Voltea el zero m\xe1s derecho\\n        n |= (1 << p);\\n        // Despeja todos los bits de la derecha de p\\n        n &= ~((1 << p) - 1);\\n        //Inserta los (c1-1) a la derecha\\n        n |= (1 << (c1 - 1)) - 1;\\n        return n;\\n    }\\n\\n    static int getPrev(int n) {\\n        int temp = n;\\n        int c0 = 0;\\n        int c1 = 0;\\n        while ((temp & 1) == 1) {\\n            c1++;\\n            temp = temp >> 1;\\n        }\\n        if (temp == 0) {\\n            return -1;\\n        }\\n        while (((temp & 1) == 0)\\n                && (temp != 0)) {\\n            c0++;\\n            temp = temp >> 1;\\n        }\\n        // posicion de el cero no final de \\n        // mas a la derecha\\n        int p = c0 + c1;\\n        //limpia del bit c hacia adelante \\n        n = n & ((~0) << (p + 1));\\n        // Secuencia de (c1+1) unos\\n        int mask = (1 << (c1 + 1)) - 1;\\n        n = n | mask << (c0 - 1);\\n        return n;\\n    }\\n\\n    public static void main(String[] args) {\\n        int n = 5;\\n        System.out.println(n + \\"->\\" + Integer.toString(n, 2) + \\" \\" + getNext(n));\\n\\n        System.out.println(n + \\"->\\" + Integer.toString(n, 2) + \\" \\" + getPrev(n));\\n    }\\n}\\n","cpp":"#include<bits/stdc++.h>\\n#include<cstdlib>\\n//---------------//\\nusing namespace std;\\nint getNext(int n){\\n    int c=n;\\n    int c0=0;\\n    int c1=0;\\n    while((c&1)==0 && (c!=0)){\\n        c0++;\\n        c >>=1;\\n    }\\n    while((c&1)==1){\\n        c1++;\\n        c >>=1;\\n    }\\n    if(c0+c1 ==31 || c0+c1==0){\\n        return -1;\\n    }\\n    int p=c0+c1;\\n    n|=(1<<p);\\n    n&=~((1<<p)-1);\\n    n|=(1<<(c1-1))-1;\\n    return n;\\n}\\n\\nint getPrev(int n){\\n    int temp=n;\\n    int c0=0;\\n    int c1=0;\\n    while((temp&1)==1){\\n        c1++;\\n        temp >>=1;\\n    }\\n    if(temp==0){\\n        return -1;\\n    }\\n    while(((temp&1)==0) && (temp!=0)){\\n        c0++;\\n        temp >>=1;\\n    }\\n    int p=c0+c1;\\n    n&=((~0)<<(p+1));\\n    int mask=(1<<(c1+1))-1;\\n    n|=mask<<(c0-1);\\n    return n;\\n}\\nint main() {\\n    int n=5;\\n    cout<<(getNext(n))<<endl;\\n    n=5;\\n    cout<<(getPrev(n))<<endl;\\n}\\n","py":"from sys import stdin, stdout\\nrl = stdin.readline\\nwr = stdout.write\\n\\n\\ndef getNext(n):\\n    c = n\\n    c0 = 0\\n    c1 = 0\\n    while (c & 1 == 0) and (c != 0):\\n        c0 += 1\\n        c >>= 1\\n    while (c & 1) == 1:\\n        c1 += 1\\n        c >>= 1\\n    if (c0 + c1 == 31) or (c0 + c1 == 0):\\n        return -1\\n    p = c0 + c1\\n    # Mascaras de Bits\\n    n |= (1 << p)\\n    n &= ~((1 << p)-1)\\n    n |= (1 << (c1-1))-1\\n    return n\\n\\n\\ndef getPrev(n):\\n    temp = n\\n    c0 = 0\\n    c1 = 0\\n    while (temp & 1) == 1:\\n        c1 += 1\\n        temp = temp >> 1\\n    if temp == 0:\\n        return -1\\n    while (temp & 1 == 0) and (temp != 0):\\n        c0 += 1\\n        temp = temp >> 1\\n    p = c0 + c1\\n    n &= ((~0) << (p + 1))\\n    mask = (1 << (c1 + 1)) - 1\\n    n |= mask << (c0 - 1)\\n    return n\\n\\n\\nn = int(rl())\\nwr(f\'{n} -> {bin(n)[2:]}\\\\n\')\\nwr(f\'{getNext(n)} -> {bin(getNext(n))[2:]}\\\\n\')\\nwr(f\'{getPrev(n)} -> {bin(getPrev(n))[2:]}\')\\n","orden":4,"suborden":6,"fecha_creacion":"2020-12-04 23:04:34","fecha_modificacion":"2020-12-06 20:11:16"},{"ID":117,"supergrupo":"BitWise","tema":"C\xf3digos de Gray a Binario e inversos","texto":"N\xfameros binarios es la forma por defecto para almacenar n\xfameros, pero en muchas aplicaciones los n\xfameros binarios son dif\xedciles de usar y una variaci\xf3n de los n\xfameros binarios es necesaria, aqu\xed es cuando los c\xf3digos de Gray son muy \xfatiles.\\nEl c\xf3digo de gray tiene una propiedad, dos n\xfameros sucesivos difieren en un solo bit porque esta propiedad permite tener ciclo a trav\xe9s de varios estados con un esfuerzo m\xednimo y son usados en mapas k, tambi\xe9n permiten correcci\xf3n de errores, comunicaci\xf3n entre  muchas cosas m\xe1s.\\n\xbfC\xf3mo generar c\xf3digos de Gray de n bits?\\nLa siguiente es la secuencia de dos bits (n=2)\\n-   00 01 11 10\\nLa siguiente es la secuencia de 3 bits (n = 3)\\n- 000 001 011 010 110 111 101 100\\nY la siguiente es la secuencia de 4 bits (n = 4)\\n- 0000 0001 0011 0010 0110 0111 0101 0100 1100 1101 1111 1110 1010 1011 1001 1000\\nLos c\xf3digos de Gray de n bits pueden ser generados de la lista de (n-1) c\xf3digos de Gray con los siguientes pasos.\\n- Dejar la lista de (n-1)bits ser L1, crear otra lista L2 la cual es la reversa de L1\\n- Modificar la lista L1 usando prefijo \u20180\u2019 en todos los c\xf3digos de L1\\n- Concatene L1 y L2. La lista concatenada es la lista requerida de los c\xf3digos de Gray de n bits\\nEn ciencias de la computaci\xf3n muchas veces necesitamos convertir de c\xf3digo binario a c\xf3digo de Gray y viceversa, esta conversion puede ser realizada bajo las siguientes reglas:\\nConversi\xf3n de binario a Gray:\\nEl bit m\xe1s significante (MSB most significant bit) del c\xf3digo de gray es siempre igual a el MSB del c\xf3digo binario dado.\\nOtros bits de la salida del c\xf3digo de gray pueden ser obtenidos realizando XOR al bit del c\xf3digo binario en ese \xedndice y en el \xedndice anterior.\\nConversi\xf3n de Gray a binario: \\nEl MSB del c\xf3digo binario es siempre igual al MSB del c\xf3digo de Gray.\\nLos otros bits de la salida del c\xf3digo binario pueden ser obtenidos verificando el bit del c\xf3digo Gray en ese incide, si el bit actual es 0, entonces copia el anterior bit del c\xf3digo binario, si no copia el inverso del anterior bit del c\xf3digo binario.\\n","complejidad_tiempo":"Mejor caso :    O(n2)  Peor caso : O(n2)  Promedio: O(n2) ","java":"// Programa en java para coversion binario - Gray e inverso\\n\\nimport java.io.*;\\n\\npublic class CodeConversionGrayToBinary {\\n\\n    public static void main(String args[]) throws IOException {\\n\\n        String binary = \\"01001\\";\\n        System.out.println(\\"Codigo gray de \\" + binary + \\" is \\" + binarytoGray(binary));\\n\\n        String gray = \\"01101\\";\\n        System.out.println(\\"Codigo Binaruo de \\" + gray + \\" is \\" + graytoBinary(gray));\\n    }\\n\\n    static char xor_c(char a, char b) {\\n        return (a == b) ? \'0\' : \'1\';\\n    }\\n    //Funcion para voltear el bit \\n\\n    static char flip(char c) {\\n        return (c == \'0\') ? \'1\' : \'0\';\\n    }\\n    //Funcion binario a gray\\n\\n    static String binarytoGray(String binary) {\\n        String gray = \\"\\";\\n        gray += binary.charAt(0);\\n        // Coomputa bits restantes, siguiente bit es conmutado haciendole\\n        // XOR del previo con el actual en binario\\n        for (int i = 1; i < binary.length(); i++) {\\n            /*Comcatena XOR del bit anterior con el actual*/\\n            gray += xor_c(binary.charAt(i - 1),\\n                    binary.charAt(i));\\n        }\\n        return gray;\\n    }\\n    //Funcion gray a binario\\n    static String graytoBinary(String gray) {\\n        String binary = \\"\\";\\n        binary += gray.charAt(0);\\n        // Computa bits restantes,\\n        for (int i = 1; i < gray.length(); i++) {\\n            //Si el bit actual es 0, concatena el bit anterior\\n            if (gray.charAt(i) == \'0\') {\\n                binary += binary.charAt(i - 1);\\n            } //Sino, concatena invertidamente el bit anterior\\n            else {\\n                binary += flip(binary.charAt(i - 1));\\n            }\\n        }\\n        return binary;\\n    }\\n}\\n","cpp":"#include<bits/stdc++.h>\\n#include<cstdlib>\\n//---------------//\\nusing namespace std;\\nchar xor_c(char a,char b){\\n    return (a==b)?\'0\':\'1\';\\n}\\nchar flip(char c){\\n    return (c==0)?\'1\':\'0\';\\n}\\nstring grayToBinary(string gray){\\n    string binary = \\"\\";\\n    int tam = gray.size();\\n    binary += gray[0];\\n    for(int i = 1; i < tam; i++){\\n        if(gray[i] == \'0\'){\\n            binary += binary[i - 1];\\n        }else{\\n            binary += flip(binary[i - 1]);\\n        }\\n    }\\n    return binary;\\n}\\nstring binaryToGrey(string binary){\\n    string grey=\\"\\";\\n    grey+=binary[0];\\n    for(int i=1;i<binary.size();i++){\\n        grey+=xor_c((binary[i-1]),(binary[i]));\\n    }\\n    return grey;\\n}\\nint main() {\\n    string n=\\"01001\\";\\n    cout<<(binaryToGrey(n))<<endl;\\n    n=\\"01001\\";\\n    cout<<(grayToBinary(n))<<endl;\\n}\\n","py":"from sys import stdin, stdout\\nrl = stdin.readline\\nwr = stdout.write\\n\\ndef binarytoGray(binary):\\n    gray = \'\'\\n    gray += binary[0]\\n    for i in range(1, len(binary)):\\n        gray += xor_c(binary[i-1], binary[i])\\n    return gray\\n\\ndef xor_c(a, b):\\n    return \'0\' if a == b else \'1\'\\n\\ndef flip(c):\\n    return \'1\' if c == \'0\' else \'0\'\\n\\ndef graytoBinary(gray):\\n    binary = \'\'\\n    binary += gray[0]\\n    for i in range(1, len(gray)):\\n        if gray[i] == \'0\':\\n            binary += binary[i-1]\\n        else:\\n            binary += flip(binary[i-1])\\n    return binary\\n\\nb1 = \'01001\'\\nres = binarytoGray(b1)\\nwr(f\'{b1} -> {res}\\\\n\')\\nres2 = graytoBinary(res)\\nwr(f\'{res} -> {res2}\')\\n","orden":4,"suborden":7,"fecha_creacion":"2020-12-04 23:04:34","fecha_modificacion":"2020-12-06 20:11:17"},{"ID":118,"supergrupo":"BitWise","tema":"C\xf3digos de Gray de N bits","texto":"Dado un n\xfamero n, generar los patrones de bits de 0 a 2^n-1 de los cuales cada patr\xf3n sucesivo difiera en uno solo bit.\\nLos c\xf3digos de Gray de n bits pueden ser generados de la lista de (n-1) c\xf3digos de Gray con los siguientes pasos.\\n- Dejar la lista de (n-1)bits ser L1, crear otra lista L2 la cual es la reversa de L1\\n- Modificar la lista L1 usando prefijo \u20180\u2019 en todos los c\xf3digos de L1\\n- Concatene L1 y L2. La lista concatenada es la lista requerida de los c\xf3digos de Gray de n bits\\nPor ejemplo, los siguientes son los pasos para generar el c\xf3digo de Gray de 3 bits desde la lista de c\xf3digos de Gray de 2 bits.\\n- L1 = {00, 01, 11, 10} (Lista de Gray de dos bits)\\n- L2 = {10, 11, 01, 00} (Reversa de  L1)\\n- Agrega prefijo a todas las entradas de L1 con \u20180\u2019, L1 se convierte en {000, 001, 011, 010}\\n- Agrega prefijo a todas las entradas de L2 con \u20181\u2019, L2 se convierte en {110, 111, 101, 100}\\n- Concatena L1 y L2, obtenemos {000, 001, 011, 010, 110, 111, 101, 100}\\nPara generar los c\xf3digos de Gray de n bits, empezamos desde la lista de Grays de un solo bit, la cual es {0,1}, repetimos los pasos de arriba para general la lista de 2 bits a partir de la de 1 solo bit, luego generamos la de 3 bits a partir de la de 2 bits, y as\xed hasta que el n\xfamero de bits sea igual a n.\\n","complejidad_tiempo":"Mejor caso :    O(nlog(n))  Peor caso : O(nlog(n))  Promedio: O(nlog(n)) ","java":"//Programa Java para generar codigos de Gray Nesimos  \\n\\nimport java.util.ArrayList;\\n\\npublic class GrayCodesOfN {\\n\\n    static void generateGrayarr(int n) {\\n        // Caso base\\n        if (n <= 0) {\\n            return;\\n        }\\n        // \'arr\' podria almacenar todos los codigos generados \\n        ArrayList<String> arr = new ArrayList<String>();\\n        // Comienza con un patron de un bit \\n        arr.add(\\"0\\");\\n        arr.add(\\"1\\");\\n        /* Cada iteracion de este ciclo genera 2*i codigos desde los \\n        i codigos generados previamente*/\\n        int i, j;\\n        for (i = 2; i < (1 << n); i = i << 1) {\\n            /*Entra los previamente generados codigos de nuevo a arr[]\\n                en orden reverso, arr[] tiene el doble de n\xfamero de codigos*/\\n            for (j = i - 1; j >= 0; j--) {\\n                arr.add(arr.get(j));\\n            }\\n            // Concatena 0 a la primera mitad\\n            for (j = 0; j < i; j++) {\\n                arr.set(j, \\"0\\" + arr.get(j));\\n            }\\n            // Concatena 1 a la segunda mitad\\n            for (j = i; j < 2 * i; j++) {\\n                arr.set(j, \\"1\\" + arr.get(j));\\n            }\\n        }\\n        // Imprime el contenido de arr\\n        for (i = 0; i < arr.size(); i++) {\\n            System.out.println(arr.get(i));\\n        }\\n    }\\n\\n    public static void main(String[] args) {\\n        generateGrayarr(3);\\n    }\\n}\\n","cpp":"#include<bits/stdc++.h>\\n#include<cstdlib>\\n//---------------//\\nusing namespace std;\\nvoid generateGray(int n){\\n    if(n<=0){\\n        return;\\n    }\\n    vector<string>arr;\\n    arr.push_back(\\"0\\");\\n    arr.push_back(\\"1\\");\\n    for(int i=2;i<(1<<n);i <<=1){\\n        for(int j = i-1;j>=0;j--){\\n            arr.push_back(arr[j]);\\n        }\\n        for(int j=0;j<i;j++){\\n            arr[j]=\\"0\\"+arr[j];\\n        }\\n        for(int j=i;j<2*i;j++){\\n            arr[j]=\\"1\\"+arr[j];\\n        }\\n    }\\n    for(int i=0;i<arr.size();i++){\\n        cout<<arr[i]<<endl;\\n    }\\n}\\nint main(){\\n    generateGray(5);\\n}\\n","py":"from sys import stdin, stdout\\nrl = stdin.readline\\nwr = stdout.write\\n\\ndef generateGray(n):\\n    if n <= 0:\\n        return\\n    arr = []\\n    arr.append(\'0\')\\n    arr.append(\'1\')\\n    i = 2\\n    j = 0\\n    while i < (1 << n):\\n        for j in range(i-1, -1, -1):\\n            arr.append(arr[j])\\n        for j in range(0, i):\\n            arr[j] = \'0\' + arr[j]\\n        for j in range(i, 2*i):\\n            arr[j] = \'1\' + arr[j]\\n        i = i << 1\\n    for i in range(len(arr)):\\n        wr(f\'{arr[i]}\\\\n\')\\n\\ngenerateGray(5)\\n","orden":4,"suborden":8,"fecha_creacion":"2020-12-04 23:04:34","fecha_modificacion":"2020-12-06 20:11:18"},{"ID":119,"supergrupo":"BitWise","tema":"Conteo de bits a activar para que  A sea B","texto":"Dados dos n\xfameros \u2018a\u2019 y \u2018b\u2019, contar el n\xfamero de bits necesarios a voltear para convertir \u2018a\u2019 en \u2018b\u2019.\\n1) Calcular el XOR de A y B:  a_xor_b = A ^ B\\n2) Contar los bits encendidos de lo de arriba\\nResultado:\\n        countSetBits(a_xor_b)\\nXOR de dos n\xfameros tendr\xe1 bits encendidos solo en esos lugares donde A difiera de B\\n","complejidad_tiempo":"Mejor caso :    O(bits)  Peor caso : O(bits)  Promedio: O(bits) ","java":"//Contar el n\xfamero de bits que van a ser volteados para convertir A en B  \\n\\npublic class CountAtoB {\\n\\n    public static int countSetBits(int n) {\\n        int count = 0;\\n        while (n != 0) {\\n            count += n & 1;\\n            n >>= 1;\\n        }\\n        return count;\\n    }\\n\\n    public static int FlippedCount(int a, int b) {\\n        //Retorna el conteo del set de bits en a XOR b \\n        return countSetBits(a ^ b);\\n    }\\n\\n    public static void main(String[] args) {\\n        int a = 10;\\n        int b = 20;\\n        System.out.print(FlippedCount(a, b));\\n    }\\n}\\n","cpp":"#include<bits/stdc++.h>\\n#include<cstdlib>\\n//---------------//\\nusing namespace std;\\nint countSetBits(int n){\\n    int cont=0;\\n    while(n!=0){\\n        cont+=n&1;\\n        n>>=1;\\n    }\\n    return cont;\\n}\\nint flippedCount(int a,int b){\\n    return countSetBits(a^b);\\n}\\nstring toBinary(int n){\\n    string r;\\n    while(n!=0) {r=(n%2==0 ?\\"0\\":\\"1\\")+r; n/=2;}\\n    return r;\\n}\\nint main(){\\n    int a=5;\\n    int b=100;\\n    cout<<a<<\\"->\\"<<toBinary(a)<<endl;\\n    cout<<b<<\\"->\\"<<toBinary(b)<<endl;\\n    cout<<flippedCount(a,b)<<endl;\\n}\\n\\n","py":"from sys import stdin, stdout\\nrl = stdin.readline\\nwr = stdout.write\\n\\ndef countSetBits(n):\\n    count = 0\\n    while n != 0:\\n        count += n & 1\\n        n >>= 1\\n    return count\\n\\ndef flipperCount(a, b):\\n    return countSetBits(a ^ b)\\n\\na = 50\\nb = 100\\nwr(f\'{a} -> {bin(a)[2:]}\\\\n\')\\nwr(f\'{b} -> {bin(b)[2:]}\\\\n\')\\nwr(f\'{flipperCount(a,b)}\')\\n","orden":4,"suborden":9,"fecha_creacion":"2020-12-04 23:04:35","fecha_modificacion":"2020-12-06 20:11:18"},{"ID":120,"supergrupo":"BitWise","tema":"Conteo de bits activos ","texto":"Dado un entero positivo n, cuente el n\xfamero total de bits encendidos en representaci\xf3n binaria de todos los n\xfameros de 1 a n.\\nUna soluci\xf3n simple es correr un ciclo desde 1 hasta n y sumar el conteo de todos los n\xfameros de 1 a n.\\n","complejidad_tiempo":"Mejor caso :    O(n)  Peor caso : O(n)  Promedio: O(n) ","java":"//Un programa simpre que cuenta los bits set (Encendidos)\\n//en todos los n\xfameros de 1 a n.\\n\\npublic class CountSetBits {\\n\\n    static int countSetBits(int n) {\\n        int bitCount = 0;\\n        for (int i = 1; i <= n; i++) {\\n            bitCount += countSetBitsUtil(i);\\n        }\\n        return bitCount;\\n    }\\n   \\n    static int countSetBitsUtil(int x) {\\n        if (x <= 0) {\\n            return 0;\\n        }\\n        return (x % 2 == 0 ? 0 : 1)\\n                + countSetBitsUtil(x / 2);\\n    }\\n\\n    public static void main(String[] args) {\\n        int n = 4;\\n        System.out.print(\\"Conteo total del set de bits es \\");\\n        System.out.print(countSetBits(n));\\n    }\\n}\\n","cpp":"#include<bits/stdc++.h>\\n#include<cstdlib>\\n//---------------//\\nusing namespace std;\\nstring toBinary(int n){\\n    string r;\\n    while(n!=0) {r=(n%2==0 ?\\"0\\":\\"1\\")+r; n/=2;}\\n    return r;\\n}\\nint countSetBitUtil(int x){\\n    if(x<=0){\\n        return 0;\\n    }\\n    return (x%2==0?0:1)+countSetBitUtil(x/2);\\n}\\nint countBitSetBits(int n){\\n    int bitCount=0;\\n    for(int i=1;i<=n;i++){\\n        cout<<i<<\\"->\\"<<toBinary(i)<<endl;\\n        bitCount+=countSetBitUtil(i);\\n    }\\n    return bitCount;\\n}\\nint main(){\\n    int n=4;\\n    cout<<countBitSetBits(n)<<endl;\\n}\\n\\n","py":"from sys import stdin, stdout\\nrl = stdin.readline\\nwr = stdout.write\\n\\ndef countSetBit(n):\\n    bitcount = 0\\n    for i in range(1, n+1):\\n        wr(f\'{i} -> {bin(i)[2:]}\\\\n\')\\n        bitcount += countSetBitsUtil(i)\\n    return bitcount\\n\\ndef countSetBitsUtil(x):\\n    if x <= 0:\\n        return 0\\n    return (0 if (x & 1 == 0) else 1) + countSetBitsUtil(x//2)\\n\\nn = 5\\nwr(f\'{countSetBit(n)}\')\\n","orden":4,"suborden":10,"fecha_creacion":"2020-12-04 23:04:35","fecha_modificacion":"2020-12-06 20:11:19"},{"ID":121,"supergrupo":"BitWise","tema":"Euclides sin modulo ni divisi\xf3n","texto":"El algoritmo de Euclides es usado para encontrar el GCD de dos n\xfameros.\\nLa idea es usar operaciones de BitWise, podemos encontrar x/2 usando x>>1. Podemos verificar si x es par o impar usando x&1.\\n- gcd(a, b) = 2*gcd(a/2, b/2) si ambos a y b son pares.\\n- gcd(a, b) = gcd(a/2, b)  si a es par y b es impar.\\n- gcd(a, b) = gcd(a, b/2) si a es impar y b es par.\\n","complejidad_tiempo":"Mejor caso :    O(log(n))  Peor caso : O(log(n))  Promedio: O(log(n)) ","java":"//Programa Java eficiente para realizar maximo comun divisor sin % y /\\n\\npublic class EuclidNoModAndDivide {\\n\\n    public static void main(String[] args) {\\n        System.out.println(gcd(8, 9));\\n    }\\n\\n    static int gcd(int a, int b) {\\n        // Casos base\\n        if (b == 0 || a == b) {\\n            return a;\\n        }\\n        if (a == 0) {\\n            return b;\\n        }\\n        /*Si ambos a y b son pares, divide ambos por 2\\n        y multiplica el resultado con 2*/\\n        if ((a & 1) == 0 && (b & 1) == 0) {\\n            return gcd(a >> 1, b >> 1) << 1;\\n        }\\n        //Si a es par, y b es impar, divide a por 2\\n        if ((a & 1) == 0 && (b & 1) != 0) {\\n            return gcd(a >> 1, b);\\n        }\\n        //Si a es impar y b es par, divide b por 2\\n        if ((a & 1) != 0 && (b & 1) == 0) {\\n            return gcd(a, b >> 1);\\n        }\\n        /*Si ambos son impares, entonces aplica el algoritmode \\n        resta normal, notese que el casp impar-impar siempre \\n        convierte casos impar-par  luego de una recursion*/\\n        return (a > b) ? gcd(a - b, b) : gcd(a, b - a);\\n    }\\n}\\n","cpp":"#include<bits/stdc++.h>\\n#include<cstdlib>\\n//---------------//\\nusing namespace std;\\nint gcd(int a,int b){\\n    if (b == 0 || a == 0) {\\n        return a;\\n    }\\n    if (a == 0) {\\n        return b;\\n    }\\n    if ((a & 1) == 0 && (b & 1) == 0) {\\n        return gcd(a >> 1, b >> 1) << 1;\\n    }\\n    if ((a & 1) == 0 && (b & 1) != 0) {\\n        return gcd(a >> 1, b);\\n    }\\n    if ((a & 1) != 0 && (b & 1) == 0) {\\n        return gcd(a, b >> 1);\\n    }\\n    return (a > b) ? gcd(a - b, b) : gcd(a, b - a);\\n}\\nint main(){\\n    cout<<gcd(50,30)<<endl;\\n}\\n","py":"from sys import stdin, stdout\\nrl = stdin.readline\\nwr = stdout.write\\n\\ndef gcd(a, b):\\n    if b == 0 or a == 0:\\n        return a\\n    if a == 0:\\n        return b\\n    if (a & 1 == 0) and (b & 1 == 0):\\n        return gcd(a >> 1, b >> 1) << 1\\n    if (a & 1 == 0) and (b & 1 != 0):\\n        return gcd(a >> 1, b)\\n    if (a & 1 != 0) and (b & 1 == 0):\\n        return gcd(a, b >> 1)\\n    return gcd(a - b, b) if a > b else gcd(a, b - a)\\n\\nwr(f\'{gcd(50,10)}\')\\n","orden":4,"suborden":11,"fecha_creacion":"2020-12-04 23:04:35","fecha_modificacion":"2020-12-06 20:11:19"},{"ID":122,"supergrupo":"BitWise","tema":"Buscar duplicados usando un arreglo de bits","texto":"Se tiene un arreglo de N n\xfameros, donde n es al menos 32000, el array puede tener entradas duplicadas y no se sabe que N es.\\nCon solo 4 kilobytes de memoria disponible, \xbfc\xf3mo podr\xeda imprimir todos los elementos duplicados en el array?\\nTenemos 4 kilobytes de memoria lo cual significa que podemos direccionar hasta 8*4*210 bits, note que 32*210 es m\xe1s grande que 32000, podemos crear un array de bits con 32000 bits, donde cada bit representa un entero.\\nSi se necesita crear un array de bit con m\xe1s de 32000 bits entonces se puede crear f\xe1cilmente m\xe1s y m\xe1s de 32000.\\nUsando este vector de bits, podemos entonces iterar a trav\xe9s del arreglo, marcando cada elemento v poniendo el bit v en 1, cuando pasemos por un elemento duplicado, los imprimimos.\\n","complejidad_tiempo":"Mejor caso :    O(n)  Peor caso : O(n)  Promedio: O(n) ","java":"//Programa Java para imprimir todos los duplicados en un arreglo\\n\\npublic class FindDuplicatesBitArray {\\n\\n    static class BitArray {\\n\\n        int[] arr;\\n        // Constructor \\n        public BitArray(int n) {\\n            /*Divide por 32, para almacenar n bits, nosotros necesitamos\\n            n/32 +1 enteros (Asumiendo int esta almacenado usando 32 bits*/\\n            arr = new int[(n >> 5) + 1];\\n        }\\n        // Obtener el valor de un bit en una posicion dada\\n        boolean get(int pos) {\\n            //Divide por 32 para encontrar la posicion del entero\\n            int index = (pos >> 5);\\n            //Ahora encuentra el bumero de bits en arr[index]\\n            int bitNo = (pos & 0x1F);\\n            //Encuentra el valor dado un n\xfamero bit en arr[index]\\n            return (arr[index] & (1 << bitNo)) != 0;\\n        }\\n        // Acomoda un bit en una posicion dada\\n        void set(int pos) {\\n            // Encuentra indice de una posicion de un bit\\n            int index = (pos >> 5);\\n            //Acomoda un n\xfamero bot es arr[index] \\n            int bitNo = (pos & 0x1F);\\n            arr[index] |= (1 << bitNo);\\n        }\\n        // Funcion de impresion de los duplicados\\n        static void checkDuplicates(int[] arr) {\\n            // Crea un bit con 320000 bits\\n            BitArray ba = new BitArray(320000);\\n            // Arreglo transverso de los elementos\\n            for (int i = 0; i < arr.length; i++) {\\n                // Indice de un arreglo de bits \\n                int num = arr[i] - 1;\\n                //Si n\xfamero ya se encuentra presente en el arreglo de bits\\n                if (ba.get(num)) {\\n                    System.out.print((num + 1) + \\" \\");\\n                } // Si no inserte el n\xfamero\\n                else {\\n                    ba.set(num);\\n                }\\n            }\\n        }\\n    }\\n\\n    public static void main(String[] args) {\\n        int[] arr = {10, 10, 1, 1, 2, 2, 3, 3};\\n        BitArray.checkDuplicates(arr);\\n    }\\n}\\n","cpp":"#include <iostream>\\n#include <vector>\\n\\nusing namespace std;\\n\\nstruct BitArray {\\n    vector <int> arr;\\n\\n    BitArray(int n) {\\n        arr.resize((n >> 5) + 1);\\n    }\\n\\n    bool get(int pos) {\\n        int index = (pos >> 5);\\n        int bitNo = (pos & 0x1F);\\n        return (arr[index] & (1 << bitNo)) != 0;\\n    }\\n\\n    void setPos(int pos) {\\n        int index = (pos >> 5);\\n        int bitNo = (pos & 0x1F);\\n        arr[index] |= (1 << bitNo);\\n    }\\n\\n    void checkDuplicates(vector <int>& arr, BitArray ba) {\\n        for (int i = 0; i < arr.size(); i++) {\\n            int num = arr[i] - 1;\\n            if (ba.get(num)) {\\n                cout << (num + 1) << \\" \\";\\n            } else {\\n                ba.setPos(num);\\n            }\\n        }\\n    }\\n};\\n\\nint main() {\\n    ios_base::sync_with_stdio(false);\\n    cin.tie(NULL);\\n    cout.tie(NULL);\\n    vector <int> arr{10, -10, -10, 8, 8, 5, 3, 4, 4, 3, 7, 9, -9, -8, -9};\\n    BitArray ba(32000);\\n    ba.checkDuplicates(arr, ba);\\n    return 0;\\n}\\n","py":"from sys import stdin, stdout\\nrl = stdin.readline\\nwr = stdout.write\\n\\nclass BitArray:\\n    arr = []\\n    def __init__(self, n):\\n        self.arr = [0 for x in range((n >> 5)+1)]\\n\\n    def get(self, pos):\\n        self.index = (pos >> 5)\\n        self.bitNo = (pos & 0x1f)\\n        return (self.arr[self.index] & (1 << self.bitNo)) != 0\\n\\n    def set(self, pos):\\n        self.index = (pos >> 5)\\n        self.bitNo = (pos & 0x1f)\\n        self.arr[self.index] |= (1 << self.bitNo)\\n\\n    def checkDuplicates(self, arr):\\n        for i in range(len(arr)):\\n            num = arr[i]-1\\n            if ba.get(num):\\n                wr(f\'{num+1} \')\\n            else:\\n                ba.set(num)\\n\\narr = [10, 10, 10, 5, 58, 8, 1, 5, 3, 2, 16, 4, 4]\\nba = BitArray(32000)\\nba.checkDuplicates(arr)\\n","orden":4,"suborden":12,"fecha_creacion":"2020-12-04 23:04:35","fecha_modificacion":"2020-12-06 20:11:20"},{"ID":123,"supergrupo":"BitWise","tema":"M\xe1ximo de unos consecutivos","texto":"Dado un entero n, pudiendo voltear exactamente un bit, encuentre la longitud de la secuencia m\xe1s larga de 1 que se pueda crear.\\nUna soluci\xf3n eficiente es andar a trav\xe9s de los bits en representaci\xf3n binaria del n\xfamero dado, mantenemos rastreo de la longitud de la secuencia actual de unos, de la longitud de la secuencia de unos previa, cuando veamos un cero, actualizamos la longitud anterior:\\n- Si el siguiente bit es un 1, la longitud anterior deber\xe1 ser ahora la longitud actual.\\n- Si el siguiente bit es un 0, entonces no podemos unir esas secuencias juntas, entonces la longitud previa es 0.\\nActualizamos la longitud m\xe1xima comparando las dos siguientes cosas:\\n- Valor actual de max_lenght\\n- Current-lenght+previos-length\\nEntonces\\n- result = return max-length+1 (// Agrega 1 para el Contador de bits volteados )\\n","complejidad_tiempo":"Mejor caso :    O(n)  Peor caso : O(n)  Promedio: O(n) ","java":"//Programa java para buscar el subset de 1 m\xe1s largo\\n\\npublic class MaxConsecutiveOne {\\n\\n    static int flipBit(int a) {\\n        /*Si todos los bits son 1, la representacion de \'a\'\\n        tiene todos los unos*/\\n        if (~a == 0) {\\n            return 8 * sizeof();\\n        }\\n        int currLen = 0, prevLen = 0, maxLen = 0;\\n        while (a != 0) {\\n            /*Si el bit actual es un 1\\n            entonces incrementa currLen++*/\\n            if ((a & 1) == 1) {\\n                currLen++;\\n            } /*Si el bit actual es un 0\\n            revisa el siguiente bit de a*/ else if ((a & 1) == 0) {\\n                /*Actualiza prevLan a 0 (Si el siguiente bit es 0)\\n                o currLen (Si el siguiente bit es 1)*/\\n                prevLen = (a & 2) == 0 ? 0 : currLen;\\n                /*Si dos bits consecutivos son 0\\n                entonces currLen tambien sera 0*/\\n                currLen = 0;\\n            }\\n            // Actualiza maxLen si es requerido \\n            maxLen = Math.max(prevLen + currLen, maxLen);\\n            //Remueve el ultimo digito (Right shift) \\n            a >>= 1;\\n        }\\n        /*Nosotros siempre podremos tener un secuencia de \\n        al menos un 1, este es un bit volteado*/\\n        return maxLen + 1;\\n    }\\n\\n    static byte sizeof() {\\n        byte sizeOfInteger = 8;\\n        return sizeOfInteger;\\n    }\\n\\n    public static void main(String[] args) {\\n        System.out.println(flipBit(13));\\n        System.out.println(flipBit(1775));\\n        System.out.println(flipBit(15));\\n    }\\n}\\n","cpp":"#include<bits/stdc++.h>\\n#include<cstdlib>\\n//---------------//\\nusing namespace std;\\nint SIZE(){\\n    int sizeOfInteger=8;\\n    return sizeOfInteger;\\n}\\nint flipBit(int a){\\n    if(~a==0){\\n        return 8*SIZE();\\n    }\\n    int currentlen=0,prevlen=0,maxlen=0;\\n    while(a!=0){\\n        if((a&1)==1){\\n            currentlen++;\\n        }\\n        else if((a&1)==0){\\n            prevlen=(a&2==0)?0:currentlen;\\n            currentlen=0;\\n        }\\n        maxlen=std::max(prevlen+currentlen,maxlen);\\n        a>>=1;\\n    }\\n    return maxlen+1;\\n}\\nstring toBinary(int n){\\n    string r;\\n    while(n!=0) {r=(n%2==0 ?\\"0\\":\\"1\\")+r; n/=2;}\\n    return r;\\n}\\nint main(){\\n    int a=654321;\\n    cout<<a<<\\"->\\"<<toBinary(a)<<\\" : \\"<<flipBit(a)<<endl;\\n\\n}\\n","py":"from sys import stdin, stdout\\nrl = stdin.readline\\nwr = stdout.write\\n\\ndef flipBit(a):\\n    if ~a == 0:\\n        return 8 * sizeof()\\n    currlen, prevlen, maxlen = 0, 0, 0\\n    while a != 0:\\n        if a & 1 == 1:  # Cambiar a 0\\n            currlen += 1\\n        elif a & 1 == 0:  # Cambiar a 1\\n            prevlen = 0 if ((a & 2) == 0) else currlen\\n            currlen = 0\\n        maxlen = max(prevlen + currlen, maxlen)\\n        a >>= 1\\n    return maxlen + 1\\n\\ndef sizeof():\\n    sizeOfInteger = 8\\n    return sizeOfInteger\\n\\na = int(rl())\\nwr(f\'{a} -> {bin(a)[2:]}\\\\n\')\\nwr(f\'{flipBit(a)}\')\\n","orden":4,"suborden":13,"fecha_creacion":"2020-12-04 23:04:36","fecha_modificacion":"2020-12-06 20:11:21"},{"ID":124,"supergrupo":"BitWise","tema":"M\xe1ximo XOR Subarray","texto":"Dado un array de enteros, encontrar el valor m\xe1ximo del Subarray XOR en el array dado. Una soluci\xf3n simple es usar dos ciclos para encontrar el XOR de todos los subarrays y retornar el m\xe1ximo.","complejidad_tiempo":"Mejor caso :    O(n2)  Peor caso : O(n2)  Promedio: O(n2) ","java":"// Programa en JAVA para buscar el maximo subarreglo XOR  \\n\\npublic class MaxSubarrayXOR {\\n\\n    static int maxSubarrayXOR(int arr[], int n) {\\n        int ans = Integer.MIN_VALUE; // Inicializar resultado \\n        // Escogiendo puntos de inicio para los subarreglos\\n        for (int i = 0; i < n; i++) {\\n            // para guardar XOR del actual subarreglo\\n            int curr_xor = 0;\\n            // Escojiendo puntos finales de subarreglos empezando por i\\n            for (int j = i; j < n; j++) {\\n                curr_xor = curr_xor ^ arr[j];\\n                ans = Math.max(ans, curr_xor);\\n            }\\n        }\\n        return ans;\\n    }\\n\\n    public static void main(String args[]) {\\n        int arr[] = {8, 1, 2, 12};\\n        int n = arr.length;\\n        System.out.println(\\"Maximo subarray XOR es \\"\\n                + maxSubarrayXOR(arr, n));\\n    }\\n}\\n","cpp":"#include<bits/stdc++.h>\\n#include<cstdlib>\\n//---------------//\\nusing namespace std;\\nint maxSubArrayXOR(int arr[],int n){\\n    int ans=INT_MIN;\\n    for(int i=0;i<n;i++){\\n        int curr_xor=0;\\n        for(int j=i;j<n;j++){\\n            curr_xor = curr_xor ^ arr[j];\\n            ans = std::max(ans, curr_xor);\\n        }\\n    }\\n    return ans;\\n}\\nint main(){\\n    int arr[] = {8, 1, 2, 12};\\n    int n = sizeof (arr)/sizeof (arr[0]);\\n    cout<<\\"Maximo subarray XOR es \\"<<maxSubArrayXOR(arr,n)<<endl;\\n} \\n","py":null,"orden":4,"suborden":14,"fecha_creacion":"2020-12-04 23:04:36","fecha_modificacion":"2020-12-06 20:11:21"},{"ID":125,"supergrupo":"BitWise","tema":"N n\xfamero m\xe1gico","texto":"Un n\xfamero m\xe1gico es definido como un n\xfamero el cual puede ser expresado como una potencia de 5 o la suma de potencias \xfanicas de 5, algunos n\xfameros m\xe1gicos son 5, 25, 30(5 + 25), 125, 130(125 + 5), \u2026.\\nSi revisamos cuidadosamente los n\xfameros m\xe1gicos, pueden ser representados como 001, 010, 011, 100, 101, 110, entre otros, donde 001 es 0*pow(5,3)+0*pow(5,2)+1*pow(5,1), entonces b\xe1sicamente necesitamos agregar potencias de 5 por cada bit dado en el entero dado n.\\n","complejidad_tiempo":"Mejor caso :    O(log(n))  Peor caso : O(log(n))  Promedio: O(log(n)) ","java":"// Programa en java para buscar el Nsimo\\n// n\xfamero magico, un n\xfamero magico esta definido como un n\xfamero el cual puede ser expresado como\\n// una potencia de 5 o suma de potencias unicas de 5\\n// Algunos primeros n\xfamero magicos son: 5, 25, 30(5 + 25), 125, 130(125 + 5), \u2026 en adelante\\n\\npublic class NMagicNumber {\\n\\n    static int nthMagicNo(int n) {\\n        int pow = 1, answer = 0;\\n        // Ir a traves de cada bit de n\\n        while (n != 0) {\\n            pow = pow * 5;\\n            // Si el untimo bit de n esta puesto\\n            if ((n & 1) == 1) {\\n                answer += pow;\\n            }\\n            //Proceder con el siguiente bit \\n            // 0 n= n/2 \\n            n >>= 1;\\n        }\\n        return answer;\\n    }\\n\\n    public static void main(String[] args) {\\n        int n = 5;\\n        System.out.println(\\"Enesimo n\xfamero\\"\\n                + \\" magico es \\" + nthMagicNo(n));\\n    }\\n} \\n","cpp":null,"py":null,"orden":4,"suborden":15,"fecha_creacion":"2020-12-04 23:04:37","fecha_modificacion":"2020-12-06 20:11:22"},{"ID":126,"supergrupo":"BitWise","tema":"Intercambio de pares e impares","texto":"Dado un entero sin signo, intercambia todos los bits pares con impares, por ejemplo si el n\xfamero dado es 23 (00010111), puede ser convertido en 43 (00101011). Cada posici\xf3n de bit par es intercambiada con el bit adyacente del lado de derecho, y cada posici\xf3n impar es cambiada con el adyacente del lado izquierdo. \\nSi realizamos una revisi\xf3n en el ejemplo, podemos observar que b\xe1sicamente necesitamos el corrimiento derecho (>>) de todos los bits pares por 1, entonces se convierten en bits impares, y corrimiento izquierdo (<<)  todos los bits impares por 1 entonces se convierten en pares, la siguiente soluci\xf3n est\xe1 basada en estas ideas, se asume que el n\xfamero de entrada est\xe1 almacenado usando 32 bits.\\nDejemos la entrada ser x.\\n1) Obtener todos los bits pares de x realizando BitWise, y or de x con 0xAAAAAAAA, el n\xfamero 0xAAAAAAAA es un entero de 32 bit con todos los bits pares ubicados en 1, y todos los impares en 0.\\n2) Obtener todos los bits impares usando BitWise, y or de x con 0x55555555, el n\xfamero 0x55555555 es un n\xfamero entero de 32 bits con todos los bits impares en 1 y los pares en 0.\\n3) Corrimiento derecho de todos los bits pares\\n4) Corrimiento izquierdo de todos los bits impares\\n5) Combina los nuevos pares e impares y retorna\\n","complejidad_tiempo":"Mejor caso :    O(1)  Peor caso : O(1)  Promedio: O(1) ","java":"// Programa java para invertir bits pares  \\n// e impares de un n\xfamero dado\\n\\npublic class OddEvenSwap {\\n\\n    static int swapBits(int x) {\\n        // Obtener todos los bits par de x \\n        int even_bits = x & 0xAAAAAAAA;\\n        //Obtener todos los bits impar de x \\n        int odd_bits = x & 0x55555555;\\n        //  Movimiento derecho de bits pares\\n        even_bits >>= 1;\\n        // Movimiento izquierdo de bits impares \\n        odd_bits <<= 1;\\n        // combinar pares e impares\\n        return (even_bits | odd_bits);\\n    }\\n\\n    public static void main(String[] args) {\\n        int x = 23; // 00010111 \\n        // La salida es 43 (00101011) \\n        System.out.println(swapBits(x));\\n    }\\n}\\n","cpp":"#include<bits/stdc++.h>\\n#include<cstdlib>\\n//---------------//\\nusing namespace std;\\nint swapBits(int x){\\n    int even_bits=x & 0xAAAAAAAA;\\n    int oddbits=x & 0x55555555;\\n    even_bits>>=1;\\n    oddbits<<=1;\\n    return (even_bits|oddbits);\\n}\\nstring toBinary(int n){\\n    string r;\\n    while(n!=0) {r=(n%2==0 ?\\"0\\":\\"1\\")+r; n/=2;}\\n    return r;\\n}\\nint main(){\\n   int x=7;\\n   cout<<x<<\\"->\\"<<toBinary(x)<<endl;\\n   int y=swapBits(x);\\n   cout<<swapBits(x)<<\\"->\\"<<toBinary(y)<<endl;\\n\\n} \\n\\n","py":null,"orden":4,"suborden":16,"fecha_creacion":"2020-12-04 23:04:37","fecha_modificacion":"2020-12-06 20:11:23"},{"ID":127,"supergrupo":"BitWise","tema":"Ocurrencia impar","texto":"Dado un array de enteros positivos, todos los n\xfameros  ocurren n\xfamero par de veces excepto un n\xfamero el cual ocurre impar veces, encuentre el n\xfamero en O(n) tiempo y espacio constante.\\nUna soluci\xf3n simple es correr dos ciclos anidados, el ciclo externo toma todos los elementos uno por uno y el ciclo interno cuenta el n\xfamero de las ocurrencias del elemento tomado en el ciclo externo, la complejidad de tiempo de esta soluci\xf3n es O(n^2).\\nLa mejor soluci\xf3n es hacer XOR bit a bit de todos los elementos. Un XOR de todos los elementos nos muestra cuales elementos son impares. Tenga en cuenta que XOR de dos elementos es 0 si ambos elementos son iguales y XOR de un n\xfamero x con 0 es x.\\n","complejidad_tiempo":"Mejor caso :    O(n)  Peor caso : O(n)  Promedio: O(n) ","java":"//Programa JAVA para buscar la ocurrencia de un elemento\\n// n\xfamero impar de veces\\n\\npublic class OddOccurence {\\n\\n    static int getOddOccurrence(int ar[], int ar_size) {\\n        int i;\\n        int res = 0;\\n        for (i = 0; i < ar_size; i++) {\\n            res = res ^ ar[i];\\n        }\\n        return res;\\n    }\\n\\n    public static void main(String[] args) {\\n        int ar[] = new int[]{2, 3, 5, 4, 5, 2, 4, 3, 5, 2, 4, 4, 2};\\n        int n = ar.length;\\n        System.out.println(getOddOccurrence(ar, n));\\n    }\\n} \\n","cpp":null,"py":null,"orden":4,"suborden":17,"fecha_creacion":"2020-12-04 23:04:37","fecha_modificacion":"2020-12-06 20:11:23"},{"ID":128,"supergrupo":"BitWise","tema":"Multiplicaci\xf3n Russian Peasant","texto":"Dados dos enteros, multiplicar sin usar el operador de multiplicaci\xf3n.\\nUna forma interesante es usar el algoritmo de la campesina rusa, la idea es duplicar el primer n\xfamero y dividir en dos el segundo n\xfamero repetidamente mientras el segundo n\xfamero no se convierta en 1, en el proceso cuando el segundo n\xfamero se vuelta impar, a\xf1adimos el primer n\xfamero al resultado, el cual esta inicializado en 0.\\nEl valor de a*b es el mismo que (a*2)*(b/2), si b es par, de otra forma el valor es el mismo de ((a*2)*(b/2) + a), en el ciclo while, seguimos multiplicando \u2018a\u2019 con dos y seguimos dividiendo \u2018b\u2019 por 2, si \u2018b\u2019 se convierte en impar en el ciclo, agregamos \u2018a\u2019 a \u2018res\u2019 cuando el valor de \u2018b\u2019 se convierta en 1, el valor de \u2018res\u2019 + \u2018a\u2019 nos da el resultado.\\nNote que cuando \u2018b\u2019 es una potencia de 2, el \u2018res\u2019 puede mantenerse en 0 y \u2018a\u2019 puede ser la multiplicaci\xf3n.\\n","complejidad_tiempo":"Mejor caso :    O(n)  Peor caso : O(n)  Promedio: O(n) ","java":"// Programa en java para multiplicar usando el algoritmo de  Russian Peasant  \\n\\npublic class RussianPeasantMultiply {\\n    // Funcion para multiplicar dos n\xfameros \\n    static int russianPeasant(int a, int b) {\\n        // Inicializar resultado\\n        int res = 0;\\n        //Mientras el segundo no se convierta en 1\\n        while (b > 0) {\\n            // Si el segundo n\xfamero es  impar, \\n            // a\xf1ade el primer n\xfamero al resultado \\n            if ((b & 1) != 0) {\\n                res = res + a;\\n            }\\n            // El doble del primer n\xfamero\\n            // y la mitad del segundo n\xfamero \\n            a = a << 1;\\n            b = b >> 1;\\n        }\\n        return res;\\n    }\\n\\n    public static void main(String[] args) {\\n        System.out.println(russianPeasant(18, 1));\\n        System.out.println(russianPeasant(20, 12));\\n    }\\n}\\n","cpp":"#include<bits/stdc++.h>\\n#include<cstdlib>\\n//---------------//\\nusing namespace std;\\n\\nint RP(int a, int b) {\\n    int res = 0;\\n    while (b > 0) {\\n        if ((b & 1) != 0) {\\n            res += a;\\n        }\\n        a <<= 1;\\n        b >>= 1;\\n    }\\n    return res;\\n}\\n\\nint main() {\\n    cout << (RP(2, 18)) << endl;\\n}\\n","py":"from sys import stdin, stdout\\nrl = stdin.readline\\nwr = stdout.write\\n\\ndef RP(a, b):\\n    res = 0\\n    while b > 0:\\n        if b & 1 != 0:\\n            res += a\\n        a <<= 1\\n        b >>= 1\\n    return res\\n\\na, b = int(rl()), int(rl())\\nwr(f\'{RP(a, b)}\')\\n","orden":4,"suborden":18,"fecha_creacion":"2020-12-04 23:04:37","fecha_modificacion":"2020-12-06 20:11:24"},{"ID":129,"supergrupo":"BitWise","tema":"Multiplicaci\xf3n de Karatsuba","texto":"Dados dos strings binarios (bigIntegers) que representan el valor de dos enteros, encuentre el producto de los dos strings, por ejemplo, si el primer string de bits es \u201c1100\u201d y el segundo string de bits es \u201c1010\u201d la salida debe ser 120.\\nPor simplicidad, dejaremos la longitud de ambos strings ser igual y ser n.\\n- x=5678 y=1234 \\n- a=56,b=78\\n- c=12,d=34\\nPaso 0 = m = n/2 + n%2\\nPaso 1 = a*c\\nPaso 2 = b*d\\nPaso 3 = (a + b)*(c + d)\\nPaso 4 = 3) - 2) - 1)\\nPaso 5 = 1)*pow(10, m*2) + 2) + 4)*pow(10, m)\\n","complejidad_tiempo":"Mejor caso :    O(1)  Peor caso : O(1)  Promedio: O(1) ","java":"//Programa JAVA que realiza multiplicaciones\\n//Por medio del algoritmo de Karatsuba\\n\\nimport java.math.BigInteger;\\nimport java.util.Scanner;\\n\\npublic class KaratsubaMultiply {\\n\\n    public static void main(String[] args) {\\n        BigInteger x, y;\\n        Scanner sc = new Scanner(System.in);\\n        x = sc.nextBigInteger();\\n        y = sc.nextBigInteger();\\n\\n        BigInteger result = karatsuba(x, y);\\n        long result2 = karatsuba(x.longValue(), y.longValue());\\n        System.out.println(result);\\n        System.out.println(result2);\\n    }\\n\\n    private static long karatsuba(long x, long y) {\\n        if (x < 10 && y < 10) {\\n            return x * y;\\n        }\\n        int n = Math.max(Long.valueOf(x).toString().length(), \\n                (Long.valueOf(y).toString().length()));\\n        int m = n / 2 + n % 2;\\n        long a = x / (long) Math.pow(10, m);\\n        long b = x % (long) Math.pow(10, m);\\n        long c = y / (long) Math.pow(10, m);\\n        long d = y % (long) Math.pow(10, m);\\n        long step1 = karatsuba(a, c);\\n        long step2 = karatsuba(b, d);\\n        long step3 = karatsuba(a + b, c + d);\\n        long step4 = step3 - step2 - step1;\\n        long step5 = step1 * (long) Math.pow(10, m * 2) + step2 + step4 * \\n                (long) Math.pow(10, m);\\n        return step5;\\n    }\\n\\n    private static BigInteger karatsuba(BigInteger x, BigInteger y) {\\n        if (x.compareTo(BigInteger.valueOf(10)) < 0 && \\n                y.compareTo(BigInteger.valueOf(10)) < 0) {\\n            return x.multiply(y);\\n        }\\n        int n = Math.max(x.toString().length(), y.toString().length());\\n        int m = n / 2 + n % 2;\\n        BigInteger[] a_b = x.divideAndRemainder(BigInteger.valueOf(10).pow(m));\\n        BigInteger a = a_b[0];\\n        BigInteger b = a_b[1];\\n        BigInteger[] c_d = y.divideAndRemainder(BigInteger.valueOf(10).pow(m));\\n        BigInteger c = c_d[0];\\n        BigInteger d = c_d[1];\\n        BigInteger step1 = karatsuba(a, c);\\n        BigInteger step2 = karatsuba(b, d);\\n        BigInteger step3 = karatsuba(a.add(b), c.add(d));\\n        BigInteger step4 = step3.subtract(step2).subtract(step1);\\n        BigInteger step5 = \\n                step1.multiply(BigInteger.valueOf(10).pow(m * 2)).add(step2)\\n                .add(step4.multiply(BigInteger.valueOf(10).pow(m)));\\n        return step5;\\n    }\\n}\\n","cpp":"#include<bits/stdc++.h>\\n#include<cstdlib>\\n//---------------//\\nusing namespace std;\\ntypedef long long int ll;\\nll makeEqualLength(string &str1, string &str2) {\\n    ll len1 = str1.size();\\n    ll len2 = str2.size();\\n    if (len1 < len2) {\\n        for (ll i = 0 ; i < len2 - len1 ; i++)\\n            str1 = \'0\' + str1;\\n        return len2;\\n    }\\n    else if (len1 > len2) {\\n        for (ll i = 0 ; i < len1 - len2 ; i++)\\n            str2 = \'0\' + str2;\\n    }\\n    return len1;\\n}\\nstring addBitStrings( string first, string second ) {\\n    string result;\\n    ll length = makeEqualLength(first, second);\\n    ll carry = 0;\\n    for (ll i = length-1 ; i >= 0 ; i--) {\\n        ll firstBit = first.at(i) - \'0\';\\n        ll secondBit = second.at(i) - \'0\';\\n        ll sum = (firstBit ^ secondBit ^ carry)+\'0\';\\n        result = (char)sum + result;\\n        carry = (firstBit&secondBit) | (secondBit&carry) | (firstBit&carry);\\n    }\\n    if (carry){\\n        result = \'1\' + result;\\n    }\\n    return result;\\n}\\nll multiplyiSingleBit(string a, string b) {\\n     return (a[0] - \'0\')*(b[0] - \'0\');\\n}\\nll karatsuba(string X, string Y) {\\n    ll n = makeEqualLength(X, Y);\\n    if (n == 0) return 0;\\n    if (n == 1) return multiplyiSingleBit(X, Y);\\n    ll fh = n/2;\\n    ll sh = (n-fh);\\n    string Xl = X.substr(0, fh);\\n    string Xr = X.substr(fh, sh);\\n    string Yl = Y.substr(0, fh);\\n    string Yr = Y.substr(fh, sh);\\n    ll P1 = karatsuba(Xl, Yl);\\n    ll P2 = karatsuba(Xr, Yr);\\n    ll P3 = karatsuba(addBitStrings(Xl, Xr), addBitStrings(Yl, Yr));\\n    return P1*(1<<(2*sh)) + (P3 - P1 - P2)*(1<<sh) + P2;\\n}\\nstring toBinary(ll n){\\n    string r;\\n    while(n!=0) {r=(n%2==0 ?\\"0\\":\\"1\\")+r; n/=2;}\\n    return r;\\n}\\nint main(){\\n    ll a;\\n    ll b;\\n    cin>>a;\\n    cin>>b;\\n    string x=toBinary(a);\\n    string y=toBinary(b);\\n    cout<<karatsuba(x,y)<<endl;\\n} \\n","py":null,"orden":4,"suborden":19,"fecha_creacion":"2020-12-04 23:04:38","fecha_modificacion":"2020-12-06 20:11:24"},{"ID":130,"supergrupo":"Grafos ","tema":"Matriz de adyacencia","texto":"La matriz de adyacencia es una matriz cuadrada que se utiliza como una forma de representar relaciones binarias, Se crea una matriz cero, cuyas columnas y filas representan los nodos del grafo. \\n1) Por cada arista que une a dos nodos, se suma 1 al valor que hay actualmente en la ubicaci\xf3n correspondiente de la matriz.\\n2) Si tal arista es un bucle y el grafo es no dirigido, entonces se suma 2 en vez de 1.\\n3) Finalmente, se obtiene una matriz que representa el n\xfamero de aristas (relaciones) entre cada par de nodos (elementos).\\nExiste una matriz de adyacencia \xfanica para cada grafo (sin considerar las permutaciones de filas o columnas), y viceversa.\\n- Para un grafo no dirigido la matriz de adyacencia es sim\xe9trica.\\n- El n\xfamero de caminos Ci,j(k), atravesando k aristas desde el nodo i al nodo j, viene dado por un elemento de la potencia k-\xe9sima de la matriz de adyacencia: -\\n- Ci,j(k)=[A^K]ij\\nExisten otras formas de representar relaciones binarias, como por ejemplo los pares ordenados o los grafos.\\n","complejidad_tiempo":"Mejor caso :    O(n)  Peor caso : O(n)  Promedio: O(n) ","java":"//Notacion java de una matriz de adyacencia\\n\\nimport java.util.Scanner;\\n\\npublic class AdyacencyMatrix {\\n    //matriz del grafo\\n    static int[][] G;\\n    static Scanner sc = new Scanner(System.in);\\n    public static void main(String[] args) {\\n        //Vertices y caminos\\n        int V = 4, E = 8;\\n        G = new int[V][V];\\n        for (int i = 0; i < V; i++) {\\n            //desde hasta peso\\n            int aux1, aux2, aux3;\\n            aux1 = sc.nextInt();\\n            aux2 = sc.nextInt();\\n            aux3 = sc.nextInt();\\n            // solo este si es dirigido\\n            G[aux1][aux2] = aux3;\\n            // inverso si es no dirigido\\n            G[aux2][aux1] = aux3;\\n        }\\n        print(V);\\n    }\\n    //Funci\xf3n que imprime la matriz de adyacencia\\n    static void print(int V) {\\n        for (int i = 0; i < V; i++) {\\n            for (int j = 0; j < V; j++) {\\n                System.out.print(G[i][j] + \\" \\");\\n            }\\n            System.out.println(\\"\\");\\n        }\\n    }\\n}\\n","cpp":"#include <bits/stdc++.h>\\n#define MAX_V 101\\nusing namespace std;\\nstatic int G[MAX_V][MAX_V];\\n\\nint main() {\\n    memset(G, 0, sizeof G);\\n    int V, E;\\n    cin >> V>>E;\\n    memset(G, NULL, MAX_V);\\n    for (int i = 0; i < E; ++i) {\\n        int desde, hasta, peso;\\n        cin >> desde>>hasta;\\n        cin>>peso;\\n        G[desde][hasta] = peso;\\n        G[hasta][desde] = peso;\\n    }\\n    for (int i = 0; i < V; ++i) {\\n        for (int j = 0; j < V; ++j) {\\n            cout << G[i][j] << \\"\\\\t\\";\\n        }\\n        cout << endl;\\n    }\\n    return 0;\\n}\\n","py":"from sys import stdin, stdout\\nrl = stdin.readline\\nwr = stdout.write\\n\\nV, E = rl().strip().split()\\nV, E = int(V), int(E)\\n\\nG = [[-1 for x in range(V)] for x in range(V)]\\nfor i in range(V):\\n    G[i][i] = 0\\n\\nfor i in range(E):\\n    desde, hasta, peso = rl().strip().split()\\n    desde, hasta, peso = int(desde), int(hasta), int(peso)\\n    G[desde][hasta] = peso\\n    G[hasta][desde] = peso\\n\\nfor i in range(V):\\n    for j in range(V):\\n        if G[i][j] == -1:\\n            wr(f\'inf\\\\t\')\\n        else:\\n            wr(f\'{G[i][j]}\\\\t\')\\n    wr(\'\\\\n\')\\n","orden":8,"suborden":0,"fecha_creacion":"2020-12-05 00:45:45","fecha_modificacion":"2020-12-06 20:30:43"},{"ID":131,"supergrupo":"Grafos ","tema":"Lista de adyacencia","texto":"En teor\xeda de grafos, una lista de adyacencia es una representaci\xf3n de todas las aristas o arcos de un grafo mediante una lista.\\nSi el grafo es no dirigido, cada entrada es un conjunto o multiconjunto de dos v\xe9rtices conteniendo los dos extremos de la arista correspondiente. Si el grafo es dirigido, cada entrada es una tupla de dos nodos, uno denotando el nodo fuente y el otro denotando el nodo destino del arco correspondiente.\\nT\xedpicamente, las listas de adyacentes no son ordenadas.\\n","complejidad_tiempo":"Mejor caso :    O(n)  Peor caso : O(n)  Promedio: O(n) ","java":"//Implementaci\xf3n java de una lista de adyacencia\\nimport java.util.ArrayList;\\nimport java.util.List;\\nimport java.util.Scanner;\\n\\n\\nimport java.util.ArrayList;\\nimport java.util.List;\\nimport java.util.Scanner;\\n\\npublic class Main {\\n    static Vertex[] G;\\n    static Scanner sc = new Scanner(System.in);\\n\\n    public static void main(String[] args) {\\n        int V = sc.nextInt(), E = sc.nextInt();\\n        G = new Vertex[V];\\n        for (int i = 0; i < V; i++) {\\n            G[i] = new Vertex();\\n            G[i].adj = new ArrayList<>();\\n        }\\n        for (int i = 0; i < E; i++) {\\n            int aux1, aux2, aux3;\\n            aux1 = sc.nextInt();\\n            aux2 = sc.nextInt();\\n            aux3 = sc.nextInt();\\n            //Dirigido\\n            G[aux1].adj.add(new Edge(aux2, aux3));\\n            //Descomentar para no dirigido\\n            //G[aux2].adj.add(new Edge(aux1, aux3));\\n        }\\n        for (int i = 0; i < G.length; i++) {\\n            System.out.print(i+\\"->\\" );\\n            for (Edge e : G[i].adj) {\\n                System.out.print(e.to + \\" \\" + e.w+\\"|\\");\\n            }\\n            System.out.println(\\"\\");\\n        }\\n    }\\n\\n    static class Vertex {\\n        List<Edge> adj;\\n        public Vertex() {\\n            adj = new ArrayList<>();\\n        }\\n    }\\n\\n    static class Edge {\\n        int to, w;\\n        public Edge(int to, int w) {\\n            this.to = to;\\n            this.w = w;\\n        }\\n    }\\n}\\n","cpp":"#include<bits/stdc++.h>\\n#include<cstdlib>\\n#define MAX_V 101\\n\\nusing namespace std;\\n\\nstruct Edge {\\n    int to = 0, w = 0;\\n\\n    Edge(int _to, int _w) {\\n        to = _to;\\n        w = _w;\\n    }\\n};\\n\\nstruct Vertex {\\n    list <Edge> adj;\\n};\\n\\nstatic Vertex G[MAX_V];\\n\\nint main(int argc, char *argv[]) {\\n    memset(G, 0, sizeof G);\\n    int V, E;\\n    scanf(\\"%i %i\\", &V, &E);\\n    Vertex G [V];\\n    for (int i = 0; i < V; i++) {\\n        G[i] = Vertex();\\n        G[i].adj;\\n    }\\n    for (int i = 0; i < E; i++) {\\n        int desde, hasta, peso;\\n        scanf(\\"%i %i %i\\", &desde, &hasta, &peso);\\n        G[desde].adj.push_back(Edge(hasta, peso));\\n        G[hasta].adj.push_back(Edge(desde, hasta));\\n    }\\n    int size = sizeof (G) / sizeof (G[0]);\\n    for (int i = 0; i < size; i++) {\\n        cout << i << \\"-> \\";\\n        for (Edge e : G[i].adj) {\\n            cout << e.to << \\" \\" << e.w << \\"|\\";\\n        }\\n        cout << \\"\\" << endl;\\n    }\\n    return 0;\\n}\\n","py":null,"orden":8,"suborden":1,"fecha_creacion":"2020-12-05 00:45:45","fecha_modificacion":"2020-12-06 20:30:44"},{"ID":132,"supergrupo":"Grafos ","tema":"DFS (Depth First Search)","texto":"Una B\xfasqueda en profundidad (en ingl\xe9s DFS o Depth First Search) es un algoritmo de b\xfasqueda no informada utilizado para recorrer todos los nodos de un grafo o \xe1rbol (teor\xeda de grafos) de manera ordenada, pero no uniforme. Su funcionamiento consiste en ir expandiendo todos y cada uno de los nodos que va localizando, de forma recurrente, en un camino concreto. Cuando ya no quedan m\xe1s nodos que visitar en dicho camino, regresa (Backtracking), de modo que repite el mismo proceso con cada uno de los hermanos del nodo ya procesado.\\nCompletitud: DFS es completo si y solo si usamos b\xfasqueda basada en grafos en espacios de estado finitos, pues todos los nodos ser\xe1n expandidos.\\nOptimalidad: DFS en ning\xfan caso asegura la optimalidad, pues puede encontrar una soluci\xf3n m\xe1s profunda que otra en una rama que todav\xeda no ha sido expandida.\\nComplejidad temporal: en el peor caso, O(b^m) siendo b el factor de ramificaci\xf3n (n\xfamero promedio de ramificaciones por nodo) y m la m\xe1xima profundidad del espacio de estados.\\nComplejidad espacial: O(b^d) siendo b el factor de ramificaci\xf3n y d la profundidad de la soluci\xf3n menos costosa, pues cada nodo generado permanece en memoria, almacen\xe1ndose la mayor cantidad de nodos en el nivel meta.\\n","complejidad_tiempo":"Mejor caso :    O(|v|+|e|)  Peor caso : O(|v|+|e|)  Promedio: O(|v|+|e|) ","java":"// Programa java que imprime DFS transverso en un grafo\\n\\nimport java.util.*;\\n\\npublic class DFS {\\n\\n    public static void main(String args[]) {\\n        Graph g = new Graph(4);\\n        g.addEdge(0, 1);\\n        g.addEdge(0, 2);\\n        g.addEdge(1, 2);\\n        g.addEdge(2, 0);\\n        g.addEdge(2, 3);\\n        g.addEdge(3, 3);\\n        System.out.println(\\"Siguiendo la primera busqueda en profundidad \\"\\n                + \\"(iniciando desde vertice  2)\\");\\n        g.DFS(2);\\n    }\\n\\n    static class Graph {\\n        private int V;  // n\xfamero de vertices \\n        // Array de listas de adyacencia\\n        private LinkedList<Integer> adj[];\\n        Graph(int v) {\\n            V = v;\\n            adj = new LinkedList[v];\\n            for (int i = 0; i < v; ++i) {\\n                adj[i] = new LinkedList();\\n            }\\n        }\\n        //Agregando caminos\\n        void addEdge(int v, int w) {\\n            adj[v].add(w);\\n        }\\n        void DFSUtil(int v, boolean visited[]) {\\n            // Marca el nodo actual como visitado y lo imprime\\n            visited[v] = true;\\n            System.out.print(v + \\" \\");\\n            // Recorre todos los vertices adyacentes a este vertice\\n            Iterator<Integer> i = adj[v].listIterator();\\n            while (i.hasNext()) {\\n                int n = i.next();\\n                if (!visited[n]) {\\n                    DFSUtil(n, visited);\\n                }\\n            }\\n        }\\n        void DFS(int v) {\\n            //Marca todos los vertices como no visitados (Falso)\\n            boolean visited[] = new boolean[V];\\n            DFSUtil(v, visited);\\n        }\\n\\n    }\\n}\\n","cpp":null,"py":"class Grafo:\\n    V = 0\\n    adj = [[], [], [], [], [], []]\\n    def addEdge(self, v, w):\\n        self.adj[v].append(w)\\n    def DFSUtil(self, v, visited=[]):\\n        visited[v] = True\\n        print(v, \\" \\")\\n        for i in range(len(self.adj[v])):\\n            n = self.adj[v][i]\\n            if not visited[n]:\\n                self.DFSUtil(n, visited)\\n    def DFS(self, v):\\n        visited = [False, False, False, False, False, False]\\n        self.DFSUtil(v, visited)\\n\\ng = Grafo()\\ng.V = 4\\ng.addEdge(0, 1)\\ng.addEdge(0, 2)\\ng.addEdge(1, 2)\\ng.addEdge(2, 0)\\ng.addEdge(2, 3)\\ng.addEdge(3, 3)\\ninicial = 0\\nprint(\\"Nodo inicial\\" + str(inicial))\\ng.DFS(inicial)\\n","orden":8,"suborden":2,"fecha_creacion":"2020-12-05 00:45:46","fecha_modificacion":"2020-12-06 20:30:44"},{"ID":133,"supergrupo":"Grafos ","tema":"BFS (Breath First Search)","texto":"B\xfasqueda en anchura (en ingl\xe9s BFS - Breadth First Search) es un algoritmo de b\xfasqueda no informada utilizado para recorrer o buscar elementos en un grafo (usado frecuentemente sobre \xe1rboles). Intuitivamente, se comienza en la ra\xedz (eligiendo alg\xfan nodo como elemento ra\xedz en el caso de un grafo) y se exploran todos los vecinos de este nodo. A continuaci\xf3n para cada uno de los vecinos se exploran sus respectivos vecinos adyacentes, y as\xed hasta que se recorra todo el \xe1rbol.\\nFormalmente, BFS es un algoritmo de b\xfasqueda sin informaci\xf3n, que expande y examina todos los nodos de un \xe1rbol sistem\xe1ticamente para buscar una soluci\xf3n. El algoritmo no usa ninguna estrategia heur\xedstica.\\n- Dado un v\xe9rtice fuente s, Breadth-first search sistem\xe1ticamente explora los v\xe9rtices de G para \u201cdescubrir\u201d todos los v\xe9rtices alcanzables desde s.\\n- Calcula la distancia (menor n\xfamero de v\xe9rtices) desde s a todos los v\xe9rtices alcanzables.\\n- Despu\xe9s produce un \xe1rbol BF con ra\xedz en s y que contiene a todos los v\xe9rtices alcanzables.\\n- El camino desde dt a cada v\xe9rtice en este recorrido contiene el m\xednimo n\xfamero de v\xe9rtices. Es el camino m\xe1s corto medido en n\xfamero de v\xe9rtices.\\n- Su nombre se debe a que expande uniformemente la frontera entre lo descubierto y lo no descubierto. Llega a los nodos de distancia k, s\xf3lo tras haber llegado a todos los nodos a distancia k-1.\\n","complejidad_tiempo":"Mejor caso :    O(|v|+|e|)  Peor caso : O(|v|+|e|)  Promedio: O(|v|+|e|) ","java":"// Programa java que imprime BFS (Busqueda en anchura) transverso\\n// desde un vertice (nodo) dado como inicio\\n// BFS(int s) atraviesa vertices alcanzables desde s \\n\\nimport java.util.*;\\n//Esta clase representa un grafo dirigido usando listas de adyacencia\\n\\npublic class BFS {\\n\\n    public static void main(String args[]) {\\n        Graph g = new Graph(4);\\n        g.addEdge(0, 1);\\n        g.addEdge(0, 2);\\n        g.addEdge(1, 2);\\n        g.addEdge(2, 0);\\n        g.addEdge(2, 3);\\n        g.addEdge(3, 3);\\n        System.out.println(\\"Siguiendo su primera busqueda en anchura transverso\\"\\n                + \\"(iniciando desde el vertice 2)\\");\\n        //Vertice de inicio\\n        g.BFS(2);\\n    }\\n\\n    static class Graph {\\n        private final int V;   // n\xfamero de vertices\\n        private LinkedList<Integer> adj[]; //lista de ayacencia\\n        // Constructor\\n        Graph(int v) {\\n            V = v;\\n            adj = new LinkedList[v];\\n            for (int i = 0; i < v; ++i) {\\n                adj[i] = new LinkedList();\\n            }\\n        }\\n        // funcion que agrega un camino al grafo\\n        void addEdge(int v, int w) {\\n            adj[v].add(w);\\n        }\\n        void BFS(int s) {\\n            //Marka todos los verticoes como no visitados (Falso)\\n            boolean visited[] = new boolean[V];\\n            //Crea una cola para la BFS\\n            // Create a queue for BFS \\n            LinkedList<Integer> queue = new LinkedList<>();\\n            //Marca el nodo actual como vistiado y lo encola\\n            visited[s] = true;\\n            queue.add(s);\\n            while (!queue.isEmpty()) {\\n                //Desencola un vertice de la cola y lo imprime\\n                s = queue.poll();\\n                System.out.print(s + \\" \\");\\n                /* Obtiene todos los vertices adyacentes del \\n                vertice desencolado, si un adyacente no ha \\n                sido visitado, lo marca lo visita y lo encola*/\\n                Iterator<Integer> i = adj[s].listIterator();\\n                while (i.hasNext()) {\\n                    int n = i.next();\\n                    if (!visited[n]) {\\n                        visited[n] = true;\\n                        queue.add(n);\\n                    }\\n                }\\n            }\\n        }\\n    }\\n}\\n","cpp":"#include <bits/stdc++.h>\\n#define MAX_V 101\\nusing namespace std;\\nvector<int> adj[MAX_V];\\nvector<int>que;\\n\\nstruct Graph {\\n    int V;\\n\\n    void addEdge(int v, int w) {\\n        adj[v].push_back(w);\\n    }\\n\\n    void BFS(int s) {\\n        bool visited[V];\\n        visited[s] = true;\\n        que.push_back(s);\\n        while (!que.empty()) {\\n            s = que.front();\\n            que.erase(que.begin());\\n            cout << s << \\" \\";\\n            for (int i = 0; i < adj[s].size(); ++i) {\\n                int n = adj[s][i];\\n                if (!visited[n]) {\\n                    visited[n] = true;\\n                    que.push_back(n);\\n                }\\n            }\\n        }\\n    }\\n};\\n\\nint main() {\\n    Graph gra;\\n    gra.V = 4;\\n    gra.addEdge(0, 1);\\n    gra.addEdge(0, 2);\\n    gra.addEdge(1, 2);\\n    gra.addEdge(2, 0);\\n    gra.addEdge(2, 3);\\n    gra.addEdge(3, 3);\\n    int initial = 0;\\n    gra.BFS(initial);\\n    return 0;\\n}\\n","py":"def add_edge(v, w):\\n    ady[v].append(w)\\ndef bfs(s):\\n    visited = [[] for i in range (V)]\\n    queue = []\\n    visited[s] = True;\\n    queue.append(s)\\n    while len(queue) > 0:\\n        s = queue[0]\\n        queue = queue[1:]\\n        print(str(s) + \\" \\")\\n        aux = ady[s]\\n        for j in range (len(aux)):\\n            n = aux[j]\\n            if(visited[n] != True):\\n                visited[n] = True\\n                queue.append(n)\\nV = 4\\nady = [[] for i in range (V)]\\nadd_edge(0, 1)\\nadd_edge(0, 2)\\nadd_edge(1, 2)\\nadd_edge(2, 0)\\nadd_edge(2, 3)\\nadd_edge(3, 3)\\nprint(ady)\\nbfs(0)\\n\\n","orden":8,"suborden":3,"fecha_creacion":"2020-12-05 00:45:46","fecha_modificacion":"2020-12-06 20:30:45"},{"ID":134,"supergrupo":"Grafos ","tema":"BFS todos los caminos","texto":"Utilizando el algoritmo de b\xfasqueda en anchura, y modific\xe1ndolo se puede realizar la b\xfasqueda de todos los caminos existentes desde un origen hasta un destino, permitiendo tambi\xe9n que se impriman los recorridos de estos caminos.","complejidad_tiempo":"Mejor caso :    O(|v|+|e|)  Peor caso : O(|v|+|e|)  Promedio: O(|v|+|e|) ","java":"//Programa java que imprime todos los caminos\\n// desde un inicio hasta un destino usando BFS\\n\\nimport java.util.ArrayList;\\nimport java.util.List;\\n//Un grafo dirigido usando lista de adyacencia\\n\\npublic class BFSAllPaths {\\n    // N\xfamero de vertices\\n    static int v;\\n    // lista de adyacencia\\n    static ArrayList<Integer>[] adjList;\\n    static void initGraph(int vertices) {\\n        //Inicializa n\xfamero de vertices\\n        v = vertices;\\n        // inicializa lista de adyacencia\\n        initAdjList();\\n    }\\n\\n    static void initAdjList() {\\n        adjList = new ArrayList[v];\\n        for (int i = 0; i < v; i++) {\\n            adjList[i] = new ArrayList<>();\\n        }\\n    }\\n    //Agrega camino de u a v\\n    static void addEdge(int u, int v) {\\n        // Agrega v a la lista de u\\n        adjList[u].add(v);\\n    }\\n    //Imrpime todos los caminos de \\n    // \'s\' a \'d\' \\n    static void printAllPaths(int s, int d) {\\n        boolean[] isVisited = new boolean[v];\\n        ArrayList<Integer> pathList = new ArrayList<>();\\n        //Agrega origen al path[]\\n        pathList.add(s);\\n        printAllPathsUtil(s, d, isVisited, pathList);\\n    }\\n    /*Funci\xf3n recursiva que imprime \\n    Todos los caminos de u a d.\\n    isVisited[] mantiene rastro de\\n    los vertices en el camino actual\\n    localPathList<> almacena vertices actuales\\n    en el camino actual*/\\n    static void printAllPathsUtil(Integer u, Integer d,\\n            boolean[] isVisited,\\n            List<Integer> localPathList) {\\n        // Marca el nodo actual\\n        isVisited[u] = true;\\n        if (u.equals(d)) {\\n            System.out.println(localPathList);\\n            // Si coincidencia encontrada entonces\\n            // no se necesita atravesar m\xe1s profundo\\n            isVisited[u] = false;\\n            return;\\n        }\\n        // Recorre todos los vertices \\n        //adyacentes al actual vertice \\n        for (Integer i : adjList[u]) {\\n            if (!isVisited[i]) {\\n                // Almacena el nodo actual\\n                // en path[]\\n                localPathList.add(i);\\n                printAllPathsUtil(i, d, isVisited, localPathList);\\n                localPathList.remove(i);\\n            }\\n        }\\n        // Marca el nodo actual\\n        isVisited[u] = false;\\n    }\\n\\n    public static void main(String[] args) {\\n        //Crea el grafo\\n        initGraph(4);\\n        //camino desde hasta\\n        addEdge(0, 1);\\n        addEdge(0, 2);\\n        addEdge(0, 3);\\n        addEdge(2, 0);\\n        addEdge(2, 1);\\n        addEdge(1, 3);\\n        // inicio arbitrario\\n        int s = 0;\\n        // destino arbitrario\\n        int d = 3;\\n        System.out.println(\\"Los siguientes son todos los diferentes\\"\\n                + \\"caminos de \\" + s + \\" a \\" + d);\\n        printAllPaths(s, d);\\n    }\\n}\\n","cpp":"#include <bits/stdc++.h>\\nusing namespace std;\\n\\n// funci\xf3n de utilidad para impresion\\n// encontrando todos los caminos\\nvoid printpath(vector<int>& path) {\\n    int size = path.size();\\n    for (int i = 0; i < size; i++)\\n        cout << path[i] << \\" \\";\\n    cout << endl;\\n}\\n// Funcion para revisar si el vertice actual\\n// ya se encuentra presente en el camino\\nint isNotVisited(int x, vector<int>& path) {\\n    int size = path.size();\\n    for (int i = 0; i < size; i++)\\n        if (path[i] == x)\\n            return 0;\\n    return 1;\\n}\\n// Funcion de utilidad para encontrar los caminos dentro de un grafo\\n// desde el inicio hasta el fin dado\\nvoid findpaths(vector<vector<int>> &g, int inicio, int destino, int v) {\\n    // Crear una cola que almacena los caminos\\n    queue<vector<int>> q;\\n    // vector de caminos que almacena el camino actual\\n    vector<int> path;\\n    path.push_back(inicio);\\n    q.push(path);\\n    while (!q.empty()) {\\n        path = q.front();\\n        q.pop();\\n        int last = path[path.size() - 1];\\n        // Si el ultimo vertice es el destino deseado\\n        // entonces se imprime el camino\\n        if (last == destino)\\n            printpath(path);\\n        // Atravesar a todos los nodos conectados al v\xc3\xa9rtice actual\\n        // y empujar una nueva ruta a la cola\\n        for (int i = 0; i < g[last].size(); i++) {\\n            if (isNotVisited(g[last][i], path)) {\\n                vector<int> newpath(path);\\n                newpath.push_back(g[last][i]);\\n                q.push(newpath);\\n            }\\n        }\\n    }\\n}\\n\\nint main() {\\n    vector<vector<int>> g;\\n    // Numero de vertices\\n    int v = 4;\\n    g.resize(4);\\n    // Contruccion del grafo\\n    g[0].push_back(3);\\n    g[0].push_back(1);\\n    g[0].push_back(2);\\n    g[1].push_back(3);\\n    g[2].push_back(0);\\n    g[2].push_back(1);\\n    //inicio y destino\\n    int inicio = 2, destino = 3;\\n    cout << \\"Los caminos desde \\" << inicio\\n            << \\" hasta \\" << destino << \\" son \\\\n\\";\\n    // Llamada a la funcion que permitir\xe1\xa1 encontrar los caminos\\n    // recibiendo como parametros la matriz de caminos, el inicio, el\\n    // y la cantidad de vertices\\n    findpaths(g, inicio, destino, v);\\n    return 0;\\n}\\n","py":"from collections import defaultdict\\n \\nclass Graph: \\n    def __init__(self, vertices): \\n        self.V = vertices  \\n        self.graph = defaultdict(list)   \\n    def addEdge(self, u, v): \\n        self.graph[u].append(v) \\n    def printAllPathsUtil(self, u, d, visited, path): \\n        visited[u] = True\\n        path.append(u)  \\n        if u == d: \\n            print path \\n        else: \\n            for i in self.graph[u]: \\n                if visited[i] == False: \\n                    self.printAllPathsUtil(i, d, visited, path) \\n        path.pop() \\n        visited[u] = False\\n\\n    def printAllPaths(self, s, d): \\n        visited = [False] * (self.V)  \\n        path = [] \\n        self.printAllPathsUtil(s, d, visited, path) \\ng = Graph(4) \\ng.addEdge(0, 1) \\ng.addEdge(0, 2) \\ng.addEdge(0, 3) \\ng.addEdge(2, 0) \\ng.addEdge(2, 1) \\ng.addEdge(1, 3) \\ns = 2 ; d = 3\\nprint (\\"Siguiendo los diferentes caminos desde %d a %d :\\" %(s, d)) \\ng.printAllPaths(s, d) \\n","orden":8,"suborden":4,"fecha_creacion":"2020-12-05 00:45:46","fecha_modificacion":"2020-12-06 20:30:46"},{"ID":135,"supergrupo":"Grafos ","tema":"Domino DFS","texto":"El efecto domin\xf3 o reacci\xf3n en cadena es el efecto acumulativo producido cuando un acontecimiento origina una cadena de otros acontecimientos similares.\\nSe produce cuando un peque\xf1o cambio origina un cambio similar a su lado, que a su vez causa otro similar, y as\xed sucesivamente en una secuencia lineal. Recibe este nombre, por analog\xeda con la ca\xedda de una hilera de fichas de domin\xf3 colocadas en posici\xf3n vertical. El efecto domin\xf3 tambi\xe9n puede hacer referencia a una cadena de acontecimientos no materiales.\\nEl t\xe9rmino, en sus distintos usos, se ha hecho popular por su analog\xeda al efecto mec\xe1nico, una fila de fichas de domin\xf3 al caer una ficha detr\xe1s de otra, aunque t\xedpicamente se refiere a una secuencia enlazada de acontecimientos donde el tiempo entre acontecimientos sucesivos es relativamente peque\xf1o. \\n","complejidad_tiempo":"Mejor caso :    O(|v|+|e|)  Peor caso : O(|v|+|e|)  Promedio: O(|v|+|e|) ","java":"//Programa java que usando DFS busca cuantos dominos\\n// caen desde un origen\\n\\nimport java.util.ArrayList;\\nimport java.util.Arrays;\\nimport java.util.Scanner;\\n\\n/* EJEMPLO DE INGRESO\\n9 6 3\\n1 2\\n2 5\\n5 3\\n4 3\\n6 7\\n7 8\\n1\\n6\\n4*/\\npublic class DominoDFS {\\n    static final int MAX = 10001;\\n    static ArrayList<ArrayList<Integer>> ady\\n            = new ArrayList<ArrayList<Integer>>(MAX);\\n    static Scanner sc = new Scanner(System.in);\\n    //la cantidad total de dominos que caer\xe1n\\n    static int total;\\n    //arreglo de domino caido\\n    static boolean visitado[] = new boolean[MAX];\\n\\n    public static void main(String[] args) {\\n        //n\xfamero de dominos, cantidad de enlaces, consultas\\n        int V, M, Q, x, y, origen;\\n        V = sc.nextInt();\\n        M = sc.nextInt();\\n        Q = sc.nextInt();\\n        for (int i = 0; i < V; i++) {\\n            ady.add(new ArrayList<>());\\n        }\\n        while (M > 0) {\\n            //domino x hace caer a domino y\\n            x = sc.nextInt();\\n            y = sc.nextInt();\\n            ady.get(x).add(y);\\n            M--;\\n        }\\n        while (Q > 0) {\\n            //domino origen\\n            origen = sc.nextInt();\\n            total = 0;\\n            Arrays.fill(visitado, false);\\n            dfs(origen);\\n            System.out.printf(\\"%d\\\\n\\", total);\\n            Q--;\\n        }\\n\\n    }\\n\\n    static void dfs(int u) { //domino origen\\n        //aumento en mi respuesta la caida de un domino\\n        total++;\\n        //domino \\"u\\" cayo\\n        visitado[u] = true;\\n        //verifico los dem\xe1s posibles \\n        //domino que caeran si impulso \\"u\\"\\n        for (int v = 0; v < ady.get(u).size(); ++v) {\\n            //si el domino adyacente no \\n            //cay\xf3 entonces es elsiguiente a evaluar\\n            if (!visitado[ady.get(u).get(v)]) {\\n                //recursivamente veo que dominos \\n                //caeran a partir del adyacente de \\"u\\"\\n                dfs(ady.get(u).get(v));\\n            }\\n        }\\n    }\\n}\\n","cpp":"#include<bits/stdc++.h>\\n#define MAX 10001\\nusing namespace std;\\nvector <vector<int> >ady(MAX);\\nint total = 0;\\nbool visited[MAX];\\n\\nvoid DFS(int u) {\\n    total++;\\n    visited[u] = true;\\n    for (int v = 0; v < ady[u].size(); v++) {\\n        if (!visited[ady[u][v]]) {\\n            DFS(ady[u][v]);\\n        }\\n    }\\n}\\n\\nint main() {\\n    int dominos, caminos, B\xfasquedas, desde, hasta, origen;\\n    cin>>dominos;\\n    cin>>caminos;\\n    cin>>B\xfasquedas;\\n    while (caminos > 0) {\\n        cin >> desde>>hasta;\\n        ady[desde].push_back(hasta);\\n        caminos--;\\n    }\\n    while (B\xfasquedas) {\\n        cin>>origen;\\n        total = 0;\\n        memset(visited, 0, sizeof visited);\\n        DFS(origen);\\n        cout << \\"Dominos tumbados : \\" << total << endl;\\n        B\xfasquedas--;\\n    }\\n    return 0;\\n}\\n","py":null,"orden":8,"suborden":5,"fecha_creacion":"2020-12-05 00:45:47","fecha_modificacion":"2020-12-06 20:30:46"},{"ID":136,"supergrupo":"Grafos ","tema":"Laberintos BFS","texto":"Un laberinto es un pasatiempo gr\xe1fico consistente en trazar una l\xednea desde un punto de origen situado en el exterior de un laberinto a uno de destino situado generalmente en el centro o bien en el lado opuesto. La dificultad consiste en encontrar un camino directo hasta el lugar deseado. El laberinto, por su propia configuraci\xf3n, contiene diferentes v\xedas sin salida (de mayor o menor longitud) y solo un recorrido correcto.","complejidad_tiempo":"Mejor caso :    O(|v|+|e|)  Peor caso : O(|v|+|e|)  Promedio: O(|v|+|e|) ","java":"// Programa java que realiza laberintos con BFS\\n\\nimport java.util.Arrays;\\nimport java.util.LinkedList;\\nimport java.util.Queue;\\nimport java.util.Scanner;\\n\\npublic class ExitTheMazeBFS {\\n\\n    /* Ejemplo de ingreso\\n8 8\\n.......I\\n.#######\\n.#......\\n.#.S...S\\n.###.#.#\\n.#...#.#\\n.#.###.#\\n........\\n     */\\n    //m\xe1ximo n\xfamero de filas y columnas del laberinto\\n    static final int MAX = 100;\\n    static Scanner sc = new Scanner(System.in);\\n    //laberinto\\n    static char ady[][] = new char[MAX][MAX];\\n    //arreglo de estados visitados\\n    static boolean visitado[][] = new boolean[MAX][MAX];\\n    //incremento en coordenada x\\n    static int dx[] = {0, 0, 1, -1};\\n    //incremento en coordanada y\\n    static int dy[] = {1, -1, 0, 0};\\n    //altura y ancho del laberinto\\n    static int h, w;\\n    //Arreglo para mostrar la ruta que se siguio\\n    static Estado prev[][] = new Estado[MAX][MAX];\\n\\n    static class Estado {\\n        int x; // Fila del estado\\n        int y; // Columna del estado\\n        int d; // Distancia del estado\\n        // Constructor\\n        Estado(int x1, int y1, int d1) {\\n            this.x = x1;\\n            this.y = y1;\\n            this.d = d1;\\n        }\\n\\n        Estado() {\\n        }\\n    }\\n\\n    public static void main(String[] args) {\\n        int x = 0, y = 0;\\n        System.out.println(\\"Ingrese altura del laberinto: \\");\\n        h = sc.nextInt();\\n        System.out.println(\\"Ingrese ancho del laberinto: \\");\\n        w = sc.nextInt();\\n        sc.nextLine();\\n        System.out.printf(\\"\\\\nIngrese el laberinto, con un solo \\"\\n                + \\"valor inicial I, valor final sera S: \\\\n\\");\\n        for (int i = 0; i < h; ++i) {\\n            String aux = sc.nextLine();\\n            for (int j = 0; j < w; ++j) {\\n                ady[i][j] = aux.charAt(j);\\n                //obtengo coordenada de valor inicial\\n                if (ady[i][j] == \'I\') {\\n                    x = i;\\n                    y = j;\\n                }\\n            }\\n        }\\n        //MOSTRAMOS LABERINTO\\n        for (int i = 0; i < h; ++i) {\\n            for (int j = 0; j < w; ++j) {\\n                System.out.printf(\\"%c\\", ady[i][j]);\\n            }\\n            System.out.printf(\\"\\\\n\\");\\n        }\\n        int min = BFS(x, y, h, w);\\n        if (min != -1) {\\n            System.out.printf(\\"Menor n\xfamero de pasos: %d\\\\n\\", min);\\n        } else {\\n            System.out.println(\\"No se pudo llegar al destino\\");\\n        }\\n\\n    }\\n    //Funcion para imprimir la ruta encontrada\\n    //Ingresan las coordenadas del nodo final\\n    static void print(int x, int y) {\\n        //El arreglo prev posee las coordenadas del nodo \\n        //anterior, por ello empezamos desde el final\\n        //El proceso termina al momento de preguntar \\n        //por el anterior del nodo inicial, como pusimos -1\\n        //Preguntamos hasta que nuestro anterior sea diferente de -1\\n        for (int i = x, j = y; prev[i][j].d != -1; i\\n                = prev[x][y].x, j = prev[x][y].y) {\\n            ady[i][j] = \'*\';\\n            x = i;\\n            y = j;\\n        }\\n\\n        System.out.printf(\\"Camino con menor n\xfamero de pasos\\\\n\\");\\n        for (int i = 0; i < h; ++i) {\\n            for (int j = 0; j < w; ++j) {\\n                System.out.printf(\\"%c\\", ady[i][j]);\\n            }\\n            System.out.printf(\\"\\\\n\\");\\n        }\\n    }\\n    //coordenadas de inicial \\"I\\" y dimensiones de laberinto\\n    static int BFS(int x, int y, int h, int w) {\\n        //Estado inicial, distancia = 0\\n        Estado inicial = new Estado(x, y, 0);\\n        //Cola de todos los posibles Estados por\\n        //los que se pase para llegar al destino\\n        Queue<Estado> Q = new LinkedList<>();\\n        //Insertamos el estado inicial en la Cola.\\n        //marcamos como no visitado\\n        Q.offer(inicial);\\n        for (int i = 0; i < MAX; i++) {\\n            Arrays.fill(visitado[i], false);\\n        }\\n        //el inicial no tiene una ruta anterior puesto que es  primero\\n        prev[x][y] = new Estado(-1, -1, -1);\\n        //Mientras cola no este vacia\\n        while (!Q.isEmpty()) {\\n            //Obtengo de la cola el estado actual, \\n            //en un comienzo ser\xe1 el inicial\\n            Estado actual = Q.peek();\\n            //Saco el elemento de la cola\\n            Q.poll();\\n            //Si se llego al destino (punto final)\\n            if (ady[actual.x][actual.y] == \'S\') {\\n                //imprimo la ruta del camino m\xe1s corto\\n                print(actual.x, actual.y);\\n                //Retornamos distancia recorrida hasta ese momento\\n                return actual.d;\\n            }\\n            //Marco como visitado dicho estado para no volver a recorrerlo\\n            visitado[actual.x][actual.y] = true;\\n            //Recorremos hasta 4 porque tenemos 4 posibles adyacentes\\n            for (int i = 0; i < 4; ++i) {\\n                //nx y ny tendran la coordenada adyacente\\n                int nx = dx[i] + actual.x;\\n                //ejemplo en i=0 y actual \\n                //(3,4) -> 3+dx[0]=3+0=3, \\n                //4+dy[0]=4+1=5, nueva coordenada (3,5)\\n                int ny = dy[i] + actual.y;\\n                //aqui comprobamos que la coordenada \\n                //adyacente no sobrepase las dimensiones del laberinto\\n                //adem\xe1s comprobamos que no sea \\n                //pared \\"#\\" y no este visitado\\n                if (nx >= 0 && nx < h && ny >= 0\\n                        && ny < w && ady[nx][ny] != \'#\' && !visitado[nx][ny]) {\\n                    //Creamos estado adyacente aumento en \\n                    //1 la distancia recorrida\\n                    Estado adyacente = new Estado(nx, ny, actual.d + 1);\\n                    //Agregamos adyacente a la cola\\n                    Q.offer(adyacente);\\n                    //El previo del nuevo nodo es el actual.\\n                    prev[nx][ny] = actual;\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n","cpp":"#include<bits/stdc++.h>\\n#define MAX 100\\nusing namespace std;\\n\\nstruct Estado {\\n    int x;\\n    int y;\\n    int d;\\n};\\nchar ady[MAX][MAX];\\nbool visited[MAX][MAX];\\nint dx[] = {0, 0, 1, -1};\\nint dy[] = {1, -1, 0, 0};\\nint h, w;\\nEstado prev[MAX][MAX];\\n\\nvoid print(int x, int y) {\\n    for (int i = x, j = y; prev[i][j].d != -1; i = prev[x][y].x, j = prev[x][y].y) {\\n        ady[i][j] = \'*\';\\n        x = i;\\n        y = j;\\n    }\\n    cout << \\"camino con menor pasos\\" << endl;\\n    for (int i = 0; i < h; i++) {\\n        for (int j = 0; j < w; j++) {\\n            cout << ady[i][j];\\n        }\\n        cout << endl;\\n    }\\n}\\n\\nint BFS(int x, int y, int h, int w) {\\n    Estado inicial;\\n    inicial.x = x;\\n    inicial.y = y;\\n    inicial.d = 0;\\n    queue<Estado> Q;\\n    Q.push(inicial);\\n    for (int i = 0; i < MAX; ++i) {\\n        memset(visited[i], false, sizeof visited[i]);\\n    }\\n    Estado nuevo;\\n    nuevo.x = -1;\\n    nuevo.y = -1;\\n    nuevo.d = -1;\\n    prev[x][y] = nuevo;\\n    while (!Q.empty()) {\\n        Estado actual = Q.front();\\n        Q.pop();\\n        if (ady[actual.x][actual.y] == \'S\') {\\n            print(actual.x, actual.y);\\n            return actual.d;\\n        }\\n        visited[actual.x][actual.y] = true;\\n        for (int i = 0; i < 4; i++) {\\n            int nx = dx[i] + actual.x;\\n            int ny = dy[i] + actual.y;\\n            if (nx >= 0 && nx < h && ny >= 0 && ny < w && ady[nx][ny] != \'#\' && !visited[nx][ny]) {\\n                Estado adyacente;\\n                adyacente.x = nx;\\n                adyacente.y = ny;\\n                adyacente.d = actual.d + 1;\\n                Q.push(adyacente);\\n                prev[nx][ny] = actual;\\n            }\\n        }\\n    }\\n    return -1;\\n}\\n\\nint main() {\\n    int x = 0;\\n    int y = 0;\\n    cout << \\"altura\\\\n\\";\\n    cin>>h;\\n    cout << \\"ancho\\\\n\\";\\n    cin>>w;\\n    cin.ignore();\\n    for (int i = 0; i < h; i++) {\\n        string aux;\\n        getline(cin, aux);\\n        for (int j = 0; j < w; j++) {\\n            ady[i][j] = aux[j];\\n            if (ady[i][j] == \'I\') {\\n                x = i;\\n                y = j;\\n            }\\n        }\\n    }\\n    for (int i = 0; i < h; i++) {\\n        for (int j = 0; j < w; j++) {\\n            cout << ady[i][j];\\n        }\\n        cout << endl;\\n    }\\n    int mini = BFS(x, y, h, w);\\n    if (mini != -1) {\\n        cout << \\"El menor numero de pasos es \\" << mini;\\n    } else {\\n        cout << \\"No se pudo llegar\\";\\n    }\\n    return 0;\\n}\\n","py":null,"orden":8,"suborden":6,"fecha_creacion":"2020-12-05 00:45:47","fecha_modificacion":"2020-12-06 20:30:47"},{"ID":137,"supergrupo":"Grafos ","tema":"15.8) Conteo de caminos DFS","texto":"Cuente el n\xfamero total de caminos o v\xedas que existen entre dos v\xe9rtices en un grafo dirigido, estos caminos no contienen un ciclo, la simple raz\xf3n de esto es que un ciclo contiene infinito n\xfamero de caminos y esto crea problema.\\nEl problema puede ser resuelto usando backtracking, esto es si tomamos un camino y empezamos a andar por \xe9l, si nos lleva al v\xe9rtice de destino entonces contamos el camino y nos devolvemos a tomar otro camino, si el camino no nos lleva al v\xe9rtice destino, descartamos este camino.\\n","complejidad_tiempo":"Mejor caso :    O(|v|+|e|)  Peor caso : O(|v|+|e|)  Promedio: O(|v|+|e|) ","java":"// Programa java que cuenta todos los caminos de un\\n// inicio a un destino. \\n\\nimport java.util.Arrays;\\nimport java.util.Iterator;\\nimport java.util.LinkedList;\\n\\npublic class CountAllPaths {\\n\\n    public static void main(String args[]) {\\n        Graph g = new Graph(4);\\n        g.addEdge(0, 1);\\n        g.addEdge(0, 2);\\n        g.addEdge(0, 3);\\n        g.addEdge(2, 0);\\n        g.addEdge(2, 1);\\n        g.addEdge(1, 3);\\n         //Origen - destino\\n        int s = 2, d = 3;\\n        System.out.println(g.countPaths(s, d));\\n    }\\n\\n    static class Graph {\\n        // N\xfamero de vertices\\n        private int V;\\n        // array de listas de adyacencia\\n        private LinkedList<Integer> adj[];\\n        Graph(int v) {\\n            V = v;\\n            adj = new LinkedList[v];\\n            for (int i = 0; i < v; ++i) {\\n                adj[i] = new LinkedList<>();\\n            }\\n        }\\n        //agrgar caminos en un grafo\\n        void addEdge(int v, int w) {\\n            //agrega w a las listas de v\\n            adj[v].add(w);\\n        }\\n        // Un metodo recursivo que cuenta\\n        // todos los caminos de u a d \\n        int countPathsUtil(int u, int d,\\n                boolean visited[],\\n                int pathCount) {\\n            //Marca el nodo actual como visitado\\n            //y lo imprime\\n            visited[u] = true;\\n            // Si el vertice actual es igual\\n            // al destino, incrementa el conteo\\n            if (u == d) {\\n                pathCount++;\\n            } // Recore todos los vertices  \\n            // adyacentes a este vertice\\n            else {\\n                Iterator<Integer> i = adj[u].listIterator();\\n                while (i.hasNext()) {\\n                    int n = i.next();\\n                    if (!visited[n]) {\\n                        pathCount = countPathsUtil(n, d,\\n                                visited,\\n                                pathCount);\\n                    }\\n                }\\n            }\\n            visited[u] = false;\\n            return pathCount;\\n        }\\n        // Retorna conteo de caminos desde s a d\\n        int countPaths(int s, int d) {\\n            //Marca todos los vertices como no visitados\\n            boolean visited[] = new boolean[V];\\n            Arrays.fill(visited, false);\\n            int pathCount = 0;\\n            pathCount = countPathsUtil(s, d,\\n                    visited,\\n                    pathCount);\\n            return pathCount;\\n        }\\n    }\\n}\\n","cpp":"#include<bits/stdc++.h>\\n#define MAX 101\\nusing namespace std;\\nvector<int> adj[MAX];\\n\\nstruct Graph {\\n    int V;\\n\\n    void addEdge(int v, int w) {\\n        adj[v].push_back(w);\\n    }\\n\\n    int countPathsUtil(int u, int d, bool visited[], int pathCount) {\\n        visited[u] = true;\\n        if (u == d) {\\n            pathCount++;\\n        } else {\\n            for (int i = 0; i < adj[u].size(); i++) {\\n                int n = adj[u][i];\\n                if (!visited[n]) {\\n                    pathCount = countPathsUtil(n, d, visited, pathCount);\\n                }\\n            }\\n        }\\n        visited[u] = false;\\n        return pathCount;\\n    }\\n\\n    int countPaths(int s, int d) {\\n        bool visited[V];\\n        memset(visited, false, sizeof visited);\\n        int pathcount = 0;\\n        pathcount = countPathsUtil(s, d, visited, pathcount);\\n        return pathcount;\\n    }\\n};\\n\\nint main() {\\n    Graph g;\\n    g.V = 4;\\n    g.addEdge(0, 1);\\n    g.addEdge(0, 2);\\n    g.addEdge(0, 3);\\n    g.addEdge(2, 0);\\n    g.addEdge(2, 1);\\n    g.addEdge(1, 3);\\n    int s = 2, d = 3;\\n    cout << g.countPaths(s, d);\\n    return 0;\\n}\\n","py":null,"orden":8,"suborden":7,"fecha_creacion":"2020-12-05 00:45:47","fecha_modificacion":"2020-12-06 20:30:48"},{"ID":138,"supergrupo":"Grafos ","tema":"Ciclo en un grafo dirigido","texto":"Dado un grafo dirigido, verificar si el grafo contiene un ciclo o no, la funci\xf3n debe retornar true si el grafo dado contiene al menos un ciclo, de lo contrario retorne false.\\nDFS puede ser usado para detectar un ciclo en un grafo, DFS para un grafo conectado produce un \xe1rbol, hay un ciclo en un grafo solo si hay un camino de regreso presente en el grafo. Un camino de regreso es un camino de un nodo a s\xed mismo, o uno de sus antecesores en el \xe1rbol producido por el DFS.\\nPara un grafo desconexo, tenemos el bosque DFS como salida, para detectar un ciclo, podemos verificar los arboles individuales en b\xfasqueda de caminos de regreso.\\nPara detectar un camino de regreso, podemos rastrear los v\xe9rtices actuales en una pila de recursi\xf3n de la funci\xf3n de DFS transverso, si llegamos a un v\xe9rtice que ya est\xe1 en la pila de recursi\xf3n entonces hay un ciclo en el \xe1rbol, el camino que conecta el v\xe9rtice actual a un v\xe9rtice en la pila recursi\xf3n es el camino de regreso, Usamos recStack[] para mantener rastreado los v\xe9rtices de la pila de recursi\xf3n.\\nLa complejidad de tiempo de este m\xe9todo es la misma complejidad de tiempo de un DFS transverso la cual es  O(V+E) siendo V la cantidad de v\xe9rtices y E la cantidad de caminos.\\n","complejidad_tiempo":"Mejor caso :    O(|v|+|e|)  Peor caso : O(|v|+|e|)  Promedio: O(|v|+|e|) ","java":"// Programa java que detecta ciclo en un grafo\\n\\nimport java.util.ArrayList;\\nimport java.util.LinkedList;\\nimport java.util.List;\\n\\npublic class CycleInADirectedGraph {\\n\\n    static class Graph {\\n        private final int V;\\n        private final List<List<Integer>> adj;\\n        public Graph(int V) {\\n            this.V = V;\\n            adj = new ArrayList<>(V);\\n            for (int i = 0; i < V; i++) {\\n                adj.add(new LinkedList<>());\\n            }\\n        }\\n        private boolean isCyclicUtil(int i, boolean[] visited,\\n                boolean[] recStack) {\\n            /* Marca el nodo actual como visitado \\n            y parte de la pila de recursi\xf3n*/\\n            if (recStack[i]) {\\n                return true;\\n            }\\n            if (visited[i]) {\\n                return false;\\n            }\\n            visited[i] = true;\\n            recStack[i] = true;\\n            List<Integer> children = adj.get(i);\\n//funcion lambda\\nif (children.stream().anyMatch((c) -> (isCyclicUtil(c, visited, recStack)))) {\\n                return true;\\n            }\\n//  for (Integer c: children) \\n//  if (isCyclicUtil(c, visited, recStack)) \\n//  return true;             recStack[i] = false;\\n            return false;\\n        }\\n        private void addEdge(int source, int dest) {\\n            adj.get(source).add(dest);\\n        }\\n        /* Retorna true si el grafo tiene un ciclo, si no falso*/\\n        private boolean isCyclic() {\\n            //Marca todos los vetices como no visitados\\n            // y no parte de la pila de recursi\xf3n\\n            boolean[] visited = new boolean[V];\\n            boolean[] recStack = new boolean[V];\\n            for (int i = 0; i < V; i++) {\\n                if (isCyclicUtil(i, visited, recStack)) {\\n                    return true;\\n                }\\n            }\\n            return false;\\n        }\\n\\n        public static void main(String[] args) {\\n            Graph graph = new Graph(4);\\n            graph.addEdge(0, 1);\\n            graph.addEdge(0, 2);\\n            graph.addEdge(1, 2);\\n            graph.addEdge(2, 0);\\n            graph.addEdge(2, 3);\\n            graph.addEdge(3, 3);\\n            if (graph.isCyclic()) {\\n                System.out.println(\\"El grafo contiene un ciclo\\");\\n            } else {\\n                System.out.println(\\"El grafo no contiene\\"\\n                        + \\"un ciclo\\");\\n            }\\n        }\\n    }\\n}\\n","cpp":"#include<bits/stdc++.h>\\n#define MAX 101\\nusing namespace std;\\nvector<vector<int> > adj(MAX);\\n\\nstruct Graph {\\n    int V;\\n\\n    void addEdge(int source, int dest) {\\n        adj[source].push_back(dest);\\n    }\\n\\n    bool isCycleUtil(int i, bool visited[], bool recStack[]) {\\n        if (recStack[i]) {\\n            return true;\\n        }\\n        if (visited[i]) {\\n            return false;\\n        }\\n        visited[i] = true;\\n        recStack[i] = true;\\n        vector<int> children = adj[i];\\n        for (int c = 0; c < children.size(); c++) {\\n            if (isCycleUtil(children[c], visited, recStack)) {\\n                return true;\\n            }\\n        }\\n        recStack[i] = false;\\n        return false;\\n    }\\n\\n    bool iscyclic() {\\n        bool visit[V];\\n        bool recStack[V];\\n        memset(visit, false, sizeof visit);\\n        memset(recStack, false, sizeof recStack);\\n        for (int i = 0; i < V; i++) {\\n            if (isCycleUtil(i, visit, recStack)) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n\\nint main() {\\n    Graph g;\\n    g.V = 4;\\n    g.addEdge(0, 1);\\n    g.addEdge(0, 2);\\n    g.addEdge(1, 2);\\n    g.addEdge(2, 0);\\n    g.addEdge(2, 3);\\n    g.addEdge(3, 3);\\n    if (g.iscyclic()) {\\n        cout << \\"el grafo SI tiene un ciclo\\";\\n    } else {\\n        cout << \\"el grafo NO tiene un ciclo\\";\\n    }\\n    return 0;\\n}\\n","py":null,"orden":8,"suborden":8,"fecha_creacion":"2020-12-05 00:45:48","fecha_modificacion":"2020-12-06 20:30:48"},{"ID":139,"supergrupo":"Grafos ","tema":"DFS Cerramiento transitivo","texto":"Dado un grafo dirigido, encontrar si un v\xe9rtice v es alcanzable desde otro v\xe9rtice u para todos los pares de v\xe9rtices (u,v) en el grafo dado, aqu\xed alcanzable significa que existe un camino desde el v\xe9rtice u a v, la matriz de habilidad de alcance es llamada cerramiento transitivo de un grafo.\\nLa soluci\xf3n est\xe1 basada en el algoritmo de Floyd Warshall, \\nLos pasos abstractos de este algoritmo son:\\n- Crear una matriz tc[V][V] que pueda tener finalmente el cerramiento transitivo de un grafo dado, inicializar todas sus entradas como 0.\\n- Llamar DFS por cada nodo del grado para marcar v\xe9rtices alcanzables en tc[][]. En llamadas recursivas de DFS no podemos llamar DFS para un v\xe9rtice adyacente si este ya fue marcado como alcanzable en tc[].\\nEl c\xf3digo usa listas de adyacencia para el grafo de entrada y construye una matriz tc[V][V] tal que tc[u][v] ser\xe1 true si v es alcanzable desde u.\\n","complejidad_tiempo":"Mejor caso :    O(|v|+|e|)  Peor caso : O(|v|+|e|)  Promedio: O(|v|+|e|) ","java":"//Programa java que imprime el cerramiento transitivo de un grafo\\n\\nimport java.util.ArrayList;\\nimport java.util.Arrays;\\n\\npublic class DFSTransitiveClosure {\\n\\n    public static void main(String[] args) {\\n        Graph g = new Graph(4);\\n        g.addEdge(0, 1);\\n        g.addEdge(0, 2);\\n        g.addEdge(1, 2);\\n        g.addEdge(2, 0);\\n        g.addEdge(2, 3);\\n        g.addEdge(3, 3);\\n        System.out.println(\\"Matriz de cerramiento transitivo es \\");\\n        g.transitiveClosure();\\n    }\\n\\n    static class Graph {\\n        // n\xfamero de vertices\\n        private int vertices;\\n        // lista de adyacencia \\n        private ArrayList<Integer>[] adjList;\\n        // para almacenar el cerramiento transitivo\\n        private int[][] tc;\\n        // Constructor \\n        public Graph(int vertices) {\\n            // inicializa el conteo de vertices\\n            this.vertices = vertices;\\n            this.tc = new int[this.vertices][this.vertices];\\n            // initializa lista de adyacencia\\n            initAdjList();\\n        }\\n        private void initAdjList() {\\n            adjList = new ArrayList[vertices];\\n            for (int i = 0; i < vertices; i++) {\\n                adjList[i] = new ArrayList<>();\\n            }\\n        }\\n        // Agregar caminos\\n        public void addEdge(int u, int v) {\\n            adjList[u].add(v);\\n        }\\n        // buscando cerramiento transitivo\\n        public void transitiveClosure() {\\n            for (int i = 0; i < vertices; i++) {\\n                dfsUtil(i, i);\\n            }\\n            for (int i = 0; i < vertices; i++) {\\n                System.out.println(Arrays.toString(tc[i]));\\n            }\\n        }\\n\\n        private void dfsUtil(int s, int v) {\\n            // Marca alcance desde s a v como true\\n            tc[s][v] = 1;\\n            // Encuentra todos los vertices alcanzables \\n            // atraves de v\\n            for (int adj : adjList[v]) {\\n                if (tc[s][adj] == 0) {\\n                    dfsUtil(s, adj);\\n                }\\n            }\\n        }\\n    }\\n}\\n","cpp":null,"py":null,"orden":8,"suborden":9,"fecha_creacion":"2020-12-05 00:45:48","fecha_modificacion":"2020-12-06 20:30:49"},{"ID":140,"supergrupo":"Grafos ","tema":"BFS para grafos desconexos","texto":"Por ejemplo asumamos que todos los v\xe9rtices son alcanzables desde un v\xe9rtice inicial, pero en el caso de un grafo desconexo o que cualquier v\xe9rtice es inalcanzable desde todos los v\xe9rtices, un BFS normal no nos da la salida deseada, por lo que se utiliza esta modificaci\xf3n del BFS.","complejidad_tiempo":"Mejor caso :    O(|v|+|e|)  Peor caso : O(|v|+|e|)  Promedio: O(|v|+|e|) ","java":"// Implementaci\xf3n de BFS modificado\\n\\nimport java.util.*;\\n\\npublic class DisconnectedGraphBFS {\\n    // Implementando grafo usando HashMap \\n    static HashMap<Integer, LinkedList<Integer>> graph = new HashMap<>();\\n    // Agregar caminos al grafo\\n    public static void addEdge(int a, int b) {\\n        if (graph.containsKey(a)) {\\n            LinkedList<Integer> l = graph.get(a);\\n            l.add(b);\\n            graph.put(a, l);\\n        } else {\\n            LinkedList<Integer> l = new LinkedList<>();\\n            l.add(b);\\n            graph.put(a, l);\\n        }\\n    }\\n\\n    public static void bfshelp(int s, ArrayList<Boolean> visited) {\\n        // Crea una cola para el BFS\\n        LinkedList<Integer> q = new LinkedList<>();\\n        //Marca el nodo actual como visitado y lo encola\\n        q.add(s);\\n        visited.set(s, true);\\n        while (!q.isEmpty()) {\\n            // Desencola un vertice de la cola y la imprime\\n            int f = q.poll();\\n            System.out.print(f + \\" \\");\\n            // Verifica cuando el nodo actual esta conectado\\n            // a otro nodo o no\\n            if (graph.containsKey(f)) {\\n                Iterator<Integer> i = graph.get(f).listIterator();\\n                // Obtiene todos los nodos adyacentes \\n                // del nodo desencolado f, si no ha sido visitado\\n                // lo marca y lo encola\\n                while (i.hasNext()) {\\n                    int n = i.next();\\n                    if (!visited.get(n)) {\\n                        visited.set(n, true);\\n                        q.add(n);\\n                    }\\n                }\\n            }\\n        }\\n    }\\n\\n    //Fuci\xf3n BFS que verifica cada nodo\\n    public static void bfs(int vertex) {\\n        ArrayList<Boolean> visited = new ArrayList<>();\\n        //Marcando cada nodo como no visitado\\n        for (int i = 0; i < vertex; i++) {\\n            visited.add(i, false);\\n        }\\n        for (int i = 0; i < vertex; i++) {\\n            //Verificando cuantos nodos no han sido visitados\\n            if (!visited.get(i)) {\\n                bfshelp(i, visited);\\n            }\\n        }\\n    }\\n\\n    public static void main(String[] args) {\\n        int v = 5;\\n        addEdge(0, 4);\\n        addEdge(1, 2);\\n        addEdge(1, 3);\\n        addEdge(1, 4);\\n        addEdge(2, 3);\\n        addEdge(3, 4);\\n        bfs(v);\\n    }\\n}\\n","cpp":null,"py":null,"orden":8,"suborden":10,"fecha_creacion":"2020-12-05 00:45:48","fecha_modificacion":"2020-12-06 20:30:49"},{"ID":141,"supergrupo":"Grafos ","tema":"Ciclo de Euler en un grafo dirigido","texto":"Un camino de Euler es un camino en un grafo que visita cada camino exactamente una vez, el circuito de Euler es un camino de Euler que empieza y termina en el mismo v\xe9rtice.\\nUn grafo es euleriano si tiene un ciclo de Euler.\\nUn grafo dirigido tiene un ciclo de Euler si las siguientes condiciones son verdad:\\n1) Todos los v\xe9rtices con grado no cero pertenecen a una sola componente fuertemente conectada.\\n2) En los grados, el grado de entrada es igual al grado de salida\\nPodemos detectar componentes fuertemente conectadas usando el DFS de Kosaraju.\\nPara comparar los grados de entrada y salida, necesitamos almacenar los grados de entrada y salida de cada v\xe9rtice, el grado de salida puede ser obtenido por el tama\xf1o de la lista de adyacencia, en grado de entrada puede ser almacenado creando un array de igual tama\xf1o al n\xfamero de v\xe9rtices.\\nLa complejidad de tiempo de esta implementaci\xf3n es de O(V+E), luego de correr el algoritmo de Kosaraju, atravesamos todos los v\xe9rtices y comparamos los grados de salida y entrada, esto toma O(V) tiempo.\\n","complejidad_tiempo":"Mejor caso :    O(|v|+|e|)  Peor caso : O(|v|+|e|)  Promedio: O(|v|+|e|) ","java":"// Programa java que verifica si un grafo es Euleriano\\n\\nimport java.util.*;\\nimport java.util.LinkedList;\\n\\npublic class EulerianCycleDirectedGraph {\\n\\n    public static void main(String[] args) throws java.lang.Exception {\\n        Graph g = new Graph(5);\\n        g.addEdge(1, 0);\\n        g.addEdge(0, 2);\\n        g.addEdge(2, 1);\\n        g.addEdge(0, 3);\\n        g.addEdge(3, 4);\\n        g.addEdge(4, 0);\\n        if (g.isEulerianCycle()) {\\n            System.out.println(\\"El grafo dado es euleriano \\");\\n        } else {\\n            System.out.println(\\"El grafo dado no es euleriano \\");\\n        }\\n    }\\n\\n    static class Graph {\\n        private int V;   // N\xfamero de vertices\\n        private LinkedList<Integer> adj[];//Lista de adyacencia\\n        private int in[];            //Manteniendo los grados\\n        //Constructor \\n        Graph(int v) {\\n            V = v;\\n            adj = new LinkedList[v];\\n            in = new int[V];\\n            for (int i = 0; i < v; ++i) {\\n                adj[i] = new LinkedList();\\n                in[i] = 0;\\n            }\\n        }\\n        //Agregar caminos \\n        void addEdge(int v, int w) {\\n            adj[v].add(w);\\n            in[w]++;\\n        }\\n\\n        void DFSUtil(int v, Boolean visited[]) {\\n            // Marca nodo actual como visitado\\n            visited[v] = true;\\n            int n;\\n            //  recorre todos los nodos adyacentes a este vertice \\n            Iterator<Integer> i = adj[v].iterator();\\n            while (i.hasNext()) {\\n                n = i.next();\\n                if (!visited[n]) {\\n                    DFSUtil(n, visited);\\n                }\\n            }\\n        }\\n        // Retornar el transpuesto de este grafo \\n        Graph getTranspose() {\\n            Graph g = new Graph(V);\\n            for (int v = 0; v < V; v++) {\\n                Iterator<Integer> i = adj[v].listIterator();\\n                while (i.hasNext()) {\\n                    g.adj[i.next()].add(v);\\n                    (g.in[v])++;\\n                }\\n            }\\n            return g;\\n        }\\n        // Verifica si el grafo esta fuertemente conectado\\n        Boolean isSC() {\\n            /*Paso 1: Marca todos los vertices como \\n            no visitados (Primer DFS)*/\\n            Boolean visited[] = new Boolean[V];\\n            for (int i = 0; i < V; i++) {\\n                visited[i] = false;\\n            }\\n            /* Paso 2: Hace DFS transverso \\n            iniciando del primer vertice*/\\n            DFSUtil(0, visited);\\n            //  Si DFS no visita todos los nodos, retorna falso \\n            for (int i = 0; i < V; i++) {\\n                if (visited[i] == false) {\\n                    return false;\\n                }\\n            }\\n            /* Paso 3: Crea un grafo reversado*/\\n            Graph gr = getTranspose();\\n            /* Paso 4: marca todos los vertices \\n            como no visitados (Segundo dfs)*/\\n            for (int i = 0; i < V; i++) {\\n                visited[i] = false;\\n            }\\n            /* Paso 5: hacer DFS para el grafo reverso \\n            iniciando desde el vertice primero\\n            debe ser el mismo que el primer DFS*/\\n            gr.DFSUtil(0, visited);\\n            // Si todos los vertices no son visitados en el segund\\n            // DFS retorna falso\\n            for (int i = 0; i < V; i++) {\\n                if (visited[i] == false) {\\n                    return false;\\n                }\\n            }\\n            return true;\\n        }\\n\\n        /* Esta funci\xf3n retorna true si encuentra un \\n        ciclo de euler, falso si no*/\\n        Boolean isEulerianCycle() {\\n            // verifica si todos los vertices con grado no cero\\n            // viendo si estan conectados\\n            if (isSC() == false) {\\n                return false;\\n            }\\n            // Verifica si en grado de entrada y \\n            // salida cada vertice es igual \\n            for (int i = 0; i < V; i++) {\\n                if (adj[i].size() != in[i]) {\\n                    return false;\\n                }\\n            }\\n            return true;\\n        }\\n    }\\n}\\n","cpp":"#include <bits/stdc++.h>\\n#define FAST ios_base::sync_with_stdio(false);cin.tie(NULL);\\n\\nusing namespace std;\\n\\nconst int MAX_V = 90;\\n\\nstruct Graph {\\n    int V;\\n    vector<int> adj[MAX_V];\\n    int in[MAX_V];\\n\\n    Graph(int v) {\\n        V = v;\\n        for (int i = 0; i < V; i++) {\\n            in[i] = 0;\\n        }\\n    }\\n\\n    void addEdge(int source, int destiny) {\\n        adj[source].push_back(destiny);\\n        in[destiny]++;\\n    }\\n\\n    void DFSUtil(int v, bool visited[]) {\\n        visited[v] = true;\\n        int n;\\n        for (int i = 0; i < adj[v].size(); ++i) {\\n            n = adj[v][i];\\n            if (!visited[n]) {\\n                DFSUtil(n, visited);\\n            }\\n        }\\n    }\\n\\n    Graph getTranspose() {\\n        Graph ge(V);\\n        for (int v = 0; v < V; v++) {\\n            for (int i : adj[v]) {\\n                ge.adj[i].push_back(v);\\n                ge.in[v]++;\\n            }\\n        }\\n        return ge;\\n    }\\n\\n    bool isSC() {\\n        bool visited[V];\\n        memset(visited, false, V);\\n        DFSUtil(0, visited);\\n        for (int i = 0; i < V; i++) {\\n            if (visited[i] == false) {\\n                return false;\\n            }\\n        }\\n        Graph gr = getTranspose();\\n        memset(visited, false, sizeof visited);\\n        gr.DFSUtil(0, visited);\\n        for (int i = 0; i < V; i++) {\\n            if (visited[i] == false) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n\\n    bool isEulerian() {\\n        if (isSC() == false) {\\n            return false;\\n        }\\n        for (int i = 0; i < V; i++) {\\n            if (adj[i].size() != in[i]) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n\\nint main() {\\n    FAST\\n            int vertices, caminos;\\n    cin >> vertices >> caminos;\\n    Graph g(vertices);\\n    for (int i = 0; i < caminos; i++) {\\n        int inicio, destino;\\n        cin >> inicio >> destino;\\n        g.addEdge(inicio, destino);\\n    }\\n    if (g.isEulerian()) {\\n        cout << \\"El grafo dado es Euleriano\\" << endl;\\n    } else {\\n        cout << \\"El grafo dado no es Euleriano\\" << endl;\\n    }\\n    return 0;\\n}\\n","py":null,"orden":8,"suborden":11,"fecha_creacion":"2020-12-05 00:45:49","fecha_modificacion":"2020-12-06 20:30:50"},{"ID":142,"supergrupo":"Grafos ","tema":"Camino de Euler en un grafo no dirigido ","texto":"\xbfEs possible dibujar un grafo dado sin levantar el l\xe1piz del papel y sin pasar por los caminos m\xe1s de una vez?\\nUn grafo es llamado euleriano si tiene un ciclo de Euler y es llamado semi-euleriano si tiene un camino de Euler, el problema es similar al camino Hamiltoniano, podemos verificar si un grafo es euleriano o no en tiempo polin\xf3mico, de O(V+E).\\nLas siguientes son propiedades interesantes de los grafos no dirigidos con un camino euleriano y ciclo, podemos usar esta propiedades para encontrar si un grafo es euleriano o no.\\nCiclo euleriano\\nUn grafo no dirigido tiene un ciclo de Euler si las siguientes dos condiciones son ciertas:\\n- Todos los v\xe9rtices con grado no cero estan conectados, no nos importa los v\xe9rtices con grado cero porque no pertenecen a el ciclo de Euler o el camino, solo estamos considerando los caminos.\\n- Todos los v\xe9rtices tienen grado par.\\nCamino euleriano\\nUn grafo no dirigido tiene un camino euleriano si las dos siguientes condiciones se cumplen:\\n- La misma primera condici\xf3n de un ciclo de Euler\\n- Si dos v\xe9rtices tienen grado impar y todos los dem\xe1s v\xe9rtices tienen grado par, note que solo un v\xe9rtice con grado impar no es posible en un grafo no dirigido, la suma de todos los grados es siempre par en un grafo no dirigido.\\nNote que un grafo sin caminos se considera euleriano porque no hay caminos que atravesar.\\nEn el camino euleriano, cada vez que visitamos un v\xe9rtice v, nosotros caminamos a trav\xe9s de dos caminos no visitados, con un punto de fin como v, por lo tanto todos los v\xe9rtices medios en el camino euleriano deben tener grado par, para el ciclo euleriano cualquier v\xe9rtice puede ser v\xe9rtice medio, sin embargo todos los v\xe9rtices deben tener grado par.\\n","complejidad_tiempo":"Mejor caso :    O(|v|+|e|)  Peor caso : O(|v|+|e|)  Promedio: O(|v|+|e|) ","java":"// Programa java que busca camino euleriano\\n// de un grafo\\n\\nimport java.util.*;\\nimport java.util.LinkedList;\\n\\npublic class EulerianPathUndirectedGraph {\\n\\n    public static void main(String args[]) {\\n        // Creamos varios ejemplos de grafos para probar\\n        Graph g1 = new Graph(5);\\n        g1.addEdge(1, 0);\\n        g1.addEdge(0, 2);\\n        g1.addEdge(2, 1);\\n        g1.addEdge(0, 3);\\n        g1.addEdge(3, 4);\\n        g1.test();\\n        Graph g2 = new Graph(5);\\n        g2.addEdge(1, 0);\\n        g2.addEdge(0, 2);\\n        g2.addEdge(2, 1);\\n        g2.addEdge(0, 3);\\n        g2.addEdge(3, 4);\\n        g2.addEdge(4, 0);\\n        g2.test();\\n        Graph g3 = new Graph(5);\\n        g3.addEdge(1, 0);\\n        g3.addEdge(0, 2);\\n        g3.addEdge(2, 1);\\n        g3.addEdge(0, 3);\\n        g3.addEdge(3, 4);\\n        g3.addEdge(1, 3);\\n        g3.test();\\n        /* Crearemos un grafo con tres vertices\\n        conectados en forma de ciclo*/\\n        Graph g4 = new Graph(3);\\n        g4.addEdge(0, 1);\\n        g4.addEdge(1, 2);\\n        g4.addEdge(2, 0);\\n        g4.test();\\n        /* Creamos un grafo con vertices con grado cero*/\\n        Graph g5 = new Graph(3);\\n        g5.test();\\n    }\\n\\n    static class Graph {\\n\\n        private int V;\\n        private LinkedList<Integer> adj[];\\n        // Constructor \\n        Graph(int v) {\\n            V = v;\\n            adj = new LinkedList[v];\\n            for (int i = 0; i < v; ++i) {\\n                adj[i] = new LinkedList();\\n            }\\n        }\\n        //Agregar caminos\\n        void addEdge(int v, int w) {\\n            adj[v].add(w);\\n            adj[w].add(v); //El grafo es no dirigido\\n        }\\n\\n        void DFSUtil(int v, boolean visited[]) {\\n            visited[v] = true;\\n            Iterator<Integer> i = adj[v].listIterator();\\n            while (i.hasNext()) {\\n                int n = i.next();\\n                if (!visited[n]) {\\n                    DFSUtil(n, visited);\\n                }\\n            }\\n        }\\n\\n        boolean isConnected() {\\n            boolean visited[] = new boolean[V];\\n            int i;\\n            for (i = 0; i < V; i++) {\\n                visited[i] = false;\\n            }\\n            for (i = 0; i < V; i++) {\\n                if (!adj[i].isEmpty()) {\\n                    break;\\n                }\\n            }\\n            //Si no hay caminos en el grafo, retorna true\\n            if (i == V) {\\n                return true;\\n            }\\n            DFSUtil(i, visited);\\n            for (i = 0; i < V; i++) {\\n                if (visited[i] == false && adj[i].size() > 0) {\\n                    return false;\\n                }\\n            }\\n            return true;\\n        }\\n\\n        int isEulerian() {\\n            if (isConnected() == false) {\\n                return 0;\\n            }\\n            // Cuenta vertices con grado impar \\n            int odd = 0;\\n            for (int i = 0; i < V; i++) {\\n                if (adj[i].size() % 2 != 0) {\\n                    odd++;\\n                }\\n            }\\n            // Si cuenta es m\xe1s de 2, el grafo no es euleriano\\n            if (odd > 2) {\\n                return 0;\\n            }\\n            //si odd es 2, es semieuleriano\\n            //Si odd es 0, es eulerian0 \\n            return (odd == 2) ? 1 : 2;\\n        }\\n        void test() {\\n            int res = isEulerian();\\n            switch (res) {\\n                case 0:\\n                    System.out.println(\\"Grafo no es euleriano\\");\\n                    break;\\n                case 1:\\n                    System.out.println(\\"Grafo tiene un camino de euler\\");\\n                    break;\\n                default:\\n                    System.out.println(\\"Grafo tiene ciclo de euler\\");\\n                    break;\\n            }\\n        }\\n    }\\n}\\n","cpp":"#include <bits/stdc++.h>\\n#define MAX 101\\nusing namespace std;\\nvector<vector<int> >adj(MAX);\\nint in[MAX];\\n\\nvoid clean() {\\n    adj.clear();\\n    adj.erase(adj.begin(), adj.begin() + adj.size());\\n    memset(in, 0, sizeof in);\\n}\\n\\nstruct Graph {\\n    int V;\\n\\n    void addEdge(int v, int w) {\\n        adj[v].push_back(w);\\n        adj[w].push_back(v);\\n    }\\n\\n    void DFSUtil(int v, bool visited[]) {\\n        visited[v] = true;\\n        int n;\\n        for (int i = 0; i < adj[v].size(); ++i) {\\n            n = adj[v][i];\\n            if (!visited[n]) {\\n                DFSUtil(n, visited);\\n            }\\n        }\\n    }\\n\\n    bool isConnected() {\\n        bool visited[V];\\n        int i;\\n        memset(visited, false, sizeof visited);\\n        for (i = 0; i < V; i++) {\\n            if (!adj[i].empty()) {\\n                break;\\n            }\\n        }\\n        if (i == V) {\\n            return true;\\n        }\\n        DFSUtil(i, visited);\\n        for (i = 0; i < V; i++) {\\n            if (visited[i] == false && adj[i].size() > 0) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n\\n    int isEulerian() {\\n        if (isConnected() == false) {\\n            return 0;\\n        }\\n        int odd = 0;\\n        for (int i = 0; i < V; i++) {\\n            if (adj[i].size() % 2 != 0) {\\n                odd++;\\n            }\\n        }\\n        if (odd > 2) {\\n            return 0;\\n        }\\n        return (odd == 2) ? 1 : 2;\\n    }\\n\\n    void test() {\\n        int res = isEulerian();\\n        switch (res) {\\n            case 0:\\n                cout << \\"Grafo no euleriano\\" << endl;\\n                break;\\n            case 1:\\n                cout << \\"Grafo tiene camino de euler\\" << endl;\\n                break;\\n            case 2:\\n                cout << \\"Grafo tiene ciclo de euler\\" << endl;\\n                break;\\n        }\\n    }\\n\\n    void init() {\\n        adj.clear();\\n        memset(in, 0, sizeof in);\\n    }\\n\\n};\\n\\nint main() {\\n    /*\\n    Graph g1;\\n    g1.init();\\n    g1.V=5;\\n    g1.addEdge(1, 0);\\n    g1.addEdge(0, 2);\\n    g1.addEdge(2, 1);\\n    g1.addEdge(0, 3);\\n    g1.addEdge(3, 4);\\n    g1.test();\\n    Graph g2;\\n    g2.init();\\n    g2.V=5;\\n    g2.addEdge(1, 0);\\n    g2.addEdge(0, 2);\\n    g2.addEdge(2, 1);\\n    g2.addEdge(0, 3);\\n    g2.addEdge(3, 4);\\n    g2.addEdge(4, 0);\\n    g2.test();\\n     */\\n    Graph g3;\\n    g3.init();\\n    g3.V = 5;\\n    g3.addEdge(1, 0);\\n    g3.addEdge(0, 2);\\n    g3.addEdge(2, 1);\\n    g3.addEdge(0, 3);\\n    g3.addEdge(3, 4);\\n    g3.addEdge(1, 3);\\n    g3.test();\\n    /*\\n    Graph g4;\\n    g4.init();\\n    g4.V=3;\\n    g4.addEdge(0, 1);\\n    g4.addEdge(1, 2);\\n    g4.addEdge(2, 0);\\n    g4.test();\\n    Graph g5;\\n    g5.init();\\n    g5.V=3;\\n    g5.test();\\n     */\\n\\n}\\n","py":null,"orden":8,"suborden":12,"fecha_creacion":"2020-12-05 00:45:49","fecha_modificacion":"2020-12-06 20:30:51"},{"ID":143,"supergrupo":"Grafos ","tema":"Ciclo Hamiltoniano","texto":"El camino Hamiltoniano de un grafo no dirigido es un camino que visita cada v\xe9rtice exactamente una vez, un ciclo Hamiltoniano es un camino Hamiltoniano que tiene un camino desde el \xfaltimo v\xe9rtice al primer v\xe9rtice del camino Hamiltoniano, debemos determinar si un grafo tiene ciclo Hamiltoniano o no, si lo contiene imprimir el camino.\\nNuestra entrada ser\xe1 un array graph[v][v] donde v es el n\xfamero de v\xe9rtices en el grafo y graph[][] es la matriz de adyacencia representando el grafo, un valor graph[i][j] es 1 si existe un camino directo de I a j, de lo contrario ser\xe1 0.\\nNuestra salida ser\xe1 un array path[v] que deber\xe1 contener el camino Hamiltoniano, path[i] puede representar el iesimo v\xe9rtice en el camino Hamiltoniano. El c\xf3digo debe tambi\xe9n retornar si no existe ciclo Hamiltoniano en el grafo.\\nSe crea un array de camino vac\xedo y se le agrega el v\xe9rtice 0 a \xe9l, se agregan los otros v\xe9rtices iniciando desde el v\xe9rtice 1, antes de a\xf1adir un v\xe9rtice, se verifica por cual es el adyacente del anterior a\xf1adido y si no se ha a\xf1adido ya, si encontramos tal v\xe9rtice, a\xf1adimos el v\xe9rtice como parte de la soluci\xf3n, si no lo encontramos retornamos false.\\nNote que el c\xf3digo siempre imprime el ciclo iniciando de 0, el punto de inicio no importa ya que el ciclo puede empezar de cualquier punto, si se quiere cambiar el punto de inicio, se deben hacer dos cambios al c\xf3digo de abajo.\\nCambie  \u201cpath[0] = 0;\u201d por \u201cpath[0] = s;\u201d donde s es el nuevo punto de inicio, tambi\xe9n cambie el ciclo \u201cfor (int v = 1; v < V; v++)\\" en hamCycleUtil() por \\"for (int v = 0; v < V; v++)\\".\\n","complejidad_tiempo":"Mejor caso :    O(|v|+|e|)  Peor caso : O(|v|+|e|)  Promedio: O(|v|+|e|) ","java":"/* Programa java que soluciona el ciclo de Hamilton\\nusando backtracking*/\\n\\npublic class HamiltonianCycle {\\n\\n    static final int V = 5;\\n    static int path[];\\n\\n    /* Una funci\xf3n de utilidad para comprobar si el v\xe9rtice v puede ser\\n       a\xf1adido en el \xedndice \'pos\'en el ciclo hamiltoniano\\n       construido hasta ahora (almacenado en \'path[]\')*/\\n    static boolean isSafe(int v, int graph[][], int path[], int pos) {\\n        /*Verifica si este vertice es adyacente del \\n        anterior vertice */\\n        if (graph[path[pos - 1]][v] == 0) {\\n            return false;\\n        }\\n        /* Verifica si el vertice ya esta incluido*/\\n        for (int i = 0; i < pos; i++) {\\n            if (path[i] == v) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n\\n    static boolean hamCycleUtil(int graph[][], int path[], int pos) {\\n        /* Caso base:Si todos los vertices estan incluidos en  \\n           el ciclo hamiltoniano*/\\n        if (pos == V) {\\n            // Y si hay un camino de el ultimo al primer vertice\\n            return graph[path[pos - 1]][path[0]] == 1;\\n        }\\n        /*Prueba diferentes v\xe9rtices como pr\xf3ximo candidato\\n        en el ciclo hamiltoniano. No intentamos con 0, \\n        ya que incluimos 0 como punto de partida en hamCycle ()*/\\n        for (int v = 1; v < V; v++) {\\n            /* Verifica si este vertice puede ser a\xf1adido al\\n            ciclo hamiltoniano*/\\n            if (isSafe(v, graph, path, pos)) {\\n                path[pos] = v;\\n                /* Recorre hasta construir el camino*/\\n                if (hamCycleUtil(graph, path, pos + 1) == true) {\\n                    return true;\\n                }\\n                path[pos] = -1;\\n            }\\n        }\\n        /* Si no hay vertice para a\xf1adir al ciclo\\n        retorna falso*/\\n        return false;\\n    }\\n\\n    /* Esta funci\xf3n resuelve el problema del ciclo hamiltoniano usando\\n       backtracking. Utiliza principalmente hamCycleUtil () para resolver el\\n       problema. Devuelve falso si no hay ciclo hamiltoniano.\\n       posible, de lo contrario devuelve verdadero e imprime la ruta.\\n       Tenga en cuenta que puede haber m\xe1s de una soluci\xf3n,\\n       Esta funci\xf3n imprime una de las soluciones factibles.*/\\n    static int hamCycle(int graph[][]) {\\n        path = new int[V];\\n        for (int i = 0; i < V; i++) {\\n            path[i] = -1;\\n        }\\n        /* Pongamos el v\xe9rtice 0 como el primer v\xe9rtice en el camino.\\n           Si hay un ciclo hamiltoniano, entonces el camino puede ser\\n           Comenz\xf3 desde cualquier punto del ciclo ya que la gr\xe1fica es\\n           no dirigido*/\\n        path[0] = 0;\\n        if (hamCycleUtil(graph, path, 1) == false) {\\n            System.out.println(\\"\\\\nNo existe soluci\xf3n\\");\\n            return 0;\\n        }\\n        printSolution(path);\\n        return 1;\\n    }\\n\\n    // Imprimir soluci\xf3n\\n    static void printSolution(int path[]) {\\n        System.out.println(\\"Soluci\xf3n existe: Este\\"\\n                + \\" es uno de los ciclos hamiltoniano\\");\\n        for (int i = 0; i < V; i++) {\\n            System.out.print(\\" \\" + path[i] + \\" \\");\\n        }\\n        System.out.println(\\" \\" + path[0] + \\" \\");\\n    }\\n\\n    public static void main(String args[]) {\\n        /*Tenemos el siguiente grafo \\n           (0)--(1)--(2) \\n            |   / \\\\   | \\n            |  /   \\\\  | \\n            | /     \\\\ | \\n           (3)-------(4)    */\\n        int graph1[][] = {{0, 1, 0, 1, 0},\\n        {1, 0, 1, 1, 1},\\n        {0, 1, 0, 0, 1},\\n        {1, 1, 0, 0, 1},\\n        {0, 1, 1, 1, 0},};\\n        // Imprimir soluci\xf3n\\n        hamCycle(graph1);\\n        /*Tenemos el siguiente grafo \\n           (0)--(1)--(2) \\n            |   / \\\\   | \\n            |  /   \\\\  | \\n            | /     \\\\ | \\n           (3)       (4)    */\\n        int graph2[][] = {{0, 1, 0, 1, 0},\\n        {1, 0, 1, 1, 1},\\n        {0, 1, 0, 0, 1},\\n        {1, 1, 0, 0, 0},\\n        {0, 1, 1, 0, 0},};\\n        // Imprimir soluci\xf3n\\n        hamCycle(graph2);\\n    }\\n}\\n","cpp":"#include<bits/stdc++.h>\\n#include<cstdlib>\\n#define MAX 256\\nusing namespace std;\\nconst int V = 5;\\nint path[MAX];\\n\\nbool isSafe(int v, int graph[V][V], int path[], int pos) {\\n    if (graph[path[pos - 1]][v] == 0)return false;\\n    for (int i = 0; i < pos; i++) {\\n        if (path[i] == v)return false;\\n    }\\n    return true;\\n}\\n\\nbool hamCycleUtil(int graph[V][V], int path[], int pos) {\\n    if (pos == V)return graph[path[pos - 1]][path[0]] == 1;\\n    for (int v = 1; v < V; v++) {\\n        if (isSafe(v, graph, path, pos)) {\\n            path[pos] = v;\\n            if (hamCycleUtil(graph, path, pos + 1) == true)return true;\\n        }\\n        path[pos] = -1;\\n    }\\n    return false;\\n}\\n\\nvoid printSolution(int path[]) {\\n    cout << \\"Solucion existente\\" << endl;\\n    for (int i = 0; i < V; i++) {\\n        cout << path[i] << \\" \\";\\n    }\\n    cout << endl;\\n}\\n\\nint hamCycle(int graph[V][V]) {\\n    path[V];\\n    memset(path, -1, sizeof path);\\n    path[0] = 0;\\n    if (hamCycleUtil(graph, path, 1) == false) {\\n        cout << \\"NO existe ciclo hamiltoniano\\" << endl;\\n        return 0;\\n    }\\n    printSolution(path);\\n    return 1;\\n}\\n\\nint main() {\\n    int graph1[V][V] = {\\n        {0, 1, 0, 1, 0},\\n        {1, 0, 1, 1, 1},\\n        {0, 1, 0, 0, 1},\\n        {1, 1, 0, 0, 1},\\n        {0, 1, 1, 1, 0},};\\n    // Imprimir soluci\xc3\xb3n\\n    hamCycle(graph1);\\n    int graph2[V][V] = {\\n        {0, 1, 0, 1, 0},\\n        {1, 0, 1, 1, 1},\\n        {0, 1, 0, 0, 1},\\n        {1, 1, 0, 0, 0},\\n        {0, 1, 1, 0, 0},};\\n    // Imprimir soluci\xc3\xb3n\\n    hamCycle(graph2);\\n}\\n","py":null,"orden":8,"suborden":13,"fecha_creacion":"2020-12-05 00:45:49","fecha_modificacion":"2020-12-06 20:30:51"},{"ID":144,"supergrupo":"Grafos ","tema":"El tour del caballo de ajedrez ","texto":"El backtracking es un paradigma algor\xedtmico que intenta diferentes soluciones hasta que encuentra una soluci\xf3n que \u201cFunciona\u201d. Problemas los cuales son t\xedpicamente resueltos con t\xe9cnicas de backtracking tienen una propiedad en com\xfan, estos problemas puede solo ser resueltos intentando cada posible configuraci\xf3n y cada configuraci\xf3n es intentada una sola vez, una soluci\xf3n ingenua para estos problemas es intentar todas las configuraciones e imprimir una configuraci\xf3n que siga las restricciones dadas por el problema. Backtracking funciona en forma incremental y es una optimizaci\xf3n sobre las soluciones ingenuas donde todas las posibles configuraciones son generadas e intentadas.\\n\\nBacktracking funciona de forma incremental para atacar problemas, t\xedpicamente iniciamos desde un vector de soluci\xf3n vac\xedo, y uno por uno vamos agregando \xedtems, cuando agregamos un \xedtem podemos verificar si agregando el siguiente \xedtem violamos alguna de las restricciones del problema, si lo hace eliminamos ese elemento e intentamos otras alternativas. Si ninguna de las alternativas funciona entonces volvemos a la fase previa y removemos el \xedtem anterior dado en la fase anterior. Si alcanzamos la fase inicial entonces decimos que no existe soluci\xf3n, si agregamos un valor que no viola alguna restricci\xf3n entonces recursivamente agregamos \xedtems uno por uno, si el vector de soluci\xf3n se completa imprimimos la soluci\xf3n.\\n\\nEl siguiente es el backtracking del problema del tour del caballo en el tablero de ajedrez.\\n- Si todos los cuadrados son visitados imprima la soluci\xf3n\\n- Si no \\na) Agregue uno de los siguientes movimientos posibles al vector de soluci\xf3n y recursivamente verifique si este movimiento lleva a una soluci\xf3n (Un caballo puede hacer m\xe1ximo 8 movimientos, aqu\xed escogemos alguno de esos 8 movimientos).\\nb) Si el movimiento escogido arriba no lleva a una soluci\xf3n entonces removemos este movimiento del vector de soluci\xf3n e intentamos otros movimientos alternativos.\\nc) Si ninguna de las alternativas funciona, retornamos falso (Retornando falso podemos remover el anterior \xedtem agregado en recursi\xf3n y si el falso es retornado a la recursi\xf3n inicial entonces no existe soluci\xf3n.\\n","complejidad_tiempo":"Mejor caso :    O(|v|+|e|)  Peor caso : O(|v|+|e|)  Promedio: O(|v|+|e|) ","java":"// Programa java para el problema del tour del caballo\\npublic class KnightTourBacktracking {\\n\\n    static int N = 8;\\n\\n    /* Una funci\xf3n que verifica si i.j es\\n    indice valido para un tablero n*n*/\\n    static boolean isSafe(int x, int y, int sol[][]) {\\n        return (x >= 0 && x < N && y >= 0\\n                && y < N && sol[x][y] == -1);\\n    }\\n\\n    /* Imprimir la soluci\xf3n*/\\n    static void printSolution(int sol[][]) {\\n        for (int x = 0; x < N; x++) {\\n            for (int y = 0; y < N; y++) {\\n                System.out.print(sol[x][y] + \\"\\\\t\\");\\n            }\\n            System.out.println();\\n        }\\n    }\\n        /*Esta funci\xf3n resuelve el problema de Knight Tour.\\n       utilizando Backtracking. Esta funci\xf3n principalmente\\n       utiliza solveKTUtil () para resolver el problema. Eso\\n       devuelve falso si no es posible realizar un recorrido completo,\\n       De lo contrario, devuelve true e imprime el recorrido.\\n       Tenga en cuenta que puede haber m\xe1s de una\\n       soluciones, esta funci\xf3n imprime una de las\\n       soluciones viables.*/\\n    static boolean solveKT() {\\n        int sol[][] = new int[N][N];\\n        /* Inicializando la matriz de soluci\xf3n*/\\n        for (int x = 0; x < N; x++) {\\n            for (int y = 0; y < N; y++) {\\n                sol[x][y] = -1;\\n            }\\n        }\\n        /* xMove[] y yMove[] define el siguiente movimiento del caballo \\n          xMove[] para siguiente valor en x\\n          yMove[] para siguiente valor en y */\\n        int xMove[] = {2, 1, -1, -2, -2, -1, 1, 2};\\n        int yMove[] = {1, 2, 2, 1, -1, -2, -2, -1};\\n        //Desde que el caballero inicie en el primer bloque\\n        sol[0][0] = 0;\\n        if (!solveKTUtil(0, 0, 1, sol, xMove, yMove)) {\\n            System.out.println(\\"No existe la soluci\xf3n\\");\\n            return false;\\n        } else {\\n            printSolution(sol);\\n        }\\n        return true;\\n    }\\n\\n    static boolean solveKTUtil(int x, int y, int movei,\\n            int sol[][], int xMove[],\\n            int yMove[]) {\\n        int k, next_x, next_y;\\n        if (movei == N * N) {\\n            return true;\\n        }\\n        /* Intenta todos los movimientos desde la coordenada\\n        x  y y*/\\n        for (k = 0; k < 8; k++) {\\n            next_x = x + xMove[k];\\n            next_y = y + yMove[k];\\n            if (isSafe(next_x, next_y, sol)) {\\n                sol[next_x][next_y] = movei;\\n                if (solveKTUtil(next_x, next_y, movei + 1,\\n                        sol, xMove, yMove)) {\\n                    return true;\\n                } else {\\n                    sol[next_x][next_y] = -1;// backtracking \\n                }\\n            }\\n        }\\n        return false;\\n    }\\n    public static void main(String args[]) {\\n        solveKT();\\n    }\\n}\\n","cpp":"#include <bits/stdc++.h>\\n#define tablero 101\\nusing namespace std;\\nint N = 12;\\n\\nbool isSafe(int x, int y, int sol[tablero][tablero]) {\\n    return (x >= 0 && x < N && y >= 0 && y < N && sol[x][y] == -1);\\n}\\n\\nvoid printSolution(int sol[tablero][tablero]) {\\n    for (int x = 0; x < N; x++) {\\n        for (int y = 0; y < N; y++) {\\n            cout << sol[x][y] << \\"\\\\t\\";\\n        }\\n        cout << endl;\\n    }\\n}\\n\\nbool solveKUtil(int x, int y, int movei, int sol[tablero][tablero], int xMove[tablero], int yMove[tablero]) {\\n    int k, next_x, next_y;\\n    if (movei == N * N) {\\n        return true;\\n    }\\n    for (k = 0; k < N; k++) {\\n        next_x = x + xMove[k];\\n        next_y = y + yMove[k];\\n        if (isSafe(next_x, next_y, sol)) {\\n            sol[next_x][next_y] = movei;\\n            if (solveKUtil(next_x, next_y, movei + 1, sol, xMove, yMove)) {\\n                return true;\\n            } else {\\n                sol[next_x][next_y] = -1;\\n            }\\n        }\\n    }\\n    return false;\\n}\\n\\nbool solveKT() {\\n    int sol[tablero][tablero];\\n    for (int x = 0; x < N; x++) {\\n        for (int y = 0; y < N; y++) {\\n            sol[x][y] = -1;\\n        }\\n    }\\n    int xMove[8] = {2, 1, -1, -2, -2, -1, 1, 2};\\n    int yMove[8] = {1, 2, 2, 1, -1, -2, -2, -1};\\n    sol[0][0] = 0;\\n    if (!solveKUtil(0, 0, 1, sol, xMove, yMove)) {\\n        cout << \\"No existe la solucion\\" << endl;\\n        return false;\\n    } else {\\n        printSolution(sol);\\n    }\\n    return true;\\n}\\n\\nint main() {\\n    solveKT();\\n}\\n","py":null,"orden":8,"suborden":14,"fecha_creacion":"2020-12-05 00:45:50","fecha_modificacion":"2022-03-08 14:36:15"},{"ID":145,"supergrupo":"Grafos ","tema":"15.16) Kosaraju DFS  Componentes fuertemente conexas ","texto":"Dado un grafo dirigido, encontrar si el grafo se encuentra fuertemente conectado o no, un grado es fuertemente conectado si hay un camino entre cualquier par de v\xe9rtices.\\nEsto es f\xe1cil para un grafo no dirigido, solo tenemos que hacer BFS y DFS comenzando desde cualquier v\xe9rtice, si BFS o DFS visita todos los v\xe9rtices, entonces el grado no dirigido dado est\xe1 conectado, esta aproximaci\xf3n no funciona con un grafo dirigido.\\nUna simple idea es usar un algoritmo de todos los caminos m\xe1s cortos entre todos los pares como Floyd Warshall o encontrar el cerramiento transitivo del grafo, la complejidad de tiempo de este m\xe9todo es de O (v^3).\\nPodemos tambi\xe9n hacer DFS V veces iniciando desde cada v\xe9rtice, si alguno de los DFS no visita todos los v\xe9rtices entonces el grafo no es fuertemente conectado. Este algoritmo toma O (V*(V+E)) en complejidad de tiempo, el cual puede ser el mismo del cerramiento transitivo para un grafo denso.\\nUna mayor idea puede ser el algoritmo de componentes fuertemente conectadas (SCC), podemos encontrar todos los SCC en O (V+E) tiempo, si el n\xfamero de SCC es 1, entonces el grafo es fuertemente conectado, el algoritmo de SCC hace trabajo extra cuando busca todos los SCC.\\nEl siguiente es un algoritmo simple basado en el DFS de Kosaraju el cual realiza dos DFS transversos en el grafo.\\n1) Inicializa todos los v\xe9rtices como no visitados.\\n2) Hace un DFS transverso del grado iniciando desde cualquier v\xe9rtice v, si este DFS transverso no visita todos los v\xe9rtices, entonces retorna falso.\\n3) Reversa todos los arcos (O encuentra transpuesta o reversa de grafo)\\n4) Marque todos los v\xe9rtices como no visitados en el grafo reverso\\n5) Hacer un DFS transverso del grafo reversado iniciando desde el mismo v\xe9rtice v, si el DFS transverso no visita todos los v\xe9rtices entonces retorna falso, de otro modo retorna true.\\nLa idea es, si cada nodo puede ser alcanzado de un v\xe9rtice v, y cada nodo puede alcanzar v, entonces el grafo es fuertemente conectado. En el paso dos podemos verificar si todos los v\xe9rtices son alcanzables desde v, en el paso 4 verificamos si todos los v\xe9rtices puede alcanzar v (En el grafo reverso, si todos los v\xe9rtices son alcanzables desde v entonces todos los v\xe9rtices pueden alcanzar v en el grafo original).\\nLa complejidad de tiempo de esta implementaciones es la misma de DFS, el cual es O (V+E) si el grafo est\xe1 representado usando listas de adyacencia.\\n","complejidad_tiempo":"Mejor caso :    O(|v|+|e|)  Peor caso : O(|v|+|e|)  Promedio: O(|v|+|e|) ","java":"// Programa java que verifica si un grafo es \\n// fuertemente conectado\\n\\nimport java.util.*;\\nimport java.util.LinkedList;\\n\\npublic class KosarajuDFSStronglyConnected {\\n\\n    public static void main(String args[]) {\\n        Graph g1 = new Graph(5);\\n        g1.addEdge(0, 1);\\n        g1.addEdge(1, 2);\\n        g1.addEdge(2, 3);\\n        g1.addEdge(3, 0);\\n        g1.addEdge(2, 4);\\n        g1.addEdge(4, 2);\\n        if (g1.isSC()) {\\n            System.out.println(\\"Si\\");\\n        } else {\\n            System.out.println(\\"No\\");\\n        }\\n        Graph g2 = new Graph(4);\\n        g2.addEdge(0, 1);\\n        g2.addEdge(1, 2);\\n        g2.addEdge(2, 3);\\n        if (g2.isSC()) {\\n            System.out.println(\\"Si\\");\\n        } else {\\n            System.out.println(\\"No\\");\\n        }\\n    }\\n\\n    static class Graph {\\n        private int V;\\n        private LinkedList<Integer> adj[];\\n        Graph(int v) {\\n            V = v;\\n            adj = new LinkedList[v];\\n            for (int i = 0; i < v; ++i) {\\n                adj[i] = new LinkedList();\\n            }\\n        }\\n        void addEdge(int v, int w) {\\n            adj[v].add(w);\\n        }\\n\\n        void DFSUtil(int v, Boolean visited[]) {\\n            visited[v] = true;\\n            int n;\\n            Iterator<Integer> i = adj[v].iterator();\\n            while (i.hasNext()) {\\n                n = i.next();\\n                if (!visited[n]) {\\n                    DFSUtil(n, visited);\\n                }\\n            }\\n        }\\n        // Obtiene el transpuesto de un grafo\\n        Graph getTranspose() {\\n            Graph g = new Graph(V);\\n            for (int v = 0; v < V; v++) {\\n                Iterator<Integer> i = adj[v].listIterator();\\n                while (i.hasNext()) {\\n                    g.adj[i.next()].add(v);\\n                }\\n            }\\n            return g;\\n        }\\n        //Verifica si el grafo esta fuertemente conectado\\n        Boolean isSC() {\\n            /*Paso 1: marcar todos los vertices como no visitados\\n            (primer DFS)*/\\n            Boolean visited[] = new Boolean[V];\\n            for (int i = 0; i < V; i++) {\\n                visited[i] = false;\\n            }\\n            //Paso 2: DFS transverso desde el primer vertice\\n            DFSUtil(0, visited);\\n            // si no visita todos, retorna falso\\n            for (int i = 0; i < V; i++) {\\n                if (visited[i] == false) {\\n                    return false;\\n                }\\n            }\\n            // Paso 3: crear grafo transpuesto\\n            Graph gr = getTranspose();\\n            // Paso 4: marcar todos los vertices como no visitados\\n            // (Segundo DFS)\\n            for (int i = 0; i < V; i++) {\\n                visited[i] = false;\\n            }\\n            /* Paso 5: hacer DFS en el grafo reversado*/\\n            gr.DFSUtil(0, visited);\\n            /* Si todos los vertices no son visitados, retorne falso*/\\n            for (int i = 0; i < V; i++) {\\n                if (visited[i] == false) {\\n                    return false;\\n                }\\n            }\\n            return true;\\n        }\\n    }\\n}\\n","cpp":null,"py":null,"orden":8,"suborden":15,"fecha_creacion":"2020-12-05 00:45:50","fecha_modificacion":"2020-12-06 20:30:53"},{"ID":146,"supergrupo":"Grafos ","tema":"M\xednimo de movimientos de un caballo de ajedrez ","texto":"Dado una mesa de ajedrez cuadrada de tama\xf1o NxN, la posici\xf3n de un caballo y la posici\xf3n objetivo, necesitamos encontrar la m\xednima cantidad de pasos que un caballo toma para llegar a la posici\xf3n objetivo.\\nEste problema puede verse como el camino m\xe1s corto en un grafo sin pesos, sin embargo usamos BFS \xb4para resolver este problema, intentamos todos las 8 posibles posiciones donde un caballo puede llegar desde su posici\xf3n, si la posici\xf3n alcanzable no ha sido visitada ya y est\xe1 dentro del tablero, agregamos este estado dentro de la cola con una distancia de 1 m\xe1s que su estado padre, finalmente retornamos la distancia de la posici\xf3n objetivo cuando sale de la cola.\\nEl siguiente c\xf3digo implementa BFS para la b\xfasqueda a trav\xe9s de las celdas, donde cada celda contiene sus coordenadas y distancias desde el nodo inicial, en el peor de los casos el c\xf3digo visita todas las celdas del tablero, haciendo que el la complejidad del peor de los casos sea O(n^2).\\n","complejidad_tiempo":"Mejor caso :    O(|v|+|e|)  Peor caso : O(v2)  Promedio: O(|v|+|e|) ","java":"//Programa java que encuentra la minima cantidad de pasos\\n// para alcanzar una celda especifica con un caballo\\n\\nimport java.util.Vector;\\n\\npublic class MinimumMovesKnight {\\n\\n    /*Clase que almacena los datos de una celda*/\\n    static class cell {\\n\\n        int x, y;\\n        int dis;\\n\\n        public cell(int x, int y, int dis) {\\n            this.x = x;\\n            this.y = y;\\n            this.dis = dis;\\n        }\\n    }\\n\\n    /* Utilidad que retorna s (x,y) yace dentro del tablero*/\\n    static boolean isInside(int x, int y, int N) {\\n        return x >= 1 && x <= N && y >= 1 && y <= N;\\n    }\\n\\n    /* Retorna los minimos pasos para llegar al objetivo*/\\n    static int minStepToReachTarget(int knightPos[], int targetPos[],\\n            int N) {\\n        // direcci\xf3n x y y, donde el caballo puede llegar \\n        int dx[] = {-2, -1, 1, 2, -2, -1, 1, 2};\\n        int dy[] = {-1, -2, -2, -1, 1, 2, 2, 1};\\n        // Vector para almacenar los estados del caballo\\n        Vector<cell> q = new Vector<>();\\n        // Agrega la posicion inicial con distancia 0\\n        q.add(new cell(knightPos[0], knightPos[1], 0));\\n        cell t;\\n        int x, y;\\n        boolean visit[][] = new boolean[N + 1][N + 1];\\n        //Hacer todas las celdas sin visitar\\n        for (int i = 1; i <= N; i++) {\\n            for (int j = 1; j <= N; j++) {\\n                visit[i][j] = false;\\n            }\\n        }\\n\\n        // visitar estado inicial\\n        visit[knightPos[0]][knightPos[1]] = true;\\n        // ciclo hasta que quede solo un valor \\n        while (!q.isEmpty()) {\\n            t = q.firstElement();\\n            q.remove(0);\\n            /* Si la celda actual es igual al objetivo\\n            retorne su distancia*/\\n            if (t.x == targetPos[0] && t.y == targetPos[1]) {\\n                return t.dis;\\n            }\\n            // Ciclo de todos los estados alcancables\\n            for (int i = 0; i < 8; i++) {\\n                x = t.x + dx[i];\\n                y = t.y + dy[i];\\n                if (isInside(x, y, N) && !visit[x][y]) {\\n                    visit[x][y] = true;\\n                    q.add(new cell(x, y, t.dis + 1));\\n                }\\n            }\\n        }\\n        return Integer.MAX_VALUE;\\n    }\\n\\n    public static void main(String[] args) {\\n        int N = 30;\\n        int knightPos[] = {1, 1};\\n        int targetPos[] = {30, 30};\\n        System.out.println(minStepToReachTarget(knightPos, targetPos, N));\\n    }\\n}\\n","cpp":null,"py":null,"orden":8,"suborden":16,"fecha_creacion":"2020-12-05 00:45:50","fecha_modificacion":"2020-12-06 20:30:53"},{"ID":147,"supergrupo":"Grafos ","tema":"El problema de las N reinas","texto":"El problema de las N reinas es aquel en donde se colocan N reinas en un tablero de NxN de tal manera que dos reinas no puedan atacarse una con otra.\\nLa idea es colocar reinas una por una en diferentes columnas, iniciando desde la columna de m\xe1s a la izquierda, cuando colocamos una reina en una columna, verificamos por colisiones con las reinas ya colocadas, en la columna actual, si encontramos una fila en la cual no hay colisi\xf3n marcamos esta columna y fila como parte de la soluci\xf3n, si nosotros no encontramos tal fila en donde haya colisi\xf3n entonces se retrocede y se retorna falso.\\n1) Iniciar desde la columna de m\xe1s a la izquierda.\\n2) Si todas las reinas han sido colocadas, retornar true\\n3) Intentar todas las filas de la  columna actual\\nRealizar lo siguiente para cada columna intentada\\na) si la reina puede ser colocada seguramente en esta fila entonces marcar esta [fila, columna] como parte de la soluci\xf3n y recursivamente verificar si colocando una reina aqu\xed se llega a la soluci\xf3n.\\nb) Si colocando una reina en [fila,columa] se llega a una soluci\xf3n, entonces retorne true.\\nc) Si colocando una reina no se llega a la soluci\xf3n entonces desmarque esta fila y columna (Paso atr\xe1s) y vaya al paso A para intentar otras filas.\\n4) Si todas las filas han sido probadas y ninguna funciona retorne falso para activar el backtracking.\\n","complejidad_tiempo":"Mejor caso :    O(v3)  Peor caso : O(v3) Promedio: O(v3) ","java":"/* Programa JAVA que resuelve el problema de las N reinas\\nusando backtracking*/\\npublic class NQueenProblem {\\n    final int N = 4;\\n\\n    void printSolution(int board[][]) {\\n        for (int i = 0; i < N; i++) {\\n            for (int j = 0; j < N; j++) {\\n                System.out.print(\\" \\" + board[i][j]\\n                        + \\" \\");\\n            }\\n            System.out.println();\\n        }\\n    }\\n/*Una funci\xf3n de utilidad para comprobar si una reina puede\\n       colocarse en board[row][col]. Tenga en cuenta que \\n       La funci\xf3n se llama cuando \\"col\\" reinas ya est\xe1n\\n       Colocadas en columnas de 0 a col -1. As\xed que necesitamos\\n       para comprobar s\xf3lo el lado izquierdo para las reinas atacantes*/\\n    boolean isSafe(int board[][], int row, int col) {\\n        int i, j;\\n        /*Verifica esta fila en el lado izquierdo*/\\n        for (i = 0; i < col; i++) {\\n            if (board[row][i] == 1) {\\n                return false;\\n            }\\n        }\\n        /*Verifica la diagonal superior de la izquierda*/\\n        for (i = row, j = col; i >= 0 && j >= 0; i--, j--) {\\n            if (board[i][j] == 1) {\\n                return false;\\n            }\\n        }\\n        /*Diagonal baja desde la izquierda*/\\n        for (i = row, j = col; j >= 0 && i < N; i++, j--) {\\n            if (board[i][j] == 1) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n\\n    boolean solveNQUtil(int board[][], int col) {\\n        /* Caso base: Si todas las reinas estan\\n        puestas, retorne true*/\\n        if (col >= N) {\\n            return true;\\n        }\\n        /*Considere esta columna e intente colocando esta \\n        reina en todas las filas una por una*/\\n        for (int i = 0; i < N; i++) {\\n            /* Verifica si la reina puede ser puesta\\n            en board[i][col] */\\n            if (isSafe(board, i, col)) {\\n                board[i][col] = 1;\\n                /*Recursivamente pone todas las reinas*/\\n                if (solveNQUtil(board, col + 1) == true) {\\n                    return true;\\n                }\\n                board[i][col] = 0; // BACKTRACK \\n            }\\n        }\\n        /*Si la reina no puede ser puesta en \\n        ninguna fila en esta columna,r retorna falso*/\\n        return false;\\n    }\\n\\n    /*Esta funci\xf3n resuelve el problema de N Queen usando\\n    Backtracking. Utiliza principalmente solveNQUtil() \\n    para resolver el problema. Devuelve false si no se \\n    pueden colocar las reinas; de lo contrario, devuelve \\n    true e imprime la ubicaci\xf3n de las reinas en forma de \\n    1s. Tenga en cuenta que puede haber m\xe1s de una soluci\xf3n,\\n    esta funci\xf3n imprime una de las soluciones posibles.*/\\n    boolean solveNQ() {\\n        int board[][] = {{0, 0, 0, 0},\\n        {0, 0, 0, 0},\\n        {0, 0, 0, 0},\\n        {0, 0, 0, 0}\\n        };\\n        if (solveNQUtil(board, 0) == false) {\\n            System.out.print(\\"Soluci\xf3n no existe\\");\\n            return false;\\n        }\\n        printSolution(board);\\n        return true;\\n    }\\n\\n    public static void main(String args[]) {\\n        NQueenProblem Queen = new NQueenProblem();\\n        Queen.solveNQ();\\n    }\\n}\\n","cpp":null,"py":null,"orden":8,"suborden":17,"fecha_creacion":"2020-12-05 00:45:50","fecha_modificacion":"2020-12-06 20:30:54"},{"ID":148,"supergrupo":"Grafos ","tema":"Ordenamiento topol\xf3gico","texto":"Ordenamiento topol\xf3gico de un grafo dirigido aciclico (DAG) es un ordenamiento lineal de v\xe9rtices tales que por cada camino dirigido uv, el v\xe9rtice u venga antes de v en el orden, si el grafo no es DAG no es posible el ordenamiento topol\xf3gico.\\nEn DFS imprimimos un v\xe9rtice y luego recursivamente llamamos DFS para los v\xe9rtices adyacentes, en el ordenamiento topol\xf3gico necesitamos imprimir un v\xe9rtice antes de sus v\xe9rtices adyacentes.\\n","complejidad_tiempo":"Mejor caso :    O(|v|+|e|)  Peor caso : O(|v|+|e|)  Promedio: O(|v|+|e|) ","java":"// Programa java que imprime el ordenamiendo topologico\\n// de un grafo dirigido\\n\\nimport java.util.*;\\n\\npublic class TopologicalSorting {\\n    public static void main(String args[]) {\\n        Graph g = new Graph(6);\\n        g.addEdge(5, 2);\\n        g.addEdge(5, 0);\\n        g.addEdge(4, 0);\\n        g.addEdge(4, 1);\\n        g.addEdge(2, 3);\\n        g.addEdge(3, 1);\\n        System.out.println(\\"Siguiendo el ordenamiento topologico \\"\\n                + \\"del grafo dado \\");\\n        g.topologicalSort();\\n    }\\n\\n    static class Graph {\\n        private int V;\\n        private LinkedList<Integer> adj[];\\n        Graph(int v) {\\n            V = v;\\n            adj = new LinkedList[v];\\n            for (int i = 0; i < v; ++i) {\\n                adj[i] = new LinkedList();\\n            }\\n        }\\n\\n        void addEdge(int v, int w) {\\n            adj[v].add(w);\\n        }\\n\\n        void topologicalSortUtil(int v, boolean visited[],\\n                Stack stack) {\\n            visited[v] = true;\\n            Integer i;\\n            Iterator<Integer> it = adj[v].iterator();\\n            while (it.hasNext()) {\\n                i = it.next();\\n                if (!visited[i]) {\\n                    topologicalSortUtil(i, visited, stack);\\n                }\\n            }\\n            stack.push(new Integer(v));\\n        }\\n        void topologicalSort() {\\n            Stack stack = new Stack();\\n            boolean visited[] = new boolean[V];\\n            for (int i = 0; i < V; i++) {\\n                visited[i] = false;\\n            }\\n            for (int i = 0; i < V; i++) {\\n                if (visited[i] == false) {\\n                    topologicalSortUtil(i, visited, stack);\\n                }\\n            }\\n            // Imprime el contenido de la pila\\n            while (stack.empty() == false) {\\n                System.out.print(stack.pop() + \\" \\");\\n            }\\n        }\\n    }\\n}\\n","cpp":null,"py":null,"orden":8,"suborden":18,"fecha_creacion":"2020-12-05 00:45:51","fecha_modificacion":"2020-12-06 20:30:54"},{"ID":149,"supergrupo":"Grafos ","tema":"Algoritmo de Kahn para ordenamiento topol\xf3gico ","texto":"Ordenamiento topol\xf3gico para un grafo dirigido aciclico (DAG) es un ordenamiento lineal de v\xe9rtices el cual por cada camino dirigido UV, el v\xe9rtice U viene antes de V en el ordenamiento, el ordenamiento topol\xf3gico no es posible si el grafo no es un DAG.\\nLos pasos de este algoritmo son los siguientes:\\n1) Calcule los grados de entrada de cada v\xe9rtice en el DAG presente e inicialice el conteo de los nodos visitados como 0.\\n2) Tome todos los v\xe9rtices con grado de entrada como o y agr\xe9guelos en una cola\\n3) Remueva un v\xe9rtice de la cola y entonces incremente el conteo de nodos visitados por 1\\n4) Decremente el grado de entrada en 1 en todos los nodos vecinos, si el grado de entrada de los nodos vecinos es cero, agr\xe9guelos a la cola.\\n5) Repita el paso 3 hasta que la cola este vac\xeda.\\n6) Si el conteo de nodos visitados no es igual al n\xfamero de notos en el grado entonces el ordenamiento topol\xf3gico no es posible en este grafo.\\n\xbfC\xf3mo encontrar el grado de entrada en cada nodo?\\nExisten dos v\xedas  para encontrar el grado de entrada de  cada nodo.\\nTomaremos un array de grado de entrada para mantener rastreo de estos.\\n1) Atraviese el array de nodos y simplemente incremente el conteo del nodo de destino en 1-\\nfor each node in Nodes\\n    indegree[node] = 0;\\nfor each edge(src,dest) in Edges\\n    indegree[dest]++\\n2) Atraviese la lista de cada nodo e incremente el grado de entrada de todos los nodos conectados con \xe9l en 1\\nfor each node in Nodes\\n        If (list[node].size()!=0) then\\n        for each dest in list\\n            indegree[dest]++;\\nLa complejidad de tiempo se da por: el ciclo externo ser\xe1 ejecutado V n\xfamero de veces y el interno ser\xe1 ejecutado E n\xfamero de veces, la complejidad resultante ser\xe1 de O(V+E).\\n","complejidad_tiempo":"Mejor caso :    O(|v|+|e|)  Peor caso : O(|v|+|e|)  Promedio: O(|v|+|e|) ","java":"// Programa java que imprime el ordenamiento topologico\\n// de un grafo  \\n\\nimport java.util.*;\\n\\npublic class KahnAlgorithmTopologicalSorting {\\n\\n    public static void main(String args[]) {\\n        Graph g = new Graph(6);\\n        g.addEdge(5, 2);\\n        g.addEdge(5, 0);\\n        g.addEdge(4, 0);\\n        g.addEdge(4, 1);\\n        g.addEdge(2, 3);\\n        g.addEdge(3, 1);\\n        System.out.println(\\"Siguiendo su ordenamiento topologico \\");\\n        g.topologicalSort();\\n    }\\n\\n    static class Graph {\\n        int V;\\n        List<Integer> adj[];\\n        public Graph(int V)// Constructor \\n        {\\n            this.V = V;\\n            adj = new ArrayList[V];\\n            for (int i = 0; i < V; i++) {\\n                adj[i] = new ArrayList<>();\\n            }\\n        }\\n        // Agregar caminos\\n        public void addEdge(int u, int v) {\\n            adj[u].add(v);\\n        }\\n\\n        public void topologicalSort() {\\n            // Crea un array para almaccenar los indegrees\\n            // de todos los vertices e inicializa en 0\\n            int indegree[] = new int[V];\\n            // Atraviesa las listas de adyacencia para llenar\\n            // grados de los vertices       \\n            for (int i = 0; i < V; i++) {\\n                ArrayList<Integer> temp = (ArrayList<Integer>) adj[i];\\n                temp.forEach((node) -> {\\n                    indegree[node]++;\\n                });\\n            }\\n            /* Crea una cola y encola todos los vertices\\n            con grado 0*/\\n            Queue<Integer> q = new LinkedList<>();\\n            for (int i = 0; i < V; i++) {\\n                if (indegree[i] == 0) {\\n                    q.add(i);\\n                }\\n            }\\n            // Inicializa el conteo de vertices visitados\\n            int cnt = 0;\\n            // Crea un vector que almacena el resultado\\n            ArrayList<Integer> topOrder = new ArrayList<Integer>();\\n            while (!q.isEmpty()) {\\n                int u = q.poll();\\n                topOrder.add(u);\\n  //Funcion lamba Reemplazable con un for\\n                adj[u].stream().filter((node) -> (--indegree[node] == 0)).forEachOrdered((node) -> {\\n                    q.add(node);\\n                });\\n                cnt++;\\n            }\\n            // Verifica si hay ciclo       \\n            if (cnt != V) {\\n                System.out.println(\\"There exists a cycle in the graph\\");\\n                return;\\n            }\\n            //Imprime el ordenamiento topologico             \\n            for (int i : topOrder) {\\n                System.out.print(i + \\" \\");\\n            }\\n        }\\n    }\\n}\\n","cpp":null,"py":null,"orden":8,"suborden":19,"fecha_creacion":"2020-12-05 00:45:51","fecha_modificacion":"2020-12-06 20:30:55"},{"ID":150,"supergrupo":"Grafos ","tema":"Caminos m\xe1s cortos mediante Dijkstra","texto":"Dado un grafo y un v\xe9rtice origen en el grafo, encuentre los caminos m\xe1s cortos del origen a todos los v\xe9rtices en el grafo dado.\\n\\nLa complejidad de tiempo de esta implementaci\xf3n es de O (V*E) si el grafo de entrada est\xe1 representado usando una lista de adyacencia. Tener en cuenta que Dijkstra no procesa pesos negativos y no detecta ciclos negativos.\\n","complejidad_tiempo":"Mejor caso :    O(v*e)  Peor caso : O(v2)  Promedio: O(v*e) ","java":"// Implementaci\xf3n java del algoritmo de Dijkstra que\\n// busca el camino m\xe1s corto de un nodo al resto\\n/*\\n EJEMPLO DE INPUT\\n 5 9\\n 1 2 7\\n 1 4 2\\n 2 3 1\\n 2 4 2\\n 3 5 4\\n 4 2 3\\n 4 3 8\\n 4 5 5\\n 5 3 5\\n 1\\n */\\nimport java.util.*;\\n\\npublic class DijkstraSP {\\n\\n    //similar a los defines de C++\\n    static final int MAX = 10005; //maximo n\xfamero de v\xe9rtices\\n    static final int INF = 1 << 30; //definimos un valor \\n    //grande que represente la distancia infinita\\n    //inicial, basta conque sea superior al maximo \\n    //valor del peso en alguna de las aristas\\n    //En el caso de java usamos una clase que \\n    //representara el pair de C++\\n\\n    static class Node implements Comparable<Node> {\\n\\n        int first, second;\\n\\n        Node(int d, int p) { //constructor\\n            this.first = d;\\n            this.second = p;\\n        }\\n\\n        @Override\\n        public int compareTo(Node other) { //es necesario \\n            //definir un comparador para el\\n            //correcto funcionamiento del PriorityQueue\\n            if (second > other.second) {\\n                return 1;\\n            }\\n            if (second == other.second) {\\n                return 0;\\n            }\\n            return -1;\\n        }\\n    };\\n\\n    static Scanner sc = new Scanner(System.in); //para lectura de datos\\n    static List< List< Node>> ady = new ArrayList< List< Node>>(); //lista de adyacencia\\n    static int distancia[] = new int[MAX]; // distancia de v\xe9rtice inicial\\n    //v\xe9rtice con ID = u\\n    static boolean visitado[] = new boolean[MAX]; //para v\xe9rtices visitados\\n    static PriorityQueue< Node> Q = new PriorityQueue<Node>();\\n    //usamos el comparador definido para \\n    //que el de menor valor este en el tope\\n    static int V; //n\xfamero de vertices\\n    static int previo[] = new int[MAX]; //para la impresion de caminos\\n\\n    //funci\xf3n de inicializaci\xf3n\\n    static void init() {\\n        for (int i = 0; i <= V; ++i) {\\n            distancia[i] = INF; //inicializamos todas \\n            //las distancias con valor infinito\\n            visitado[i] = false; //inicializamos todos \\n            //los v\xe9rtices como no visitados\\n            previo[i] = -1; //inicializamos el previo \\n            //del vertice i con -1\\n        }\\n    }\\n\\n    //Paso de relajacion\\n    static void relajacion(int actual, int adyacente, int peso) {\\n        //Si la distancia del origen al vertice actual + \\n        //peso de su arista es menor a la distancia del\\n        //origen al vertice adyacente\\n        if (distancia[actual] + peso < distancia[adyacente]) {\\n            //relajamos el vertice actualizando la distancia\\n            distancia[adyacente] = distancia[actual] + peso;\\n            //a su vez actualizamos el v\xe9rtice previo\\n            previo[adyacente] = actual;\\n            //agregamos adyacente a la cola de prioridad\\n            Q.add(new Node(adyacente, distancia[adyacente]));\\n        }\\n    }\\n    //Impresion del camino m\xe1s corto desde el vertice inicial y final ingresados\\n    static void print(int destino) {\\n        if (previo[destino] != -1) //si aun poseo un vertice previo\\n        {\\n            print(previo[destino]); //recursivamente sigo explorando\\n        }\\n        //terminada la recursion imprimo los vertices\\n        //recorridos\\n        System.out.printf(\\"%d \\", destino);\\n    }\\n\\n    static void dijkstra(int inicial) {\\n        init(); //inicializamos nuestros arreglos\\n        //Insertamos el v\xe9rtice inicial en la Cola de Prioridad\\n        Q.add(new Node(inicial, 0));\\n        //Este paso es importante, inicializamos la distancia del\\n        //inicial como 0\\n        distancia[inicial] = 0;\\n        int actual, adyacente, peso;\\n        while (!Q.isEmpty()) { //Mientras cola no este vacia\\n            //Obtengo de la cola el nodo con menor peso, en un\\n            //comienzo ser\xe1 el inicial\\n            actual = Q.element().first;\\n            Q.remove(); //Sacamos el elemento de la cola\\n            if (visitado[actual]) {\\n                continue; //Si el v\xe9rtice actual ya fue visitado entonces sigo\\n            }//sacando elementos de la cola\\n            visitado[actual] = true; //Marco como visitado el v\xe9rtice actual\\n            //reviso sus adyacentes del\\n            //vertice actual\\n            for (int i = 0; i < ady.get(actual).size(); ++i) {\\n                adyacente = ady.get(actual).get(i).first; //id del vertice adyacente\\n                //peso de la arista que une actual\\n                //con adyacente ( actual , adyacente )\\n                peso = ady.get(actual).get(i).second;\\n                //si el vertice adyacente no fue visitado\\n                if (!visitado[adyacente]) {\\n                    //realizamos el paso de relajacion\\n                    relajacion(actual, adyacente, peso);\\n                }\\n            }\\n        }\\n\\n        System.out.printf(\\"Distancias m\xe1s cortas iniciando en vertice %d\\\\n\\", inicial);\\n        for (int i = 1; i <= V; ++i) {\\n            System.out.printf(\\"Vertice %d , distancia m\xe1s corta = %d\\\\n\\", i, distancia[i]);\\n        }\\n\\n        System.out.println(\\"\\\\n**************Impresion de camino m\xe1s corto**************\\");\\n        System.out.printf(\\"Ingrese vertice destino: \\");\\n        int destino;\\n        destino = sc.nextInt();\\n        print(destino);\\n        System.out.printf(\\"\\\\n\\");\\n    }\\n\\n    public static void main(String[] args) {\\n        int E, origen, destino, peso, inicial;\\n\\n        V = sc.nextInt();\\n        E = sc.nextInt();\\n        for (int i = 0; i <= V; ++i) {\\n            ady.add(new ArrayList<Node>()); //inicializamos lista de\\n        }//adyacencia\\n        for (int i = 0; i < E; ++i) {\\n            origen = sc.nextInt();\\n            destino = sc.nextInt();\\n            peso = sc.nextInt();\\n            ady.get(origen).add(new Node(destino, peso)); //grafo dirigido\\n            //ady.get( destino ).add( new Node( origen , peso ) ); //no dirigido\\n        }\\n        System.out.print(\\"Ingrese el vertice inicial: \\");\\n        inicial = sc.nextInt();\\n        dijkstra(inicial);\\n    }\\n}\\n","cpp":"#include<bits/stdc++.h>\\n#include<cstdlib>\\n//---------------//\\n#define MAX 10005\\nconst int INF = 1 << 30;\\n//---------------// \\nusing namespace std;\\n\\nstruct Node {\\n    int destino, peso;\\n\\n    Node(int _destino, int _peso) : destino(_destino), peso(_peso) {\\n    }\\n\\n    Node() : destino(-1), peso(-1) {\\n    }\\n};\\n\\nstruct State {\\n    int destino;\\n    int peso;\\n\\n    State(int _destino, int _peso) : destino(_destino), peso(_peso) {\\n    }\\n\\n    bool operator<(const State &b) const {\\n        return peso > b.peso;\\n    }\\n};\\nvector <vector<Node> >ady(MAX);\\nint distancia[MAX];\\nbool visited[MAX];\\npriority_queue<State> Q;\\nint previo[MAX];\\n\\nvoid init(int V) {\\n    for (int i = 1; i <= V; i++) {\\n        distancia[i] = INF;\\n    }\\n}\\n\\nvoid relajacion(int actual, int adyacente, int peso) {\\n    if (distancia[actual] + peso < distancia[adyacente]) {\\n        distancia[adyacente] = distancia[actual] + peso;\\n        previo[adyacente] = actual;\\n        Q.push(State{adyacente, distancia[adyacente]});\\n    }\\n}\\n\\nvoid print(int destino) {\\n    if (previo[destino] != -1) {\\n        print(previo[destino]);\\n    }\\n    cout << destino << \\" \\";\\n}\\n\\nvoid dijkstra(int inicial, int V) {\\n    init(V);\\n    Q.push(State{inicial, 0});\\n    distancia[inicial] = 0;\\n    int actual, adyacente, peso;\\n    while (!Q.empty()) {\\n        actual = Q.top().destino;\\n        Q.pop();\\n        if (visited[actual]) {\\n            continue;\\n        }\\n        visited[actual] = true;\\n        for (int i = 0; i < ady[actual].size(); i++) {\\n            adyacente = ady[actual][i].destino;\\n            peso = ady[actual][i].peso;\\n            if (!visited[adyacente]) {\\n                relajacion(actual, adyacente, peso);\\n            }\\n        }\\n    }\\n    cout << \\"distancia mas corta iniciada desde \\" << inicial << endl;\\n    for (int i = 1; i <= V; i++) {\\n        cout << \\"vertice \\" << i << \\" distancia mas corta = \\" << distancia[i] << endl;\\n    }\\n    cout << \\"impresion del camino mas corto\\" << endl;\\n    int destino;\\n    cin>>destino;\\n    print(destino);\\n    cout << endl;\\n}\\n\\nint main() {\\n    memset(previo, -1, sizeof previo);\\n    int V, E, origen, destino, peso, inicial;\\n    cin >> V>>E;\\n    for (int i = 0; i < E; i++) {\\n        cin >> origen >> destino>>peso;\\n        ady[origen].push_back(Node{destino, peso}); //dirigido\\n        //ady[destino].push_back(Node{origen,peso});// no dirigido\\n    }\\n    cout << \\"Inserte el verice inicial\\" << endl;\\n    cin>>inicial;\\n    dijkstra(inicial, V);\\n}\\n","py":null,"orden":8,"suborden":20,"fecha_creacion":"2020-12-05 00:45:51","fecha_modificacion":"2020-12-06 20:30:56"},{"ID":151,"supergrupo":"Grafos ","tema":"15.22) Caminos m\xe1s cortos mediante Bellman-Ford ","texto":"Dado un grafo y un v\xe9rtice de origen src en el grafo, encontrar los caminos m\xe1s cortos desde src a todos los v\xe9rtices en el grafo dado, el grafo puede contener caminos con pesos negativos. Si hay un ciclo de peso negativo, entonces las distancias m\xe1s cortas no son calculadas, se reporta el ciclo negativo.\\n1) Este paso inicializa las distancias desde el origen de todos los v\xe9rtices como infinito y la distancia al origen en si como 0, crea un array dist[] de tama\xf1o V con todos los valores como infinito excepto dist[src] donde src es el v\xe9rtice origen.\\n2) Este paso calcula las distancias m\xe1s cortas, esto se realiza V-1 veces.\\n3) si dist[v] > dist[u] + peso del camino uv, entonces actualice dist[] en dist[v] = dist[u] + weight of edge uv\\n4) Este paso verifica si hay un ciclo negativo en el grafo, se realiza lo siguiente:\\n5) si dist[v] > dist[u] + peso del camino uv, entonces \u201cEl grafo contiene un ciclo negativo\u201d\\nLa idea del paso 3 es, el paso 2 garantiza las distancias m\xe1s cortas si el grafo no contiene un ciclo de peso negativo, si iteramos a trav\xe9s de todos los caminos una vez m\xe1s y obtenemos un camino m\xe1s corto para cualquier v\xe9rtice, entonces  ah\xed hay un ciclo negativo.\\nComo en otros problemas de programaci\xf3n din\xe1mica, el algoritmo calcula los caminos m\xe1s cortos de manera del atr\xe1s hacia adelante, primero calcula las distancias m\xe1s cortas las cuales tienen  al menos una arista en el camino, luego calcula los caminos m\xe1s cortos con al menos dos aristas, y as\xed en adelante, luego de la iesima iteraci\xf3n del ciclo exterior, los caminos m\xe1s cortos con al menos i aristas son calculados, ah\xed puede haber un m\xe1ximo de V-1 aristas en un camino simple, por eso el ciclo externo se corre V-1 veces, la idea es, asumiendo que ah\xed no hay ciclo negativo, si calculamos los caminos m\xe1s cortos con al menos i aristas, entonces una interacci\xf3n sobre todos las aristas garantiza darnos el camino m\xe1s corto con al menos i+1 artistas.\\nEjemplo basado en la imagen anterior:\\n\\nDado el v\xe9rtice origen 0, inicializamos todas las distancias como infinito, excepto la distancia al origen mismo, el n\xfamero total de v\xe9rtices en el grafo es 5 y todos los caminos deben ser procesados 4 veces.\\nTodos las aristas son procesadas en el siguiente orden, (B, E), (D, B), (B, D), (A, B), (A, C), (D, C), (B, C), (E, D). Tenemos las siguientes distancias cuando todos las aristas son procesadas por primera vez, la primera fila \\nLa primera iteraci\xf3n garantiza darnos todos los caminos m\xe1s cortos los cuales tienen un largo de una arista, obtenemos las distancias siguientes cuando todos las aristas son procesadas por segunda vez.\\nLa segunda iteraci\xf3n garantiza darnos todos los caminos m\xe1s cortos que sean de 2 aristas m\xe1s larga, el algoritmo procesa los caminos 2 veces m\xe1s, las distancias son minimizadas luego de la segunda iteraci\xf3n, y la tercera y cuarta no actualiza distancias...\\n1) Pesos negativos son encontrados en varias aplicaciones de grafos, por ejemplo en vez de pagar el costo por un camino, podemos obtener ventaja si seguimos el camino.\\n2) Bellman-Ford trabaja mejor que Dijkstra para sistemas distribuidos, a diferencia de Dijkstra en donde necesitamos encontrar el valor menor de todos los v\xe9rtices, en Bellman-Ford necesitamos considerar uno por uno.\\n","complejidad_tiempo":"Mejor caso :    O(v2*e)  Peor caso : O(v3)  Promedio: O(v2*e) ","java":"// Implementaci\xf3n java del algoritmo de BellmanFord\\n// para la busqueda del camino m\xe1s corto de un vertice al\\n// resto y con capacidad de detecci\xf3n de ciclo negativo\\n\\nimport java.util.ArrayList;\\nimport java.util.List;\\nimport java.util.Scanner;\\n\\npublic class BellmanFordSP {\\n\\n    static final int MAX = 105;\\n    static final int INF = 1 << 30;\\n    static int[] previo = new int[MAX];\\n    static int[] distancia = new int[MAX];\\n    static int vertices;\\n    static List<List<Node>> adyacencia = new ArrayList<List<Node>>();\\n    static Scanner sc = new Scanner(System.in);\\n\\n    static void inicializacion() {\\n        for (int i = 0; i <= vertices; i++) {\\n            distancia[i] = INF;\\n            previo[i] = -1;\\n        }\\n    }\\n\\n    static class Node {\\n        int first, second;\\n        public Node(int destino, int peso) {\\n            this.first = destino;\\n            this.second = peso;\\n        }\\n    }\\n\\n    static void print(int destino) {\\n        if (previo[destino] != -1) {\\n            print(previo[destino]);\\n        }\\n        System.out.printf(\\"%d \\", destino);\\n    }\\n\\n    static boolean relajacion(int actual, int adyacente, int peso) {\\n        if (distancia[actual] + peso < distancia[adyacente]) {\\n            distancia[adyacente] = distancia[actual] + peso;\\n            previo[adyacente] = actual;\\n            return true;\\n        }\\n        return false;\\n    }\\n\\n    static void bellmanFord(int inicial) {\\n        inicializacion();\\n        distancia[inicial] = 0;\\n        for (int i = 0; i < vertices - 1; i++) {\\n            for (int actual = 0; actual < vertices; actual++) {\\n                for (int j = 0; j < adyacencia.get(actual).size(); j++) {\\n                    int adyacente = adyacencia.get(actual).get(j).first;\\n                    int peso = adyacencia.get(actual).get(j).second;\\n                    relajacion(actual, adyacente, peso);\\n                }\\n            }\\n        }\\n        for (int actual = 0; actual < vertices; actual++) {\\n            for (int j = 0; j < adyacencia.get(actual).size(); j++) {\\n                int adyacente = adyacencia.get(actual).get(j).first;\\n                int peso = adyacencia.get(actual).get(j).second;\\n                if (relajacion(actual, adyacente, peso)) {\\n                    System.out.println(\\"Existe ciclo negativo\\");\\n                    return;\\n                }\\n            }\\n        }\\n        System.out.println(\\"No existe ciclo negativo\\");\\n        System.out.printf(\\"Distancias m\xe1s corteas iniciando en el nodo %d\\\\n\\", inicial);\\n        for (int i = 0; i < vertices; i++) {\\n            System.out.printf(\\"Nodo %d , distancia m\xe1s corta = %d\\\\n\\", i, distancia[i]);\\n        }\\n        System.out.println(\\"\\\\n ________Camino m\xe1s corto____\\");\\n        System.out.println(\\"Ingrese vertice destino: \\");\\n        int destino = sc.nextInt();\\n        print(destino);\\n        System.out.println(\\"\\");\\n    }\\n\\n    public static void main(String[] args) {\\n        int E, origen, destino, peso, inicial;\\n        vertices = sc.nextInt();\\n        E = sc.nextInt();\\n        for (int i = 0; i < 10; i++) {\\n            adyacencia.add(new ArrayList<>());\\n        }\\n        for (int i = 0; i < E; i++) {\\n            origen = sc.nextInt();\\n            destino = sc.nextInt();\\n            peso = sc.nextInt();\\n            adyacencia.get(origen).add(new Node(destino, peso));\\n        }\\n        System.out.printf(\\"Ingrese el nodo inicial: \\");\\n        inicial = sc.nextInt();\\n        bellmanFord(inicial);\\n    }\\n}\\n","cpp":"#include<bits/stdc++.h>\\n#include<cstdlib>\\n//---------------//\\n#define MAX 105\\nusing namespace std;\\nint previo[MAX];\\nint distancia[MAX];\\n\\nvoid init(int vertices) {\\n    for (int i = 0; i <= vertices; i++) {\\n        distancia[i] = INT_MAX;\\n        previo[i] = -1;\\n    }\\n}\\n\\nvoid printPath(int destino) {\\n    if (previo[destino] != -1)printPath(previo[destino]);\\n    printf(\\"%d \\", destino);\\n}\\n\\nbool relajacion(int actual, int adyacente, int peso) {\\n    if (distancia[actual] + peso < distancia[adyacente]) {\\n        distancia[adyacente] = distancia[actual] + peso;\\n        previo[adyacente] = actual;\\n        return true;\\n    }\\n    return false;\\n}\\nvector<vector<pair <int, int> > >ady(MAX);\\n\\nvoid BellmanFord(int inicial, int vertices) {\\n    init(vertices);\\n    distancia[inicial] = 0;\\n    for (int i = 0; i < vertices; i++) {\\n        for (int actual = 0; actual < vertices; actual++) {\\n            for (int j = 0; j < ady[actual].size(); j++) {\\n                int adyacente = ady[actual][j].first;\\n                int peso = ady[actual][j].second;\\n                relajacion(actual, adyacente, peso);\\n            }\\n        }\\n    }\\n    for (int actual = 0; actual < vertices; actual++) {\\n        for (int j = 0; j < ady[actual].size(); j++) {\\n            int adyacente = ady[actual][j].first;\\n            int peso = ady[actual][j].second;\\n            if (relajacion(actual, adyacente, peso)) {\\n                printf(\\"Existe ciclo negativo\\\\n\\");\\n                return;\\n            }\\n        }\\n    }\\n    printf(\\"No existe ciclo negativo\\\\ndistancias mas corta desde el nodo %d\\", inicial);\\n    for (int i = 0; i <= vertices; i++) {\\n        printf(\\"nodo %d distancia mas corta = %d\\\\n\\", i, distancia[i]);\\n    }\\n    printf(\\"camino mas corto hasta un destino\\\\n\\");\\n    int destino;\\n    cin>>destino;\\n    printPath(destino);\\n    cout << endl;\\n}\\n\\nint main() {\\n    int E, origen, destino, peso, inicial, vertices;\\n    cin >> vertices>>E;\\n    for (int i = 0; i < E; i++) {\\n        cin >> origen >> destino>>peso;\\n        ady[origen].push_back(make_pair(destino, peso)); //dirigido\\n        //ady[destino].push_back(make_pair{origen,peso});//NO dirigido\\n    }\\n    printf(\\"Nodo inicial : \\");\\n    cin>>inicial;\\n    BellmanFord(inicial, vertices);\\n}\\n","py":null,"orden":8,"suborden":21,"fecha_creacion":"2020-12-05 00:45:52","fecha_modificacion":"2020-12-06 20:30:56"},{"ID":152,"supergrupo":"Grafos ","tema":"Caminos m\xe1s cortos entre todos los nodos Floyd-Warshall","texto":"El algoritmo de Floyd Warshall se usa para la resoluci\xf3n de todos los caminos m\xe1s cortos de todos los pares, el problema es encontrar las distancias m\xe1s peque\xf1as entre cada par de v\xe9rtices dado un grafo de caminos con pesos.\\nInicializamos la matriz de la soluci\xf3n igual que la matriz de entrada del grafo en el primer paso, luego actualizamos la matriz de soluci\xf3n considerando todos los v\xe9rtices en un v\xe9rtice intermedio, la idea es uno por uno tomar todos los v\xe9rtices y actualizar todos los caminos m\xe1s cortos los cuales incluyen el v\xe9rtice seleccionado como el v\xe9rtice intermedio en el camino m\xe1s corto. Cuando tomamos el v\xe9rtice de n\xfamero k como un v\xe9rtice intermedio ya estamos considerando v\xe9rtices {0,1,2\u2026k-1} como intermedios, para cada par (i,j) del origen al destino respetivamente existen dos posibles casos.\\n1) k no es un v\xe9rtice intermedio en el camino m\xe1s corto de i a j, mantenemos el valor de dist[i][j] como esta.\\n2) K es un v\xe9rtice intermedio en el camino m\xe1s corto de i a j, actualizamos el valor de dist[i][j] como dist[i][k] + dist[k][j] if dist[i][j] > dist[i][k] + dist[k][j]\\nLa complejidad de tiempo es: O(V^3) o O(N^3).\\nEl programa solo imprime las distancias m\xe1s cortas, podemos modificar la soluci\xf3n para imprimir el camino m\xe1s corto ordenando la informaci\xf3n del predecesor en una matriz separada.\\nEl valor de INF puede ser tomado de INT_MAX o Integer.MAX_VALUE, lo que nos permite manejar el los valores m\xe1ximos posibles.\\n","complejidad_tiempo":"Mejor caso :    O(v3  Peor caso : O(v3)  Promedio: O(v3) ","java":"// Programa java que busca todos los caminos m\xe1s cortos\\n// en un grafo\\n\\nimport java.util.ArrayList;\\nimport java.util.Scanner;\\n\\npublic class Main {\\n\\n    static int INF = 9999;\\n    static int V = 0;\\n    //grafo en matriz fija\\n    static int[][] graph;\\n    //matriz que almacena el camino recorrido\\n    static int[][] next;\\n\\n    public static void main(String[] args) {\\n        Scanner sc = new Scanner(System.in);\\n        V = sc.nextInt();\\n        graph = new int[V][V];\\n        next = new int[V][V];\\n        int E = sc.nextInt();\\n        //Inicializa todo en infinito\\n        for (int i = 0; i < V; i++) {\\n            for (int j = 0; j < V; j++) {\\n                graph[i][j] = INF;\\n            }\\n        }\\n        // De un nodo al mismo nodo es 0\\n        for (int i = 0; i < V; i++) {\\n            graph[i][i] = 0;\\n        }\\n        for (int i = 0; i < E; i++) {\\n            graph[sc.nextInt()][sc.nextInt()] = sc.nextInt();\\n        }\\n        floydWarshall(graph);\\n        ArrayList<Integer> path;\\n        System.out.println(\\"El camino mas corto desde 0 a 3: \\");\\n        //Construit camino\\n        path = constructPath(0, 3);\\n        //imprimir camino\\n        printPath(path);\\n    }\\n\\n    static void floydWarshall(int graph[][]) {\\n        int dist[][] = new int[V][V];\\n        int i, j, k;\\n        /*Inicialice la matriz de soluci\xf3n igual que \\n            la matriz del gr\xe1fico de entrada. O podemos \\n            decir que los valores iniciales de las distancias \\n            m\xe1s cortas se basan en las rutas m\xe1s cortas, \\n            considerando que no hay v\xe9rtice intermedio. */\\n        for (i = 0; i < V; i++) {\\n            for (j = 0; j < V; j++) {\\n                dist[i][j] = graph[i][j];\\n                // Si no hay camino entre i y j\\n                if (graph[i][j] == INF) {\\n                    next[i][j] = -1;\\n                } else {\\n                    next[i][j] = j;\\n                }\\n            }\\n        }\\n\\n            /*Agregue todos los v\xe9rtices uno por uno al conjunto \\n            de v\xe9rtices intermedios.\\n            ---\x3e Antes del inicio de una iteraci\xf3n, tenemos \\n            distancias m\xe1s cortas entre todos los pares de v\xe9rtices, \\n            de modo que las distancias m\xe1s cortas consideran solo\\n            los v\xe9rtices en el conjunto {0, 1, 2, .. k-1} como \\n            v\xe9rtices intermedios.\\n            ----\x3e Despu\xe9s del final de una iteraci\xf3n, el v\xe9rtice \\n            n\xfamero k se agrega al conjunto de v\xe9rtices intermedios \\n            y el conjunto se convierte en {0, 1, 2, ... k} */\\n        for (k = 0; k < V; k++) {\\n            //Toma todos los vertices como inicio uno por uno\\n            for (i = 0; i < V; i++) {\\n                /* Toma todos los vertices como destino del\\n                    incio del origen seleccionado*/\\n                for (j = 0; j < V; j++) {\\n                    // Si vertice k esa en el camino m\xe1s corto\\n                    // desde i a j, actualiza el valor de dist[i][j]\\n                    // No podemos viajar por un camino si no existe\\n                    if (dist[i][k] == INF|| dist[k][j] == INF) {\\n                        continue;\\n                    }\\n                    if (dist[i][j] > dist[i][k]+ dist[k][j]) {\\n                        dist[i][j] = dist[i][k]+ dist[k][j];\\n                        next[i][j] = next[i][k];\\n                    }\\n                }\\n            }\\n        }\\n        //Imprime la matriz de distancias cortas\\n        printSolution(dist);\\n    }\\n\\n    static ArrayList<Integer> constructPath(int u, int v) {\\n        // si no hay camino devuelve una lista vacia\\n        if (next[u][v] == -1) {\\n            return new ArrayList<>();\\n        }\\n        // Almacenando el camino en el vector\\n        ArrayList<Integer> path = new ArrayList<>();\\n        path.add(u);\\n        while (u != v) {\\n            u = next[u][v];\\n            path.add(u);\\n        }\\n        return path;\\n    }\\n\\n    static void printPath(ArrayList<Integer> path) {\\n        int n = path.size();\\n        for (int i = 0; i < n - 1; i++) {\\n            System.out.print(path.get(i) + \\" -> \\");\\n        }\\n        System.out.println(path.get(n - 1) + \\" -> \\");\\n    }\\n\\n    static void printSolution(int dist[][]) {\\n        System.out.println(\\"La siguiente matriz muestra las distancias \\"\\n                + \\"m\xe1s cortas entre cada par de vertices\\");\\n        for (int i = 0; i < V; ++i) {\\n            for (int j = 0; j < V; ++j) {\\n                if (dist[i][j] == Main.INF) {\\n                    System.out.print(\\"INF \\");\\n                } else {\\n                    System.out.print(dist[i][j] + \\" \\");\\n                }\\n            }\\n            System.out.println();\\n        }\\n    }\\n}\\n","cpp":"#include<bits/stdc++.h>\\n#include<cstdlib>\\n//--------------//\\n#define INF 9999\\n#define MAX 256\\nusing namespace std;\\nconst int V = 4;\\nint next[V][V];\\n\\nvoid printPath(vector<int> path) {\\n    int n = path.size() - 1;\\n    for (int i = 0; i < n - 1; i++) {\\n        cout << path[i] << \\" -> \\";\\n    }\\n    cout << path[n - 1] << \\" -> \\" << endl;\\n}\\n\\nint constructPath(int u, int v) {\\n    if (next[u][v] == -1) {\\n        return 0;\\n    }\\n    vector<int>path;\\n    path.push_back(u);\\n    while (u != v) {\\n        u = next[u][v];\\n        path.push_back(u);\\n    }\\n    printPath(path);\\n    return 1;\\n}\\n\\nvoid printSolution(int dist[V][V]) {\\n    cout << \\"La siguiente matriz muestra las distancias mas cortas entre cada par de vertices\\\\n\\";\\n    for (int i = 0; i < V; ++i) {\\n        for (int j = 0; j < V; ++j) {\\n            if (dist[i][j] == INF) {\\n                cout << \\"INF \\\\t\\";\\n            } else {\\n                cout << dist[i][j] << \\"\\\\t\\";\\n            }\\n        }\\n        cout << endl;\\n    }\\n}\\n\\nvoid floydWarshall(int graph[V][V]) {\\n    int dist[V][V];\\n    int i, j, k;\\n    for (i = 0; i < V; i++) {\\n        for (j = 0; j < V; j++) {\\n            dist[i][j] = graph[i][j];\\n            if (graph[i][j] == INF) {\\n                next[i][j] = -1;\\n            } else {\\n                next[i][j] = j;\\n            }\\n        }\\n    }\\n    for (k = 0; k < V; k++) {\\n        for (i = 0; i < V; i++) {\\n            for (j = 0; j < V; j++) {\\n                if (dist[i][k] == INF || dist[k][j] == INF) {\\n                    continue;\\n                }\\n                if (dist[i][k] + dist[k][j] < dist[i][j]) {\\n                    dist[i][j] = dist[i][k] + dist[k][j];\\n                    next[i][j] = next[i][k];\\n                }\\n            }\\n        }\\n    }\\n    printSolution(dist);\\n}\\n\\nint main() {\\n    int E, a, b, c;\\n    cin>>E;\\n    int graph[V][V];\\n    for (int i = 0; i < V; i++) {\\n        for (int j = 0; j < V; j++) {\\n            graph[i][j] = INF;\\n        }\\n    }\\n    for (int i = 0; i < V; i++) {\\n        graph[i][i] = 0;\\n    }\\n    for (int i = 0; i < E; i++) {\\n        cin >> a >> b>>c;\\n        graph[a][b] = c;\\n    }\\n    floydWarshall(graph);\\n    constructPath(0, 3);\\n}\\n","py":null,"orden":8,"suborden":22,"fecha_creacion":"2020-12-05 00:45:52","fecha_modificacion":"2020-12-06 20:30:57"},{"ID":153,"supergrupo":"Grafos ","tema":"Caminos m\xe1s cortos en un grafo binario","texto":"Dado un grafo donde cada camino tiene un peso de 0 o 1, un v\xe9rtice inicial tambi\xe9n es dado, encuentre el camino m\xe1s corto desde el origen hasta cualquier otro v\xe9rtice.\\nEn el BFS normal de un grafo, todos los caminos son de igual peso, pero en BFS 0-1 ALGUNOS caminos pueden tener peso 0 y algunos 1, en este no podemos usar un array de booleanos para marcar los nodos visitados pero en cada paso podemos verificar la condici\xf3n de distancia optima, usamos una cola de doble fin para almacenar el nodo, mientras realizamos BFS si un camino es encontrado con peso 0 el nodo es empujado al frente de la doble cola y si el camino tiene peso 1 es empujado atr\xe1s en la doble cola.\\nEsta aproximaci\xf3n es similar a Dijkstra en que si la distancia m\xe1s corta a un nodo es relajada por el nodo anterior entonces solo ser\xe1 empujada en la cola.\\nLa idea de arriba trabaja en todos los casos, cuando sacamos un v\xe9rtice, es el v\xe9rtice de m\xednimo peso de todos los v\xe9rtices restantes, si hay un v\xe9rtice de peso 0 adyacente a el entonces este adyacente tiene la misma distancia, si hay un adyacente de peso 1, entonces este adyacente tiene la m\xe1xima distancia de todos los v\xe9rtices en la cola doble, (Porque todos los otros v\xe9rtices son adyacentes de actual eliminado v\xe9rtice o adyacente de los anteriores eliminados).\\nEste problema puede ser resuelto con Dijkstra pero el tiempo de complejidad seria de O(E + V Log V) donde por BFS puede ser de O(V+E).\\n","complejidad_tiempo":"Mejor caso :    O(v+e)  Peor caso : O(v+e)  Promedio: O(v+e) ","java":"//Programa java que implementa el camino m\xe1s corto\\n// en un grafo binario\\n\\nimport java.util.ArrayDeque;\\nimport java.util.ArrayList;\\nimport java.util.Deque;\\n\\npublic class BinaryGraphShortestPath {\\n    //N\xfamero de vertices\\n    static int V = 9;\\n    // Lista de listas que almacena los caminos\\n    static ArrayList<ArrayList<node>> edges = new ArrayList<ArrayList<node>>();\\n    public static void main(String[] args) {\\n        for (int i = 0; i < V; i++) {\\n            edges.add(new ArrayList<>());\\n        }\\n        addEdge(0, 1, 0);\\n        addEdge(0, 7, 1);\\n        addEdge(1, 7, 1);\\n        addEdge(1, 2, 1);\\n        addEdge(2, 3, 0);\\n        addEdge(2, 5, 0);\\n        addEdge(2, 8, 1);\\n        addEdge(3, 4, 1);\\n        addEdge(3, 5, 1);\\n        addEdge(4, 5, 1);\\n        addEdge(5, 6, 1);\\n        addEdge(6, 7, 1);\\n        addEdge(7, 8, 1);\\n        int src = 0;//Nodo inicial\\n        zeroOneBFS(src);\\n    }\\n\\n    static void zeroOneBFS(int src) {\\n        // Inicializa las distancias desde el nodo inicial\\n        int dist[] = new int[V];\\n        for (int i = 0; i < V; i++) {\\n            dist[i] = Integer.MAX_VALUE;\\n        }\\n        //cola doble para el BFS. \\n        Deque<Integer> Q = new ArrayDeque<>();\\n        dist[src] = 0;\\n        Q.add(src);\\n        while (!Q.isEmpty()) {\\n            int v = Q.getFirst();\\n            Q.removeFirst();\\n            for (int i = 0; i < edges.get(v).size(); i++) {\\n                //Busca la distancia optima\\n                if (dist[edges.get(v).get(i).to] > dist[v] + edges.get(v).get(i).weight) {\\n                    dist[edges.get(v).get(i).to] = dist[v] + edges.get(v).get(i).weight;\\n                    /* pone peso caminos de peso 0 al frente y 1 atras para \\n                    que los vertices puedan ser procesados en orden ascendente\\n                    por sus pesos*/\\n                    if (edges.get(v).get(i).weight == 0) {\\n                        Q.addFirst(edges.get(v).get(i).to);\\n                    } else {\\n                        Q.addLast(edges.get(v).get(i).to);\\n                    }\\n                }\\n            }\\n        }\\n        //imprimiendo los caminos m\xe1s cortos\\n        for (int i = 0; i < V; i++) {\\n            System.out.print(dist[i] + \\" \\");\\n        }\\n        System.out.println(\\"\\");\\n    }\\n    static void addEdge(int u, int v, int wt) {\\n        edges.get(u).add(new node(v, wt));\\n        edges.get(v).add(new node(u, wt));\\n    }\\n    // una estructura que representa los caminos\\n    static class node {\\n        // Dos variables, una denora el nodo\\n        // destino y otra el peso\\n        int to, weight;\\n        public node(int to, int weight) {\\n            this.to = to;\\n            this.weight = weight;\\n        }\\n    }\\n}\\n","cpp":null,"py":null,"orden":8,"suborden":23,"fecha_creacion":"2020-12-05 00:45:52","fecha_modificacion":"2020-12-06 20:30:57"},{"ID":154,"supergrupo":"Grafos ","tema":"Grafo bipartito","texto":"Un grafo bipartito es un grafo cuyos v\xe9rtices pueden ser divididos en dos sets independientes, U y V en donde cada arista (u, v) conecta un v\xe9rtice de U a V o un v\xe9rtice de V a U. En otras palabras para cada arista (u,v) u pertenece a U y v pertenece a V, o viceversa, tambi\xe9n podemos decir que no hay aristas que conecte v\xe9rtices del mismo set.\\nUn grafo bipartito es posible si el coloramiento del grafo es posible usando dos colores los cuales los v\xe9rtices de un set son coloreados del mismo color.\\nUna aproximaci\xf3n para verificar si un grafo es bipartito es verificar si el grafo es coloreable o no usando backtracking.\\nEl siguiente es un algoritmo simple de verificaci\xf3n de bipartito usando  BFS.\\n1) Asigna el color ROJO al v\xe9rtice origen (Poni\xe9ndolo en el set U)\\n2) Colorea todos los vecinos con color AZUL (poni\xe9ndolos en el set V)\\n3) Colorear todos los vecinos del vecino anterior de color ROJO (Poni\xe9ndolos en U)\\n4) De esta forma se asigna color a todos los v\xe9rtices los cuales satisfacen todas las restricciones del coloramiento.\\n5) Mientras asignamos colores, si encontramos un vecino que esta coloreado del mismo color del actual v\xe9rtice entonces el grafo no puede ser coloreado, es decir no es bipartito.\\nEl algoritmo solo funciona si el grafo es fuertemente conectado, en el c\xf3digo siempre empezamos desde el origen 0 y asumimos que los v\xe9rtices son visitados desde el, una observaci\xf3n importante es un  grafo sin aristas es tambi\xe9n bipartito, \\nLa complejidad de tiempo de esta aproximaci\xf3n es la misma del BFS, O(V^2) si el grafo es representado con listas de adyacencia, se convierte en O(V+E).\\n","complejidad_tiempo":"Mejor caso :    O(v+e)  Peor caso : O(v+e)  Promedio: O(v+e) ","java":"//Programa java que encuentra si un grafo es \\n//bipartito o no\\n\\nimport java.util.*;\\n\\npublic class BipartiteGraph {\\n\\n    final static int V = 4;\\n\\n    static boolean isBipartite(int G[][], int src) {\\n        /*Crear una matriz de colores para almacenar los \\n        colores asignados a todas las verificaciones. \\n        El n\xfamero de v\xe9rtice se utiliza como \xedndice en \\n        esta matriz. El valor \'-1\' de colorArr [i] se \\n        usa para indicar que no se asigna ning\xfan color \\n        al v\xe9rtice \'i\'. El valor 1 se utiliza para indicar \\n        que el primer color est\xe1 asignado y el valor 0 \\n        indica que el segundo color est\xe1 asignado.*/\\n        int colorArr[] = new int[V];\\n        for (int i = 0; i < V; ++i) {\\n            colorArr[i] = -1;\\n        }\\n        //Asigna primer color al origen\\n        colorArr[src] = 1;\\n        //Crea una cola de n\xfamero de vertices\\n        // y encola el vertice origen \\n        LinkedList<Integer> q = new LinkedList<>();\\n        q.add(src);\\n        while (!q.isEmpty()) {\\n            // Descola un vertice de la cola\\n            int u = q.poll();\\n            //Retorna falso si hay un autociclo\\n            if (G[u][u] == 1) {\\n                return false;\\n            }\\n            //Encuentra todos los vertoces adyacentes sin color \\n            for (int v = 0; v < V; ++v) {\\n                // Un camino de u a v existe\\n                // y destino v no esta coloreado\\n                if (G[u][v] == 1 && colorArr[v] == -1) {\\n                    //Asigna color alternativo para esta adyacencia\\n                    colorArr[v] = 1 - colorArr[u];\\n                    q.add(v);\\n                } /*Un camino de u a v existe y el destino \\n                esta del mismo color que u*/ \\n                else if (G[u][v] == 1 && colorArr[v] == colorArr[u]) {\\n                    return false;\\n                }\\n            }\\n        }\\n        // Si llegamos aqui, todos los vertoces adyacentes pueden\\n        // ser coloreados con color alternativo\\n        return true;\\n    }\\n\\n    public static void main(String[] args) {\\n        int G[][] = {{0, 1, 0, 1},\\n        {1, 0, 1, 0},\\n        {0, 1, 0, 1},\\n        {1, 0, 1, 0}\\n        };\\n        if (isBipartite(G, 0)) {\\n            System.out.println(\\"Si\\");\\n        } else {\\n            System.out.println(\\"No\\");\\n        }\\n    }\\n}\\n","cpp":"#include<bits/stdc++.h>\\n#include<cstdlib>\\nusing namespace std;\\nconst int V = 4;\\n\\nbool isBipartite(int G[V][V], int src) {\\n    int colorArr[V];\\n    memset(colorArr, -1, sizeof colorArr);\\n    colorArr[src] = 1;\\n    vector<int>q;\\n    q.push_back(src);\\n    while (!q.empty()) {\\n        int u = q.front();\\n        q.erase(q.begin());\\n        if (G[u][u] == 1) {\\n            return false;\\n        }\\n        for (int v = 0; v < V; v++) {\\n            if (G[u][v] == 1 && colorArr[v] == 1) {\\n                colorArr[v] = 1 - colorArr[u];\\n                q.push_back(v);\\n            } else if (G[u][v] == 1 && colorArr[v] == colorArr[u]) {\\n                return false;\\n            }\\n        }\\n    }\\n    return true;\\n}\\n\\nint main() {\\n    int G[V][V] = {\\n        {0, 1, 0, 1},\\n        {1, 0, 1, 0},\\n        {0, 1, 0, 1},\\n        {1, 0, 1, 0}};\\n    if (isBipartite(G, 0)) {\\n        cout << \\"Es bipartito\\" << endl;\\n    } else {\\n        cout << \\"NO Es bipartito\\" << endl;\\n    }\\n}\\n","py":"V = 4\\n\\ndef isBipartite(G, src):\\n    global V\\n    colorarr = [-1 for x in range(V)]\\n    colorarr[src] = 1\\n    q = []\\n    q.append(src)\\n    while not len(q) == 0:\\n        u = q.pop()\\n        if G[u][u] == 1:\\n            return False\\n    for v in range(V):\\n        if G[u][v] == 1 and colorarr[v] == -1:\\n            colorarr[v] = 1 - colorarr[u]\\n            q.append(v)\\n        elif G[u][v] and colorarr[v] == colorarr[u]:\\n            return False\\n    return True\\n\\nG = [[0, 1, 0, 1], [1, 0, 1, 0], [0, 1, 0, 1], [1, 0, 1, 0]]\\nif isBipartite(G, 0):\\n    print(\\"Es bipartitio\\")\\nelse:\\n    print(\\"No es bipartitio\\")\\n\\n","orden":8,"suborden":24,"fecha_creacion":"2020-12-05 00:45:53","fecha_modificacion":"2020-12-06 20:30:58"},{"ID":155,"supergrupo":"Grafos ","tema":"Union Find","texto":"Una estructura de datos para conjuntos disjuntos, es una estructura de datos que mantiene un conjunto de elementos particionados en un n\xfamero de conjuntos disjuntos no se solapan los conjuntos). Un algoritmo Uni\xf3n-Buscar es un algoritmo que realiza dos importantes operaciones en esta estructura de datos:\\nBuscar: Determina a cual subconjunto pertenece un elemento. Esta operaci\xf3n puede usarse para verificar si dos elementos est\xe1n en el mismo conjunto.\\nUnion: Une dos subconjuntos en uno solo.\\nLa otra operaci\xf3n importante CrearConjunto es generalmente trivial, esta crea un conjunto con un elemento dado. Con estas tres operaciones, muchos problemas pr\xe1cticos de particionamiento pueden ser resueltos.\\nCon el fin de definir estas operaciones m\xe1s precisamente, es necesario representar los conjuntos de alguna manera. Una aproximaci\xf3n com\xfan es seleccionar un elemento fijo de cada conjunto, llamado el representativo, para representar el conjunto como un todo. Entonces Buscar(x) retorna el elemento representativo del conjunto al cual x pertenece, y Uni\xf3n toma como argumento dos elementos representativos de dos conjuntos respectivamente.\\n","complejidad_tiempo":"Mejor caso :    O(v+e)  Peor caso : O(v+e)  Promedio: O(v+e) ","java":"//Programa java que usa el algoritmo UNION FIND \\n// para verificar componentes conexas\\n/*\\nINPUT\\n9 7\\n2 0\\n7 0\\n3 1\\n1 0\\n6 4\\n8 5\\n4 5\\n */\\nimport java.util.*;\\n\\npublic class UnionFind {\\n\\n    static final int MAX = 10005; //maximo n\xfamero de v\xe9rtices\\n    static int padre[] = new int[MAX]; //Este arreglo contiene el padre del i-esimo nodo\\n    static int rango[] = new int[MAX]; //profundidad de cada v\xe9rtice\\n\\n    //M\xe9todo de inicializaci\xf3n\\n    static void MakeSet(int n) {\\n        for (int i = 0; i < n; ++i) {\\n            padre[i] = i; //Inicialmente el padre de cada v\xe9rtice es el mismo v\xe9rtice\\n            rango[i] = 0; //Altura o rango de cada v\xe9rtice es 0\\n        }\\n    }   \\n    //M\xe9todo para encontrar la raiz del v\xe9rtice actual X\\n    static int Find(int x) {\\n        if (x == padre[x]) { //Si estoy en la raiz\\n            return x; //Retorno la raiz\\n        } //else return Find( padre[ x ] ); //De otro modo busco el padre del v\xe9rtice actual, hasta llegar a la raiz.\\n        else {\\n            return padre[x] = Find(padre[x]); //Compresion de caminos\\n        }\\n    }\\n    //M\xe9todo para unir 2 componentes conexas\\n    static void Union(int x, int y) {\\n        int xRoot = Find(x); //Obtengo la raiz de la componente del v\xe9rtice X\\n        int yRoot = Find(y); //Obtengo la raiz de la componente del v\xe9rtice Y\\n        padre[xRoot] = yRoot; //Mezclo ambos arboles o conjuntos, actualizando su padre de alguno de ellos como la raiz de otro\\n    }\\n\\n    //M\xe9todo para unir 2 componentes conexas usando sus alturas (rangos)\\n    static void UnionbyRank(int x, int y) {\\n        int xRoot = Find(x); //Obtengo la raiz de la componente del v\xe9rtice X\\n        int yRoot = Find(y); //Obtengo la raiz de la componente del v\xe9rtice Y\\n        if (rango[xRoot] > rango[yRoot]) { //en este caso la altura de la componente del v\xe9rtice X es\\n            //mayor que la altura de la componente del v\xe9rtice Y.\\n            padre[yRoot] = xRoot; //el padre de ambas componentes ser\xe1 el de mayor altura\\n        } else { //en este caso la altura de la componente del v\xe9rtice Y es mayor o igual que la de X\\n            padre[xRoot] = yRoot; //el padre de ambas componentes ser\xe1 el de mayor altura\\n            if (rango[xRoot] == rango[yRoot]) { //si poseen la misma altura\\n                rango[yRoot]++; //incremento el rango de la nueva ra\xedz\\n            }\\n        }\\n    }\\n\\n    static int root[] = new int[MAX]; //tendra las raices de las componentes conexas luego de aplicar el m\xe9todo\\n    static int numComponentes; //variable para el n\xfamero total de componentes conexas\\n    //M\xe9todo para obtener el n\xfamero de componentes conexas luego de realizar las conexiones respectivas\\n\\n    static int getNumberConnectedComponents(int n) {\\n        numComponentes = 0;\\n        for (int i = 0; i < n; ++i) {\\n            if (padre[i] == i) { //Si el padre del v\xe9rtice i es el mismo v\xe9rtice entonces es ra\xedz\\n                //if( Find( i ) == i ){ //podemos usamos find para el mismo proposito y\\n                //para que se realice compresion de caminos\\n                root[numComponentes++] = i; //almaceno la raiz de cada nueva componente\\n                // numComponentes++;\\n            }\\n        }\\n        return numComponentes;\\n    }\\n\\n    static int numVertices[] = new int[MAX]; //almacenara la cantidad de v\xe9rtices para la i-esima raiz.\\n    //M\xe9todo para obtener la raiz y el n\xfamero de v\xe9rtices de cada componente conexa\\n    //ser\xe1 necesario primero tener la cantidad de componentes conexas\\n    //podemos llamar 1ero al metodo getNumberConnectedComponents o incluir porcion de su codigo en este\\n\\n    static void getNumberNodes(int n) {\\n        Arrays.fill(numVertices, 0); //inicializo mi contador de v\xe9rtices\\n        for (int i = 0; i < n; ++i) {\\n            numVertices[Find(i)]++; //incremento la ra\xedz del v\xe9rtice i\\n        }\\n        for (int i = 0; i < numComponentes; ++i) {\\n            System.out.printf(\\"Componente %d: Raiz = %d , Nro nodos = %d.\\\\n\\", i + 1, root[i], numVertices[root[i]]);\\n        }\\n    }\\n\\n    //M\xe9todo que me determina si 2 v\xe9rtices estan o no en la misma componente conexa\\n    static boolean sameComponent(int x, int y) {\\n        if (Find(x) == Find(y)) {\\n            return true; //si poseen la misma ra\xedz\\n        }\\n        return false;\\n    }\\n\\n    public static void main(String[] args) {\\n        int V, E, origen, destino;\\n        Scanner sc = new Scanner(System.in);\\n        V = sc.nextInt();\\n        E = sc.nextInt(); //tengamos n\xfamero de vertices y aristas\\n        MakeSet(V); //inicializamos los conjuntos\\n        for (int i = 0; i < E; ++i) {\\n            origen = sc.nextInt();\\n            destino = sc.nextInt();\\n            UnionbyRank(origen, destino); //union de elementos\\n        }\\n        System.out.printf(\\"El n\xfamero de componentes conexas es: %d\\\\n\\", getNumberConnectedComponents(V));\\n        getNumberNodes(V);\\n\\n    }\\n\\n}\\n","cpp":null,"py":null,"orden":8,"suborden":25,"fecha_creacion":"2020-12-05 00:45:53","fecha_modificacion":"2020-12-06 20:30:59"},{"ID":156,"supergrupo":"Grafos ","tema":"\xc1rbol de expansi\xf3n m\xednima de Kruskal","texto":"Dado un grafo conexo y no dirigido, un \xe1rbol de expansi\xf3n del grafo es el subgrafo que es el \xe1rbol que conecta todos los v\xe9rtices juntos, un solo grafo puede tener muchos \xe1rboles de expansi\xf3n diferentes, un \xe1rbol de expansi\xf3n m\xednima (MST) o \xe1rbol de expansi\xf3n de peso m\xednimo para un grafo ponderado, conexo y no dirigido es el \xe1rbol de expansi\xf3n con el peso menor o igual a cualquier otro \xe1rbol de expansi\xf3n. El peso de un \xe1rbol de expansi\xf3n es la suma de los pesos dados en cada camino del \xe1rbol de expansi\xf3n.\\n\xbfCuantos caminos tiene un \xe1rbol de expansi\xf3n m\xednima?\\nUn MST tiene (V-1) caminos donde V es el n\xfamero de v\xe9rtices en el grafo dado.\\nLos siguientes son los pasos para encontrar el MST con el algoritmo de Kruskal.\\n1) ordene todos los caminos en orden incremental dado su peso.\\n2) Tome el camino m\xe1s peque\xf1o, verifique si forma un ciclo con el \xe1rbol formado hasta ahora, si el ciclo no es formado, incluya este camino, si no desc\xe1rtelo\\n3) Repita el paso 2 hasta que haya (V-1) caminos en el \xe1rbol de expansi\xf3n.\\nEl paso 2 usa el algoritmo Union-Find para detectar ciclos.\\nEl algoritmo es un algoritmo voraz, la voracidad escogida es tomar el camino de tama\xf1o m\xe1s peque\xf1o lo que no causa un ciclo en el MST construido hasta ese punto\\nLa complejidad de tiempo de este algoritmo es de O(ElogE) or O(ElogV). Ordenar los caminos toma O(ELogE) tiempo, luego de ordenar iteramos a trav\xe9s de todos los caminos y aplicamos el algoritmo Union-Find, Las operaciones de unir y encontrar puede tomar al menos O(LogV) tiempo, entonces la complejidad completa es O(ELogE + ELogV) tiempo. El valor de W puede ser al menos O (V^2) entonces O (LogV) son O (LogE) iguales. \\n","complejidad_tiempo":"Mejor caso :    O(eLog(e)+ eLog(v))  Peor caso : O(eLog(e)+ eLog(v)) \\nPromedio: O(eLog(e)+ eLog(v)) \\n","java":"//Implementaci\xf3n java de busqueda del \\n// arbol de expansi\xf3n minima usando el algoritmo de Kruskal\\n/*\\n EJEMPLO DE INPUT\\n 9 14\\n 1 2 4\\n 1 8 9\\n 2 3 9\\n 2 8 11\\n 3 4 7\\n 3 9 2\\n 3 6 4\\n 4 5 10\\n 4 6 15\\n 5 6 11\\n 6 7 2\\n 7 8 1\\n 7 9 6\\n 8 9 7\\n\\n EJEMPLO VERIFICACION DE MST\\n9 11\\n 1 2 4\\n 1 8 9\\n 2 3 9\\n 2 8 11\\n 3 9 2\\n 7 8 1\\n 7 9 6\\n 8 9 7\\n 4 5 10\\n 4 6 15\\n 5 6 11\\n */\\nimport java.util.Arrays;\\nimport java.util.Comparator;\\nimport java.util.Scanner;\\n\\npublic class KruskalMST {\\n\\n    static final int MAX = 1005; //maximo n\xfamero de v\xe9rtices\\n    //UNION-FIND\\n    static int padre[] = new int[MAX]; //Este arreglo contiene el padre del i-esimo nodo\\n    //M\xe9todo de inicializaci\xf3n\\n    static void MakeSet(int n) {\\n        for (int i = 1; i <= n; ++i) {\\n            padre[i] = i;\\n        }\\n    }\\n    //M\xe9todo para encontrar la raiz del v\xe9rtice actual X\\n    static int Find(int x) {\\n        return (x == padre[x]) ? x : (padre[x] = Find(padre[x]));\\n    }\\n    //M\xe9todo para unir 2 componentes conexas\\n    static void Union(int x, int y) {\\n        padre[Find(x)] = Find(y);\\n    }\\n    //M\xe9todo que me determina si 2 v\xe9rtices estan o no en la misma componente conexa\\n    static boolean sameComponent(int x, int y) {\\n        if (Find(x) == Find(y)) {\\n            return true;\\n        }\\n        return false;\\n    }\\n    ///FIN UNION-FIND\\n    static int V, E; //n\xfamero de vertices y aristas\\n    //Estructura arista( edge )\\n\\n    static class Edge implements Comparator<Edge> {\\n        int origen; //V\xe9rtice origen\\n        int destino; //V\xe9rtice destino\\n        int peso; //Peso entre el v\xe9rtice origen y destino\\n        Edge() {\\n        }\\n        //Comparador por peso, me servira al momento de ordenar lo realizara en orden ascendente\\n        //Ordenar de forma descendente para obtener el arbol de expansion maxima\\n        @Override\\n        public int compare(Edge e1, Edge e2) {\\n            //return e2.peso - e1.peso; //Arbol de expansion maxima\\n            return e1.peso - e2.peso; //Arbol de expansion minima\\n        }\\n    };\\n\\n    static Edge arista[] = new Edge[MAX]; //Arreglo de aristas para el uso en kruskal\\n    static Edge MST[] = new Edge[MAX]; //Arreglo de aristas del MST encontrado\\n    static void KruskalMST() {\\n        int origen, destino, peso;\\n        int total = 0; //Peso total del MST\\n        int numAristas = 0; //N\xfamero de Aristas del MST\\n        MakeSet(V); //Inicializamos cada componente\\n        Arrays.sort(arista, 0, E, new Edge()); //Ordenamos las aristas por su comparador\\n        for (int i = 0; i < E; ++i) {\\n            origen = arista[i].origen; //V\xe9rtice origen de la arista actual\\n            destino = arista[i].destino; //V\xe9rtice destino de la arista actual\\n            peso = arista[i].peso; //Peso de la arista actual\\n            //Verificamos si estan o no en la misma componente conexa\\n            if (!sameComponent(origen, destino)) { //Evito ciclos\\n                total += peso; //Incremento el peso total del MST\\n                MST[numAristas++] = arista[i]; //Agrego al MST la arista actual\\n                Union(origen, destino); //Union de ambas componentes en una sola\\n            }\\n        }\\n\\n        //Si el MST encontrado no posee todos los v\xe9rtices mostramos mensaje de error\\n        //Para saber si contiene o no todos los v\xe9rtices basta con que el n\xfamero\\n        //de aristas sea igual al n\xfamero de vertices - 1\\n        if (V - 1 != numAristas) {\\n            System.out.println(\\"No existe MST valido para el grafo ingresado, el grafo debe ser conexo.\\");\\n            return;\\n        }\\n        System.out.println(\\"-----El MST encontrado contiene las siguientes aristas-----\\");\\n        for (int i = 0; i < numAristas; ++i) {\\n            System.out.printf(\\"( %d , %d ) : %d\\\\n\\", MST[i].origen, MST[i].destino, MST[i].peso);\\n        }\\n        System.out.printf(\\"El costo minimo de todas las aristas del MST es : %d\\\\n\\", total);\\n    }\\n\\n    //( vertice u , vertice v ) : peso\\n    public static void main(String[] args) {\\n        Scanner sc = new Scanner(System.in); //para lectura de datos\\n        V = sc.nextInt();\\n        E = sc.nextInt();\\n        //Realizamos el ingreso del grafo, almacenando las aristas en un arreglo con los datos respectivos\\n        for (int i = 0; i < E; ++i) {\\n            arista[i] = new Edge();\\n            arista[i].origen = sc.nextInt();\\n            arista[i].destino = sc.nextInt();\\n            arista[i].peso = sc.nextInt();\\n            //arista[ i ] = new Arista( sc.nextInt() , );\\n        }\\n        KruskalMST();\\n    }\\n}\\n","cpp":"#include <bits/stdc++.h>\\n#define MAX 1005\\nusing namespace std;\\nint padre[MAX];\\n\\nstruct Edge {\\n    int origen, destino, peso;\\n\\n    bool operator<(const Edge &t) {\\n        return peso < t.peso;\\n    }\\n};\\n//set de nodos para indicar cuales son sus padre e hijos\\n\\nvoid makeSet(int n) {\\n    for (int i = 0; i <= n; i++) {\\n        padre[i] = i;\\n    }\\n}\\n\\nint find(int x) {\\n    return (x == padre[x] ? x : (padre[x] = find(padre[x])));\\n}\\n\\nvoid Union(int x, int y) {\\n    padre[find(x)] = find(y);\\n}\\n\\nbool sameComponent(int x, int y) {\\n    if (find(x) == find(y)) {\\n        return true;\\n    }\\n    return false;\\n}\\nEdge aristas[MAX];\\nEdge MST[MAX];\\nvector<Edge>vec;\\n\\nvoid KruskalMST(int V, int E) {\\n    int origen, destino, peso;\\n    int total = 0;\\n    int numAristas = 0;\\n    makeSet(V);\\n    sort(vec.begin(), vec.end());\\n    for (int i = 0; i < E; i++) {\\n        origen = vec[i].origen;\\n        destino = vec[i].destino;\\n        peso = vec[i].peso;\\n        if (!sameComponent(origen, destino)) {\\n            total += peso;\\n            MST[numAristas++] = vec[i];\\n            Union(origen, destino);\\n        }\\n    }\\n    if (V - 1 != numAristas) {\\n        cout << \\"No existe MST valido para el grafo ingresado este debe ser conexo\\" << endl;\\n        return;\\n    }\\n    cout << \\"MST encontrado contiene las siguientes aristas\\" << endl;\\n    for (int i = 0; i < numAristas; i++) {\\n        cout << MST[i].origen << \\",\\" << MST[i].destino << \\":\\" << MST[i].peso << endl;\\n    }\\n    cout << \\"el costo minimo de todas las aristas de MST es : \\" << total << endl;\\n}\\n\\nint main() {\\n    int V, E;\\n    cin >> V>>E;\\n    for (int i = 0; i < E; i++) {\\n        Edge aristas[i];\\n        cin >> aristas[i].origen;\\n        cin >> aristas[i].destino;\\n        cin >> aristas[i].peso;\\n        vec.push_back(aristas[i]);\\n    }\\n    KruskalMST(V, E);\\n}\\n","py":null,"orden":8,"suborden":26,"fecha_creacion":"2020-12-05 00:45:53","fecha_modificacion":"2020-12-06 20:30:59"},{"ID":157,"supergrupo":"Grafos ","tema":"\xc1rbol de expansi\xf3n m\xednima de Prim","texto":"El algoritmo de Prim es tambi\xe9n un algoritmo voraz, comienza con un \xe1rbol de expansi\xf3n vac\xedo, la idea es mantener dos conjuntos de v\xe9rtices, el primero contiene los v\xe9rtices ya incluidos en el MST, la otra contiene los v\xe9rtices que no han sido incluidos aun, en cada paso, se considera todos los caminos que conectan dos sets, y toma el camino con m\xednimo peso de esos caminos, luego de tomar el camino, se mueve el otro punto final del camino al set conteniendo el MST.\\nUn grupo de caminos que conectan dos sets de v\xe9rtices en un grafo es llamado corte en la teor\xeda de grafos, entonces en cada paso del algoritmo de Prim, nosotros buscamos un corte (de dos conjuntos, uno contiene los v\xe9rtices ya en el MST y el otro el resto de v\xe9rtices), tome el camino de m\xednimo peso del corte e incluye este v\xe9rtice al conjunto MST. \\n\\nLa idea detr\xe1s del algoritmo de Prim es simple, un \xe1rbol de expansi\xf3n significa que todos los v\xe9rtices deben estar conectados, entonces los dos conjuntos disjuntos de v\xe9rtices deben estar conectados para hacer un \xe1rbol de expansi\xf3n. Y ellos deben estar conectados con el camino de peso m\xednimo para realizar un \xe1rbol de expansi\xf3n m\xednima.\\n1) Crear un set mstSet que mantenga rastro de los v\xe9rtices ya incluidos en el MST.\\n2) Asignar un valor key a todos los v\xe9rtices en el grafo de entrada, inicializar los valores key como INFINITO, asignar el valor key como 0 para el primer v\xe9rtice entonces este es tomado primero.\\n3) Mientras mstSet no incluya todos los v\xe9rtices.\\na) Tomar un v\xe9rtice u el cual no est\xe9 en el mstSet y tenga el valor key m\xednimo\\nb) Incluir u al mstSet\\nc) Actualizar el valor key de todos los v\xe9rtices adyacentes de u, para actualizar los valores key, se itera a trav\xe9s de todos los v\xe9rtices adyacentes v, si el peso del camino u-v es menos que el valor key anterior de v, actualice el valor key como peso de u-v.\\nLa idea de usar valores key es tomar el camino de m\xednimo peso como el corte, los valores key son usados \xfanicamente por los v\xe9rtices que no han sido incluidos en el MST, el valor key de estos v\xe9rtices indican los caminos de peso m\xednimo conect\xe1ndolos con el set de v\xe9rtices incluidos en el MST.\\nPor ejemplo:\\n\\n- El set mstSet esta inicialmente vac\xedo y los keys asignados a los v\xe9rtices son {0, INF, INF, INF, INF, INF, INF, INF} donde INF indica infinito, ahora tomamos el v\xe9rtices con el valor key menor el v\xe9rtice 0 es tomado, se incluye en el mstSetm entonces mstSet se convierte en {0}, luego de incluir al mstSet, se actualizan los valores key de los v\xe9rtices adyacentes, los v\xe9rtices adyacentes  de 0 son 1 y 7, los valores key de 1 y 7 son actualizados como 4 y 8.\\n- Se toma el v\xe9rtice con el menor valor key y no incluido ya en el MST, (no en mstSet), el v\xe9rtice 1 es tomado y a\xf1adido al mstSet por lo que se convierte en {0,1}, se actualiza los valores key de los v\xe9rtices adyacentes de 1, el valor key del v\xe9rtice 2 se convierte en 8.\\n- Se toma el v\xe9rtice con el valor key m\xednimo y no incluido en MST, podemos tomar el v\xe9rtice 7 o 2, tomaremos el 7, entonces el mstSet es {0,1,7}, actualizamos los valores key de los v\xe9rtices adyacentes de 7, el valor key del v\xe9rtice 6 y 8 se convierten en finitos, en 1 y 7.\\n- Tome el v\xe9rtice con el valor key m\xednimo, y no incluido ya en MST, el v\xe9rtice 6 es tomado entonces el mstSet se convierte en {0,1,7,6}, se actualizan los valores key y los v\xe9rtices adyacentes de 6m el valor de 5 y 8 es actualizado.\\n- Repetimos los pasos de arriba hasta que mstSet incluya todos los v\xe9rtices del grafo dado.\\n","complejidad_tiempo":"Mejor caso :    O(v3) Peor caso : O(v3) Promedio: O(v3) ","java":"//Programa java que calcula el MST de un grafo\\n\\nimport java.util.LinkedList;\\nimport java.util.PriorityQueue;\\nimport java.util.Comparator;\\n\\npublic class PrimMSTFULL {\\n\\n    public static void main(String[] args) {\\n        int V = 9;\\n        Graph graph = new Graph(V);\\n        addEdge(graph, 0, 1, 4);\\n        addEdge(graph, 0, 7, 8);\\n        addEdge(graph, 1, 2, 8);\\n        addEdge(graph, 1, 7, 11);\\n        addEdge(graph, 2, 3, 7);\\n        addEdge(graph, 2, 8, 2);\\n        addEdge(graph, 2, 5, 4);\\n        addEdge(graph, 3, 4, 9);\\n        addEdge(graph, 3, 5, 14);\\n        addEdge(graph, 4, 5, 10);\\n        addEdge(graph, 5, 6, 2);\\n        addEdge(graph, 6, 7, 1);\\n        addEdge(graph, 6, 8, 6);\\n        addEdge(graph, 7, 8, 7);\\n        prims_mst(graph);\\n    }\\n\\n    static class node1 {\\n        int dest;\\n        int weight;\\n        node1(int a, int b) {\\n            dest = a;\\n            weight = b;\\n        }\\n    }\\n\\n    static class Graph {\\n        int V;\\n        LinkedList<node1>[] adj;\\n        Graph(int e) {\\n            V = e;\\n            adj = new LinkedList[V];\\n            for (int o = 0; o < V; o++) {\\n                adj[o] = new LinkedList<>();\\n            }\\n        }\\n    }\\n\\n    static class node {\\n        int vertex;\\n        int key;\\n    }\\n\\n    /* Comparador de la priorityQueue\\n     retorna 1 si node0.key > node1.key \\n     retorna 0 si node0.key < node1.key y\\n    retorna -1 otherwise */\\n    static class comparator implements Comparator<node> {\\n\\n        @Override\\n        public int compare(node node0, node node1) {\\n            return node0.key - node1.key;\\n        }\\n    }\\n    static void addEdge(Graph graph, int src, int dest, int weight) {\\n        node1 node0 = new node1(dest, weight);\\n        node1 node = new node1(src, weight);\\n        graph.adj[src].addLast(node0);\\n        graph.adj[dest].addLast(node);\\n    }\\n\\n    // Buscar MST\\n    static void prims_mst(Graph graph) {\\n        Boolean[] mstset = new Boolean[graph.V];\\n        node[] e = new node[graph.V];\\n        int[] parent = new int[graph.V];\\n        for (int o = 0; o < graph.V; o++) {\\n            e[o] = new node();\\n        }\\n        for (int o = 0; o < graph.V; o++) {\\n            //inicializar en falso\\n            mstset[o] = false;\\n            // Inicial valores key en infinito\\n            e[o].key = Integer.MAX_VALUE;\\n            e[o].vertex = o;\\n            parent[o] = -1;\\n        }\\n        // incluir el vertice inicial en el MST\\n        mstset[0] = true;\\n        e[0].key = 0;\\n        PriorityQueue<node> queue = new PriorityQueue<>(graph.V, new comparator());\\n        for (int o = 0; o < graph.V; o++) {\\n            queue.add(e[o]);\\n        }\\n        while (!queue.isEmpty()) {\\n            node node0 = queue.poll();\\n            mstset[node0.vertex] = true;\\n            for (node1 iterator : graph.adj[node0.vertex]) {\\n                if (mstset[iterator.dest] == false) {\\n                    if (e[iterator.dest].key > iterator.weight) {\\n                        queue.remove(e[iterator.dest]);\\n                        e[iterator.dest].key = iterator.weight;\\n                        queue.add(e[iterator.dest]);\\n                        parent[iterator.dest] = node0.vertex;\\n                    }\\n                }\\n            }\\n        }\\n        // Imprimir el par de vertices del mst \\n        for (int o = 1; o < graph.V; o++) {\\n            System.out.println(parent[o] + \\" \\"\\n                    + \\"-\\"\\n                    + \\" \\" + o);\\n        }\\n    }\\n}\\n\\n//Version 2:\\n//Programa java que busca el arbol de expansi\xf3n \\n// minima de minimo costo\\n\\nimport java.util.ArrayList;\\nimport java.util.List;\\nimport java.util.PriorityQueue;\\nimport java.util.Scanner;\\n\\npublic class PrimMSTMinValue {\\n\\n    public static void main(String[] args) {\\n        Scanner sc = new Scanner(System.in);\\n        N = sc.nextInt();\\n        G = new Vertex[N];\\n        for (int i = 0; i < G.length; i++) {\\n            G[i] = new Vertex();\\n        }\\n        E = sc.nextInt();\\n        for (int i = 0; i < E; i++) {\\n            int from, to, w;\\n            from = sc.nextInt();\\n            to = sc.nextInt();\\n            w = sc.nextInt();\\n            G[from].adj.add(new Edge(to, w));\\n            G[to].adj.add(new Edge(from, w));\\n        }\\n        System.out.println(prim());\\n\\n    }\\n\\n    static PriorityQueue<QueueItem> Q;\\n    static int E;\\n    static boolean[] intree;\\n    static int N;\\n    static Vertex[] G;\\n    \\n    static class QueueItem implements Comparable<QueueItem> {\\n        int v, w;\\n        public QueueItem(int v, int w) {\\n            this.v = v;\\n            this.w = w;\\n        }\\n        @Override\\n        public int compareTo(QueueItem q) {\\n            if (this.w != q.w) {\\n                return this.w - q.w;\\n            }\\n            return this.v - q.v;\\n        }\\n    }\\n\\n    static void process(int u) {\\n        intree[u] = true;\\n        G[u].adj.forEach((e) -> {\\n            int v = e.to, w = e.w;\\n            if (!intree[v]) {\\n                Q.offer(new QueueItem(v, w));\\n            }\\n        });\\n    }\\n\\n    static int prim() {\\n        intree = new boolean[N];\\n        Q = new PriorityQueue<>();\\n        int cost = 0;\\n        process(0);\\n        while (!Q.isEmpty()) {\\n            QueueItem qi = Q.poll();\\n            int v = qi.v, w = qi.w;\\n            if (!intree[v]) {\\n                cost += w;\\n                process(v);\\n            }\\n        }\\n        return cost;\\n    }\\n\\n    static class Vertex {\\n        List<Edge> adj;\\n        public Vertex() {\\n            adj = new ArrayList<>();\\n        }\\n    }\\n\\n    static class Edge {\\n        int to, w;\\n        public Edge(int to, int w) {\\n            this.to = to;\\n            this.w = w;\\n        }\\n    }\\n}\\n","cpp":null,"py":null,"orden":8,"suborden":27,"fecha_creacion":"2020-12-05 00:45:54","fecha_modificacion":"2020-12-06 20:31:00"},{"ID":158,"supergrupo":"DP","tema":"Knapsack 0/1","texto":"Dados pesos y valores de n \xedtems, ponga esos \xedtems en una mochila de capacidad W, para obtener el m\xe1ximo valor total en la mochila, en otras palabras dados dos arrays de enteros val[0..n-1] y wt[0\u2026-1] los cuales representan los valores y pesos asociados a los n \xedtems respectivamente. Tambi\xe9n dado un entero W el cual representa la capacidad de la mochila, encuentre el m\xe1ximo valor subset de val[] tal que esa suma de los pesos de este subset es menor o igual a w, no se puede romper un \xedtem, se tiene que tomar o no tomar, (propiedad 0-1).\\nUna simple soluci\xf3n es considerar todos los subsets de \xedtems y calcular el peso total y valor de todos los subsets, considere solo los subsets los cuales el peso total es menor a W, de todos los subsets tome el que tenga el m\xe1ximo valor de peso.\\nConsidere todos los subsets de \xedtems, puede haber dos casos para cada \xedtem:\\n1) El \xedtem est\xe1 incluido en el subset optimo\\n2) El \xedtem no est\xe1 incluido en el subset optimo\\nCon esto, el m\xe1ximo valor puede ser obtenido de n \xedtems es m\xe1ximo siguiendo los dos siguientes valores,\\n1) El m\xe1ximo valor obtenido por n-1 \xedtems y peso W (Excluyendo el en\xe9simo \xedtem)\\n2) Valor del en\xe9simo \xedtem m\xe1s el m\xe1ximo valor obtenido por n-1 \xedtems y W menos el peso del en\xe9simo \xedtem (Incluyendo el en\xe9simo \xedtem).\\nSI el peso del en\xe9simo \xedtem es mayor que W, entonces el en\xe9simo \xedtem no puede ser incluido y el caso 1 es la \xfanica posibilidad.\\nDesde que los subproblemas son evaluados de nuevo, este problema tiene la propiedad de sobreponer subproblemas. Entonces el problema de  la mochila 0-1 tiene ambas propiedades de un problema de programaci\xf3n din\xe1mica, como otros problemas de programaci\xf3n din\xe1mica, recomputaciones de subproblemas iguales pueden ser evadidos construyendo una matriz temporal desde el fondo, el c\xf3digo usa esta metodolog\xeda.\\nLa complejidad de tiempo de este algoritmo es de O(nW) donde n es el n\xfamero de \xedtems y W el peso de la mochila.\\n","complejidad_tiempo":null,"java":"/*Implementaci\xf3n java del problema 0-1 Knapsack */\\npublic class KnapsackRecursive {\\n//Funci\xf3n de utilidad que retorna el mayor de dos n\xfameros\\n\\n    static int max(int a, int b) {\\n        return (a > b) ? a : b;\\n    }\\n    // Retorna el maximo valor que puede ser \\n    //Puesto en una knapsack de capacidad w\\n\\n    static int knapSack(int W, int wt[], int val[], int n) {\\n        // Caso base\\n        if (n == 0 || W == 0) {\\n            return 0;\\n        }\\n        /*Si el peso de el nesimo item es m\xe1s\\n        que la capacidad el knapsack, entonces\\n        este item no puede ser icluido en una \\n        soluci\xf3n optima*/\\n        if (wt[n - 1] > W) {\\n            return knapSack(W, wt, val, n - 1);\\n        } // Retorna el maximo de dos casos:\\n        //1) nesimo termino incluido\\n        //2) no incluido\\n        else {\\n            return max(val[n - 1] + knapSack(W - wt[n - 1], wt, val, n - 1),\\n                    knapSack(W, wt, val, n - 1));\\n        }\\n    }\\n\\n    public static void main(String args[]) {\\n        int val[] = new int[]{60, 100, 120};\\n        int wt[] = new int[]{10, 20, 30};\\n        int W = 50;\\n        int n = val.length;\\n        System.out.println(knapSack(W, wt, val, n));\\n    }\\n}\\n// Implementaci\xf3n java que usa programaci\xf3n dinamica\\n// para solucionar el problema de 0-1 Knapsack\\n\\npublic class KnapsackDP {\\n    //Funci\xf3n de utilidad que retorna el maximo de dos enteros\\n    static int max(int a, int b) {\\n        return (a > b) ? a : b;\\n    }\\n    // Retorna el maximo valor que puede ser puesto en un\\n    //knapsack de capacidad w\\n    static int knapSack(int W, int wt[], int val[], int n) {\\n        int i, w;\\n        int K[][] = new int[n + 1][W + 1];\\n        // Construye la tabla K[][]de abajo hacia arriba\\n        for (i = 0; i <= n; i++) {\\n            for (w = 0; w <= W; w++) {\\n                if (i == 0 || w == 0) {\\n                    K[i][w] = 0;\\n                } else if (wt[i - 1] <= w) {\\n                    K[i][w] = max(val[i - 1]\\n                            + K[i - 1][w - wt[i - 1]], K[i - 1][w]);\\n                } else {\\n                    K[i][w] = K[i - 1][w];\\n                }\\n            }\\n        }\\n\\n        return K[n][W];\\n    }\\n\\n    public static void main(String args[]) {\\n        int val[] = new int[]{60, 100, 120};\\n        int wt[] = new int[]{10, 20, 30};\\n        int W = 50;\\n        int n = val.length;\\n        System.out.println(knapSack(W, wt, val, n));\\n    }\\n}\\n","cpp":null,"py":null,"orden":9,"suborden":0,"fecha_creacion":"2020-12-05 00:45:54","fecha_modificacion":"2020-12-06 20:32:33"},{"ID":159,"supergrupo":"DP","tema":"Cambio de monedas","texto":"Dado un valor N, si queremos hacer el cambio de N centavos y tenemos suministros infinitos de cada uno de las S = {S1, S2,.., Sm} monedas con valor, \xbfde cuantas formas podemos hacer el cambio? El orden de las monedas no importa\\nDado un valor N, queremos hacer el cambio por N centavos, y tenemos suministros de cada una, por  ejemplo, para N=4, y S={1,2,3}, existen 4 soluciones {1,1,1,1},{1,1,2},{2,2},{1,3}. Entonces la salida debe ser 4, para N=10, y S={2,5,3,6} existen 6 soluciones {2,2,2,2,2}, {2,2,3,3}, {2,2,6}, {2,3,5} y {5,5}. Entonces la salida debe ser 5.\\nPara contar el total el n\xfameros de soluciones podemos dividir todos los sets soluci\xf3n en dos sets.\\n1) Soluciones que no contienen emesima moneda o Sm.\\n2) Soluciones que al menos contienen una Sm.\\nDejaremos ser count(S[],m,n) la funci\xf3n de conteo del n\xfamero de soluciones, luego estas pueden ser escritas como suma de count(S[], m-1, n) y count(S[], m, n-Sm).\\nPor lo tanto, el problema tiene una propiedad se subestructura optima haciendo que el problema pueda ser resuelto usando soluciones a subproblemas.\\nComplejidad de tiempo: O(mn)\\n","complejidad_tiempo":null,"java":"// Programa java que resuelve el problema\\n// del cambio de monedas\\n\\npublic class CoinExchange {\\n\\n    // Retorna el conteo de form\xe1s que podemos\\n    // sumar S[0...m-1] monedas para obtener n \\n    static int count(int S[], int m, int n) {\\n        // Si n es 0 entonces 1 es la soluci\xf3n \\n        // (No incluir ninguna moneda \\n        if (n == 0) {\\n            return 1;\\n        }\\n        // Si n es menos que 0 entonces no hay soluci\xf3n\\n        if (n < 0) {\\n            return 0;\\n        }\\n        /*Si no hay monedas y n es mayor que 0, no existe soluci\xf3n*/\\n        if (m <= 0 && n >= 1) {\\n            return 0;\\n        }\\n        // count es la suma de las soluci\xf3nes (i) \\n        // incluyendo S[m-1] (ii) excluyendo S[m-1] \\n        return count(S, m - 1, n)\\n                + count(S, m, n - S[m - 1]);\\n    }\\n\\n    public static void main(String[] args) {\\n        int arr[] = {1, 2, 3};\\n        int m = arr.length;\\n        System.out.println(count(arr, m, 4));\\n    }\\n}\\n","cpp":null,"py":null,"orden":9,"suborden":1,"fecha_creacion":"2020-12-05 00:45:54","fecha_modificacion":"2020-12-06 20:32:33"},{"ID":160,"supergrupo":"DP","tema":"Longest Increasing Subsequence","texto":"El problema de la  secuencia incremental m\xe1s larga (LIS), es encontrar la longitud de la subsecuencia m\xe1s larga dada una secuencia la cual todos los elementos de la subsecuencia est\xe1n ordenados en orden ascendente, por ejemplo la longitud de a LIS para {10, 22, 9, 33, 21, 50, 41, 60, 80} es 6 y LIS es {10, 22, 33, 50, 60, 80}.\\nDejaremos arr [0...n-1] ser el array de entrada y L(i) ser la longitud de la LIS finalizando en el \xedndice I tal que arr[i] es el \xfaltimo elemento de la LIS.\\nEntonces L(i) puede ser recursivamente escrito como:\\nL(i) = 1 + max( L(j) ) donde 0 < j < i y arr[j] < arr[i]; \\no\\nL(i) = 1, Si no existe tal j.\\nPara encontrar la LIS de un array dado, necesitamos retornar max(L(i)) donde 0 < i < n.\\nPor lo tanto vemos que el problema LIS satisface la propiedad de la subestructura \xf3ptima como el problema principal puede ser resuelto usando soluciones a subproblemas.\\n\\nNote que la complejidad de tiempo de esta programaci\xf3n din\xe1mica es O(nLogn).\\n","complejidad_tiempo":null,"java":"\\npublic class LongestIncreasingSubsequence {\\n\\n    static int max_ref;\\n\\n    /* Para hacer uso de llamadas recursivas, esta funci\xf3n debe devolver.\\n   dos cosas:\\n   1) Longitud de LIS que termina con el elemento arr [n-1]. Usamos\\n      max_ending_here para este prop\xf3sito\\n   2) M\xe1ximo global ya que el LIS puede terminar con un elemento\\n      antes de arr [n-1] max_ref se usa para este prop\xf3sito.\\n   El valor de LIS de la matriz completa de tama\xf1o n se almacena en\\n   * max_ref cual es nuestro resultado final*/\\n    static int _lis(int arr[], int n) {\\n        // Caso base\\n        if (n == 1) {\\n            return 1;\\n        }\\n        // \'max_ending_here\' es el tama\xf1o de LIS \\n        // terminando con arr[n-1] \\n        int res, max_ending_here = 1;\\n        for (int i = 1; i < n; i++) {\\n            res = _lis(arr, i);\\n            if (arr[i - 1] < arr[n - 1] && res + 1 > max_ending_here) {\\n                max_ending_here = res + 1;\\n            }\\n        }\\n        if (max_ref < max_ending_here) {\\n            max_ref = max_ending_here;\\n        }\\n        return max_ending_here;\\n    }\\n\\n    static int lis(int arr[], int n) {\\n        // Guarda el resultado \\n        max_ref = 1;\\n        //Almacena su resultado en max \\n        _lis(arr, n);\\n        //Retorna el maximo\\n        return max_ref;\\n    }\\n\\n    public static void main(String args[]) {\\n        int arr[] = {10, 22, 9, 33, 21, 50, 41, 60};\\n        int n = arr.length;\\n        System.out.println(\\"Tama\xf1o de la subsecuencia incremental m\xe1s larga\\"\\n                + \\" es \\" + lis(arr, n) + \\"\\\\n\\");\\n    }\\n}\\n","cpp":null,"py":null,"orden":9,"suborden":2,"fecha_creacion":"2020-12-05 00:45:55","fecha_modificacion":"2020-12-06 20:32:34"},{"ID":161,"supergrupo":"DP","tema":"Longest Common SubString","texto":"Dados dos strings X y Y encuentre el substring com\xfan m\xe1s largo. Dejaremos que M y N sean las longitudes del primer y segundo string respectivamente.\\nUna simple soluci\xf3n es uno por uno considerar todos los substrings del primer string y por cada substring verificar su es un substring en el segundo substring, mantenemos rastro del string de longitud m\xe1xima, ah\xed pueden haber O(m^2) substrings y podemos encontrar si un string es substring de otro string en tiempo O(n), entonces el tiempo general de este m\xe9todo ser\xe1 O(n * m2)\\nProgramaci\xf3n din\xe1mica puede ser usada para encontrar el string com\xfan m\xe1s largo en O(n*m) tiempo, la idea es encontrar el sufijo com\xfan m\xe1s largo para todos los substrings de ambos strings y almacena estas longitudes en la tabla.\\nEl sufijo com\xfan m\xe1s largo tiene propiedad de subestructura propia.\\nSi el \xfaltimo car\xe1cter coincide, entonces reducimos ambas longitudes en 1.\\n- LCSuff(X, Y, m, n) = LCSuff(X, Y, m-1, n-1) + 1 if X[m-1] = Y[n-1]\\nSi el \xfaltimo car\xe1cter no coincide, entonces el resultado es 0, por ejemplo:\\n- LCSuff(X, Y, m, n) = 0 if (X[m-1] != Y[n-1])\\nAhora consideramos sufijos de diferentes substrings terminando en diferentes \xedndices, el sufijo com\xfan m\xe1s largo, su longitud es el substring com\xfan m\xe1s largo.\\n- LCSubStr(X, Y, m, n) = Max(LCSuff(X, Y, i, j)) donde 1 <= i <= m y 1 <= j <= n\\nComplejidad de tiempo: O(m*n)\\n","complejidad_tiempo":null,"java":"/* Implementaci\xf3n java que encuentra el substring comun m\xe1s \\nlargo usando programaci\xf3n dinamica*/\\npublic class LongestCommonSubString {\\n\\n    static int LCSubStr(char X[], char Y[], int m, int n) {\\n\\n        int LCStuff[][] = new int[m + 1][n + 1];\\n        int result = 0;  //Para almacenar el tama\xf1o del substring \\n        for (int i = 0; i <= m; i++) {\\n            for (int j = 0; j <= n; j++) {\\n                if (i == 0 || j == 0) {\\n                    LCStuff[i][j] = 0;\\n                } else if (X[i - 1] == Y[j - 1]) {\\n                    LCStuff[i][j] = LCStuff[i - 1][j - 1] + 1;\\n                    result = Integer.max(result, LCStuff[i][j]);\\n                } else {\\n                    LCStuff[i][j] = 0;\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n\\n    public static void main(String[] args) {\\n        String X = \\"hola mundo\\";\\n        String Y = \\"mundo\\";\\n        int m = X.length();\\n        int n = Y.length();\\n        System.out.println(\\"El tama\xf1o del substring c\xf3mun m\xe1s largo es \\"\\n                + LCSubStr(X.toCharArray(), Y.toCharArray(), m, n));\\n    }\\n}\\n\\n","cpp":null,"py":null,"orden":9,"suborden":3,"fecha_creacion":"2020-12-05 00:45:55","fecha_modificacion":"2020-12-06 20:32:35"},{"ID":162,"supergrupo":"DP","tema":"Tri\xe1ngulo de Pascal","texto":"El tri\xe1ngulo de Pascal es un tri\xe1ngulo de n\xfameros enteros, infinito y sim\xe9trico Se empieza con un 1 en la primera fila, y en las filas siguientes se van colocando n\xfameros de forma que cada uno de ellos sea la suma de los dos n\xfameros que tiene encima. Se supone que los lugares fuera del tri\xe1ngulo contienen ceros, de forma que los bordes del tri\xe1ngulo est\xe1n formados por unos.\\n- Los n\xfameros del tri\xe1ngulo de Pascal coinciden con los n\xfameros combinatorios.\\n- El n\xfamero combinatorio Cm n (n sobre m) se encuentra en el tri\xe1ngulo en la fila n+1, en el lugar m+1. \\n- El n\xfamero combinatorio Cm n (n sobre m) que representa el n\xfamero de grupos de m elementos que pueden hacerse de entre un conjunto de n (por ejemplo, (4 sobre 2) nos da el n\xfamero de parejas distintas que podr\xedan hacerse en un grupo de cuatro personas), se encuentra en el tri\xe1ngulo en la fila n+1, en el lugar m+1. \\n- Podemos saber que el n\xfamero de parejas posibles que dec\xedamos antes es 6 si miramos el tercer n\xfamero de la quinta fila. \\nEsto hace que el tri\xe1ngulo sea \xfatil como representaci\xf3n de estos n\xfameros, y proporciona una buena forma de intuir sus propiedades.\\n- La f\xf3rmula general del llamado Binomio de Newton (a + b)n est\xe1 formada por unos coeficientes que coinciden con la l\xednea n\xfamero n+1 del tri\xe1ngulo de Pascal (la que empieza por 1 y n).\\n- Si el primer elemento de una fila es un n\xfamero primo, todos los n\xfameros de esa fila ser\xe1n divisibles por \xe9l (menos el 1, claro). As\xed, en la fila 7: (1 7 21 35 35 21 7 1), los n\xfameros 7,21 y 35 son divisibles por 7.\\n- La suma de los elementos de cualquier fila es el resultado de elevar 2 al n\xfamero que define a esa fila. \\n- La serie de Fibonacci puede ser encontrada tambi\xe9n en el tri\xe1ngulo de Pascal. Dividiendo al mismo seg\xfan las l\xedneas que mostramos en el diagrama, los n\xfameros atrapados entre ellas suman cada uno de los elementos de esta sucesi\xf3n.\\n","complejidad_tiempo":null,"java":"//C\xf3digo java que realiza el tri\xe1ngulo de Pascal\\n\\npublic class PascalTriangle {\\n\\n    static void printPascal(int n) {\\n        /* Itera atraves de cada linea y la imprime\\n        con sus entradas*/\\n        for (int line = 0; line < n; line++) {\\n            // Cada linea tiene u n\xfamero de enteror\\n            //igual al n\xfamero de linea\\n            for (int i = 0; i <= line; i++) {\\n                System.out.print(binomialCoeff(line, i) + \\" \\");\\n            }\\n            System.out.println();\\n        }\\n    }\\n\\n    static int binomialCoeff(int n, int k) {\\n        int res = 1;\\n        if (k > n - k) {\\n            k = n - k;\\n        }\\n        for (int i = 0; i < k; ++i) {\\n            res *= (n - i);\\n            res /= (i + 1);\\n        }\\n        return res;\\n    }\\n\\n    public static void main(String args[]) {\\n        int n = 7;\\n        printPascal(n);\\n    }\\n}\\n","cpp":null,"py":null,"orden":9,"suborden":4,"fecha_creacion":"2020-12-05 00:45:55","fecha_modificacion":"2020-12-06 20:32:35"},{"ID":163,"supergrupo":"Archivos","tema":"Lectura desde archivos","texto":"Cada lenguaje tiene diferentes funciones que permiten realizar esto, aqu\xed les presentamos varios ejemplos en los tres lenguajes, necesitaremos primero crear los siguientes archivos de texto en la misma carpeta en la que se encuentre el proyecto (Puede variar).","complejidad_tiempo":"Archivos de entrada\\nIO_in1.txt 3\\n1 2\\n5 7\\n6 3\\nIO_in2.txt 1 2\\n5 7\\n6 3\\n0 0\\n1 1\\nIO_in3.txt 1 2\\n5 7\\n6 3\\nIO_in4.txt 1 1\\n2 3 4\\n3 8 1 1\\n4 7 2 9 3\\n5 1 1 1 1 1\\nIO_in5.txt 1\\n3 4\\n8 1 1\\n7 2 9 3\\n1 1 1 1 1\\n","java":"import java.util.*;\\nimport java.io.*;\\n\\nclass IO {\\n\\n    public static void main(String[] args) throws Exception {\\n        // Comente todas las l\xedneas y solo descomente el c\xf3digo de \\n        // demostraci\xf3n que le interese\\n\\n        // Detectar el directorio actual por si es necesario\\n        // hay que diferencias entre URL relativa y URL absoluta\\n        // se necesita determinar si es necesario  colocar la ruta completa\\n        // dependiendo del sistema operativo\\n        System.out.println(System.getProperty(\\"user.dir\\"));\\n        Scanner sc = new Scanner(new File(System.getProperty(\\"user.dir\\")\\n                + \\"\\\\\\\\src\\\\\\\\ready\\\\\\\\IO_in1.txt\\"));\\n        int TC = sc.nextInt(); // n\xfamero de casos de prueba\\n        while (TC-- > 0) { // atajo para repetir hasta 0\\n            int a = sc.nextInt(), b = sc.nextInt(); // calcular respuesta\\n            System.out.println(a + b); // sobre la marcha\\n        }\\n\\n//        Scanner sc = new Scanner(new File(\\"IO_in2.txt\\"));\\n//        int a, b;\\n//        // detenerse cuando ambos enteros sean 0\\n//        while (true) {\\n//            a = sc.nextInt();\\n//            b = sc.nextInt();\\n//            if ((a == 0) && (b == 0)) {\\n//                break;\\n//            }\\n//            System.out.println(a + b);\\n//        }\\n//\\n//        Scanner sc = new Scanner(new File(\\"IO_in3.txt\\"));\\n//        // La clase de esc\xe1ner tiene el m\xe9todo hasNext\\n//        while (sc.hasNext()) {\\n//            int a = sc.nextInt(), b = sc.nextInt();\\n//            System.out.println(a + b);\\n//        }\\n//\\n//        Scanner sc = new Scanner(new File(\\"IO_in3.txt\\")); // mismo archivo de \\n//        // entrada que antes\\n//        int c = 0;\\n//        while (sc.hasNext()) {\\n//            int a = sc.nextInt(), b = sc.nextInt();\\n//            // observe los dos \'\\\\ n\', Java System.out tambi\xe9n tiene printf\\n//            System.out.printf(\\"Case %d: %d\\\\n\\\\n\\", ++c, a + b);\\n//        }\\n//\\n//        Scanner sc = new Scanner(new File(\\"IO_in3.txt\\")); // mismo archivo \\n//        // de entrada que antes\\n//        int c = 0;\\n//        while (sc.hasNext()) {\\n//            int a = sc.nextInt(), b = sc.nextInt();\\n//            if (c > 0) {\\n//                System.out.println(); // 2do / m\xe1s casos\\n//            }\\n//            System.out.printf(\\"Case %d: %d\\\\n\\", ++c, a + b);\\n//        }\\n//\\n//        Scanner sc = new Scanner(new File(\\"IO_in4.txt\\"));\\n//        while (sc.hasNext()) {\\n//            int k = sc.nextInt();\\n//            int ans = 0, v;\\n//            while (k-- > 0) {\\n//                v = sc.nextInt();\\n//                ans += v;\\n//            }\\n//            System.out.println(ans);\\n//        }\\n//\\n//        Scanner sc = new Scanner(new File(\\"IO_in5.txt\\"));\\n//        while (sc.hasNext()) { // sigue en bucle\\n//            String[] token = sc.nextLine().split(\\" \\");\\n//            int ans = 0;\\n//            for (int i = 0; i < token.length; ++i) {\\n//                ans += Integer.parseInt(token[i]);\\n//            }\\n//            System.out.println(ans);\\n//        }\\n    }\\n}\\n","cpp":"#include <bits/stdc++.h>\\nusing namespace std;\\n\\nint main() {\\n    // Comente todas las l\xedneas y solo descomente el c\xf3digo de demostraci\xf3n que le interese\\n\\n    freopen(\\"IO_in1.txt\\", \\"r\\", stdin);\\n    int TC;\\n    scanf(\\"%d\\", &TC); // n\xfamero de casos de prueba\\n    while (TC--) { // atajo para repetir hasta 0\\n        int a, b;\\n        scanf(\\"%d %d\\", &a, &b);\\n        printf(\\"%d\\\\n\\", a + b); // calcular sobre la marcha\\n    }\\n\\n    //   freopen(\\"IO_in2.txt\\", \\"r\\", stdin);\\n    //   int a, b;\\n    //   // detenerse cuando ambos enteros sean 0\\n    //   while (scanf(\\"%d %d\\", &a, &b), (a || b))\\n    //     printf(\\"%d\\\\n\\", a+b);\\n    //\\n    //   freopen(\\"IO_in3.txt\\", \\"r\\", stdin);\\n    //   int a, b;\\n    //   // scanf devuelve el n\xfamero de elementos le\xeddos\\n    //   while (scanf(\\"%d %d\\", &a, &b) == 2)\\n    //   // o puede verificar EOF, es decir\\n    //   // while (scanf (\\"% d% d\\", & a, & b)! = EOF)\\n    //     printf(\\"%d\\\\n\\", a+b);\\n    //\\n    //   freopen(\\"IO_in3.txt\\", \\"r\\", stdin); // mismo archivo de entrada que antes\\n    //   int a, b, c = 0;\\n    //   while (scanf(\\"%d %d\\", &a, &b) != EOF)\\n    //     // note los dos \'\\\\ n\'\\n    //     printf(\\"Case %d: %d\\\\n\\\\n\\", ++c, a+b);\\n    //\\n    //   freopen(\\"IO_in3.txt\\", \\"r\\", stdin); // mismo archivo de entrada que antes\\n    //   int a, b, c = 0;\\n    //   while (scanf(\\"%d %d\\", &a, &b) != EOF) {\\n    //     if (c > 0) printf(\\"\\\\n\\"); // 2do / m\xe1s casos\\n    //     printf(\\"Case %d: %d\\\\n\\", ++c, a+b);\\n    //   }\\n    //\\n    //   freopen(\\"IO_in4.txt\\", \\"r\\", stdin);\\n    //   int k;\\n    //   while (scanf(\\"%d\\", &k) != EOF) {\\n    //     int ans = 0, v;\\n    //     while (k--) { scanf(\\"%d\\", &v); ans += v; }\\n    //     printf(\\"%d\\\\n\\", ans);\\n    //   }\\n    //\\n    //   freopen(\\"IO_in5.txt\\", \\"r\\", stdin);\\n    //   while (1) { // sigue en bucle\\n    //     int ans = 0, v;\\n    //     char dummy;\\n    //     while (scanf(\\"%d%c\\", &v, &dummy) != EOF) {\\n    //       ans += v;\\n    //       if (dummy == \'\\\\n\') break; // prueba EOLN\\n    //     }\\n    //     if (feof(stdin)) break; // tprueba EOF\\n    //     printf(\\"%d\\\\n\\", ans);\\n    //   }\\n\\n    return 0;\\n}\\n\\n","py":"# Comente todas las l\xedneas y solo descomente el c\xf3digo de \\n# demostraci\xf3n que le interese\\n\\n# IO_in1.txt\\nimport sys\\ninputs = iter(sys.stdin.readlines())\\nTC = int(next(inputs))\\nfor _ in range(TC):\\n    print(sum(map(int, next(inputs).split())))\\n\\n## IO_in2.txt\\n#import sys\\n#for line in sys.stdin.readlines():\\n#    if line == \'0 0\\\\n\': break\\n#    print(sum(map(int, line.split())))\\n#\\n## IO_in3.txt\\n#import sys\\n#for line in sys.stdin.readlines():\\n#    print(sum(map(int, line.split())))\\n#\\n## IO_in3.txt, mismo archivo de entrada que antes\\n#import sys\\n#for c, line in enumerate(sys.stdin.readlines(), 1):\\n#    print(\\"Case %s: %s\\\\n\\" % (c, sum(map(int, line.split()))))\\n#\\n## IO_in3.txt, mismo archivo de entrada que antes\\n#import sys\\n#for c, line in enumerate(sys.stdin.readlines(), 1):\\n#    if c > 1: print()\\n#    print(\\"Case %s: %s\\" % (c, sum(map(int, line.split()))))\\n#\\n## IO_in4.txt\\n#import sys\\n#for line in sys.stdin.readlines():\\n#    print(sum(map(int, line.split()[1:]))) # skip the first integer\\n#\\n## IO_in5.txt\\n#import sys\\n#for line in sys.stdin.readlines():\\n#    print(sum(map(int, line.split())))\\n","orden":12,"suborden":1,"fecha_creacion":"2020-12-05 01:56:08","fecha_modificacion":"2020-12-06 20:36:17"},{"ID":164,"supergrupo":"Archivos","tema":"Escritura de archivos ","texto":"","complejidad_tiempo":null,"java":"// Creando un archivo de texto usando FileWriter\\n\\nimport java.io.FileWriter;\\nimport java.io.IOException;\\n\\npublic class WriteFile {\\n\\n    public static void main(String[] args) throws IOException {\\n        // Aceptar una cadena\\n        String str = \\"Programaci\xf3n competitiva\\";\\n        // adjuntar un archivo a FileWriter\\n        FileWriter fw = new FileWriter(\\"output.txt\\");\\n        // leer caracteres de la cadena y escribir en FileWriter\\n        fw.write(str);\\n        System.out.println(\\"Writing successful\\");\\n        //close the file \\n        fw.close();\\n    }\\n}\\n","cpp":"#include <bits/stdc++.h> \\nusing namespace std;\\n\\nint main() {\\n    // fstream es la clase Stream para leer y escribir desde / hacia archivos.\\n    // file es objeto de la clase fstream\\n    fstream file;\\n\\n    // abrir el archivo \\"out.txt\\" en el modo de salida (escritura)\\n    // ios::out Abierto para operaciones de salida.\\n    file.open(\\"out.txt\\", ios::out);\\n\\n    // Si no se crea ning\xfan archivo, muestre el mensaje de error.\\n    if (!file) {\\n        cout << \\"Error in creating file!!!\\";\\n        return 0;\\n    }\\n    file << \\"programaci\xf3n competitiva\\" << endl;\\n\\n    cout << \\"File created successfully.\\";\\n    // cerrando el archivo.\\n    // La raz\xf3n por la que necesita llamar a close () al final del ciclo \\n    // es que al intentar abrir un nuevo archivo sin cerrar \\n    // el primer archivo fallar\xe1.\\n    file.close();\\n\\n    return 0;\\n}\\n","py":"# Abrir un archivo\\nfile1 = open(\'myfile.txt\', \'w\') \\nL = [\\"Programaci\xf3n competitiva \\\\n\\", \\"artemis \\\\n\\", \\"NMA \\\\n\\"] \\ns = \\"hola mundo\\\\n\\"\\n\\n# Escribir una cadena en un archivo\\nfile1.write(s) \\n\\n# Escribir varias cadenas a la vez\\nfile1.writelines(L) \\n\\n# Archivo de cierre\\nfile1.close() \\n\\n# Comprobando si los datos est\xe1n escritos en un archivo o no\\nfile1 = open(\'myfile.txt\', \'r\') \\nprint(file1.read()) \\nfile1.close() \\n","orden":12,"suborden":2,"fecha_creacion":"2020-12-05 01:56:08","fecha_modificacion":"2022-03-08 11:38:01"},{"ID":165,"supergrupo":"Matem\xe1tica","tema":"Test de primalidad AKS","texto":"Hay varias pruebas de primalidad disponibles para verificar si el n\xfamero es primo o no, como el teorema de Fermat, la prueba de primaria de Miller-Rabin y mucho m\xe1s. Pero el problema con todos ellos es que todos son de naturaleza probabil\xedstica. Entonces, aqu\xed viene otro m\xe9todo, es decir, la prueba de primalidad AKS (prueba de primalidad de Agrawal-Kayal-Saxena) y es determin\xedsticamente correcto para cualquier n\xfamero general.\\nCaracter\xedsticas de la prueba de primalidad de AKS:\\n\\n1. El algoritmo AKS se puede utilizar para verificar la primac\xeda de cualquier n\xfamero general dado.\\n\\n2. El tiempo m\xe1ximo de ejecuci\xf3n del algoritmo se puede expresar como un polinomio sobre el n\xfamero de d\xedgitos del n\xfamero objetivo.\\n\\n3. Se garantiza que el algoritmo distingue de forma determinista si el n\xfamero objetivo es primo o compuesto.\\n\\n4. La exactitud de AKS no est\xe1 condicionada a ninguna hip\xf3tesis subsidiaria no probada.\\n\\nEsta congruencia se puede verificar en tiempo polinomial cuando r es polinomial a los d\xedgitos de n. El algoritmo AKS eval\xfaa esta congruencia para un gran conjunto de valores a, cuyo tama\xf1o es polinomial a los d\xedgitos de n. La prueba de validez del algoritmo AKS muestra que uno puede encontrar r y un conjunto de valores a con las propiedades anteriores, de modo que si las congruencias se cumplen, entonces n es una potencia de un primo. El enfoque de fuerza bruta requerir\xeda la expansi\xf3n del polinomio (x - a) ^ n y una reducci\xf3n (mod n) de los coeficientes n + 1 resultantes.\\nComo debe ser coprimo a n. Entonces, para implementar este algoritmo podemos verificar tomando a = 1, pero para valores grandes de n debemos tomar valores grandes de a.\\nEl algoritmo se basa en la condici\xf3n de que si n es cualquier n\xfamero, entonces es primo si:\\n(x - 1) ^ n - (x ^ n - 1) es divisible por n.\\nComprobando n = 3:\\n(x-1) ^ 3 - (x ^ 3 - 1)\\n= (x ^ 3 - 3x ^ 2 + 3x - 1) - (x ^ 3 - 1)\\n= -3x ^ 2 + 3x\\nComo todos los coeficientes son divisibles por n, es decir, 3, 3 (n) es primo.\\nA medida que aumenta el n\xfamero, aumenta el tama\xf1o.\\nEl c\xf3digo se basa en esta condici\xf3n y puede verificar n\xfameros primos hasta 64.\\n","complejidad_tiempo":null,"java":"/*Verifica si el n\xfamero es primo, este programa demuestra el concepto detras del\\nAlgoritmo AKS (solo funciona hasta n=64*/\\npublic class AKSPrimalityTest {\\n\\n    // array usado para almacenar coeficientes\\n    static long c[] = new long[100];\\n\\n    /*\\n    Funci\xf3n que calcula los coeficientes de \\n    (x - 1)^n - (x^n - 1) con ayuda del triangulo de pascal\\n     */\\n    static void coef(int n) {\\n        c[0] = 1;\\n        for (int i = 0; i < n; c[0] = -c[0], i++) {\\n            c[1 + i] = 1;\\n            for (int j = i; j > 0; j--) {\\n                c[j] = c[j - 1] - c[j];\\n            }\\n        }\\n    }\\n\\n    //funci\xf3n de verificaci\xf3n de un numero primo\\n    static boolean isPrime(int n) {\\n\\n        //Calculando todos los coeficientes \\n        //por la funci\xf3n coef y almacenando todos\\n        //los coeficientes en en el array c.\\n        coef(n);\\n        //restando c [n] y sumando c [0] por 1\\n        //como (x - 1) ^ n - (x ^ n - 1), aqu\xed\\n        //se resta c [n] por 1 y se suma\\n        //1 en expresi\xf3n.\\n        c[0]++;\\n        c[n]--;\\n        //comprobando todos los coeficientes si\\n        //son divisibles por n o no.\\n        //si n no es primo, entonces el bucle se rompe\\n        //y (i> 0).\\n        int i = n;\\n        while ((i--) > 0 && c[i] % n == 0);\\n        // Retorna true si todos los coeficientes son divisibles por n\\n        return i < 0;\\n    }\\n\\n    public static void main(String[] args) {\\n        int n = 37;\\n        if (isPrime(n)) {\\n            System.out.println(\\"Prime\\");\\n        } else {\\n            System.out.println(\\"Not Prime\\");\\n        }\\n    }\\n}\\n","cpp":"#include <cstdlib>\\n#include <bits/stdc++.h>\\nusing namespace std;\\nlong c[100];\\n\\nstatic void coef(int n) {\\n    c[0] = 1;\\n    for (int i = 0; i < n; c[0] = -c[0], i++) {\\n        c[1 + i] = 1;\\n        for (int j = i; j > 0; j--)\\n            c[j] = c[j - 1] - c[j];\\n    }\\n}\\n\\nbool isPrime(int n) {\\n    coef(n);\\n    c[0]++;\\n    c[n]--;\\n    int i = n;\\n    while ((i--) > 0 && c[i] % n == 0);\\n    return i < 0;\\n}\\n\\nint main() {\\n    int n = 37;\\n    if (isPrime(n))\\n        cout << \\"Primo\\" << endl;\\n    else\\n        cout << \\"No es primo\\" << endl;\\n}\\n","py":"c = [0] * 100 \\ndef coef(n): \\n    c[0] = 1 \\n    for i in range(n): \\n        c[1 + i] = 1 \\n        for j in range(i, 0, -1): \\n            c[j] = c[j - 1] - c[j] \\n        c[0] = -c[0] \\n                \\ndef isPrime(n): \\n    coef(n) \\n    c[0] = c[0] + 1 \\n    c[n] = c[n] - 1 \\n    i = n \\n    while (i > -1 and c[i] % n == 0): \\n        i = i - 1 \\n    return True if i < 0 else False \\n\\nn = 37; \\nif (isPrime(n)): \\n    print(\\"Prime\\") \\nelse: \\n    print(\\"Not Prime\\")\\n","orden":6,"suborden":58,"fecha_creacion":"2020-12-05 01:56:08","fecha_modificacion":"2022-03-08 11:38:01"},{"ID":166,"supergrupo":"Matem\xe1tica","tema":"Test de primalidad Miller-Rabin","texto":"Dado un n\xfamero n, compruebe si es primo o no.\\nEste m\xe9todo es un m\xe9todo probabil\xedstico (como Fermat), pero generalmente se prefiere al m\xe9todo de Fermat.\\n\\n\xbfComo funciona esto?\\n1. El teorema de Fermat establece que, si n es un n\xfamero primo, entonces para cada a, 1 <= a <n, an-1% n = 1\\n2. Los casos base aseguran que n debe ser impar. Dado que n es impar, n-1 debe ser par. Y un n\xfamero par se puede escribir como d * 2s donde d es un n\xfamero impar y s> 0.\\n3. A partir de los dos puntos anteriores, por cada n\xfamero elegido al azar en el rango [2, n-2], el valor de ad * 2r% n debe ser 1.\\n4. De acuerdo con el Lema de Euclides, si x2% n = 1 o (x2 - 1)% n = 0 o (x-1) (x + 1)% n = 0. Entonces, para que n sea primo, n divide (x-1) on divide (x + 1). Lo que significa x% n = 1 o x% n = -1.\\n\\nDe los puntos 2 y 3, podemos concluir\\nFor n to be prime, either\\n\\tad % n = 1 \\n        OR \\n    ad*2i % n = -1 \\n    for some i, where 0 <= i <= r-1.\\n\\n","complejidad_tiempo":null,"java":"//La funci\xf3n de Miller-Rabin determina si un n\xfamero \\n//dado es o no un n\xfamero primo. \\n\\npublic class MillerRabin {\\n\\n    static boolean isPrime(long p) {\\n        if (p < 2 || (p != 2 && p % 2 == 0)) {\\n            return false;\\n        }\\n        long s = p - 1;\\n        while (s % 2 == 0) {\\n            s /= 2;\\n        }\\n        for (int i = 0; i < 5; i++) {\\n            long a = (long) (Math.random() * p) % (p - 1) + 1;\\n            long temp = s;\\n            long mod = modpow(a, temp, p);\\n            while (temp != p - 1 && mod != 1 && mod != p - 1) {\\n                mod = modmul(mod, mod, p);\\n                temp *= 2;\\n            }\\n            if (mod != p - 1 && temp % 2 == 0) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n\\n    static long modpow(long a, long b, long mod) {\\n        if (b == 0) {\\n            return 1;\\n        }\\n        if (b % 2 == 0) {\\n            long temp = modpow(a, b / 2, mod);\\n            return (temp * temp) % mod;\\n        } else {\\n            long temp = modpow(a, b - 1, mod);\\n            return (temp * a) % mod;\\n        }\\n    }\\n\\n    public static long modmul(long a, long b, long mod) {\\n        long x = 0;\\n        long y = a % mod;\\n        while (b > 0) {\\n            if (b % 2 == 1) {\\n                x = (x + y) % mod;\\n            }\\n            y = (y << 1) % mod;\\n            b >>= 1;\\n        }\\n        return x % mod;\\n    }\\n\\n    public static void main(String[] args) {\\n        for (int i = 0; i < 100; i++) {\\n            System.out.println(i + \\" \\" + isPrime(i));\\n        }\\n    }\\n}\\n","cpp":"#include <bits/stdc++.h> \\nusing namespace std;\\n\\nlong modmul(long a, long b, long mod) {\\n    long x = 0;\\n    long y = a % mod;\\n    while (b > 0) {\\n        if (b % 2 == 1) {\\n            x = (x + y) % mod;\\n        }\\n        y = (y << 1) % mod;\\n        b >>= 1;\\n    }\\n    return x % mod;\\n}\\n\\nlong modpow(long a, long b, long mod) {\\n    if (b == 0) {\\n        return 1;\\n    }\\n    if (b % 2 == 0) {\\n        long temp = modpow(a, b / 2, mod);\\n        return (temp * temp) % mod;\\n    } else {\\n        long temp = modpow(a, b - 1, mod);\\n        return (temp * a) % mod;\\n    }\\n}\\n\\nbool isPrime(long p) {\\n    if (p < 2 || (p != 2 && p % 2 == 0)) {\\n        return false;\\n    }\\n    long s = p - 1;\\n    while (s % 2 == 0) {\\n        s /= 2;\\n    }\\n    for (int i = 0; i < 5; i++) {\\n        long a = (long) (0.5 * p) % (p - 1) + 1;\\n        long temp = s;\\n        long mod = modpow(a, temp, p);\\n        while (temp != p - 1 && mod != 1 && mod != p - 1) {\\n            mod = modmul(mod, mod, p);\\n            temp *= 2;\\n        }\\n        if (mod != p - 1 && temp % 2 == 0) {\\n            return false;\\n        }\\n    }\\n    return true;\\n}\\n\\nint main() {\\n    for (int i = 0; i < 100; i++) {\\n        cout << i << \\" \\" << isPrime(i) << endl;\\n    }\\n}\\n","py":"def modmul(a, b, mod):\\n    x = 0;\\n    y = a % mod;\\n    while (b > 0):\\n        if (b % 2 == 1):\\n            x = (x + y) % mod;\\n        y = (y << 1) % mod\\n        b >>= 1\\n    return x % mod\\n\\n\\ndef modpow(a, b, mod):\\n    if (b == 0):\\n        return 1\\n    if (b % 2 == 0):\\n        temp = modpow(a, b / 2, mod)\\n        return (temp * temp) % mod\\n    else:\\n        temp = modpow(a, b - 1, mod)\\n        return (temp * a) % mod;\\n    \\ndef isPrime(p):\\n    if (p < 2 or (p != 2 and p % 2 == 0)):\\n        return False\\n    s = p - 1\\n    while (s % 2 == 0):\\n        s /= 2\\n    for i in range (5):\\n        a = int((0.5 * p) % (p - 1) + 1)\\n        temp = s\\n        mod = modpow(a, temp, p)\\n        while (temp != p - 1 and mod != 1 and mod != p - 1):\\n            mod = modmul(mod, mod, p)\\n            temp *= 2\\n        if (mod != p - 1 and temp % 2 == 0):\\n            return False\\n    return True\\nfor i in range (100):\\n    print(str(i) + \\" \\" + str(isPrime(i)))\\n","orden":6,"suborden":59,"fecha_creacion":"2020-12-05 01:56:09","fecha_modificacion":"2022-03-08 11:40:32"},{"ID":167,"supergrupo":"Matem\xe1tica","tema":"Criba de Sundaram","texto":"Dado un n\xfamero n, imprima todos los n\xfameros primos menores o iguales an.\\n1) En general la criba de Sundaram, produce primos menores que (2 * x +2) para un n\xfamero dado x. Como queremos primos menores que n, reducimos n-1 a la mitad. Lo llamamos nNew, nNew = (n-1) / 2;\\n    Por ejemplo, si n = 102, entonces nNew = 50.\\n                 si n = 103, entonces nNew = 51\\n2) Cree una array marked[n] que se utilizar\xe1 para separar n\xfameros de la forma i + j + 2ij de otros donde 1 <= i <= j\\n\\n3) Inicialice todas las entradas de marked[] como falsa.\\n\\n4) Marque todos los n\xfameros de la forma i + j + 2ij como verdaderos donde 1 <= i <= j, ciclo para i = 1 a nNew\\n\\ta) j = i;\\nb) Haga un ciclo mientras (i + j + 2 * i * j) 2, luego imprima 2 como primer primo.\\n5) Los n\xfameros primos restantes tienen la forma 2i + 1 donde i es el \xedndice de n\xfameros NO marcados. Entonces imprima 2i + 1 para todo i tal que marked[i] sea falso.\\n\\n\\n\\n\xbfComo funciona esto?\\nCuando producimos nuestra salida final, producimos todos los enteros de la forma 2x + 1 (es decir, son impares) excepto 2 que se maneja por separado.\\nSea q un n\xfamero entero de la forma 2x + 1.\\nq se excluye si y solo si x es de la forma i + j + 2ij. Eso significa:\\nq = 2(i + j + 2ij) + 1\\n  = (2i + 1)(2j + 1)\\nEntonces, un entero impar se excluye de la lista final si y solo si tiene una factorizaci\xf3n de la forma (2i + 1) (2j + 1) es decir, si tiene un factor impar no trivial.\\n","complejidad_tiempo":null,"java":"// Programa Java para imprimir primos menores que n usando la criba de Sundaram.\\n\\nimport java.util.Arrays;\\n\\npublic class SieveSundaram {\\n\\n    // Imprime todos los n\xfameros primos m\xe1s peque\xf1os\\n    static int SieveOfSundaram(int n) {\\n\\n        // En general la criba de Sundaram, produce n\xfameros primos menores que \\n        //(2 * x + 2) para un n\xfamero dado x. Como queremos primos menores que n, \\n        // reducimos n a la mitad\\n        int nNew = (n - 1) / 2;\\n\\n        // Esta matriz se usa para separar n\xfameros de la \\n        // forma i + j + 2ij de otros donde 1 <= i <= j\\n        boolean marked[] = new boolean[nNew + 1];\\n\\n        // Inicializar todos los elementos como no marcados\\n        Arrays.fill(marked, false);\\n\\n        // L\xf3gica principal de Sundaram. Marque todos los n\xfameros \\n        // de la forma i + j + 2ij como verdaderos donde 1 <= i <= j\\n        for (int i = 1; i <= nNew; i++) {\\n            for (int j = i; (i + j + 2 * i * j) <= nNew; j++) {\\n                marked[i + j + 2 * i * j] = true;\\n            }\\n        }\\n\\n        // Dado que 2 es un n\xfamero primo\\n        if (n > 2) {\\n            System.out.print(2 + \\" \\");\\n        }\\n\\n        // Imprime otros primos. Los n\xfameros primos restantes son de la \\n        // forma 2 * i + 1, de modo que marcado [i] es falso. \\n        for (int i = 1; i <= nNew; i++) {\\n            if (marked[i] == false) {\\n                System.out.print(2 * i + 1 + \\" \\");\\n            }\\n        }\\n        return -1;\\n    }\\n\\n\\n    public static void main(String[] args) {\\n        int n = 20;\\n        SieveOfSundaram(n);\\n    }\\n}\\n","cpp":"#include <bits/stdc++.h> \\nusing namespace std;\\n\\nint SieveOfSundaram(int n) {\\n\\n    int nNew = (n - 1) / 2;\\n    bool marked[nNew + 1];\\n    memset(marked, false, sizeof (marked));\\n    for (int i = 1; i <= nNew; i++)\\n        for (int j = i; (i + j + 2 * i * j) <= nNew; j++)\\n            marked[i + j + 2 * i * j] = true;\\n    if (n > 2)\\n        cout << 2 << \\" \\";\\n    for (int i = 1; i <= nNew; i++)\\n        if (marked[i] == false)\\n            cout << 2 * i + 1 << \\" \\";\\n}\\n\\nint main(void) {\\n    int n = 20;\\n    SieveOfSundaram(n);\\n    return 0;\\n} \\n","py":"def SieveOfSundaram(n): \\n    nNew = int((n - 1) / 2); \\n    marked = [0] * (nNew + 1); \\n    for i in range(1, nNew + 1): \\n        j = i; \\n        while((i + j + 2 * i * j) <= nNew): \\n            marked[i + j + 2 * i * j] = 1; \\n            j += 1; \\n    if (n > 2): \\n        print(2, end=\\" \\"); \\n  \\n    for i in range(1, nNew + 1): \\n        if (marked[i] == 0): \\n            print((2 * i + 1), end=\\" \\"); \\n  \\nn = 20; \\nSieveOfSundaram(n); \\n","orden":6,"suborden":60,"fecha_creacion":"2020-12-05 01:56:09","fecha_modificacion":"2022-03-08 11:40:32"},{"ID":168,"supergrupo":"Matem\xe1tica","tema":"Criba de Atkin","texto":"Dado un l\xedmite, imprima todos los n\xfameros primos menores o iguales al l\xedmite dado.\\nEl tamiz de Atkin es un algoritmo moderno para encontrar todos los n\xfameros primos hasta un n\xfamero entero especificado. Comparado con el antiguo Tamiz de Erat\xf3stenes, que delimita m\xfaltiplos de primos, realiza un trabajo preliminar y luego marca m\xfaltiplos de cuadrados de primos, por eso tiene una mejor complejidad te\xf3rica asint\xf3tica, esta complejidad es Complejidad de (N / (log log N) ).\\n\\n1. Cree una lista de resultados, completa con 2, 3 y 5.\\n2. Cree una lista tamiz con una entrada para cada entero positivo; todas las entradas de esta lista deben marcarse inicialmente como no principales.\\n3. Para cada n\xfamero de entrada n en la lista de tamices, con m\xf3dulo sesenta resto r:\\n1. Si r es 1, 13, 17, 29, 37, 41, 49 o 53, invierta la entrada para cada posible soluci\xf3n a 4x2 + y2 = n.\\n\\n2. Si r es 7, 19, 31 o 43, invierta la entrada para cada posible soluci\xf3n a 3x2 + y2 = n.\\n\\n3. Si r es 11, 23, 47 o 59, invierta la entrada para cada posible soluci\xf3n a 3x2 - y2 = n cuando x> y.\\n\\n4. Si r es otra cosa, ign\xf3rela por completo.\\n\\n4. Empiece con el n\xfamero m\xe1s bajo de la lista de tamiz.\\n5. Tome el siguiente n\xfamero en la lista tamiz a\xfan marcado como principal.\\n6. Incluya el n\xfamero en la lista de resultados.\\n7. Eleve al cuadrado el n\xfamero y marque todos los m\xfaltiplos de ese cuadrado como no primos. Tenga en cuenta que los m\xfaltiplos que se pueden factorizar por 2, 3 o 5 no necesitan marcarse, ya que se ignorar\xe1n en la enumeraci\xf3n final de primos.\\n8. Repita los pasos del cuatro al siete.\\n\\n\xbfC\xf3mo funciona?\\n1. El algoritmo trata 2, 3 y 5 como casos especiales y simplemente los agrega al conjunto de n\xfameros primos para empezar.\\n2. Como la criba de Erat\xf3stenes, comenzamos con una lista de n\xfameros que queremos investigar. Supongamos que queremos encontrar n\xfameros primos <= 100, luego hacemos una lista para [5, 100]. Como se explica en (1), 2, 3 y 5 son casos especiales y 4 no es primo.\\n3. El algoritmo habla en t\xe9rminos de residuos de m\xf3dulo 60. .\\n4. Todos los n\xfameros con un resto de m\xf3dulo sesenta 1, 13, 17, 29, 37, 41, 49 o 53 tienen un resto de m\xf3dulo doce de 1 o 5. Estos n\xfameros son primos si y solo si el n\xfamero de soluciones a 4 \xd7 2 + y2 = n es impar y el n\xfamero no tiene cuadrados. Un cuadrado entero libre es aquel que no es divisible por ning\xfan cuadrado perfecto distinto de 1.\\n5. Todos los n\xfameros con un resto m\xf3dulo sesenta 7, 19, 31 o 43 tienen un resto m\xf3dulo seis de 1. Estos n\xfameros son primos si y solo si el n\xfamero de soluciones de 3x2 + y2 = n es impar y el n\xfamero es squarefree.\\n6. Todos los n\xfameros con un resto de m\xf3dulo sesenta 11, 23, 47 o 59 tienen un resto de m\xf3dulo doce de 11. Estos n\xfameros son primos si y s\xf3lo si el n\xfamero de soluciones de 3x2 - y2 = n es impar y el n\xfamero es squarefree.\\nVeamos c\xf3mo genera primos hasta 20:\\n1    2    3    4    5    6    7    8    9    10\\n11  12   13    14   15   16   17  18   19    20\\nPaso 0:\\nEl estado de todos los n\xfameros al inicio es Falso. El n\xfamero especial es 2, 3 y 5 que se sabe que son primos.\\nPaso 1:\\nGenere valores para las condiciones.\\n \\nPaso 2:\\nCambiando el estado seg\xfan la condici\xf3n.\\nLos valores anteriores de n en la tabla generada en el ciclo x, y se probar\xe1n para la condici\xf3n de m\xf3dulo.\\n\\nColumna 1: si (valor de la columna1)% 12 == 1 o 5\\nluego invierta el estado del tamiz para ese n\xfamero.\\nEstamos tomando un mod con 12 en lugar de 60, esto se debe a que si tomamos el mod 60, tenemos que considerar muchos r como 1, 13, 17, 29, 37, 41, 49 o 53 y para todos estos r, mod 12 es 1 o 5. (hecho solo para reducir el tama\xf1o de la expresi\xf3n)\\n\\nColumna 2: si (valor de la columna2)% 12 == 7\\nluego invierta el estado del tamiz para ese n\xfamero.\\n\\nColumna 3: si (valor de la columna3)% 12 == 11\\nluego invierta el estado del tamiz para ese n\xfamero.\\n\\nPaso 3 :\\nComprobaci\xf3n de estado libre de cuadrados: si alg\xfan n\xfamero de nuestra lista est\xe1 en el cuadrado de cualquier n\xfamero, elim\xednelo.\\n\\nPaso 4 :\\nCreando una matriz de n\xfameros primos para los que el estado es verdadero.\\nes decir, 2 3 5 7 11 13 17 19\\nPaso 5:\\nImprime la salida en la pantalla.\\n","complejidad_tiempo":null,"java":"// Programa Java para la implementaci\xf3n de la criba de Atkin\\n\\npublic class SieveAtkin {\\n\\n    static int SieveOfAtkin(int limit) {\\n        // 2 y 3 son conocidos por ser primos\\n        if (limit > 2) {\\n            System.out.print(2 + \\" \\");\\n        }\\n\\n        if (limit > 3) {\\n            System.out.print(3 + \\" \\");\\n        }\\n\\n        // Inicializar la matriz de tamices con valores falsos\\n        boolean sieve[] = new boolean[limit];\\n\\n        for (int i = 0; i < limit; i++) {\\n            sieve[i] = false;\\n        }\\n\\n        /* Se marca sieve[n] es verdadero si uno de los\\n         lo siguiente es cierto:\\n         a) n = (4 * x * x) + (y * y) tiene un n\xfamero impar de soluciones, \\n         es decir, existe un n\xfamero impar de pares distintos (x, y) que \\n         satisfacen la ecuaci\xf3n y n% 12 = 1 o n% 12 = 5.\\n         b) n = (3 * x * x) + (y * y) tiene un n\xfamero impar de soluciones \\n         yn% 12 = 7\\n         c) n = (3 * x * x) - (y * y) tiene un n\xfamero impar de soluciones, \\n         x> y y n% 12 = 11 */\\n        for (int x = 1; x * x < limit; x++) {\\n            for (int y = 1; y * y < limit; y++) {\\n\\n                // Parte principal de la criba de Atkin\\n                int n = (4 * x * x) + (y * y);\\n                if (n <= limit && (n % 12 == 1 || n % 12 == 5)) {\\n                    sieve[n] ^= true;\\n                }\\n\\n                n = (3 * x * x) + (y * y);\\n                if (n <= limit && n % 12 == 7) {\\n                    sieve[n] ^= true;\\n                }\\n\\n                n = (3 * x * x) - (y * y);\\n                if (x > y && n <= limit && n % 12 == 11) {\\n                    sieve[n] ^= true;\\n                }\\n            }\\n        }\\n\\n        // Marcar todos los m\xfaltiplos de cuadrados como no primos\\n        for (int r = 5; r * r < limit; r++) {\\n            if (sieve[r]) {\\n                for (int i = r * r; i < limit;\\n                        i += r * r) {\\n                    sieve[i] = false;\\n                }\\n            }\\n        }\\n\\n        // Imprima primos usando sieve[] \\n        for (int a = 5; a < limit; a++) {\\n            if (sieve[a]) {\\n                System.out.print(a + \\" \\");\\n            }\\n        }\\n        return 0;\\n    }\\n\\n    public static void main(String[] args) {\\n        int limit = 20;\\n        SieveOfAtkin(limit);\\n    }\\n}\\n","cpp":"#include <bits/stdc++.h> \\nusing namespace std;\\n\\nint SieveOfAtkin(int limit) {\\n    if (limit > 2)\\n        cout << 2 << \\" \\";\\n    if (limit > 3)\\n        cout << 3 << \\" \\";\\n\\n    bool sieve[limit];\\n    for (int i = 0; i < limit; i++)\\n        sieve[i] = false;\\n\\n    for (int x = 1; x * x < limit; x++) {\\n        for (int y = 1; y * y < limit; y++) {\\n\\n            int n = (4 * x * x) + (y * y);\\n            if (n <= limit && (n % 12 == 1 || n % 12 == 5))\\n                sieve[n] ^= true;\\n\\n            n = (3 * x * x) + (y * y);\\n            if (n <= limit && n % 12 == 7)\\n                sieve[n] ^= true;\\n\\n            n = (3 * x * x) - (y * y);\\n            if (x > y && n <= limit && n % 12 == 11)\\n                sieve[n] ^= true;\\n        }\\n    }\\n\\n    for (int r = 5; r * r < limit; r++) {\\n        if (sieve[r]) {\\n            for (int i = r * r; i < limit; i += r * r)\\n                sieve[i] = false;\\n        }\\n    }\\n\\n    for (int a = 5; a < limit; a++)\\n        if (sieve[a])\\n            cout << a << \\" \\";\\n}\\n\\nint main(void) {\\n    int limit = 20;\\n    SieveOfAtkin(limit);\\n    return 0;\\n} \\n","py":"def SieveOfAtkin(limit): \\n    if (limit > 2): \\n        print(2, end=\\" \\") \\n    if (limit > 3): \\n        print(3, end=\\" \\") \\n    sieve = [False] * limit \\n    for i in range(0, limit): \\n        sieve[i] = False\\n    x = 1\\n    while(x * x < limit): \\n        y = 1\\n        while(y * y < limit): \\n            n = (4 * x * x) + (y * y) \\n            if (n <= limit and (n % 12 == 1 or \\n                n % 12 == 5)): \\n                sieve[n] ^= True\\n            n = (3 * x * x) + (y * y) \\n            if (n <= limit and n % 12 == 7): \\n                sieve[n] ^= True\\n  \\n            n = (3 * x * x) - (y * y) \\n            if (x > y and n <= limit and \\n                n % 12 == 11): \\n                sieve[n] ^= True\\n            y += 1\\n        x += 1\\n    r = 5\\n    while(r * r < limit): \\n        if (sieve[r]): \\n            for i in range(r * r, limit, r * r): \\n                sieve[i] = False\\n          \\n    for a in range(5, limit): \\n        if (sieve[a]): \\n            print(a, end=\\" \\") \\n  \\nlimit = 20\\nSieveOfAtkin(limit) \\n","orden":6,"suborden":61,"fecha_creacion":"2020-12-05 01:56:09","fecha_modificacion":"2022-03-08 11:40:32"},{"ID":169,"supergrupo":"Matem\xe1tica","tema":"Exponenciaci\xf3n binaria","texto":"Dados tres n\xfameros x, y y p, calcule (xy)% p.\\nA continuaci\xf3n se muestra la propiedad modular fundamental que se utiliza para calcular de manera eficiente la potencia bajo aritm\xe9tica modular.\\n(ab) mod p = ( (a mod p) (b mod p) ) mod p \\nPor ejemplo a = 50,  b = 100, p = 13\\n50  mod 13  = 11\\n100 mod 13  = 9\\n(50 * 100) mod 13 = ( (50 mod 13) * (100 mod 13) ) mod 13 \\nor (5000) mod 13 = ( 11 * 9 ) mod 13\\nor 8 = 8\\n","complejidad_tiempo":null,"java":"// Computando iterativamente la potencia modular\\n\\npublic class BinaryExp {\\n\\n    //Funci\xf3n iterativa para calcular\\n    //(x ^ y)% p en O (log y)\\n    static int power(int x, int y, int p) {\\n        // Inicializar resultado\\n        int res = 1;\\n        // Actualiza x si es m\xe1s\\n        // que o igual ap\\n        x = x % p;\\n        if (x == 0) {\\n            return 0; //  en caso de que x sea divisible por p\\n        }\\n        while (y > 0) {\\n            //si y es impar, multiplicar x con res \\n            if ((y & 1) == 1) {\\n                res = (res * x) % p;\\n            }\\n            // y debe ser par ahora \\n            // y = y / 2 \\n            y = y >> 1;\\n            x = (x * x) % p;\\n        }\\n        return res;\\n    }\\n\\n    public static void main(String args[]) {\\n        int x = 2;\\n        int y = 5;\\n        int p = 13;\\n        System.out.println(power(x, y, p));\\n    }\\n}\\n","cpp":"#include <cstdlib>\\n#include <bits/stdc++.h>\\n\\nusing namespace std;\\n\\nint power(int x, int y, int p) {\\n    int res = 1;\\n    x = x % p;\\n    if (x == 0) return 0;\\n    while (y > 0) {\\n        if ((y & 1) == 1)\\n            res = (res * x) % p;\\n        y = y >> 1;\\n        x = (x * x) % p;\\n    }\\n    return res;\\n}\\n\\nint main() {\\n\\n    cout << power(x, y, p) << endl;\\n}\\n","py":"def power(x, y, p):\\n    res = 1\\n    x = x % p\\n    if x == 0: \\n        return 0\\n    while y > 0:\\n        if ((y & 1) == 1):\\n            res = (res * x) % p\\n        y = y >> 1\\n        x = (x * x) % p\\n    return res\\nx = 2\\ny = 5\\np = 13\\nprint(power(x, y, p))\\n","orden":6,"suborden":62,"fecha_creacion":"2020-12-05 01:56:10","fecha_modificacion":"2022-03-08 11:40:51"},{"ID":170,"supergrupo":"Matem\xe1tica","tema":"Conteo de digitos ","texto":"Cuente el n\xfamero de d\xedgitos en un entero largo ingresado por un usuario.\\nPodemos usar log10 (logaritmo de base 10) para contar el n\xfamero de d\xedgitos de n\xfameros positivos (el logaritmo no est\xe1 definido para n\xfameros negativos).\\nRecuento de d\xedgitos de N = l\xedmite superior de log10 (N).\\n","complejidad_tiempo":null,"java":"// C\xf3digo JAVA para contar el n\xfamero de d\xedgitos en un entero\\n\\npublic class CountDigit {\\n\\n    static int countDigit(long n) {\\n        return (int) Math.floor(Math.log10(n) + 1);\\n    }\\n\\n    public static void main(String[] args) {\\n        long n = 345289467;\\n        System.out.print(\\"Number of digits : \\" + countDigit(n));\\n    }\\n}\\n","cpp":"#include <bits/stdc++.h> \\nusing namespace std;\\n\\nint countDigit(long long n) {\\n    return floor(log10(n) + 1);\\n}\\n\\nint main(void) {\\n    long long n = 345289467;\\n    cout << \\"Number of digits : \\" << countDigit(n);\\n    return 0;\\n}\\n","py":"import math \\n\\ndef countDigit(n): \\n        return math.floor(math.log(n, 10)+1) \\nn = 345289467\\nprint (\\"Number of digits : % d\\"%(countDigit(n))) \\n","orden":6,"suborden":63,"fecha_creacion":"2020-12-05 01:56:10","fecha_modificacion":"2022-03-08 11:44:37"},{"ID":171,"supergrupo":"Matem\xe1tica","tema":"BigInteger Modular","texto":"Dado un n\xfamero grande \\"num\\" representado como una cadena y un entero x, encuentre el valor de \\"num% x\\" o \\"num mod x\\". La salida se espera como un n\xfamero entero.\\nEjemplos:\\nEntrada: num = \\"12316767678678\\", a = 10\\nSalida: num (mod a) = 8\\nLa idea es procesar todos los d\xedgitos uno por uno y usar la propiedad que xy (mod a) = ((x (mod a) * y) (mod a)). A continuaci\xf3n se muestra la implementaci\xf3n.\\n","complejidad_tiempo":null,"java":"//Calcula n % m. Utilizar cuando n es un n\xfamero muy muy grande.\\n\\npublic class BigIntegerMod {\\n\\n    static int mod(String n, int m) {\\n        int r = 0;\\n        for (int i = 0; i < n.length(); i++) {\\n            r = (r * 10 + (n.charAt(i) - \'0\')) % m;\\n        }\\n        return r;\\n    }\\n    public static void main(String[] args) {\\n        System.out.println(mod(\\"9564784542\\", 10));\\n    }\\n}\\n","cpp":"#include <cstdlib>\\n#include <bits/stdc++.h>\\n\\nusing namespace std;\\n\\nint mod(string n, int m) {\\n    int r = 0;\\n    for (int i = 0; i < n.size(); i++) {\\n        r = (r * 10 + (n.at(i) - \'0\')) % m;\\n    }\\n    return r;\\n}\\n\\nint main() {\\n    cout<<(mod(\\"9564784542\\", 10))<<endl;\\n}\\n","py":"def mod(num, a): \\n    res = 0 \\n    for i in range(0, len(num)): \\n        res = (res * 10 + int(num[i])) % a; \\n    return res \\n\\nnum = \\"9564784542\\"; \\nprint(mod(num, 10)) \\n","orden":6,"suborden":64,"fecha_creacion":"2020-12-05 01:56:10","fecha_modificacion":"2022-03-08 11:49:59"},{"ID":172,"supergrupo":"Matem\xe1tica","tema":"Residuo Chino","texto":"Se nos dan dos matrices num [0..k-1] y rem [0..k-1]. En num [0..k-1], cada par es coprime (mcd para cada par es 1). Necesitamos encontrar un n\xfamero m\xednimo positivo x tal que:\\n\\n     x % num[0]    =  rem[0], \\n     x % num[1]    =  rem[1], \\n     .......................\\n     x % num[k-1]  =  rem[k-1] \\n\\nB\xe1sicamente, se nos dan k n\xfameros que son coprimos por pares, y se nos dan restos de estos n\xfameros cuando se divide un n\xfamero desconocido x por ellos. Necesitamos encontrar el valor m\xednimo posible de x que produce residuos dados.\\nEjemplos:\\nEntrada: num [] = {5, 7}, rem [] = {1, 3}\\nSalida: 31\\n\\nExplicaci\xf3n:\\n31 es el n\xfamero m\xe1s peque\xf1o tal que:\\n   (1) Cuando lo dividimos entre 5, obtenemos el resto 1.\\n   (2) Cuando lo dividimos entre 7, obtenemos el resto 3.\\n\\nEntrada: num [] = {3, 4, 5}, rem [] = {2, 3, 1}\\nSalida: 11\\n\\nExplicaci\xf3n:\\n11 es el n\xfamero m\xe1s peque\xf1o tal que:\\n   (1) Cuando lo dividimos por 3, obtenemos el resto 2.\\n   (2) Cuando lo dividimos entre 4, obtenemos el resto 3.\\n   (3) Cuando lo dividimos entre 5, obtenemos el resto 1.\\n\\nEl teorema chino del resto establece que siempre existe una x que satisface las congruencias dadas. A continuaci\xf3n se muestra el enunciado del teorema adaptado de wikipedia.\\nSean num [0], num [1],\u2026 num [k-1] enteros positivos que son coprimos por pares. Entonces, para cualquier secuencia dada de enteros rem [0], rem [1],\u2026 rem [k-1], existe un entero x que resuelve el siguiente sistema de congruencias simult\xe1neas.\\n\\nLa primera parte es clara que existe una x. La segunda parte b\xe1sicamente establece que todas las soluciones (incluida la m\xednima) producen el mismo resto cuando se dividen como subproducto de n [0], num [1], .. num [k-1]. En el ejemplo anterior, el producto es 3 * 4 * 5 = 60. Y 11 es una soluci\xf3n, otras soluciones son 71, 131, .. etc. Todas estas soluciones producen el mismo resto cuando se dividen por 60, es decir, son de forma 11 + m * 60 donde m> = 0.\\n\\nLa soluci\xf3n se basa en la siguiente f\xf3rmula.\\nx =  ( \u2211 (rem[i]*pp[i]*inv[i]) ) % prod\\n   Where 0 <= i <= n-1\\n\\nrem[i] array de residuos\\n\\nprod es producto de todos los n\xfameros dados\\nprod = num[0] * num[1] * ... * num[k-1]\\n\\npp[i] es producto de todo dividido por num[i]\\npp[i] = prod / num[i]\\n\\ninv[i] = Modular Multiplicativo Inverso de\\n         pp[i] con respecto a num[i]\\n\\n","complejidad_tiempo":null,"java":"//Programa Java para demostrar el\\n//funcionamiento del teorema del resto chino\\n\\npublic class ChineseRemainder {\\n\\n    //Devuelve el m\xf3dulo inverso de a con respecto a m \\n    //utilizando el algoritmo de Euclides extendido.\\n    static int inv(int a, int m) {\\n        int m0 = m, t, q;\\n        int x0 = 0, x1 = 1;\\n\\n        if (m == 1) {\\n            return 0;\\n        }\\n        // Aplicando algoritmo de Euclides extendido\\n        while (a > 1) {\\n            // q es cociente\\n            q = a / m;\\n            t = m;\\n            // m es el resto ahora, proceso igual que el algoritmo de euclides\\n            m = a % m;\\n            a = t;\\n\\n            t = x0;\\n\\n            x0 = x1 - q * x0;\\n\\n            x1 = t;\\n        }\\n        // Hacer x1 positivo\\n        if (x1 < 0) {\\n            x1 += m0;\\n        }\\n\\n        return x1;\\n    }\\n\\n    // k es el tama\xf1o de num [] y rem [].\\n    // Devuelve el n\xfamero m\xe1s peque\xf1o\\n    // x tal que:\\n    // x% num [0] = rem [0],\\n    // x% num [1] = rem [1],\\n    // ..................\\n    // x% num [k-2] = rem [k-1]\\n    // Supuesto: los n\xfameros en num [] son \\n    // coprimos por pares (mcd para cada par es 1)\\n    static int findMinX(int num[], int rem[], int k) {\\n        // Calcular el producto de todos los n\xfameros\\n        int prod = 1;\\n        for (int i = 0; i < k; i++) {\\n            prod *= num[i];\\n        }\\n        int result = 0;\\n        for (int i = 0; i < k; i++) {\\n            int pp = prod / num[i];\\n            result += rem[i] * inv(pp, num[i]) * pp;\\n        }\\n\\n        return result % prod;\\n    }\\n\\n    public static void main(String args[]) {\\n        int num[] = {3, 4, 5};\\n        int rem[] = {2, 3, 1};\\n        int k = num.length;\\n        System.out.println(\\"x is \\" + findMinX(num, rem, k));\\n    }\\n}\\n","cpp":"#include<bits/stdc++.h> \\nusing namespace std;\\n\\nint inv(int a, int m) {\\n    int m0 = m, t, q;\\n    int x0 = 0, x1 = 1;\\n    if (m == 1)\\n        return 0;\\n    while (a > 1) {\\n        q = a / m;\\n        t = m;\\n        m = a % m, a = t;\\n        t = x0;\\n        x0 = x1 - q * x0;\\n        x1 = t;\\n    }\\n    if (x1 < 0)\\n        x1 += m0;\\n    return x1;\\n}\\n\\nint findMinX(int num[], int rem[], int k) {\\n    int prod = 1;\\n    for (int i = 0; i < k; i++)\\n        prod *= num[i];\\n    int result = 0;\\n    for (int i = 0; i < k; i++) {\\n        int pp = prod / num[i];\\n        result += rem[i] * inv(pp, num[i]) * pp;\\n    }\\n    return result % prod;\\n}\\n\\nint main(void) {\\n    int num[] = {3, 4, 5};\\n    int rem[] = {2, 3, 1};\\n    int k = sizeof (num) / sizeof (num[0]);\\n    cout << \\"x is \\" << findMinX(num, rem, k);\\n    return 0;\\n}\\n","py":"def inv(a, m): \\n    m0 = m \\n    x0 = 0\\n    x1 = 1\\n    if (m == 1): \\n        return 0\\n    while (a > 1): \\n        q = a // m \\n        t = m \\n        m = a % m \\n        a = t \\n        t = x0 \\n        x0 = x1 - q * x0 \\n        x1 = t \\n    if (x1 < 0): \\n        x1 = x1 + m0 \\n    return x1 \\n\\ndef findMinX(num, rem, k): \\n    prod = 1\\n    for i in range(0, k): \\n        prod = prod * num[i] \\n    result = 0\\n    for i in range(0, k): \\n        pp = prod // num[i] \\n        result = result + rem[i] * inv(pp, num[i]) * pp \\n    return result % prod \\nnum = [3, 4, 5] \\nrem = [2, 3, 1] \\nk = len(num) \\nprint(\\"x is \\", findMinX(num, rem, k)) \\n","orden":6,"suborden":65,"fecha_creacion":"2020-12-05 01:56:11","fecha_modificacion":"2022-03-08 14:36:15"},{"ID":173,"supergrupo":"Matem\xe1tica","tema":"Logaritmo discreto","texto":"Dados tres n\xfameros enteros a, b y m. Encuentre un n\xfamero entero k tal que a ^ k\u2261b donde a y m son primos relativos. Si no es posible que ning\xfan k satisfaga esta relaci\xf3n, imprima -1.","complejidad_tiempo":null,"java":"// Programa Java para calcular logaritmos discretos\\n\\npublic class DiscreteLogarithm {\\n\\n    /* Funci\xf3n iterativa para calcular (x ^ y)% p en\\n         O (log y) */\\n    static int powmod(int x, int y, int p) {\\n        int res = 1; // inicializar resultado\\n\\n        x = x % p; // Actualice x si es m\xe1s de o\\n        // igual a p\\n        while (y > 0) {\\n            // Si y es impar, multiplica x con el resultado\\n            if ((y & 1) > 0) {\\n                res = (res * x) % p;\\n            }\\n\\n            // y debe ser par ahora \\n            y = y >> 1; // y = y/2 \\n            x = (x * x) % p;\\n        }\\n        return res;\\n    }\\n\\n    // Funci\xf3n para calcular k para a, b, m dados\\n    static int discreteLogarithm(int a, int b, int m) {\\n\\n        int n = (int) (Math.sqrt(m) + 1);\\n\\n        int[] value = new int[m];\\n\\n        // Almacene todos los valores de a ^ (n * i) de LHS\\n        for (int i = n; i >= 1; --i) {\\n            value[powmod(a, i * n, m)] = i;\\n        }\\n\\n        for (int j = 0; j < n; ++j) {\\n            // Calcule (a ^ j) * by compruebe si hay colisi\xf3n\\n            int cur = (powmod(a, j, m) * b) % m;\\n            // Si ocurre una colisi\xf3n, es decir, LHS = RHS\\n            if (value[cur] > 0) {\\n                int ans = value[cur] * n - j;\\n                // Compruebe si y se encuentra por debajo de m o no\\n                if (ans < m) {\\n                    return ans;\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n\\n    public static void main(String[] args) {\\n        int a = 2, b = 3, m = 5;\\n        System.out.println(discreteLogarithm(a, b, m));\\n\\n        a = 3;\\n        b = 7;\\n        m = 11;\\n        System.out.println(discreteLogarithm(a, b, m));\\n    }\\n}\\n","cpp":"#include<bits/stdc++.h> \\nusing namespace std;\\n\\nint discreteLogarithm(int a, int b, int m) {\\n    int n = (int) sqrt(m) + 1;\\n    int an = 1;\\n    for (int i = 0; i < n; ++i)\\n        an = (an * a) % m;\\n    unordered_map<int, int> value;\\n    for (int i = 1, cur = an; i <= n; ++i) {\\n        if (!value[ cur ])\\n            value[ cur ] = i;\\n        cur = (cur * an) % m;\\n    }\\n    for (int i = 0, cur = b; i <= n; ++i) {\\n        if (value[cur]) {\\n            int ans = value[cur] * n - i;\\n            if (ans < m)\\n                return ans;\\n        }\\n        cur = (cur * a) % m;\\n    }\\n    return -1;\\n}\\n\\nint main() {\\n    int a = 2, b = 3, m = 5;\\n    cout << discreteLogarithm(a, b, m) << endl;\\n    a = 3, b = 7, m = 11;\\n    cout << discreteLogarithm(a, b, m);\\n}\\n","py":"import math\\n\\ndef powmod(x, y, p): \\n    res = 1; \\n    x = x % p;\\n    while (y > 0):  \\n        if (y & 1): \\n            res = (res * x) % p; \\n        y = y >> 1; # y = y/2 \\n        x = (x * x) % p; \\n    return res; \\n\\ndef discreteLogarithm(a, b, m): \\n    n = int(math.sqrt(m) + 1); \\n    value = [0] * m; \\n    for i in range(n, 0, -1): \\n        value[powmod (a, i * n, m)] = i; \\n    for j in range(n): \\n        cur = (powmod (a, j, m) * b) % m; \\n        if (value[cur]): \\n            ans = value[cur] * n - j; \\n            if (ans < m): \\n                return ans; \\n    return -1; \\n\\na = 2; \\nb = 3; \\nm = 5; \\nprint(discreteLogarithm(a, b, m)); \\na = 3; \\nb = 7; \\nm = 11; \\nprint(discreteLogarithm(a, b, m)); \\n","orden":6,"suborden":66,"fecha_creacion":"2020-12-05 01:56:11","fecha_modificacion":"2022-03-08 11:58:23"},{"ID":174,"supergrupo":"Matem\xe1tica","tema":"Eliminaci\xf3n Gaussiana","texto":"Nos ocuparemos de una matriz de coeficientes. La eliminaci\xf3n gaussiana no funciona en matrices singulares (conducen a la divisi\xf3n por cero).\\nEntrada: para N inc\xf3gnitas, la entrada es una matriz aumentada de tama\xf1o N x (N + 1). Una columna adicional es para el lado derecho \\n  mat[N][N+1] = {\\n\\t\\t   {3.0, 2.0,-4.0, 3.0},\\n                 {2.0, 3.0, 3.0, 15.0},\\n                 {5.0, -3, 1.0, 14.0}\\n                };\\nResultado: La soluci\xf3n a las ecuaciones es:\\n        3.000000\\n        1.000000\\n        2.000000\\n\\nExplicaci\xf3n:\\nLa matriz dada representa las siguientes ecuaciones\\n\\n3.0X1 + 2.0X2 - 4.0X3 =  3.0\\n2.0X1 + 3.0X2 + 3.0X3 = 15.0\\n5.0X1 - 3.0X2 +    X3 = 14.0\\n\\nExiste una soluci\xf3n \xfanica para las ecuaciones dadas, las soluciones son:\\nX1 = 3.0, X2 = 1.0, X3 = 2.0, \\n\\n\\nForma escalonada de fila: se dice que la matriz est\xe1 en r.e.f. si se cumplen las siguientes condiciones:\\n \\n1. El primer elemento distinto de cero en cada fila, llamado coeficiente principal, es 1.\\n2. Cada coeficiente principal est\xe1 en una columna a la derecha del coeficiente principal de la fila anterior.\\n3. Las filas con todos ceros est\xe1n debajo de las filas con al menos un elemento distinto de cero.\\n\\n \\nForma escalonada de fila reducida: se dice que la matriz est\xe1 en r.r.e.f. si se cumplen las siguientes condiciones:\\n1. Todas las condiciones para r.e.f.\\n2. El coeficiente principal de cada fila es la \xfanica entrada distinta de cero en su columna.\\nEl algoritmo trata principalmente de realizar una secuencia de operaciones en las filas de la matriz. Lo que nos gustar\xeda tener en cuenta al realizar estas operaciones es que queremos convertir la matriz en una matriz triangular superior en forma escalonada. Las operaciones pueden ser:\\n1. Intercambio de dos filas\\n2. Multiplicar una fila por un escalar distinto de cero\\n3. Agregar a una fila un m\xfaltiplo de otra\\n\\nEl proceso:\\n1. Eliminaci\xf3n hacia adelante: reducci\xf3n a la forma escalonada de fila. Us\xe1ndolo uno puede saber si no hay soluciones, o una soluci\xf3n \xfanica, o infinitas soluciones.\\n2. Sustituci\xf3n hacia atr\xe1s: reducci\xf3n adicional a la forma escalonada de fila reducida.\\n\\nAlgoritmo:\\n1. Pivote parcial: encuentre el k-\xe9simo pivote intercambiando filas, para mover la entrada con el valor absoluto m\xe1s grande a la posici\xf3n del pivote. Esto imparte estabilidad computacional al algoritmo.\\n2. Para cada fila debajo del pivote, calcule el factor f que hace que la entrada k sea cero, y para cada elemento de la fila reste el quinto m\xfaltiplo del elemento correspondiente en la fila k.\\n3. Repita los pasos anteriores para cada desconocido. Nos quedaremos con una r.e.f. parcial. matriz.\\nComplejidad de tiempo: Dado que para cada pivote recorremos la parte a su derecha para cada fila debajo de \xe9l, O (n) * (O (n) * O (n)) = O (n3).\\nTambi\xe9n podemos aplicar la eliminaci\xf3n gaussiana para calcular:\\n1. Rango de una matriz\\n2. Determinante de una matriz\\n3. Inversa de una matriz cuadrada invertible\\n","complejidad_tiempo":null,"java":"//Resuelve sistemas de ecuaciones lineales \\n//por eliminaci\xf3n Gaussiana. matrix contiene los \\n//valores de la matriz cuadrada y result los resultados de \\n//las ecuaciones. Retorna un vector con el valor de las n \\n//incongnitas. Los resultados pueden necesitar redondeo.\\n\\nimport java.util.ArrayList;\\nimport java.util.Random;\\n\\npublic class GaussianElimination {\\n\\n    static int MAX = 100;\\n    static int n = 3;\\n    static double matrix[][] = new double[MAX][MAX];\\n    static double result[] = new double[MAX];\\n\\n    static ArrayList<Double> gauss() {\\n        ArrayList<Double> ans = new ArrayList<Double>();\\n        for (int i = 0; i < n; i++) {\\n            ans.add(0.0);\\n        }\\n        double temp;\\n        for (int i = 0; i < n; i++) {\\n            int pivot = i;\\n            for (int j = i + 1; j < n; j++) {\\n                temp = Math.abs(matrix[j][i]) - Math.abs(matrix[pivot][i]);\\n                if (temp > 0.000001) {\\n                    pivot = j;\\n                }\\n            }\\n            double temp2[] = new double[n];\\n            System.arraycopy(matrix[i], 0, temp2, 0, n);\\n            System.arraycopy(matrix[pivot], 0, matrix[i], 0, n);\\n            System.arraycopy(temp2, 0, matrix[pivot], 0, n);\\n            temp = result[i];\\n            result[i] = result[pivot];\\n            result[pivot] = temp;\\n            if (!(Math.abs(matrix[i][i]) < 0.000001)) {\\n                for (int k = i + 1; k < n; k++) {\\n                    temp = -matrix[k][i] / matrix[i][i];\\n                    matrix[k][i] = 0;\\n                    for (int l = i + 1; l < n; l++) {\\n                        matrix[k][l] += matrix[i][l] * temp;\\n                    }\\n                    result[k] += result[i] * temp;\\n                }\\n            }\\n        }\\n        for (int m = n - 1; m >= 0; m--) {\\n            temp = result[m];\\n            for (int i = n - 1; i > m; i--) {\\n                temp -= ans.get(i) * matrix[m][i];\\n            }\\n            ans.set(m, temp / matrix[m][m]);\\n        }\\n        return ans;\\n    }\\n\\n    public static void main(String[] args) {\\n        Random r = new Random();\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < n; j++) {\\n                matrix[i][j] = r.nextInt(20);\\n            }\\n        }\\n        for (int i = 0; i < n; i++) {\\n            result[i] = r.nextInt(10);\\n        }\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < n; j++) {\\n                System.out.print(matrix[i][j] + \\" \\");\\n            }\\n            System.out.print(\\"= \\" + result[i]);\\n            System.out.println(\\"\\");\\n        }\\n        ArrayList<Double> res = gauss();\\n        for (Double re : res) {\\n            System.out.print(re + \\" \\");\\n        }\\n    }\\n}\\n","cpp":"#include <bits/stdc++.h>\\n#include <cstdlib>\\nusing namespace std;\\nconst int MAX = 100;\\nint n = 3;\\ndouble matrix[MAX][MAX];\\ndouble result[MAX];\\n\\nvector<double> gauss() {\\n    vector<double> ans;\\n    for (int i = 0; i < n; i++) {\\n        ans.emplace_back(0.0);\\n    }\\n    double temp;\\n    for (int i = 0; i < n; i++) {\\n        int pivot = i;\\n        for (int j = i + 1; j < n; j++) {\\n            temp = abs(matrix[j][i]) - abs(matrix[pivot][i]);\\n            if (temp > 0.000001) {\\n                pivot = j;\\n            }\\n        }\\n        double temp2[n];\\n        copy(matrix[i], matrix[i] + n, temp2);\\n        copy(matrix[pivot], matrix[pivot] + n, matrix[i]);\\n        copy(temp2, temp2 + n, matrix[pivot]);\\n        temp = result[i];\\n        result[i] = result[pivot];\\n        result[pivot] = temp;\\n        if (!(abs(matrix[i][i]) < 0.000001)) {\\n            for (int k = i + 1; k < n; k++) {\\n                temp = -matrix[k][i] / matrix[i][i];\\n                matrix[k][i] = 0;\\n                for (int l = i + 1; l < n; l++) {\\n                    matrix[k][l] += matrix[i][l] * temp;\\n                }\\n                result[k] += result[i] * temp;\\n            }\\n        }\\n    }\\n    for (int m = n - 1; m >= 0; m--) {\\n        temp = result[m];\\n        for (int i = n - 1; i > m; i--) {\\n            temp -= ans.at(i) * matrix[m][i];\\n        }\\n        auto itPos = ans.begin() + m;\\n        ans.insert(itPos, temp / matrix[m][m]);\\n        itPos = ans.begin() + m + 1;\\n        ans.erase(itPos);\\n    }\\n    return ans;\\n}\\n\\nint main() {\\n    for (int i = 0; i < n; i++) {\\n        for (int j = 0; j < n; j++) {\\n            matrix[i][j] = rand() % 100;\\n        }\\n    }\\n    for (int i = 0; i < n; i++) {\\n        result[i] = rand() % 100;\\n    }\\n    for (int i = 0; i < n; i++) {\\n        for (int j = 0; j < n; j++) {\\n            cout << matrix[i][j] << \\" \\";\\n        }\\n        cout << \\"= \\" << result[i];\\n        cout << endl;\\n    }\\n    vector<double> res = gauss();\\n    for (double re : res) {\\n        cout << re << \\" \\";\\n    }\\n}\\n","py":"import math\\nimport random as rand\\nMAX = 100\\nn = 3\\nmatrix = [[0.0 for i in range (MAX)]for i in range (MAX)]\\nresult = [0.0 for i in range (MAX)]\\ndef gauss():\\n    ans = [0.0 for i in range (n)]\\n    for i in range (n):\\n        pivot = i\\n        for j in range (i + 1, n-1, -1):\\n            temp = abs(matrix[j][i]) - abs(matrix[pivot][i])\\n            if (temp > 0.000001):\\n                pivot = j;\\n        temp2 = [0.0 for k in range (n)]\\n        temp2 = matrix[i]\\n        matrix[i] = matrix[pivot]\\n        matrix[pivot] = temp2\\n        temp = result[i]\\n        result[i] = result[pivot]\\n        result[pivot] = temp\\n        if (not(abs(matrix[i][i]) < 0.000001)):\\n            for k in range (i + 1, n-1, -1):\\n                temp = -matrix[k][i] / matrix[i][i]\\n                matrix[k][i] = 0\\n                for l in range (i + 1, n-1, -1):\\n                    matrix[k][l] += matrix[i][l] * temp\\n                result[k] += result[i] * temp;\\n    for m in range (n-1, 0-1, -1):            \\n        temp = result[m]\\n        for i in range (n-1, m-1, -1):\\n            temp -= ans[i] * matrix[m][i]\\n        ans[m] = matrix[m][m]\\n    return ans\\n\\nfor i in range (n):\\n    for j in range (n):\\n        matrix[i][j] = rand.randint(0, 100)\\nfor i in range (n):\\n    result[i] = rand.randint(0, 100)\\nfor i in range (n):\\n    print(matrix[i][0:3])\\n    print(\\"= \\" + str(result[i]))\\nres = gauss();\\nprint(res)\\n","orden":6,"suborden":67,"fecha_creacion":"2020-12-05 01:56:11","fecha_modificacion":"2022-03-08 11:58:23"},{"ID":175,"supergrupo":"Matem\xe1tica","tema":"\xdaltimos dos d\xedgitos de una potencia de 2","texto":"Dado un n\xfamero n, necesitamos encontrar los dos \xfaltimos d\xedgitos de 2n.\\nEjemplos:\\nEntrada: n = 7\\nSalida: 28\\n\\nEntrada: n = 72\\nSalida: 96\\n2 ^ 72 = 4722366482869645213696\\n\\nLa forma eficiente es mantener solo 2 d\xedgitos despu\xe9s de cada multiplicaci\xf3n. Esta idea es muy similar a la discutida en Exponenciaci\xf3n modular donde se discute una forma general de encontrar (a ^ b)% c, aqu\xed en este caso c es 10 ^ 2 ya que los dos \xfaltimos d\xedgitos solo son necesarios.\\n","complejidad_tiempo":null,"java":"// C\xf3digo Java para encontrar los 2 \xfaltimos d\xedgitos de 2 ^ n\\n\\npublic class LastTwoDigits2powN {\\n\\n    /* Funci\xf3n iterativa para calcular (x ^ y)% p en O (log y) */\\n    static int power(long x, long y,\\n            long p) {\\n        int res = 1; // Inicializar resultado\\n        x = x % p; // Actualiza x si es mayor o igual que p\\n        while (y > 0) {\\n            // Si y es impar, multiplica x con el resultado \\n            long r = y & 1;\\n            if (r == 1) {\\n                res = (res * (int) x) % (int) p;\\n            }\\n            // y debe ser par ahora\\n            y = y >> 1; // y = y/2 \\n            x = (x * x) % p;\\n        }\\n        return res;\\n    }\\n\\n    // funci\xf3n para calcular el n\xfamero de d\xedgitos en x\\n    static int numberOfDigits(int x) {\\n        int i = 0;\\n        while (x != 0) {\\n            x /= 10;\\n            i++;\\n        }\\n        return i;\\n    }\\n\\n    // Funci\xf3n Java para imprimir los \xfaltimos 2 d\xedgitos de 2 ^ n\\n    static void LastTwoDigit(int n) {\\n        System.out.print(\\"Last \\" + 2\\n                + \\" digits of \\" + 2 + \\"^\\");\\n        System.out.print(n + \\" = \\");\\n\\n        // Generando 10 ^ 2\\n        int temp = 1;\\n        for (int i = 1; i <= 2; i++) {\\n            temp *= 10;\\n        }\\n        // Llamar exponenciaci\xf3n modular\\n        temp = power(2, n, temp);\\n\\n        // Imprimiendo ceros m\xe1s a la izquierda. Dado que (2 ^ n)% 2 puede \\n        // tener d\xedgitos menores que 2. En ese caso, necesitamos imprimir ceros\\n        for (int i = 0;\\n                i < (2 - numberOfDigits(temp)); i++) {\\n            System.out.print(0 + \\" \\");\\n        }\\n\\n        // Si la temperatura no es cero, imprima la temperatura.\\n        // Si la temperatura es cero, entonces ya est\xe1 impreso\\n        if (temp != 0) {\\n            System.out.println(temp);\\n        }\\n    }\\n\\n    public static void main(String[] args) {\\n        int n = 72;\\n        LastTwoDigit(n);\\n    }\\n}\\n","cpp":"#include <cstdlib>\\n#include <bits/stdc++.h> \\nusing namespace std;\\n\\nint power(long x, long y, long p) {\\n    int res = 1;\\n    x = x % p;\\n    while (y > 0) {\\n        long r = y & 1;\\n        if (r == 1) {\\n            res = (res * (int) x) % (int) p;\\n        }\\n        y = y >> 1;\\n        x = (x * x) % p;\\n    }\\n    return res;\\n}\\n\\nint numberOfDigits(int x) {\\n    int i = 0;\\n    while (x != 0) {\\n        x /= 10;\\n        i++;\\n    }\\n    return i;\\n}\\n\\nvoid LastTwoDigit(int n) {\\n    cout << \\"Last \\" << 2 << \\"digits of \\" << 2 << \\"^\\";\\n    cout << n << \\" = \\";\\n    int temp = 1;\\n    for (int i = 1; i <= 2; i++) {\\n        temp *= 10;\\n    }\\n    temp = power(2, n, temp);\\n    for (int i = 0;\\n            i < (2 - numberOfDigits(temp)); i++) {\\n        cout << 0 << \\" \\";\\n    }\\n    if (temp != 0) {\\n        cout << temp << endl;\\n    }\\n}\\n\\nint main() {\\n    int n = 72;\\n    LastTwoDigit(n);\\n}\\n","py":"def power(x, y, p):\\n    res = 1\\n    x = x % p\\n    while (y > 0):\\n        r = y & 1\\n        if (r == 1):\\n            res = (res * int (x)) % int(p)\\n        y = y >> 1\\n        x = (x * x) % p\\n    return res\\n\\ndef numberOfDigits(x):\\n    i = 0\\n    while (x != 0):\\n        x /= 10\\n        i += 1\\n    return i\\n\\ndef LastTwoDigit(n):\\n    print(\\"Last \\" + str(2) + \\"digits of \\" + str(2) + \\"^\\" + str(n) + \\" = \\")\\n    temp = 1\\n    for i in range (1, 3):\\n        temp *= 10\\n    temp = power(2, n, temp)\\n    aux = (2 - numberOfDigits(temp))\\n    for i in range (aux):\\n        print(str(0) + \\" \\")\\n    if (temp != 0):\\n        print(temp);\\nn = 72\\nLastTwoDigit(n)\\n","orden":6,"suborden":68,"fecha_creacion":"2020-12-05 01:56:12","fecha_modificacion":"2022-03-08 11:58:23"},{"ID":176,"supergrupo":"Matem\xe1tica","tema":"Ecuaciones lineales diofantinas","texto":"Una ecuaci\xf3n diof\xe1ntica es una ecuaci\xf3n polinomial, generalmente en dos o m\xe1s inc\xf3gnitas, de modo que solo se requieren las soluciones integrales. Una soluci\xf3n integral es una soluci\xf3n tal que todas las variables desconocidas toman solo valores enteros.\\n\\nDados tres n\xfameros enteros a, b, c que representan una ecuaci\xf3n lineal de la forma: ax + by = c. Determina si la ecuaci\xf3n tiene una soluci\xf3n tal que xey son ambos valores integrales.\\n\\nEjemplos:\\nEntrada: a = 3, b = 6, c = 9\\nSalida: posible\\nExplicaci\xf3n: La ecuaci\xf3n resulta ser,\\n3x + 6y = 9 una soluci\xf3n integral ser\xeda\\nx = 1, y = 1\\n\\nEntrada: a = 3, b = 6, c = 8\\nSalida: no posible\\nExplicaci\xf3n: o valores integrales de x e y\\nexiste que puede satisfacer la ecuaci\xf3n 3x + 6y = 8\\n\\nEntrada: a = 2, b = 5, c = 1\\nSalida: posible\\nExplicaci\xf3n: Varias soluciones integrales\\nposibles son, (-2,1), (3, -1) etc.\\n\\nPara las ecuaciones lineales de ecuaciones diof\xe1nticas, existen soluciones integrales si y solo si, el MCD de los coeficientes de las dos variables divide perfectamente el t\xe9rmino constante. En otras palabras, la soluci\xf3n integral existe si, MCD (a, b) divide c.\\nPor tanto, el algoritmo para determinar si una ecuaci\xf3n tiene una soluci\xf3n integral es bastante sencillo.\\n\\n\u2022 Encuentra MCD de a y b\\n\u2022 Compruebe si c% GCD (a, b) == 0\\n\u2022 Si es as\xed, imprima Posible\\n\u2022 Otra impresi\xf3n no es posible\\n","complejidad_tiempo":null,"java":"// Programa Java para buscar soluciones de ecuaciones diof\xe1nticas\\n\\npublic class LinearDiophantineEquations {\\n\\n    // Funci\xf3n de utilidad para encontrar el GCD de dos n\xfameros\\n    static int gcd(int a, int b) {\\n        return (a % b == 0)\\n                ? Math.abs(b) : gcd(b, a % b);\\n    }\\n\\n    // Esta funci\xf3n comprueba si son posibles soluciones enteras\\n    static boolean isPossible(int a,\\n            int b, int c) {\\n        return (c % gcd(a, b) == 0);\\n    }\\n\\n    public static void main(String[] args) {\\n        int a = 3, b = 6, c = 9;\\n        if (isPossible(a, b, c)) {\\n            System.out.println(\\"Possible\\");\\n        } else {\\n            System.out.println(\\"Not Possible\\");\\n        }\\n        a = 3;\\n        b = 6;\\n        c = 8;\\n        if (isPossible(a, b, c)) {\\n            System.out.println(\\"Possible\\");\\n        } else {\\n            System.out.println(\\"Not Possible\\");\\n        }\\n        a = 2;\\n        b = 5;\\n        c = 1;\\n        if (isPossible(a, b, c)) {\\n            System.out.println(\\"Possible\\");\\n        } else {\\n            System.out.println(\\"Not Possible\\");\\n        }\\n    }\\n}\\n","cpp":"#include <cstdlib>\\n#include <bits/stdc++.h> \\nusing namespace std;\\n\\nint gcd(int a, int b) {\\n    return (a % b == 0) ? abs(b) : gcd(b, a % b);\\n}\\n\\nbool isPossible(int a, int b, int c) {\\n    return (c % gcd(a, b) == 0);\\n}\\n\\nint main() {\\n    int a = 3, b = 6, c = 9;\\n    if (isPossible(a, b, c)) {\\n        cout << \\"Possible\\" << endl;\\n    } else {\\n        cout << \\"Not Possible\\" << endl;\\n    }\\n    a = 3;\\n    b = 6;\\n    c = 8;\\n    if (isPossible(a, b, c)) {\\n        cout << \\"Possible\\" << endl;\\n    } else {\\n        cout << \\"Not Possible\\" << endl;\\n    }\\n    a = 2;\\n    b = 5;\\n    c = 1;\\n    if (isPossible(a, b, c)) {\\n        cout << \\"Possible\\" << endl;\\n    } else {\\n        cout << \\"Not Possible\\" << endl;\\n    }\\n}\\n","py":"def gcd(a, b):\\n    if(a % b == 0):\\n        return abs(b)\\n    else:\\n        return gcd(b, a % b)\\n\\ndef isPossible(a, b, c):\\n    return (c % gcd(a, b) == 0)\\na = 3\\nb = 6\\nc = 9\\nif (isPossible(a, b, c)):\\n    \\n    print(\\"Possible\\")\\nelse:\\n    print(\\"Not Possible\\") \\na = 3\\nb = 6\\nc = 8\\nif (isPossible(a, b, c)):\\n    print(\\"Possible\\")\\nelse:\\n    print(\\"Not Possible\\")\\na = 2;\\nb = 5;\\nc = 1;\\nif (isPossible(a, b, c)):\\n    print(\\"Possible\\")\\nelse:\\n    print(\\"Not Possible\\")\\n","orden":6,"suborden":69,"fecha_creacion":"2020-12-05 01:56:12","fecha_modificacion":"2022-03-08 12:01:48"},{"ID":177,"supergrupo":"Matem\xe1tica","tema":"Exponenciaci\xf3n de matrices","texto":"\xbfCu\xe1l es la complejidad de tiempo m\xednima para encontrar el n\xfamero n de Fibonacci?\\nPodemos encontrar el n\xfamero n de Fibonacci en el tiempo O (Log n) usando la exponenciaci\xf3n matricial.\\n\\nPara resolver la exponenciaci\xf3n matricial asumimos un ecuaci\xf3n de recurrencia lineal como a continuaci\xf3n:\\nF (n) = a * F (n-1) + segundo * F (n-2) + c * F (n-3) para n> = 3\\n. . . . . Ecuaci\xf3n (1) donde a, b y c son constantes.\\n\\nPara esta relaci\xf3n de recurrencia, depende de tres valores anteriores.\\nAhora intentaremos representar la Ecuaci\xf3n (1) en t\xe9rminos de la matriz.\\n\\n[First Matrix] = [Second matrix] * [Third Matrix]\\n| F(n)   |     =   Matrix \'C\'    *  | F(n-1) |\\n| F(n-1) |                          | F(n-2) |\\n| F(n-2) |                          | F(n-3) |\\n \\nLa dimensi\xf3n de la primera matriz es 3 x 1.\\nLa dimensi\xf3n de la tercera matriz tambi\xe9n es 3 x 1.\\n\\nEntonces la dimensi\xf3n de la segunda matriz debe ser 3 x 3\\n[Para que se cumpla la regla de la multiplicaci\xf3n.]\\n\\nAhora necesitamos llenar la Matriz \'C\'.\\n\\nEntonces de acuerdo con nuestra ecuaci\xf3n.\\nF(n) = a*F(n-1) + b*F(n-2) + c*F(n-3)\\nF(n-1) = F(n-1)\\nF(n-2) = F(n-2)\\n\\nC = [a b c\\n     1 0 0\\n     0 1 0]\\n\\nAhora la relaci\xf3n entre la matriz se convierte en: \\n[First Matrix]  [Second matrix]       [Third Matrix]\\n| F(n)   |  =  | a b c |  *           | F(n-1) |\\n| F(n-1) |     | 1 0 0 |              | F(n-2) |\\n| F(n-2) |     | 0 1 0 |              | F(n-3) |\\n\\nSupongamos los valores iniciales para este caso: -\\nF(0) = 0\\nF(1) = 1\\nF(2) = 1\\n\\nEntonces, necesitamos obtener F (n) en t\xe9rminos de estos valores.\\n\\nEntonces, para n = 3, la ecuaci\xf3n (1) cambia a\\n| F(3) |  =  | a b c |  *           | F(2) |\\n| F(2) |     | 1 0 0 |              | F(1) |\\n| F(1) |     | 0 1 0 |              | F(0) |\\n\\nAhora de manera similar para n = 4\\n| F(4) |  =  | a b c |  *           | F(3) |\\n| F(3) |     | 1 0 0 |              | F(2) |\\n| F(2) |     | 0 1 0 |              | F(1) |\\n\\n             - - - -  2 veces - - -\\n| F(4) |  =  | a b c |  * | a b c | *       | F(2) |\\n| F(3) |     | 1 0 0 |    | 1 0 0 |         | F(1) |\\n| F(2) |     | 0 1 0 |    | 0 1 0 |         | F(0) |\\n\\nEntonces, para in, la Ecuaci\xf3n (1) cambia a\\n\\n                - - - - - - - - n -2 veces - - - -  -       \\n| F(n)   |  =  | a b c | * | a b c | * ... * | a b c | * | F(2) |\\n| F(n-1) |     | 1 0 0 |   | 1 0 0 |         | 1 0 0 |   | F(1) |\\n| F(n-2) |     | 0 1 0 |   | 0 1 0 |         | 0 1 0 |   | F(0) |\\n\\n\\n| F(n)   |  =  [ | a b c | ] ^ (n-2)   *  | F(2) |\\n| F(n-1) |     [ | 1 0 0 | ]              | F(1) |\\n| F(n-2) |     [ | 0 1 0 | ]              | F(0) |\\n\\nEntonces, simplemente podemos multiplicar nuestra Segunda matriz n-2 veces y luego multiplicarla con la tercera matriz para obtener el resultado. La multiplicaci\xf3n se puede hacer en (log n) tiempo usando el algoritmo Divide and Conquer para el poder.\\n\\nConsideremos el problema de encontrar el t\xe9rmino n de una serie definida usando la siguiente recurrencia.\\nen\xe9simo t\xe9rmino,\\n     F (n) = F (n-1) + F (n-2) + F (n-3), n> = 3\\nCasos base:\\n     F (0) = 0, F (1) = 1, F (2) = 1\\nPodemos encontrar el t\xe9rmino n usando lo siguiente:\\nPoniendo a = 1, b = 1 y c = 1 en la f\xf3rmula anterior\\n\\n| F(n)   |  =  [ | 1 1 1 | ] ^ (n-2)   *  | F(2) |\\n| F(n-1) |     [ | 1 0 0 | ]              | F(1) |\\n| F(n-2) |     [ | 0 1 0 | ]              | F(0) \\nComplejidad temporal de esta soluci\xf3n: O (log n)\\n","complejidad_tiempo":null,"java":"// Programa JAVA para encontrar el valor de f (n) donde\\n// f (n) se define como\\n// F (n) = F (n-1) + F (n-2) + F (n-3), n> = 3\\n// Casos base:\\n// F (0) = 0, F (1) = 1, F (2) = 1\\n\\npublic class MatrixExponentiation {\\n\\n    // Una funci\xf3n de utilidad para multiplicar dos matrices a [][] y b [][]. \\n    // El resultado de la multiplicaci\xf3n se almacena en b [][]\\n    static void multiply(int a[][], int b[][]) {\\n        // Crear una matriz auxiliar para almacenar elementos \\n        // de la matriz de multiplicaci\xf3n.\\n        int mul[][] = new int[3][3];\\n        for (int i = 0; i < 3; i++) {\\n            for (int j = 0; j < 3; j++) {\\n                mul[i][j] = 0;\\n                for (int k = 0; k < 3; k++) {\\n                    mul[i][j] += a[i][k]\\n                            * b[k][j];\\n                }\\n            }\\n        }\\n\\n        // almacenar el resultado de la multiplicaci\xf3n en a [][]\\n        for (int i = 0; i < 3; i++) {\\n            for (int j = 0; j < 3; j++) // Actualizando nuestra matriz\\n            {\\n                a[i][j] = mul[i][j];\\n            }\\n        }\\n    }\\n\\n    // Funci\xf3n para calcular F subir a potencia n-2.\\n    static int power(int F[][], int n) {\\n        int M[][] = {{1, 1, 1}, {1, 0, 0},\\n        {0, 1, 0}};\\n        // Multipl\xedquelo con valores iniciales, es decir, con F (0) = 0,\\n        // F (1) = 1, F (2) = 1\\n        if (n == 1) {\\n            return F[0][0] + F[0][1];\\n        }\\n        power(F, n / 2);\\n        multiply(F, F);\\n        if (n % 2 != 0) {\\n            multiply(F, M);\\n        }\\n        // Multipl\xedquelo con valores iniciales, es decir, \\n        // con F (0) = 0, F (1) = 1, F (2) = 1\\n        return F[0][0] + F[0][1];\\n    }\\n\\n    // Devuelve el n-\xe9simo t\xe9rmino de una serie definida\\n    // usando la siguiente relaci\xf3n de recurrencia.\\n    // f (n) se define como\\n    // f (n) = f (n-1) + f (n-2) + f (n-3), n> = 3\\n    // Casos base:\\n    // f (0) = 0, f (1) = 1, f (2) = 1\\n    static int findNthTerm(int n) {\\n        int F[][] = {{1, 1, 1}, {1, 0, 0},\\n        {0, 1, 0}};\\n\\n        return power(F, n - 2);\\n    }\\n\\n    public static void main(String[] args) {\\n        int n = 5;\\n        System.out.println(\\"F(5) is \\" + findNthTerm(n));\\n    }\\n}\\n","cpp":"#include<bits/stdc++.h> \\nusing namespace std;\\n\\nvoid multiply(int a[3][3], int b[3][3]) {\\n    int mul[3][3];\\n    for (int i = 0; i < 3; i++) {\\n        for (int j = 0; j < 3; j++) {\\n            mul[i][j] = 0;\\n            for (int k = 0; k < 3; k++) {\\n                mul[i][j] += a[i][k]\\n                        * b[k][j];\\n            }\\n        }\\n    }\\n    for (int i = 0; i < 3; i++) {\\n        for (int j = 0; j < 3; j++) {\\n            a[i][j] = mul[i][j];\\n        }\\n    }\\n}\\n\\nint power(int F[3][3], int n) {\\n    int M[3][3] = {\\n        {1, 1, 1},\\n        {1, 0, 0},\\n        {0, 1, 0}\\n    };\\n    if (n == 1) {\\n        return F[0][0] + F[0][1];\\n    }\\n    power(F, n / 2);\\n    multiply(F, F);\\n    if (n % 2 != 0) {\\n        multiply(F, M);\\n    }\\n    return F[0][0] + F[0][1];\\n}\\n\\nint findNthTerm(int n) {\\n    int F[3][3] = {\\n        {1, 1, 1},\\n        {1, 0, 0},\\n        {0, 1, 0}\\n    };\\n\\n    return power(F, n - 2);\\n}\\n\\nint main() {\\n    int n = 5;\\n    cout << \\"F(5) is \\" << findNthTerm(n) << endl;\\n}\\n","py":"def multiply(a, b):\\n    mul = [[0 for i in range (3)]for j in range (3)]\\n    for i in range (3):\\n        for j in range(3):\\n            mul[i][j] = 0\\n            for k in range(3):\\n                mul[i][j] += a[i][k] * b[k][j]\\n    for i in range (3):\\n        for j in range(3):\\n            a[i][j] = mul[i][j]\\n \\ndef power(F, n):\\n    M = [[1, 1, 1],\\n        [1, 0, 0],\\n        [0, 1, 0]]\\n    if (n == 1):\\n        return F[0][0] + F[0][1]\\n    power(F, n / 2)\\n    multiply(F, F)\\n    if (n % 2 != 0):\\n        multiply(F, M)\\n    return F[0][0] + F[0][1]\\n\\ndef findNthTerm(n):\\n    F = [[1, 1, 1],\\n        [1, 0, 0],\\n        [0, 1, 0]]\\n    return power(F, n - 2)\\n\\nn = 5\\nprint(\\"F(5) is \\" + str(findNthTerm(n)));\\n","orden":6,"suborden":70,"fecha_creacion":"2020-12-05 01:56:12","fecha_modificacion":"2022-03-08 12:01:47"},{"ID":178,"supergrupo":"Matem\xe1tica","tema":"Verificaci\xf3n de cuadrados m\xe1gicos","texto":"Dada una matriz, comprueba si es un cuadrado m\xe1gico o no. Un cuadrado m\xe1gico es una matriz n x n de elementos distintos de 1 a n2 donde la suma de cualquier fila, columna o diagonal es siempre igual al mismo n\xfamero.\\nEjemplos:\\nEntrada: n = 3\\n 2   7   6\\n  9   5   1\\n  4   3   8\\nSalida: matriz m\xe1gica\\nExplicaci\xf3n: En la matriz, la suma de cada fila y cada columna y la suma diagonal es igual = 15.\\n\\nEntrada: n = 3\\n  1   2   2 \\n  2   2   1\\n  2   1   2\\nResultado: No es una matriz m\xe1gica\\nExplicaci\xf3n: En la matriz, la suma de cada fila y cada columna y la suma de las diagonales no es la misma.\\n\\n1. Encuentre la suma de la diagonal principal y la diagonal secundaria.\\n2. Calcule la suma de cada fila y columna.\\n3. Si la suma de la diagonal principal y la diagonal secundaria es igual a la suma de cada fila y la suma de cada columna, entonces es una matriz m\xe1gica.\\n","complejidad_tiempo":null,"java":"// Programa JAVA para verificar si una matriz dada es matriz m\xe1gica o no\\n\\npublic class IsMagicSquare {\\n\\n    static int N = 3;\\n\\n    // Devuelve verdadero si mat [][] es un cuadrado m\xe1gico, de lo contrario devuelve falso.\\n    static boolean isMagicSquare(int mat[][]) {\\n\\n        // calcular la suma de la diagonal prima\\n        int sum = 0, sum2 = 0;\\n        for (int i = 0; i < N; i++) {\\n            sum = sum + mat[i][i];\\n        }\\n\\n        // la diagonal secundaria\\n        for (int i = 0; i < N; i++) {\\n            sum2 = sum2 + mat[i][N - 1 - i];\\n        }\\n\\n        if (sum != sum2) {\\n            return false;\\n        }\\n\\n        // Para sumas de filas\\n        for (int i = 0; i < N; i++) {\\n\\n            int rowSum = 0;\\n            for (int j = 0; j < N; j++) {\\n                rowSum += mat[i][j];\\n            }\\n\\n            // compruebe si la suma de cada fila es igual a la suma diagonal principal\\n            if (rowSum != sum) {\\n                return false;\\n            }\\n        }\\n\\n        // Para sumas de columnas\\n        for (int i = 0; i < N; i++) {\\n\\n            int colSum = 0;\\n            for (int j = 0; j < N; j++) {\\n                colSum += mat[j][i];\\n            }\\n\\n            // compruebe si la suma de cada columna es igual \\n            // a la suma diagonal principal\\n            if (sum != colSum) {\\n                return false;\\n            }\\n        }\\n\\n        return true;\\n    }\\n\\n    public static void main(String[] args) {\\n        int mat[][] = {{2, 7, 6},\\n        {9, 5, 1},\\n        {4, 3, 8}};\\n\\n        if (isMagicSquare(mat)) {\\n            System.out.println(\\"Magic Square\\");\\n        } else {\\n            System.out.println(\\"Not a magic\\"\\n                    + \\" Square\\");\\n        }\\n    }\\n}\\n","cpp":"#include <bits/stdc++.h> \\n\\n#define N 3 \\nusing namespace std;\\n\\nbool isMagicSquare(int mat[][N]) {\\n\\n    int sum = 0, sum2 = 0;\\n    for (int i = 0; i < N; i++)\\n        sum = sum + mat[i][i];\\n    for (int i = 0; i < N; i++)\\n        sum2 = sum2 + mat[i][N - 1 - i];\\n\\n    if (sum != sum2)\\n        return false;\\n\\n    for (int i = 0; i < N; i++) {\\n\\n        int rowSum = 0;\\n        for (int j = 0; j < N; j++)\\n            rowSum += mat[i][j];\\n\\n        if (rowSum != sum)\\n            return false;\\n    }\\n\\n\\n    for (int i = 0; i < N; i++) {\\n\\n        int colSum = 0;\\n        for (int j = 0; j < N; j++)\\n            colSum += mat[j][i];\\n        if (sum != colSum)\\n            return false;\\n    }\\n\\n    return true;\\n}\\n\\nint main() {\\n    int mat[][N] = {\\n        { 2, 7, 6},\\n        { 9, 5, 1},\\n        { 4, 3, 8}\\n    };\\n\\n    if (isMagicSquare(mat))\\n        cout << \\"Magic Square\\";\\n    else\\n        cout << \\"Not a magic Square\\";\\n\\n    return 0;\\n} \\n","py":"N = 3\\n\\ndef isMagicSquare(mat): \\n    s = 0 \\n    for i in range(0, N): \\n        s = s + mat[i][i] \\n\\n    s2 = 0\\n    for i in range(0, N): \\n        s2 = s2 + mat[i][N-i-1] \\n  \\n    if(s != s2): \\n        return False\\n \\n    for i in range(0, N): \\n        rowSum = 0;      \\n        for j in range(0, N): \\n            rowSum += mat[i][j] \\n         \\n        if (rowSum != s): \\n            return False\\n\\n    for i in range(0, N): \\n        colSum = 0\\n        for j in range(0, N): \\n            colSum += mat[j][i] \\n        if (s != colSum): \\n            return False\\n  \\n    return True\\n   \\nmat = [[2, 7, 6], \\n    [9, 5, 1], \\n    [4, 3, 8]] \\n      \\nif (isMagicSquare(mat)): \\n    print(\\"Magic Square\\") \\nelse: \\n    print(\\"Not a magic Square\\") \\n","orden":6,"suborden":71,"fecha_creacion":"2020-12-05 01:56:13","fecha_modificacion":"2022-03-08 12:01:48"},{"ID":179,"supergrupo":"Matem\xe1tica","tema":"B\xfasqueda de datos faltantes en cuadrados m\xe1gicos ","texto":"Dado un tapete de matriz de 3X3 con los elementos de la diagonal izquierda que faltan (establecido en 0), considerando que la suma de cada fila, columna y diagonal de la matriz original era igual, la tarea es encontrar los elementos diagonales que faltan e imprimir la matriz original.\\nEjemplos:\\nEntrada: mat[][] = {{0, 7, 6}, {9, 0, 1}, {4, 3, 0}}\\nSalida:\\n2 7 6\\n9 5 1\\n4 3 8\\nSuma de filas = Suma de columnas = Suma diagonal = 15\\nEntrada: mat[][] = {{0, 1, 1}, {1, 0, 1}, {1, 1, 0}}\\nSalida:\\n1 1 1\\n1 1 1\\n1 1 1\\nEnfoque: Sea Sum la suma total excluyendo los elementos diagonales,\\nSum = suma total de la matriz dada - diagonalSum\\nSuma = (3 * rowSum) - diagonalSum\\nSum = (2 * rowSum) [Dado que, columnSum = rowSum = diagonalSum]\\nrowSum = Sum / 2\\nPor lo tanto, podemos insertar un elemento en cada fila de modo que la suma de la fila sea rowSum\\n","complejidad_tiempo":null,"java":"// JPrograma Java para llenar espacios en blanco con n\xfameros\\n\\npublic class MagicSquareMissing {\\n\\n    // Funci\xf3n para imprimir la matriz original\\n    static int printFilledDiagonal(int sq[][]) {\\n        // Calcular la suma de todos los elementos de la matriz\\n        int sum = 0;\\n        for (int i = 0; i < 3; i++) {\\n            for (int j = 0; j < 3; j++) {\\n                sum += sq[i][j];\\n            }\\n        }\\n\\n        // Suma requerida de cada fila (del enfoque)\\n        sum /= 2;\\n\\n        for (int i = 0; i < 3; i++) {\\n            // Suma de filas excluyendo el elemento diagonal\\n            int rowSum = 0;\\n            for (int j = 0; j < 3; j++) {\\n                rowSum += sq[i][j];\\n            }\\n            // Elemento que debe insertarse en el \\n            // elemento diagonal de la fila actual\\n            sq[i][i] = sum - rowSum;\\n        }\\n\\n        // Imprime la matriz actualizada\\n        for (int i = 0; i < 3; i++) {\\n            for (int j = 0; j < 3; j++) {\\n                System.out.print(sq[i][j] + \\" \\");\\n            }\\n            System.out.println();\\n        }\\n        return 0;\\n    }\\n\\n    public static void main(String[] args) {\\n        int sq[][] = {\\n            {0, 7, 6},\\n            {9, 0, 1},\\n            {4, 3, 0}\\n        };\\n\\n        printFilledDiagonal(sq);\\n    }\\n\\n}\\n","cpp":"#include <bits/stdc++.h> \\nusing namespace std;\\n\\nint printFilledDiagonal(int sq[][3]) {\\n\\n    int sum = 0;\\n    for (int i = 0; i < 3; i++)\\n        for (int j = 0; j < 3; j++)\\n            sum += sq[i][j];\\n\\n    sum /= 2;\\n\\n    for (int i = 0; i < 3; i++) {\\n        int rowSum = 0;\\n        for (int j = 0; j < 3; j++)\\n            rowSum += sq[i][j];\\n        sq[i][i] = sum - rowSum;\\n    }\\n\\n    for (int i = 0; i < 3; i++) {\\n        for (int j = 0; j < 3; j++)\\n            cout << sq[i][j] << \\" \\";\\n        cout << endl;\\n    }\\n}\\n\\nint main() {\\n    int sq[3][3] = {\\n        { 0, 7, 6},\\n        { 9, 0, 1},\\n        { 4, 3, 0}\\n    };\\n\\n    printFilledDiagonal(sq);\\n    return 0;\\n} \\n","py":"def printFilledDiagonal(sq):  \\n  \\n    Sum = 0\\n    for i in range(0, 3):  \\n        for j in range(0, 3):  \\n            Sum += sq[i][j]  \\n \\n    Sum = Sum // 2\\n  \\n    for i in range(0, 3):  \\n        rowSum = 0\\n        for j in range(0, 3):  \\n            rowSum += sq[i][j]  \\n \\n        sq[i][i] = Sum - rowSum  \\n      \\n    for i in range(0, 3):  \\n        for j in range(0, 3):  \\n            print(sq[i][j], end=\\" \\")  \\n        print() \\n        \\nsq = [[0, 7, 6], \\n    [9, 0, 1], \\n    [4, 3, 0]]  \\n\\nprintFilledDiagonal(sq)  \\n      \\n","orden":6,"suborden":72,"fecha_creacion":"2020-12-05 01:56:13","fecha_modificacion":"2022-03-08 12:01:47"},{"ID":180,"supergrupo":"Matem\xe1tica","tema":"Intercambio m\xednimo entre esquinas","texto":"Dado el n\xfamero N de elementos, encuentre el n\xfamero m\xednimo de intercambios requeridos para que el elemento m\xe1ximo est\xe9 al principio y el elemento m\xednimo est\xe9 al final con la condici\xf3n de que solo se permita el intercambio de elementos adyacentes.\\n\\nEjemplos:\\nEntrada: a [] = {3, 1, 5, 3, 5, 5, 2}\\nSalida: 6\\nPaso 1: intercambie 5 con 1 para hacer el array como {3, 5, 1, 3, 5, 5, 2}\\nPaso 2: intercambia 5 por 3 para hacer el array como {5, 3, 1, 3, 5, 5, 2}\\nPaso 3: intercambia 1 con 3 a su derecha para hacer el array como {5, 3, 3, 1, 5, 5, 2}\\nPaso 4: intercambie 1 con 5 a su derecha para hacer el array como {5, 3, 3, 5, 1, 5, 2}\\nPaso 5: intercambia 1 con 5 a su derecha para hacer el array como {5, 3, 3, 5, 5, 1, 2}\\nPaso 6: intercambie 1 con 2 a su derecha para hacer el array como {5, 3, 3, 5, 5, 2, 1}\\nDespu\xe9s de realizar 6 operaciones de intercambio, 5 est\xe1 al principio y 1 al final\\nEntrada: a [] = {5, 6, 1, 3}\\nSalida: 2\\n\\nEl enfoque ser\xe1 encontrar el \xedndice del elemento m\xe1s grande (sea l). Encuentre el \xedndice del elemento m\xe1s grande m\xe1s a la izquierda si el elemento m\xe1s grande aparece en el array m\xe1s de una vez. De manera similar, encuentre el \xedndice del elemento m\xe1s peque\xf1o m\xe1s a la derecha (sea r). Existen dos casos para solucionar este problema.\\n1. Caso 1: Si l <r: N\xfamero de intercambios = l + (n-r-1)\\n2. Caso 2: Si l> r: N\xfamero de intercambios = l + (n-r-2), ya que ya se realiz\xf3 un intercambio mientras se intercambiaba el elemento m\xe1s grande al frente\\n","complejidad_tiempo":null,"java":"// Programa Java para contar N\xfamero m\xednimo de intercambios para que el\\n// elemento m\xe1s grande est\xe9 al principio y el elemento m\xe1s peque\xf1o est\xe9 al final\\n\\nimport java.io.*;\\n\\npublic class MinimumAdjacentSwapsMaxMinCorners {\\n\\n    public static void minimumSwaps(int a[], int n) {\\n        int maxx = -1, minn = a[0], l = 0, r = 0;\\n        for (int i = 0; i < n; i++) {\\n            // \xcdndice del elemento m\xe1s grande situado m\xe1s a la izquierda\\n            if (a[i] > maxx) {\\n                maxx = a[i];\\n                l = i;\\n            }\\n            // \xcdndice del elemento m\xe1s peque\xf1o situado m\xe1s a la derecha\\n            if (a[i] <= minn) {\\n                minn = a[i];\\n                r = i;\\n            }\\n        }\\n        if (r < l) {\\n            System.out.println(l + (n - r - 2));\\n        } else {\\n            System.out.println(l + (n - r - 1));\\n        }\\n    }\\n\\n    public static void main(String args[]) throws IOException {\\n        int a[] = {5, 6, 1, 3};\\n        int n = a.length;\\n        minimumSwaps(a, n);\\n    }\\n}\\n","cpp":null,"py":null,"orden":6,"suborden":73,"fecha_creacion":"2020-12-05 01:56:13","fecha_modificacion":"2022-03-08 12:01:47"},{"ID":181,"supergrupo":"Matem\xe1tica","tema":"Multiplicaci\xf3n modular","texto":"Considere a continuaci\xf3n un m\xe9todo simple para multiplicar dos n\xfameros.\\nUna soluci\xf3n simple que causa un desbordamiento cuando el valor de (a% mod) * (b% mod) supera el valor m\xe1ximo de long long int  \\n\\n#define ll long long\\nll multiply(ll a, ll b, ll mod) \\n{ \\n   return ((a % mod) * (b % mod)) % mod; \\n}\\n\\nLa funci\xf3n anterior funciona bien cuando la multiplicaci\xf3n no da como resultado un desbordamiento. Pero si los n\xfameros de entrada son tales que el resultado de la multiplicaci\xf3n supera el l\xedmite m\xe1ximo.\\nPor ejemplo, el m\xe9todo anterior falla cuando mod = 1011, a = 9223372036854775807 (mayor largo int largo) yb = 9223372036854775807 (mayor int largo largo). Tenga en cuenta que puede haber valores m\xe1s peque\xf1os para los que puede fallar. Puede haber muchos m\xe1s ejemplos de valores m\xe1s peque\xf1os. De hecho, cualquier conjunto de valores para los que la multiplicaci\xf3n puede generar un valor superior al l\xedmite m\xe1ximo.\\n\\n\xbfC\xf3mo evitar el desbordamiento?\\nPodemos multiplicar de forma recursiva para superar la dificultad del desbordamiento. Para multiplicar a * b, primero calcula a * b / 2 y luego s\xfamalo dos veces. Para calcular a * b / 2, calcule a * b / 4 y as\xed sucesivamente (similar al algoritmo de exponenciaci\xf3n log n).\\n\\n// Computar (a * b) % mod\\nmultiply(a,  b, mod)\\n1)  ll res = 0; // Inicializar resultado\\n2)  a = a % mod.\\n3)  While (b > 0)\\n        a) Si b es impar, agregue \'a\' al resultado.\\n               res = (res + a) % mod\\n        b) Multiplica \'a\' por 2\\n           a = (a * 2) % mod\\n        c) Dividir \'b\' por 2\\n           b = b/2  \\n4)  Return res \\n","complejidad_tiempo":null,"java":"// Realiza la operaci\xf3n (a * b) % mod minimizando posibles desbordamientos.\\n\\npublic class ModMultiplication {\\n\\n    public static long modmul(long a, long b, long mod) {\\n        long x = 0;\\n        long y = a % mod;\\n        while (b > 0) {\\n            if (b % 2 == 1) {\\n                x = (x + y) % mod;\\n            }\\n            y = (y << 1) % mod;\\n            b >>= 1;\\n        }\\n        return x % mod;\\n    }\\n\\n    public static void main(String[] args) {\\n        System.out.println(modmul(2, 2, 2));\\n    }\\n}\\n","cpp":"#include <bits/stdc++.h> \\nusing namespace std;\\n\\nlong modmul(long a, long b, long mod) {\\n    long x = 0;\\n    long y = a % mod;\\n    while (b > 0) {\\n        if (b % 2 == 1) {\\n            x = (x + y) % mod;\\n        }\\n        y = (y << 1) % mod;\\n        b >>= 1;\\n    }\\n    return x % mod;\\n}\\n\\nint main() {\\n    cout << modmul(2, 2, 2) << endl;\\n}\\n","py":"def modmul(a, b, mod):\\n    x = 0\\n    y = a % mod\\n    while (b > 0):\\n        if (b % 2 == 1):\\n            x = (x + y) % mod\\n        y = (y << 1) % mod;\\n        b >>= 1;\\n    return x % mod;\\nprint(modmul(2, 2, 2))\\n","orden":6,"suborden":74,"fecha_creacion":"2020-12-05 01:56:14","fecha_modificacion":"2022-03-08 12:01:47"},{"ID":182,"supergrupo":"Matem\xe1tica","tema":"Next Permutation","texto":"Dada una matriz o cadena, la tarea es encontrar la siguiente permutaci\xf3n lexicogr\xe1ficamente mayor de la misma.\\n\\nEjemplos:\\nEntrada: string = \\"gfg\\"\\nSalida: ggf\\n\\nEntrada: arr [] = {1, 2, 3}\\nSalida: {1, 3, 2}\\n\\nEn C ++, hay una funci\xf3n espec\xedfica que nos ahorra mucho c\xf3digo. Est\xe1 en el archivo de encabezado #include <algorithm>. La funci\xf3n es next_permutation (a.begin (), a.end ()). Se utiliza para reorganizar los elementos en el rango [primero, \xfaltimo) en la siguiente permutaci\xf3n lexicogr\xe1ficamente mayor. Una permutaci\xf3n es cada uno de los N! posibles disposiciones que pueden tomar los elementos (donde N es el n\xfamero de elementos en el rango). Se pueden ordenar diferentes permutaciones seg\xfan c\xf3mo se comparan lexicogr\xe1ficamente entre s\xed.\\nAparentemente, Java no proporciona ning\xfan m\xe9todo incorporado.\\n\\n\\n1. Encuentre el sufijo no creciente m\xe1s largo y encuentre el pivote.\\n2. Si el sufijo es la matriz completa, entonces no hay permutaci\xf3n de orden superior para los datos.\\n3. Encuentre el sucesor del pivote situado m\xe1s a la derecha.\\n4. Cambie el sucesor y el pivote.\\n5. Invierta el sufijo.\\n","complejidad_tiempo":null,"java":"// Programa Java para implementar el m\xe9todo next_permutation\\n\\nimport java.util.Arrays;\\n\\npublic class NextPermutation {\\n\\n    // Funci\xf3n para intercambiar los datos presentes en los \xedndices izquierdo y derecho\\n    public static int[] swap(int data[], int left, int right) {\\n\\n        // Intercambiar los datos\\n        int temp = data[left];\\n        data[left] = data[right];\\n        data[right] = temp;\\n\\n        // Devuelve la matriz actualizada\\n        return data;\\n    }\\n\\n    // Funci\xf3n para invertir la submatriz comenzando \\n    // de izquierda a derecha ambos inclusive\\n    public static int[] reverse(int data[], int left, int right) {\\n\\n        // Invertir la submatriz\\n        while (left < right) {\\n            int temp = data[left];\\n            data[left++] = data[right];\\n            data[right--] = temp;\\n        }\\n\\n        // Devuelve la matriz actualizada\\n        return data;\\n    }\\n\\n    // Funci\xf3n para encontrar la siguiente permutaci\xf3n de la matriz de enteros dada\\n    public static boolean findNextPermutation(int data[]) {\\n\\n        // Si el conjunto de datos dado est\xe1 vac\xedo o contiene solo \\n        // un elemento next_permutation no es posible\\n        if (data.length <= 1) {\\n            return false;\\n        }\\n\\n        int last = data.length - 2;\\n\\n        // encuentra el sufijo no creciente m\xe1s largo y encuentra el pivote\\n        while (last >= 0) {\\n            if (data[last] < data[last + 1]) {\\n                break;\\n            }\\n            last--;\\n        }\\n\\n        // Si no hay un par creciente, no hay permutaci\xf3n de orden superior\\n        if (last < 0) {\\n            return false;\\n        }\\n\\n        int nextGreater = data.length - 1;\\n\\n        // Encuentra el sucesor m\xe1s a la derecha del pivote\\n        for (int i = data.length - 1; i > last; i--) {\\n            if (data[i] > data[last]) {\\n                nextGreater = i;\\n                break;\\n            }\\n        }\\n\\n        // Intercambiar el sucesor y el pivote\\n        data = swap(data, nextGreater, last);\\n\\n        // Invertir el sufijo\\n        data = reverse(data, last + 1, data.length - 1);\\n\\n        // Devuelve verdadero cuando se realiza next_permutation\\n        return true;\\n    }\\n\\n    public static void main(String args[]) {\\n        int data[] = {1, 2, 3};\\n        if (!findNextPermutation(data)) {\\n            System.out.println(\\"There is no higher\\"\\n                    + \\" order permutation \\"\\n                    + \\"for the given data.\\");\\n        } else {\\n            System.out.println(Arrays.toString(data));\\n        }\\n    }\\n}\\n","cpp":"#include <algorithm> \\n#include <iostream> \\nusing namespace std;\\n\\nint main() {\\n    int arr[] = {1, 2, 3};\\n    int n = sizeof (arr) / sizeof (arr[0]);\\n\\n    sort(arr, arr + n);\\n\\n    cout << \\"The \\" << n << \\"! possible permutations with \\" << n << \\" elements:\\\\n\\";\\n    do {\\n        cout << arr[0] << \\" \\" << arr[1] << \\" \\" << arr[2] << \\"\\\\n\\";\\n    } while (next_permutation(arr, arr + 3));\\n\\n    cout << \\"After loop: \\" << arr[0] << \' \'\\n            << arr[1] << \' \' << arr[2] << \'\\\\n\';\\n\\n    return 0;\\n}\\n","py":"def swap(data, left, right):\\n    temp = data[left]\\n    data[left] = data[right]\\n    data[right] = temp\\n    return data\\n\\ndef reverse(data, left, right):\\n    while (left < right):\\n        temp = data[left]\\n        left += 1\\n        data[left] = data[right]\\n        right -= 1\\n        data[right] = temp\\n    return data;\\n\\ndef findNextPermutation(data):\\n    if (len(data) <= 1):\\n        return False;\\n    last = len(data) - 2\\n    while (last >= 0):\\n        if (data[last] < data[last + 1]):\\n            break\\n        last -= 1\\n    if (last < 0):\\n        return False\\n    nextGreater = len(data) - 1\\n    for i in range (len(data)-1, last, -1):\\n        if (data[i] > data[last]):\\n            nextGreater = i\\n            break\\n    data = swap(data, nextGreater, last);\\n    data = reverse(data, last + 1, len(data) - 1);\\n    return True\\n\\n\\ndata = [1, 2, 3]\\nif (findNextPermutation(data) == False):\\n    print(\\"There is no higher\\"\\n          + \\" order permutation \\"\\n          + \\"for the given data.\\")\\nelse:\\n    print(data)\\n\\n","orden":6,"suborden":75,"fecha_creacion":"2020-12-05 01:56:14","fecha_modificacion":"2022-03-08 12:01:47"},{"ID":183,"supergrupo":"Matem\xe1tica","tema":"Prev Permutation","texto":"Dada una palabra, encuentre una permutaci\xf3n lexicogr\xe1ficamente m\xe1s peque\xf1a de ella. Por ejemplo, la permutaci\xf3n lexicogr\xe1ficamente m\xe1s peque\xf1a de \\"4321\\" es \\"4312\\" y la siguiente permutaci\xf3n m\xe1s peque\xf1a de \\"4312\\" es \\"4231\\". Si la cadena est\xe1 ordenada en orden ascendente, la siguiente permutaci\xf3n lexicogr\xe1ficamente m\xe1s peque\xf1a no existe.\\nHemos discutido next_permutation () que modifica una cadena para que almacene permutaci\xf3n lexicogr\xe1ficamente m\xe1s peque\xf1a. STL tambi\xe9n proporciona std :: prev_permutation. Devuelve \\"verdadero\\" si la funci\xf3n pudiera reorganizar el objeto como una permutaci\xf3n lexicogr\xe1ficamente m\xe1s peque\xf1a. De lo contrario, devuelve \\"falso\\".\\n","complejidad_tiempo":null,"java":"import java.util.Arrays;\\n\\npublic class PrevPermutation {\\n\\n    public static boolean prev_permutation(int[] arr) {\\n        int len = arr.length;\\n        int i = len - 1;\\n        // 1. encuentra el mayor i donde arr [i - 1]> arr [i]\\n        while (i > 0) {\\n            if (arr[i - 1] > arr[i]) {\\n                break;\\n            }\\n            i--;\\n        }\\n        if (i <= 0) {\\n            return false;\\n        }\\n        // 2. encontrar el mayor j donde arr [i - 1]> arr [j] yj> = i\\n        int j = len - 1;\\n        while (j >= i) {\\n            if (arr[i - 1] > arr[j]) {\\n                break;\\n            }\\n            j--;\\n        }\\n        // 3. intercambiar elementos entre arr [i-1] y arr [j]\\n        swap(i - 1, j, arr);\\n        // 4. invertir elementos desde i hasta el final de la matriz\\n        len--;\\n        while (i < len) {\\n            swap(i, len, arr);\\n            len--;\\n            i++;\\n        }\\n        return true;\\n    }\\n\\n    public static void swap(int x, int y, int[] arr) {\\n        int temp = arr[x];\\n        arr[x] = arr[y];\\n        arr[y] = temp;\\n    }\\n\\n    public static void main(String[] args) {\\n        int data[] = {3, 2, 1};\\n        while (prev_permutation(data)) {\\n            System.out.println(Arrays.toString(data));\\n        }\\n    }\\n}\\n\\n","cpp":"#include <algorithm> \\n#include <iostream> \\nusing namespace std;\\n\\nint main() {\\n    int arr[] = {1, 2, 3};\\n    int n = sizeof (arr) / sizeof (arr[0]);\\n\\n    sort(arr, arr + n);\\n    reverse(arr, arr + n);\\n\\n    cout << \\"The \\" << n << \\"! possible permutations with \\" << n << \\" elements:\\\\n\\";\\n    do {\\n        cout << arr[0] << \\" \\" << arr[1] << \\" \\" << arr[2] << \\"\\\\n\\";\\n    } while (prev_permutation(arr, arr + 3));\\n\\n    cout << \\"After loop: \\" << arr[0] << \' \' << arr[1]\\n            << \' \' << arr[2] << \'\\\\n\';\\n    return 0;\\n}\\n\\n","py":"def swap(x, y, arr):\\n    temp = arr[x]\\n    arr[x] = arr[y]\\n    arr[y] = temp\\n    \\ndef prev_permutation(arr):\\n    lenght = len(arr)\\n    i = lenght - 1\\n    while (i > 0):\\n        if (arr[i - 1] > arr[i]):\\n            break\\n        i -= 1\\n    if (i <= 0):\\n        return False\\n    j = lenght - 1\\n    while (j >= i):\\n        if (arr[i - 1] > arr[j]):\\n            break\\n        j -= 1\\n    swap(i - 1, j, arr);\\n    lenght -= 1\\n    while (i < lenght):\\n        swap(i, lenght, arr)\\n        lenght -= 1\\n        i += 1\\n    return True;\\ndata = [3, 2, 1]\\nwhile (prev_permutation(data)):\\n    print(data)\\n","orden":6,"suborden":76,"fecha_creacion":"2020-12-05 01:56:14","fecha_modificacion":"2022-03-08 12:01:47"},{"ID":184,"supergrupo":"Matem\xe1tica","tema":"Tripletas pitag\xf3ricas","texto":"Un triplete pitag\xf3rico es un conjunto de tres enteros positivos a, b y c tales que a2 + b2 = c2. Dado un l\xedmite, genere todos los Triples pitag\xf3ricos con valores menores que el l\xedmite dado.\\nEntrada: l\xedmite = 20\\nSalida: 3 4 5\\n        \\t  8 6 10\\n           5 12 13\\n           15 8 17\\n           12 16 20\\nUna soluci\xf3n simple es generar estos tripletes m\xe1s peque\xf1os que el l\xedmite dado utilizando tres bucles anidados. Para cada triplete, verifique si la condici\xf3n pitag\xf3rica es verdadera, si es verdadera, luego imprima el triplete. La complejidad temporal de esta soluci\xf3n es O (l\xedmite3) donde \\"l\xedmite\\" se da l\xedmite.\\nUna soluci\xf3n eficiente puede imprimir todos los tripletes en el tiempo O (k) donde k es el n\xfamero de tripletes impresos. La idea es usar la relaci\xf3n de suma cuadrada del triplete pitag\xf3rico, es decir, la suma de los cuadrados de a y b es igual al cuadrado de c, podemos escribir estos n\xfameros en t\xe9rminos de m y n de manera que,\\n\\ta = m2 - n2\\n       b = 2 * m * n\\n       c  = m2 + n2\\nporque,\\n       a2 = m4 + n4 \u2013 2 * m2 * n2\\n       b2 = 4 * m2 * n2\\n       c2 = m4 + n4 + 2* m2 * n2\\nPodemos ver que a2 + b2 = c2, por lo que en lugar de iterar para a, b y c, podemos iterar para m y n y podemos generar estos tripletes.\\n","complejidad_tiempo":null,"java":"// Programa Java para generar tripletes pitag\xf3ricos \\n// m\xe1s peque\xf1os que un l\xedmite dado\\n\\npublic class PythagoreanTriplets {\\n\\n    // Funci\xf3n para generar tripletes pitag\xf3ricos menores que el l\xedmite\\n    static void pythagoreanTriplets(int limit) {\\n\\n        // triplete: a ^ 2 + b ^ 2 = c ^ 2\\n        int a, b, c = 0;\\n\\n        // bucle de 2 a max_limit\\n        int m = 2;\\n\\n        // Limitar c limitar\xeda todo a, b y c\\n        while (c < limit) {\\n\\n            // ahora bucle en j de 1 a i-1\\n            for (int n = 1; n < m; ++n) {\\n                // Evaluar e imprimir tripletes usando \\n                // la relaci\xf3n entre a, by c\\n                a = m * m - n * n;\\n                b = 2 * m * n;\\n                c = m * m + n * n;\\n\\n                if (c > limit) {\\n                    break;\\n                }\\n\\n                System.out.println(a + \\" \\" + b + \\" \\" + c);\\n            }\\n            m++;\\n        }\\n    }\\n\\n    public static void main(String args[]) {\\n        int limit = 20;\\n        pythagoreanTriplets(limit);\\n    }\\n}\\n","cpp":"#include <bits/stdc++.h> \\n\\nvoid pythagoreanTriplets(int limit) {\\n\\n    int a, b, c = 0;\\n    int m = 2;\\n\\n    while (c < limit) {\\n        for (int n = 1; n < m; ++n) {\\n            a = m * m - n * n;\\n            b = 2 * m * n;\\n            c = m * m + n * n;\\n            if (c > limit)\\n                break;\\n            printf(\\"%d %d %d\\\\n\\", a, b, c);\\n        }\\n        m++;\\n    }\\n}\\n\\nint main() {\\n    int limit = 20;\\n    pythagoreanTriplets(limit);\\n    return 0;\\n} \\n","py":"def pythagoreanTriplets(limits) : \\n    c, m = 0, 2\\n    while c < limits : \\n        for n in range(1, m) : \\n            a = m * m - n * n \\n            b = 2 * m * n \\n            c = m * m + n * n \\n            if c > limits : \\n                break\\n  \\n            print(a, b, c) \\n  \\n        m = m + 1\\n        \\nlimit = 20\\npythagoreanTriplets(limit) \\n","orden":6,"suborden":77,"fecha_creacion":"2020-12-05 01:56:14","fecha_modificacion":"2022-03-08 12:01:47"},{"ID":185,"supergrupo":"Matem\xe1tica","tema":"Horas posibles","texto":"Dada una temporizaci\xf3n de uno o dos d\xedgitos, calcule las posibilidades de ocurrencia de otras temporizaciones (incluida la que brilla intensamente) con respecto a los segmentos brillantes, asumiendo que algunos segmentos pueden no estar brillantes.\\nLa visualizaci\xf3n de los n\xfameros se realiza mediante una pantalla de siete segmentos. Se garantiza que los palos que se muestran actualmente funcionan bien.\\n \\nExamples:\\nEntrada: 78\\nSalida: 5\\n\\nEntrada: 05\\nSalida: 8\\nExplicaci\xf3n:\\nEjemplo 1: 7 se puede reemplazar por 5 n\xfameros diferentes 9, 3, 8, 0 y 7 (si ninguno de los segmentos est\xe1 roto) y 8 se puede reemplazar por solo 1 n\xfamero, es decir, el 8 en s\xed mismo (si ninguno de los segmentos est\xe1 roto) , por lo tanto, la respuesta es 5 * 1 = 5.\\nEjemplo 2: 0 se puede reemplazar por 2 n\xfameros, 8 y 0, mientras que 5 se puede reemplazar por 4 n\xfameros diferentes. Entonces, la respuesta es 4 * 2 = 8.\\n\\nAproximaci\xf3n :\\nCalcule para cada n\xfamero del 0 al 9 qu\xe9 d\xedgitos son posibles sumando o\\nquitando exactamente una varilla de la pantalla. Almacene esto en una matriz y la respuesta ser\xe1 el producto del valor de la matriz de ambos d\xedgitos de la entrada.\\n","complejidad_tiempo":null,"java":"// Programa Java para calcular posibles tiempos.\\n\\npublic class PossibleTimings {\\n    // Array que almacena diferentes n\xfameros de d\xedgitos, \\n    // un d\xedgito en particular se puede reemplazar con\\n\\n    static int num[] = {2, 7, 2, 3, 3, 4, 2, 5, 1, 2};\\n\\n    public static void possibleTimings(String n) {\\n        System.out.println(num[(n.charAt(0) - \'0\')]\\n                * num[n.charAt(1) - \'0\']);\\n    }\\n\\n    public static void main(String args[]) {\\n        String n = \\"05\\";\\n        possibleTimings(n);\\n    }\\n}\\n","cpp":"#include \\"bits/stdc++.h\\" \\nusing namespace std;\\n\\nint num[] = {2, 7, 2, 3, 3, 4, 2, 5, 1, 2};\\n\\nvoid possibleTimings(string n) {\\n    cout << (num[(n.at(0) - \'0\')]\\n            * num[n.at(1) - \'0\']) << endl;\\n}\\n\\nint main() {\\n    string n = \\"05\\";\\n    possibleTimings(n);\\n}\\n","py":"num = [2, 7, 2, 3, 3, 4, 2, 5, 1, 2]\\ndef possibleTimings(n):\\n    print(num[(ord(n[0]) - ord(\'0\'))] * num[ord(n[1]) - ord(\'0\')]) \\n\\nn = \\"05\\"\\npossibleTimings(n)\\n","orden":6,"suborden":78,"fecha_creacion":"2020-12-05 01:56:15","fecha_modificacion":"2022-03-08 12:01:47"},{"ID":186,"supergrupo":"Matem\xe1tica","tema":"Factorizaci\xf3n prima","texto":"Podemos calcular la factorizaci\xf3n prima de un n\xfamero \\"n\\" en O (sqrt (n)). Pero el m\xe9todo O (sqrt n) se agota cuando necesitamos responder m\xfaltiples consultas sobre factorizaci\xf3n prima.\\n\\nConcepto clave: Nuestra idea es almacenar el factor primo m\xe1s peque\xf1o (SPF) para cada n\xfamero. Luego, para calcular la factorizaci\xf3n prima del n\xfamero dado dividiendo el n\xfamero dado de forma recursiva con su factor primo m\xe1s peque\xf1o hasta que se convierta en 1.\\n\\nPara calcular el factor primo m\xe1s peque\xf1o de cada n\xfamero, usaremos el tamiz de erat\xf3stenes. En la criba original, cada vez que marcamos un n\xfamero como no primo, almacenamos el factor primo m\xe1s peque\xf1o correspondiente para ese n\xfamero.\\n\\nAhora, despu\xe9s de que hayamos terminado de calcular previamente el factor primo m\xe1s peque\xf1o para cada n\xfamero, dividiremos nuestro n\xfamero n (cuya factorizaci\xf3n prima se calcular\xe1) por su factor primo m\xe1s peque\xf1o correspondiente hasta que n se convierta en 1.\\nPseudoc\xf3digo para factorizaci\xf3n prima asumiendo que los SPF se calculan:\\n\\nPrimeFactors [] // Para almacenar el resultado\\n\\ni = 0 // \xcdndice en PrimeFactors\\n\\nmientras que n! = 1:\\n\\n    // SPF: factor primo m\xe1s peque\xf1o\\n    PrimeFactors [i] = SPF [n]\\n    yo ++\\n    n = n / SPF [n]\\n\\nNota: El c\xf3digo anterior funciona bien para n hasta el orden de 10 ^ 7. M\xe1s all\xe1 de esto, enfrentaremos problemas de memoria.\\nComplejidad de tiempo: el c\xe1lculo previo para el factor primo m\xe1s peque\xf1o se realiza en O (n log log n) utilizando un tamiz. Donde, como en el paso de c\xe1lculo, estamos dividiendo el n\xfamero cada vez por el n\xfamero primo m\xe1s peque\xf1o hasta que se convierte en 1. Entonces, consideremos el peor de los casos en el que cada vez el SPF es 2. Por lo tanto, tendr\xe1 log n pasos de divisi\xf3n. Por tanto, podemos decir que nuestra Complejidad de Tiempo ser\xe1 O (log n) en el peor de los casos.\\n","complejidad_tiempo":null,"java":"//Guarda en factors la lista de factores primos de n de menor a \\n//mayor. IMPORTANTE: Debe ejecutarse primero Sieve of Eratosthenes \\n//(al menos hasta un numero mayor a la raiz cuadrada de n).\\n\\nimport java.util.ArrayList;\\n\\npublic class PrimeFactorization {\\n\\n    static int MAX = 1000000;\\n    static int SQRT = 1000;\\n    static ArrayList<Integer> primes = new ArrayList<>();\\n    static boolean marked[] = new boolean[MAX + 1];\\n    static ArrayList<Integer> factors = new ArrayList<>();\\n\\n    public static void primeFactors(int n) {\\n        factors.clear();\\n        for (int i = 0, p = primes.get(i); p * p <= n; p = primes.get(++i)) {\\n            while (n % p == 0) {\\n                factors.add(p);\\n                n /= p;\\n            }\\n        }\\n        if (n > 1) {\\n            factors.add(n);\\n        }\\n    }\\n\\n    static void sieve() {\\n        marked[1] = true;\\n        int i = 2;\\n        for (; i <= SQRT; ++i) {\\n            if (!marked[i]) {\\n                primes.add(i);\\n                for (int j = i * i; j <= MAX; j += i) {\\n                    marked[j] = true;\\n                }\\n            }\\n        }\\n        for (; i <= MAX; ++i) {\\n            if (!marked[i]) {\\n                primes.add(i);\\n            }\\n        }\\n    }\\n\\n    public static void main(String[] args) {\\n        sieve();\\n        primeFactors(100);\\n        for (Integer i : factors) {\\n            System.out.print(i + \\" \\");\\n        }\\n        System.out.println(\\"\\");\\n    }\\n}\\n","cpp":"#include <bits/stdc++.h> \\nusing namespace std;\\nint const MAX = 1000000;\\nint SQRT = 1000;\\nvector<int> primes;\\nbool marked[MAX + 1];\\nvector<int> factors;\\n\\nvoid primeFactors(int n) {\\n    factors.clear();\\n    for (int i = 0, p = primes[i]; p * p <= n; p = primes[++i]) {\\n        while (n % p == 0) {\\n            factors.emplace_back(p);\\n            n /= p;\\n        }\\n    }\\n    if (n > 1) {\\n        factors.emplace_back(n);\\n    }\\n}\\n\\nvoid sieve() {\\n    marked[1] = true;\\n    int i = 2;\\n    for (; i <= SQRT; ++i) {\\n        if (!marked[i]) {\\n            primes.emplace_back(i);\\n            for (int j = i * i; j <= MAX; j += i) {\\n                marked[j] = true;\\n            }\\n        }\\n    }\\n    for (; i <= MAX; ++i) {\\n        if (!marked[i]) {\\n            primes.emplace_back(i);\\n        }\\n    }\\n}\\n\\nint main() {\\n    sieve();\\n    primeFactors(100);\\n    for (int i : factors) {\\n        cout << i << \\" \\";\\n    }\\n    cout << endl;\\n}\\n","py":"import math\\n \\n\\ndef primeFactors(n): \\n        \\n    while n % 2 == 0: \\n        print 2, \\n        n = n / 2\\n    for i in range(3, int(math.sqrt(n)) + 1, 2): \\n        while n % i == 0: \\n            print i, \\n            n = n / i \\n                        \\n    if n > 2: \\n        print n \\n                \\n\\n\\nn = 100\\nprimeFactors(n) \\n","orden":6,"suborden":79,"fecha_creacion":"2020-12-05 01:56:15","fecha_modificacion":"2022-03-08 12:01:47"},{"ID":187,"supergrupo":"Matem\xe1tica","tema":"Raiz primitiva","texto":"Dado un n\xfamero primo n, la tarea consiste en encontrar su ra\xedz primitiva en m\xf3dulo n. La ra\xedz primitiva de un n\xfamero primo n es un entero r entre [1, n-1] tal que los valores de r ^ x (mod n) donde x est\xe1 en el rango [0, n-2] son diferentes. Devuelve -1 si n es un n\xfamero no primo.\\nEjemplos:\\nEntrada: 7\\nResultado: ra\xedz primitiva m\xe1s peque\xf1a = 3\\nExplicaci\xf3n: n = 7\\n3 ^ 0 (mod 7) = 1\\n3 ^ 1 (mod 7) = 3\\n3 ^ 2 (mod 7) = 2\\n3 ^ 3 (mod 7) = 6\\n3 ^ 4 (mod 7) = 4\\n3 ^ 5 (mod 7) = 5\\n\\nEntrada: 761\\nResultado: ra\xedz primitiva m\xe1s peque\xf1a = 6\\nUna soluci\xf3n simple es probar todos los n\xfameros del 2 al n-1. Para cada n\xfamero r, calcule los valores de r ^ x (mod n) donde x est\xe1 en el rango [0, n-2]. Si todos estos valores son diferentes, devuelva r, de lo contrario contin\xfae con el siguiente valor de r. Si se prueban todos los valores de r, devuelve -1.\\n\\nUna soluci\xf3n eficiente se basa en el siguiente hecho.\\nSi el orden multiplicativo de un n\xfamero r m\xf3dulo n es igual a la Funci\xf3n Totient de Euler \u03a6 (n) (Note que la Funci\xf3n Totient de Euler para un primo n es n-1), entonces es una ra\xedz primitiva.\\n\\n1- Funci\xf3n Totient de Euler phi = n-1 [Suponiendo que n es primo]\\n1- Encuentra todos los factores primos de phi.\\n2- Calcule todas las potencias para seguir calculando\\n   usando (phi / factores primos) uno por uno.\\n3- Compruebe todos los numerados para todas las potencias de i = 2\\n   a n-1 es decir (i ^ potencias) m\xf3dulo n.\\n4- Si es 1, entonces \'i\' no es una ra\xedz primitiva de n.\\n5- Si nunca es 1, devuelve i ;.\\n\\nAunque puede haber m\xfaltiples ra\xedces primitivas para un n\xfamero primo, solo nos preocupa el m\xe1s peque\xf1o. Si desea encontrar todas las ra\xedces, contin\xfae el proceso hasta p-1 en lugar de dividir al encontrar la primera ra\xedz primitiva.\\n","complejidad_tiempo":null,"java":"// Programa Java para encontrar la ra\xedz primitiva de un n\xfamero n dado\\n\\nimport java.util.*;\\n\\npublic class PrimitiveRoot {\\n\\n    // Devuelve verdadero si n es primo\\n    static boolean isPrime(int n) {\\n        // casos esquina\\n        if (n <= 1) {\\n            return false;\\n        }\\n        if (n <= 3) {\\n            return true;\\n        }\\n        // Esto est\xe1 marcado para que podamos omitir los cinco \\n        // n\xfameros del medio en el ciclo inferior\\n        if (n % 2 == 0 || n % 3 == 0) {\\n            return false;\\n        }\\n\\n        for (int i = 5; i * i <= n; i = i + 6) {\\n            if (n % i == 0 || n % (i + 2) == 0) {\\n                return false;\\n            }\\n        }\\n\\n        return true;\\n    }\\n\\n    /* Funci\xf3n iterativa para calcular (x ^ n)% p en O (logy) */\\n    static int power(int x, int y, int p) {\\n        int res = 1;     // Inicializar resultado\\n\\n        x = x % p; // Actualiza x si es mayor o igual que p\\n\\n        while (y > 0) {\\n            // Si y es impar, multiplica x con el resultado\\n            if (y % 2 == 1) {\\n                res = (res * x) % p;\\n            }\\n\\n            // y debe ser par ahora\\n            y = y >> 1; // y = y/2 \\n            x = (x * x) % p;\\n        }\\n        return res;\\n    }\\n\\n    // Funci\xf3n de utilidad para almacenar factores primos de un n\xfamero\\n    static void findPrimefactors(HashSet<Integer> s, int n) {\\n        // Imprime el n\xfamero de 2 que dividen n \\n        while (n % 2 == 0) {\\n            s.add(2);\\n            n = n / 2;\\n        }\\n\\n        // n debe ser extra\xf1o en este punto. Entonces podemos \\n        // omitir un elemento (Note i = i +2)\\n        for (int i = 3; i <= Math.sqrt(n); i = i + 2) {\\n            // Mientras yo divide n, imprime i y divide n\\n            while (n % i == 0) {\\n                s.add(i);\\n                n = n / i;\\n            }\\n        }\\n        // Esta condici\xf3n es para manejar el caso \\n        // cuando n es un n\xfamero primo mayor que 2\\n        if (n > 2) {\\n            s.add(n);\\n        }\\n    }\\n\\n    // Funci\xf3n para encontrar la ra\xedz primitiva m\xe1s peque\xf1a de n\\n    static int findPrimitive(int n) {\\n        HashSet<Integer> s = new HashSet<>();\\n\\n        // Compruebe si n es primo o no\\n        if (isPrime(n) == false) {\\n            return -1;\\n        }\\n\\n        // Encuentre el valor de la funci\xf3n Euler Totient de n \\n        // Dado que n es un n\xfamero primo, el valor de la funci\xf3n Euler \\n        // Totient es n-1 ya que hay n-1 n\xfameros primos relativos.\\n        int phi = n - 1;\\n        // Encuentra factores primos de phi y gu\xe1rdalos en un conjunto \\n        findPrimefactors(s, phi);\\n        // Compruebe todos los n\xfameros del 2 al phi\\n        for (int r = 2; r <= phi; r++) {\\n            // Repita todos los factores primos de phi. \\n            // y verificamos si encontramos una potencia con valor 1\\n            boolean flag = false;\\n            for (Integer a : s) {\\n                // Compruebe si r ^ ((phi) / primefactors) mod n es 1 o no\\n                if (power(r, phi / (a), n) == 1) {\\n                    flag = true;\\n                    break;\\n                }\\n            }\\n\\n            // Si no hubiera potencia con valor 1.\\n            if (flag == false) {\\n                return r;\\n            }\\n        }\\n\\n        // Si no se encuentra ra\xedz primitiva\\n        return -1;\\n    }\\n\\n    public static void main(String[] args) {\\n        int n = 761;\\n        System.out.println(\\" Smallest primitive root of \\" + n\\n                + \\" is \\" + findPrimitive(n));\\n    }\\n}\\n","cpp":"#include<bits/stdc++.h> \\nusing namespace std;\\n\\nbool isPrime(int n) {\\n\\n    if (n <= 1) return false;\\n    if (n <= 3) return true;\\n    if (n % 2 == 0 || n % 3 == 0) return false;\\n    for (int i = 5; i * i <= n; i = i + 6)\\n        if (n % i == 0 || n % (i + 2) == 0)\\n            return false;\\n    return true;\\n}\\n\\nint power(int x, unsigned int y, int p) {\\n    int res = 1;\\n    x = x % p;\\n    while (y > 0) {\\n        if (y & 1)\\n            res = (res * x) % p;\\n        y = y >> 1;\\n        x = (x * x) % p;\\n    }\\n    return res;\\n}\\n\\nvoid findPrimefactors(unordered_set<int> &s, int n) {\\n\\n    while (n % 2 == 0) {\\n        s.insert(2);\\n        n = n / 2;\\n    }\\n\\n    for (int i = 3; i <= sqrt(n); i = i + 2) {\\n        while (n % i == 0) {\\n            s.insert(i);\\n            n = n / i;\\n        }\\n    }\\n    if (n > 2)\\n        s.insert(n);\\n}\\n\\nint findPrimitive(int n) {\\n    unordered_set<int> s;\\n    if (isPrime(n) == false)\\n        return -1;\\n    int phi = n - 1;\\n    findPrimefactors(s, phi);\\n    for (int r = 2; r <= phi; r++) {\\n        bool flag = false;\\n        for (auto it = s.begin(); it != s.end(); it++) {\\n            if (power(r, phi / (*it), n) == 1) {\\n                flag = true;\\n                break;\\n            }\\n        }\\n        if (flag == false)\\n            return r;\\n    }\\n    return -1;\\n}\\n\\nint main() {\\n    int n = 761;\\n    cout << \\" Smallest primitive root of \\" << n\\n            << \\" is \\" << findPrimitive(n);\\n    return 0;\\n}\\n","py":"from math import sqrt\\n \\ndef isPrime(n): \\n    if (n <= 1): \\n        return False\\n    if (n <= 3): \\n        return True\\n    if (n % 2 == 0 or n % 3 == 0): \\n        return False\\n    i = 5\\n    while(i * i <= n): \\n        if (n % i == 0 or n % (i + 2) == 0): \\n            return False\\n        i = i + 6\\n    return True\\n\\ndef power(x, y, p): \\n    res = 1 \\n    x = x % p \\n    while (y > 0): \\n        if (y & 1): \\n            res = (res * x) % p \\n        y = y >> 1 \\n        x = (x * x) % p \\n    return res \\n\\ndef findPrimefactors(s, n): \\n    while (n % 2 == 0): \\n        s.add(2) \\n        n = n // 2\\n    for i in range(3, int(sqrt(n)), 2): \\n        while (n % i == 0): \\n            s.add(i) \\n            n = n // i \\n    if (n > 2): \\n        s.add(n) \\n\\ndef findPrimitive(n): \\n    s = set() \\n    if (isPrime(n) == False): \\n        return -1 \\n    phi = n - 1\\n    findPrimefactors(s, phi) \\n    for r in range(2, phi + 1): \\n\\n        flag = False\\n        for it in s: \\n\\n            if (power(r, phi // it, n) == 1): \\n\\n                flag = True\\n                break\\n                         \\n        if (flag == False): \\n            return r \\n\\n    return -1\\n\\nn = 761\\nprint(\\"Smallest primitive root of\\", \\n      n, \\"is\\", findPrimitive(n)) \\n","orden":6,"suborden":80,"fecha_creacion":"2020-12-05 01:56:15","fecha_modificacion":"2022-03-08 12:03:39"},{"ID":188,"supergrupo":"Matem\xe1tica","tema":"Series geom\xe9tricas bajo condiciones ","texto":"Una progresi\xf3n geom\xe9trica es una secuencia de enteros b1, b2, b3,\u2026, donde para cada i> 1, el t\xe9rmino respectivo satisface la condici\xf3n bi = bi-1 * q, donde q se llama la raz\xf3n com\xfan de la progresi\xf3n.\\nDada la progresi\xf3n geom\xe9trica b definida por dos enteros b1 y q, y m enteros \\"malos\\" a1, a2, .., am, y un entero l, escribe todos los t\xe9rminos de progresi\xf3n uno por uno (incluido el repetitivo) while condici\xf3n | bi | <= l est\xe1 satisfecho (| x | significa valor absoluto de x).\\n\\n\\nCalcule cu\xe1ntos n\xfameros habr\xe1 en nuestra secuencia, o imprima \\"inf\\" en el caso de infinitos n\xfameros enteros.\\nNota: Si un t\xe9rmino es igual a uno de los n\xfameros enteros \u201cmalos\u201d, om\xedtalo y avanza al siguiente t\xe9rmino.\\nEjemplos:\\nEntrada: b1 = 3, q = 2, l = 30,\\n        m = 4\\n        6 14 25 48\\nSalida: 3\\nLa progresi\xf3n ser\xe1 3 12 24.\\n6 tambi\xe9n estar\xe1 all\xed, pero porque\\nes un n\xfamero entero malo, no lo incluiremos\\n\\nEntrada: b1 = 123, q = 1, l = 2143435\\n        m = 4\\n        123 11 -5453 141245\\nSalida: 0\\nComo el valor de q es 1, la progresi\xf3n\\nsiempre ser\xe1 123 y se volver\xeda infinito\\npero como es un n\xfamero entero malo,\\nno lo incluir\xe1 y por lo tanto nuestro valor\\nse convertir\xe1 en 0\\n\\nEntrada: b1 = 123, q = 1, l = 2143435\\n        m = 4\\n        5234 11-5453 141245\\nSalida: inf\\nEn este caso, el valor ser\xe1 infinito\\nporque la serie siempre ser\xe1 123 como\\nq es 1 y 123 no es un n\xfamero entero incorrecto.\\n\\nAproximaci\xf3n:\\nPodemos dividir nuestra soluci\xf3n en diferentes casos:\\nCaso 1: si el valor inicial de la serie es mayor que el l\xedmite dado, la salida es 0.\\nCaso 2: Si el valor inicial de la serie oq es 0, hay tres casos m\xe1s:\\nCaso 2.a: Si no se da 0 como un n\xfamero entero incorrecto, la respuesta se convertir\xe1 en inf.\\nCaso 2.b: Si b1! = 0 pero q es 0 y b1 tampoco es un n\xfamero entero incorrecto, la respuesta ser\xe1 1.\\nCaso 2.c: Si 0 se da como un n\xfamero entero incorrecto y b1 = 0, la respuesta ser\xe1 0.\\nCaso 3: Si q = 1 comprobaremos si b1 se da como un entero incorrecto o no. Si es as\xed, la respuesta ser\xe1 0; de lo contrario, la respuesta ser\xe1 inf.\\nCaso 4: Si q = -1, verifique si b1 y -b1 est\xe1n presentes o no, si est\xe1n presentes nuestra respuesta ser\xe1 0, de lo contrario nuestra respuesta ser\xe1 inf.\\nCaso 5: Si ninguno de los casos anteriores se cumple, simplemente ejecute un ciclo para b1 hasta l y calcule el n\xfamero de elementos.\\n","complejidad_tiempo":null,"java":"// Programa Java para encontrar el n\xfamero de t\xe9rminos en series geom\xe9tricas\\n\\nimport java.util.*;\\n\\npublic class TermsGeometricSerieswithConditions {\\n\\n    // Un mapa para realizar un seguimiento de los n\xfameros enteros incorrectos\\n    static HashMap<Integer, Boolean> map = new HashMap<>();\\n\\n    // Funci\xf3n para calcular el No. de elementos de nuestra serie\\n    static void progression(int b1, int q, int l,\\n            int m, int[] bad) {\\n\\n        // Actualizaci\xf3n del valor de nuestro mapa\\n        for (int i = 0; i < m; i++) {\\n            map.put(bad[i], true);\\n        }\\n        // si el valor inicial es mayor que nuestro l\xedmite dado \\n        if (Math.abs(b1) > l) {\\n            System.out.print(\\"0\\");\\n        } // si q o el valor inicial es 0\\n        else if (q == 0 || b1 == 0) {\\n            // si 0 no es un n\xfamero entero incorrecto, \\n            // la respuesta se convierte en inf\\n            if (!map.containsKey(0)) {\\n                System.out.print(\\"inf\\");\\n            } // si q es 0 y b1 no lo es y b1\\n            // no es un n\xfamero entero malo, la respuesta se convierte en 1\\n            else if (map.get(0) == true && !map.containsKey(b1)) {\\n                System.out.print(\\"1\\");\\n            } // de lo contrario, si 0 es un n\xfamero entero incorrecto y b1 \\n            // tambi\xe9n es un n\xfamero incorrecto, la respuesta se convierte en 0\\n            else {\\n                System.out.print(\\"0\\");\\n            }\\n        } // si q es 1\\n        else if (q == 1) {\\n            // y b1 no es un n\xfamero entero incorrecto, \\n            // la respuesta se convierte en inf\\n            if (!map.containsKey(b1)) {\\n                System.out.print(\\"inf\\");\\n            } // si no, la respuesta es 0\\n            else {\\n                System.out.print(\\"0\\");\\n            }\\n\\n        } // si q es -1\\n        else if (q == -1) {\\n            // y b1 o -b1 no est\xe1 presente la respuesta se convierte en inf\\n            if (!map.containsKey(b1) || !map.containsKey(-1 * b1)) {\\n                System.out.print(\\"inf\\");\\n            } // si no, la respuesta se convierte en 0\\n            else {\\n                System.out.print(\\"0\\");\\n            }\\n\\n        } // si ninguno de los casos anteriores es cierto, \\n        // simplemente calcule el n\xfamero de elementos en nuestra serie\\n        else {\\n            int co = 0;\\n            while (Math.abs(b1) <= l) {\\n                if (!map.containsKey(b1)) {\\n                    co++;\\n                }\\n                b1 *= q;\\n            }\\n            System.out.print(co);\\n        }\\n    }\\n\\n    public static void main(String[] args) {\\n        // valor inicial de la serie, n\xfamero a multiplicar, l\xedmite dentro del\\n        // cual nuestra serie, n\xfamero de enteros incorrectos dado\\n        int b1 = 3, q = 2, l = 30, m = 4;\\n\\n        // Enteros malos\\n        int[] bad = {6, 14, 25, 48};\\n\\n        progression(b1, q, l, m, bad);\\n    }\\n}\\n","cpp":"#include <bits/stdc++.h> \\nusing namespace std;\\n\\nmap<int, bool> mapp;\\n\\nvoid progression(int b1, int q, int l, int m, int bad[]) {\\n\\n    for (int i = 0; i < m; i++)\\n        mapp[bad[i]] = 1;\\n    if (abs(b1) > l)\\n        cout << \\"0\\";\\n\\n    else if (q == 0 || b1 == 0) {\\n        if (mapp[0] != 1)\\n            cout << \\"inf\\";\\n        else if (mapp[0] == 1 && mapp[b1] != 1)\\n            cout << \\"1\\";\\n\\n        else\\n            cout << \\"0\\";\\n    } else if (q == 1) {\\n\\n        if (mapp[b1] != 1)\\n            cout << \\"inf\\";\\n        else\\n            cout << \\"0\\";\\n    } else if (q == -1) {\\n\\n        if (mapp[b1] != 1 || mapp[-1 * b1] != 1)\\n            cout << \\"inf\\";\\n        else\\n            cout << \\"0\\";\\n    } else {\\n        int co = 0;\\n        while (abs(b1) <= l) {\\n            if (mapp[b1] != 1)\\n                co++;\\n            b1 *= 1LL * q;\\n        }\\n        cout << co;\\n    }\\n}\\n\\nint main() {\\n    int b1 = 3, q = 2, l = 30, m = 4;\\n    int bad[4] = {6, 14, 25, 48};\\n    progression(b1, q, l, m, bad);\\n    return 0;\\n} \\n","py":"mpp = dict() \\n  \\ndef progression(b1, q, l, m, bad): \\n    for i in range(m): \\n        mpp[bad[i]] = 1\\n    if (abs(b1) > l): \\n        print(\\"0\\", end=\\"\\") \\n    elif (q == 0 or b1 == 0): \\n        if (0 not in mpp.keys()): \\n            print(\\"inf\\", end=\\"\\") \\n        elif (mpp[0] == 1 and b1 not in mpp.keys()): \\n            print(\\"1\\", end=\\"\\") \\n        else: \\n            print(\\"0\\", end=\\"\\") \\n    elif (q == 1): \\n        if (b1 not in mpp.keys()): \\n            print(\\"inf\\", end=\\"\\") \\n        else: # else answer is 0 \\n            print(\\"0\\", end=\\"\\") \\n  \\n    elif (q == -1): \\n        if (b1 not in mpp.keys() or -1 * b1 not in mpp.keys()): \\n            print(\\"inf\\", end=\\"\\") \\n        else:\\n            print(\\"0\\", end=\\"\\") \\n    else:\\n        co = 0\\n        while (abs(b1) <= l): \\n            if (b1 not in mpp.keys()): \\n                co += 1\\n            b1 *= q \\n        print(co, end=\\"\\") \\n  \\n  \\n\\nb1 = 3\\nq = 2\\nl = 30\\nm = 4\\n  \\nbad = [6, 14, 25, 48] \\nprogression(b1, q, l, m, bad) \\n","orden":6,"suborden":81,"fecha_creacion":"2020-12-05 01:56:16","fecha_modificacion":"2022-03-08 12:03:39"},{"ID":189,"supergrupo":"Matem\xe1tica","tema":"Verificando si existe una progresi\xf3n geom\xe9trica","texto":"Una secuencia de n\xfameros se llama progresi\xf3n geom\xe9trica si la raz\xf3n de dos t\xe9rminos consecutivos es siempre la misma. En t\xe9rminos simples, significa que el siguiente n\xfamero de la serie se calcula multiplicando un n\xfamero fijo por el n\xfamero anterior de la serie. Por ejemplo, 2, 4, 8, 16 es un GP porque la proporci\xf3n de dos t\xe9rminos consecutivos cualesquiera de la serie (diferencia com\xfan) es el mismo (4/2 = 8/4 = 16/8 = 2).\\n \\nHechos sobre la progresi\xf3n geom\xe9trica:\\n1. T\xe9rmino inicial: en una progresi\xf3n geom\xe9trica, el primer n\xfamero se llama t\xe9rmino inicial.\\n2. Raz\xf3n com\xfan: la raz\xf3n entre un t\xe9rmino en la secuencia y el t\xe9rmino anterior se denomina \\"raz\xf3n com\xfan\\".\\n3. El comportamiento de una secuencia geom\xe9trica depende del valor de la raz\xf3n com\xfan. Si la raz\xf3n com\xfan es:\\n\u2022 Positiva, todos los t\xe9rminos tendr\xe1n el mismo signo que el t\xe9rmino inicial.\\n\u2022 Negativa, los t\xe9rminos se alternar\xe1n entre positivo y negativo.\\n\u2022 Mayor que 1, habr\xe1 un crecimiento exponencial hacia el infinito positivo o negativo (seg\xfan el signo del t\xe9rmino inicial).\\n\u2022 1, la progresi\xf3n es una secuencia constante.\\n\u2022 Entre -1 y 1 pero no cero, habr\xe1 una ca\xedda exponencial hacia cero.\\n\u2022 -1, la progresi\xf3n es una secuencia alterna.\\n\u2022 Menos de -1, para los valores absolutos hay un crecimiento exponencial hacia el infinito (sin signo), debido al signo alterno.\\nF\xf3rmula del en\xe9simo t\xe9rmino de una progresi\xf3n geom\xe9trica:\\nSi \\"a\\" es el primer t\xe9rmino y \\"r\\" es la raz\xf3n com\xfan, la f\xf3rmula expl\xedcita es\\n\\n\\n\xbfC\xf3mo comprobamos si una serie es progresi\xf3n geom\xe9trica o no?\\nEncontremos la raz\xf3n de los t\xe9rminos consecutivos, por lo que podemos decir que la raz\xf3n de los t\xe9rminos consecutivos de las secuencias dadas es 13 o una constante. Entonces esta secuencia est\xe1 formando una progresi\xf3n geom\xe9trica.\\n","complejidad_tiempo":null,"java":"// Programa Java para verificar si una matriz \\n// determinada puede formar una progresi\xf3n geom\xe9trica\\n\\npublic class IsGeometricProgression {\\n\\n    // funci\xf3n para comprobar que la serie es progresi\xf3n geom\xe9trica o no\\n    static boolean is_geometric(int arr[], int n) {\\n        if (n == 1) {\\n            return true;\\n        }\\n\\n        // Calcular la proporci\xf3n\\n        int ratio = arr[1] / (arr[0]);\\n\\n        //Compruebe la proporci\xf3n de los restantes\\n        for (int i = 1; i < n; i++) {\\n            if ((arr[i] / (arr[i - 1])) != ratio) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n\\n    public static void main(String[] args) {\\n        int arr[] = {2, 6, 18, 54};\\n        int n = arr.length;\\n\\n        if (is_geometric(arr, n)) {\\n            System.out.println(\\"True\\");\\n        } else {\\n            System.out.println(\\"False\\");\\n        }\\n    }\\n}\\n","cpp":"#include <bits/stdc++.h> \\nusing namespace std;\\n\\nbool is_geometric(int arr[], int n) {\\n    if (n == 1)\\n        return true;\\n\\n    int ratio = arr[1] / (arr[0]);\\n\\n    for (int i = 1; i < n; i++) {\\n        if ((arr[i] / (arr[i - 1])) != ratio) {\\n            return false;\\n        }\\n    }\\n    return true;\\n}\\n\\nint main() {\\n    int arr[] = {2, 6, 18, 54};\\n    int n = sizeof (arr) / sizeof (arr[0]);\\n\\n    (is_geometric(arr, n)) ? (cout << \\"True\\" << endl) : (cout << \\"False\\" << endl);\\n\\n    return 0;\\n} \\n","py":"def is_geometric(li): \\n    if len(li) <= 1: \\n        return True\\n    ratio = li[1]/float(li[0]) \\n     \\n    for i in range(1, len(li)): \\n        if li[i]/float(li[i-1]) != ratio:  \\n            return False\\n    return True\\n  \\nprint(is_geometric([2, 6, 18, 54])) \\n","orden":6,"suborden":82,"fecha_creacion":"2020-12-05 01:56:16","fecha_modificacion":"2022-03-08 12:03:39"},{"ID":190,"supergrupo":"Matem\xe1tica","tema":"Subsecuencias \xfanicas de tama\xf1o k","texto":"Dada un array de N n\xfameros y un entero K. La tarea es imprimir el n\xfamero de subsecuencias \xfanicas posibles de longitud K.\\nEjemplos:\\nEntrada: a [] = {1, 2, 3, 4}, k = 3\\nSalida: 4.\\nLas subsecuencias \xfanicas son:\\n{1, 2, 3}, {1, 2, 4}, {1, 3, 4}, {2, 3, 4}\\n\\nEntrada: a [] = {1, 1, 1, 2, 2, 2}, k = 3\\nSalida: 4\\nLas subsecuencias \xfanicas son\\n{1, 1, 1}, {1, 1, 2}, {1, 2, 2}, {2, 2, 2}\\n\\nEnfoque: Existe una f\xf3rmula bien conocida de cu\xe1ntas subsecuencias de longitud fija K se pueden elegir entre N objetos \xfanicos. Pero el problema aqu\xed tiene varias diferencias. Uno de ellos es que el orden en las subsecuencias es importante y debe conservarse como en la secuencia original. Para tal problema, no puede haber una f\xf3rmula combinatoria lista porque los resultados dependen del orden de la matriz original.\\nLa idea principal es tratar de forma recurrente la longitud de la subsecuencia. En cada paso recurrente, mu\xe9vase del final al principio y cuente las combinaciones \xfanicas usando el recuento de combinaciones \xfanicas m\xe1s cortas del paso anterior. M\xe1s estrictamente en cada paso j, mantenemos un array de longitud N y cada elemento en el lugar p significa cu\xe1ntas subsecuencias \xfanicas con longitud j encontramos a la derecha del elemento en el lugar i, incluido el propio i.\\n","complejidad_tiempo":null,"java":"import java.util.*;\\n\\npublic class UniqueSubsequencesklength {\\n\\n// Function which returns the numbe of\\n// unique subsequences of length K\\n    static int solution(int[] A, int N, int k) {\\n\\n        // Bases cases\\n        if (N < k || N < 1 || k < 1) {\\n            return 0;\\n        }\\n        if (N == k) {\\n            return 1;\\n        }\\n\\n        // Prepare arrays for recursion\\n        int[] v1 = new int[N];\\n        int[] v2 = new int[N];\\n        int[] v3 = new int[N];\\n\\n        // Initiate separately for k = 1\\n        // intiate the last element\\n        v2[N - 1] = 1;\\n        v3[A[N - 1] - 1] = 1;\\n\\n        // Initiate all other elements of k = 1\\n        for (int i = N - 2; i >= 0; i--) {\\n\\n            // Initialize the front element\\n            // to vector v2\\n            v2[i] = v2[i + 1];\\n\\n            // If element v[a[i]-1] is 0\\n            // then increment it in vector v2\\n            if (v3[A[i] - 1] == 0) {\\n                v2[i]++;\\n                v3[A[i] - 1] = 1;\\n            }\\n        }\\n\\n        // Iterate for all possible values of K\\n        for (int j = 1; j < k; j++) {\\n\\n            // Fill the vectors with 0\\n            Arrays.fill(v3, 0);\\n\\n            // Fill(v1.begin(), v1.end(), 0)\\n            // the last must be 0 as from last\\n            // no unique subarray can be formed\\n            v1[N - 1] = 0;\\n\\n            // Iterate for all index from which \\n            // unique subsequences can be formed\\n            for (int i = N - 2; i >= 0; i--) {\\n\\n                // Add the number of subsequence \\n                // formed from the next index\\n                v1[i] = v1[i + 1];\\n\\n                // Start with combinations on the\\n                // next index\\n                v1[i] = v1[i] + v2[i + 1];\\n\\n                // Remove the elements which have\\n                // already been counted\\n                v1[i] = v1[i] - v3[A[i] - 1];\\n\\n                // Update the number used\\n                v3[A[i] - 1] = v2[i + 1];\\n            }\\n        }\\n\\n        // Last answer is stored in v2\\n        return v2[0];\\n    }\\n\\n// Driver Code\\n    public static void main(String[] args) {\\n        int a[] = {1, 2, 3, 4};\\n        int n = a.length;\\n        int k = 3;\\n\\n        System.out.print(solution(a, n, k));\\n    }\\n}\\n","cpp":"#include <bits/stdc++.h> \\nusing namespace std;\\n\\nint solution(vector<int>& A, int k) {\\n    const int N = A.size();\\n    if (N < k || N < 1 || k < 1)\\n        return 0;\\n    if (N == k)\\n        return 1;\\n\\n    vector<int> v1(N, 0);\\n    vector<int> v2(N, 0);\\n    vector<int> v3(N, 0);\\n\\n    v2[N - 1] = 1;\\n    v3[A[N - 1] - 1] = 1;\\n\\n    for (int i = N - 2; i >= 0; i--) {\\n\\n        v2[i] = v2[i + 1];\\n        if (v3[A[i] - 1] == 0) {\\n            v2[i]++;\\n            v3[A[i] - 1] = 1;\\n        }\\n    }\\n\\n    for (int j = 1; j < k; j++) {\\n\\n        fill(v3.begin(), v3.end(), 0);\\n        v1[N - 1] = 0;\\n\\n        for (int i = N - 2; i >= 0; i--) {\\n\\n            v1[i] = v1[i + 1];\\n            v1[i] = v1[i] + v2[i + 1];\\n            v1[i] = v1[i] - v3[A[i] - 1];\\n            v3[A[i] - 1] = v2[i + 1];\\n        }\\n        v2 = v1;\\n    }\\n    return v2[0];\\n}\\n\\nvoid solve(int a[], int n, int k) {\\n    vector<int> v;\\n    v.assign(a, a + n);\\n    cout << solution(v, k);\\n}\\n\\nint main() {\\n    int a[] = {1, 2, 3, 4};\\n    int n = sizeof (a) / sizeof (a[0]);\\n    int k = 3;\\n    solve(a, n, k);\\n\\n    return 0;\\n} \\n","py":"def solution(A, k):\\n\\n    N = len(A)\\n    if (N < k or N < 1 or k < 1):\\n        return 0\\n    if (N == k):\\n        return 1\\n    v1 = [0] * (N)\\n    v2 = [0] * N\\n    v3 = [0] * N\\n    v2[N - 1] = 1\\n    v3[A[N - 1] - 1] = 1\\n\\n    for i in range(N - 2, -1, -1):\\n        v2[i] = v2[i + 1]\\n        if (v3[A[i] - 1] == 0):\\n            v2[i] += 1\\n            v3[A[i] - 1] = 1\\n                \\n    for j in range(1, k):\\n        v3 = [0] * N\\n        v1[N - 1] = 0\\n        for i in range(N - 2, -1, -1):\\n            v1[i] = v1[i + 1]\\n            v1[i] = v1[i] + v2[i + 1]\\n            v1[i] = v1[i] - v3[A[i] - 1]\\n            v3[A[i] - 1] = v2[i + 1]\\n        \\n        for i in range(len(v1)):\\n            v2[i] = v1[i]\\n        \\n    return v2[0]\\n\\ndef solve(a, n, k):\\n    v = a\\n    print(solution(v, k))\\n\\n\\na = [1, 2, 3, 4]\\nn = len(a)\\nk = 3\\nsolve(a, n, k)\\n","orden":6,"suborden":83,"fecha_creacion":"2020-12-05 01:56:16","fecha_modificacion":"2022-03-08 12:03:39"},{"ID":191,"supergrupo":"Matem\xe1tica","tema":"Bisecci\xf3n","texto":"* f (b) <0 yf (x) es continua en [a, b]. Aqu\xed f (x) representa una ecuaci\xf3n algebraica o trascendental. Encuentre la ra\xedz de la funci\xf3n en el intervalo [a, b] (O encuentre un valor de x tal que f (x) sea 0).\\nEjemplo:\\nEntrada: una funci\xf3n de x, por ejemplo x3 - x2 + 2.\\n       Y dos valores: a = -200 yb = 300 tales que\\n       f (a) * f (b) <0, es decir, f (a) yf (b) tienen\\n       signos opuestos.\\nSalida: El valor de la ra\xedz es: -1,0025\\n        O cualquier otro valor con permitido\\n        desviaci\xf3n de la ra\xedz.\\n\xbfQu\xe9 son las funciones algebraicas y trascendentales?\\nLa funci\xf3n algebraica es aquella que se puede representar en forma de polinomios como f (x) = a1x3 + a2x2 +\u2026 .. + e donde aa1, a2,\u2026 son constantes yx es una variable.\\nLas funciones trascendentales son funciones no algebraicas, por ejemplo f (x) = sin (x) * x - 3 o f (x) = ex + x2 o f (x) = ln (x) + x\u2026.\\n\xbfQu\xe9 es el m\xe9todo de bisecci\xf3n?\\nEl m\xe9todo tambi\xe9n se denomina m\xe9todo de reducci\xf3n a la mitad del intervalo, m\xe9todo de b\xfasqueda binaria o m\xe9todo de dicotom\xeda. Este m\xe9todo se usa para encontrar la ra\xedz de una ecuaci\xf3n en un intervalo dado que es el valor de \\"x\\" para el cual f (x) = 0.\\nEl m\xe9todo se basa en el Teorema del valor intermedio que establece que si f (x) es una funci\xf3n continua y hay dos n\xfameros reales ayb tales que f (a) * f (b) 0 yf (b) <0) , entonces se garantiza que tiene al menos una ra\xedz entre ellos.\\nSupuestos:\\n\\n1. f (x) es una funci\xf3n continua en el intervalo [a, b]\\n2. f (a) * f (b) <0\\nPasos:\\n1. Encuentre el punto medio c = (a + b) / 2.\\n2. Si f (c) == 0, entonces c es la ra\xedz de la soluci\xf3n.\\n3. De lo contrario, f (c)! = 0\\n1. Si el valor f (a) * f (c) <0, la ra\xedz se encuentra entre ay c. Entonces recurrimos para ayc\\n2. De lo contrario Si f (b) * f (c) <0, entonces la ra\xedz se encuentra entre by c. Entonces recurrimos by c.\\n3. La otra funci\xf3n dada no sigue uno de los supuestos.\\nDado que la ra\xedz puede ser un n\xfamero de punto flotante, repetimos los pasos anteriores mientras que la diferencia entre ayb es menor que un valor. (Un valor muy peque\xf1o).\\n \\nComplejidad temporal: - La complejidad temporal de este m\xe9todo depende de los valores asumidos y de la funci\xf3n.\\n\xbfCu\xe1les son los pros y los contras?\\nLa ventaja del m\xe9todo de bisecci\xf3n es que se garantiza que converger\xe1. La desventaja del m\xe9todo de bisecci\xf3n es que no puede detectar m\xfaltiples ra\xedces.\\nEn general, el m\xe9todo de bisecci\xf3n se utiliza para obtener una aproximaci\xf3n inicial aproximada de la soluci\xf3n. Luego, se utilizan m\xe9todos convergentes m\xe1s r\xe1pidos para encontrar la soluci\xf3n.\\n","complejidad_tiempo":null,"java":"// Programa Java para la implementaci\xf3n del m\xe9todo de \\n// bisecci\xf3n para resolver ecuaciones\\n\\npublic class Bisection {\\n\\n    static final float EPSILON = (float) 0.01;\\n\\n    // Una funci\xf3n de ejemplo cuya soluci\xf3n se determina mediante el m\xe9todo de\\n    // bisecci\xf3n. La funci\xf3n es x ^ 3 - x ^ 2 + 2\\n    static double func(double x) {\\n        return x * x * x - x * x + 2;\\n    }\\n\\n    // Imprime la ra\xedz de func (x) con error de EPSILON\\n    static void bisection(double a, double b) {\\n        if (func(a) * func(b) >= 0) {\\n            System.out.println(\\"You have not assumed\\"\\n                    + \\" right a and b\\");\\n            return;\\n        }\\n        double c = a;\\n        while ((b - a) >= EPSILON) {\\n            // Encuentra el punto medio\\n            c = (a + b) / 2;\\n\\n            // Compruebe si el punto medio es la ra\xedz\\n            if (func(c) == 0.0) {\\n                break;\\n            } // Decide el lado para repetir los pasos\\n            else if (func(c) * func(a) < 0) {\\n                b = c;\\n            } else {\\n                a = c;\\n            }\\n        }\\n        //imprime el valor de c hasta 4 lugares decimales\\n        System.out.printf(\\"The value of root is : %.4f\\",\\n                c);\\n    }\\n\\n    public static void main(String[] args) {\\n        // Valores iniciales asumidos\\n        double a = -200, b = 300;\\n        bisection(a, b);\\n    }\\n}\\n","cpp":"#include<bits/stdc++.h> \\nusing namespace std;\\n#define EPSILON 0.01 \\n\\ndouble func(double x) {\\n    return x * x * x - x * x + 2;\\n}\\n\\nvoid bisection(double a, double b) {\\n    if (func(a) * func(b) >= 0) {\\n        cout << \\"You have not assumed right a and b\\\\n\\";\\n        return;\\n    }\\n\\n    double c = a;\\n    while ((b - a) >= EPSILON) {\\n        c = (a + b) / 2;\\n\\n        if (func(c) == 0.0)\\n            break;\\n\\n        else if (func(c) * func(a) < 0)\\n            b = c;\\n        else\\n            a = c;\\n    }\\n    cout << \\"The value of root is : \\" << c;\\n}\\n\\nint main() {\\n    double a = -200, b = 300;\\n    bisection(a, b);\\n    return 0;\\n} \\n","py":"def func(x): \\n    return x * x * x - x * x + 2\\n   \\ndef bisection(a, b): \\n  \\n    if (func(a) * func(b) >= 0): \\n        print(\\"You have not assumed right a and b\\\\n\\") \\n        return\\n   \\n    c = a \\n    while ((b-a) >= 0.01): \\n        c = (a + b) / 2\\n        if (func(c) == 0.0): \\n            break\\n  \\n        if (func(c) * func(a) < 0): \\n            b = c \\n        else: \\n            a = c \\n              \\n    print(\\"The value of root is : \\", \\"%.4f\\" % c) \\n      \\n\\na = -200\\nb = 300\\nbisection(a, b) \\n","orden":6,"suborden":84,"fecha_creacion":"2020-12-05 01:56:17","fecha_modificacion":"2022-03-08 12:03:39"},{"ID":192,"supergrupo":"Matem\xe1tica","tema":"Interpolaci\xf3n de LaGrange","texto":"\xbfQu\xe9 es la interpolaci\xf3n?\\nLa interpolaci\xf3n es un m\xe9todo para encontrar nuevos puntos de datos dentro del rango de un conjunto discreto de puntos de datos conocidos. En otras palabras, la interpolaci\xf3n es la t\xe9cnica para estimar el valor de una funci\xf3n matem\xe1tica, para cualquier valor intermedio de la variable independiente.\\nPor ejemplo, en la tabla dada se nos dan 4 conjuntos de puntos de datos discretos, para una funci\xf3n desconocida f (x):\\n \\n\xbfComo encontrarlo?\\nAqu\xed podemos aplicar la f\xf3rmula de interpolaci\xf3n de Lagrange para obtener nuestra soluci\xf3n.\\nLa f\xf3rmula de interpolaci\xf3n de Lagrange:\\nSi, y = f (x) toma los valores y0, y1,\u2026, yn correspondientes ax = x0, x1,\u2026, xn entonces, \\nEste m\xe9todo se prefiere sobre sus contrapartes como el m\xe9todo de Newton porque es aplicable incluso para valores de x desigualmente espaciados.\\nPodemos usar t\xe9cnicas de interpolaci\xf3n para encontrar un punto de datos intermedio, digamos en x = 3.\\nComplejidad:\\nLa complejidad temporal de la soluci\xf3n anterior es O (n2) y el espacio auxiliar es O (1).\\n","complejidad_tiempo":null,"java":"// Programa Java para la implementaci\xf3n de la interpolaci\xf3n de Lagrange\\n\\npublic class LagrangeInterpolation {\\n\\n    // Para representar un punto de datos correspondiente ax e y = f (x)\\n    static class Data {\\n\\n        int x, y;\\n\\n        public Data(int x, int y) {\\n            super();\\n            this.x = x;\\n            this.y = y;\\n        }\\n\\n    };\\n\\n    // funci\xf3n para interpolar los puntos de datos dados utilizando \\n    // la f\xf3rmula de Lagrange xi corresponde al nuevo punto de datos cuyo\\n    // valor se va a obtener n representa el n\xfamero de puntos de datos conocidos \\n    static double interpolate(Data f[], int xi, int n) {\\n        double result = 0; // Initialize result \\n\\n        for (int i = 0; i < n; i++) {\\n            //Calcule los t\xe9rminos individuales de la f\xf3rmula anterior\\n            double term = f[i].y;\\n            for (int j = 0; j < n; j++) {\\n                if (j != i) {\\n                    term = term * (xi - f[j].x) / (f[i].x - f[j].x);\\n                }\\n            }\\n\\n            // Agregar t\xe9rmino actual al resultado\\n            result += term;\\n        }\\n\\n        return result;\\n    }\\n\\n    public static void main(String[] args) {\\n        // Agregar t\xe9rmino actual al resultado\\n        Data f[] = {new Data(0, 2), new Data(1, 3),\\n            new Data(2, 12), new Data(5, 147)};\\n\\n        // Usando la funci\xf3n de interpolaci\xf3n para \\n        // obtener un punto de datos correspondiente ax = 3\\n        System.out.print(\\"Value of f(3) is : \\"\\n                + (int) interpolate(f, 3, 4));\\n    }\\n}\\n","cpp":"#include<bits/stdc++.h> \\nusing namespace std;\\n\\nstruct Data {\\n    int x, y;\\n};\\n\\ndouble interpolate(Data f[], int xi, int n) {\\n    double result = 0;\\n    for (int i = 0; i < n; i++) {\\n        double term = f[i].y;\\n        for (int j = 0; j < n; j++) {\\n            if (j != i)\\n                term = term * (xi - f[j].x) / double(f[i].x - f[j].x);\\n        }\\n        result += term;\\n    }\\n\\n    return result;\\n}\\n\\nint main() {\\n    Data f[] = {\\n        {0, 2},\\n        {1, 3},\\n        {2, 12},\\n        {5, 147}\\n    };\\n    cout << \\"Value of f(3) is : \\" << interpolate(f, 3, 5);\\n    return 0;\\n} \\n","py":"class Data: \\n    def __init__(self, x, y): \\n        self.x = x \\n        self.y = y \\n  \\n\\ndef interpolate(f, xi, n): \\n    result = 0.0\\n    for i in range(n): \\n        term = f[i].y \\n        for j in range(n): \\n            if j != i: \\n                term = term * (xi - f[j].x) / (f[i].x - f[j].x) \\n        result += term \\n  \\n    return result \\nf = [Data(0, 2), Data(1, 3), Data(2, 12), Data(5, 147)] \\n\\nprint(\\"Value of f(3) is :\\", interpolate(f, 3, 4))\\n\\n","orden":6,"suborden":85,"fecha_creacion":"2020-12-05 01:56:17","fecha_modificacion":"2022-03-08 12:05:45"},{"ID":193,"supergrupo":"Matem\xe1tica","tema":"Interpolaci\xf3n inversa de LaGrange","texto":"La tarea dada es encontrar el valor de x para una y dada de una funci\xf3n desconocida y = f (x) donde se dan los valores de algunos pares de puntos (x, y).\\nEl proceso de encontrar el valor de la variable independiente x para un valor dado de y que se encuentra entre dos valores tabulados con la ayuda del conjunto dado de observaci\xf3n para una funci\xf3n desconocida se conoce como interpolaci\xf3n inversa.\\nEsto se usa a menudo para verificar si la exactitud de la salida y para una funci\xf3n desconocida, es decir, cu\xe1nto argumento x para esta salida y difiere de la entrada original.\\nEste m\xe9todo se puede utilizar incluso cuando los puntos est\xe1n espaciados de forma desigual. Aqu\xed x se expresa en funci\xf3n de y.\\nEjemplos:\\nEntrada: Encuentre el valor de x donde y = 4.5 y los puntos dados son \\nSalida: 2.79501\\nExplicaci\xf3n: Aqu\xed el n\xfamero de puntos de datos dados = 4 e y = 4.5\\nEntonces, poniendo los valores de todo xey en la f\xf3rmula de interpolaci\xf3n inversa dada anteriormente obtenemos,\\n\\n \\nDe aqu\xed obtenemos,\\nEl valor de x = 2.79501 donde el valor de y = 4.5\\n \\nAlgoritmo:\\nAqu\xed, los datos son una lista de puntos que consta de xey y n es el n\xfamero de puntos de datos.\\nPASO - 1: Inicializar el valor final x = 0\\nPASO - 2: PARA i = 1 an do\\n     PASO - 3: Inicializar xi = datos [i] .x\\n     PASO - 4: PARA j = 1 an hacer\\n         PASO - 5: SI i! = J hago\\n             PASO - 6: Multiplica xi por (y - dato [j] .y) y divide por (dato [i] .y - dato [j] .y)\\n         TERMINARA SI\\n     ENDFOR\\n     PASO - 7: Suma xi a x\\nENDFOR\\nPASO - 8: Devuelve el valor final de x\\nPASO - 9: FIN\\n","complejidad_tiempo":null,"java":"// C\xf3digo Java para resolver interpolaci\xf3n inversa\\n\\npublic class InvLagrangeInterpolation {\\n\\n    // Considere una estructura para mantener juntos cada par de xey\\n    static class Data {\\n\\n        double x, y;\\n\\n        public Data(double x, double y) {\\n            super();\\n            this.x = x;\\n            this.y = y;\\n        }\\n\\n    };\\n\\n    // Funci\xf3n para calcular la interpolaci\xf3n inversa\\n    static double inv_interpolate(Data[] d, int n, double y) {\\n        // Inicializar x final\\n        double x = 0;\\n        int i, j;\\n        for (i = 0; i < n; i++) {\\n            // Calcula cada t\xe9rmino de la f\xf3rmula dada\\n            double xi = d[i].x;\\n            for (j = 0; j < n; j++) {\\n\\n                if (j != i) {\\n                    xi = xi * (y - d[j].y) / (d[i].y - d[j].y);\\n                }\\n            }\\n\\n            //Agregar t\xe9rmino al resultado final\\n            x += xi;\\n        }\\n        return x;\\n    }\\n\\n    public static void main(String[] args) {\\n\\n        // Conjunto de datos de muestra de 4 \\n        // puntos Aqu\xed encontramos el valor de x cuando y = 4.5\\n        Data[] d = {new Data(1.27, 2.3),\\n            new Data(2.25, 2.95),\\n            new Data(2.5, 3.5),\\n            new Data(3.6, 5.1)};\\n\\n        // Tama\xf1o del conjunto de datos\\n        int n = 4;\\n\\n        // Valor de muestra y\\n        double y = 4.5;\\n\\n        // Usar la funci\xf3n de interpolaci\xf3n inversa \\n        // para encontrar el valor de x cuando y = 4.5\\n        System.out.printf(\\"Value of x at y = 4.5 : %.5f\\",\\n                inv_interpolate(d, n, y));\\n    }\\n}\\n","cpp":"#include <bits/stdc++.h> \\nusing namespace std;\\n\\nstruct Data {\\n    double x, y;\\n};\\n\\ndouble inv_interpolate(Data d[], int n, double y) {\\n    double x = 0;\\n    int i, j;\\n    for (i = 0; i < n; i++) {\\n        double xi = d[i].x;\\n        for (j = 0; j < n; j++) {\\n            if (j != i) {\\n                xi = xi * (y - d[j].y) / (d[i].y - d[j].y);\\n            }\\n        }\\n        x += xi;\\n    }\\n\\n    return x;\\n}\\n\\nint main() {\\n    Data d[] = {\\n        { 1.27, 2.3},\\n        { 2.25, 2.95},\\n        { 2.5, 3.5},\\n        { 3.6, 5.1}\\n    };\\n\\n    int n = 4;\\n    double y = 4.5;\\n    cout << \\"Value of x at y = 4.5 : \\"\\n            << inv_interpolate(d, n, y);\\n    return 0;\\n} \\n","py":"class Data: \\n    def __init__(self, x, y): \\n        self.x = x \\n        self.y = y \\n  \\n\\ndef inv_interpolate(d, n,  y) : \\n    x = 0\\n    for i in range(n): \\n        xi = d[i].x \\n        for j in range(n): \\n            if j != i: \\n                xi = (xi * (y - d[j].y) / \\n                      (d[i].y - d[j].y)) \\n        x += xi \\n    return x \\nd = [Data(1.27, 2.3),  \\n     Data(2.25, 2.95),  \\n     Data(2.5, 3.5),  \\n     Data(3.6, 5.1)] \\n\\nn = 4\\ny = 4.5\\nprint(\\"Value of x at y = 4.5 :\\",  \\n       round(inv_interpolate(d, n, y), 5)) \\n","orden":6,"suborden":86,"fecha_creacion":"2020-12-05 01:56:17","fecha_modificacion":"2022-03-08 12:05:45"},{"ID":194,"supergrupo":"Matem\xe1tica","tema":"Raiz mediante Newton","texto":"Dado un n\xfamero entero N y un nivel de tolerancia L, la tarea es encontrar la ra\xedz cuadrada de ese n\xfamero usando el m\xe9todo de Newton.\\nEjemplos:\\nEntrada: N = 16, L = 0.0001\\nSalida: 4\\n42 = 16\\nEntrada: N = 327, L = 0.00001\\nSalida: 18.0831\\n\\nM\xe9todo de Newton:\\nSea N cualquier n\xfamero, entonces la ra\xedz cuadrada de N puede estar dada por la f\xf3rmula:\\n\\nroot = 0.5 * (X + (N / X)) donde X es cualquier conjetura que se puede suponer que es N o 1.\\n\u2022 En la f\xf3rmula anterior, X es cualquier ra\xedz cuadrada asumida de N y ra\xedz es la ra\xedz cuadrada correcta de N.\\n\u2022 El l\xedmite de tolerancia es la diferencia m\xe1xima entre X y la ra\xedz permitida.\\nEnfoque: se pueden seguir los siguientes pasos para calcular la respuesta:\\n1. Asigne X a la propia N.\\n2. Ahora, inicie un ciclo y siga calculando la ra\xedz que seguramente se mover\xe1 hacia la ra\xedz cuadrada correcta de N.\\n3. Verifique la diferencia entre la X supuesta y la ra\xedz calculada, si a\xfan no est\xe1 dentro de la tolerancia, actualice la ra\xedz y contin\xfae.\\n4. Si la ra\xedz calculada entra dentro de la tolerancia permitida, salga del ciclo.\\n5. Imprima la ra\xedz.\\n","complejidad_tiempo":null,"java":"// Implementaci\xf3n Java de la ra\xedz cuadrada de Newton\\n\\npublic class NewtonSquareRoot {\\n\\n    // Funci\xf3n para devolver la ra\xedz cuadrada de un n\xfamero usando el m\xe9todo de Newton\\n    static double squareRoot(double n, double l) {\\n        // Suponiendo la sqrt de n como n solamente\\n        double x = n;\\n\\n        // La conjetura cerrada se almacenar\xe1 en la ra\xedz.\\n        double root;\\n\\n        // Para contar el n\xfamero de iteraciones\\n        int count = 0;\\n\\n        while (true) {\\n            count++;\\n\\n            // Calcular m\xe1s cerrado x\\n            root = 0.5 * (x + (n / x));\\n\\n            // Compruebe la cercan\xeda\\n            if (Math.abs(root - x) < l) {\\n                break;\\n            }\\n\\n            // Actualizar root\\n            x = root;\\n        }\\n\\n        return root;\\n    }\\n\\n    public static void main(String[] args) {\\n        double n = 327;\\n        double l = 0.00001;\\n\\n        System.out.println(squareRoot(n, l));\\n    }\\n}\\n","cpp":"#include <bits/stdc++.h> \\nusing namespace std;\\n\\ndouble squareRoot(double n, float l) {\\n    double x = n;\\n    double root;\\n    int count = 0;\\n\\n    while (1) {\\n        count++;\\n        root = 0.5 * (x + (n / x));\\n        if (abs(root - x) < l)\\n            break;\\n        x = root;\\n    }\\n\\n    return root;\\n}\\n\\nint main() {\\n    double n = 327;\\n    float l = 0.00001;\\n    cout << squareRoot(n, l);\\n    return 0;\\n} \\n","py":"def squareRoot(n, l):  \\n    x = n  \\n    count = 0 \\n    while (1): \\n        count += 1 \\n        root = 0.5 * (x + (n / x))  \\n        if (abs(root - x) < l): \\n            break \\n        x = root \\n  \\n    return root  \\n  \\nn = 327\\nl = 0.00001 \\nprint(squareRoot(n, l))  \\n","orden":6,"suborden":87,"fecha_creacion":"2020-12-05 01:56:18","fecha_modificacion":"2022-03-08 12:05:45"},{"ID":195,"supergrupo":"Matem\xe1tica","tema":"Raiz mediante Newton Raphson ","texto":"Dada una funci\xf3n f (x) en un n\xfamero flotante x y una estimaci\xf3n inicial de la ra\xedz, encuentre la ra\xedz de la funci\xf3n en el intervalo. Aqu\xed f (x) representa una ecuaci\xf3n algebraica o trascendental.\\nPara simplificar, hemos asumido que la derivada de la funci\xf3n tambi\xe9n se proporciona como entrada.\\nEjemplo:\\nEntrada: una funci\xf3n de x (por ejemplo, x3 - x2 + 2),\\n       funci\xf3n derivada de x (3x2 - 2x para el ejemplo anterior)\\n       y una suposici\xf3n inicial x0 = -20\\nSalida: El valor de la ra\xedz es: -1,00\\n        O cualquier otro valor cercano a la ra\xedz.\\n\\nEl m\xe9todo de bisecci\xf3n vs el m\xe9todo de posici\xf3n falsa\\nComparaci\xf3n con los dos m\xe9todos anteriores:\\n\\n1. En los m\xe9todos anteriores, se nos dio un intervalo. Aqu\xed se requiere un valor aproximado inicial de ra\xedz.\\n2. Se garantiza que los dos m\xe9todos anteriores converger\xe1n, Newton Rahhson puede no converger en algunos casos.\\n3. El m\xe9todo de Newton Raphson requiere derivada. Algunas funciones pueden resultar dif\xedciles de\\nimposible de diferenciar.\\n4. Para muchos problemas, el m\xe9todo de Newton Raphson converge m\xe1s r\xe1pido que los dos m\xe9todos anteriores.\\n5. Adem\xe1s, puede identificar ra\xedces repetidas, ya que no busca cambios en el signo de f (x) expl\xedcitamente\\nLa formula:\\nA partir de la estimaci\xf3n inicial x1, el m\xe9todo de Newton Raphson utiliza la siguiente f\xf3rmula para encontrar el siguiente valor de x, es decir, xn + 1 del valor anterior xn.\\n \\nAlgoritmo:\\nEntrada: x inicial, func (x), derivFunc (x)\\nSalida: Ra\xedz de Func ()\\n1. Calcule los valores de func (x) y derivFunc (x) para una x inicial dada\\n2. Calcule h: h = func (x) / derivFunc (x)\\n3. Si bien h es mayor que el error permitido \u03b5\\n1. h = func (x) / derivFunc (x)\\n2. x = x - h\\n\\n\xbfComo funciona esto?\\nLa idea es dibujar una recta tangente af (x) en el punto x1. El punto donde la l\xednea tangente cruza el eje x deber\xeda ser una mejor estimaci\xf3n de la ra\xedz que x1. Llame a este punto x2. Calcula f (x2) y dibuja una recta tangente en x2.\\n \\nSabemos que la pendiente de la recta de (x1, f (x1)) a (x2, 0) es f \'(x1)) donde f\' representa la derivada de f.\\nf \'(x1) = (0 - f (x1)) / (x2 - x1)\\n\\nf \'(x1) * (x2 - x1) = - f (x1)\\n\\nx2 = x1 - f (x1) / f \'(x1)\\n\\nAl encontrar este punto \'x2\', nos acercamos a la ra\xedz.\\nTenemos que seguir repitiendo el paso anterior hasta que nos acerquemos mucho a\\nla ra\xedz o la encontramos.\\n\\nEn general,\\nxn + 1 = xn - f (xn) / f \'(xn)\\nExplicaci\xf3n alternativa usando la serie de Taylor:\\nSea x1 la estimaci\xf3n inicial.\\n\\nPodemos escribir x2 de la siguiente manera:\\n  xn + 1 = xn + h ------- (1)\\nAqu\xed h ser\xeda un valor peque\xf1o que puede ser positivo o negativo.\\n\\nSeg\xfan la serie de Taylor,\\n\u0192 (x) que es infinitamente diferenciable se puede escribir como se muestra a continuaci\xf3n\\nf (xn + 1) = f (xn + h)\\n       = f (xn) + h * f \'(xn) + ((h * h) / 2!) * (f\' \'(xn)) + ...\\n\\nComo buscamos la ra\xedz de la funci\xf3n, f (xn + 1) = 0\\n\\nf (xn) + h * f \'(xn) + ((h * h) / 2!) * (f\' \'(xn)) + ... = 0\\n\\nAhora que h es peque\xf1o, h * h ser\xeda muy peque\xf1o.\\nEntonces, si ignoramos los t\xe9rminos de orden superior, obtenemos\\n\\nf (xn) + h * f \'(xn) = 0\\n\\nSustituyendo este valor de h = xn + 1 - xn de la ecuaci\xf3n (1) obtenemos,\\nf (xn) + (xn + 1 - xn) * f \'(xn) = 0\\n\\nxn + 1 = xn - f (xn) / f \'(xn)\\nNotas:\\n1. Generalmente usamos este m\xe9todo para mejorar el resultado obtenido por el m\xe9todo de bisecci\xf3n o el m\xe9todo de falsa posici\xf3n.\\n2. El m\xe9todo babil\xf3nico para la ra\xedz cuadrada se deriva del m\xe9todo de Newton-Raphson.\\n","complejidad_tiempo":null,"java":"// Programa Java para la implementaci\xf3n del M\xe9todo \\n// Newton Raphson para resolver ecuaciones\\n\\npublic class NewtonRaphsonRoot {\\n\\n    static final double EPSILON = 0.001;\\n\\n    // Una funci\xf3n de ejemplo cuya soluci\xf3n se determina mediante el \\n    // m\xe9todo de bisecci\xf3n. La funci\xf3n es x ^ 3 - x ^ 2 + 2\\n    static double func(double x) {\\n        return x * x * x - x * x + 2;\\n    }\\n\\n    // Derivada de la funci\xf3n anterior que es 3 * x ^ x - 2 * x\\n    static double derivFunc(double x) {\\n        return 3 * x * x - 2 * x;\\n    }\\n\\n    // Funci\xf3n para encontrar la ra\xedz\\n    static void newtonRaphson(double x) {\\n        double h = func(x) / derivFunc(x);\\n        while (Math.abs(h) >= EPSILON) {\\n            h = func(x) / derivFunc(x);\\n            // x (yo + 1) = x (yo) - f (x) / f \'(x)\\n            x = x - h;\\n        }\\n\\n        System.out.print(\\"The value of the\\"\\n                + \\" root is : \\"\\n                + Math.round(x * 100.0) / 100.0);\\n    }\\n\\n    public static void main(String[] args) {\\n\\n        // Valores iniciales asumidos\\n        double x0 = -20;\\n        newtonRaphson(x0);\\n    }\\n}\\n","cpp":"#include<bits/stdc++.h> \\n#define EPSILON 0.001 \\nusing namespace std;\\n\\ndouble func(double x) {\\n    return x * x * x - x * x + 2;\\n}\\n\\ndouble derivFunc(double x) {\\n    return 3 * x * x - 2 * x;\\n}\\n\\nvoid newtonRaphson(double x) {\\n    double h = func(x) / derivFunc(x);\\n    while (abs(h) >= EPSILON) {\\n        h = func(x) / derivFunc(x);\\n\\n        x = x - h;\\n    }\\n\\n    cout << \\"The value of the root is : \\" << x;\\n}\\n\\nint main() {\\n    double x0 = -20;\\n    newtonRaphson(x0);\\n    return 0;\\n} \\n","py":"def func(x): \\n    return x * x * x - x * x + 2\\n  \\ndef derivFunc(x): \\n    return 3 * x * x - 2 * x \\n  \\ndef newtonRaphson(x): \\n    h = func(x) / derivFunc(x) \\n    while abs(h) >= 0.0001: \\n        h = func(x) / derivFunc(x) \\n        x = x - h \\n      \\n    print(\\"The value of the root is : \\", \\n          \\"%.4f\\" % x) \\n  \\nx0 = -20 \\nnewtonRaphson(x0) \\n","orden":6,"suborden":88,"fecha_creacion":"2020-12-05 01:56:18","fecha_modificacion":"2022-03-08 12:05:45"},{"ID":196,"supergrupo":"Matem\xe1tica","tema":"Teorema de Lucas","texto":"Usando el teorema de Lucas para nCr% p:\\nEl teorema de Lucas b\xe1sicamente sugiere que el valor de nCr se puede calcular multiplicando los resultados de niCri donde ni y ri son d\xedgitos individuales en la misma posici\xf3n en representaciones en base p de nyr respectivamente.\\nLa idea es calcular niCri uno por uno para los d\xedgitos individuales ni y ri en base p. Dado que estos d\xedgitos est\xe1n en base p, nunca necesitar\xedamos m\xe1s de O (p) espacio y la complejidad temporal de estos c\xe1lculos individuales estar\xeda limitada por O (p2).\\n\\nComplejidad temporal: La complejidad temporal de esta soluci\xf3n es O (p2 * Logp n). Hay d\xedgitos O (Logp n) en la representaci\xf3n base p de n. Cada uno de estos d\xedgitos es menor que p, por lo tanto, los c\xe1lculos para d\xedgitos individuales toman O (p2). Tenga en cuenta que estos c\xe1lculos se realizan mediante el m\xe9todo DP que lleva O (n * r) tiempo.\\nImplementaci\xf3n alternativa con tiempo O (p2 + Logp n) y espacio O (p2):\\nLa idea es precalcular el tri\xe1ngulo de Pascal para el tama\xf1o p x py almacenarlo en una matriz 2D. Todos los valores necesarios ahora tomar\xedan O (1) tiempo. Por tanto, la complejidad del tiempo total se convierte en O (p2 + Logp n).\\n","complejidad_tiempo":null,"java":"// Una soluci\xf3n basada en el teorema de Lucas para calcular nCr% p\\n\\npublic class LucasTheorem {\\n\\n    // Devuelve nCr% p. En este programa basado en el Teorema de Lucas, \\n    // esta funci\xf3n solo se llama para n <p y r <p. \\n    static int nCrModpDP(int n, int r, int p) {\\n        // La matriz C va a almacenar la \xfaltima fila del tri\xe1ngulo pascal al \\n        // final. Y la \xfaltima entrada de la \xfaltima fila es nCr\\n        int[] C = new int[r + 1];\\n        C[0] = 1; // Fila superior del tri\xe1ngulo de Pascal\\n        // Uno por construye las filas restantes del Tri\xe1ngulo Pascal de arriba a abajo\\n        for (int i = 1; i <= n; i++) {\\n            // Llene las entradas de la fila actual utilizando \\n            // los valores de la fila anterior\\n            for (int j = Math.min(i, r); j > 0; j--) // nCj = (n-1)Cj + (n-1)C(j-1); \\n            {\\n                C[j] = (C[j] + C[j - 1]) % p;\\n            }\\n        }\\n        return C[r];\\n    }\\n\\n    // Funci\xf3n basada en el Teorema de Lucas que devuelve nCr% p Esta \\n    // funci\xf3n funciona como una funci\xf3n recursiva de conversi\xf3n \\n    // decimal a binaria. Primero calculamos los \xfaltimos d\xedgitos \\n    // de nyr en base p, luego recurrimos para los d\xedgitos restantes\\n    static int nCrModpLucas(int n, int r, int p) {\\n        // Caso base\\n        if (r == 0) {\\n            return 1;\\n        }\\n        // Calcule los \xfaltimos d\xedgitos de nyr en base p\\n        int ni = n % p;\\n        int ri = r % p;\\n\\n        // Calcule el resultado de los \xfaltimos d\xedgitos calculados \\n        // anteriormente y de los d\xedgitos restantes. Multiplica los \\n        // dos resultados y calcula el resultado de la \\n        // multiplicaci\xf3n en m\xf3dulo p.\\n        return (nCrModpLucas(n / p, r / p, p)\\n                * // \xdaltimos d\xedgitos de nyr\\n                nCrModpDP(ni, ri, p)) % p; // D\xedgitos restantes\\n    }\\n\\n    public static void main(String[] args) {\\n        int n = 1000, r = 900, p = 13;\\n        System.out.println(\\"Value of nCr % p is \\" + nCrModpLucas(n, r, p));\\n    }\\n}\\n","cpp":"#include<bits/stdc++.h> \\nusing namespace std;\\n\\nint nCrModpDP(int n, int r, int p) {\\n\\n    int C[r + 1];\\n    memset(C, 0, sizeof (C));\\n    C[0] = 1;\\n\\n    for (int i = 1; i <= n; i++) {\\n\\n        for (int j = min(i, r); j > 0; j--)\\n            C[j] = (C[j] + C[j - 1]) % p;\\n    }\\n    return C[r];\\n}\\n\\nint nCrModpLucas(int n, int r, int p) {\\n\\n    if (r == 0)\\n        return 1;\\n    int ni = n % p, ri = r % p;\\n\\n    return (nCrModpLucas(n / p, r / p, p) * nCrModpDP(ni, ri, p)) % p;\\n}\\n\\nint main() {\\n    int n = 1000, r = 900, p = 13;\\n    cout << \\"Value of nCr % p is \\" << nCrModpLucas(n, r, p);\\n    return 0;\\n}\\n","py":"def nCrModpDP(n, r, p): \\n    C = [0] * (n + 1);\\n    C[0] = 1; \\n    for i in range(1, (n + 1)): \\n        j = min(i, r); \\n        while(j > 0): \\n            C[j] = (C[j] + C[j - 1]) % p; \\n            j -= 1; \\n    return C[r]; \\n    \\ndef nCrModpLucas(n, r, p): \\n\\n    if (r == 0): \\n        return 1; \\n    ni = int(n % p); \\n    ri = int(r % p); \\n    return (nCrModpLucas(int(n / p), int(r / p), p) *\\n            nCrModpDP(ni, ri, p)) % p;  \\nn = 1000; \\nr = 900; \\np = 13; \\nprint(\\"Value of nCr % p is\\", \\n      nCrModpLucas(n, r, p)); \\n","orden":6,"suborden":88,"fecha_creacion":"2020-12-05 01:56:18","fecha_modificacion":"2022-03-08 12:05:45"},{"ID":197,"supergrupo":"Geometr\xeda","tema":"\xc1ngulos","texto":"\xc1ngulo es un concepto de la Geometr\xeda para referirse al espacio comprendido entre la intersecci\xf3n de dos l\xedneas que parten de un mismo punto o v\xe9rtice, y que es medido en grados.","complejidad_tiempo":null,"java":"//Dados 3 puntos A, B, y C, determina el valor del angulo ABC (origen en B) \\n//en radianes. \\n//Si se desea convertir a grados sexagesimales, \\n//revisar degrees and radians.\\n\\nimport java.awt.Point;\\n\\npublic class Angle {\\n\\n    static double angle(Point a, Point b, Point c) {\\n        Vec ba = toVector(b, a);\\n        Vec bc = toVector(b, c);\\n        return Math.acos((ba.x * bc.x + ba.y * bc.y) / Math.sqrt((ba.x * ba.x + ba.y * ba.y) * (bc.x * bc.x + bc.y * bc.y)));\\n    }\\n\\n    static class Vec {\\n\\n        public double x, y;\\n\\n        public Vec(double _x, double _y) {\\n            this.x = _x;\\n            this.y = _y;\\n        }\\n    }\\n\\n    static Vec toVector(Point a, Point b) {\\n        return new Vec(b.x - a.x, b.y - a.y);\\n    }\\n\\n    static double DegToRad(double d) {\\n        return d * Math.PI / 180.0;\\n    }\\n\\n    static double RadToDeg(double r) {\\n        return r * 180.0 / Math.PI;\\n    }\\n\\n    public static void main(String[] args) {\\n        Point[] puntos = new Point[]{new Point(0, 0),\\n            new Point(1, 0), new Point(0, 1)};\\n        double res = angle(puntos[0], puntos[1], puntos[2]);\\n        System.out.println(res);\\n        System.out.println(RadToDeg(res));\\n    }\\n\\n","cpp":"#include <cstdlib>\\n#include <bits/stdc++.h>\\nusing namespace std;\\n#define PI  acos(-1.0)\\n\\nstruct Point {\\n    double x, y;\\n\\n    Point() {\\n        x = y = 0.0;\\n    }\\n\\n    Point(double _x, double _y) : x(_x), y(_y) {\\n    }\\n\\n    bool operator==(Point other) const {\\n        return (fabs(x - other.x) < 1e-9 && (fabs(y - other.y) < 1e-9));\\n    }\\n};\\n\\nstruct Vec {\\n    double x, y;\\n\\n    Vec(double _x, double _y) : x(_x), y(_y) {\\n    }\\n};\\n\\nVec toVector(Point a, Point b) {\\n    return Vec(b.x - a.x, b.y - a.y);\\n}\\n\\ndouble angle(Point a, Point b, Point c) {\\n    Vec ba = toVector(b, a);\\n    Vec bc = toVector(b, c);\\n    return acos((ba.x * bc.x + ba.y * bc.y) / sqrt((ba.x * ba.x + ba.y * ba.y) * (bc.x * bc.x + bc.y * bc.y)));\\n}\\n\\ndouble DegToRad(double d) {\\n    return d * acos(-1.0) / 180.0;\\n}\\n\\ndouble RadToDeg(double r) {\\n    return r * 180.0 / acos(-1.0);\\n}\\n\\nint main() {\\n    vector<Point> puntos;\\n    Point a = {0, -1};\\n    Point b = {0, 0};\\n    Point c = {0, 1};\\n    puntos.emplace_back(a);\\n    puntos.emplace_back(b);\\n    puntos.emplace_back(c);\\n    double res = angle(puntos.at(0), puntos.at(1), puntos.at(2));\\n    cout << res << endl;\\n    cout << RadToDeg(res) << endl;\\n}\\n","py":"import math as math\\nclass Point:\\n    def __init__(self, x, y):\\n        self.x = x\\n        self.y = y\\n \\n    def equals(self, other):\\n        if (abs(self.x - other.x) < 1e-9 and (abs(self.y - other.y) < 1e-9)):\\n            return True\\n        return False\\nclass Vec:\\n    def __init__(self, x, y):\\n        self.x = x\\n        self.y = y\\ndef toVector(a, b):\\n    return Vec(b.x - a.x, b.y - a.y)\\ndef angle(a, b, c):\\n    ba = toVector(b, a)\\n    bc = toVector(b, c)\\n    return math.acos((ba.x * bc.x + ba.y * bc.y) / math.sqrt((ba.x * ba.x + ba.y * ba.y) * (bc.x * bc.x + bc.y * bc.y)))\\n\\n\\ndef DegToRad (d):\\n    return d * math.acos(-1.0) / 180.0\\n\\n\\ndef RadToDeg(r): \\n    return r * 180.0 / math.acos(-1.0)\\npuntos = []\\npuntos.append(Point(0, -1))\\npuntos.append(Point(0, 0))\\npuntos.append(Point(0, 1))\\nres = angle(puntos[0], puntos[1], puntos[2]);\\nprint(res)\\nprint(RadToDeg(res))\\n\\n","orden":7,"suborden":20,"fecha_creacion":"2020-12-06 19:51:35","fecha_modificacion":"2022-03-08 12:13:57"},{"ID":198,"supergrupo":"Geometr\xeda","tema":"Puntos 2D","texto":"El PUNTO es una \xabfigura geom\xe9trica\xbb adimensional: no tiene longitud, \xe1rea, volumen, ni otro \xe1ngulo dimensional. No es un objeto f\xedsico. Describe una posici\xf3n en el espacio, determinada respecto de un sistema de coordenadas preestablecido.\\n\\nA los puntos se les suele nombrar con una letra may\xfascula: A, B, C, etc.\\n\\n \\n\\nEl concepto de punto, como ente geom\xe9trico, surge en la antigua concepci\xf3n griega de la geometr\xeda, compilada en Alejandr\xeda por Euclides en su tratado Los Elementos, dando una definici\xf3n de punto excluyente: \xablo que no tiene ninguna parte\xbb. El punto, en la geometr\xeda cl\xe1sica se basa en la idea de que era un concepto intuitivo, el ente geom\xe9trico \xabsin dimensiones\xbb, y s\xf3lo era necesario asumir la noci\xf3n de punto.\\n\\nEsa cuesti\xf3n fue analizada por A. N. Whitehead en: Una investigaci\xf3n sobre los principios naturales de conocimiento (An Inquiry Concerning the Principles of Natural Knowledge), y El concepto de la Naturaleza (The concept of Nature). En estos libros se expone la \xabrelaci\xf3n de inclusi\xf3n\xbb. En Proceso y Realidad (Process and Reality) Whitehead propone un nuevo enfoque basado en la \xabrelaci\xf3n de conexi\xf3n\xbb topol\xf3gica. Tambi\xe9n H. J. Schmidt plantea una visi\xf3n totalmente distinta del punto geom\xe9trico.\\n\\n\\nDeterminaci\xf3n geom\xe9trica\\n\\nUn punto puede determinarse con diversos sistemas de referencia:\\n\\nEn el sistema de coordenadas cartesianas, se determina mediante las distancias ortogonales a los ejes principales, que se indican con dos letras o n\xfameros: (x, y) en el plano; y con tres en el espacio (x, y, z).\\n\\nEn coordenadas polares, mediante su distancia al centro y la medida angular respecto del eje de referencia: (r, \u03b8).\\n\\nEn coordenadas esf\xe9ricas, mediante su distancia al centro y la medida angular respecto de los ejes de referencia: (r, \u03b8, \u03c6).\\n\\nEn coordenadas cil\xedndricas, mediante coordenadas radial, acimutal y altura: (\u03c1, \u03c6, z).\\n\\nTambi\xe9n se pueden emplear sistemas de coordenadas el\xedpticas, parab\xf3licas, esferoidales, toridales, etc.\\n\\n\\nSEGMENTO\\n\\nUn segmento, en geometr\xeda, es un fragmento de recta que est\xe1 comprendido entre dos puntos.\\n\\n\xf3 tambi\xe9n\\n\\nSegmento es la porci\xf3n de recta limitada por dos puntos, llamados extremos.\\n\\nTipos de segmentos\\n\\nSegmento nulo: Un segmento es nulo cuando sus extremos coinciden.\\n\\n\\nSegmentos consecutivos\\n\\nDos segmentos son consecutivos cuando tienen un extremo en com\xfan.\\t \\n\\nSeg\xfan pertenezcan o no a la misma l\xednea, se clasifican en:\\n\\nColineales\\n\\nNo colineales: Los segmentos consecutivos no colineales, llamados poligonal o quebrada, pueden ser abiertos o cerrados seg\xfan tengan o no extremos comunes el primer y el \xfaltimo segmento que lo forman. Las poligonales cerradas forman pol\xedgonos.\\n \\nLA RECTA\\n\\nEn geometr\xeda euclidiana, la recta o l\xednea recta, es el ente ideal que se extiende en una misma direcci\xf3n, existe en una sola dimensi\xf3n y contiene infinitos puntos; est\xe1 compuesta de infinitos segmentos (el fragmento de l\xednea m\xe1s corto que une dos puntos). Tambi\xe9n se describe como la sucesi\xf3n continua e indefinida de puntos en una sola dimensi\xf3n, o sea, no posee principio ni fin.\\n \\nLa Recta se nombra con una letra Min\xfascula o dos May\xfasculas y se lee la recta AB, la recta HG y la recta m.\\n \\nLA SEMIRECTA\\n\\nLa Semirecta se nombra con dos May\xfasculas y se lee la Semirecta AB, la Semirecta HG.\\n\\nPLANO\\n\\nEn geometr\xeda, un plano es el ente ideal que s\xf3lo posee dos dimensiones, y contiene infinitos puntos y rectas; es uno de los entes geom\xe9tricos fundamentales junto con el punto y la recta.\\n\\nSolamente puede ser definido o descrito en relaci\xf3n a otros elementos geom\xe9tricos similares. Se suele describir apoy\xe1ndose en los postulados caracter\xedsticos, que determinan las relaciones entre los entes geom\xe9tricos fundamentales. .-Cuando se habla de un plano, se est\xe1 haciendo referencia a la superficie geom\xe9trica que no posee volumen (es decir, que es s\xf3lo bidimensional) y que posee un n\xfamero infinito de rectas y puntos que lo cruzan de un lado al otro. Sin embargo, cuando el t\xe9rmino se utiliza en plural, se est\xe1 hablando de aquel material que es elaborado como una representaci\xf3n gr\xe1fica de superficies de diferente tipo. Los planos son especialmente utilizados en ingenier\xeda, arquitectura y dise\xf1o ya que sirven para diagramar en una superficie plana otras superficies que son regularmente tridimensionales.\\n\\nUn plano queda definido por los siguientes elementos geom\xe9tricos:\\n\\nTres puntos no alineados.\\nUna recta y un punto exterior a ella.\\nDos rectas paralelas.\\nDos rectas que se cortan\\n\\nLos planos suelen nombrarse con una letra del alfabeto griego: Alfa (\u03b1), Beta (\u03b2), Theta (\u03b8), Fi (\u03c6) entre otras\\n\\nSuele representarse gr\xe1ficamente, para su mejor visualizaci\xf3n, como una figura delimitada por bordes irregulares (para indicar que el dibujo es una parte de una superficie infinita).\\n","complejidad_tiempo":null,"java":"// La clase punto ser\xe1 la base sobre la cual se ejecuten otros algoritmos. \\n\\n public class PointClass {\\n\\n    static class Point {\\n\\n        public double x, y;\\n\\n        public Point() {\\n            this.x = this.y = 0.0;\\n        }\\n\\n        public Point(double _x, double _y) {\\n            this.x = _x;\\n            this.y = _y;\\n        }\\n\\n        public boolean equals(Point other) {\\n            if (Math.abs(this.x - other.x) < 1e-9 && (Math.abs(this.y - other.y) < 1e-9)) {\\n                return true;\\n            }\\n            return false;\\n        }\\n\\n    }\\n    \\n     public static void main(String[] args) {\\n         //coordenadas en x y y\\n         Point A= new Point(0, 0);\\n     }\\n}\\n","cpp":"#include \\"bits/stdc++.h\\" \\nusing namespace std;\\n\\nstruct Point {\\n    double x, y;\\n\\n    Point() {\\n        x = y = 0.0;\\n    }\\n\\n    Point(double _x, double _y) : x(_x), y(_y) {\\n    }\\n\\n    bool operator==(Point other) const {\\n        return (fabs(x - other.x) < 1e-9 && (fabs(y - other.y) < 1e-9));\\n    }\\n};\\n\\nint main() {\\n    Point A = Point(0, 0);\\n}\\n","py":"class Point:\\n    def __init__(self, x, y):\\n        self.x = x\\n        self.y = y\\n \\n    def compare(self, other):\\n        if (abs(self.x - other.x) < 1e-9 and (abs(self.y - other.y) < 1e-9)):\\n            return True\\n        return False\\n    \\nA = Point(0, 0)\\n","orden":7,"suborden":21,"fecha_creacion":"2020-12-06 19:51:35","fecha_modificacion":"2022-03-08 12:13:57"},{"ID":199,"supergrupo":"Geometr\xeda","tema":"Per\xedmetro de un pol\xedgono","texto":"El per\xedmetro y el \xe1rea son dos elementos fundamentales en matem\xe1ticas. Para cuantificar el espacio f\xedsico y tambi\xe9n para proveer las bases de matem\xe1ticas m\xe1s avanzadas como en el \xe1lgebra, trigonometr\xeda, y c\xe1lculo. El per\xedmetro es una medida de la distancia alrededor de una figura y el \xe1rea nos da una idea de qu\xe9 tanta superficie cubre dicha figura.\\n \\n \\nPer\xedmetro\\n \\nEl per\xedmetro de una figura de dos dimensiones es la distancia alrededor de la figura. Algunas personas encuentran \xfatil pensar \u201cperi-metro\u201d donde peri es \u201cperiferia\u201d y metro es \u201cmedida\u201d.\\n \\nSi la figura es un pol\xedgono, entonces puede sumar todas las longitudes de sus lados para encontrar el per\xedmetro. \\n","complejidad_tiempo":null,"java":"//Calcula el per\xedmetro de un pol\xedgono representado \\n//como un vector de puntos. \\n//IMPORTANTE: Definir P[0] = P[n-1] para cerrar el pol\xedgono. \\n//La estructura point debe estar definida, al igual que el\\n//m\xe9todo euclideanDistance.\\n\\nimport java.util.ArrayList;\\nimport java.awt.Point;\\n\\npublic class Perimeter {\\n\\n    public static double perimeter(ArrayList<Point> P) {\\n        double result = 0.0;\\n        for (int i = 0; i < P.size() - 1; i++) {\\n            result += euclideanDistance(P.get(i), P.get(i + 1));\\n        }\\n        return result;\\n    }\\n\\n    /*Trabajando con la clase Point*/\\n    static double euclideanDistance(Point p1, Point p2) {\\n        return Math.hypot(p1.x - p2.x, p1.y - p2.y);\\n    }\\n\\n    /*Trabajando con los valores x y y de cada punto*/\\n    static double euclideanDistance(double x1, double y1, double x2, double y2) {\\n        return Math.hypot(x2 - x1, y2 - y1);\\n    }\\n\\n    public static void main(String[] args) {\\n        ArrayList<Point> polygon = new ArrayList<>();\\n        polygon.add(new Point(0, 0));\\n        polygon.add(new Point(1, 0));\\n        polygon.add(new Point(1, 1));\\n        polygon.add(new Point(0, 1));\\n        polygon.add(new Point(0, 0));\\n        System.out.println(perimeter(polygon));\\n    }\\n}\\n","cpp":"using namespace std;\\n\\nstruct Point {\\n    double x, y;\\n\\n    Point() {\\n        x = y = 0.0;\\n    }\\n\\n    Point(double _x, double _y) : x(_x), y(_y) {\\n    }\\n\\n};\\n\\ndouble euclideanDistance(Point p1, Point p2) {\\n    return hypot(p1.x - p2.x, p1.y - p2.y);\\n}\\n\\ndouble perimeter(vector<Point> P) {\\n    double result = 0.0;\\n    for (int i = 0; i < P.size() - 1; i++) {\\n        result += euclideanDistance(P[i], P[i + 1]);\\n    }\\n    return result;\\n}\\n\\ndouble euclideanDistance(double x1, double y1, double x2, double y2) {\\n    return hypot(x2 - x1, y2 - y1);\\n}\\n\\nint main() {\\n    vector<Point> polygon;\\n    polygon.emplace_back(Point(0, 0));\\n    polygon.emplace_back(Point(1, 0));\\n    polygon.emplace_back(Point(1, 1));\\n    polygon.emplace_back(Point(0, 1));\\n    polygon.emplace_back(Point(0, 0));\\n    cout << perimeter(polygon) << endl;\\n}\\n","py":"import math as math\\nclass Point:\\n    def __init__(self, x, y):\\n        self.x = x\\n        self.y = y\\n        \\ndef euclideanDistance(p1, p2):\\n    return math.hypot(p1.x - p2.x, p1.y - p2.y)\\n\\ndef perimeter(P):\\n    result = 0.0\\n    for i in range (len(P)-1):\\n        result += euclideanDistance(P[i], P[i + 1])\\n    return result;\\n\\npolygon = []\\npolygon.append(Point(0, 0));\\npolygon.append(Point(1, 0));\\npolygon.append(Point(1, 1));\\npolygon.append(Point(0, 1));\\npolygon.append(Point(0, 0));\\nprint(perimeter(polygon))\\n","orden":7,"suborden":22,"fecha_creacion":"2020-12-06 19:51:36","fecha_modificacion":"2022-03-08 12:13:57"},{"ID":200,"supergrupo":"Geometr\xeda","tema":"Area de un  pol\xedgono","texto":"Las f\xf3rmulas para calcular el \xe1rea de un pol\xedgono son diferentes seg\xfan si el pol\xedgono es regular o irregular:\\nPol\xedgono regular: es un pol\xedgono con todos los lados y \xe1ngulos iguales.\\nPol\xedgono irregular: pol\xedgono con con los lados y \xe1ngulos desiguales.\\n \\nMientras que el \xe1rea del pol\xedgono regular se calcula a partir de un lado y la apotema, el \xe1rea del pol\xedgono irregular requiere de m\xe9todos alternativos de c\xe1lculo de \xe1reas: m\xe9todo de triangulaci\xf3n o determinante de Gauss.\\n\xc1rea del pol\xedgono regular\\nEl \xe1rea de un pol\xedgono regular se calcula a partir de su per\xedmetro y su apotema. Sea P el pol\xedgono regular con N lados, su \xe1rea es:\\n \\nEn un pol\xedgono regular, el per\xedmetro se puede determinar por el producto del n\xfamero de lados por la longitud de uno de los lados, es decir, Per\xedmetro=N\xb7L. O sea:\\n \\n\xc1rea del pol\xedgono irregular\\nEl c\xe1lculo del \xe1rea de un pol\xedgono irregular requiere de m\xe9todos alternativos de c\xe1lculo de \xe1reas. El m\xe9todo m\xe1s com\xfan es dividir el pol\xedgono en N tri\xe1ngulos (siendo N el n\xfamero de lados del pol\xedgono) y calcular la \xe1rea como suma de las \xe1reas de los tri\xe1ngulos. \\n \\nEl \xe1rea del pol\xedgono irregular se puede calcular mediante dos procedimientos alternativos: el m\xe9todo de triangulaci\xf3n o el determinante de Gauss.\\n","complejidad_tiempo":null,"java":"//Calcula el area de un pol\xedgono representado como un \\n//ArrayList de puntos. \\n//IMPORTANTE: Definir P[0] = P[n-1] para cerrar el pol\xedgono. \\n//El algor\xedtmo utiliza el metodo de determinante \\n//de la matriz de puntos de la figura. \\n\\nimport java.util.ArrayList;\\nimport java.awt.Point;\\n\\npublic class Area {\\n\\n    public static double area(ArrayList<Point> P) {\\n        double result = 0.0;\\n        for (int i = 0; i < P.size() - 1; i++) {\\n            result += ((P.get(i).x * P.get(i + 1).y) - (P.get(i + 1).x *            P.get(i).y));\\n        }\\n        return Math.abs(result) / 2.0;\\n    }\\n\\n    public static void main(String[] args) {\\n        ArrayList<Point> puntos = new ArrayList<>();\\n        //los puntos deben ir en orden\\n        puntos.add(new Point(0, 0));\\n        puntos.add(new Point(0, 1));\\n        puntos.add(new Point(1, 1));\\n        puntos.add(new Point(1, 0));\\n        //Definir el ultimo punto igual que el primero para cerrar el poligono\\n        puntos.add(new Point(0, 0));\\n        System.out.println(area(puntos));\\n    }\\n}\\n","cpp":"#include <cstdlib>\\n#include <bits/stdc++.h>\\nusing namespace std;\\n\\nstruct Point {\\n    double x, y;\\n\\n    Point() {\\n        x = y = 0.0;\\n    }\\n\\n    Point(double _x, double _y) : x(_x), y(_y) {\\n    }\\n\\n    bool operator==(Point other) const {\\n        return (fabs(x - other.x) < 1e-9 && (fabs(y - other.y) < 1e-9));\\n    }\\n};\\n\\ndouble area(vector<Point> P) {\\n    double result = 0.0;\\n    for (int i = 0; i < P.size() - 1; i++) {\\n        result += ((P.at(i).x * P.at(i + 1).y) - (P.at(i + 1).x * P.at(i).y));\\n    }\\n    return abs(result) / 2.0;\\n}\\n\\nint main() {\\n    vector<Point> puntos;\\n    puntos.emplace_back(Point(0, 0));\\n    puntos.emplace_back(Point(0, 1));\\n    puntos.emplace_back(Point(1, 1));\\n    puntos.emplace_back(Point(1, 0));\\n    puntos.emplace_back(Point(0, 0));\\n    cout << area(puntos) << endl;\\n}\\n","py":"class Point:\\n    def __init__(self, x, y):\\n        self.x = x\\n        self.y = y\\n \\n    def equals(self, other):\\n        if (abs(self.x - other.x) < 1e-9 and (abs(self.y - other.y) < 1e-9)):\\n            return True\\n        return False\\ndef area(P):\\n    result = 0.0\\n    for i in range (len(P)-1):\\n        result += ((P[i].x * P[i + 1].y) - (P[i + 1].x * P[i].y))\\n    return abs(result) / 2.0;\\npuntos = []\\npuntos.append(Point(0, 0))\\npuntos.append(Point(0, 1))\\npuntos.append(Point(1, 1))\\npuntos.append(Point(1, 0))\\npuntos.append(Point(0, 0))\\nprint(area(puntos))\\n","orden":7,"suborden":23,"fecha_creacion":"2020-12-06 19:51:36","fecha_modificacion":"2022-03-08 12:13:57"},{"ID":201,"supergrupo":"Geometr\xeda","tema":"Intersecci\xf3n de c\xedrculos","texto":"Hay dos c\xedrculos A y B con sus centros C1 (x1, y1) y C2 (x2, y2) y radio R1 y R2. La tarea es comprobar que ambos c\xedrculos A y B se toquen o no.\\nEjemplos:\\nEntrada: C1 = (3, 4)\\n         C2 = (14, 18)\\n         R1 = 5, R2 = 8\\nResultado: Los c\xedrculos no se tocan entre s\xed.\\n\\nEntrada: C1 = (2, 3)\\n         C2 = (15, 28)\\n         R1 = 12, R2 = 10\\nResultado: los c\xedrculos se cruzan entre s\xed.\\n\\nEntrada: C1 = (-10, 8)\\n         C2 = (14, -24)\\n         R1 = 30, R2 = 10\\nEntrada: -10 8\\n         14-24\\n         30 10\\nSalida: C\xedrculos se tocan entre s\xed.\\nLa distancia entre los centros C1 y C2 se calcula como\\n  C1C2 = ra\xedz cuadrada ((x1 - x2) 2 + (y1 - y2) 2).\\nHay tres condiciones que surgen.\\n1. Si C1C2 == R1 + R2\\n      Los c\xedrculos A y B se tocan entre s\xed.\\n2. Si C1C2> R1 + R2\\n      Los c\xedrculos A y B no se tocan entre s\xed.\\n3. Si C1C2 <R1 + R2\\n       El c\xedrculo se cruza entre s\xed.\\n","complejidad_tiempo":null,"java":"// Programa Java para comprobar si dos c\xedrculos se tocan o no.\\n\\npublic class CircleIntersect {\\n\\n    static int circle(int x1, int y1, int x2,\\n            int y2, int r1, int r2) {\\n        int distSq = (x1 - x2) * (x1 - x2)\\n                + (y1 - y2) * (y1 - y2);\\n        int radSumSq = (r1 + r2) * (r1 + r2);\\n        if (distSq == radSumSq) {\\n            return 1;\\n        } else if (distSq > radSumSq) {\\n            return -1;\\n        } else {\\n            return 0;\\n        }\\n    }\\n\\n    public static void main(String[] args) {\\n        int x1 = -10, y1 = 8;\\n        int x2 = 14, y2 = -24;\\n        int r1 = 30, r2 = 10;\\n        int t = circle(x1, y1, x2,\\n                y2, r1, r2);\\n        if (t == 1) {\\n            System.out.println(\\"Circle touch to\\"\\n                    + \\" each other.\\");\\n        } else if (t < 0) {\\n            System.out.println(\\"Circle not touch\\"\\n                    + \\" to each other.\\");\\n        } else {\\n            System.out.println(\\"Circle intersect\\"\\n                    + \\" to each other.\\");\\n        }\\n    }\\n}\\n","cpp":"#include<bits/stdc++.h> \\n#include<cstdlib>\\nusing namespace std;\\n\\nint circle(int x1, int y1, int x2,\\n        int y2, int r1, int r2) {\\n    int distSq = (x1 - x2) * (x1 - x2)\\n            + (y1 - y2) * (y1 - y2);\\n    int radSumSq = (r1 + r2) * (r1 + r2);\\n    if (distSq == radSumSq) {\\n        return 1;\\n    } else if (distSq > radSumSq) {\\n        return -1;\\n    } else {\\n        return 0;\\n    }\\n}\\n\\nint main() {\\n    int x1 = -10, y1 = 8;\\n    int x2 = 14, y2 = -24;\\n    int r1 = 30, r2 = 10;\\n    int t = circle(x1, y1, x2,\\n            y2, r1, r2);\\n    if (t == 1) {\\n        cout << \\"Circle touch to each other.\\" << endl;\\n    } else if (t < 0) {\\n        cout << \\"Circle not touch to each other.\\" << endl;\\n    } else {\\n        cout << \\"Circle intersect to each other.\\" << endl;\\n    }\\n}\\n","py":"def circle(x1, y1, x2, y2, r1, r2):\\n    distSq = (x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2)\\n    radSumSq = (r1 + r2) * (r1 + r2)\\n    if (distSq == radSumSq):\\n        return 1\\n    elif (distSq > radSumSq):\\n        return -1\\n    else: \\n        return 0\\n\\nx1 = -10\\ny1 = 8\\nx2 = 14\\ny2 = -24\\nr1 = 30\\nr2 = 10\\nt = circle(x1, y1, x2, y2, r1, r2)\\nif (t == 1):\\n    print(\\"Circle touch to each other.\\")\\nelif (t < 0):\\n    print(\\"Circle not touch to each other.\\")\\nelse:\\n    print(\\"Circle intersect to each other.\\")\\n","orden":7,"suborden":24,"fecha_creacion":"2020-12-06 19:51:36","fecha_modificacion":"2022-03-08 12:13:57"},{"ID":202,"supergrupo":"Geometr\xeda","tema":"Limpieza del cuarto","texto":"Dada una habitaci\xf3n con cuadr\xedculas cuadradas que tienen \\"*\\" y \\".\\" Que representan celdas normales y desordenadas respectivamente.\\nDebe averiguar si la habitaci\xf3n se puede limpiar o no.\\nHay una m\xe1quina que le ayuda en esta tarea, pero es capaz de limpiar solo la celda normal. Las celdas desordenadas no se pueden limpiar con la m\xe1quina hasta que haya limpiado la celda normal en su fila o columna. Ahora, verifique si la habitaci\xf3n se puede limpiar o no.\\nLa entrada es la siguiente:\\nLa primera l\xednea contiene el tama\xf1o de la habitaci\xf3n. Las siguientes n l\xedneas contienen una descripci\xf3n para cada fila en la que la fila [i] [j] es \\"\\" si est\xe1 m\xe1s desordenada que otras, de lo contrario, es \\"\\" si es una celda normal.\\nEjemplos:\\nEntrada: 3\\n        . **\\n        . **\\n        . **\\nResultado: S\xed, la habitaci\xf3n se puede limpiar.\\n        1 1\\n        2 1\\n        3 1\\nEntrada: 4\\n       ****\\n       .. *.\\n       .. *.\\n       .. *.\\nResultado: la casa no se puede limpiar.\\nAproximaci\xf3n :\\nEl n\xfamero m\xednimo de celdas puede ser n. Es la \xfanica respuesta posible, ya que debe tener un elemento de tipo \\"\\" en cada fila y columna diferente. Si una columna determinada y una fila determinada contienen \\"\\" en todas las celdas, se sabe que la casa no se puede limpiar. Recorra cada fila y encuentre el \\"\\" que se puede utilizar para la m\xe1quina. Use este paso dos veces, verifique cada columna para cada fila y luego verifique cada fila para cada columna. Luego, verifique si alguno de los dos da una respuesta como n. Si es as\xed, la casa se puede limpiar, de lo contrario no. Este enfoque nos dar\xe1 la respuesta m\xednima requerida.\\n\\nEn el primer ejemplo, la m\xe1quina limpiar\xe1 la celda (1, 1), (2, 1), (3, 1) para limpiar toda la habitaci\xf3n.\\nEn el segundo ejemplo, cada celda de la fila tiene \\"\\" y cada celda de la columna contiene \\"\\", por lo que la casa no se puede limpiar. La fila no se puede limpiar de ninguna manera.\\n","complejidad_tiempo":null,"java":"// c\xf3digo java para encontrar si la casa se puede limpiar o no\\n\\nimport java.util.ArrayList;\\n\\npublic class CleaningRoom {\\n\\n    static class Pair {\\n\\n        int a, b;\\n\\n        public Pair(int a, int b) {\\n            this.a = a;\\n            this.b = b;\\n        }\\n    }\\n    // El array A almacena el string\\n    static int A[][] = new int[105][105];\\n    // ans almacena el par de \xedndices que la m\xe1quina va a limpiar\\n    static ArrayList<Pair> ans = new ArrayList<>();\\n\\n    // Funci\xf3n para imprimir el vector de pares\\n    static void print() {\\n        System.out.println(\\"Yes, the house can be cleaned.\\");\\n        for (int i = 0; i < ans.size(); i++) {\\n            System.out.println((ans.get(i).a + \\" \\" + ans.get(i).b));\\n        }\\n    }\\n\\n    static void solve(int n) {\\n        // inserta cada primera celda en cada fila que contenga \'.\'\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (A[i][j] == \'.\') {\\n                    ans.add(new Pair(i + 1, j + 1));\\n                    break;\\n                }\\n            }\\n        }\\n        // Si el n\xfamero total de celdas es n, la casa se puede limpiar\\n        if (ans.size() == n) {\\n            print();\\n            return;\\n        }\\n        ans = new ArrayList<>();\\n        // inserta cada primera celda en cada columna que contenga \'.\'\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (A[i][j] == \'.\') {\\n                    ans.add(new Pair(i + 1, j + 1));\\n                    break;\\n                }\\n            }\\n        }\\n        // Si el n\xfamero total de celdas es n, la casa se puede limpiar\\n        if (ans.size() == n) {\\n            print();\\n            return;\\n        }\\n        System.out.println(\\"house cannot be cleaned.\\");\\n    }\\n\\n    public static void main(String[] args) {\\n        int n = 3;\\n        String s = \\"\\";\\n        s += \\".**\\";\\n        s += \\".**\\";\\n        s += \\".**\\";\\n        int k = 0;\\n        // Bucle para insertar letras de cadena en la matriz\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < n; j++) {\\n                A[i][j] = s.charAt(k);\\n                k += 1;\\n            }\\n        }\\n        solve(n);\\n    }\\n\\n}\\n","cpp":"#include <bits/stdc++.h> \\nusing namespace std;\\nchar A[105][105];\\nvector<pair<int, int> > ans;\\n\\nvoid print() {\\n    cout << \\"Yes, the house can be\\"\\n            << \\" cleaned.\\" << endl;\\n\\n    for (int i = 0; i < ans.size(); i++)\\n        cout << ans[i].first << \\" \\"\\n            << ans[i].second << endl;\\n}\\n\\nint solve(int n) {\\n    for (int i = 0; i < n; i++) {\\n        for (int j = 0; j < n; j++) {\\n            if (A[i][j] == \'.\') {\\n                ans.push_back(make_pair(i + 1, j + 1));\\n                break;\\n            }\\n        }\\n    }\\n    if (ans.size() == n) {\\n        print();\\n        return 0;\\n    }\\n\\n    ans.clear();\\n\\n    for (int i = 0; i < n; i++) {\\n        for (int j = 0; j < n; j++) {\\n            if (A[j][i] == \'.\') {\\n                ans.push_back(make_pair(i + 1, j + 1));\\n                break;\\n            }\\n        }\\n    }\\n    if (ans.size() == n) {\\n        print();\\n        return 0;\\n    }\\n    cout << \\"house cannot be cleaned.\\" << endl;\\n}\\n\\nint main() {\\n    int n = 3;\\n    string s = \\"\\";\\n    s += \\".**\\";\\n    s += \\".**\\";\\n    s += \\".**\\";\\n    int k = 0;\\n    for (int i = 0; i < n; i++) {\\n        for (int j = 0; j < n; j++)\\n            A[i][j] = s[k++];\\n    }\\n    solve(n);\\n    return 0;\\n}\\n","py":"A = [[0 for i in range(105)] for j in range(105)] \\nans = [] \\n\\ndef printt(): \\n      \\n    print(\\"Yes, the house can be cleaned.\\") \\n    for i in range(len(ans)): \\n        print(ans[i][0], ans[i][1]) \\n          \\ndef solve(n): \\n    global ans \\n    for i in range(n): \\n        for j in range(n): \\n            if (A[i][j] == \'.\'): \\n                ans.append([i + 1, j + 1]) \\n                break\\n    if (len(ans) == n): \\n        printt() \\n        return 0\\n          \\n    ans = [] \\n\\n    for i in range(n): \\n        for j in range(n): \\n            if (A[j][i] == \'.\'): \\n                ans.append([i + 1, j + 1]) \\n                break\\n    if (len(ans) == n): \\n        printt() \\n        return 0\\n    print(\\"house cannot be cleaned.\\") \\n  \\n\\nn = 3\\ns = \\"\\" \\ns += \\".**\\"\\ns += \\".**\\"\\ns += \\".**\\"\\nk = 0\\nfor i in range(n): \\n    for j in range(n): \\n        A[i][j] = s[k] \\n        k += 1\\n  \\nsolve(n) \\n","orden":7,"suborden":25,"fecha_creacion":"2020-12-06 19:51:37","fecha_modificacion":"2022-03-08 12:13:57"},{"ID":203,"supergrupo":"Geometr\xeda","tema":"Distancia Euclidiana","texto":"Se le dan dos coordenadas (x1, y1) y (x2, y2) de un gr\xe1fico bidimensional. Calcula la distancia entre ellos.\\nEjemplos:\\nEntrada: x1, y1 = (3, 4)\\n         x2, y2 = (7, 7)\\nSalida: 5\\n\\nEntrada: x1, y1 = (3, 4)\\n         x2, y2 = (4, 3)\\nSalida: 1.41421\\n","complejidad_tiempo":null,"java":"//Halla la distancia euclideana de 2 puntos en dos dimensiones (x,y). Para usar el primer m\xe9todo, debe definirse previamente la clase Point\\n\\nimport java.awt.Point;\\n\\npublic class EuclideanDistance {\\n\\n    /*Trabajando con la clase Point*/\\n    static double euclideanDistance(Point p1, Point p2) {\\n        return Math.hypot(p1.x - p2.x, p1.y - p2.y);\\n    }\\n\\n    /*Trabajando con los valores x y y de cada punto*/\\n    static double euclideanDistance(double x1, double y1, double x2, double y2) {\\n        return Math.hypot(x2 - x1, y2 - y1);\\n    }\\n\\n    public static void main(String[] args) {\\n        System.out.println(euclideanDistance(new Point(0, 0), new Point(20, 20)));\\n        System.out.println(euclideanDistance(0, 0, 20, 20));\\n    }\\n\\n}\\n","cpp":"#include <cstdlib>\\n#include <bits/stdc++.h>\\nusing namespace std;\\n\\nstruct Point {\\n    double x, y;\\n\\n    Point() {\\n        x = y = 0.0;\\n    }\\n\\n    Point(double _x, double _y) : x(_x), y(_y) {\\n    }\\n\\n    bool operator==(Point other) const {\\n        return (fabs(x - other.x) < 1e-9 && (fabs(y - other.y) < 1e-9));\\n    }\\n};\\n\\ndouble euclideanDistance(Point p1, Point p2) {\\n    return hypot(p1.x - p2.x, p1.y - p2.y);\\n}\\n\\ndouble euclideanDistance(double x1, double y1, double x2, double y2) {\\n    return hypot(x2 - x1, y2 - y1);\\n}\\n\\nint main() {\\n    cout << euclideanDistance(Point(0, 0), Point(20, 20)) << endl;\\n    cout << euclideanDistance(0, 0, 20, 20) << endl;\\n\\n}\\n","py":"import math\\nclass Point:\\n    def __init__(self, x, y):\\n        self.x = x\\n        self.y = y\\n \\n    def equals(self, other):\\n        if (abs(self.x - other.x) < 1e-9 and (abs(self.y - other.y) < 1e-9)):\\n            return True\\n        return False\\ndef euclideanDistance1(p1, p2):\\n    return math.hypot(p1.x - p2.x, p1.y - p2.y);\\n\\n\\ndef euclideanDistance(x1, y1, x2, y2):\\n    return math.hypot(x2 - x1, y2 - y1)\\nprint(euclideanDistance1(Point(0, 0), Point(20, 20)))\\nprint(euclideanDistance(0, 0, 20, 20))\\n","orden":7,"suborden":26,"fecha_creacion":"2020-12-06 19:51:37","fecha_modificacion":"2022-03-08 12:13:57"},{"ID":204,"supergrupo":"Geometr\xeda","tema":"Vector geom\xe9trico","texto":"Un vector director es un vector que da la direcci\xf3n de una recta y tambi\xe9n la orienta, es decir, le da un sentido determinado.\\nEn el plano, en el espacio tridimensional o en cualquier espacio vectorial, una recta se puede definir con dos puntos o, de manera equivalente, con un punto y un vector director. En efecto, a partir de dos puntos distintos A y B se obtiene un punto, digamos A, y un vector director u = AB. Rec\xedprocamente, con un punto A de la recta y un vector director u se construye un segundo punto de la misma, definido por AB = u. Esta recta se escribe (AB) o (A, u).\\n","complejidad_tiempo":null,"java":"import java.awt.Point;\\n//Dados dos puntos A y B, crea el vector A->B. \\n//Es llamado Vec para no confundirlo con vector \\n//como colecci\xf3n de elementos.\\n\\npublic class GeometricVector {\\n\\n    static class Vec {\\n\\n        public double x, y;\\n\\n        public Vec(double _x, double _y) {\\n            this.x = _x;\\n            this.y = _y;\\n        }\\n    }\\n\\n    static Vec toVector(Point a, Point b) {\\n        return new Vec(b.x - a.x, b.y - a.y);\\n    }\\n\\n    public static void main(String[] args) {\\n        Point a = new Point(0, 0);\\n        Point b = new Point(5, 5);\\n        Vec segmento = toVector(a, b);\\n    }\\n}\\n","cpp":"#include <bits/stdc++.h>\\n#include <cstdlib>\\nusing namespace std;\\n\\nstruct Point {\\n    double x, y;\\n\\n    Point() {\\n        x = y = 0.0;\\n    }\\n\\n    Point(double _x, double _y) : x(_x), y(_y) {\\n    }\\n\\n    bool operator==(Point other) const {\\n        return (fabs(x - other.x) < 1e-9 && (fabs(y - other.y) < 1e-9));\\n    }\\n};\\n\\nstruct Vec {\\n    double x, y;\\n\\n    Vec(double _x, double _y) : x(_x), y(_y) {\\n    }\\n};\\n\\nVec toVector(Point a, Point b) {\\n    return Vec(b.x - a.x, b.y - a.y);\\n}\\n\\nint main() {\\n    Point a = {0, 0};\\n    Point b = {5, 5};\\n    Vec segmento = toVector(a, b);\\n}\\n","py":"class Point:\\n    def __init__(self, x, y):\\n        self.x = x\\n        self.y = y\\n \\n    def equals(self, other):\\n        if (abs(self.x - other.x) < 1e-9 and (abs(self.y - other.y) < 1e-9)):\\n            return True\\n        return False\\nclass Vec:\\n    def __init__(self, x, y):\\n        self.x = x\\n        self.y = y\\ndef toVector(a, b):\\n    return Vec(b.x - a.x, b.y - a.y)\\ndef angle(a, b, c):\\n    ba = toVector(b, a)\\n    bc = toVector(b, c)\\n    return math.acos((ba.x * bc.x + ba.y * bc.y) / math.sqrt((ba.x * ba.x + ba.y * ba.y) * (bc.x * bc.x + bc.y * bc.y)))\\n\\na = Point(0, 0)\\nb = Point(5, 5)\\nsegmento = toVector(a, b)\\n","orden":7,"suborden":27,"fecha_creacion":"2020-12-06 19:51:37","fecha_modificacion":"2022-03-08 12:13:57"},{"ID":205,"supergrupo":"Geometr\xeda","tema":"Punto dentro de un pol\xedgono","texto":"Dado un pol\xedgono y un punto \\"p\\", averig\xfce si \\"p\\" se encuentra dentro del pol\xedgono o no. Los puntos que se encuentran en el borde se consideran dentro\\n\\nA continuaci\xf3n se presenta una idea sencilla para comprobar si un punto est\xe1 dentro o fuera.\\n1) Dibuja una l\xednea horizontal a la derecha de cada punto y exti\xe9ndela hasta el infinito\\n\\n1) Cuente el n\xfamero de veces que la l\xednea se cruza con los bordes del pol\xedgono.\\n\\n2) Un punto est\xe1 dentro del pol\xedgono si el recuento de intersecciones es impar o\\n    el punto se encuentra en un borde de pol\xedgono. Si ninguna de las condiciones es verdadera, entonces\\n    el punto se encuentra afuera.\\n \\n\xbfC\xf3mo manejar el punto \\"g\\" en la figura anterior?\\nTenga en cuenta que debemos devolver verdadero si el punto se encuentra en la l\xednea o igual que uno de los v\xe9rtices del pol\xedgono dado. Para manejar esto, despu\xe9s de verificar si la l\xednea desde \\"p\\" hasta el extremo se interseca, verificamos si \\"p\\" es colineal con los v\xe9rtices de la l\xednea actual del pol\xedgono. Si es coliear, entonces verificamos si el punto \\"p\\" se encuentra en el lado actual del pol\xedgono, si se encuentra, devolvemos verdadero, de lo contrario falso.\\n","complejidad_tiempo":null,"java":"//Determina si un punto pt se encuentra en el pol\xedgono \\n//P. Este pol\xedgono se define como un vector de puntos, \\n//donde el punto 0 y n-1 son el mismo. \\nimport java.util.ArrayList;\\nimport java.awt.Point;\\n\\npublic class PointtInPolygon {\\n\\n    static boolean ccw(Point p, Point q, Point r) {\\n        return cross(toVector(p, q), toVector(p, r)) > 0;\\n    }\\n\\n    static boolean inPolygon(Point pt, ArrayList<Point> P) {\\n        if (P.isEmpty()) {\\n            return false;\\n        }\\n        double sum = 0;\\n        for (int i = 0; i < P.size() - 1; i++) {\\n            if (ccw(pt, P.get(i), P.get(i + 1))) {\\n                sum += angle(P.get(i), pt, P.get(i + 1));\\n            } else {\\n                sum -= angle(P.get(i), pt, P.get(i + 1));\\n            }\\n        }\\n        if (Math.abs(Math.abs(sum) - 2 * Math.acos(-1.0)) < 1e-9) {\\n            return true;\\n        }\\n        return false;\\n    }\\n\\n    static double cross(Vec a, Vec b) {\\n        return a.x * b.y - a.y * b.x;\\n    }\\n\\n    static boolean collinear(Point p, Point q, Point r) {\\n        return Math.abs(cross(toVector(p, q), toVector(p, r))) < 1e-9;\\n    }\\n\\n    static double angle(Point a, Point b, Point c) {\\n        Vec ba = toVector(b, a);\\n        Vec bc = toVector(b, c);\\n        return Math.acos((ba.x * bc.x + ba.y * bc.y) / Math.sqrt((ba.x * ba.x + ba.y * ba.y) * (bc.x * bc.x + bc.y * bc.y)));\\n    }\\n\\n    static class Vec {\\n\\n        public double x, y;\\n\\n        public Vec(double _x, double _y) {\\n            this.x = _x;\\n            this.y = _y;\\n        }\\n    }\\n\\n    static Vec toVector(Point a, Point b) {\\n        return new Vec(b.x - a.x, b.y - a.y);\\n    }\\n\\n    public static void main(String[] args) {\\n        ArrayList<Point> polygon = new ArrayList<>();\\n        polygon.add(new Point(0, 0));\\n        polygon.add(new Point(2, 0));\\n        polygon.add(new Point(2, 2));\\n        polygon.add(new Point(0, 2));\\n        polygon.add(new Point(0, 0));\\n        Point punto = new Point(1, 1);\\n        if (inPolygon(punto, polygon)) {\\n            System.out.println(\\"Si\\");\\n        } else {\\n            System.out.println(\\"No\\");\\n        }\\n    }\\n}\\n","cpp":"#include \\"bits/stdc++.h\\" \\nusing namespace std;\\n\\nstruct Point {\\n    double x, y;\\n\\n    Point() {\\n        x = y = 0.0;\\n    }\\n\\n    Point(double _x, double _y) : x(_x), y(_y) {\\n    }\\n\\n    bool operator==(Point other) const {\\n        return (fabs(x - other.x) < 1e-9 && (fabs(y - other.y) < 1e-9));\\n    }\\n};\\n\\nstruct Vec {\\n    double x, y;\\n\\n    Vec(double _x, double _y) {\\n        x = _x;\\n        y = _y;\\n    }\\n};\\n\\nstatic Vec toVector(Point a, Point b) {\\n    return Vec(b.x - a.x, b.y - a.y);\\n}\\n\\ndouble angle(Point a, Point b, Point c) {\\n    Vec ba = toVector(b, a);\\n    Vec bc = toVector(b, c);\\n    return acos((ba.x * bc.x + ba.y * bc.y) / sqrt((ba.x * ba.x + ba.y * ba.y) * (bc.x * bc.x + bc.y * bc.y)));\\n}\\n\\ndouble cross(Vec a, Vec b) {\\n    return a.x * b.y - a.y * b.x;\\n}\\n\\nbool ccw(Point p, Point q, Point r) {\\n    return cross(toVector(p, q), toVector(p, r)) > 0;\\n}\\n\\nbool inPolygon(Point pt, vector<Point> P) {\\n    if (P.empty()) {\\n        return false;\\n    }\\n    double sum = 0;\\n    for (int i = 0; i < P.size() - 1; i++) {\\n        if (ccw(pt, P[i], P[i + 1])) {\\n            sum += angle(P[i], pt, P[i + 1]);\\n        } else {\\n            sum -= angle(P[i], pt, P[i + 1]);\\n        }\\n    }\\n    if (abs(abs(sum) - 2 * acos(-1.0)) < 1e-9) {\\n        return true;\\n    }\\n    return false;\\n}\\n\\nbool collinear(Point p, Point q, Point r) {\\n    return abs(cross(toVector(p, q), toVector(p, r))) < 1e-9;\\n}\\n\\nint main() {\\n    vector<Point> polygon;\\n    polygon.emplace_back(Point(0, 0));\\n    polygon.emplace_back(Point(2, 0));\\n    polygon.emplace_back(Point(2, 2));\\n    polygon.emplace_back(Point(0, 2));\\n    polygon.emplace_back(Point(0, 0));\\n    Point punto = Point(1, 1);\\n    if (inPolygon(punto, polygon)) {\\n        cout << \\"Si\\" << endl;\\n    } else {\\n        cout << \\"No\\" << endl;\\n    }\\n}\\n","py":"import math\\n \\nclass Point:\\n    def __init__(self, x, y):\\n        self.x = x\\n        self.y = y\\n \\n    def compare(self, other):\\n        if (abs(self.x - other.x) < 1e-9 and (abs(self.y - other.y) < 1e-9)):\\n            return True\\n        return False\\n    \\nclass Vec:\\n    def __init__(self, x, y):\\n        self.x = x\\n        self.y = y\\n   \\ndef toVector(a, b):\\n    return Vec(b.x - a.x, b.y - a.y)\\n\\ndef angle(a, b, c):\\n    ba = toVector(b, a)\\n    bc = toVector(b, c)\\n    return math.acos((ba.x * bc.x + ba.y * bc.y) / math.sqrt((ba.x * ba.x + ba.y * ba.y) * (bc.x * bc.x + bc.y * bc.y)))\\n\\ndef cross(a, b):\\n    return a.x * b.y - a.y * b.x\\n\\n\\ndef ccw(p, q, r):\\n    return cross(toVector(p, q), toVector(p, r)) > 0\\n\\ndef inPolygon(pt, P):\\n    if (len(P) == 0):\\n        return false;\\n    sum = 0;\\n    for i in range (len(P)-1):\\n        if (ccw(pt, P[i], P[i + 1])):\\n            sum += angle(P[i], pt, P[i + 1])\\n        else:\\n            sum -= angle(P[i], pt, P[i + 1])\\n    if (abs(abs(sum) - 2 * math.acos(-1.0)) < 1e-9):\\n        return True\\n    return False\\n\\ndef collinear(p, q, r):\\n    return abs(cross(toVector(p, q), toVector(p, r))) < 1e-9\\n\\npolygon = []\\npolygon.append(Point(0, 0));\\npolygon.append(Point(2, 0));\\npolygon.append(Point(2, 2));\\npolygon.append(Point(0, 2));\\npolygon.append(Point(0, 0));\\npunto = Point(1, 1)\\nif (inPolygon(punto, polygon)):\\n    print(\\"Si\\")\\nelse:\\n    print(\\"No\\")\\n","orden":7,"suborden":28,"fecha_creacion":"2020-12-06 19:51:38","fecha_modificacion":"2022-03-08 12:13:57"},{"ID":206,"supergrupo":"Geometr\xeda","tema":"Algoritmo lazo de zapato para \xe1reas de pol\xedgonos","texto":"Dadas las coordenadas ordenadas de un pol\xedgono con n v\xe9rtices. Encuentra el \xe1rea del pol\xedgono. Aqu\xed ordenados significa que las coordenadas se dan en sentido horario o antihorario desde el primer v\xe9rtice hasta el \xfaltimo.\\nEjemplos:\\nEntrada: X [] = {0, 4, 4, 0}, Y [] = {0, 0, 4, 4};\\nSalida: 16\\n\\nEntrada: X [] = {0, 4, 2}, Y [] = {0, 0, 4}\\nSalida: 8\\nPodemos calcular el \xe1rea de un pol\xedgono usando la f\xf3rmula de Cordones.\\nArea: \\n = | 1/2 [(x1y2 + x2y3 + ... + xn-1yn + xny1) -\\n           (x2y1 + x3y2 + ... + xnyn-1 + x1yn)] |\\n\xbfPor qu\xe9 se llama F\xf3rmula de cordones de zapatos?\\nLa f\xf3rmula se llama as\xed por la forma en que la evaluamos.\\nEjemplo:\\nDeje que los v\xe9rtices de entrada sean\\n (0, 1), (2, 3) y (4, 7).\\n\\nEl procedimiento de evaluaci\xf3n coincide con el proceso de vinculaci\xf3n\\ncordones de zapatos.\\n\\nEscribimos v\xe9rtices como se muestra a continuaci\xf3n\\n  0 1\\n  2 3\\n  4 7\\n  0 1 [escrito dos veces]\\n\\nevaluamos t\xe9rminos positivos como se muestra a continuaci\xf3n\\n  0 \\\\ 1\\n  2 \\\\ 3\\n  4 \\\\ 7\\n  0 1\\nes decir, 0 * 3 + 2 * 7 + 4 * 1 = 18\\n\\nevaluamos los t\xe9rminos negativos de la siguiente manera\\n  0 1\\n  2/3\\n  4/7\\n  0/1\\nes decir, 0 * 7 + 4 * 3 + 2 * 1 = 14\\n\\n\xc1rea = 1/2 (18 - 14) = 2\\n\xbfComo funciona esto?\\nSiempre podemos dividir un pol\xedgono en tri\xe1ngulos. La f\xf3rmula del \xe1rea se obtiene tomando cada arista AB y calculando el \xe1rea (con signo) del tri\xe1ngulo ABO con un v\xe9rtice en el origen O, tomando el producto cruzado (que da el \xe1rea de un paralelogramo) y dividi\xe9ndolo por 2. Como uno envuelve el pol\xedgono, estos tri\xe1ngulos con \xe1rea positiva y negativa se superpondr\xe1n, y las \xe1reas entre el origen y el pol\xedgono se cancelar\xe1n y sumar\xe1n 0, mientras que solo queda el \xe1rea dentro del tri\xe1ngulo de referencia.\\n","complejidad_tiempo":null,"java":"// Programa Java para evaluar el \xe1rea de un pol\xedgono usando la f\xf3rmula del cord\xf3n\\n\\npublic class ShoelacePoly {\\n\\n    // (X [i], Y [i]) son coordenadas del i-\xe9simo punto.\\n    public static double polygonArea(double X[], double Y[],\\n            int n) {\\n        // Inicializar \xe1rea\\n        double area = 0.0;\\n\\n        // Calcular el valor de la f\xf3rmula del cord\xf3n\\n        int j = n - 1;\\n        for (int i = 0; i < n; i++) {\\n            area += (X[j] + X[i]) * (Y[j] - Y[i]);\\n\\n            // j es el v\xe9rtice anterior a i\\n            j = i;\\n        }\\n\\n        // Return valor absoluto\\n        return Math.abs(area / 2.0);\\n    }\\n\\n    public static void main(String[] args) {\\n        double X[] = {0, 2, 4};\\n        double Y[] = {1, 3, 7};\\n\\n        int n = 3;\\n        System.out.println(polygonArea(X, Y, n));\\n    }\\n\\n}\\n","cpp":"#include <bits/stdc++.h> \\nusing namespace std;\\n\\ndouble polygonArea(double X[], double Y[], int n) {\\n    double area = 0.0;\\n\\n    int j = n - 1;\\n    for (int i = 0; i < n; i++) {\\n        area += (X[j] + X[i]) * (Y[j] - Y[i]);\\n        j = i;\\n    }\\n    return abs(area / 2.0);\\n}\\n\\nint main() {\\n    double X[] = {0, 2, 4};\\n    double Y[] = {1, 3, 7};\\n\\n    int n = sizeof (X) / sizeof (X[0]);\\n\\n    cout << polygonArea(X, Y, n);\\n} \\n","py":"def polygonArea(X, Y, n): \\n    area = 0.0\\n    j = n - 1\\n    for i in range(0, n): \\n        area += (X[j] + X[i]) * (Y[j] - Y[i]) \\n    return int(abs(area / 2.0)) \\n  \\nX = [0, 2, 4] \\nY = [1, 3, 7] \\nn = len(X) \\nprint(polygonArea(X, Y, n)) \\n","orden":7,"suborden":29,"fecha_creacion":"2020-12-06 19:51:38","fecha_modificacion":"2022-03-08 12:13:57"},{"ID":207,"supergrupo":"Geometr\xeda","tema":"N\xfameros de cuadrados en un rect\xe1ngulo ","texto":"Dado un rect\xe1ngulo de m x n, \xbfcu\xe1ntos cuadrados tiene?\\nEjemplos:\\nEntrada: m = 2, n = 2\\nSalida: 5\\nHay 4 cuadrados de tama\xf1o 1x1 +\\n           1 cuadrado de tama\xf1o 2x2.\\n\\nEntrada: m = 4, n = 3\\nSalida: 20\\nHay 12 cuadrados de tama\xf1o 1x1 +\\n           6 cuadrados de tama\xf1o 2x2 +\\n           2 cuadrados de tama\xf1o 3x3.\\n\\nResolvamos primero este problema para m = n, es decir, para un cuadrado:\\nPara m = n = 1, salida: 1\\nPara m = n = 2, salida: 4 + 1 [4 de tama\xf1o 1 \xd7 1 + 1 de tama\xf1o 2 \xd7 2]\\nPara m = n = 3, salida: 9 + 4 + 1 [9 de tama\xf1o 1 \xd7 1 + 4 de tama\xf1o 2 \xd7 2 + 1 de tama\xf1o 3 \xd7 3]\\nPara m = n = 4, salida 16 + 9 + 4 + 1 [16 de tama\xf1o 1 \xd7 1 + 9 de tama\xf1o 2 \xd7 2 + 4 de tama\xf1o 3 \xd7 3 + 1 de tama\xf1o 4 \xd7 4]\\nEn general, parece ser n ^ 2 + (n-1) ^ 2 +\u2026 1 = n (n + 1) (2n + 1) / 6\\n\\nResolvamos este problema cuando m puede no ser igual an:\\nSupongamos que m <= n\\n\\nDe la explicaci\xf3n anterior, sabemos que el n\xfamero de cuadrados en una matriz de m x m es m (m + 1) (2m + 1) / 6\\n\xbfQu\xe9 sucede cuando agregamos una columna, es decir, cu\xe1l es el n\xfamero de cuadrados en la matriz m x (m + 1)?\\nCuando agregamos una columna, el n\xfamero de cuadrados aumentados es m + (m-1) +\u2026 + 3 + 2 + 1\\n[m cuadrados de tama\xf1o 1 \xd7 1 + (m-1) cuadrados de tama\xf1o 2 \xd7 2 +\u2026 + 1 cuadrado de tama\xf1o m x m]\\nQue es igual a m (m + 1) / 2\\nEntonces, cuando agregamos (n-m) columnas, el n\xfamero total de cuadrados aumentados es (n-m) * m (m + 1) / 2.\\nEntonces, el n\xfamero total de cuadrados es m (m + 1) (2m + 1) / 6 + (n-m) * m (m + 1) / 2.\\nUsando la misma l\xf3gica podemos probar cuando n <= m.\\nEntonces, en general,\\nN\xfamero total de cuadrados = m x (m + 1) x (2m + 1) / 6 +\\n                          (n-m) x m x (m + 1) / 2\\n\\ncuando n es una dimensi\xf3n mayor\\nUsando la l\xf3gica anterior para el rect\xe1ngulo, tambi\xe9n podemos probar que el n\xfamero de cuadrados en un cuadrado es n (n + 1) (2n + 1) / 6\\n","complejidad_tiempo":null,"java":"// Programa Java para contar cuadrados en un rect\xe1ngulo de tama\xf1o m x n\\n\\npublic class NumberSquaresRectangle {\\n\\n    // Devuelve el recuento de todos los cuadrados \\n    // en un rect\xe1ngulo de tama\xf1o m x n\\n    static int countSquares(int m,\\n            int n) {\\n        // Si n es menor, intercambie my n\\n        if (n < m) {\\n            // intercambio (m, n)\\n            int temp = m;\\n            m = n;\\n            n = temp;\\n        }\\n        // Ahora n es una dimensi\xf3n mayor, aplica la f\xf3rmula\\n        return m * (m + 1) * (2 * m + 1)\\n                / 6 + (n - m) * m * (m + 1) / 2;\\n    }\\n\\n    public static void main(String[] args) {\\n        int m = 4, n = 3;\\n        System.out.println(\\"Count of squares is \\"\\n                + countSquares(m, n));\\n    }\\n}\\n","cpp":"#include<iostream> \\nusing namespace std;\\n\\nint countSquares(int m, int n) {\\n    if (n < m)\\n        swap(m, n);\\n    return m * (m + 1) * (2 * m + 1) /\\n            6 + (n - m) * m * (m + 1) / 2;\\n}\\n\\nint main() {\\n    int m = 4, n = 3;\\n    cout << \\"Count of squares is \\"\\n            << countSquares(m, n);\\n} \\n","py":"def countSquares(m, n): \\n    if(n < m): \\n        temp = m \\n        m = n \\n        n = temp \\n    return ((m * (m + 1) * (2 * m + 1) / \\n            6 + (n - m) * m * (m + 1) / 2)) \\n  \\nm = 4 \\nn = 3\\nprint(\\"Count of squares is \\", countSquares(m, n)) \\n","orden":7,"suborden":30,"fecha_creacion":"2020-12-06 19:51:38","fecha_modificacion":"2022-03-08 12:13:57"},{"ID":208,"supergrupo":"Geometr\xeda","tema":"Algoritmo de Jarvis para cascos convexos","texto":"Dado un conjunto de puntos en el plano. el casco convexo del conjunto es el pol\xedgono convexo m\xe1s peque\xf1o que contiene todos los puntos del mismo.\\n \\n\xbfC\xf3mo verificar si dos segmentos de l\xednea dados se cruzan?\\nLa idea del algoritmo de Jarvis es simple, comenzamos desde el punto m\xe1s a la izquierda (o punto con el valor m\xednimo de la coordenada x) y seguimos envolviendo puntos en direcci\xf3n contraria a las agujas del reloj. La gran pregunta es, dado un punto p como punto actual, \xbfc\xf3mo encontrar el siguiente punto en la salida? La idea es utilizar la orientaci\xf3n () aqu\xed. El siguiente punto se selecciona como el punto que vence a todos los dem\xe1s puntos en la orientaci\xf3n en sentido antihorario, es decir, el siguiente punto es q si para cualquier otro punto r, tenemos \\"orientaci\xf3n (p, q, r) = en sentido antihorario\\". A continuaci\xf3n se muestra el algoritmo detallado.\\n1) Inicialice p como punto m\xe1s a la izquierda.\\n2) Haga lo siguiente mientras no regresemos al primer punto (o al extremo izquierdo).\\n\u2026 ..A) El siguiente punto q es el punto tal que el triplete (p, q, r) es en sentido antihorario para cualquier otro punto r.\\n\u2026 ..B) siguiente [p] = q (Almacenar q como siguiente de p en el casco convexo de salida).\\n\u2026 ..C) p = q (Establecer p como q para la siguiente iteraci\xf3n).\\n\\nComplejidad del tiempo: para cada punto del casco, examinamos todos los dem\xe1s puntos para determinar el siguiente. La complejidad del tiempo es? (M * n) donde n es el n\xfamero de puntos de entrada y m es el n\xfamero de puntos de salida o de casco (m <= n). En el peor de los casos, la complejidad del tiempo es O (n 2). El peor caso ocurre cuando todos los puntos est\xe1n en el casco (m = n)\\n\\n","complejidad_tiempo":null,"java":"// Programa Java para encontrar el casco convexo de un conjunto de puntos.\\n\\nimport java.util.*;\\n\\nclass ConvexHullJarvis {\\n\\n    static class Point {\\n\\n        int x, y;\\n\\n        Point(int x, int y) {\\n            this.x = x;\\n            this.y = y;\\n        }\\n    }\\n\\n    // Encontrar la orientaci\xf3n del triplete ordenado (p, q, r). \\n    // La funci\xf3n devuelve los siguientes valores\\n    // 0 -> p, q y r son colineales\\n    // 1 -> En sentido horario\\n    // 2 -> en sentido antihorario\\n    public static int orientation(Point p, Point q, Point r) {\\n        int val = (q.y - p.y) * (r.x - q.x)\\n                - (q.x - p.x) * (r.y - q.y);\\n\\n        if (val == 0) {\\n            return 0;  // collinear \\n        }\\n        return (val > 0) ? 1 : 2; // reloj o en sentido antihorario\\n    }\\n\\n    // Imprime el casco convexo de un conjunto de n puntos.\\n    public static void convexHull(Point points[], int n) {\\n        // Debe haber al menos 3 puntos\\n        if (n < 3) {\\n            return;\\n        }\\n\\n        // Inicializar resultado\\n        ArrayList<Point> hull = new ArrayList<>();\\n\\n        // Encuentra el punto m\xe1s a la izquierda\\n        int l = 0;\\n        for (int i = 1; i < n; i++) {\\n            if (points[i].x < points[l].x) {\\n                l = i;\\n            }\\n        }\\n\\n        // Comience desde el punto m\xe1s a la izquierda, contin\xfae \\n        // movi\xe9ndose en sentido antihorario hasta llegar al punto de \\n        // inicio nuevamente. Este ciclo se ejecuta O (h) veces donde h \\n        // es el n\xfamero de puntos en el resultado o la salida. \\n        int p = l, q;\\n        do {\\n            // Agregar el punto actual al resultado\\n            hull.add(points[p]);\\n\\n            // Busque un punto \'q\' tal que la orientaci\xf3n (p, x, q) sea \\n            // en sentido antihorario para todos los puntos \'x\'. La idea es \\n            // realizar un seguimiento del \xfaltimo punto visitado m\xe1s en sentido \\n            // antihorario en q. Si alg\xfan punto \'i\' est\xe1 m\xe1s en sentido \\n            // contrario a las agujas del reloj que q, actualice q.\\n            q = (p + 1) % n;\\n\\n            for (int i = 0; i < n; i++) {\\n                // Si i est\xe1 m\xe1s en sentido antihorario que la q actual, actualice q\\n                if (orientation(points[p], points[i], points[q])\\n                        == 2) {\\n                    q = i;\\n                }\\n            }\\n\\n            // Ahora q es el m\xe1s en sentido antihorario con respecto a p.\\n            // Establezca p como q para la pr\xf3xima iteraci\xf3n, de modo que \\n            // q se agregue al resultado \'casco\'\\n            p = q;\\n\\n        } while (p != l);  // Mientras no llegamos primer point \\n\\n        // Print Result \\n        for (Point temp : hull) {\\n            System.out.println(\\"(\\" + temp.x + \\", \\"\\n                    + temp.y + \\")\\");\\n        }\\n    }\\n\\n    public static void main(String[] args) {\\n        Point points[] = new Point[7];\\n        points[0] = new Point(0, 3);\\n        points[1] = new Point(2, 3);\\n        points[2] = new Point(1, 1);\\n        points[3] = new Point(2, 1);\\n        points[4] = new Point(3, 0);\\n        points[5] = new Point(0, 0);\\n        points[6] = new Point(3, 3);\\n        int n = points.length;\\n        convexHull(points, n);\\n    }\\n}\\n","cpp":"#include <bits/stdc++.h> \\nusing namespace std;\\n\\nstruct Point {\\n    int x, y;\\n};\\n\\nint orientation(Point p, Point q, Point r) {\\n    int val = (q.y - p.y) * (r.x - q.x) -\\n            (q.x - p.x) * (r.y - q.y);\\n\\n    if (val == 0) return 0;\\n    return (val > 0) ? 1 : 2;\\n}\\n\\nvoid convexHull(Point points[], int n) {\\n\\n    if (n < 3) return;\\n    vector<Point> hull;\\n    int l = 0;\\n    for (int i = 1; i < n; i++)\\n        if (points[i].x < points[l].x)\\n            l = i;\\n\\n    int p = l, q;\\n    do {\\n\\n        hull.push_back(points[p]);\\n\\n        q = (p + 1) % n;\\n        for (int i = 0; i < n; i++) {\\n            if (orientation(points[p], points[i], points[q]) == 2)\\n                q = i;\\n        }\\n\\n        p = q;\\n\\n    } while (p != l);\\n\\n    for (int i = 0; i < hull.size(); i++)\\n        cout << \\"(\\" << hull[i].x << \\", \\"\\n            << hull[i].y << \\")\\\\n\\";\\n}\\n\\nint main() {\\n    Point points[] = {\\n        {0, 3},\\n        {2, 2},\\n        {1, 1},\\n        {2, 1},\\n        {3, 0},\\n        {0, 0},\\n        {3, 3}\\n    };\\n    int n = sizeof (points) / sizeof (points[0]);\\n    convexHull(points, n);\\n    return 0;\\n} \\n","py":"class Point: \\n    def __init__(self, x, y): \\n        self.x = x \\n        self.y = y \\n  \\ndef Left_index(points): \\n      \\n    minn = 0\\n    for i in range(1, len(points)): \\n        if points[i].x < points[minn].x: \\n            minn = i \\n        elif points[i].x == points[minn].x: \\n            if points[i].y > points[minn].y: \\n                minn = i \\n    return minn \\n  \\ndef orientation(p, q, r): \\n    val = (q.y - p.y) * (r.x - q.x) - \\\\ (q.x - p.x) * (r.y - q.y) \\n    if val == 0: \\n        return 0\\n    elif val > 0: \\n        return 1\\n    else: \\n        return 2\\n  \\ndef convexHull(points, n): \\n    if n < 3: \\n        return\\n    l = Left_index(points) \\n    hull = [] \\n    p = l \\n    q = 0\\n    while(True): \\n        hull.append(p) \\n        q = (p + 1) % n \\n        for i in range(n): \\n            if(orientation(points[p], \\n               points[i], points[q]) == 2): \\n                q = i \\n        p = q \\n        if(p == l): \\n            break\\n \\n    for each in hull: \\n        print(points[each].x, points[each].y) \\n  \\npoints = [] \\npoints.append(Point(0, 3)) \\npoints.append(Point(2, 2)) \\npoints.append(Point(1, 1)) \\npoints.append(Point(2, 1)) \\npoints.append(Point(3, 0)) \\npoints.append(Point(0, 0)) \\npoints.append(Point(3, 3)) \\nconvexHull(points, len(points)) \\n","orden":7,"suborden":31,"fecha_creacion":"2020-12-06 19:51:38","fecha_modificacion":"2022-03-08 14:36:15"},{"ID":209,"supergrupo":"Strings","tema":"Algoritmo Z","texto":"Este algoritmo encuentra todas las apariciones de un patr\xf3n en un texto en tiempo lineal. Deje que la longitud del texto sea n y el patr\xf3n sea m, entonces el tiempo total tomado es O (m + n) con complejidad de espacio lineal. Ahora podemos ver que la complejidad del tiempo y el espacio es la misma que la del algoritmo KMP, pero este algoritmo es m\xe1s simple de entender.\\nEn este algoritmo, construimos una array Z.\\n\xbfQu\xe9 es Z Array?\\nPara una cadena str [0..n-1], la array Z tiene la misma longitud que la cadena. Un elemento Z [i] de la array Z almacena la longitud de la subcadena m\xe1s larga a partir de str [i], que tambi\xe9n es un prefijo de str [0..n-1]. La primera entrada de la array Z significa menos, ya que la cadena completa siempre es un prefijo de s\xed misma.\\nEjemplo:\\n\xcdndice 0 1 2 3 4 5 6 7 8 9 10 11\\nTexto a a b c a a b x a a a z\\nValores Z X 1 0 0 3 1 0 0 2 2 1 0\\nM\xe1s ejemplos:\\nstr = \\"aaaaaa\\"\\nZ [] = {x, 5, 4, 3, 2, 1}\\n\\nstr = \\"aabaacd\\"\\nZ [] = {x, 1, 0, 2, 1, 0, 0}\\n\\nstr = \\"abababab\\"\\nZ [] = {x, 0, 6, 0, 4, 0, 2, 0}\\n \\n\xbfC\xf3mo es \xfatil la array Z en la b\xfasqueda de patrones en tiempo lineal?\\nLa idea es concatenar patr\xf3n y texto, y crear una cadena \u201cP $ T\u201d donde P es patr\xf3n, $ es un car\xe1cter especial que no debe estar presente en patr\xf3n y texto, y T es texto. Construya la array Z para cadenas concatenadas. En la array Z, si el valor Z en cualquier punto es igual a la longitud del patr\xf3n, entonces el patr\xf3n est\xe1 presente en ese punto.\\nEjemplo:\\nPatr\xf3n P = \\"aab\\", Texto T = \\"baabaa\\"\\n\\nLa cadena concatenada es = \\"aab $ baabaa\\"\\n\\nLa array Z para la cadena concatenada anterior es {x, 1, 0, 0, 0,\\n                                          3, 1, 0, 2, 1}.\\nDado que la longitud del patr\xf3n es 3, el valor 3 en la array Z\\nindica presencia de patr\xf3n.\\n\xbfC\xf3mo construir una array Z?\\n     Una soluci\xf3n simple consiste en ejecutar dos bucles anidados, el bucle externo va a cada \xedndice y el bucle interno encuentra la longitud del prefijo m\xe1s largo que coincide con la subcadena que comienza en el \xedndice actual. La complejidad temporal de esta soluci\xf3n es O (n2).\\n\\n      Podemos construir una array Z en tiempo lineal.\\nLa idea es mantener un intervalo [L, R] que es el intervalo con el m\xe1ximo R\\ntal que [L, R] es una subcadena de prefijo (subcadena que tambi\xe9n es prefijo).\\n\\nLos pasos para mantener este intervalo son los siguientes:\\n\\n1) Si i> R entonces no hay subcadena de prefijo que comience antes de i y\\n   termina despu\xe9s de i, por lo que restablecemos L y R y calculamos nuevo [L, R] comparando\\n   str [0 ..] a str [i ..] y obtener Z [i] (= R-L + 1).\\n\\n2) Si i <= R entonces sea K = i-L, ahora Z [i]> = min (Z [K], R-i + 1) porque\\n   str [i ..] coincide con str [K ..] para al menos R-i + 1 caracteres (est\xe1n en\\n   [L, R] intervalo que sabemos que es una subcadena de prefijo).\\n   Ahora surgen dos sub casos:\\n      a) Si Z [K] <R-i + 1 entonces no hay una subcadena de prefijo que comience en\\n         str [i] (de lo contrario Z [K] ser\xeda m\xe1s grande) entonces Z [i] = Z [K] y\\n         el intervalo [L, R] permanece igual.\\n      b) Si Z [K]> = R-i + 1 entonces es posible extender el intervalo [L, R]\\n         por lo tanto, estableceremos L como i y comenzaremos a emparejar desde str [R] en adelante y\\n         obtener un nuevo R, entonces actualizaremos el intervalo [L, R] y calcularemos Z [i] (= R-L + 1).\\nEl algoritmo se ejecuta en tiempo lineal porque nunca comparamos caracteres menores que R y con la coincidencia aumentamos R en uno para que haya como m\xe1ximo comparaciones T. En el caso de desajuste, el desajuste ocurre solo una vez para cada i (debido a que R se detiene), esa es otra comparaci\xf3n como m\xe1ximo de T que genera complejidad lineal general.\\n","complejidad_tiempo":null,"java":"// Un programa Java que implementa el algoritmo Z para la b\xfasqueda de patrones\\n\\npublic class Zalgorithm {\\n\\n    // imprime todas las apariciones del patr\xf3n en el texto usando algo Z\\n    public static void search(String text, String pattern) {\\n        // Crear cadena concatenada \\"P $ T\\"\\n        String concat = pattern + \\"$\\" + text;\\n        int l = concat.length();\\n\\n        int Z[] = new int[l];\\n        // Construir matriz Z\\n        getZarr(concat, Z);\\n\\n        // ahora recorriendo la matriz Z para la condici\xf3n coincidente\\n        for (int i = 0; i < l; ++i) {\\n            // si Z [i] (regi\xf3n coincidente) es igual al patr\xf3n\\n            // longitud tenemos el patr\xf3n\\n            if (Z[i] == pattern.length()) {\\n                System.out.println(\\"Pattern found at index \\"\\n                        + (i - pattern.length() - 1));\\n            }\\n        }\\n    }\\n\\n    // Rellena la matriz Z para una cadena determinada str [] \\n    private static void getZarr(String str, int[] Z) {\\n\\n        int n = str.length();\\n\\n        // [L, R] crea una ventana que coincida con el prefijo de s\\n        int L = 0, R = 0;\\n\\n        for (int i = 1; i < n; ++i) {\\n            // si i> R nada coincide, entonces calcularemos. Z [i] de manera ingenua.\\n            if (i > R) {\\n                L = R = i;\\n                // R-L = 0 en el inicio, por lo que comenzar\xe1 a verificar desde \\n                // el \xedndice 0. Por ejemplo, para \\"ababab\\" ei = 1, el valor de \\n                // R sigue siendo 0 y Z [i] se convierte en 0. \\n                // Para la cadena \\"aaaaaa\\" e i = 1, Z [i] y R se convierten en 5\\n                while (R < n && str.charAt(R - L) == str.charAt(R)) {\\n                    R++;\\n                }\\n\\n                Z[i] = R - L;\\n                R--;\\n\\n            } else {\\n\\n                // k = i-L entonces k corresponde al n\xfamero que coincide en el intervalo [L, R].\\n                int k = i - L;\\n                // si Z [k] es menor que el intervalo restante, entonces Z [i] \\n                // ser\xe1 igual a Z [k]. Por ejemplo, str = \\"ababab\\", \\n                // i = 3, R = 5 y L = 2\\n                if (Z[k] < R - i + 1) {\\n                    Z[i] = Z[k];\\n                } // Por ejemplo, str = \\"aaaaaa\\" e i = 2, R es 5,\\n                // L es 0 \\n                else {\\n                    // de lo contrario, comience desde R y verifique manualmente\\n                    L = i;\\n                    while (R < n && str.charAt(R - L) == str.charAt(R)) {\\n                        R++;\\n                    }\\n\\n                    Z[i] = R - L;\\n                    R--;\\n                }\\n            }\\n        }\\n    }\\n\\n    public static void main(String[] args) {\\n        String text = \\"GEEKS FOR GEEKS\\";\\n        String pattern = \\"GEEK\\";\\n        search(text, pattern);\\n    }\\n}\\n","cpp":"#include<iostream> \\nusing namespace std;\\n\\nvoid getZarr(string str, int Z[]);\\n\\nvoid search(string text, string pattern) {\\n    string concat = pattern + \\"$\\" + text;\\n    int l = concat.length();\\n\\n    int Z[l];\\n    getZarr(concat, Z);\\n\\n    for (int i = 0; i < l; ++i) {\\n        if (Z[i] == pattern.length())\\n            cout << \\"Pattern found at index \\"\\n                << i - pattern.length() - 1 << endl;\\n    }\\n}\\n\\nvoid getZarr(string str, int Z[]) {\\n    int n = str.length();\\n    int L, R, k;\\n    L = R = 0;\\n    for (int i = 1; i < n; ++i) {\\n\\n        if (i > R) {\\n            L = R = i;\\n            while (R < n && str[R - L] == str[R])\\n                R++;\\n            Z[i] = R - L;\\n            R--;\\n        } else {\\n            k = i - L;\\n            if (Z[k] < R - i + 1)\\n                Z[i] = Z[k];\\n            else {\\n                L = i;\\n                while (R < n && str[R - L] == str[R])\\n                    R++;\\n                Z[i] = R - L;\\n                R--;\\n            }\\n        }\\n    }\\n}\\n\\nint main() {\\n    string text = \\"GEEKS FOR GEEKS\\";\\n    string pattern = \\"GEEK\\";\\n    search(text, pattern);\\n    return 0;\\n}\\n","py":"def getZarr(string, z): \\n    n = len(string) \\n    l, r, k = 0, 0, 0\\n    for i in range(1, n): \\n        if i > r: \\n            l, r = i, i \\n            while r < n and string[r - l] == string[r]: \\n                r += 1\\n            z[i] = r - l \\n            r -= 1\\n        else: \\n\\n            k = i - l \\n            if z[k] < r - i + 1: \\n                z[i] = z[k] \\n            else: \\n                l = i \\n                while r < n and string[r - l] == string[r]: \\n                    r += 1\\n                z[i] = r - l \\n                r -= 1\\n\\ndef search(text, pattern): \\n    concat = pattern + \\"$\\" + text \\n    l = len(concat) \\n    z = [0] * l \\n    getZarr(concat, z) \\n    for i in range(l): \\n        if z[i] == len(pattern): \\n            print(\\"Pattern found at index\\", \\n                  i - len(pattern) - 1) \\n\\ntext = \\"GEEKS FOR GEEKS\\"\\npattern = \\"GEEK\\"\\nsearch(text, pattern) \\n","orden":5,"suborden":6,"fecha_creacion":"2020-12-06 19:51:39","fecha_modificacion":"2022-03-08 12:17:06"},{"ID":210,"supergrupo":"Strings","tema":"Supersecuencia com\xfan m\xe1s corta","texto":"Dadas dos cadenas str1 y str2, la tarea es encontrar la longitud de la cadena m\xe1s corta que tiene str1 y str2 como subsecuencias.\\nEjemplos:\\nEntrada: str1 = \\"geek\\", str2 = \\"eke\\"\\nSalida: 5\\nExplicaci\xf3n:\\nLa cadena \\"geeke\\" tiene ambas cadenas \\"geek\\"\\ny \\"eke\\" como subsecuencias.\\n\\nEntrada: str1 = \\"AGGTAB\\", str2 = \\"GXTXAYB\\"\\nSalida: 9\\nExplicaci\xf3n:\\nLa cadena \\"AGXGTXAYB\\" tiene ambas cadenas\\n\\"AGGTAB\\" y \\"GXTXAYB\\" como subsecuencias.\\nEste problema est\xe1 estrechamente relacionado con el problema de subsecuencia com\xfan m\xe1s largo. A continuaci\xf3n se muestran los pasos.\\n1) Encuentre la subsecuencia com\xfan m\xe1s larga (lcs) de dos cadenas dadas. Por ejemplo, lcs de \\"geek\\" y \\"eke\\" es \\"ek\\".\\n2) Inserte caracteres que no sean lcs (en su orden original en cadenas) en los lcs que se encuentran arriba y devuelva el resultado. Entonces \\"ek\\" se convierte en \\"geeke\\", que es la supersecuencia com\xfan m\xe1s corta.\\nConsideremos otro ejemplo, str1 = \\"AGGTAB\\" y str2 = \\"GXTXAYB\\". LCS de str1 y str2 es \\"GTAB\\". Una vez que encontramos LCS, insertamos caracteres de ambas cadenas en orden y obtenemos \\"AGXGTXAYB\\"\\n\\n\xbfComo funciona esto?\\nNecesitamos encontrar una cadena que tenga ambas cadenas como subsecuencias y que sea la m\xe1s corta. Si ambas cadenas tienen todos los caracteres diferentes, el resultado es la suma de longitudes de dos cadenas dadas. Si hay caracteres comunes, no los queremos varias veces, ya que la tarea es minimizar la longitud. Por lo tanto, primero encontramos la subsecuencia com\xfan m\xe1s larga, tomamos una aparici\xf3n de esta subsecuencia y agregamos caracteres adicionales.\\nDuraci\xf3n de la supersecuencia m\xe1s corta\\n= (Suma de longitudes de dos cadenas dadas)\\n- (Longitud de LCS de dos cadenas dadas)\\n\\nComplejidad temporal de la soluci\xf3n anterior exponencial O (2min (m, n)). Dado que hay subproblemas superpuestos, podemos resolver este problema recursivo de manera eficiente utilizando la programaci\xf3n din\xe1mica. A continuaci\xf3n se muestra la implementaci\xf3n basada en programaci\xf3n din\xe1mica. La complejidad temporal de esta soluci\xf3n es O (mn).\\n","complejidad_tiempo":null,"java":"// Un programa Java basado en programaci\xf3n din\xe1mica para encontrar \\n// la longitud de la supersecuencia m\xe1s corta\\n\\npublic class ShortestCommonSupersequence {\\n\\n    // Devuelve la longitud de la supersecuencia m\xe1s corta de X e Y\\n    static int superSeq(String X, String Y,\\n            int m, int n) {\\n        int[][] dp = new int[m + 1][n + 1];\\n\\n        // Llene la tabla de abajo hacia arriba\\n        for (int i = 0; i <= m; i++) {\\n            for (int j = 0; j <= n; j++) {\\n                // Los pasos siguientes siguen la recurrencia anterior\\n                if (i == 0) {\\n                    dp[i][j] = j;\\n                } else if (j == 0) {\\n                    dp[i][j] = i;\\n                } else if (X.charAt(i - 1) == Y.charAt(j - 1)) {\\n                    dp[i][j] = 1 + dp[i - 1][j - 1];\\n                } else {\\n                    dp[i][j] = 1 + Math.min(dp[i - 1][j],\\n                            dp[i][j - 1]);\\n                }\\n            }\\n        }\\n\\n        return dp[m][n];\\n    }\\n\\n    public static void main(String args[]) {\\n        String X = \\"AGGTAB\\";\\n        String Y = \\"GXTXAYB\\";\\n        System.out.println(\\"Length of the shortest supersequence is \\"\\n                + superSeq(X, Y, X.length(), Y.length()));\\n    }\\n}\\n","cpp":"#include<bits/stdc++.h> \\nusing namespace std;\\n\\nint superSeq(char* X, char* Y, int m, int n) {\\n    int dp[m + 1][n + 1];\\n    for (int i = 0; i <= m; i++) {\\n        for (int j = 0; j <= n; j++) {\\n            if (!i)\\n                dp[i][j] = j;\\n            else if (!j)\\n                dp[i][j] = i;\\n            else if (X[i - 1] == Y[j - 1])\\n                dp[i][j] = 1 + dp[i - 1][j - 1];\\n            else\\n                dp[i][j] = 1 + min(dp[i - 1][j],\\n                    dp[i][j - 1]);\\n        }\\n    }\\n\\n    return dp[m][n];\\n}\\n\\nint main() {\\n    char X[] = \\"AGGTAB\\";\\n    char Y[] = \\"GXTXAYB\\";\\n    cout << \\"Length of the shortest supersequence is \\"\\n            << superSeq(X, Y, strlen(X), strlen(Y));\\n    return 0;\\n}\\n","py":"def superSeq(X, Y, m, n): \\n    dp = [[0] * (n + 2) for i in range(m + 2)] \\n    for i in range(m + 1): \\n        for j in range(n + 1): \\n            if (not i): dp[i][j] = j \\n            elif (not j): dp[i][j] = i \\n                        \\n            elif (X[i - 1] == Y[j - 1]): \\n                dp[i][j] = 1 + dp[i - 1][j - 1] \\n                                \\n            else: dp[i][j] = 1 + min(dp[i - 1][j], \\n                                     dp[i][j - 1])              \\n    return dp[m][n] \\n\\nX = \\"AGGTAB\\"\\nY = \\"GXTXAYB\\"\\nprint(\\"Length of the shortest supersequence is %d\\"\\n      % superSeq(X, Y, len(X), len(Y))) \\n","orden":5,"suborden":7,"fecha_creacion":"2020-12-06 19:51:39","fecha_modificacion":"2022-03-08 12:17:06"},{"ID":211,"supergrupo":"Strings","tema":"Trie","texto":"Trie es una estructura de datos de recuperaci\xf3n de informaci\xf3n eficiente. Con Trie, las complejidades de la b\xfasqueda se pueden llevar al l\xedmite \xf3ptimo (longitud de la clave). Si almacenamos claves en un \xe1rbol de b\xfasqueda binario, un BST bien balanceado necesitar\xe1 un tiempo proporcional a M * log N, donde M es la longitud m\xe1xima de la cadena y N es el n\xfamero de claves en el \xe1rbol. Usando Trie, podemos buscar la clave en tiempo O (M). Sin embargo, la penalizaci\xf3n est\xe1 en los requisitos de almacenamiento de Trie.\\n \\nCada nodo de Trie consta de m\xfaltiples ramas. Cada rama representa un posible car\xe1cter de claves. Necesitamos marcar el \xfaltimo nodo de cada clave como nodo de fin de palabra. Un campo de nodo Trie isEndOfWord se utiliza para distinguir el nodo como nodo de fin de palabra. Una estructura simple para representar nodos del alfabeto ingl\xe9s puede ser la siguiente:\\n\\n// Trie nodo\\nestructura TrieNode\\n{\\n     struct TrieNode * children [ALPHABET_SIZE];\\n     // isEndOfWord es verdadero si el nodo\\n     // representa el final de una palabra\\n     bool isEndOfWord;\\n};\\nInsertar una llave en Trie es un enfoque simple. Cada car\xe1cter de la clave de entrada se inserta como un nodo Trie individual. Tenga en cuenta que los ni\xf1os son una matriz de punteros (o referencias) a los nodos de prueba del siguiente nivel. El car\xe1cter clave act\xfaa como un \xedndice en los hijos de la matriz. Si la clave de entrada es nueva o una extensi\xf3n de la clave existente, necesitamos construir nodos no existentes de la clave y marcar el final de la palabra para el \xfaltimo nodo. Si la clave de entrada es un prefijo de la clave existente en Trie, simplemente marcamos el \xfaltimo nodo de la clave como el final de una palabra. La longitud de la clave determina la profundidad de Trie.\\n\\nLa b\xfasqueda de una clave es similar a la operaci\xf3n de inserci\xf3n, sin embargo, solo comparamos los caracteres y nos movemos hacia abajo. La b\xfasqueda puede terminar debido al final de una cadena o la falta de clave en el trie. En el primer caso, si el campo isEndofWord del \xfaltimo nodo es verdadero, entonces la clave existe en el trie. En el segundo caso, la b\xfasqueda termina sin examinar todos los caracteres de la clave, ya que la clave no est\xe1 presente en el trie.\\nLa siguiente imagen explica la construcci\xf3n de trie utilizando las claves que se dan en el ejemplo siguiente,\\n                       ra\xedz\\n                    / \\\\ \\\\\\n                    t a b\\n                    | | |\\n                    h n y\\n                    | | \\\\ |\\n                    e s y e\\n                 / | |\\n                 yo r w\\n                 | | |\\n                 r e e\\n                        |\\n                        r\\nEn la imagen, cada car\xe1cter es de tipo trie_node_t. Por ejemplo, la ra\xedz es de tipo trie_node_t, y sus hijos a, byt est\xe1n llenos, todos los dem\xe1s nodos de la ra\xedz ser\xe1n NULL. De manera similar, \\"a\\" en el siguiente nivel es tener un solo hijo (\\"n\\"), todos los dem\xe1s hijos son NULL. Los nodos de las hojas est\xe1n en azul.\\nInsertar y buscar cuesta O (key_length), sin embargo, los requisitos de memoria de Trie es O (ALPHABET_SIZE * key_length * N) donde N es el n\xfamero de claves en Trie. Hay una representaci\xf3n eficiente de los nodos trie (por ejemplo, trie comprimido, \xe1rbol de b\xfasqueda ternario, etc.) para minimizar los requisitos de memoria de trie.\\n\\nTries es un \xe1rbol que almacena cuerdas. El n\xfamero m\xe1ximo de hijos de un nodo es igual al tama\xf1o del alfabeto. Trie admite operaciones de b\xfasqueda, inserci\xf3n y eliminaci\xf3n en tiempo O (L) donde L es la longitud de la clave.\\nHashing: - En hash, convertimos la clave a un valor peque\xf1o y el valor se usa para indexar datos. El hash admite operaciones de b\xfasqueda, inserci\xf3n y eliminaci\xf3n en tiempo O (L) en promedio.\\nBST autoequilibrado: la complejidad temporal de las operaciones de b\xfasqueda, inserci\xf3n y eliminaci\xf3n en un \xe1rbol de b\xfasqueda binaria (BST) autoequilibrado (como \xe1rbol rojo-negro, \xe1rbol AVL, \xe1rbol de expansi\xf3n, etc.) es O (L + Log n) donde n es el n\xfamero total de palabras y L es la longitud de la palabra. La ventaja de los BST autoequilibrantes es que mantienen el orden, lo que hace que las operaciones como m\xednimo, m\xe1ximo, m\xe1s cercano (piso o techo) y k-\xe9simo sean m\xe1s r\xe1pidas.\\n\\n\xbfPor qu\xe9 Trie? : -\\n1. Con Trie, podemos insertar y encontrar cadenas en tiempo O (L) donde L representa la longitud de una sola palabra. Obviamente, esto es m\xe1s r\xe1pido que BST. Esto tambi\xe9n es m\xe1s r\xe1pido que Hashing debido a la forma en que se implementa. No necesitamos calcular ninguna funci\xf3n hash. No se requiere manejo de colisiones (como lo hacemos en direccionamiento abierto y encadenamiento separado)\\n2. Otra ventaja de Trie es que podemos imprimir f\xe1cilmente todas las palabras en orden alfab\xe9tico, lo que no es posible con hash.\\n3. Podemos realizar b\xfasquedas de prefijos (o autocompletar) de manera eficiente con Trie.\\n\\nProblemas con Trie: \\nLa principal desventaja de los intentos es que necesitan mucha memoria para almacenar las cadenas. Para cada nodo tenemos demasiados punteros de nodo (igual al n\xfamero de caracteres del alfabeto), si se trata de espacio, entonces el \xc1rbol de b\xfasqueda ternario puede ser preferido para implementaciones de diccionario. En Ternary Search Tree, la complejidad temporal de la operaci\xf3n de b\xfasqueda es O (h) donde h es la altura del \xe1rbol. Ternary Search Trees tambi\xe9n admite otras operaciones compatibles con Trie, como la b\xfasqueda de prefijos, la impresi\xf3n en orden alfab\xe9tico y la b\xfasqueda de vecinos m\xe1s cercanos.\\nLa conclusi\xf3n final con respecto a la estructura de datos de los intentos es que son m\xe1s r\xe1pidos pero requieren una gran memoria para almacenar las cadenas.\\n","complejidad_tiempo":null,"java":"// Implementaci\xf3n Java de operaciones de b\xfasqueda e inserci\xf3n en Trie \\n\\npublic class Trie {\\n\\n    // Tama\xf1o del alfabeto (n\xfamero de s\xedmbolos)\\n    static final int ALPHABET_SIZE = 26;\\n\\n    // nodo trie\\n    static class TrieNode {\\n\\n        TrieNode[] children = new TrieNode[ALPHABET_SIZE];\\n\\n        // isEndOfWord es verdadero si el nodo representa el final de una palabra\\n        boolean isEndOfWord;\\n\\n        TrieNode() {\\n            isEndOfWord = false;\\n            for (int i = 0; i < ALPHABET_SIZE; i++) {\\n                children[i] = null;\\n            }\\n        }\\n    };\\n\\n    static TrieNode root;\\n\\n    // Si no est\xe1 presente, inserta la clave en trie \\n    // Si la clave es el prefijo del nodo trie, solo marca el nodo hoja\\n    static void insert(String key) {\\n        int level;\\n        int length = key.length();\\n        int index;\\n\\n        TrieNode pCrawl = root;\\n\\n        for (level = 0; level < length; level++) {\\n            index = key.charAt(level) - \'a\';\\n            if (pCrawl.children[index] == null) {\\n                pCrawl.children[index] = new TrieNode();\\n            }\\n\\n            pCrawl = pCrawl.children[index];\\n        }\\n\\n        // marcar el \xfaltimo nodo como hoja\\n        pCrawl.isEndOfWord = true;\\n    }\\n\\n    // // Devuelve verdadero si la clave est\xe1 presente en verdadero, de lo contrario es falso\\n    static boolean search(String key) {\\n        int level;\\n        int length = key.length();\\n        int index;\\n        TrieNode pCrawl = root;\\n\\n        for (level = 0; level < length; level++) {\\n            index = key.charAt(level) - \'a\';\\n\\n            if (pCrawl.children[index] == null) {\\n                return false;\\n            }\\n\\n            pCrawl = pCrawl.children[index];\\n        }\\n\\n        return (pCrawl != null && pCrawl.isEndOfWord);\\n    }\\n\\n    public static void main(String args[]) {\\n        // Datos de entrada (use solo \'a\' a \'z\' y min\xfasculas)\\n        String keys[] = {\\"the\\", \\"a\\", \\"there\\", \\"answer\\", \\"any\\",\\n            \\"by\\", \\"bye\\", \\"their\\"};\\n\\n        String output[] = {\\"Not present in trie\\", \\"Present in trie\\"};\\n\\n        root = new TrieNode();\\n\\n        // Construir trie\\n        int i;\\n        for (i = 0; i < keys.length; i++) {\\n            insert(keys[i]);\\n        }\\n\\n        // Buscar diferentes claves \\n        if (search(\\"the\\") == true) {\\n            System.out.println(\\"the --- \\" + output[1]);\\n        } else {\\n            System.out.println(\\"the --- \\" + output[0]);\\n        }\\n\\n        if (search(\\"these\\") == true) {\\n            System.out.println(\\"these --- \\" + output[1]);\\n        } else {\\n            System.out.println(\\"these --- \\" + output[0]);\\n        }\\n\\n        if (search(\\"their\\") == true) {\\n            System.out.println(\\"their --- \\" + output[1]);\\n        } else {\\n            System.out.println(\\"their --- \\" + output[0]);\\n        }\\n\\n        if (search(\\"thaw\\") == true) {\\n            System.out.println(\\"thaw --- \\" + output[1]);\\n        } else {\\n            System.out.println(\\"thaw --- \\" + output[0]);\\n        }\\n\\n    }\\n}\\n","cpp":"#include <iostream> \\n#include <memory> \\n\\nusing namespace std;\\n#define ALPHABET_SIZE 26 \\n\\nclass TrieNode { \\npublic:\\n    shared_ptr<TrieNode> children[ALPHABET_SIZE];\\n\\n    bool isWord;\\n\\n    TrieNode() {\\n        for (int i = 0; i < ALPHABET_SIZE; i++) {\\n            children[i] = shared_ptr<TrieNode>();\\n        }\\n        isWord = false;\\n    }\\n};\\n\\n\\n\\n\\nclass Trie  {     \\n    shared_ptr<TrieNode> root;\\n    int Total_words;\\n\\npublic:\\n    Trie() {\\n        root = shared_ptr<TrieNode>\\n                (new TrieNode());\\n        Total_words = 0;\\n    }\\n\\n    ~Trie() {\\n    }\\n\\n    int i2c(char c) {\\n        return static_cast<int> (c - \'a\');\\n    }\\n\\n    void insertWord(string& trieString) {\\n        shared_ptr<TrieNode> current = root;\\n        for (int i = 0; i < trieString.size(); i++) {\\n\\n            if (current->children[i2c(trieString[i])] ==\\n                    shared_ptr<TrieNode>(nullptr)) {\\n                current->children[i2c(trieString[i])] =\\n                        shared_ptr<TrieNode>(new TrieNode());\\n            }\\n            current = (current->children[i2c(trieString[i])]);\\n        } \\n        current->isWord = true;\\n    }\\n\\n\\n    bool searchWord(string& trieString) {\\n        shared_ptr<TrieNode> current = root;\\n\\n        for (int i = 0; i < trieString.size(); i++) {\\n\\n            if (current->children[i2c(trieString[i])] ==\\n                    shared_ptr<TrieNode>(nullptr))\\n                return false;\\n            current = current->children[i2c(trieString[i])];\\n        }\\n\\n        if (current->isWord == true)\\n            return true;\\n\\n        return false;\\n    }\\n\\n    bool Partdelete(string& trieString, shared_ptr<TrieNode>&\\n            checkout) {\\n\\n        if (checkout == nullptr)\\n            return false;\\n\\n        if (trieString.size() == 0) {\\n            if (checkout->isWord == true) {\\n                checkout->isWord = false;\\n                return true;\\n            }\\n            return false;\\n        }\\n\\n        string part = trieString.substr(1);\\n\\n        if (Partdelete(part, checkout->\\n                children[i2c(trieString[0])])) {\\n\\n            if (isEmptyNode(checkout->\\n                    children[i2c(trieString[0])])) {\\n                checkout->children[i2c(trieString[0])].\\n                        reset();\\n\\n                checkout->children[i2c(trieString[0])] =\\n                        nullptr;\\n\\n                return true;\\n            }\\n            else\\n                return true;\\n        }\\n        else\\n            return false;\\n\\n        return false;\\n    }\\n\\n\\n    bool deleteWord(string& trieString) {\\n        if (Partdelete(trieString, root))\\n            return true;\\n        return false;\\n    }\\n\\n    bool isEmptyNode(shared_ptr<TrieNode> check) const {\\n        for (int i = 0; i < ALPHABET_SIZE; i++) {\\n            if (check->children[i] != nullptr ||\\n                    check->isWord == true)\\n                return false;\\n        }\\n        return true;\\n    }\\n};\\n\\n\\nint main() {\\n    shared_ptr<Trie> myTrie(new Trie());\\n\\n    string word1 = \\"geeksfor\\";\\n    string word2 = \\"geeksforgeeks\\";\\n    string word3 = \\"nothing\\";\\n\\n    myTrie->insertWord(word1);\\n\\n    if (myTrie->searchWord(word1))\\n        cout << word1 << \\": Is Present\\" << endl;\\n    else\\n        cout << word1 << \\": Not Present\\" << endl;\\n\\n    if (myTrie->searchWord(word3))\\n        cout << word3 << \\": Is Present\\" << endl;\\n    else\\n        cout << word3 << \\": Not Present\\" << endl;\\n\\n    myTrie->insertWord(word2);\\n\\n    if (myTrie->deleteWord(word2))\\n        cout << word2 << \\": Successfully deleted\\" << endl;\\n    else\\n        cout << word2 << \\": Not Present\\" << endl;\\n\\n    if (myTrie->searchWord(word2))\\n        cout << word2 << \\": Is Present\\" << endl;\\n    else\\n        cout << word2 << \\": Not Present\\" << endl;\\n\\n}\\n","py":"class TrieNode: \\n    def __init__(self): \\n        self.children = [None] * 26\\n\\n        self.isEndOfWord = False\\n\\nclass Trie: \\n    def __init__(self): \\n        self.root = self.getNode() \\n\\n    def getNode(self): \\n        return TrieNode() \\n\\n    def _charToIndex(self, ch): \\n        return ord(ch)-ord(\'a\') \\n\\n\\n    def insert(self, key): \\n                \\n        pCrawl = self.root \\n        length = len(key) \\n        for level in range(length): \\n            index = self._charToIndex(key[level]) \\n\\n            if not pCrawl.children[index]: \\n                pCrawl.children[index] = self.getNode() \\n            pCrawl = pCrawl.children[index] \\n\\n        pCrawl.isEndOfWord = True\\n\\n    def search(self, key): \\n                 \\n        pCrawl = self.root \\n        length = len(key) \\n        for level in range(length): \\n            index = self._charToIndex(key[level]) \\n            if not pCrawl.children[index]: \\n                return False\\n            pCrawl = pCrawl.children[index] \\n\\n        return pCrawl != None and pCrawl.isEndOfWord \\n\\ndef main(): \\n\\n    keys = [\\"the\\", \\"a\\", \\"there\\", \\"anaswe\\", \\"any\\", \\n        \\"by\\", \\"their\\"] \\n    output = [\\"Not present in trie\\", \\n        \\"Present in trie\\"] \\n    t = Trie() \\n    for key in keys: \\n        t.insert(key) \\n    print(\\"{} ---- {}\\".format(\\"the\\", output[t.search(\\"the\\")])) \\n    print(\\"{} ---- {}\\".format(\\"these\\", output[t.search(\\"these\\")])) \\n    print(\\"{} ---- {}\\".format(\\"their\\", output[t.search(\\"their\\")])) \\n    print(\\"{} ---- {}\\".format(\\"thaw\\", output[t.search(\\"thaw\\")])) \\n\\nmain() \\n","orden":5,"suborden":8,"fecha_creacion":"2020-12-06 19:51:39","fecha_modificacion":"2022-03-08 12:17:06"},{"ID":212,"supergrupo":"Strings","tema":"Hash polin\xf3mico","texto":"\xbfQu\xe9 es String-Hashing?\\nEl hash de cadena es la forma de convertir una cadena en un n\xfamero entero conocido como hash de esa cadena.\\nUn hash ideal es aquel en el que existen m\xednimas posibilidades de colisi\xf3n (es decir, 2 cadenas diferentes que tienen el mismo hash).\\nFunci\xf3n hash polinomial rodante\\nEn esta t\xe9cnica de hash, el hash de una cadena se calcula como: \\nDonde P y M son algunos n\xfameros positivos. Y s [0], s [1], s [2]\u2026 s [n-1] son los valores asignados a cada car\xe1cter en el alfabeto ingl\xe9s (a-> 1, b-> 2,\u2026 z-> 26).\\nValores apropiados para P y M\\n\\n\u2022 P: el valor de P puede ser cualquier n\xfamero primo aproximadamente igual al n\xfamero de caracteres diferentes utilizados.\\nPor ejemplo: si la cadena de entrada contiene solo letras min\xfasculas del alfabeto ingl\xe9s, entonces P = 31 es el valor apropiado de P.\\nSi la cadena de entrada contiene letras may\xfasculas y min\xfasculas, entonces P = 53 es una opci\xf3n adecuada.\\n\u2022 M: la probabilidad de que dos cadenas aleatorias choquen es inversamente proporcional am. Por lo tanto, m deber\xeda ser un n\xfamero primo grande.\\nM = 10 ^ 9 + 9 es una buena opci\xf3n.\\n","complejidad_tiempo":null,"java":"// Implementaci\xf3n de Java de la funci\xf3n Polynomial Rolling Hash\\n\\npublic class PolynomialRollingHash {\\n\\n    // Funci\xf3n para calcular el hash de un String\\n    static long polynomialRollingHash(String str) {\\n\\n        // P y M\\n        int p = 31;\\n        int m = (int) (1e9 + 9);\\n        long power_of_p = 1;\\n        long hash_val = 0;\\n        // Bucle para calcular el valor hash \\n        // iterando sobre los elementos de String\\n        for (int i = 0; i < str.length(); i++) {\\n            hash_val = (hash_val + (str.charAt(i)\\n                    - \'a\' + 1) * power_of_p) % m;\\n            power_of_p = (power_of_p * p) % m;\\n        }\\n        return hash_val;\\n    }\\n\\n    public static void main(String[] args) {\\n        String str1 = \\"holaholaholo\\";\\n        System.out.print(\\"Hash of \'\\" + str1 + \\"\' = \\"\\n                + polynomialRollingHash(str1));\\n    }\\n}\\n","cpp":"#include <bits/stdc++.h>\\nusing namespace std;\\n\\nlong long polynomialRollingHash(string const& str) {\\n    int p = 31;\\n    int m = 1e9 + 9;\\n    long long power_of_p = 1;\\n    long long hash_val = 0;\\n    for (int i = 0; i < str.length(); i++) {\\n        hash_val\\n                = (hash_val\\n                + (str[i] - \'a\' + 1) * power_of_p)\\n                % m;\\n        power_of_p\\n                = (power_of_p * p) % m;\\n    }\\n    return hash_val;\\n}\\n\\nint main() {\\n    string str1 = \\"geeksforgeeks\\";\\n    string str2 = \\"geeks\\";\\n\\n    cout << \\"Hash of \'\\" << str1 << \\"\' = \\"\\n            << polynomialRollingHash(str1);\\n    cout << endl;\\n}\\n","py":"def polynomialRollingHash(str):\\n        \\n    # P and M\\n    p = 31\\n    m = 1e9 + 9\\n    power_of_p = 1\\n    hash_val = 0\\n    for i in range(len(str)):\\n        hash_val = ((hash_val + (ord(str[i]) -\\n                    ord(\'a\') + 1) *\\n                    power_of_p) % m)\\n\\n        power_of_p = (power_of_p * p) % m\\n\\n    return int(hash_val)\\n\\nstr1 = \\"geeksforgeeks\\"\\n\\nprint(\\"Hash of \'{}\' = {}\\".format(\\n      str1, polynomialRollingHash(str1)))\\n","orden":5,"suborden":9,"fecha_creacion":"2020-12-06 19:51:40","fecha_modificacion":"2022-03-08 12:17:06"},{"ID":213,"supergrupo":"Strings","tema":"El m\xe1s peque\xf1o lexicogr\xe1ficamente","texto":"Escriba c\xf3digo para encontrar el m\xednimo lexicogr\xe1fico en una matriz circular, p. Ej. para la matriz BCABDADAB, el m\xednimo lexicogr\xe1fico es ABBCABDAD\\nRestricci\xf3n de entrada: 1 <n <1000\\nEjemplos:\\nEntrada: GEEKSQUIZ\\nSalida: EEKSQUIZG\\n\\nEntrada: GFG\\nSalida: FGG\\n\\nEntrada: CAPABCQ\\nSalida: ABCQCAP\\nAqu\xed necesitamos encontrar el \xedndice inicial de rotaci\xf3n m\xednima y luego imprimir la rotaci\xf3n.\\n\\n1) Asuma inicialmente que 0 es el m\xednimo actual\\n    \xedndice inicial.\\n2) Haz un bucle a trav\xe9s de i = 1 hasta n-1.\\n    a) Para cada comienzo de secuencia de comparaci\xf3n\\n       en i con el \xedndice inicial m\xednimo actual\\n    b) Si la secuencia que comienza en i es lexicogr\xe1ficamente\\n       m\xe1s peque\xf1o, actualizar el m\xednimo actual comenzando\\n       \xedndice.\\nComplejidad del tiempo: O (n ^ 2)\\nEspacio auxiliar: O (1)\\n","complejidad_tiempo":null,"java":"// Programa Java para encontrar la secuencia lexicogr\xe1ficamente m\xe1s peque\xf1a con rotaciones.\\n\\npublic class LexoSmallest {\\n    // Funci\xf3n para comparar lexicogr\xe1ficamente dos secuencias con diferentes \\n    // \xedndices de inicio. Devuelve verdadero si la secuencia que comienza \\n    // con y es lexicogr\xe1ficamente mayor.\\n\\n    static boolean compareSeq(char[] S, int x, int y, int n) {\\n        for (int i = 0; i < n; i++) {\\n            if (S[x] < S[y]) {\\n                return false;\\n            } else if (S[x] > S[y]) {\\n                return true;\\n            }\\n            x = (x + 1) % n;\\n            y = (y + 1) % n;\\n        }\\n        return true;\\n    }\\n\\n    // Funci\xf3n para encontrar el \xedndice inicial de la secuencia \\n    // lexicogr\xe1ficamente m\xe1s peque\xf1a\\n    static int smallestSequence(char[] S, int n) {\\n        int index = 0;\\n        for (int i = 1; i < n; i++) // si la nueva secuencia es m\xe1s peque\xf1a\\n        {\\n            if (compareSeq(S, index, i, n)) // cambiar el \xedndice del m\xednimo actual\\n            {\\n                index = i;\\n            }\\n        }\\n\\n        return index;\\n    }\\n\\n    // Funci\xf3n para imprimir la secuencia lexicogr\xe1ficamente m\xe1s peque\xf1a \\n    static void printSmallestSequence(String str, int n) {\\n        char[] S = str.toCharArray();\\n        int starting_index = smallestSequence(S, n);\\n        for (int i = 0; i < n; i++) {\\n            System.out.print(S[(starting_index + i) % n]);\\n        }\\n    }\\n\\n    public static void main(String[] args) {\\n        String S = \\"DCACBCAA\\";\\n        int n = 8;\\n        printSmallestSequence(S, n);\\n    }\\n}\\n","cpp":"#include <cstdlib>\\n#include <bits/stdc++.h> \\nusing namespace std;\\n\\nbool compareSeq(char S[], int x, int y, int n) {\\n    for (int i = 0; i < n; i++) {\\n        if (S[x] < S[y]) {\\n            return false;\\n        } else if (S[x] > S[y]) {\\n            return true;\\n        }\\n        x = (x + 1) % n;\\n        y = (y + 1) % n;\\n    }\\n    return true;\\n}\\n\\nint smallestSequence(char S[], int n) {\\n    int index = 0;\\n    for (int i = 1; i < n; i++) {\\n        if (compareSeq(S, index, i, n)) {\\n            index = i;\\n        }\\n    }\\n    return index;\\n}\\n\\nvoid printSmallestSequence(string str, int n) {\\n    char S[str.size() + 1];\\n    strcpy(S, str.c_str());\\n    int starting_index = smallestSequence(S, n);\\n    for (int i = 0; i < n; i++) {\\n        cout << S[(starting_index + i) % n];\\n    }\\n}\\n\\nint main() {\\n    string S = \\"DCACBCAA\\";\\n    int n = 8;\\n    printSmallestSequence(S, n);\\n}\\n","py":"def compareSeq(S, x, y, n):\\n    for i in range (n):\\n        if (S[x] < S[y]):\\n            return False\\n        elif (S[x] > S[y]):\\n            return True\\n        x = (x + 1) % n\\n        y = (y + 1) % n\\n    return True\\n\\n\\ndef smallestSequence(S, n):\\n    index = 0\\n    for i in range (n):\\n        if (compareSeq(S, index, i, n)):\\n            index = i\\n    return index\\n\\n\\ndef printSmallestSequence(str, n):\\n    starting_index = smallestSequence(S, n);\\n    for i in range (n):\\n        print(str[(starting_index + i) % n])\\n    \\nS = \\"DCACBCAA\\"\\nn = 8\\nprintSmallestSequence(S, n);\\n","orden":5,"suborden":10,"fecha_creacion":"2020-12-06 19:51:40","fecha_modificacion":"2022-03-08 12:17:06"},{"ID":214,"supergrupo":"Strings","tema":"Convirtiendo una cadena dadas restricciones","texto":"Dadas dos cadenas contiene tres caracteres, es decir, \\"A\\", \\"B\\" y \\"#\\" \xfanicamente. Compruebe si es posible convertir la primera cadena en otra cadena realizando las siguientes operaciones en la cadena primero.\\n1- \\"A\\" solo puede moverse hacia la izquierda\\n2- \\"B\\" solo puede moverse hacia la derecha\\n3- Ni \'A\' ni \'B\' se cruzan\\nSi es posible, imprima \\"S\xed\\"; de lo contrario, \\"No\\".\\n\\nEjemplos:\\nEntrada: str1 = \u201d# A # B # B #\u201c, str2 = \u201dA ### B # B\u201d\\nSalida: si\\nExplicacion:\\n\'A\' en str1 est\xe1 a la derecha de la \'A\' en str2 por lo que \'A\' de str1 puede moverse f\xe1cilmente hacia la izquierda porque no hay \'B\' en sus posiciones izquierdas y para la primera \'B\' en str1 se deja a la \' B \'en str2 para que\' B \'de str2 pueda moverse f\xe1cilmente hacia la derecha porque no hay\' A \'en sus posiciones correctas y es lo mismo para la siguiente\' B \', por lo que str1 se puede convertir f\xe1cilmente en str2.\\nEntrada: str1 = \\"# A # B #\\", str2 = \\"# B # A #\\"\\nSalida: No\\nExplicacion:\\nAqu\xed, la primera \\"A\\" en str1 se deja a la \\"A\\" en str2 y, seg\xfan la condici\xf3n, \\"A\\" no puede moverse hacia la derecha. entonces str1 no se puede convertir en str2.\\nM\xe9todo:\\n1-La longitud de ambas cuerdas debe ser la misma\\n2-No. de A y B en ambas cadenas deben ser iguales\\n3-El orden de A y B en ambas cadenas debe ser el mismo (por ejemplo: si \\"A\\" viene antes de \\"B\\" en la cadena en segundo lugar, la misma secuencia debe seguirse primero en la cadena)\\n","complejidad_tiempo":null,"java":"public class ConvertStringIntoAnotherGivenConstraints {\\n\\n    //Funci\xf3n para comprobar si es posible \\n    //convertir la primera cadena en otra cadena o no.\\n    static boolean isItPossible(char[] str1, char[] str2,\\n            int m, int n) {\\n        // Para comprobar que la longitud de ambas cadenas es igual o no\\n        if (m != n) {\\n            return false;\\n        }\\n        // Para comprobar La frecuencia de A y B es igual en ambas cadenas o no.\\n        if (count(str1, \'A\')\\n                != count(str2, \'A\')\\n                || count(str1, \'B\')\\n                != count(str2, \'B\')) {\\n            return false;\\n        }\\n        // Empieza a atravesar\\n        for (int i = 0; i < m; i++) {\\n            if (str1[i] != \'#\') {\\n                for (int j = 0; j < n; j++) {\\n                    // Comprobar que no se crucen dos elementos.\\n                    if ((str2[j] != str1[i]) && str2[j] != \'#\') {\\n                        return false;\\n                    }\\n                    if (str2[j] == str1[i]) {\\n                        str2[j] = \'#\';\\n                        // Para comprobar si es posible moverse \\n                        // hacia la izquierda o no.\\n                        if (str1[i] == \'A\' && i < j) {\\n                            return false;\\n                        }\\n                        // Para comprobar si es posible \\n                        // moverse hacia la derecha o no.\\n                        if (str1[i] == \'B\' && i > j) {\\n                            return false;\\n                        }\\n\\n                        break;\\n                    }\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n\\n    private static int count(char[] str1, char c) {\\n        int count = 0;\\n        for (char temp : str1) {\\n            if (c == temp) {\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n\\n    public static void main(String[] args) {\\n        String str1 = \\"A#B#\\";\\n        String str2 = \\"A##B\\";\\n        int m = str1.length();\\n        int n = str2.length();\\n        System.out.print(isItPossible(str1.toCharArray(), str2.toCharArray(), m, n)\\n                ? \\"Yes\\\\n\\" : \\"No\\\\n\\");\\n    }\\n}\\n","cpp":"#include <bits/stdc++.h> \\nusing namespace std;\\n\\nbool isItPossible(string str1, string str2, int m, int n) {\\n    if (m != n)\\n        return false;\\n    if (count(str1.begin(), str1.end(), \'A\') !=\\n            count(str2.begin(), str2.end(), \'A\') ||\\n            count(str1.begin(), str1.end(), \'B\') !=\\n            count(str2.begin(), str2.end(), \'B\'))\\n        return false;\\n    for (int i = 0; i < m; i++) {\\n        if (str1[i] != \'#\') {\\n            for (int j = 0; j < n; j++) {\\n                if ((str2[j] != str1[i]) && str2[j] != \'#\')\\n                    return false;\\n                if (str2[j] == str1[i]) {\\n                    str2[j] = \'#\';\\n                    if (str1[i] == \'A\' && i < j)\\n                        return false;\\n                    if (str1[i] == \'B\' && i > j)\\n                        return false;\\n                    break;\\n                }\\n            }\\n        }\\n    }\\n    return true;\\n}\\n\\nint main() {\\n    string str1 = \\"A#B#\\";\\n    string str2 = \\"A##B\\";\\n    int m = str1.length();\\n    int n = str2.length();\\n    isItPossible(str1, str2, m, n) ? cout << \\"Yes\\\\n\\" : cout << \\"No\\\\n\\";\\n    return 0;\\n}\\n","py":"def isItPossible(str1, str2, m, n): \\n    if (m != n): \\n        return False\\n    if str1.count(\'A\') != str2.count(\'A\') \\\\ or str1.count(\'B\') != str2.count(\'B\'): \\n        return False\\n    for i in range(m): \\n        if (str1[i] != \'#\'): \\n            for j in range(n): \\n                if ((str2[j] != str1[i]) and str2[j] != \'#\'): \\n                    return False\\n                if (str2[j] == str1[i]): \\n                    str2[j] = \'#\'\\n                    if (str1[i] == \'A\' and i < j): \\n                        return False\\n                    if (str1[i] == \'B\' and i > j): \\n                        return False\\n                    break\\n                                \\n    return True\\nstr1 = \\"A#B#\\"\\nstr2 = \\"A##B\\"\\nm = len(str1) \\nn = len(str2) \\nstr1 = list(str1) \\nstr2 = list(str2) \\nif(isItPossible(str1, str2, m, n)): \\n    print(\\"Yes\\") \\nelse: \\n    print(\\"No\\") \\n","orden":5,"suborden":11,"fecha_creacion":"2020-12-06 19:51:40","fecha_modificacion":"2022-03-08 12:17:06"},{"ID":215,"supergrupo":"BitWise","tema":"Encontrar dos n\xfameros de sumandos XOR","texto":"Dada la suma y xor de dos n\xfameros X e Y s.t. suma y xor, necesitamos encontrar los n\xfameros minimizando el valor de X.\\nEjemplos:\\nEntrada: S = 17\\n        X = 13\\nSalida: a = 2\\n         b = 15\\n\\nEntrada: S = 1870807699\\n        X = 259801747\\nSalida: a = 805502976\\n         b = 1065304723\\n\\nEntrada: S = 1639\\n        X = 1176\\nResultado: No existen tales n\xfameros\\nVariables utilizadas:\\nX ==> XOR de dos n\xfameros\\nS ==> Suma de dos n\xfameros\\nX [i] ==> Valor del i-\xe9simo bit en X\\nS [i] ==> Valor del i-\xe9simo bit en S\\nUna soluci\xf3n simple es generar todos los pares posibles con un XOR dado. Para generar todos los pares, podemos seguir las siguientes reglas.\\n1. Si X [i] es 1, entonces tanto a [i] como b [i] deber\xedan ser diferentes, tenemos dos casos.\\n2. Si X [i] es 0, entonces tanto a [i] como b [i] deber\xedan ser iguales. tenemos dos casos.\\nEntonces generamos 2 ^ n pares posibles donde n es el n\xfamero de bits en X. Luego, para cada par, verificamos si su suma es S o no.\\nUna soluci\xf3n eficiente se basa en el siguiente hecho.\\nS = X + 2 * A\\ndonde A = a Y b\\nPodemos verificar el hecho anterior usando el proceso de suma. En resumen, siempre que vemos ambos bits 1 (es decir, Y es 1), hacemos el bit resultante 0 y agregamos 1 como acarreo, lo que significa que cada bit en Y se desplaza a la izquierda por 1 O el valor de Y se multiplica por 2 y se suma.\\nEntonces podemos encontrar A = (S - X) / 2.\\nUna vez que encontramos A, podemos encontrar todos los bits de \\"a\\" y \\"b\\" usando las siguientes reglas.\\n1. Si X [i] = 0 y A [i] = 0, entonces a [i] = b [i] = 0. S\xf3lo una posibilidad para este bit.\\n2. Si X [i] = 0 y A [i] = 1, entonces a [i] = b [i] = 1. S\xf3lo una posibilidad para este bit.\\n3. Si X [i] = 1 y A [i] = 0, entonces (a [i] = 1 yb [i] = 0) o (a [i] = 0 y b [i] = 1), podemos elegir cualquiera de los dos.\\n4. Si X [i] = 1 y A [i] = 1, el resultado no es posible (Nota X [i] = 1 significa bits diferentes)\\nSea la sumatoria S y XOR sea X.\\n","complejidad_tiempo":null,"java":"// Java program to find two numbers with  \\n// given Sum and XOR such that value of  \\n// first number is minimum.  \\n\\npublic class FindTwoNumbersFromSumandXOR {\\n\\n// Function that takes in the sum and XOR  \\n// of two numbers and generates the two  \\n// numbers such that the value of X is  \\n// minimized  \\n    static void compute(long S, long X) {\\n        long A = (S - X) / 2;\\n        int a = 0, b = 0;\\n        final int LONG_FIELD_SIZE = 8;\\n\\n        // Traverse through all bits  \\n        for (int i = 0; i < 8 * LONG_FIELD_SIZE; i++) {\\n            long Xi = (X & (1 << i));\\n            long Ai = (A & (1 << i));\\n            if (Xi == 0 && Ai == 0) {\\n                // Let us leave bits as 0.  \\n            } else if (Xi == 0 && Ai > 0) {\\n                a = ((1 << i) | a);\\n                b = ((1 << i) | b);\\n            } else if (Xi > 0 && Ai == 0) {\\n                a = ((1 << i) | a);\\n\\n                // We leave i-th bit of b as 0.  \\n            } else // (Xi == 1 && Ai == 1)  \\n            {\\n                System.out.println(\\"Not Possible\\");\\n                return;\\n            }\\n        }\\n        System.out.println(\\"a = \\" + a + \\"\\\\nb = \\" + b);\\n    }\\n\\n// Driver function  \\n    public static void main(String[] args) {\\n        long S = 17, X = 13;\\n        compute(S, X);\\n\\n    }\\n}\\n","cpp":"#include <bits/stdc++.h> \\n#include <cstdlib>\\nusing namespace std;\\n\\nvoid compute(long S, long X) {\\n    long A = (S - X) / 2;\\n    int a = 0, b = 0;\\n    const int LONG_FIELD_SIZE = 8;\\n    for (int i = 0; i < 8 * LONG_FIELD_SIZE; i++) {\\n        long Xi = (X & (1 << i));\\n        long Ai = (A & (1 << i));\\n        if (Xi == 0 && Ai == 0) {\\n        } else if (Xi == 0 && Ai > 0) {\\n            a = ((1 << i) | a);\\n            b = ((1 << i) | b);\\n        } else if (Xi > 0 && Ai == 0) {\\n            a = ((1 << i) | a);\\n        } else {\\n            cout << \\"Not Possible\\" << endl;\\n            return;\\n        }\\n    }\\n    cout << \\"a = \\" << a << \\"\\\\nb = \\" << b << endl;\\n}\\n\\nint main() {\\n    long S = 17, X = 13;\\n    compute(S, X);\\n}\\n","py":"def compute(S, X):\\n    A = (S - X) / 2\\n    a = 0\\n    b = 0\\n    LONG_FIELD_SIZE = 8\\n    leng = 8 * LONG_FIELD_SIZE\\n    for i in range (leng):\\n        Xi = (X & (1 << i))\\n        Ai = (A & (1 << i))\\n        if (Xi == 0 and Ai == 0):\\n            c = 0\\n        elif (Xi == 0 and Ai > 0):\\n            a = ((1 << i) | a)\\n            b = ((1 << i) | b)\\n        elif (Xi > 0 and Ai == 0):\\n            a = ((1 << i) | a);\\n        else:\\n            cout << \\"Not Possible\\" << endl;\\n            return;\\n    print(\\"a = \\" + str(a) + \\"\\\\nb = \\" + str(b))\\nS = 17\\nX = 13\\ncompute(S, X);\\n","orden":4,"suborden":20,"fecha_creacion":"2020-12-06 19:51:41","fecha_modificacion":"2022-03-08 12:18:28"},{"ID":216,"supergrupo":"BitWise","tema":"Cantidad de formas para realizar XOR en dos n\xfameros","texto":"Dadas dos cadenas binarias s1 y s2. El XOR de ellos es X, la tarea es encontrar el n\xfamero de formas de intercambiar posiciones de dos bits en la cadena s1 de manera que el XOR formado entre los nuevos s1 y s2 no sea lo mismo que X.\\nEjemplos:\\nEntrada: s1 = \\"01011\\", s2 = \\"11001\\"\\nSalida: 4\\nintercambiar bits de \xedndice (basado en 1) (1, 4), (2, 3), (3, 4) o (3, 5) de modo que se cambie el valor XOR.\\nEntrada: s1 = \\"011000\\", s2 = \\"010011\\"\\nSalida: 6\\n\\nAproximaci\xf3n:\\n1. Cuente el n\xfamero de unos y ceros en s1.\\n2. Recorra la cadena s1 y compruebe dos casos:\\n\u2022 0 y 0 en s1 [i] y s2 [i], al reemplazar 0 con 1, cambiar\xe1 el valor XOR.\\n\u2022 1 y 0 en s1 [i] y s2 [i], ya que reemplazar 1 con 0 cambiar\xe1 el valor XOR.\\n3. Para el primer caso, el n\xfamero de formas de reemplazo ser\xe1 el n\xfamero de unos, unos ya utilizados.\\n4. Para el segundo caso, el n\xfamero de formas de reemplazo ser\xe1 el n\xfamero de ceros, ceros ya usados.\\n5. La suma de varias formas en ambos casos ser\xe1 la respuesta.\\n","complejidad_tiempo":null,"java":"// Programa Java para encontrar N\xfamero de formas de cambiar el \\n// XOR de dos n\xfameros intercambiando los bits\\n\\npublic class WaysToXORTwoNumbers {\\n\\n    // Funci\xf3n que devuelve el n\xfamero de intercambios de bits de modo que xor es diferente\\n    static int countWays(String s1,\\n            String s2) {\\n        int c1 = 0, c0 = 0;\\n        int n = s1.length();\\n\\n        // atravesar y contar 1 y 0\\n        for (int i = 0; i < n; i++) {\\n            if (s1.charAt(i) == \'1\') {\\n                c1++;\\n            } else {\\n                c0++;\\n            }\\n        }\\n        int used1 = 0, used0 = 0;\\n        int ways = 0;\\n\\n        // atravesar el string\\n        for (int i = 0; i < n; i++) {\\n\\n            // si ambas posiciones son 0\\n            if (s1.charAt(i) == \'0\'\\n                    && s2.charAt(i) == \'0\') {\\n                // agregue el n\xfamero de unos, ya que cambiar\xe1 el XOR\\n                ways += c1;\\n                // restar el n\xfamero de los ya usados\\n                ways -= used1;\\n                // se han utilizado ceros\\n                used0++;\\n            } // cuando 1 y 0, para cambiar XOR, tenemos que reemplazar 1 por 0\\n            else if (s1.charAt(i) == \'1\'\\n                    && s2.charAt(i) == \'0\') {\\n                // agregar el n\xfamero de ceros\\n                ways += c0;\\n                // restar el n\xfamero de ceros ya usados\\n                ways -= used0;\\n                // cuenta 1 se usa\\n                used1++;\\n            }\\n        }\\n        return ways;\\n    }\\n\\n    public static void main(String[] args) {\\n        String s1 = \\"01011\\";\\n        String s2 = \\"11001\\";\\n        System.out.println(countWays(s1, s2));\\n    }\\n}\\n","cpp":"#include <bits/stdc++.h> \\nusing namespace std;\\n\\nint countWays(string s1, string s2) {\\n    int c1 = 0, c0 = 0;\\n    int n = s1.length();\\n    for (int i = 0; i < n; i++) {\\n        if (s1[i] == \'1\')\\n            c1++;\\n        else\\n            c0++;\\n    }\\n    int used1 = 0, used0 = 0;\\n    int ways = 0;\\n\\n    for (int i = 0; i < n; i++) {\\n        if (s1[i] == \'0\' and s2[i] == \'0\') {\\n            ways += c1;\\n            ways -= used1;\\n            used0++;\\n        } else if (s1[i] == \'1\' and s2[i] == \'0\') {\\n            ways += c0;\\n            ways -= used0;\\n            used1++;\\n        }\\n    }\\n    return ways;\\n}\\n\\nint main() {\\n    string s1 = \\"01011\\";\\n    string s2 = \\"11001\\";\\n\\n    cout << countWays(s1, s2);\\n    return 0;\\n}\\n","py":"def countWays(s1, s2): \\n\\n    c1 = 0\\n    c0 = 0\\n    n = len(s1) \\n    for i in range(0, n): \\n        if (s1[i] == \'1\'): \\n            c1 += 1\\n        else: \\n            c0 += 1\\n        \\n    used1 = 0\\n    used0 = 0\\n    ways = 0\\n\\n    for i in range(0, n): \\n        if (s1[i] == \'0\' and s2[i] == \'0\'): \\n            ways += c1 \\n            ways -= used1 \\n            used0 += 1\\n        elif (s1[i] == \'1\' and s2[i] == \'0\'): \\n            ways += c0 \\n            ways -= used0 \\n            used1 += 1\\n\\n    return ways \\ns1 = \\"01011\\"\\ns2 = \\"11001\\"\\nprint(countWays(s1, s2)) \\n","orden":4,"suborden":21,"fecha_creacion":"2020-12-06 19:51:41","fecha_modificacion":"2022-03-08 12:18:28"},{"ID":217,"supergrupo":"BitWise","tema":"Ecuaciones BitWise para multiplicaci\xf3n de un numero por n","texto":"En n\xfameros enteros sin signo, el desplazamiento l\xf3gico hacia la izquierda equivale a una multiplicaci\xf3n por 2 y el desplazamiento l\xf3gico hacia la derecha equivale a una divisi\xf3n por 2. En la divisi\xf3n (desplazamiento hacia la derecha), se pierde el bit menos significativo, dando como resultado un truncamiento del resultado (redondeo hacia abajo, hacia menos infinito). As\xed, 6 / 2 es igual a 3, pero 7 / 2 es igual a 3,5, pero el 0,5 se pierde quedando el resultado en 3.\\nLos programadores de lenguaje ensamblador usan esta propiedad para hacer multiplicaciones y divisiones r\xe1pidas, de enteros sin signo, por una potencia de 2, en donde n desplazamientos equivalen a multiplicar o dividir por 2n. Tambi\xe9n, si el procesador no tiene operaciones de multiplicaci\xf3n y divisi\xf3n de enteros, o si \xe9stas son muy lentas, se puede multiplicar o dividir usando desplazamientos y sumas para multiplicar y desplazamientos y restas para dividir.\\n","complejidad_tiempo":null,"java":"import java.util.ArrayList;\\nimport java.util.TreeMap;\\n\\npublic class BitwiseMultiplication {\\n\\n    static boolean powerof2(int x) {\\n        return x != 0 && ((x & (x - 1)) == 0);\\n    }\\n\\n    static int suma(int n) {\\n        return (~(-(1 << n))) << 1;\\n    }\\n\\n    static int nith(int n) {\\n        return (int) ((Math.log(n + 2) / Math.log(2)) - 1);\\n    }\\n\\n    static String bitsum(ArrayList<Integer> arr, String n, int len) {\\n        ArrayList<Integer> rev = new ArrayList<>();\\n        TreeMap<String, Integer> counter = new TreeMap<>();\\n        String serie = \\"\\";\\n        for (int i : arr) {\\n            for (int j = 1; j <= nith(i); ++j) {\\n                rev.add(j);\\n            }\\n        }\\n        for (int i : rev) {\\n            int aux = 0;\\n            for (int j : rev) {\\n                if (j == i) {\\n                    aux++;\\n                }\\n            }\\n            counter.put(\\"(\\" + n + \\"<<\\" + i + \\")\\", aux);\\n        }\\n        for (String s : counter.keySet()) {\\n            String key = s;\\n            int value = counter.get(s);\\n            if (powerof2(value) && value != 1) {\\n                serie += \\"(\\" + key + \\"<<\\" + ((int) (Math.log(value) / Math.log(2))) + \\") + \\";\\n                continue;\\n            }\\n            for (int j = 0; j < value; j++) {\\n                serie += \\" \\" + key + \\" + \\";\\n            }\\n        }\\n        if (arr.get(len - 1) == 1) { // si el n es impar se le a\xf1ade el ultimo termino n como sumando; si es par no se le a\xf1ade\\n            return serie + \\" \\" + n;\\n        }\\n        return serie;\\n    }\\n\\n    public static void main(String[] args) {\\n        int n = 7; //numero al cual le quiero calcular la ecuaci\xf3n\\n        int N = n; //una copia del numero\\n        ArrayList<Integer> arr = new ArrayList<>();\\n        while (suma(nith(n)) > 0) { //c\xe1lculos los t\xe9rminos de 2^n - 2 tales que su suma me da n (si n es impar siempre falta un 1) y los voy almacenando en un vector\\n            arr.add(suma(nith(n)));\\n            n -= suma(nith(n));\\n        }\\n        int sumarr = 0;\\n        for (int i = 0; i < arr.size(); ++i) {\\n            sumarr += arr.get(i);//sumo los termino del vector\\n        }\\n        if (sumarr < N) {//si la suma no me da mi N a\xf1ado el 1 que me falta\\n            arr.add(1);\\n        }\\n        System.out.println(\\"x*\\" + N + \\" -> \\" + bitsum(arr, \\"x\\", arr.size())); //imprime la ecuaci\xf3n\\n    }\\n\\n}\\n","cpp":"#include<bits/stdc++.h>\\n#include<cstdlib>\\n#include <math.h>\\n#include <iterator>\\nusing namespace std;\\n#define FAST ios_base::sync_with_stdio(false);cin.tie(NULL);cout.tie(0);\\n\\nbool powerof2(int x) {\\n    return x != 0 & & ((x & (x - 1)) == 0);\\n}\\n\\nint suma(int n) {\\n    return ( ~(-(1 << n))) << 1;\\n}\\n\\nint nith(int n) {\\n    return (int) (log2(n + 2) - 1);\\n}\\n\\nstring bitsum(vector < int > arr, string n, int len) {\\n    vector < int > rev;\\n    map < string, int > counter;\\n    string serie = \\"\\";\\n    for (int i : arr) {\\n        for (int j = 1; j <= nith(i); + + j) {\\n            rev.push_back(j);\\n        }\\n    }\\n    for (int i : rev) {\\n        int aux = 0;\\n        for (int j : rev) {\\n            if (j == i) {\\n                aux + +;\\n            }\\n        }\\n        string dat = \\"(\\" + n + \\"<<\\" + to_string(i) + \\")\\";\\n        counter.insert(pair < string, int > (dat, aux));\\n    }\\n    map < string, int > ::iterator itr;\\n    for (itr = counter.begin(); itr != counter.end(); + + itr) {\\n        string key = itr - > first;\\n        int value = itr - > second;\\n        if (powerof2(value) & & value != 1) {\\n            serie += \\"(\\" + key + \\"<<\\" + to_string(((int) (log2(value)))) + \\") + \\";\\n            continue;\\n        }\\n        for (int j = 0; j < value; j + +) {\\n            serie += \\" \\" + key + \\" + \\";\\n        }\\n    }\\n    if (arr[len - 1] == 1) {\\n        return serie + \\" \\" + n;\\n    }\\n    return serie;\\n}\\n\\nint main() {\\n    FAST;\\n    int n = 7;\\n    int N = n;\\n    vector < int > arr;\\n    while (suma(nith(n))) {\\n        arr.push_back(suma(nith(n)));\\n        n -= suma(nith(n));\\n    }\\n    int sumarr = 0;\\n    for (int i = 0; i < arr.size(); + + i) {\\n        sumarr += arr[i];\\n    }\\n    if (sumarr < N) {\\n        arr.push_back(1);\\n    }\\n    cout << \\"x*\\" << N << \\" -> \\" << bitsum(arr, \\"x\\", arr.size()) << endl;\\n}\\n","py":"from sys import stdin, stdout\\nfrom collections import Counter\\nfrom math import log2\\n\\nin_, out = stdin.readline, stdout.write\\n\\n\\ndef powerof2(n):\\n    x = n\\n    y = not(n & (n - 1))\\n    return x and y\\n\\nsuma = lambda n: (~(-(1 << n))) << 1\\n\\nnith = lambda n: int(log2(n + 2) - 1)\\n\\n\\ndef bitsum(arr, n):\\n    serie = str()\\n    lista = []\\n    for i in arr:\\n        for j in range(1, nith(i) + 1):\\n            lista.append(f\\"({n}<<{j})\\")\\n    v = dict(Counter(lista))\\n    for i in v:\\n        if powerof2(v[i]) and v[i] != 1:\\n            serie += f\\"({i}<<{int(log2(v[i]))}) + \\"\\n            continue\\n        for j in range(v[i]):\\n            serie += f\\"{i} + \\"\\n    if arr[-1] == 1:\\n        return serie[:-3] + f\\" + {n}\\"\\n    return serie[:-3]\\n\\nn = 7\\nN = n\\narr = []\\n\\nwhile suma(nith(n)):\\n    arr.append(suma(nith(n)))\\n    n -= suma(nith(n))\\n\\nif sum(arr) != N:\\n    arr.append(1)\\n\\nout(f\\"x*{N} -> {bitsum(arr,\'x\')}\\\\n\\")\\n","orden":4,"suborden":22,"fecha_creacion":"2020-12-06 19:51:41","fecha_modificacion":"2022-03-08 12:18:28"},{"ID":218,"supergrupo":"BitWise","tema":"Bitmasking (Parte 1)","texto":"Considere la siguiente declaraci\xf3n de problema.\\nHay 100 tipos diferentes de l\xedmites, cada uno con una identificaci\xf3n \xfanica de 1 a 100. Adem\xe1s, hay \\"n\\" personas, cada una con una colecci\xf3n de un n\xfamero variable de l\xedmites. Un d\xeda todas estas personas deciden ir a una fiesta con gorra, pero para verse \xfanicas decidieron que ninguna usar\xeda el mismo tipo de gorra. Por lo tanto, cuente el n\xfamero total de arreglos o formas en que ninguno de ellos use el mismo tipo de gorra.\\nRestricciones: 1 <= n <= 10 Ejemplo:\\nLa primera l\xednea contiene el valor de n, las siguientes n l\xedneas contienen colecciones\\nde todas las n personas.\\nEntrada:\\n3\\n5 100 1 // Recogida de la primera persona.\\n2 // Recogida de la segunda persona.\\n5 100 // Recogida de la tercera persona.\\n\\nSalida:\\n4\\nExplicaci\xf3n: Todas las formas posibles v\xe1lidas son (5, 2, 100), (100, 2, 5),\\n            (1, 2, 5) y (1, 2, 100)\\nDado que, el n\xfamero de formas podr\xeda ser grande, entonces el m\xf3dulo de salida 1000000007\\nLe recomendamos encarecidamente que minimice su navegador e intente esto usted mismo primero.\\nUna soluci\xf3n simple es probar todas las combinaciones posibles. Comience eligiendo el primer elemento del primer conjunto, marc\xe1ndolo como visitado y repita para los conjuntos restantes. Es b\xe1sicamente una soluci\xf3n basada en Backtracking.\\nUna mejor soluci\xf3n es utilizar Bitmasking y DP. Primero introduzcamos Bitmasking.\\n\\n\\n\\n\xbfQu\xe9 es la m\xe1scara de bits?\\nSupongamos que tenemos una colecci\xf3n de elementos que est\xe1n numerados de 1 a N. Si queremos representar un subconjunto de este conjunto, entonces puede ser codificado por una secuencia de N bits (usualmente llamamos a esta secuencia una \u201cm\xe1scara\u201d). En nuestro subconjunto elegido, el elemento i-\xe9simo le pertenece si y solo si el bit i-\xe9simo de la m\xe1scara est\xe1 establecido, es decir, es igual a 1. Por ejemplo, la m\xe1scara 10000101 significa que el subconjunto del conjunto [1\u2026 8 ] consta de los elementos 1, 3 y 8. Sabemos que para un conjunto de N elementos hay un total de 2N subconjuntos, por lo que son posibles 2N m\xe1scaras, una que representa cada subconjunto. Cada m\xe1scara es, de hecho, un n\xfamero entero escrito en notaci\xf3n binaria.\\nNuestra metodolog\xeda principal es asignar un valor a cada m\xe1scara (y, por lo tanto, a cada subconjunto) y as\xed calcular los valores para nuevas m\xe1scaras utilizando valores de las m\xe1scaras ya calculadas. Por lo general, nuestro objetivo principal es calcular el valor / soluci\xf3n para el conjunto completo, es decir, para la m\xe1scara 11111111. Normalmente, para encontrar el valor para un subconjunto X, eliminamos un elemento de todas las formas posibles y usamos valores para los subconjuntos obtenidos X\'1, X \' 2\u2026, X\'k para calcular el valor / soluci\xf3n de X. Esto significa que los valores de X\'i ya deben haberse calculado, por lo que debemos establecer un orden en el que se considerar\xe1n las m\xe1scaras. Es f\xe1cil ver que el orden natural funciona: revise las m\xe1scaras en orden creciente de los n\xfameros correspondientes. Adem\xe1s, a veces, comenzamos con el subconjunto vac\xedo X y agregamos elementos de todas las formas posibles y usamos los valores de los subconjuntos obtenidos X\'1, X\'2 ..., X\'k para calcular el valor / soluci\xf3n para X.\\n\\nUsamos principalmente las siguientes notaciones / operaciones en m\xe1scaras:\\nbit (i, mask) - el i-\xe9simo bit de m\xe1scara\\n\\ncount (m\xe1scara): el n\xfamero de bits distintos de cero en la m\xe1scara\\nprimero (m\xe1scara): el n\xfamero del bit distinto de cero m\xe1s bajo en la m\xe1scara\\nset (i, mask) - establece el bit i en la m\xe1scara\\n\\ncheck (i, m\xe1scara) - comprobar el bit i en la m\xe1scara\\n\\n\xbfC\xf3mo se resuelve este problema usando Bitmasking + DP?\\n\\nLa idea es aprovechar el hecho de que hay hasta 10 personas. Entonces podemos usar una variable entera como una m\xe1scara de bits para almacenar qu\xe9 persona usa gorra y cu\xe1l no.\\n\\nSea i el n\xfamero de l\xedmite actual (los l\xedmites de 1 a i-1 ya est\xe1n\\nprocesado). Dejemos que la m\xe1scara de variable entera indica que las personas w\\norejas y no gorras. Si el bit i\'th est\xe1 configurado en m\xe1scara, entonces\\ni\'th persona lleva una gorra, de lo contrario no.\\n\\n             // considere el caso en el que no se incluye el tope\\n                     // en el arreglo\\ncountWays (m\xe1scara, i) = countWays (m\xe1scara, i + 1) +\\n                    \\n                    // cuando se incluye el tope en el arreglo\\n                    // entonces, asigne este l\xedmite a todas las personas posibles\\n                    // uno por uno y se repite para las personas restantes.\\n                    \u2211 countWays (m\xe1scara | (1 << j), i + 1)\\n                       por cada persona j que pueda usar gorra i\\n \\nTenga en cuenta que la expresi\xf3n \\"m\xe1scara | (1 << j)\\" establece j\'th bit en m\xe1scara.\\nY una persona puede usar gorra i si est\xe1 en la lista de gorra de la persona\\nproporcionado como entrada.\\nSi dibujamos el \xe1rbol de recursividad completo, podemos observar que muchos subproblemas se resuelven una y otra vez. Entonces usamos Programaci\xf3n Din\xe1mica. Se utiliza una tabla dp [] [] de modo que en cada entrada dp [i] [j], i es la m\xe1scara y j es el n\xfamero de l\xedmite.\\n\\nComo queremos acceder a todas las personas que pueden usar una gorra determinada, utilizamos una matriz de vectores, capList [101]. Un valor capList [i] indica la lista de personas que pueden usar gorra i.\\n","complejidad_tiempo":null,"java":"// Usando bitmasking para resolver el problema del numero de formas de \\n// usar sombrero\\n\\nimport java.io.BufferedReader;\\nimport java.io.InputStreamReader;\\nimport java.util.ArrayList;\\n\\npublic class Bitmasking1 {\\n\\n    static final int MOD = 1000000007;\\n\\n    // Objecto lector \\n    static BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\\n\\n    //capList[i]esimo vector contiene la lista de personas que \\n    //tienen un sombrero con id i, id est\xe1 entre 1 y 100, \\n    //por lo que declaramos una array de 101 vectores ya \\n    //que la indexaci\xf3n comienza desde 0.\\n    static ArrayList<Integer> capList[] = new ArrayList[101];\\n\\n    //dp [2 ^ 10] [101] .. en dp [i] [j], i denota la m\xe1scara, \\n    //es decir, indica cu\xe1ntas personas y qu\xe9 personas llevan sombrero. \\n    //j denota el primer j sombrero utilizado. Entonces, dp [i] [j] \\n    //indica el n\xfamero de formas en que asignamos j sombreros para \\n    //enmascarar i de tal manera que ninguno de ellos use el mismo gorro\\n    static int dp[][] = new int[1025][101];\\n\\n    //Esto se usa para el caso base, tiene todos los N bits configurados, \\n    //por lo que indica si todas las N personas est\xe1n usando un sombrero.\\n    static int allmask;\\n\\n    //M\xe1scara es el conjunto de personas, i es cap-id \\n    //(OR el n\xfamero de sombreros procesados a partir del primer sombrero).\\n    static long countWaysUtil(int mask, int i) {\\n        //Si todas las personas est\xe1n usando gorra, \\n        //hemos terminado y esta es una forma, regrese 1\\n        if (mask == allmask) {\\n            return 1;\\n        }\\n\\n        //Si no todo el mundo est\xe1 usando una gorra y adem\xe1s no \\n        //quedan m\xe1s gorras para procesar, \\n        //entonces no hay forma, entonces devuelve 0;\\n        if (i > 100) {\\n            return 0;\\n        }\\n\\n        // Si ya hemos resuelto este subproblema, devolvemos la respuesta.\\n        if (dp[mask][i] != -1) {\\n            return dp[mask][i];\\n        }\\n\\n        //Maneras en las que no incluimos este l\xedmite \\n        //en nuestro arreglo o conjunto de soluciones.\\n        long ways = countWaysUtil(mask, i + 1);\\n\\n        // size es el n\xfamero total de personas que tienen un l\xedmite con la identificaci\xf3n i. \\n        int size = capList[i].size();\\n\\n        //Por lo tanto, asigne uno a uno el sombrero iesimo a \\n        //todas las personas posibles y repita para los sombreros restantes.\\n        for (int j = 0; j < size; j++) {\\n            //Si la persona capList [i] [j] ya est\xe1 usando una gorra, \\n            //contin\xfae, ya que no podemos asignarle esta gorra.\\n            if ((mask & (1 << capList[i].get(j))) != 0) {\\n                continue;\\n            }// De lo contrario, as\xedgnele este sombrero y repita \\n            //para los sombreros restantes con un nuevo vector de m\xe1scara actualizado\\n            else {\\n                ways += countWaysUtil(mask | (1 << capList[i].get(j)), i + 1);\\n            }\\n            ways %= MOD;\\n        }\\n        // Guarde el resultado y devu\xe9lvalo.\\n        return dp[mask][i] = (int) ways;\\n    }\\n\\n    // Lee n l\xedneas de la entrada est\xe1ndar para el caso de prueba actual\\n    static void countWays(int n) throws Exception {\\n        String str;\\n        String split[];\\n        int x;\\n\\n        for (int i = 0; i < n; i++) {\\n            str = br.readLine();\\n            split = str.split(\\" \\");\\n\\n            // mientras haya palabras en split[]\\n            for (int j = 0; j < split.length; j++) {\\n                // agregue la i-\xe9sima persona en la lista de cap si con id x\\n                x = Integer.parseInt(split[j]);\\n                capList[x].add(i);\\n            }\\n\\n        }\\n        //Todas las m\xe1scaras se utilizan para comprobar si \\n        //todas las personas est\xe1n incluidas o no,\\n        //establezca todos los n bits como 1\\n        allmask = (1 << n) - 1;\\n        // Inicializar todas las entradas en dp como -1\\n        for (int[] is : dp) {\\n            for (int i = 0; i < is.length; i++) {\\n                is[i] = -1;\\n            }\\n        }\\n        // Llamar a la funci\xf3n recursiva contar formas\\n        System.out.println(countWaysUtil(0, 1));\\n    }\\n\\n    public static void main(String args[]) throws Exception {\\n        int n; //numero de personas en cada caso de prueba\\n        // inicializando vector de listas\\n        for (int i = 0; i < capList.length; i++) {\\n            capList[i] = new ArrayList<>();\\n        }\\n        //3\\n        //5 100 1\\n        //2\\n        //5 100\\n        n = Integer.parseInt(br.readLine());\\n        countWays(n);\\n        // salida -> 4\\n    }\\n}\\n","cpp":"// C++ program to find number of ways to wear hats \\n#include<bits/stdc++.h> \\n#define MOD 1000000007 \\nusing namespace std;\\n\\nvector<int> capList[101];\\nint dp[1025][101];\\nint allmask;\\n\\nlong long int countWaysUtil(int mask, int i) {\\n    if (mask == allmask) return 1;\\n    if (i > 100) return 0;\\n    if (dp[mask][i] != -1) return dp[mask][i];\\n    long long int ways = countWaysUtil(mask, i + 1);\\n    int size = capList[i].size();\\n    for (int j = 0; j < size; j++) {\\n        if (mask & (1 << capList[i][j])) continue;\\n        else ways += countWaysUtil(mask | (1 << capList[i][j]), i + 1);\\n        ways %= MOD;\\n    }\\n    return dp[mask][i] = ways;\\n}\\n\\nvoid countWays(int n) {\\n    string temp, str;\\n    int x;\\n    getline(cin, str);\\n    for (int i = 0; i < n; i++) {\\n        getline(cin, str);\\n        stringstream ss(str);\\n        while (ss >> temp) {\\n            stringstream s;\\n            s << temp;\\n            s >> x;\\n            capList[x].push_back(i);\\n        }\\n    }\\n    allmask = (1 << n) - 1;\\n    memset(dp, -1, sizeof dp);\\n    cout << countWaysUtil(0, 1) << endl;\\n}\\n\\nint main() {\\n    int n;\\n    cin >> n;\\n    countWays(n);\\n    return 0;\\n}\\n","py":"from collections import defaultdict\\n \\nclass AssignCap: \\n    def __init__(self): \\n        self.allmask = 0\\n        self.total_caps = 100\\n        self.caps = defaultdict(list) \\n\\n    def countWaysUtil(self, dp, mask, cap_no): \\n        if mask == self.allmask: \\n            return 1\\n        if cap_no > self.total_caps: \\n            return 0\\n        if dp[mask][cap_no] != -1: \\n            return dp[mask][cap_no] \\n        ways = self.countWaysUtil(dp, mask, cap_no + 1)  \\n        if cap_no in self.caps: \\n            for ppl in self.caps[cap_no]: \\n                if mask & (1 << ppl): continue\\n                ways += self.countWaysUtil(dp, mask | (1 << ppl), cap_no + 1) \\n                ways = ways % (10 ** 9 + 7)  \\n        dp[mask][cap_no] = ways \\n        return dp[mask][cap_no] \\n    def countWays(self, N): \\n        for ppl in range(N): \\n            cap_possessed_by_person = map(int, raw_input().strip().split()) \\n            for i in cap_possessed_by_person: \\n                self.caps[i].append(ppl) \\n        self.allmask = (1 << N) -1\\n        dp = [[-1 for j in range(self.total_caps + 1)] for i in range(2 ** N)] \\n        print self.countWaysUtil(dp, 0, 1,) \\n\\ndef main(): \\n    No_of_people = input()  \\n    AssignCap().countWays(No_of_people) \\nmain() \\n","orden":4,"suborden":23,"fecha_creacion":"2020-12-06 19:51:42","fecha_modificacion":"2022-03-08 12:18:28"},{"ID":219,"supergrupo":"DP","tema":"El problema de los globos y las monedas","texto":"Se nos han dado N globos, cada uno con una cantidad de monedas asociadas. Al reventar un globo i, el n\xfamero de monedas ganadas es igual a A [i-1] * A [i] * A [i + 1]. Adem\xe1s, los globos i-1 e i + 1 ahora se vuelven adyacentes. Encuentra la m\xe1xima ganancia posible obtenida despu\xe9s de reventar todos los globos. Suponga un 1 adicional en cada l\xedmite.\\nEjemplos:\\nEntrada: 5, 10\\nSalida: 60\\nExplicaci\xf3n - Primera r\xe1faga 5, monedas = 1 * 5 * 10\\n              Luego revienta 10, monedas + = 1 * 10 * 1\\n              Total = 60\\n\\nEntrada: 1, 2, 3, 4, 5\\nSalida: 110\\n\\nPrimero, considere una submatriz de \xedndices de izquierda a derecha (inclusive).\\nSi asumimos que el globo en el \xedndice \xdaltimo es el \xfaltimo globo en reventar en este subarreglo, dir\xedamos que la ganancia acu\xf1ada es-A [izquierda-1] * A [\xfaltimo] * A [derecha + 1].\\nAdem\xe1s, la moneda total ganada ser\xeda este valor, m\xe1s dp [izquierda] [\xfaltimo - 1] + dp [\xfaltimo + 1] [derecha], donde dp [i] [j] significa la moneda m\xe1xima ganada para la submatriz con \xedndices yo, j.\\nPor lo tanto, para cada valor de Izquierda y Derecha, necesitamos encontrar y elegir un valor de \xdaltimo con la m\xe1xima moneda ganada y actualizar la matriz dp.\\nNuestra respuesta es el valor en dp [1] [N].\\n","complejidad_tiempo":null,"java":"//Programa Java para ilustrar el problema del BurstBalloon\\n\\npublic class BurstBalloonMaximizeCoins {\\n\\n    public static int getMax(int[] A, int N) {\\n\\n        // Agregar globos de borde\\n        int[] B = new int[N + 2];\\n        B[0] = B[N + 1] = 1;\\n\\n        for (int i = 1; i <= N; i++) {\\n            B[i] = A[i - 1];\\n        }\\n\\n        // Declaraci\xf3n de array DP\\n        int[][] dp = new int[N + 2][N + 2];\\n\\n        for (int length = 1;\\n                length < N + 1; length++) {\\n            for (int left = 1;\\n                    left < N - length + 2; left++) {\\n                int right = left + length - 1;\\n\\n                //Para una submatriz de \xedndices a la izquierda, a la derecha. \\n                //Este bucle m\xe1s interno encuentra la \xfaltima explosi\xf3n del globo.\\n                for (int last = left;\\n                        last < right + 1; last++) {\\n                    dp[left][right] = Math.max(\\n                            dp[left][right],\\n                            dp[left][last - 1]\\n                            + B[left - 1] * B[last]\\n                            * B[right + 1]\\n                            + dp[last + 1][right]);\\n                }\\n            }\\n        }\\n        return dp[1][N];\\n    }\\n\\n    public static void main(String args[]) {\\n        int[] A = {1, 2, 3, 4, 5};\\n        int N = A.length;\\n        System.out.println(getMax(A, N));\\n    }\\n}\\n","cpp":"#include <bits/stdc++.h> \\n#include <iostream> \\nusing namespace std;\\n\\nint getMax(int A[], int N) {\\n    int B[N + 2];\\n    B[0] = 1;\\n    B[N + 1] = 1;\\n    for (int i = 1; i <= N; i++)\\n        B[i] = A[i - 1];\\n    int dp[N + 2][N + 2];\\n    memset(dp, 0, sizeof (dp));\\n\\n    for (int length = 1; length < N + 1; length++) {\\n        for (int left = 1; left < N - length + 2; left++) {\\n            int right = left + length - 1;\\n            for (int last = left; last < right + 1; last++) {\\n                dp[left][right] = max(dp[left][right],\\n                        dp[left][last - 1] +\\n                        B[left - 1] * B[last] * B[right + 1] +\\n                        dp[last + 1][right]);\\n            }\\n        }\\n    }\\n    return dp[1][N];\\n}\\n\\nint main() {\\n    int A[] = {1, 2, 3, 4, 5};\\n    int N = sizeof (A) / sizeof (A[0]);\\n    cout << getMax(A, N) << endl;\\n}\\n","py":"def getMax(A): \\n    N = len(A) \\n    A = [1] + A + [1]\\n    dp = [[0 for x in range(N + 2)] for y in range(N + 2)] \\n      \\n    for length in range(1, N + 1): \\n        for left in range(1, N-length + 2): \\n            right = left + length -1\\n            for last in range(left, right + 1): \\n                dp[left][right] = max(dp[left][right], \\\\ \\n                                      dp[left][last-1] + \\\\ \\n                                      A[left-1] * A[last] * A[right + 1] + \\\\ \\n                                      dp[last + 1][right]) \\n    return(dp[1][N]) \\n  \\nA = [1, 2, 3, 4, 5] \\nprint(getMax(A)) \\n","orden":9,"suborden":5,"fecha_creacion":"2020-12-06 19:51:42","fecha_modificacion":"2022-03-08 12:19:51"},{"ID":220,"supergrupo":"DP","tema":"El problema de apilamiento de cajas","texto":"Se le da un conjunto de n tipos de cajas rectangulares en 3D, donde la i ^ \xe9sima caja tiene altura h (i), ancho w (i) y profundidad d (i) (todos n\xfameros reales). Desea crear una pila de cajas lo m\xe1s alta posible, pero solo puede apilar una caja encima de otra caja si las dimensiones de la base 2-D de la caja inferior son estrictamente m\xe1s grandes que las del 2- D base de la caja superior. Por supuesto, puede rotar una caja para que cualquier lado funcione como base. Tambi\xe9n est\xe1 permitido utilizar varias instancias del mismo tipo de caja.\\n \\nEl problema de apilamiento de cajas es una variaci\xf3n del problema LIS (Longest increasing subsequence). Necesitamos construir una pila de altura m\xe1xima.\\nLos siguientes son los puntos clave a tener en cuenta en el planteamiento del problema:\\n1) Una caja puede colocarse encima de otra caja solo si tanto el ancho como la profundidad de la caja colocada en la parte superior son menores que el ancho y la profundidad de la caja inferior respectivamente.\\n2) Podemos rotar cajas de manera que el ancho sea menor que la profundidad. Por ejemplo, si hay un cuadro con dimensiones {1x2x3} donde 1 es la altura, 2 \xd7 3 es la base, entonces puede haber tres posibilidades, {1x2x3}, {2x1x3} y {3x1x2}\\n3) Podemos utilizar varias instancias de cajas. Lo que significa es que podemos tener dos rotaciones diferentes de una caja como parte de nuestra pila de altura m\xe1xima.\\nA continuaci\xf3n se muestra la soluci\xf3n basada en la soluci\xf3n DP del problema LIS.\\n\\n1) Genere las 3 rotaciones de todas las cajas. El tama\xf1o de la matriz de rotaci\xf3n se convierte en 3 veces el tama\xf1o de la matriz original. Por simplicidad, consideramos que el ancho es siempre menor o igual que la profundidad.\\n2) Ordene los cuadros 3n generados anteriormente en orden decreciente de \xe1rea base.\\n3) Despu\xe9s de clasificar las cajas, el problema es el mismo que LIS con la siguiente propiedad de subestructura \xf3ptima.\\nMSH (i) = Altura m\xe1xima posible de la pila con la caja i en la parte superior de la pila\\nMSH (i) = {Max (MSH (j)) + altura (i)} donde j <i y ancho (j)> ancho (i) y profundidad (j)> profundidad (i).\\nSi no existe tal j, entonces MSH (i) = altura (i)\\n4) Para obtener la altura m\xe1xima general, devolvemos max (MSH (i)) donde 0 <i <n\\n\\nEn el programa, los cuadros de entrada dados son {4, 6, 7}, {1, 2, 3}, {4, 5, 6}, {10, 12, 32}. A continuaci\xf3n se muestran todas las rotaciones de las cajas en orden decreciente del \xe1rea de la base.\\n   10 x 12 x 32\\n   12 x 10 x 32\\n   32 x 10 x 12\\n   4 x 6 x 7\\n   4 x 5 x 6\\n   6 x 4 x 7\\n   5 x 4 x 6\\n   7 x 4 x 6\\n   6 x 4 x 5\\n   1 x 2 x 3\\n   2 x 1 x 3\\n   3 x 1 x 2\\nLa altura 60 se obtiene mediante cuadros {{3, 1, 2}, {1, 2, 3}, {6, 4, 5}, {4, 5, 6}, {4, 6, 7}, {32 , 10, 12}, {10, 12, 32}}\\n","complejidad_tiempo":null,"java":"/* Implementaci\xf3n de programaci\xf3n din\xe1mica del problema de \\n   apilamiento de cajas en Java*/\\nimport java.util.*;\\n\\npublic class BoxStackingProblem {\\n\\n    /* Representaci\xf3n de una caja */\\n    static class Box implements Comparable<Box> {\\n\\n        // h -> altura, w -> ancho,\\n        // d -> profundidad\\n        int h, w, d, area;\\n\\n        // para simplificar la soluci\xf3n, mantenga siempre w <= d\\n        // Constructor para inicializar el objeto\\n        public Box(int h, int w, int d) {\\n            this.h = h;\\n            this.w = w;\\n            this.d = d;\\n        }\\n\\n        // Para ordenar la matriz de cajas seg\xfan el \\n        // \xe1rea en orden decreciente de \xe1rea\\n        @Override\\n        public int compareTo(Box o) {\\n            return o.area - this.area;\\n        }\\n    }\\n\\n    /* Devuelve la altura de la pila m\xe1s alta que se puede \\n    formar con un tipo de cajas determinado */\\n    static int maxStackHeight(Box arr[], int n) {\\n        Box[] rot = new Box[n * 3];\\n        /* Se crea una nueva matriz de cajas, considerando las 3 posibles \\n        rotaciones, con un ancho siempre mayor que igual al ancho */\\n        for (int i = 0; i < n; i++) {\\n            Box box = arr[i];\\n\\n            /* Caja original*/\\n            rot[3 * i] = new Box(box.h, Math.max(box.w, box.d),\\n                    Math.min(box.w, box.d));\\n\\n            /* Primera rotaci\xf3n de caja*/\\n            rot[3 * i + 1] = new Box(box.w, Math.max(box.h, box.d),\\n                    Math.min(box.h, box.d));\\n\\n            /* Segunda rotaci\xf3n de caja*/\\n            rot[3 * i + 2] = new Box(box.d, Math.max(box.w, box.h),\\n                    Math.min(box.w, box.h));\\n        }\\n\\n        /* C\xe1lculo del \xe1rea base de\\n        cada una de las cajas.*/\\n        for (int i = 0; i < rot.length; i++) {\\n            rot[i].area = rot[i].w * rot[i].d;\\n        }\\n\\n        /* Clasificaci\xf3n de las cajas seg\xfan el \xe1rea en orden no creciente.*/\\n        Arrays.sort(rot);\\n        int count = 3 * n;\\n        /* Inicializar los valores de msh para todos\\n            \xedndices\\n        msh [i] -> Altura m\xe1xima de pila posible con \\n        la casilla i en la parte superior */\\n        int[] msh = new int[count];\\n        for (int i = 0; i < count; i++) {\\n            msh[i] = rot[i].h;\\n        }\\n\\n        /* Calcular valores optimizados de msh [] de forma ascendente */\\n        for (int i = 0; i < count; i++) {\\n            msh[i] = 0;\\n            Box box = rot[i];\\n            int val = 0;\\n\\n            for (int j = 0; j < i; j++) {\\n                Box prevBox = rot[j];\\n                if (box.w < prevBox.w && box.d < prevBox.d) {\\n                    val = Math.max(val, msh[j]);\\n                }\\n            }\\n            msh[i] = val + box.h;\\n        }\\n\\n        int max = -1;\\n\\n        /* Elija el m\xe1ximo de todos los valores de msh */\\n        for (int i = 0; i < count; i++) {\\n            max = Math.max(max, msh[i]);\\n        }\\n\\n        return max;\\n    }\\n\\n    public static void main(String[] args) {\\n        Box[] arr = new Box[4];\\n        arr[0] = new Box(4, 6, 7);\\n        arr[1] = new Box(1, 2, 3);\\n        arr[2] = new Box(4, 5, 6);\\n        arr[3] = new Box(10, 12, 32);\\n\\n        System.out.println(\\"The maximum possible \\"\\n                + \\"height of stack is \\"\\n                + maxStackHeight(arr, 4));\\n    }\\n}\\n","cpp":"#include<stdio.h> \\n#include<stdlib.h> \\n\\nstruct Box {\\n    int h, w, d;\\n};\\n\\nint min(int x, int y) {\\n    return (x < y) ? x : y;\\n}\\n\\nint max(int x, int y) {\\n    return (x > y) ? x : y;\\n}\\n\\nint compare(const void *a, const void * b) {\\n    return ( (*(Box *) b).d * (*(Box *) b).w) -\\n            ((*(Box *) a).d * (*(Box *) a).w);\\n}\\n\\nint maxStackHeight(Box arr[], int n) {\\n\\n    Box rot[3 * n];\\n    int index = 0;\\n    for (int i = 0; i < n; i++) {\\n        rot[index].h = arr[i].h;\\n        rot[index].d = max(arr[i].d, arr[i].w);\\n        rot[index].w = min(arr[i].d, arr[i].w);\\n        index++;\\n\\n        rot[index].h = arr[i].w;\\n        rot[index].d = max(arr[i].h, arr[i].d);\\n        rot[index].w = min(arr[i].h, arr[i].d);\\n        index++;\\n\\n        rot[index].h = arr[i].d;\\n        rot[index].d = max(arr[i].h, arr[i].w);\\n        rot[index].w = min(arr[i].h, arr[i].w);\\n        index++;\\n    }\\n\\n    n = 3 * n;\\n\\n    qsort(rot, n, sizeof (rot[0]), compare);\\n    //Uncomment following two lines to print all rotations \\n    // for (int i = 0; i < n; i++ ) \\n    // printf(\\"%d x %d x %d\\\\n\\", rot[i].h, rot[i].w, rot[i].d); \\n    int msh[n];\\n    for (int i = 0; i < n; i++)\\n        msh[i] = rot[i].h;\\n\\n    for (int i = 1; i < n; i++)\\n        for (int j = 0; j < i; j++)\\n            if (rot[i].w < rot[j].w &&\\n                    rot[i].d < rot[j].d &&\\n                    msh[i] < msh[j] + rot[i].h\\n                    ) {\\n                msh[i] = msh[j] + rot[i].h;\\n            }\\n\\n\\n    int max = -1;\\n    for (int i = 0; i < n; i++)\\n        if (max < msh[i])\\n            max = msh[i];\\n\\n    return max;\\n}\\n\\nint main() {\\n    Box arr[] = {\\n        {4, 6, 7},\\n        {1, 2, 3},\\n        {4, 5, 6},\\n        {10, 12, 32}\\n    };\\n    int n = sizeof (arr) / sizeof (arr[0]);\\n\\n    printf(\\"The maximum possible height of stack is %d\\\\n\\",\\n            maxStackHeight(arr, n));\\n\\n    return 0;\\n}\\n","py":"class Box: \\n    def __init__(self, h, w, d): \\n        self.h = h \\n        self.w = w \\n        self.d = d \\n\\n    def __lt__(self, other): \\n        return self.d * self.w < other.d * other.w \\n\\ndef maxStackHeight(arr, n): \\n    rot = [Box(0, 0, 0) for _ in range(3 * n)] \\n    index = 0\\n    for i in range(n): \\n        rot[index].h = arr[i].h \\n        rot[index].d = max(arr[i].d, arr[i].w) \\n        rot[index].w = min(arr[i].d, arr[i].w) \\n        index += 1\\n        rot[index].h = arr[i].w \\n        rot[index].d = max(arr[i].h, arr[i].d) \\n        rot[index].w = min(arr[i].h, arr[i].d) \\n        index += 1\\n        rot[index].h = arr[i].d \\n        rot[index].d = max(arr[i].h, arr[i].w) \\n        rot[index].w = min(arr[i].h, arr[i].w) \\n        index += 1\\n    n *= 3\\n    rot.sort(reverse=True) \\n\\n    # Uncomment following two lines to print \\n    # all rotations \\n    # for i in range(n): \\n    #    print(rot[i].h, \'x\', rot[i].w, \'x\', rot[i].d) \\n\\n    msh = [0] * n \\n\\n    for i in range(n): \\n        msh[i] = rot[i].h \\n    for i in range(1, n): \\n        for j in range(0, i): \\n            if (rot[i].w < rot[j].w and\\n                rot[i].d < rot[j].d): \\n                if msh[i] < msh[j] + rot[i].h: \\n                    msh[i] = msh[j] + rot[i].h \\n\\n    maxm = -1\\n    for i in range(n): \\n        maxm = max(maxm, msh[i]) \\n\\n    return maxm \\n\\n\\narr = [Box(4, 6, 7), Box(1, 2, 3), \\n    Box(4, 5, 6), Box(10, 12, 32)] \\nn = len(arr) \\nprint(\\"The maximum possible height of stack is\\", \\n      maxStackHeight(arr, n)) \\n","orden":9,"suborden":6,"fecha_creacion":"2020-12-06 19:51:42","fecha_modificacion":"2022-03-08 12:19:51"},{"ID":221,"supergrupo":"DP","tema":"Secuencia m\xe1xima de sumas incrementales desde prefijos","texto":"Dada una matriz de n enteros positivos, escriba un programa para encontrar la suma m\xe1xima de subsecuencia creciente desde el prefijo hasta el \xedndice i-\xe9simo y tambi\xe9n incluya un elemento k-\xe9simo dado que est\xe1 despu\xe9s de i, es decir, k> i.\\nEjemplos:\\n \\nEntrada: arr [] = {1, 101, 2, 3, 100, 4, 5} i-\xe9simo \xedndice = 4 (el elemento del cuarto \xedndice es 100) K-\xe9simo \xedndice = 6 (el elemento del sexto \xedndice es 5.)\\nSalida: 11\\nExplicaci\xf3n:\\nPor lo tanto, necesitamos calcular la suma m\xe1xima de la subsecuencia (1 101 2 3 100 5) de modo que 5 se incluya necesariamente en la subsecuencia, por lo que la respuesta es 11 por subsecuencia (1 2 3 5).\\nEntrada: arr [] = {1, 101, 2, 3, 100, 4, 5} i-\xe9simo \xedndice = 2 (el elemento en el segundo \xedndice es 2) K-\xe9simo \xedndice = 5 (el elemento en el quinto \xedndice es 4.)\\nSalida: 7\\nExplicaci\xf3n:\\nPor lo tanto, debemos calcular la suma m\xe1xima de la subsecuencia (1101 2 4) de modo que 4 se incluya necesariamente en la subsecuencia, por lo que la respuesta es 7 por subsecuencia (1 2 4).\\n\\nEnfoque ingenuo:\\n \\n1. Construya una nueva matriz que contenga elementos hasta el \xedndice i y el elemento k.\\n2. Calcule de forma recursiva todas las subsecuencias crecientes.\\n3. Descarte todas las subsecuencias que no tengan el k-\xe9simo elemento incluido.\\n4. Calcule la suma m\xe1xima de las subsecuencias restantes y visual\xedcela.\\n\\nMejor enfoque: utilice un enfoque din\xe1mico para mantener una tabla dp [] []. El valor de dp [i] [k] almacena la suma m\xe1xima de la subsecuencia creciente hasta el \xedndice i y que contiene el elemento k.\\n\\nEnfoque eficiente: este problema consiste b\xe1sicamente en encontrar que la suma m\xe1xima de la subsecuencia creciente hasta el \xedndice i dado es que todos los elementos de la subsecuencia son menores que el elemento kth (\xedndice) o arr [k]. Por lo tanto, encuentre la subsecuencia creciente de suma m\xe1xima.\\n \\nPor ejemplo: arr [] = {1, 101, 2, 3, 100, 4, 5}, index = 4; k = 6;\\nAhora, necesitamos encontrar la subsecuencia de suma m\xe1xima desde la matriz hasta el \xedndice 4 dado que todos los elementos de esa subsecuencia son menores que arr [k] que es 5. Ahora, iterando a trav\xe9s de la matriz.\\nPara i = 0; como 1 <5; max subsecuencia creciente {1}, max = 1.\\nPara i = 1; como 101> 5; omita esta entrada. Subsecuencia creciente m\xe1x. {1}, m\xe1x = 1.\\nPara i = 2; como 2 <5; max subsecuencia creciente {1, 2}, max = 3.\\nPara i = 3; como 3 <5; max subsecuencia creciente {1, 2, 3}, max = 6.\\nPara i = 4; como 100> 5; omita esta entrada. Subsecuencia creciente m\xe1x. {1, 2, 3}, m\xe1x = 6.\\ncomo \xedndice = 4; por lo tanto, det\xe9ngase aqu\xed y la respuesta ser\xe1 max + a [k] = 6 + 5 = 11.\\n","complejidad_tiempo":null,"java":"// Programa Java para encontrar la suma m\xe1xima que aumenta la subsecuencia \\n// del \xedndice i-\xe9simo e incluye el \xedndice k-\xe9simo.\\n\\npublic class MaximumSumIncreasingSubsequenceFromPrefix {\\n\\n    static int pre_compute(int a[], int n,\\n            int index, int k) {\\n        int dp[][] = new int[n][n];\\n\\n        // Inicializando la primera fila del dp[][].\\n        for (int i = 0; i < n; i++) {\\n            if (a[i] > a[0]) {\\n                dp[0][i] = a[i] + a[0];\\n            } else {\\n                dp[0][i] = a[i];\\n            }\\n        }\\n\\n        // Creando la matriz dp[][].\\n        for (int i = 1; i < n; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (a[j] > a[i] && j > i) {\\n                    if (dp[i - 1][i] + a[j]\\n                            > dp[i - 1][j]) {\\n                        dp[i][j] = dp[i - 1][i]\\n                                + a[j];\\n                    } else {\\n                        dp[i][j] = dp[i - 1][j];\\n                    }\\n                } else {\\n                    dp[i][j] = dp[i - 1][j];\\n                }\\n            }\\n        }\\n\\n        // Calcular para i = 4 y k = 6.\\n        return dp[index][k];\\n    }\\n\\n    public static void main(String[] args) {\\n        int a[] = {1, 101, 2, 3, 100, 4, 5};\\n        int n = a.length;\\n        int index = 4, k = 6;\\n        System.out.println(\\n                pre_compute(a, n, index, k));\\n    }\\n}\\n","cpp":"#include <bits/stdc++.h> \\nusing namespace std;\\n\\nint pre_compute(int a[], int n, int index, int k) {\\n    int dp[n][n];\\n\\n    for (int i = 0; i < n; i++) {\\n        if (a[i] > a[0]) {\\n            dp[0][i] = a[i] + a[0];\\n        } else {\\n            dp[0][i] = a[i];\\n        }\\n    }\\n\\n    for (int i = 1; i < n; i++) {\\n        for (int j = 0; j < n; j++) {\\n            if (a[j] > a[i] && j > i) {\\n                if (dp[i - 1][i] + a[j]\\n                        > dp[i - 1][j]) {\\n                    dp[i][j] = dp[i - 1][i]\\n                            + a[j];\\n                } else {\\n                    dp[i][j] = dp[i - 1][j];\\n                }\\n            } else {\\n                dp[i][j] = dp[i - 1][j];\\n            }\\n        }\\n    }\\n\\n    return dp[index][k];\\n}\\n\\nint main() {\\n    int a[] = {1, 101, 2, 3, 100, 4, 5};\\n    int n = sizeof (a) / sizeof (a[0]);\\n    int index = 4, k = 6;\\n    cout << pre_compute(a, n, index, k) << endl;\\n}\\n","py":"def pre_compute(a, n, index, k):\\n    dp = [[0 for i in range(n)]for j in range(n)]\\n    for i in range (n):\\n        if (a[i] > a[0]):\\n            dp[0][i] = a[i] + a[0]\\n        else:\\n            dp[0][i] = a[i]\\n\\n    for i in range (n):\\n        for j in range (n):\\n            if (a[j] > a[i] and j > i):\\n                if (dp[i - 1][i] + a[j] > dp[i - 1][j]):\\n                    dp[i][j] = dp[i - 1][i] + a[j];\\n                else:\\n                    dp[i][j] = dp[i - 1][j]\\n            else:\\n                dp[i][j] = dp[i - 1][j]\\n    return dp[index][k];\\n\\na = [1, 101, 2, 3, 100, 4, 5]\\nn = len(a)\\nindex = 4\\nk = 6\\nprint(pre_compute(a, n, index, k) + 1)\\n","orden":9,"suborden":7,"fecha_creacion":"2020-12-06 19:51:43","fecha_modificacion":"2022-03-08 12:19:51"},{"ID":222,"supergrupo":"DP","tema":"Minima suma en particiones ","texto":"Dado un conjunto de n\xfameros enteros, la tarea es dividirlo en dos conjuntos S1 y S2 de manera que la diferencia absoluta entre sus sumas sea m\xednima.\\nSi hay un conjunto S con n elementos, entonces si asumimos que Subconjunto1 tiene m elementos, Subconjunto2 debe tener n-m elementos y el valor de abs (suma (Subconjunto1) - suma (Subconjunto2)) debe ser m\xednimo.\\nEjemplo:\\nEntrada: arr [] = {1, 6, 11, 5}\\nSalida: 1\\nExplicaci\xf3n:\\nSubconjunto1 = {1, 5, 6}, suma de Subconjunto1 = 12\\nSubconjunto2 = {11}, suma de Subconjunto2 = 11\\n\\nSoluci\xf3n recursiva\\nEl enfoque recursivo consiste en generar todas las sumas posibles a partir de todos los valores de la matriz y comprobar qu\xe9 soluci\xf3n es la m\xe1s \xf3ptima.\\nPara generar sumas, incluimos el elemento i en el conjunto 1 o no lo incluimos, es decir, lo incluimos en el conjunto 2.\\n\\nComplejidad del tiempo:\\nTodas las sumas pueden ser generadas por\\n(1) incluyendo ese elemento en el conjunto 1.\\n(2) sin incluir ese elemento en el conjunto 1.\\nEntonces las posibles combinaciones son: -\\narr [0] (1 o 2) -> 2 valores\\narr [1] (1 o 2) -> 2 valores\\n.\\n.\\n.\\narr [n] (2 o 2) -> 2 valores\\nEntonces, la complejidad del tiempo ser\xe1 2 * 2 * ..... * 2 (Para n veces),\\neso es O (2 ^ n).\\n\\nProgramaci\xf3n din\xe1mica\\nEl problema se puede resolver mediante programaci\xf3n din\xe1mica cuando la suma de los elementos no es demasiado grande. Podemos crear una matriz 2D dp [n + 1] [suma + 1] donde n es un n\xfamero de elementos en un conjunto dado y suma es la suma de todos los elementos. Podemos construir la soluci\xf3n de forma ascendente.\\n\\n\\n\\nLa tarea consiste en dividir el conjunto en dos partes.\\nConsideraremos los siguientes factores para dividirlo.\\nDejar\\n  dp [n + 1] [suma + 1] = {1 si alg\xfan subconjunto del 1 al i tiene una suma\\n                      igual a j\\n                   0 de lo contrario}\\n    \\n    i var\xeda de {1..n}\\n    j oscila entre {0 .. (suma de todos los elementos)}\\n\\nEntonces\\n    dp [n + 1] [suma + 1] ser\xe1 1 si\\n    1) La suma j se logra incluyendo el \xedtem i.\\n    2) La suma j se obtiene excluyendo el \xedtem i.\\n\\nSea la suma de todos los elementos S.\\n\\nPara encontrar la diferencia de suma m\xednima, w tenemos que encontrar j tales\\nese Min {suma - j * 2: dp [n] [j] == 1}\\n    donde j var\xeda de 0 a suma / 2\\n\\nLa idea es que la suma de S1 es j y deber\xeda ser la m\xe1s cercana\\na sum / 2, es decir, 2 * j debe ser el m\xe1s cercano a sum.\\n\\nComplejidad de tiempo = O (n * suma) donde n es el n\xfamero de elementos y suma es la suma de todos los elementos.\\n","complejidad_tiempo":null,"java":"// Un programa Java recursivo para resolver el problema de partici\xf3n de suma m\xednima.\\n\\npublic class MinimumSumPartition {\\n    // Devuelve el valor m\xednimo de la diferencia de los dos conjuntos.\\n\\n    static int findMin(int arr[], int n) {\\n        // Calcular la suma de todos los elementos\\n        int sum = 0;\\n        for (int i = 0; i < n; i++) {\\n            sum += arr[i];\\n        }\\n\\n        // Cree una matriz para almacenar los resultados de los subproblemas\\n        boolean dp[][] = new boolean[n + 1][sum + 1];\\n\\n        // Inicialice la primera columna como verdadera. \\n        // La suma 0 es posible con todos los elementos.\\n        for (int i = 0; i <= n; i++) {\\n            dp[i][0] = true;\\n        }\\n\\n        // Inicialice la fila superior, excepto dp [0] [0], \\n        // como falso. Con 0 elementos, no es posible ninguna otra suma excepto 0\\n        for (int i = 1; i <= sum; i++) {\\n            dp[0][i] = false;\\n        }\\n\\n        // Llene la tabla de partici\xf3n de abajo hacia arriba\\n        for (int i = 1; i <= n; i++) {\\n            for (int j = 1; j <= sum; j++) {\\n                // Si se excluye el i-\xe9simo elemento\\n                dp[i][j] = dp[i - 1][j];\\n\\n                // Si se incluye i\'th elemento\\n                if (arr[i - 1] <= j) {\\n                    dp[i][j] |= dp[i - 1][j - arr[i - 1]];\\n                }\\n            }\\n        }\\n\\n        // Inicialice la diferencia de dos sumas.\\n        int diff = Integer.MAX_VALUE;\\n\\n        // Encuentre el j m\xe1s grande tal que dp [n] [j] \\n        // sea verdadero donde j hace un ciclo de suma / 2 t0 0\\n        for (int j = sum / 2; j >= 0; j--) {\\n            if (dp[n][j] == true) {\\n                diff = sum - 2 * j;\\n                break;\\n            }\\n        }\\n        return diff;\\n    }\\n\\n    public static void main(String[] args) {\\n        int arr[] = {3, 1, 4, 2, 2, 1};\\n        int n = arr.length;\\n        System.out.println(\\"The minimum difference between 2 sets is \\"\\n                + findMin(arr, n));\\n    }\\n}\\n","cpp":"#include <bits/stdc++.h> \\nusing namespace std;\\n\\nint findMin(int arr[], int n) {\\n\\n    int sum = 0;\\n    for (int i = 0; i < n; i++)\\n        sum += arr[i];\\n\\n    bool dp[n + 1][sum + 1];\\n\\n    for (int i = 0; i <= n; i++)\\n        dp[i][0] = true;\\n\\n    for (int i = 1; i <= sum; i++)\\n        dp[0][i] = false;\\n    for (int i = 1; i <= n; i++) {\\n        for (int j = 1; j <= sum; j++) {\\n            dp[i][j] = dp[i - 1][j];\\n            if (arr[i - 1] <= j)\\n                dp[i][j] |= dp[i - 1][j - arr[i - 1]];\\n        }\\n    }\\n    int diff = INT_MAX;\\n    for (int j = sum / 2; j >= 0; j--) {\\n        if (dp[n][j] == true) {\\n            diff = sum - 2 * j;\\n            break;\\n        }\\n    }\\n    return diff;\\n}\\n\\nint main() {\\n    int arr[] = {3, 1, 4, 2, 2, 1};\\n    int n = sizeof (arr) / sizeof (arr[0]);\\n    cout << \\"The minimum difference between 2 sets is \\"\\n            << findMin(arr, n);\\n    return 0;\\n}\\n","py":"import sys\\n \\n\\ndef findMin(a, n):      \\n    su = 0\\n    su = sum(a) \\n    dp = [[0 for i in range(su + 1)] \\n        for j in range(n + 1)] \\n    for i in range(n + 1): \\n        dp[i][0] = True\\n    for j in range(1, su + 1): \\n        dp[0][j] = False\\n    for i in range(1, n + 1): \\n        for j in range(1, su + 1): \\n            dp[i][j] = dp[i - 1][j]  \\n            if a[i - 1] <= j: \\n                dp[i][j] |= dp[i - 1][j - a[i - 1]] \\n    diff = sys.maxsize \\n    for j in range(su // 2, -1, -1): \\n        if dp[n][j] == True: \\n            diff = su - (2 * j) \\n            break\\n                        \\n    return diff \\n        \\na = [3, 1, 4, 2, 2, 1] \\nn = len(a) \\n        \\nprint(\\"The minimum difference between \\"\\n      \\"2 sets is \\", findMin(a, n)) \\n","orden":9,"suborden":8,"fecha_creacion":"2020-12-06 19:51:43","fecha_modificacion":"2022-03-08 12:19:51"},{"ID":223,"supergrupo":"DP","tema":"Camino m\xe1s largo en una matriz usando DP","texto":"Dada una matriz n * n donde todos los n\xfameros son distintos, encuentre la ruta de longitud m\xe1xima (comenzando desde cualquier celda) de modo que todas las celdas a lo largo de la ruta est\xe9n en orden creciente con una diferencia de 1.\\nPodemos movernos en 4 direcciones desde una celda dada (i, j), es decir, podemos movernos a (i + 1, j) o (i, j + 1) o (i-1, j) o (i, j -1) con la condici\xf3n de que las celdas adyacentes tengan una diferencia de 1.\\nEjemplo:\\nEntrada: mat [] [] = {{1, 2, 9}\\n                   {5, 3, 8}\\n                   {4, 6, 7}}\\nSalida: 4\\nEl camino m\xe1s largo es 6-7-8-9.\\nLa idea es simple, calculamos la ruta m\xe1s larga comenzando con cada celda. Una vez que hemos calculado el m\xe1ximo para todas las celdas, devolvemos el m\xe1ximo de todas las rutas m\xe1s largas. Una observaci\xf3n importante en este enfoque son muchos subproblemas superpuestos. Por lo tanto, este problema se puede resolver de manera \xf3ptima mediante la programaci\xf3n din\xe1mica.\\nA continuaci\xf3n se muestra una implementaci\xf3n basada en Programaci\xf3n din\xe1mica que usa una tabla de b\xfasqueda dp [] [] para verificar si un problema ya est\xe1 resuelto o no.\\nLa complejidad temporal de la soluci\xf3n es O (n2). Puede parecer m\xe1s a primera vista. Si miramos m\xe1s de cerca, podemos notar que todos los valores de dp [i] [j] se calculan solo una vez.\\n","complejidad_tiempo":null,"java":"// Programa Java para encontrar la ruta m\xe1s larga en una matriz con restricciones dadas\\n\\npublic class DPLongestPath {\\n\\n    public static int n = 3;\\n\\n    // Funci\xf3n que devuelve la longitud de la ruta m\xe1s larga que comienza con mat [i] [j]\\n    // Esta funci\xf3n usa principalmente la tabla de b\xfasqueda dp [n] [n]\\n    static int findLongestFromACell(int i, int j, int mat[][], int dp[][]) {\\n        // Base case \\n        if (i < 0 || i >= n || j < 0 || j >= n) {\\n            return 0;\\n        }\\n\\n        // Si este subproblema ya est\xe1 resuelto\\n        if (dp[i][j] != -1) {\\n            return dp[i][j];\\n        }\\n\\n        // Para almacenar las longitudes de la ruta en las cuatro direcciones\\n        int x = Integer.MIN_VALUE, y = Integer.MIN_VALUE, z = Integer.MIN_VALUE, w = Integer.MIN_VALUE;\\n        // Dado que todos los n\xfameros son \xfanicos y est\xe1n en el \\n        // rango de 1 an * n, hay al menos una direcci\xf3n posible desde cualquier celda\\n        if (j < n - 1 && ((mat[i][j] + 1) == mat[i][j + 1])) {\\n            x = dp[i][j] = 1 + findLongestFromACell(i, j + 1, mat, dp);\\n        }\\n\\n        if (j > 0 && (mat[i][j] + 1 == mat[i][j - 1])) {\\n            y = dp[i][j] = 1 + findLongestFromACell(i, j - 1, mat, dp);\\n        }\\n\\n        if (i > 0 && (mat[i][j] + 1 == mat[i - 1][j])) {\\n            z = dp[i][j] = 1 + findLongestFromACell(i - 1, j, mat, dp);\\n        }\\n\\n        if (i < n - 1 && (mat[i][j] + 1 == mat[i + 1][j])) {\\n            w = dp[i][j] = 1 + findLongestFromACell(i + 1, j, mat, dp);\\n        }\\n\\n        // Si ninguno de los cuatro adyacentes es uno mayor, tomaremos 1; \\n        // de lo contrario, elegiremos el m\xe1ximo de las cuatro direcciones.\\n        return dp[i][j] = Math.max(x, Math.max(y, Math.max(z, Math.max(w, 1))));\\n    }\\n\\n    // Funci\xf3n que devuelve la longitud de la ruta m\xe1s \\n    // larga que comienza con cualquier celda\\n    static int finLongestOverAll(int mat[][]) {\\n        // Inicializar resultado\\n        int result = 1;\\n\\n        // Cree una tabla de b\xfasqueda y complete todas las entradas en ella como -1\\n        int[][] dp = new int[n][n];\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < n; j++) {\\n                dp[i][j] = -1;\\n            }\\n        }\\n\\n        // Calcule la ruta m\xe1s larga comenzando desde todas las celdas\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (dp[i][j] == -1) {\\n                    findLongestFromACell(i, j, mat, dp);\\n                }\\n\\n                // Actualizar el resultado si es necesario\\n                result = Math.max(result, dp[i][j]);\\n            }\\n        }\\n\\n        return result;\\n    }\\n\\n    public static void main(String[] args) {\\n        int mat[][] = {{1, 2, 9},\\n        {5, 3, 8},\\n        {4, 6, 7}};\\n        System.out.println(\\"Length of the longest path is \\" + finLongestOverAll(mat));\\n    }\\n}\\n","cpp":"#include <bits/stdc++.h> \\n#define n 3 \\nusing namespace std;\\n\\nint findLongestFromACell(int i, int j, int mat[n][n], int dp[n][n]) {\\n    if (i < 0 || i >= n || j < 0 || j >= n)\\n        return 0;\\n    if (dp[i][j] != -1)\\n        return dp[i][j];\\n    int x = INT_MIN, y = INT_MIN, z = INT_MIN, w = INT_MIN;\\n\\n    if (j < n - 1 && ((mat[i][j] + 1) == mat[i][j + 1]))\\n        x = 1 + findLongestFromACell(i, j + 1, mat, dp);\\n\\n    if (j > 0 && (mat[i][j] + 1 == mat[i][j - 1]))\\n        y = 1 + findLongestFromACell(i, j - 1, mat, dp);\\n\\n    if (i > 0 && (mat[i][j] + 1 == mat[i - 1][j]))\\n        z = 1 + findLongestFromACell(i - 1, j, mat, dp);\\n\\n    if (i < n - 1 && (mat[i][j] + 1 == mat[i + 1][j]))\\n        w = 1 + findLongestFromACell(i + 1, j, mat, dp);\\n\\n    return dp[i][j] = max(x, max(y, max(z, max(w, 1))));\\n}\\n\\nint finLongestOverAll(int mat[n][n]) {\\n    int result = 1;\\n    int dp[n][n];\\n    memset(dp, -1, sizeof dp);\\n    for (int i = 0; i < n; i++) {\\n        for (int j = 0; j < n; j++) {\\n            if (dp[i][j] == -1)\\n                findLongestFromACell(i, j, mat, dp);\\n            result = max(result, dp[i][j]);\\n        }\\n    }\\n\\n    return result;\\n}\\n\\nint main() {\\n    int mat[n][n] = {\\n        { 1, 2, 9},\\n        { 5, 3, 8},\\n        { 4, 6, 7}\\n    };\\n    cout << \\"Length of the longest path is \\"\\n            << finLongestOverAll(mat);\\n    return 0;\\n} \\n","py":"n = 3 \\ndef findLongestFromACell(i, j, mat, dp): \\n\\n    if (i < 0 or i >= n or j < 0 or j >= n): \\n        return 0\\n\\n    if (dp[i][j] != -1):  \\n        return dp[i][j] \\n    x, y, z, w = -1, -1, -1, -1\\n    if (j < n-1 and ((mat[i][j] + 1) == mat[i][j + 1])): \\n        x = 1 + findLongestFromACell(i, j + 1, mat, dp) \\n  \\n    if (j > 0 and (mat[i][j] + 1 == mat[i][j-1])):  \\n        y = 1 + findLongestFromACell(i, j-1, mat, dp) \\n  \\n    if (i > 0 and (mat[i][j] + 1 == mat[i-1][j])): \\n        z = 1 + findLongestFromACell(i-1, j, mat, dp) \\n  \\n    if (i < n-1 and (mat[i][j] + 1 == mat[i + 1][j])): \\n        w = 1 + findLongestFromACell(i + 1, j, mat, dp) \\n    dp[i][j] = max(x, max(y, max(z, max(w, 1)))) \\n    return dp[i][j] \\n  \\ndef finLongestOverAll(mat): \\n    result = 1 \\n    dp = [[-1 for i in range(n)]for i in range(n)] \\n    for i in range(n): \\n        for j in range(n): \\n            if (dp[i][j] == -1): \\n                findLongestFromACell(i, j, mat, dp) \\n            result = max(result, dp[i][j]);  \\n    return result \\n  \\nmat = [[1, 2, 9], \\n    [5, 3, 8], \\n    [4, 6, 7]]  \\nprint(\\"Length of the longest path is \\", finLongestOverAll(mat)) \\n","orden":9,"suborden":9,"fecha_creacion":"2020-12-06 19:51:43","fecha_modificacion":"2022-03-08 12:19:51"},{"ID":224,"supergrupo":"Grafos","tema":"Puntos de articulaci\xf3n","texto":"Un v\xe9rtice en un gr\xe1fico conectado no dirigido es un punto de articulaci\xf3n (o v\xe9rtice de corte) si al eliminarlo (y las aristas a trav\xe9s de \xe9l) se desconecta el gr\xe1fico. Los puntos de articulaci\xf3n representan vulnerabilidades en una red conectada: puntos \xfanicos cuya falla dividir\xeda la red en 2 o m\xe1s componentes. Son \xfatiles para dise\xf1ar redes confiables.\\nPara un gr\xe1fico no dirigido desconectado, un punto de articulaci\xf3n es una eliminaci\xf3n de v\xe9rtices que aumenta el n\xfamero de componentes conectados.\\nA continuaci\xf3n se muestran algunos ejemplos de gr\xe1ficos con puntos de articulaci\xf3n rodeados de color rojo.\\n\\n\xbfC\xf3mo encontrar todos los puntos de articulaci\xf3n en un gr\xe1fico dado?\\nUn enfoque simple es eliminar uno por uno todos los v\xe9rtices y ver si la eliminaci\xf3n de un v\xe9rtice causa un gr\xe1fico desconectado. Los siguientes son pasos de enfoque simple para gr\xe1ficos conectados.\\n1) Para cada v\xe9rtice v, haga lo siguiente\\n\u2026 ..A) Eliminar v del gr\xe1fico\\n..\u2026 b) Vea si el gr\xe1fico permanece conectado (podemos usar BFS o DFS)\\n\u2026 ..C) Suma v de nuevo al gr\xe1fico\\n\\nLa complejidad del tiempo del m\xe9todo anterior es O (V * (V + E)) para un gr\xe1fico representado mediante una lista de adyacencia. \xbfPodemos hacerlo mejor?\\n\\nUn algoritmo O (V + E) para encontrar todos los puntos de articulaci\xf3n (AP)\\nLa idea es utilizar DFS (Depth First Search). En DFS, seguimos los v\xe9rtices en forma de \xe1rbol llamados \xe1rbol DFS. En el \xe1rbol DFS, un v\xe9rtice u es padre de otro v\xe9rtice v, si v es descubierto por u (obviamente v es un adyacente de u en el gr\xe1fico). En el \xe1rbol DFS, un v\xe9rtice u es un punto de articulaci\xf3n si se cumple una de las dos condiciones siguientes.\\n1) u es la ra\xedz del \xe1rbol DFS y tiene al menos dos hijos.\\n2) u no es la ra\xedz del \xe1rbol DFS y tiene un hijo v tal que ning\xfan v\xe9rtice en el sub\xe1rbol enraizado con v tiene una arista posterior a uno de los antepasados (en el \xe1rbol DFS) de u.\\n\\nHacemos un recorrido DFS de un gr\xe1fico dado con c\xf3digo adicional para averiguar los puntos de articulaci\xf3n (AP). En el recorrido DFS, mantenemos una matriz padre [] donde padre [u] almacena padre del v\xe9rtice u. Entre los dos casos mencionados anteriormente, el primer caso es f\xe1cil de detectar. Para cada v\xe9rtice, cuente los ni\xf1os. Si el v\xe9rtice u actualmente visitado es ra\xedz (el padre [u] es NULO) y tiene m\xe1s de dos hijos, impr\xedmalo.\\n\\n\xbfC\xf3mo manejar el segundo caso? El segundo caso es m\xe1s complicado. Mantenemos un disc de matriz [] para almacenar el tiempo de descubrimiento de los v\xe9rtices. Para cada nodo u, necesitamos encontrar el v\xe9rtice visitado m\xe1s temprano (el v\xe9rtice con el tiempo m\xednimo de descubrimiento) que se puede alcanzar desde el sub\xe1rbol enraizado con u. As\xed que mantenemos una matriz adicional baja [] que se define de la siguiente manera.\\n\\nlow [u] = min (disc [u], disc [w])\\ndonde w es un antepasado de u y hay una arista posterior de\\nalg\xfan descendiente de u a w.\\n","complejidad_tiempo":null,"java":"//Encontrando los puntos de articulaci\xf3n en un grafo no dirigido \\n\\nimport java.util.Iterator;\\nimport java.util.LinkedList;\\n\\n\\npublic class ArticulationBridges {\\n    // Esta clase representa un gr\xe1fico no dirigido \\n    // usando una lista de adyacencia\\n    static class Graph {\\n\\n        private int V; // No. de vertices \\n\\n        // array de listas para la representaci\xf3n de la adyacencia\\n        private LinkedList<Integer> adj[];\\n        int time = 0;\\n        static final int NIL = -1;\\n        Graph(int v) {\\n            V = v;\\n            adj = new LinkedList[v];\\n            for (int i = 0; i < v; ++i) {\\n                adj[i] = new LinkedList();\\n            }\\n        }\\n\\n        //Agregar caminos en el grafo\\n        void addEdge(int v, int w) {\\n            adj[v].add(w); \\n            adj[w].add(v); \\n        }\\n\\n        //Una funci\xf3n recursiva que encuentra puntos de articulaci\xf3n usando DFS\\n        //u -> El v\xe9rtice a visitar a continuaci\xf3n\\n        //visited [] -> mantiene un tramo de v\xe9rtices visitados\\n        //disc [] -> Almacena las veces de descubrimiento de los v\xe9rtices visitados\\n        //parent [] -> Almacena los v\xe9rtices principales en el \xe1rbol DFS\\n        //ap [] -> Almacenar puntos de articulaci\xf3n\\n        void APUtil(int u, boolean visited[], int disc[],\\n                int low[], int parent[], boolean ap[]) {\\n\\n            // conteo de hijos en el arbol de DFS\\n            int children = 0;\\n\\n            // Marcando el nodo actual como visitado\\n            visited[u] = true;\\n\\n            // Inicializar las veces de descubrimiento y el valor bajo\\n            disc[u] = low[u] = ++time;\\n\\n            // Pasa por todos los v\xe9rtices adyacentes a este\\n            Iterator<Integer> i = adj[u].iterator();\\n            while (i.hasNext()) {\\n                int v = i.next(); // v es adyacente de u \\n                //Si v a\xfan no se ha visitado, convi\xe9rtalo en hijo de u en el \\n                //\xe1rbol DFS y recurse para \xe9l\\n                if (!visited[v]) {\\n                    children++;\\n                    parent[v] = u;\\n                    APUtil(v, visited, disc, low, parent, ap);\\n\\n                    //Compruebe si el sub\xe1rbol enraizado con v \\n                    //tiene una conexi\xf3n con uno de los antepasados de u\\n                    low[u] = Math.min(low[u], low[v]);\\n\\n                    //u es un punto de articulaci\xf3n en los siguientes casos\\n                    //(1) u es la ra\xedz del \xe1rbol DFS y tiene dos o m\xe1s hijos.\\n                    if (parent[u] == NIL && children > 1) {\\n                        ap[u] = true;\\n                    }\\n\\n                    //(2) Si u no es ra\xedz y el valor bajo de uno de sus hijos es \\n                    //mayor que el valor de descubrimiento de u.\\n                    if (parent[u] != NIL && low[v] >= disc[u]) {\\n                        ap[u] = true;\\n                    }\\n                } // Actualice el valor bajo de u para las llamadas a funciones \\n                  // padre.\\n                else if (v != parent[u]) {\\n                    low[u] = Math.min(low[u], disc[v]);\\n                }\\n            }\\n        }\\n\\n        // La funci\xf3n para hacer un recorrido DFS. Utiliza la funci\xf3n recursiva APUtil ()\\n        void AP() {\\n            boolean visited[] = new boolean[V];\\n            int disc[] = new int[V];\\n            int low[] = new int[V];\\n            int parent[] = new int[V];\\n            boolean ap[] = new boolean[V]; // para almacenar los puntos \\n            //de articulaci\xf3n\\n\\n            // Inicializar matrices parent y \\n            //visited, y ap (punto de articulaci\xf3n)\\n            for (int i = 0; i < V; i++) {\\n                parent[i] = NIL;\\n                visited[i] = false;\\n                ap[i] = false;\\n            }\\n            //Llame a la funci\xf3n auxiliar recursiva para encontrar puntos de \\n            //articulaci\xf3n en el \xe1rbol DFS enraizado con el v\xe9rtice \'i\'\\n            for (int i = 0; i < V; i++) {\\n                if (visited[i] == false) {\\n                    APUtil(i, visited, disc, low, parent, ap);\\n                }\\n            }\\n\\n            // Ahora ap [] contiene puntos de articulaci\xf3n, impr\xedmalos\\n            for (int i = 0; i < V; i++) {\\n                if (ap[i] == true) {\\n                    System.out.print(i + \\" \\");\\n                }\\n            }\\n        }\\n    }\\n\\n    public static void main(String args[]) {\\n        System.out.println(\\"Puntos de articulaci\xf3n en el grafo \\");\\n        Graph g1 = new Graph(5);\\n        g1.addEdge(1, 0);\\n        g1.addEdge(0, 2);\\n        g1.addEdge(2, 1);\\n        g1.addEdge(0, 3);\\n        g1.addEdge(3, 4);\\n        g1.AP();\\n        System.out.println();\\n\\n        System.out.println(\\"Puntos de articulaci\xf3n en el grafo\\");\\n        Graph g2 = new Graph(4);\\n        g2.addEdge(0, 1);\\n        g2.addEdge(1, 2);\\n        g2.addEdge(2, 3);\\n        g2.AP();\\n        System.out.println();\\n\\n        System.out.println(\\"Puntos de articulaci\xf3n en el grafo \\");\\n        Graph g3 = new Graph(7);\\n        g3.addEdge(0, 1);\\n        g3.addEdge(1, 2);\\n        g3.addEdge(2, 0);\\n        g3.addEdge(1, 3);\\n        g3.addEdge(1, 4);\\n        g3.addEdge(1, 6);\\n        g3.addEdge(3, 5);\\n        g3.addEdge(4, 5);\\n        g3.AP();\\n    }\\n}\\n","cpp":"#include <cstdlib>\\n#include <bits/stdc++.h>\\n#define  MAX 105\\nusing namespace std;\\n\\nstruct Graph {\\n    int V;\\n    vector<int> adj[MAX];\\n    int time = 0;\\n    int NIL = -1;\\n\\n    void addEdge(int v, int w) {\\n        adj[v].emplace_back(w);\\n        adj[w].emplace_back(v);\\n    }\\n\\n    void APUtil(int u, bool visited[], int disc[],\\n            int low[], int parent[], bool ap[]) {\\n        static int time = 0;\\n        int children = 0;\\n        visited[u] = true;\\n        disc[u] = low[u] = ++time;\\n        for (int i = 0; i < adj[u].size(); i++) {\\n            int v = adj[u].at(i);\\n            if (!visited[v]) {\\n                children++;\\n                parent[v] = u;\\n                APUtil(v, visited, disc, low, parent, ap);\\n                low[u] = min(low[u], low[v]);\\n                if (parent[u] == NIL && children > 1)\\n                    ap[u] = true;\\n                if (parent[u] != NIL && low[v] >= disc[u])\\n                    ap[u] = true;\\n            } else if (v != parent[u])\\n                low[u] = min(low[u], disc[v]);\\n        }\\n    }\\n\\n    void AP() {\\n        bool visited[V];\\n        int disc[V];\\n        int low [V];\\n        int parent[V];\\n        bool ap[V];\\n        for (int i = 0; i < V; i++) {\\n            parent[i] = NIL;\\n            visited[i] = false;\\n            ap[i] = false;\\n        }\\n        for (int i = 0; i < V; i++)\\n            if (visited[i] == false)\\n                APUtil(i, visited, disc, low, parent, ap);\\n        for (int i = 0; i < V; i++)\\n            if (ap[i] == true)\\n                cout << i << \\" \\";\\n    }\\n\\n\\n};\\n\\nint main() {\\n    // Create graphs given in above diagrams \\n    cout << \\"Puntos de articulaci\xf3n en el grafo\\" << endl;\\n    Graph g1;\\n    g1.V = 5;\\n    g1.addEdge(1, 0);\\n    g1.addEdge(0, 2);\\n    g1.addEdge(2, 1);\\n    g1.addEdge(0, 3);\\n    g1.addEdge(3, 4);\\n    g1.AP();\\n    cout << endl;\\n\\n    cout << \\"Puntos de articulaci\xf3n en el grafo\\" << endl;\\n    Graph g2;\\n    g2.V = 4;\\n    g2.addEdge(0, 1);\\n    g2.addEdge(1, 2);\\n    g2.addEdge(2, 3);\\n    g2.AP();\\n    cout << endl;\\n\\n    cout << \\"Puntos de articulaci\xf3n en el grafo\\" << endl;\\n    Graph g3;\\n    g3.V=7;\\n    g3.addEdge(0, 1);\\n    g3.addEdge(1, 2);\\n    g3.addEdge(2, 0);\\n    g3.addEdge(1, 3);\\n    g3.addEdge(1, 4);\\n    g3.addEdge(1, 6);\\n    g3.addEdge(3, 5);\\n    g3.addEdge(4, 5);\\n    g3.AP();\\n}\\n","py":"from collections import defaultdict \\n\\nclass Graph: \\n        def __init__(self,vertices): \\n                self.V= vertices \\n                self.graph = defaultdict(list)\\n                self.Time = 0\\n        def addEdge(self,u,v): \\n                self.graph[u].append(v) \\n                self.graph[v].append(u) \\n        def APUtil(self,u, visited, ap, parent, low, disc): \\n                children =0\\n                visited[u]= True\\n                disc[u] = self.Time \\n                low[u] = self.Time \\n                self.Time += 1\\n                for v in self.graph[u]: \\n                        if visited[v] == False : \\n                                parent[v] = u \\n                                children += 1\\n                                self.APUtil(v, visited, ap, parent, low, disc) \\n                                low[u] = min(low[u], low[v]) \\n                                if parent[u] == -1 and children > 1: \\n                                        ap[u] = True\\n                                if parent[u] != -1 and low[v] >= disc[u]: \\n                                        ap[u] = True                     \\n                        elif v != parent[u]: \\n                                low[u] = min(low[u], disc[v]) \\n        def AP(self): \\n                visited = [False] * (self.V) \\n                disc = [float(\\"Inf\\")] * (self.V) \\n                low = [float(\\"Inf\\")] * (self.V) \\n                parent = [-1] * (self.V) \\n                ap = [False] * (self.V) \\n                for i in range(self.V): \\n                        if visited[i] == False: \\n                                self.APUtil(i, visited, ap, parent, low, disc) \\n                for index, value in enumerate (ap): \\n                        if value == True: print index, \\ng1 = Graph(5) \\ng1.addEdge(1, 0) \\ng1.addEdge(0, 2) \\ng1.addEdge(2, 1) \\ng1.addEdge(0, 3) \\ng1.addEdge(3, 4) \\nprint \\"Puntos de articulacion en el grafo \\"\\ng1.AP() \\ng2 = Graph(4) \\ng2.addEdge(0, 1) \\ng2.addEdge(1, 2) \\ng2.addEdge(2, 3) \\nprint \\"Puntos de articulacion en el grafo \\"\\ng2.AP() \\ng3 = Graph (7) \\ng3.addEdge(0, 1) \\ng3.addEdge(1, 2) \\ng3.addEdge(2, 0) \\ng3.addEdge(1, 3) \\ng3.addEdge(1, 4) \\ng3.addEdge(1, 6) \\ng3.addEdge(3, 5) \\ng3.addEdge(4, 5) \\nprint \\"Puntos de articulacion en el grafo \\"\\ng3.AP() \\n","orden":8,"suborden":28,"fecha_creacion":"2020-12-06 19:51:44","fecha_modificacion":"2022-03-08 12:28:52"},{"ID":225,"supergrupo":"Grafos","tema":"Puentes ","texto":"Una arista en un gr\xe1fico conectado no dirigido es un puente si, al eliminarlo, se desconecta el gr\xe1fico. Para un gr\xe1fico desconectado no dirigido, la definici\xf3n es similar, un puente es una eliminaci\xf3n de aristas que aumenta el n\xfamero de componentes desconectados.\\nAl igual que los puntos de articulaci\xf3n, los puentes representan vulnerabilidades en una red conectada y son \xfatiles para dise\xf1ar redes confiables. Por ejemplo, en una red de computadoras cableada, un punto de articulaci\xf3n indica las computadoras cr\xedticas y un puente indica los cables o conexiones cr\xedticas.\\nA continuaci\xf3n se muestran algunos gr\xe1ficos de ejemplo con puentes resaltados en color rojo.\\n\\n\xbfC\xf3mo encontrar todos los puentes en un gr\xe1fico dado?\\nUn enfoque simple es eliminar uno por uno todos las aristas y ver si la eliminaci\xf3n de una arista provoca un gr\xe1fico desconectado. Los siguientes son pasos de enfoque simple para gr\xe1ficos conectados.\\n1) Para cada arista (u, v), haga lo siguiente\\n\u2026 ..A) Eliminar (u, v) del gr\xe1fico\\n..\u2026 b) Vea si el gr\xe1fico permanece conectado (podemos usar BFS o DFS)\\n\u2026 ..C) Suma (u, v) de nuevo al gr\xe1fico.\\n\\nLa complejidad de tiempo del m\xe9todo anterior es O (E * (V + E)) para un gr\xe1fico representado usando una lista de adyacencia. \xbfPodemos hacerlo mejor?\\nUn algoritmo O (V + E) para encontrar todos los puentes\\nLa idea es similar al algoritmo O (V + E) para los puntos de articulaci\xf3n. Hacemos un recorrido DFS del gr\xe1fico dado. En el \xe1rbol DFS, una arista (u, v) (u es el padre de v en el \xe1rbol DFS) es puente si no existe ninguna otra alternativa para llegar a u o un ancestro de u del sub\xe1rbol enraizado con v, el valor low [v] indica el v\xe9rtice visitado m\xe1s temprano que se puede alcanzar desde el sub\xe1rbol enraizado con v. La condici\xf3n para que una arista (u, v) sea un puente es \\"low [v]> disc [u]\\".\\n","complejidad_tiempo":null,"java":"// buscando los puentes en un grafo\\n\\nimport java.util.Iterator;\\nimport java.util.LinkedList;\\n\\npublic class BridgesInGraph {\\n\\n    static private int V; // No. de vertices \\n\\n    // Array de listas representando el grafo\\n    static private LinkedList<Integer> adj[];\\n    static int time = 0;\\n    static final int NIL = -1;\\n\\n    static void init(int v) {\\n        V = v;\\n        adj = new LinkedList[v];\\n        for (int i = 0; i < v; ++i) {\\n            adj[i] = new LinkedList();\\n        }\\n    }\\n\\n    // Agregando caminos en el grafo\\n    static void addEdge(int v, int w) {\\n        adj[v].add(w);\\n        adj[w].add(v);\\n    }\\n\\n    // Una funci\xf3n recursiva que busca e imprime puentes\\n    // usando DFS transversal\\n    // u -> El v\xe9rtice a visitar a continuaci\xf3n\\n    // visited [] -> mantiene un tramo de v\xe9rtices visitados\\n    // disc [] -> Almacena las veces de descubrimiento de los v\xe9rtices visitados\\n    // parent [] -> Almacena los v\xe9rtices padre en el \xe1rbol DFS\\n    static void bridgeUtil(int u, boolean visited[], int disc[],\\n            int low[], int parent[]) {\\n        // Marcar nodo actual como visitado\\n        visited[u] = true;\\n        // Inicializar el tiempo de descubrimiento y el valor bajo\\n        disc[u] = low[u] = ++time;\\n\\n        // Pasa por todos los v\xe9rtices adyacentes a este\\n        Iterator<Integer> i = adj[u].iterator();\\n        while (i.hasNext()) {\\n            int v = i.next(); // v es la corriente adyacente a u\\n\\n            // Si v a\xfan no se ha visitado, convi\xe9rtalo en hijo\\n            // de u en el \xe1rbol DFS y recurra en el.\\n            // Si v a\xfan no se ha visitado, repita para ello\\n            if (!visited[v]) {\\n                parent[v] = u;\\n                bridgeUtil(v, visited, disc, low, parent);\\n\\n                //Compruebe si el sub\xe1rbol enraizado con v tiene \\n                //una conexi\xf3n con uno de los antepasados de u\\n                low[u] = Math.min(low[u], low[v]);\\n\\n                //Si el v\xe9rtice m\xe1s bajo accesible desde el sub\xe1rbol \\n                //debajo de v est\xe1 debajo de u en el \xe1rbol DFS, \\n                //entonces u-v es un puente\\n                if (low[v] > disc[u]) {\\n                    System.out.println(u + \\" \\" + v);\\n                }\\n            } // Actualice el valor bajo de u para las llamadas a funciones principales. \\n            else if (v != parent[u]) {\\n                low[u] = Math.min(low[u], disc[v]);\\n            }\\n        }\\n    }\\n\\n    // Funci\xf3n basada en DFS para encontrar todos los puentes. \\n    // Utiliza la funci\xf3n recursiva bridgeUtil ()\\n    static void bridge() {\\n        // Marcar todos los v\xe9rtices como no visitados\\n        boolean visited[] = new boolean[V];\\n        int disc[] = new int[V];\\n        int low[] = new int[V];\\n        int parent[] = new int[V];\\n\\n        // Inicializa parent, visited, y ap(articulation point)\\n        for (int i = 0; i < V; i++) {\\n            parent[i] = NIL;\\n            visited[i] = false;\\n        }\\n\\n        //Llame a la funci\xf3n auxiliar recursiva para encontrar \\n        //puentes en el \xe1rbol DFS enraizado con el v\xe9rtice \'i\'\\n        for (int i = 0; i < V; i++) {\\n            if (visited[i] == false) {\\n                bridgeUtil(i, visited, disc, low, parent);\\n            }\\n        }\\n    }\\n\\n    public static void main(String args[]) {\\n        System.out.println(\\"Bridges in first graph \\");\\n        init(5);\\n        addEdge(1, 0);\\n        addEdge(0, 2);\\n        addEdge(2, 1);\\n        addEdge(0, 3);\\n        addEdge(3, 4);\\n        bridge();\\n        System.out.println();\\n        System.out.println(\\"Bridges in second graph \\");\\n        init(4);\\n        addEdge(0, 1);\\n        addEdge(1, 2);\\n        addEdge(2, 3);\\n        bridge();\\n        System.out.println();\\n\\n    }\\n}\\n","cpp":"#include<iostream> \\n#include <list> \\n#define NIL -1 \\n#define MAX 10000\\nusing namespace std;\\n\\nstruct Graph {\\n    int V;\\n    list<int> adj[MAX];\\n\\n    void addEdge(int v, int w) {\\n        adj[v].push_back(w);\\n        adj[w].push_back(v);\\n    }\\n\\n    void bridgeUtil(int u, bool visited[], int disc[],\\n            int low[], int parent[]) {\\n        static int time = 0;\\n        visited[u] = true;\\n        disc[u] = low[u] = ++time;\\n        list<int>::iterator i;\\n        for (i = adj[u].begin(); i != adj[u].end(); ++i) {\\n            int v = *i;\\n            if (!visited[v]) {\\n                parent[v] = u;\\n                bridgeUtil(v, visited, disc, low, parent);\\n                low[u] = min(low[u], low[v]);\\n                if (low[v] > disc[u])\\n                    cout << u << \\" \\" << v << endl;\\n            } else if (v != parent[u])\\n                low[u] = min(low[u], disc[v]);\\n        }\\n    }\\n\\n    void bridge() {\\n        bool visited[V];\\n        int disc [V];\\n        int low [V];\\n        int parent[V];\\n\\n        for (int i = 0; i < V; i++) {\\n            parent[i] = NIL;\\n            visited[i] = false;\\n        }\\n        for (int i = 0; i < V; i++)\\n            if (visited[i] == false)\\n                bridgeUtil(i, visited, disc, low, parent);\\n    }\\n};\\n\\nint main() {\\n    cout << \\"\\\\nBridges in first graph \\\\n\\";\\n    Graph g1;\\n    g1.V = 5;\\n    g1.addEdge(1, 0);\\n    g1.addEdge(0, 2);\\n    g1.addEdge(2, 1);\\n    g1.addEdge(0, 3);\\n    g1.addEdge(3, 4);\\n    g1.bridge();\\n\\n    cout << \\"\\\\nBridges in second graph \\\\n\\";\\n    Graph g2;\\n    g2.V = 2;\\n    g2.addEdge(0, 1);\\n    g2.addEdge(1, 2);\\n    g2.addEdge(2, 3);\\n    g2.bridge();\\n}\\n","py":"from collections import defaultdict\\n \\nclass Graph: \\n\\n    def __init__(self, vertices): \\n        self.V = vertices \\n        self.graph = defaultdict(list) \\n        self.Time = 0\\n    def addEdge(self, u, v): \\n        self.graph[u].append(v) \\n        self.graph[v].append(u) \\n\\n    def bridgeUtil(self, u, visited, parent, low, disc): \\n        visited[u] = True\\n        disc[u] = self.Time \\n        low[u] = self.Time \\n        self.Time += 1\\n        for v in self.graph[u]: \\n            if visited[v] == False: \\n                parent[v] = u \\n                self.bridgeUtil(v, visited, parent, low, disc) \\n                low[u] = min(low[u], low[v]) \\n                if low[v] > disc[u]: \\n                    print (\\"%d %d\\" % (u, v)) \\n                \\n            elif v != parent[u]: \\n                low[u] = min(low[u], disc[v]) \\n\\n    def bridge(self): \\n        visited = [False] * (self.V) \\n        disc = [float(\\"Inf\\")] * (self.V) \\n        low = [float(\\"Inf\\")] * (self.V) \\n        parent = [-1] * (self.V) \\n\\n        for i in range(self.V): \\n            if visited[i] == False: \\n                self.bridgeUtil(i, visited, parent, low, disc) \\n\\ng1 = Graph(5) \\ng1.addEdge(1, 0) \\ng1.addEdge(0, 2) \\ng1.addEdge(2, 1) \\ng1.addEdge(0, 3) \\ng1.addEdge(3, 4) \\n\\n\\nprint \\"Bridges in first graph \\"\\ng1.bridge() \\n\\ng2 = Graph(4) \\ng2.addEdge(0, 1) \\ng2.addEdge(1, 2) \\ng2.addEdge(2, 3) \\nprint \\"\\\\nBridges in second graph \\"\\ng2.bridge() \\n","orden":8,"suborden":29,"fecha_creacion":"2020-12-06 19:51:44","fecha_modificacion":"2022-03-08 12:28:52"},{"ID":226,"supergrupo":"Grafos","tema":"Combinatorias en arboles ordenados","texto":"Un \xe1rbol ordenado es un \xe1rbol orientado en el que los hijos de un nodo est\xe1n ordenados de alguna manera. Es un \xe1rbol enraizado en el que se especifica un orden para los hijos de cada v\xe9rtice. A esto se le llama \u201c\xe1rbol plano\u201d porque ordenar los hijos equivale a incrustar el \xe1rbol en el plano, con la ra\xedz en la parte superior y los hijos de cada v\xe9rtice m\xe1s abajo que ese v\xe9rtice.\\nEl \xe1rbol ordenado se puede especificar m\xe1s como \xe1rbol ordenado etiquetado y \xe1rbol ordenado no etiquetado.\\n\xc1rboles ordenados etiquetados: un \xe1rbol etiquetado es un \xe1rbol donde a cada v\xe9rtice se le asigna un n\xfamero \xfanico de 1 a n.\\n \\nSi T1 y T2 son \xe1rboles ordenados. Entonces, T1! = T2 de lo contrario T1 = T2.\\n\\n\xc1rboles ordenados sin etiquetar: un \xe1rbol sin etiquetar es un \xe1rbol en el que cada v\xe9rtice no est\xe1 etiquetado. A continuaci\xf3n se muestran los posibles \xe1rboles ordenados sin etiquetar que tienen 3 v\xe9rtices.\\n","complejidad_tiempo":null,"java":"// c\xf3digo java para encontrar el n\xfamero de \\n//\xe1rboles ordenados con un n\xfamero determinado \\n//de bordes y hojas\\n\\npublic class CombinatoricsOnOrderedTrees {\\n\\n    // La funci\xf3n devuelve el valor del\\n    // Coeficiente binomial C (n, k)\\n    static int binomialCoeff(int n, int k) {\\n        int[][] C = new int[n + 1][k + 1];\\n        int i, j;\\n        // Calculate value of Binomial \\n        // Coefficient in bottom up manner \\n        for (i = 0; i <= n; i++) {\\n            for (j = 0; j <= Math.min(i, k); j++) {\\n                if (j == 0 || j == i) {\\n                    C[i][j] = 1;\\n                } // Calcular valor usando valores previamente almacenados\\n                else {\\n                    C[i][j] = C[i - 1][j - 1]\\n                            + C[i - 1][j];\\n                }\\n            }\\n        }\\n        return C[n][k];\\n    }\\n\\n    // Funci\xf3n para calcular el n\xfamero\\n    // de \xe1rboles con exactamente k hojas.\\n    static int k_Leaves(int n, int k) {\\n        int ans = (binomialCoeff(n, k)\\n                * binomialCoeff(n, k - 1)) / n;\\n        System.out.println(\\"Number of trees \\"\\n                + \\"having 4 edges and exactly 2 \\"\\n                + \\"leaves : \\" + ans);\\n        return 0;\\n    }\\n\\n    // Funci\xf3n para calcular el n\xfamero total de\\n    // nodos de grado d en estos \xe1rboles.\\n    static int numberOfNodes(int n, int d) {\\n        int ans = binomialCoeff(2 * n - 1 - d,\\n                n - 1);\\n        System.out.println(\\"Number of nodes \\"\\n                + \\"of degree 1 in a tree having 4 \\"\\n                + \\"edges : \\" + ans);\\n        return 0;\\n    }\\n\\n    // Funci\xf3n para calcular el n\xfamero de\\n    // \xe1rboles en los que la ra\xedz tiene grado r.\\n    static int rootDegreeR(int n, int r) {\\n        int ans = r * binomialCoeff(2 * n\\n                - 1 - r, n - 1);\\n        ans = ans / n;\\n        System.out.println(\\"Number of trees \\"\\n                + \\"having 4 edges where root has\\"\\n                + \\" degree 2 : \\" + ans);\\n        return 0;\\n    }\\n\\n    public static void main(String[] args) {\\n        // N\xfamero de \xe1rboles que tienen 3\\n        // caminos y exactamente 2 hojas\\n        k_Leaves(3, 2);\\n        // N\xfamero de nodos de grado\\n        // 3 en un \xe1rbol que tiene 4 caminos\\n        numberOfNodes(3, 1);\\n        // N\xfamero de \xe1rboles que tienen 3\\n        // caminos donde la ra\xedz tiene grado 2\\n        rootDegreeR(3, 2);\\n    }\\n}\\n","cpp":"#include<bits/stdc++.h> \\n#include<cstdlib>\\nusing namespace std;\\n\\nint binomialCoeff(int n, int k) {\\n    int C [n + 1][k + 1] = {0};\\n    int i, j;\\n    for (i = 0; i <= n; i++) {\\n        for (j = 0; j <= min(i, k); j++) {\\n            if (j == 0 || j == i) {\\n                C[i][j] = 1;\\n            } else {\\n                C[i][j] = C[i - 1][j - 1] + C[i - 1][j];\\n            }\\n        }\\n    }\\n    return C[n][k];\\n}\\n\\nstatic int k_Leaves(int n, int k) {\\n    int ans = (binomialCoeff(n, k)\\n            * binomialCoeff(n, k - 1)) / n;\\n    cout << \\"Number of trees having 4 edges and exactly 2 leaves : \\"\\n            << ans << endl;\\n    return 0;\\n}\\n\\nstatic int numberOfNodes(int n, int d) {\\n    int ans = binomialCoeff(2 * n - 1 - d, n - 1);\\n    cout << \\"Number of nodes of degree 1 in a tree having 4 edges : \\"\\n            << ans << endl;\\n    return 0;\\n}\\n\\nstatic int rootDegreeR(int n, int r) {\\n    int ans = r * binomialCoeff(2 * n\\n            - 1 - r, n - 1);\\n    ans = ans / n;\\n    cout << \\"Number of trees having 4 edges where root has degree 2 : \\"\\n            << ans << endl;\\n    return 0;\\n}\\n\\nint main() {\\n    k_Leaves(3, 2);\\n    numberOfNodes(3, 1);\\n    rootDegreeR(3, 2);\\n}\\n","py":"import math\\ndef binomialCoeff(n, k):\\n    C = [[0 for i in range(k + 1)] for i in range (n + 1)]\\n    for i in range (n + 1):\\n        aux = min(i, k)\\n        for j in range (aux + 1):\\n            if (j == 0 or j == i):\\n                C[i][j] = 1\\n            else:\\n                C[i][j] = C[i - 1][j - 1] + C[i - 1][j];\\n    return C[n][k];\\n\\ndef k_Leaves(n, k):\\n    ans = (binomialCoeff(n, k) * binomialCoeff(n, k - 1)) / n\\n    print(\\"Number of trees having 4 edges and exactly 2 leaves : \\" + str(ans))\\n\\ndef numberOfNodes(n, d):\\n    ans = binomialCoeff(2 * n - 1 - d, n - 1);\\n    print(\\"Number of nodes of degree 1 in a tree having 4 edges : \\" + str(ans))\\n\\ndef rootDegreeR(n, r):\\n    ans = r * binomialCoeff(2 * n- 1 - r, n - 1)\\n    ans = ans / n\\n    print(\\"Number of trees having 4 edges where root has degree 2 : \\" + str(ans))\\n\\nk_Leaves(3, 2); \\nnumberOfNodes(3, 1); \\nrootDegreeR(3, 2);\\n","orden":8,"suborden":30,"fecha_creacion":"2020-12-06 19:51:44","fecha_modificacion":"2022-03-08 12:28:52"},{"ID":227,"supergrupo":"Grafos","tema":"Conjuntos disjuntos","texto":"Considere una situaci\xf3n con varias personas y las siguientes tareas que se realizar\xe1n en ellas.\\n1. Agregue una nueva relaci\xf3n de amistad, es decir, una persona x se convierte en amiga de otra persona y.\\n2. Encuentre si el individuo x es amigo del individuo y (amigo directo o indirecto)\\nEjemplo:\\nNos dan 10 personas que dicen:\\na, b, c, d, e, f, g, h, yo, j\\n\\nA continuaci\xf3n se muestran las relaciones que se agregar\xe1n.\\na <-> b\\nb <-> d\\nc <-> f\\nc <-> i\\nj <-> e\\ng <-> j\\nY dadas consultas como si a es amigo de d o no.\\nB\xe1sicamente, necesitamos crear los siguientes 4 grupos y mantener una conexi\xf3n de acceso r\xe1pido entre los elementos del grupo:\\nG1 = {a, b, d}\\nG2 = {c, f, i}\\nG3 = {e, g, j}\\nG4 = {h}\\nProblema: Encontrar si xey pertenecen al mismo grupo o no, es decir, encontrar si xey son amigos directos / indirectos.\\nSoluci\xf3n: dividir a los individuos en diferentes conjuntos de acuerdo con los grupos en los que se encuentran. Este m\xe9todo se conoce como estructura de datos de conjuntos disjuntos que mantiene la colecci\xf3n de conjuntos disjuntos y cada conjunto est\xe1 representado por su representante, que es uno de sus miembros.\\nAproximaci\xf3n:\\n\u2022 \xbfC\xf3mo resolver conjuntos? Inicialmente, todos los elementos pertenecen a conjuntos diferentes. Despu\xe9s de trabajar en las relaciones dadas, seleccionamos a un miembro como representante. Puede haber muchas formas de seleccionar un representante, una simple es seleccionar con el \xedndice m\xe1s grande.\\n\u2022 \xbfCompruebe si hay 2 personas en el mismo grupo? Si los representantes de dos personas son iguales, se har\xe1n amigos.\\n \\nEstructuras de datos utilizadas:\\nArray: una array de enteros, denominada padre []. Si estamos tratando con n elementos, el elemento i de la array representa el elemento i. M\xe1s precisamente, el i-\xe9simo elemento de la array es el padre del i-\xe9simo elemento. Estas relaciones crean uno o m\xe1s \xe1rboles virtuales.\\n\xc1rbol: es un conjunto disjunto. Si dos elementos est\xe1n en el mismo \xe1rbol, entonces est\xe1n en el mismo conjunto disjunto. El nodo ra\xedz (o el nodo m\xe1s alto) de cada \xe1rbol se denomina representante del conjunto. Siempre hay un \xfanico representante de cada conjunto. Una regla simple para identificar al representante es, si i es el representante de un conjunto, entonces padre [i] = i. Si yo no es el representante de su conjunto, entonces se puede encontrar viajando por el \xe1rbol hasta que encontremos al representante.\\n \\nOperaciones:\\nBuscar: se puede implementar atravesando recursivamente la array principal hasta que lleguemos a un nodo que es padre de s\xed mismo.\\n// Encuentra al representante del conjunto\\n// que yo es un elemento de\\nint encontrar (int i)\\n{\\n    // Si i es el padre de s\xed mismo\\n    si (padre [i] == i)\\n    {\\n        // Entonces yo es el representante de\\n        // este conjunto\\n        volver i;\\n    }\\n    m\xe1s\\n    {\\n        // De lo contrario, si yo no es el padre de\\n        // en s\xed mismo, entonces yo no es el\\n        // representante de su conjunto. As\xed que nosotros\\n        // llama recursivamente Find en su padre\\n        return find (padre [i]);\\n    }\\n}\\nUni\xf3n: Toma como insumo dos elementos. Y encuentra los representantes de sus conjuntos usando la operaci\xf3n de b\xfasqueda, y finalmente coloca uno de los \xe1rboles (que representa el conjunto) debajo del nodo ra\xedz del otro \xe1rbol, fusionando efectivamente los \xe1rboles y los conjuntos.\\n// Une el conjunto que incluye i\\n// y el conjunto que incluye j\\nuni\xf3n vac\xeda (int i, int j)\\n{\\n    // Encuentra los representantes\\n    // (o los nodos ra\xedz) para el conjunto\\n    // eso incluye i\\n    \\n    int irep = this.Find (i),\\n\\n    // Y haz lo mismo con el set\\n    // eso incluye j\\n    int jrep = this.Find (j);\\n\\n    // Hacer el padre del representante de i\\n    // ser el representante de j de forma eficaz\\n    // moviendo todo el conjunto de i al conjunto de j)\\n    this.Parent [irep] = jrep;\\n}\\nMejoras (uni\xf3n por rango y compresi\xf3n de ruta)\\nLa eficiencia depende en gran medida de la altura del \xe1rbol. Necesitamos minimizar la altura del \xe1rbol para mejorar la eficiencia. Podemos usar Path Compression y Union por m\xe9todos de rango para hacerlo.\\nCompresi\xf3n de ruta (modificaciones para encontrar ()): acelera la estructura de datos al comprimir la altura de los \xe1rboles. Se puede lograr insertando un peque\xf1o mecanismo de almacenamiento en cach\xe9 en la operaci\xf3n de b\xfasqueda. Eche un vistazo al c\xf3digo para obtener m\xe1s detalles:\\n// Encuentra el representante del conjunto que yo\\n// es un elemento de.\\nint encontrar (int i)\\n{\\n    // Si i es el padre de s\xed mismo\\n    si (Padre [i] == i)\\n    {\\n        // Entonces yo soy el representante\\n        volver i;\\n    }\\n    m\xe1s\\n    {\\n        // Encontrar al representante de forma recursiva.\\n        int resultado = buscar (Padre [i]);\\n\\n        // Almacenamos en cach\xe9 el resultado moviendo el nodo i\\n        // directamente bajo el representante de este\\n        // establecer\\n        Padre [i] = resultado;\\n       \\n        // Y luego devolvemos el resultado\\n        devolver resultado;\\n     }\\n}\\nUni\xf3n por rango: En primer lugar, necesitamos una nueva array de n\xfameros enteros llamada rango []. El tama\xf1o de esta array es el mismo que el de la array principal. Si i es un representante de un conjunto, el rango [i] es la altura del \xe1rbol que representa el conjunto.\\n\\nAhora recuerde que, en la operaci\xf3n Union, no importa cu\xe1l de los dos \xe1rboles se mueva debajo del otro (vea los dos \xfaltimos ejemplos de im\xe1genes arriba). Ahora lo que queremos hacer es minimizar la altura del \xe1rbol resultante. Si estamos uniendo dos \xe1rboles (o conjuntos), llam\xe9moslos izquierda y derecha, entonces todo depende del rango de la izquierda y el rango de la derecha.\\n\u2022 Si el rango de la izquierda es menor que el rango de la derecha, entonces es mejor moverse hacia la izquierda debajo de la derecha, porque eso no cambiar\xe1 el rango de la derecha (mientras que moverse hacia la derecha debajo de la izquierda aumentar\xeda la altura). De la misma manera, si el rango de la derecha es menor que el rango de la izquierda, entonces debemos movernos a la derecha debajo de la izquierda.\\n\u2022 Si los rangos son iguales, no importa qu\xe9 \xe1rbol va debajo del otro, pero el rango del resultado siempre ser\xe1 uno mayor que el rango de los \xe1rboles.\\n// Une el conjunto que incluye i y el conjunto\\n// eso incluye j\\nuni\xf3n vac\xeda (int i, int j)\\n{\\n    // Encuentra los representantes (o los nodos ra\xedz)\\n    // para el conjunto que incluye i\\n    int irep = this.find (i);\\n\\n    // Y haz lo mismo con el conjunto que incluye j\\n    int jrep = this.Find (j);\\n\\n    // Los elementos est\xe1n en el mismo conjunto, no es necesario\\n    // unir cualquier cosa.\\n    si (irep == jrep)\\n        regreso;\\n\\n    // Obtener el rango del \xe1rbol de i\\n    irank = Rango [irep],\\n\\n    // Obtener el rango del \xe1rbol de j\\n    jrank = Rango [jrep];\\n\\n    // Si el rango de i es menor que el rango de j\\n    si (irank <bromeo)\\n    {\\n        // Luego mueve i debajo de j\\n        this.parent [irep] = jrep;\\n    }\\n\\n    // De lo contrario, si el rango de j es menor que el rango de i\\n    m\xe1s si (broma <irank)\\n    {\\n        // Luego mueve j debajo de i\\n        this.Parent [jrep] = irep;\\n    }\\n\\n    // De lo contrario, si sus rangos son los mismos\\n    m\xe1s\\n    {\\n\\n        // Luego mueve i debajo de j (no importa\\n        // cual va donde)\\n        this.Parent [irep] = jrep;\\n\\n        // E incrementa el \xe1rbol de resultados\\n        // clasificar por 1\\n        Rango [jrep] ++;\\n    }\\n}\\n","complejidad_tiempo":null,"java":"//Estructura de datos para modelar \\n//una colecci\xf3n de conjuntos disyuntos.\\n//Permite determinar de manera eficiente \\n//a que conjunto pertenece un elemento,\\n//si dos elementos se encuentran en un mismo \\n//conjunto y unir dos conjuntos disyuntos en un uno.\\n\\npublic class DisjointSet {\\n\\n    static class DisjointUnionSets {\\n\\n        int[] rank, parent;\\n        int n;\\n\\n        public DisjointUnionSets(int n) {\\n            rank = new int[n];\\n            parent = new int[n];\\n            this.n = n;\\n            makeSet();\\n        }\\n\\n        // Crea n conjuntos con un solo elemento en cada uno\\n        void makeSet() {\\n            for (int i = 0; i < n; i++) {\\n                // Inicialmente, todos los elementos est\xe1n en su propio conjunto.\\n                parent[i] = i;\\n            }\\n        }\\n\\n        // Devuelve representativo del conjunto de x\\n        int find(int x) {\\n            // Encuentra el representante del conjunto del que x es un elemento de\\n            if (parent[x] != x) {\\n                // si x no es el padre de s\xed mismo Entonces \\n                // x no es el representante de su conjunto,\\n                parent[x] = find(parent[x]);\\n                // entonces llamamos recursivamente Find en su padre y movemos \\n                // el nodo de i directamente debajo del \\n                // representante de este conjunto\\n            }\\n\\n            return parent[x];\\n        }\\n\\n        // Une el conjunto que incluye x y el conjunto que incluye x\\n        void union(int x, int y) {\\n            // Encuentra representantes de dos conjuntos\\n            int xRoot = find(x), yRoot = find(y);\\n            // Los elementos est\xe1n en el mismo conjunto, no es necesario unir nada.\\n            if (xRoot == yRoot) {\\n                return;\\n            }\\n\\n            // Si el rango de x es menor que el rango de y\\n            if (rank[xRoot] < rank[yRoot]) // Luego mueva y debajo de x \\n            //para que la profundidad del \xe1rbol permanezca menor\\n            {\\n                parent[xRoot] = yRoot;\\n            } // De lo contrario, si el rango de y es menor que el rango de x\\n            else if (rank[yRoot] < rank[xRoot]) // Luego mueva y debajo de x \\n            //para que la profundidad del \xe1rbol permanezca menor\\n            {\\n                parent[yRoot] = xRoot;\\n            } else // si los rangos son los mismos\\n            {\\n                // Luego mueva y debajo de x (no importa cu\xe1l vaya a d\xf3nde)\\n                parent[yRoot] = xRoot;\\n                // E incrementar el rango del \xe1rbol de resultados en 1\\n                rank[xRoot] = rank[xRoot] + 1;\\n            }\\n        }\\n    }\\n\\n    public static void main(String[] args) {\\n        // Sea 5 personas con identificadores como 0, 1, 2, 3 y 4\\n        int n = 5;\\n        DisjointUnionSets dus\\n                = new DisjointUnionSets(n);\\n\\n        // 0 es amigo de 2\\n        dus.union(0, 2);\\n\\n        // 4 es amigo de 2\\n        dus.union(4, 2);\\n\\n        // 3 es amigo de 1\\n        dus.union(3, 1);\\n\\n        // Verifica si 4 es amigo de 0\\n        if (dus.find(4) == dus.find(0)) {\\n            System.out.println(\\"Yes\\");\\n        } else {\\n            System.out.println(\\"No\\");\\n        }\\n\\n        // Verifica si 1 es amigo de 0\\n        if (dus.find(1) == dus.find(0)) {\\n            System.out.println(\\"Yes\\");\\n        } else {\\n            System.out.println(\\"No\\");\\n        }\\n    }\\n}\\n","cpp":"#include <iostream> \\n#define MAX 105\\nusing namespace std;\\n\\nstruct DisjSet {\\n    int rank[MAX], parent[MAX], n;\\n\\n    DisjSet(int n) {\\n        this->n = n;\\n        makeSet();\\n    }\\n\\n    void makeSet() {\\n        for (int i = 0; i < n; i++) {\\n            parent[i] = i;\\n        }\\n    }\\n\\n    int find(int x) {\\n        if (parent[x] != x) {\\n            parent[x] = find(parent[x]);\\n        }\\n        return parent[x];\\n    }\\n\\n    void Union(int x, int y) {\\n        int xset = find(x);\\n        int yset = find(y);\\n        if (xset == yset)\\n            return;\\n        if (rank[xset] < rank[yset]) {\\n            parent[xset] = yset;\\n        } else if (rank[xset] > rank[yset]) {\\n            parent[yset] = xset;\\n        } else {\\n            parent[yset] = xset;\\n            rank[xset] = rank[xset] + 1;\\n        }\\n    }\\n};\\n\\nint main() {\\n    DisjSet obj(5);\\n    obj.Union(0, 2);\\n    obj.Union(4, 2);\\n    obj.Union(3, 1);\\n    if (obj.find(4) == obj.find(0))\\n        cout << \\"Yes\\\\n\\";\\n    else\\n        cout << \\"No\\\\n\\";\\n    if (obj.find(1) == obj.find(0))\\n        cout << \\"Yes\\\\n\\";\\n    else\\n        cout << \\"No\\\\n\\";\\n\\n    return 0;\\n}\\n","py":"class DisjSet: \\n    def __init__(self, n): \\n        self.rank = [1] * n \\n        self.parent = [i for i in range(n)] \\n    def find(self, x):  \\n        if (self.parent[x] != x): \\n            self.parent[x] = self.find(self.parent[x]) \\n\\n        return self.parent[x] \\n    def Union(self, x, y): \\n        xset = self.find(x) \\n        yset = self.find(y) \\n        if xset == yset: \\n            return\\n        if self.rank[xset] < self.rank[yset]: \\n            self.parent[xset] = yset \\n        elif self.rank[xset] > self.rank[yset]: \\n            self.parent[yset] = xset \\n        else: \\n            self.parent[yset] = xset \\n            self.rank[xset] = self.rank[xset] + 1\\n\\n\\nobj = DisjSet(5) \\nobj.Union(0, 2) \\nobj.Union(4, 2) \\nobj.Union(3, 1) \\nif obj.find(4) == obj.find(0): \\n    print(\'Yes\') \\nelse: \\n    print(\'No\') \\nif obj.find(1) == obj.find(0): \\n    print(\'Yes\') \\nelse: \\n    print(\'No\') \\n","orden":8,"suborden":31,"fecha_creacion":"2020-12-06 19:51:45","fecha_modificacion":"2022-03-08 12:28:52"},{"ID":228,"supergrupo":"Grafos","tema":"Union de conjuntos disjuntos en un \xe1rbol ","texto":"Dado un \xe1rbol y pesos de nodos. Los pesos son n\xfameros enteros no negativos. La tarea consiste en encontrar el tama\xf1o m\xe1ximo de un sub\xe1rbol de un \xe1rbol dado, de modo que todos los nodos tengan pesos iguales.\\n\\nEjemplos:\\n \\nEntrada: N\xfamero de nodos = 7\\n        Pesos de los nodos = 1 2 6 4 2 0 3\\n        aristas = (1, 2), (1, 3), (2, 4),\\n                (2, 5), (4, 6), (6, 7)\\nSalida: tama\xf1o m\xe1ximo del sub\xe1rbol\\ncon nodos ponderados pares = 4\\nExplicacion:\\nEl sub\xe1rbol de nodos {2, 4, 5, 6} da el tama\xf1o m\xe1ximo.\\n\\nEntrada: N\xfamero de nodos = 6\\n        Pesos de los nodos = 2 4 0 2 2 6\\n        aristass = (1, 2), (2, 3), (3, 4),\\n                (4, 5), (1, 6)\\nSalida: tama\xf1o m\xe1ximo del sub\xe1rbol\\ncon nodos ponderados pares = 6\\nExplicacion:\\nEl \xe1rbol dado da el tama\xf1o m\xe1ximo.\\n \\nEnfoque: podemos encontrar una soluci\xf3n simplemente ejecutando DFS en el \xe1rbol. La soluci\xf3n DFS nos da la respuesta en O (n). Pero, \xbfc\xf3mo podemos usar DSU para este problema? Primero iteramos a trav\xe9s de todos las aristas. Si ambos nodos son pares en pesos, hacemos una uni\xf3n de ellos. El conjunto de nodos con tama\xf1o m\xe1ximo es la respuesta. Si usamos union-find con compresi\xf3n de ruta, la complejidad del tiempo es O (n).\\n","complejidad_tiempo":null,"java":"// C\xf3digo Java para encontrar el sub\xe1rbol m\xe1ximo de \\n// modo que todos los nodos tengan un peso par\\n\\npublic class DisjoinSetUnionTree {\\n\\n    static final int N = 100010;\\n\\n    // Estructura para camino\\n    static class Edge {\\n\\n        int u, v;\\n\\n        public Edge(int u, int v) {\\n            this.u = u;\\n            this.v = v;\\n        }\\n    }\\n\\n    /* \'id\': almacena el padre de un nodo.\\n     \'sz\': almacena el tama\xf1o de un \xe1rbol DSU. */\\n    static int[] id = new int[N];\\n    static int[] sz = new int[N];\\n\\n    // Funci\xf3n para asignar root\\n    static int Root(int idx) {\\n        int i = idx;\\n        while (i != id[i]) {\\n            id[i] = id[id[i]];\\n            i = id[i];\\n        }\\n        return i;\\n    }\\n\\n    // Funci\xf3n para encontrar Uni\xf3n\\n    static void Union(int a, int b) {\\n        int i = Root(a), j = Root(b);\\n        if (i != j) {\\n            if (sz[i] >= sz[j]) {\\n                id[j] = i;\\n                sz[i] += sz[j];\\n                sz[j] = 0;\\n            } else {\\n                id[i] = j;\\n                sz[j] += sz[i];\\n                sz[i] = 0;\\n            }\\n        }\\n    }\\n\\n    // Funci\xf3n de utilidad para Union\\n    static void UnionUtil(Edge e[], int W[], int q) {\\n        for (int i = 0; i < q; i++) {\\n            // Camino entre \'u\' y \'v\'\\n            int u, v;\\n            u = e[i].u;\\n            v = e[i].v;\\n            u--;\\n            v--;\\n\\n            // Si los pesos de \'u\' y \'v\' son pares, los unimos.\\n            if (W[u] % 2 == 0 && W[v] % 2 == 0) {\\n                Union(u, v);\\n            }\\n        }\\n    }\\n\\n    // Funci\xf3n para encontrar el tama\xf1o m\xe1ximo del \xe1rbol DSU\\n    static int findMax(int n, int W[]) {\\n        int maxi = 0;\\n        for (int i = 1; i < n; i++) {\\n            if (W[i] % 2 == 0) {\\n                maxi = Math.max(maxi, sz[i]);\\n            }\\n        }\\n        return maxi;\\n    }\\n\\n    public static void main(String[] args) {\\n        /* \\n        Los nodos est\xe1n indexados en 0 en este c\xf3digo, \\n        por lo que tenemos que hacer los cambios \\n        necesarios mientras tomamos entradas\\n         */\\n        // Pesos de nodos\\n        int W[] = {1, 2, 6, 4, 2, 0, 3};\\n\\n        // N\xfamero de nodos en un \xe1rbol\\n        int n = W.length;\\n\\n        // Inicializando cada nodo como un \xe1rbol con un solo nodo.\\n        for (int i = 0; i < n; i++) {\\n            id[i] = i;\\n            sz[i] = 1;\\n        }\\n\\n        Edge e[] = {new Edge(1, 2), new Edge(1, 3),\\n            new Edge(2, 4), new Edge(2, 5),\\n            new Edge(4, 6), new Edge(6, 7)};\\n\\n        int q = e.length;\\n        UnionUtil(e, W, q);\\n        // Encuentre el tama\xf1o m\xe1ximo del \xe1rbol DSU.\\n        int maxi = findMax(n, W);\\n        System.out.printf(\\"Maximum size of the subtree with \\");\\n        System.out.printf(\\"even weighted nodes = %d\\\\n\\", maxi);\\n    }\\n}\\n","cpp":"#include<bits/stdc++.h> \\n\\nusing namespace std;\\n\\n#define N 100010 \\n\\nstruct Edge {\\n    int u, v;\\n};\\n\\nint id[N], sz[N];\\n\\nint Root(int idx) {\\n    int i = idx;\\n    while (i != id[i])\\n        id[i] = id[id[i]], i = id[i];\\n    return i;\\n}\\n\\nvoid Union(int a, int b) {\\n    int i = Root(a), j = Root(b);\\n    if (i != j) {\\n        if (sz[i] >= sz[j]) {\\n            id[j] = i, sz[i] += sz[j];\\n            sz[j] = 0;\\n        } else {\\n            id[i] = j, sz[j] += sz[i];\\n            sz[i] = 0;\\n        }\\n    }\\n}\\n\\nvoid UnionUtil(struct Edge e[], int W[], int q) {\\n    for (int i = 0; i < q; i++) {\\n        int u, v;\\n        u = e[i].u, v = e[i].v;\\n        u--, v--;\\n        if (W[u] % 2 == 0 && W[v] % 2 == 0)\\n            Union(u, v);\\n    }\\n}\\n\\nint findMax(int n, int W[]) {\\n    int maxi = 0;\\n    for (int i = 1; i <= n; i++)\\n        if (W[i] % 2 == 0)\\n            maxi = max(maxi, sz[i]);\\n\\n    return maxi;\\n}\\n\\nint main() {\\n    int W[] = {1, 2, 6, 4, 2, 0, 3};\\n    int n = sizeof (W) / sizeof (W[0]);\\n    for (int i = 0; i < n; i++)\\n        id[i] = i, sz[i] = 1;\\n    Edge e[] = {\\n        {1, 2},\\n        {1, 3},\\n        {2, 4},\\n        {2, 5},\\n        {4, 6},\\n        {6, 7}\\n    };\\n    int q = sizeof (e) / sizeof (e[0]);\\n    UnionUtil(e, W, q);\\n    .\\n    int maxi = findMax(n, W);\\n    printf(\\"Maximum size of the subtree with \\");\\n    printf(\\"even weighted nodes = %d\\\\n\\", maxi);\\n\\n    return 0;\\n} \\n","py":"N = 100010\\nclass Edge:\\n    def __init__(self, u, v):\\n        self.u = u\\n        self.v = v\\n\\nid = [0 for i in range(N)]\\nsz = [0 for i in range(N)]\\n\\ndef Root(idx):\\n    i = idx\\n    while (i != id[i]):\\n        id[i] = id[id[i]]\\n        i = id[i]\\n    return i\\n\\ndef Union(a, b):\\n    i = Root(a)\\n    j = Root(b)\\n    if (i != j):\\n        if (sz[i] >= sz[j]):\\n            id[j] = i\\n            sz[i] += sz[j]\\n            sz[j] = 0;\\n        else:\\n            id[i] = j\\n            sz[j] += sz[i]\\n            sz[i] = 0;\\n \\n\\ndef UnionUtil(e, W, q):\\n    for i in range (q):\\n        u = e[i].u\\n        v = e[i].v\\n        u -= 1\\n        v -= 1\\n        if (W[u] % 2 == 0 and W[v] % 2 == 0):\\n            Union(u, v)\\n\\ndef findMax(n, W):\\n    maxi = 0\\n    for i in range (1, n):\\n        if (W[i] % 2 == 0):\\n            maxi = max(maxi, sz[i])\\n    return maxi;\\n\\n\\nW = [1, 2, 6, 4, 2, 0, 3]\\nn = len(W);\\nfor i in range (n):\\n    id[i] = i\\n    sz[i] = 1\\n\\ne = [Edge(1, 2), Edge(1, 3),\\n    Edge(2, 4), Edge(2, 5),\\n    Edge(4, 6), Edge(6, 7)]\\nq = len(e);\\nUnionUtil(e, W, q);\\nmaxi = findMax(n, W);\\nprint(\\"Maximum size of the subtree with \\")\\nprint(\\"even weighted nodes = \\", maxi);\\n","orden":8,"suborden":32,"fecha_creacion":"2020-12-06 19:51:45","fecha_modificacion":"2022-03-08 12:28:52"},{"ID":229,"supergrupo":"Grafos","tema":"Llenado mediante inundaciones","texto":"En MS-Paint, cuando llevamos el pincel a un p\xedxel y hacemos clic, el color de la regi\xf3n de ese p\xedxel se reemplaza con un nuevo color seleccionado. A continuaci\xf3n se muestra el enunciado del problema para realizar esta tarea.\\nDada una pantalla 2D, la ubicaci\xf3n de un p\xedxel en la pantalla y un color, reemplace el color del p\xedxel dado y todos los p\xedxeles adyacentes del mismo color con el color dado.\\nEjemplo:\\nEntrada:\\npantalla [M] [N] = {\\t {1, 1, 1, 1, 1, 1, 1, 1},\\n              \\t\\t {1, 1, 1, 1, 1, 1, 0, 0},\\n               \\t\\t {1, 0, 0, 1, 1, 0, 1, 1},\\n              \\t\\t {1, 2, 2, 2, 2, 0, 1, 0},\\n               \\t\\t {1, 1, 1, 2, 2, 0, 1, 0},\\n              \\t\\t {1, 1, 1, 2, 2, 2, 2, 0},\\n              \\t\\t {1, 1, 1, 1, 1, 2, 1, 1},\\n               \\t\\t {1, 1, 1, 1, 1, 2, 2, 1},\\n              \\t\\t\\t };\\n    x = 4, y = 4, nuevoColor = 3\\nLos valores en la pantalla 2D dada\\n  indicar los colores de los p\xedxeles.\\nxey son coordenadas del pincel,\\n   newColor es el color que\\ndebe reemplazar el color anterior en\\n   pantalla [x] [y] y todos los alrededores\\np\xedxeles con el mismo color.\\n\\nSalida:\\nLa pantalla debe cambiarse a siguiente.\\npantalla [M] [N] = {\\t{1, 1, 1, 1, 1, 1, 1, 1},\\n               \\t\\t{1, 1, 1, 1, 1, 1, 0, 0},\\n              \\t\\t{1, 0, 0, 1, 1, 0, 1, 1},\\n               \\t\\t{1, 3, 3, 3, 3, 0, 1, 0},\\n               \\t\\t{1, 1, 1, 3, 3, 0, 1, 0},\\n               \\t\\t{1, 1, 1, 3, 3, 3, 3, 0},\\n              \\t\\t{1, 1, 1, 1, 1, 3, 1, 1},\\n               \\t\\t{1, 1, 1, 1, 1, 3, 3, 1},\\n              \\t\\t };\\n \\n\\n1: - Uso de recursividad\\nLa idea es simple, primero reemplazamos el color del p\xedxel actual, luego repetimos para 4 puntos circundantes. El siguiente es un algoritmo detallado.\\n// Una funci\xf3n recursiva para reemplazar\\n// color anterior \'prevC\' en \'(x, y)\'\\n// y todos los p\xedxeles circundantes de (x, y)\\n// con nuevo color \'newC\' y\\nfloodFil (pantalla [M] [N], x, y, prevC, newC)\\n1) Si xoy est\xe1 fuera de la pantalla, regrese.\\n2) Si el color de la pantalla [x] [y] no es el mismo que prevC, regrese\\n3) Se repite para norte, sur, este y oeste.\\n    floodFillUtil (pantalla, x + 1, y, prevC, newC);\\n    floodFillUtil (pantalla, x-1, y, prevC, newC);\\n    floodFillUtil (pantalla, x, y + 1, prevC, newC);\\n    floodFillUtil (pantalla, x, y-1, prevC, newC);\\n\\nM\xe9todo 2: usar el enfoque BFS\\nAlgoritmo para el enfoque basado en BFS:\\n1. Cree una cola de parejas.\\n2. Inserte un \xedndice inicial dado en la cola.\\n3. Marque el \xedndice inicial como visitado en vis [] [] matriz.\\n4. Hasta que la cola no est\xe9 vac\xeda, repita los pasos 3.1 a 3.6\\n\u2022 Toma el elemento frontal de la cola\\n\u2022 Salir de la cola\\n\u2022 Almacene el valor / color actual en las coordenadas sacadas de la cola (precolor)\\n\u2022 Actualizar el valor / color del \xedndice actual que se saca de la cola\\n\u2022 Verifique las 4 direcciones, es decir, (x + 1, y), (x-1, y), (x, y + 1), (x, y-1) es v\xe1lido o no y si es v\xe1lido, verifique ese valor en esa coordenada debe ser igual al precolor y el valor de esa coordenada en vis [] [] es 0.\\n\u2022 Si toda la condici\xf3n anterior es verdadera, empuje la coordenada correspondiente en la cola y marque como 1 en vis [] []\\n5. Imprima la matriz.\\n","complejidad_tiempo":null,"java":"// Programa Java para implementar el algoritmo de relleno por inundaci\xf3n\\n\\npublic class FloodFill {\\n\\n// Dimensiones de la pantalla \\n    static int M = 8;\\n    static int N = 8;\\n\\n    // Una funci\xf3n recursiva para reemplazar el color anterior \'prevC\' en \\n    // \'(x, y)\' y todos los p\xedxeles circundantes de (x, y) con el nuevo color \'newC\' \\n    static void floodFillUtil(int screen[][], int x, int y,\\n            int prevC, int newC) {\\n        if (x < 0 || x >= M || y < 0 || y >= N) {\\n            return;\\n        }\\n        if (screen[x][y] != prevC) {\\n            return;\\n        }\\n        // Reemplazar el color en (x, y)\\n        screen[x][y] = newC;\\n        // ir recursivamente para norte, este, sur y oeste\\n        floodFillUtil(screen, x + 1, y, prevC, newC);\\n        floodFillUtil(screen, x - 1, y, prevC, newC);\\n        floodFillUtil(screen, x, y + 1, prevC, newC);\\n        floodFillUtil(screen, x, y - 1, prevC, newC);\\n    }\\n\\n    // se encuentra principalmente el color anterior en (x, y)\\n    // y llama a floodFillUtil ()\\n    static void floodFill(int screen[][], int x, int y, int newC) {\\n        int prevC = screen[x][y];\\n        floodFillUtil(screen, x, y, prevC, newC);\\n    }\\n\\n    public static void main(String[] args) {\\n        int screen[][] = {{1, 1, 1, 1, 1, 1, 1, 1},\\n        {1, 1, 1, 1, 1, 1, 0, 0},\\n        {1, 0, 0, 1, 1, 0, 1, 1},\\n        {1, 2, 2, 2, 2, 0, 1, 0},\\n        {1, 1, 1, 2, 2, 0, 1, 0},\\n        {1, 1, 1, 2, 2, 2, 2, 0},\\n        {1, 1, 1, 1, 1, 2, 1, 1},\\n        {1, 1, 1, 1, 1, 2, 2, 1},};\\n        int x = 4, y = 4, newC = 3;\\n        floodFill(screen, x, y, newC);\\n\\n        System.out.println(\\"Updated screen after call to floodFill: \\");\\n        for (int i = 0; i < M; i++) {\\n            for (int j = 0; j < N; j++) {\\n                System.out.print(screen[i][j] + \\" \\");\\n            }\\n            System.out.println();\\n        }\\n    }\\n}\\n","cpp":"#include<iostream> \\nusing namespace std;\\n\\n#define M 8 \\n#define N 8 \\n\\nvoid floodFillUtil(int screen[][N], int x, int y, int prevC, int newC) {\\n    if (x < 0 || x >= M || y < 0 || y >= N)\\n        return;\\n    if (screen[x][y] != prevC)\\n        return;\\n    if (screen[x][y] == newC)\\n        return;\\n    screen[x][y] = newC;\\n    floodFillUtil(screen, x + 1, y, prevC, newC);\\n    floodFillUtil(screen, x - 1, y, prevC, newC);\\n    floodFillUtil(screen, x, y + 1, prevC, newC);\\n    floodFillUtil(screen, x, y - 1, prevC, newC);\\n}\\n\\nvoid floodFill(int screen[][N], int x, int y, int newC) {\\n    int prevC = screen[x][y];\\n    floodFillUtil(screen, x, y, prevC, newC);\\n}\\n\\nint main() {\\n    int screen[M][N] = {\\n        {1, 1, 1, 1, 1, 1, 1, 1},\\n        {1, 1, 1, 1, 1, 1, 0, 0},\\n        {1, 0, 0, 1, 1, 0, 1, 1},\\n        {1, 2, 2, 2, 2, 0, 1, 0},\\n        {1, 1, 1, 2, 2, 0, 1, 0},\\n        {1, 1, 1, 2, 2, 2, 2, 0},\\n        {1, 1, 1, 1, 1, 2, 1, 1},\\n        {1, 1, 1, 1, 1, 2, 2, 1},\\n    };\\n    int x = 4, y = 4, newC = 3;\\n    floodFill(screen, x, y, newC);\\n    cout << \\"Updated screen after call to floodFill: \\\\n\\";\\n    for (int i = 0; i < M; i++) {\\n        for (int j = 0; j < N; j++)\\n            cout << screen[i][j] << \\" \\";\\n        cout << endl;\\n    }\\n}\\n","py":"M = 8\\nN = 8\\ndef floodFillUtil(screen, x, y, prevC, newC): \\n    if (x < 0 or x >= M or y < 0 or\\n        y >= N or screen[x][y] != prevC or\\n        screen[x][y] == newC): \\n        return\\n    screen[x][y] = newC \\n    floodFillUtil(screen, x + 1, y, prevC, newC) \\n    floodFillUtil(screen, x - 1, y, prevC, newC) \\n    floodFillUtil(screen, x, y + 1, prevC, newC) \\n    floodFillUtil(screen, x, y - 1, prevC, newC) \\ndef floodFill(screen, x, y, newC): \\n    prevC = screen[x][y] \\n    floodFillUtil(screen, x, y, prevC, newC) \\nscreen = [[1, 1, 1, 1, 1, 1, 1, 1], \\n    [1, 1, 1, 1, 1, 1, 0, 0], \\n    [1, 0, 0, 1, 1, 0, 1, 1], \\n    [1, 2, 2, 2, 2, 0, 1, 0], \\n    [1, 1, 1, 2, 2, 0, 1, 0], \\n    [1, 1, 1, 2, 2, 2, 2, 0], \\n    [1, 1, 1, 1, 1, 2, 1, 1], \\n    [1, 1, 1, 1, 1, 2, 2, 1]] \\n\\nx = 4\\ny = 4\\nnewC = 3\\nfloodFill(screen, x, y, newC) \\nprint (\\"Updated screen after call to floodFill:\\") \\nfor i in range(M): \\n    print(screen[i]) \\n\\n","orden":8,"suborden":33,"fecha_creacion":"2020-12-06 19:51:45","fecha_modificacion":"2022-03-08 12:28:52"},{"ID":230,"supergrupo":"Grafos","tema":"Algoritmo de Ford-Fulkerson para m\xe1ximos flujos","texto":"Dado un gr\xe1fico que representa una red de flujo donde cada arista tiene una capacidad. Tambi\xe9n dados dos v\xe9rtices fuente \\"s\\" y sumidero \\"t\\" en el gr\xe1fico, encuentre el flujo m\xe1ximo posible de s a t con las siguientes restricciones:\\n\\na) El flujo en una arista no excede la capacidad dada del arista.\\nb) El flujo entrante es igual al flujo saliente para cada v\xe9rtice excepto s y t.\\n \\nLa siguiente es una idea simple del algoritmo Ford-Fulkerson:\\n1) Comience con el flujo inicial como 0.\\n2) Si bien hay un camino creciente desde la fuente hasta el sumidero.\\nAgregue este flujo de ruta para fluir.\\n3) Retorne el flujo.\\n\\nComplejidad de tiempo: La complejidad de tiempo del algoritmo anterior es O (max_flow * E). Ejecutamos un bucle mientras hay una ruta de aumento. En el peor de los casos, podemos agregar 1 unidad de flujo en cada iteraci\xf3n. Por tanto, la complejidad del tiempo se convierte en O (max_flow * E).\\n\xbfC\xf3mo implementar el algoritmo simple anterior?\\nPrimero definamos el concepto de Gr\xe1fico Residual que se necesita para comprender la implementaci\xf3n.\\n\\nEl gr\xe1fico residual de una red de flujo es un gr\xe1fico que indica un flujo adicional posible. Si hay una ruta desde la fuente hasta el sumidero en el gr\xe1fico residual, entonces es posible agregar flujo. Cada arista de un gr\xe1fico residual tiene un valor llamado capacidad residual que es igual a la capacidad original de la arista menos el flujo de corriente. La capacidad residual es b\xe1sicamente la capacidad actual de la arista.\\n\\nHablemos ahora de los detalles de implementaci\xf3n. La capacidad residual es 0 si no hay arista entre dos v\xe9rtices del gr\xe1fico residual. Podemos inicializar el gr\xe1fico residual como gr\xe1fico original ya que no hay flujo inicial y la capacidad residual inicial es igual a la capacidad original. Para encontrar una ruta de aumento, podemos hacer un BFS o DFS del gr\xe1fico residual. Hemos utilizado BFS en la siguiente implementaci\xf3n. Usando BFS, podemos averiguar si hay una ruta desde la fuente hasta el sumidero. BFS tambi\xe9n crea una matriz principal []. Usando la matriz principal [], atravesamos la ruta encontrada y encontramos el flujo posible a trav\xe9s de esta ruta al encontrar la capacidad residual m\xednima a lo largo de la ruta. Posteriormente agregamos el flujo de ruta encontrado al flujo general.\\nLo importante es que necesitamos actualizar las capacidades residuales en el gr\xe1fico de residuos. Restamos el flujo de la ruta de todos las aristas a lo largo de la ruta y agregamos el flujo de la ruta a lo largo de las aristas inversos Necesitamos agregar el flujo de la ruta a lo largo de las aristas inversas porque m\xe1s tarde es posible que necesitemos enviar el flujo en direcci\xf3n inversa\\n\\nLa implementaci\xf3n anterior del algoritmo Ford Fulkerson se llama algoritmo Edmonds-Karp. La idea de Edmonds-Karp es utilizar BFS en la implementaci\xf3n de Ford Fulkerson, ya que BFS siempre elige un camino con un n\xfamero m\xednimo de aristas. Cuando se utiliza BFS, la complejidad de tiempo del peor de los casos se puede reducir a O (VE2). La implementaci\xf3n anterior usa una representaci\xf3n de matriz de adyacencia, aunque donde BFS toma tiempo O (V2), la complejidad de tiempo de la implementaci\xf3n anterior es O (EV3).\\n\\nEste es un problema importante ya que surge en muchas situaciones pr\xe1cticas. Los ejemplos incluyen, maximizar el transporte con l\xedmites de tr\xe1fico dados, maximizar el flujo de paquetes en las redes de computadoras.\\n","complejidad_tiempo":null,"java":"// Programa Java para la implementaci\xf3n del algoritmo Ford Fulkerson\\n\\nimport java.util.LinkedList;\\n\\npublic class FordFulkersonMaxFlow {\\n\\n    static final int V = 6; //N\xfamero de v\xe9rtices en el gr\xe1fico\\n\\n    /* Devuelve verdadero si hay una ruta desde la fuente \'s\' hasta el sumidero \\n    \'t\' en el gr\xe1fico residual. Tambi\xe9n llena parent [] \\n    para almacenar la ruta */\\n    static boolean bfs(int rGraph[][], int s, int t, int parent[]) {\\n        // Cree una matriz visitada y marque todos los v\xe9rtices como no visitados\\n        boolean visited[] = new boolean[V];\\n        for (int i = 0; i < V; ++i) {\\n            visited[i] = false;\\n        }\\n        // Cree una cola, ponga en cola el v\xe9rtice de origen y \\n        // marque el v\xe9rtice de origen como visitado\\n        LinkedList<Integer> queue = new LinkedList<>();\\n        queue.add(s);\\n        visited[s] = true;\\n        parent[s] = -1;\\n        // Bucle BFS est\xe1ndar\\n        while (!queue.isEmpty()) {\\n            int u = queue.poll();\\n            for (int v = 0; v < V; v++) {\\n                if (visited[v] == false && rGraph[u][v] > 0) {\\n                    queue.add(v);\\n                    parent[v] = u;\\n                    visited[v] = true;\\n                }\\n            }\\n        }\\n\\n        // Si alcanzamos el sumidero en BFS a partir de la fuente, \\n        // devolvemos verdadero, de lo contrario falso\\n        return (visited[t] == true);\\n    }\\n\\n    // Devuelve el caudal m\xe1ximo de s - t en el gr\xe1fico dado\\n    static int fordFulkerson(int graph[][], int s, int t) {\\n        int u, v;\\n\\n        // Cree un grafo residual y llene el grafo residual con las capacidades \\n        // dadas en el grafo original como capacidades residuales en el grafo \\n        // residual donde rGraph [i] [j] indica la capacidad residual del \\n        // borde de i a j (si hay un borde. If rGraph [i] [j] es 0,\\n        // entonces no hay)\\n        int rGraph[][] = new int[V][V];\\n        for (u = 0; u < V; u++) {\\n            for (v = 0; v < V; v++) {\\n                rGraph[u][v] = graph[u][v];\\n            }\\n        }\\n\\n        // Esta matriz est\xe1 llena de BFS y para almacenar la ruta\\n        int parent[] = new int[V];\\n        int max_flow = 0; // No hay flujo inicialmente\\n\\n        // Aumente el flujo mientras hay un camino desde la fuente hasta el sumidero\\n        while (bfs(rGraph, s, t, parent)) {\\n            // Encuentre la capacidad residual m\xednima de los bordes a lo largo \\n            // del camino llenado por BFS. O podemos decir encontrar \\n            // el flujo m\xe1ximo a trav\xe9s del camino encontrado.\\n            int path_flow = Integer.MAX_VALUE;\\n            for (v = t; v != s; v = parent[v]) {\\n                u = parent[v];\\n                path_flow = Math.min(path_flow, rGraph[u][v]);\\n            }\\n            // actualizar las capacidades residuales de los bordes e invertir \\n            // los bordes a lo largo del camino\\n            for (v = t; v != s; v = parent[v]) {\\n                u = parent[v];\\n                rGraph[u][v] -= path_flow;\\n                rGraph[v][u] += path_flow;\\n            }\\n\\n            // Agregue el flujo de ruta al flujo general\\n            max_flow += path_flow;\\n        }\\n\\n        // Devuelve el flujo general\\n        return max_flow;\\n    }\\n\\n    public static void main(String[] args) throws java.lang.Exception {\\n        int graph[][] = new int[][]{{0, 16, 13, 0, 0, 0},\\n        {0, 0, 10, 12, 0, 0},\\n        {0, 4, 0, 0, 14, 0},\\n        {0, 0, 9, 0, 0, 20},\\n        {0, 0, 0, 7, 0, 4},\\n        {0, 0, 0, 0, 0, 0}\\n        };\\n        System.out.println(\\"The maximum possible flow is \\"\\n                + fordFulkerson(graph, 0, 5));\\n    }\\n}\\n","cpp":"#include <iostream> \\n#include <limits.h> \\n#include <string.h> \\n#include <queue> \\nusing namespace std;\\n\\n#define V 6 \\n\\nbool bfs(int rGraph[V][V], int s, int t, int parent[]) {\\n\\n    bool visited[V];\\n    memset(visited, 0, sizeof (visited));\\n    queue <int> q;\\n    q.push(s);\\n    visited[s] = true;\\n    parent[s] = -1;\\n\\n    while (!q.empty()) {\\n        int u = q.front();\\n        q.pop();\\n        for (int v = 0; v < V; v++) {\\n            if (visited[v] == false && rGraph[u][v] > 0) {\\n                q.push(v);\\n                parent[v] = u;\\n                visited[v] = true;\\n            }\\n        }\\n    }\\n    return (visited[t] == true);\\n}\\n\\nint fordFulkerson(int graph[V][V], int s, int t) {\\n    int u, v;\\n    int rGraph[V][V];\\n    for (u = 0; u < V; u++)\\n        for (v = 0; v < V; v++)\\n            rGraph[u][v] = graph[u][v];\\n    int parent[V];\\n    int max_flow = 0;\\n    while (bfs(rGraph, s, t, parent)) {\\n        int path_flow = INT_MAX;\\n        for (v = t; v != s; v = parent[v]) {\\n            u = parent[v];\\n            path_flow = min(path_flow, rGraph[u][v]);\\n        }\\n        for (v = t; v != s; v = parent[v]) {\\n            u = parent[v];\\n            rGraph[u][v] -= path_flow;\\n            rGraph[v][u] += path_flow;\\n        }\\n        max_flow += path_flow;\\n    }\\n    return max_flow;\\n}\\n\\nint main() {\\n    int graph[V][V] = {\\n        {0, 16, 13, 0, 0, 0},\\n        {0, 0, 10, 12, 0, 0},\\n        {0, 4, 0, 0, 14, 0},\\n        {0, 0, 9, 0, 0, 20},\\n        {0, 0, 0, 7, 0, 4},\\n        {0, 0, 0, 0, 0, 0}\\n    };\\n    cout << \\"The maximum possible flow is \\" << fordFulkerson(graph, 0, 5);\\n    return 0;\\n}\\n","py":"class Graph: \\n\\n    def __init__(self, graph): \\n        self.graph = graph \\n        self. ROW = len(graph) \\n        #self.COL = len(gr[0]) \\n                \\n    def BFS(self, s, t, parent): \\n        visited = [False] * (self.ROW) \\n        queue = [] \\n        queue.append(s) \\n        visited[s] = True\\n        while queue: \\n            u = queue.pop(0) \\n            for ind, val in enumerate(self.graph[u]): \\n                if visited[ind] == False and val > 0: \\n                    queue.append(ind) \\n                    visited[ind] = True\\n                    parent[ind] = u \\n        return True if visited[t] else False\\n\\n    def FordFulkerson(self, source, sink): \\n        parent = [-1] * (self.ROW) \\n        max_flow = 0 \\n        while self.BFS(source, sink, parent):  \\n            path_flow = float(\\"Inf\\") \\n            s = sink \\n            while(s != source): \\n                path_flow = min (path_flow, self.graph[parent[s]][s]) \\n                s = parent[s] \\n\\n            max_flow += path_flow \\n            v = sink \\n            while(v != source): \\n                u = parent[v] \\n                self.graph[u][v] -= path_flow \\n                self.graph[v][u] += path_flow \\n                v = parent[v] \\n        return max_flow \\n\\ngraph = [[0, 16, 13, 0, 0, 0], \\n    [0, 0, 10, 12, 0, 0], \\n    [0, 4, 0, 0, 14, 0], \\n    [0, 0, 9, 0, 0, 20], \\n    [0, 0, 0, 7, 0, 4], \\n    [0, 0, 0, 0, 0, 0]] \\ng = Graph(graph) \\nsource = 0; sink = 5\\nprint (\\"The maximum possible flow is %d \\" % g.FordFulkerson(source, sink)) \\n","orden":8,"suborden":34,"fecha_creacion":"2020-12-06 19:51:46","fecha_modificacion":"2022-03-08 12:28:52"},{"ID":231,"supergrupo":"Grafos","tema":"Antecesor com\xfan m\xe1s bajo","texto":"El ancestro com\xfan m\xe1s bajo (ACB LCA) es un concepto dentro de la Teor\xeda de grafos y Ciencias de la computaci\xf3n. Sea T un \xe1rbol con ra\xedz y n nodos. El ancestro com\xfan m\xe1s bajo entre dos nodos v y w se define como el nodo m\xe1s bajo en T que tiene a v y w como descendientes (donde se permite a un nodo ser descendiente de \xe9l mismo).\\nEl ACB de v y w en T es el ancestro compartido de v y w que est\xe1 localizado m\xe1s lejos de la ra\xedz. El c\xf3mputo del ancestro com\xfan m\xe1s bajo puede ser \xfatil, por ejemplo, como parte de un procedimiento para determinar la distancia entre pares de nodos en un \xe1rbol: la distancia de v a w puede ser calculada como la distancia desde la ra\xedz hasta v, sumada con la distancia desde la ra\xedz hasta w, menos dos veces la distancia desde la ra\xedz hasta su ancestro com\xfan m\xe1s bajo.\\nEn una estructura de datos \xe1rbol donde cada nodo referencia a su padre, el ancestro com\xfan m\xe1s bajo puede ser determinado de forma muy simple encontrando la primera intersecci\xf3n de los caminos desde v and w hasta la ra\xedz. En general, el tiempo computacional requerido por este algoritmo es O(h) donde h es la altura del \xe1rbol (longitud del camino m\xe1s largo desde una hoja hasta la ra\xedz). Sin embargo, existen muchos algoritmos para procesar \xe1rboles con los que el ancestro com\xfan m\xe1s bajo puede ser encontrado de forma m\xe1s r\xe1pida.\\nSe puede buscar en tiempo constante por pregunta despu\xe9s de un preprocesamiento en tiempo lineal.\\nSin preprocesamiento se puede mejorar el tiempo de c\xf3mputo del algoritmo ingenuo hasta O(log h) almacenando los caminos a trav\xe9s del \xe1rbol usando skew-binary random access lists, premitiendo a\xfan al \xe1rbol ser extendido en tiempo constante\\n \\nEn el diagrama anterior, el LCA de 10 y 14 es 12 y el LCA de 10 y 12 es 12.\\n  (1) Cree una matriz padre y almacene el padre del i-\xe9simo nodo en ella. El padre del nodo ra\xedz debe ser -1.\\n(2) Ahora, acceda a todos los nodos desde el nodo deseado \\"m\\" hasta el nodo ra\xedz y m\xe1rquelos como visitados.\\n(3) Por \xfaltimo, acceda a todos los nodos desde el nodo deseado \\"n\\" hasta que llegue el primer nodo visitado.\\n(4) Este nodo es el ancestro com\xfan m\xe1s bajo\\n","complejidad_tiempo":null,"java":"import java.util.ArrayList;\\n\\npublic class LowestCommonAncestor {\\n\\n    static final int MAX = 100005; //Cantidad maxima de nodos\\n    static final int LOG2 = 17; //log2(MAX)+1\\n    //ArrayList<edge> g[] = new ArrayList[MAX]; //Lista de adyacencia\\n    static ArrayList<Integer> g[] = new ArrayList[MAX]; //Lista de adyacencia\\n    static int dep[] = new int[MAX]; //Almacena la profundidad de cada nodo\\n    static int par[][] = new int[MAX][LOG2]; //Almacena los padres para responder las consultas\\n    //int rmq[][] = new int[MAX][LOG2]; //Almacena los pesos para responder las consultas\\n    static int nodos, aristas; //Cantidad de nodos y aristas \\n\\n    /*static class edge {\\n    int v, w; \\n    \\n    edge(int _v, int _w){\\n        v = _v;\\n        w = _w;\\n    }\\n};*/\\n    static int lca(int u, int v) {\\n        //int ans = -1;\\n        if (dep[u] < dep[v]) {\\n            int aux = u;\\n            u = v;\\n            v = aux;\\n        }\\n        int diff = dep[u] - dep[v];\\n        for (int i = LOG2 - 1; i >= 0; i--) {\\n            if ((diff & (1 << i)) > 0) {\\n                //ans = Math.max(ans, rmq[u][i]);\\n                u = par[u][i];\\n            }\\n        }\\n        //if (u == v) return ans;\\n        if (u == v) {\\n            return u;\\n        }\\n        for (int i = LOG2 - 1; i >= 0; i--) {\\n            if (par[u][i] != par[v][i]) {\\n                //ans = Math.max(ans, Math.max(rmq[u][i], rmq[v][i]));\\n                u = par[u][i];\\n                v = par[v][i];\\n            }\\n        }\\n        //return Math.max(ans, Math.max(rmq[u][0], rmq[v][0]));\\n        return par[u][0];\\n    }\\n\\n    static void dfs(int u, int p, int d) {\\n        dep[u] = d;\\n        par[u][0] = p;\\n        for (int v /* edge ed*/ : g[u]) {\\n            //int v = ed.v;\\n            if (v != p) {\\n                //rmq[v][0] = ed.w;\\n                dfs(v, u, d + 1);\\n            }\\n        }\\n    }\\n\\n    static void build() {\\n        for (int i = 0; i < nodos; i++) {\\n            dep[i] = -1;\\n        }\\n        for (int i = 0; i < nodos; i++) {\\n            if (dep[i] == -1) {\\n                //rmq[i][0] = -1;\\n                dfs(i, i, 0);\\n            }\\n        }\\n        for (int j = 0; j < LOG2 - 1; j++) {\\n            for (int i = 0; i < nodos; i++) {\\n                par[i][j + 1] = par[par[i][j]][j];\\n                //rmq[i][j+1] = Math.max(rmq[ par[i][j] ][j], rmq[i][j]);\\n            }\\n        }\\n    }\\n\\n    static void init() {\\n        for (int i = 0; i <= nodos; i++) {\\n            g[i] = new ArrayList<>();\\n        }\\n    }\\n\\n    public static void main(String[] args) {\\n        nodos = 5;\\n        aristas = 4;\\n        init();\\n        g[0].add(1);\\n        g[0].add(2);\\n        g[2].add(3);\\n        g[3].add(4);\\n        build();\\n        System.out.println(lca(2, 1));\\n    }\\n}\\n","cpp":"#include <cstdlib>\\n#include <bits/stdc++.h> \\nusing namespace std;\\nconst int MAX = 100005;\\nconst int LOG2 = 17;\\n//vector<edge> g[MAX];\\nvector<int> g[MAX];\\nint dep[MAX];\\nint par[MAX][LOG2];\\nint rmq[MAX][LOG2];\\nstatic int nodos, aristas;\\n\\nstruct edge {\\n    int v, w;\\n\\n    edge(int _v, int _w) {\\n        v = _v;\\n        w = _w;\\n    }\\n};\\n\\nint lca(int u, int v) {\\n    //int ans = -1;\\n    if (dep[u] < dep[v]) {\\n        int aux = u;\\n        u = v;\\n        v = aux;\\n    }\\n    int diff = dep[u] - dep[v];\\n    for (int i = LOG2 - 1; i >= 0; i--) {\\n        if ((diff & (1 << i)) > 0) {\\n            //ans = max(ans, rmq[u][i]);\\n            u = par[u][i];\\n        }\\n    }\\n    //if (u == v) return ans;\\n    if (u == v) {\\n        return u;\\n    }\\n    for (int i = LOG2 - 1; i >= 0; i--) {\\n        if (par[u][i] != par[v][i]) {\\n            //ans = max(ans, max(rmq[u][i], rmq[v][i]));\\n            u = par[u][i];\\n            v = par[v][i];\\n        }\\n    }\\n    //return max(ans, max(rmq[u][0], rmq[v][0]));\\n    return par[u][0];\\n}\\n\\nvoid dfs(int u, int p, int d) {\\n    dep[u] = d;\\n    par[u][0] = p;\\n    for (int v /* edge ed*/ : g[u]) {\\n        //int v = ed.v;\\n        if (v != p) {\\n            //rmq[v][0] = ed.w;\\n            dfs(v, u, d + 1);\\n        }\\n    }\\n}\\n\\nvoid build() {\\n    for (int i = 0; i < nodos; i++) {\\n        dep[i] = -1;\\n    }\\n    for (int i = 0; i < nodos; i++) {\\n        if (dep[i] == -1) {\\n            //rmq[i][0] = -1;\\n            dfs(i, i, 0);\\n        }\\n    }\\n    for (int j = 0; j < LOG2 - 1; j++) {\\n        for (int i = 0; i < nodos; i++) {\\n            par[i][j + 1] = par[par[i][j]][j];\\n            //rmq[i][j+1] = max(rmq[ par[i][j] ][j], rmq[i][j]);\\n        }\\n    }\\n}\\n\\nvoid init() {\\n    for (int i = 0; i <= nodos; i++) {\\n        //        g[i] = new ArrayList<>();\\n    }\\n}\\n\\nint main() {\\n    nodos = 5;\\n    aristas = 4;\\n    init();\\n    g[0].emplace_back(1);\\n    g[0].emplace_back(2);\\n    g[2].emplace_back(3);\\n    g[3].emplace_back(4);\\n    build();\\n    cout << (lca(2, 1)) << endl;\\n}\\n","py":"MAX = 100005\\nLOG2 = 17\\n#vector<edge> g[MAX];\\ng = [[]for i in range (MAX)]\\ndep = [0 for i in range (MAX)]\\npar = [[0 for j in range (MAX)]for i in range (LOG2)]\\nrmq = [[0 for j in range (MAX)]for i in range (LOG2)]\\nclass edge:\\n    def __init__(self, v, w):\\n        self.v = v\\n        self.w = w\\n        \\ndef lca(u, v):\\n    #int ans = -1;\\n    if (dep[u] < dep[v]):\\n        aux = u;\\n        u = v;\\n        v = aux;\\n    diff = dep[u] - dep[v];\\n    for i in range (LOG2-1, -1, -1):\\n        if ((diff & (1 << i)) > 0):\\n            #ans = max(ans, rmq[u][i]);\\n            u = par[u][i];\\n    #if (u == v) return ans;\\n    if (u == v):\\n        return u\\n    for i in range (LOG2-1, -1, -1):\\n        if (par[u][i] != par[v][i]):\\n            #ans = max(ans, max(rmq[u][i], rmq[v][i]));\\n            u = par[u][i]\\n            v = par[v][i]\\n    \\n    #return max(ans, max(rmq[u][0], rmq[v][0]));\\n    return par[u][0]\\n\\ndef dfs(u, p, d):\\n    dep[u] = d\\n    par[u][0] = p\\n    for v in g[u]:\\n        #v = ed.v;\\n        if (v != p):\\n            #rmq[v][0] = ed.w\\n            dfs(v, u, d + 1)\\n \\n\\ndef build():\\n    for i in range (nodos):\\n        dep[i] = -1\\n    for i in range (nodos): \\n        if (dep[i] == -1):\\n            #rmq[i][0] = -1;\\n            dfs(i, i, 0);\\n    for i in range (LOG2-1):\\n        for j in range (nodos):\\n            par[i][j + 1] = par[par[i][j]][j]\\n            #rmq[i][j+1] = max(rmq[ par[i][j] ][j], rmq[i][j]);\\n \\n\\ndef init():\\n    g = [[]for i in range (MAX)]\\n\\nnodos = 5\\naristas = 4\\ninit()\\ng[0].append(1)\\ng[0].append(2)\\ng[2].append(3)\\ng[3].append(4)\\nbuild();\\nprint(lca(2, 1))\\n","orden":8,"suborden":35,"fecha_creacion":"2020-12-06 19:51:46","fecha_modificacion":"2022-03-08 12:28:52"},{"ID":232,"supergrupo":"Grafos","tema":"Serpientes y escaleras","texto":"Dado un tablero de serpiente y escalera, encuentre el n\xfamero m\xednimo de lanzamientos de dados necesarios para llegar al destino o la \xfaltima celda desde la fuente o la primera celda. B\xe1sicamente, el jugador tiene control total sobre el resultado del lanzamiento de dados y quiere averiguar el n\xfamero m\xednimo de lanzamientos necesarios para llegar a la \xfaltima celda.\\nSi el jugador llega a una celda que es la base de una escalera, el jugador tiene que subir esa escalera y si llega a una celda que es la boca de la serpiente, tiene que bajar hasta la cola de la serpiente sin lanzar un dado.\\n \\nPor ejemplo, considere el tablero que se muestra, el n\xfamero m\xednimo de lanzamientos de dados necesarios para llegar a la celda 30 desde la celda 1 es 3.\\nLos siguientes son los pasos:\\na) Primero lanza dos dados para llegar a la celda n\xfamero 3 y luego escala para llegar a la 22\\nb) Luego lanza 6 para llegar a 28.\\nc) Finalmente a trav\xe9s del 2 para llegar a 30.\\nTambi\xe9n puede haber otras soluciones como (2, 2, 6), (2, 4, 4), (2, 3, 5) .. etc.\\nLa idea es considerar el tablero de serpiente y escalera dado como un gr\xe1fico dirigido con un n\xfamero de v\xe9rtices igual al n\xfamero de celdas del tablero. El problema se reduce a encontrar el camino m\xe1s corto en un gr\xe1fico. Cada v\xe9rtice del gr\xe1fico tiene una arista hasta los siguientes seis v\xe9rtices si los siguientes 6 v\xe9rtices no tienen una serpiente o una escalera. Si alguno de los siguientes seis v\xe9rtices tiene una serpiente o una escalera, entonces la arista del v\xe9rtice actual va a la parte superior de la escalera o la cola de la serpiente. Dado que todos las aristas tienen el mismo peso, podemos encontrar de manera eficiente la ruta m\xe1s corta usando la b\xfasqueda de amplitud primero del gr\xe1fico.\\nA continuaci\xf3n se muestra la implementaci\xf3n de la idea anterior. La entrada est\xe1 representada por dos cosas, primero es \'N\' que es el n\xfamero de celdas en el tablero dado, segundo es una matriz \'mover [0\u2026 N-1]\' de tama\xf1o N. Una entrada de movimiento [i] es -1 si no hay serpiente ni escalera desde i, de lo contrario, el movimiento [i] contiene el \xedndice de la celda de destino para la serpiente o la escalera en i.\\nLa complejidad de tiempo de la soluci\xf3n anterior es O (N) ya que cada celda se agrega y se elimina solo una vez de la cola. Y una operaci\xf3n t\xedpica de poner en cola o sacar de cola lleva O (1) tiempo.\\n","complejidad_tiempo":null,"java":"// Programa Java para encontrar el n\xfamero m\xednimo de lanzamientos de dados \\n// necesarios para llegar a la \xfaltima celda de la primera celda de una \\n// tabla de escalera y serpiente determinada\\n\\nimport java.util.LinkedList;\\nimport java.util.Queue;\\n\\npublic class SnakesAndLadders {\\n    // Una entrada en la cola utilizada en BFS\\n\\n    static class qentry {\\n\\n        int v;// N\xfamero de v\xe9rtice\\n        int dist;// Distancia de este v\xe9rtice desde la fuente\\n    }\\n\\n    // Esta funci\xf3n devuelve el n\xfamero m\xednimo de lanzamientos de dados \\n    // necesarios para llegar a la \xfaltima celda desde la celda 0 en un juego \\n    // de serpientes y escaleras. move[] es una matriz de tama\xf1o N donde N es \\n    // no. de celdas a bordo Si no hay una serpiente o escalera desde la \\n    // celda i, entonces move[i] es -1 De lo contrario, el move[i] contiene \\n    // la celda a la que lleva la serpiente o escalera en i.\\n    static int getMinDiceThrows(int move[], int n) {\\n        int visited[] = new int[n];\\n        Queue<qentry> q = new LinkedList<>();\\n        qentry qe = new qentry();\\n        qe.v = 0;\\n        qe.dist = 0;\\n\\n        // Marque el nodo 0 como visitado y col\xf3quelo.\\n        visited[0] = 1;\\n        q.add(qe);\\n\\n        // Hacer un BFS comenzando desde el v\xe9rtice en el \xedndice 0\\n        while (!q.isEmpty()) {\\n            qe = q.remove();\\n            int v = qe.v;\\n\\n            // Si el v\xe9rtice frontal es el v\xe9rtice de destino, hemos terminado.\\n            if (v == n - 1) {\\n                break;\\n            }\\n\\n            // De lo contrario, quite de la cola del v\xe9rtice frontal y ponga \\n            // en cola sus v\xe9rtices adyacentes (o n\xfameros de celda \\n            // accesibles a trav\xe9s de un lanzamiento de dados)\\n            for (int j = v + 1; j <= (v + 6) && j < n; ++j) {\\n                // Si esta celda ya est\xe1 visitada, ignore\\n                if (visited[j] == 0) {\\n                    // De lo contrario, calcule su distancia y m\xe1rquela como visitada.\\n                    qentry a = new qentry();\\n                    a.dist = (qe.dist + 1);\\n                    visited[j] = 1;\\n\\n                    // Compruebe si hay una serpiente o una escalera en \'j\', luego la cola de la serpiente o la parte superior de la escalera se convierte en el adyacente de \'i\'\\n                    if (move[j] != -1) {\\n                        a.v = move[j];\\n                    } else {\\n                        a.v = j;\\n                    }\\n                    q.add(a);\\n                }\\n            }\\n        }\\n\\n        // Llegamos aqu\xed cuando \'qe\' tiene el \xfaltimo v\xe9rtice devuelve la distancia del v\xe9rtice en \'qe\'\\n        return qe.dist;\\n    }\\n\\n    public static void main(String[] args) {\\n        // Construyamos el tablero dado en el diagrama anterior\\n        int N = 30;\\n        int moves[] = new int[N];\\n        for (int i = 0; i < N; i++) {\\n            moves[i] = -1;\\n        }\\n\\n        // Escaleras\\n        moves[2] = 21;\\n        moves[4] = 7;\\n        moves[10] = 25;\\n        moves[19] = 28;\\n\\n        // Snakes\\n        moves[26] = 0;\\n        moves[20] = 8;\\n        moves[16] = 3;\\n        moves[18] = 6;\\n\\n        System.out.println(\\"Min Dice throws required is \\"\\n                + getMinDiceThrows(moves, N));\\n    }\\n}\\n","cpp":"#include<iostream> \\n#include <queue> \\nusing namespace std;\\n\\nstruct queueEntry {\\n    int v;\\n    int dist;\\n};\\n\\nint getMinDiceThrows(int move[], int N) {\\n\\n    bool *visited = new bool[N];\\n    for (int i = 0; i < N; i++)\\n        visited[i] = false;\\n    queue<queueEntry> q;\\n    visited[0] = true;\\n    queueEntry s = {0, 0};\\n    /\\n    q.push(s);\\n    queueEntry qe;\\n    while (!q.empty()) {\\n        qe = q.front();\\n        int v = qe.v;\\n        if (v == N - 1)\\n            break;\\n        q.pop();\\n        for (int j = v + 1; j <= (v + 6) && j < N; ++j) {\\n            if (!visited[j]) {\\n\\n                queueEntry a;\\n                a.dist = (qe.dist + 1);\\n                visited[j] = true;\\n                if (move[j] != -1)\\n                    a.v = move[j];\\n                else\\n                    a.v = j;\\n                q.push(a);\\n            }\\n        }\\n    }\\n    return qe.dist;\\n}\\n\\nint main() {\\n    int N = 30;\\n    int moves[N];\\n    for (int i = 0; i < N; i++)\\n        moves[i] = -1;\\n\\n    // Ladders \\n    moves[2] = 21;\\n    moves[4] = 7;\\n    moves[10] = 25;\\n    moves[19] = 28;\\n\\n    // Snakes \\n    moves[26] = 0;\\n    moves[20] = 8;\\n    moves[16] = 3;\\n    moves[18] = 6;\\n\\n    cout << \\"Min Dice throws required is \\" << getMinDiceThrows(moves, N);\\n    return 0;\\n}\\n","py":"class QueueEntry(object): \\n    def __init__(self, v=0, dist=0): \\n        self.v = v \\n        self.dist = dist \\ndef getMinDiceThrows(move, N): \\n    visited = [False] * N \\n    queue = [] \\n    visited[0] = True\\n    queue.append(QueueEntry(0, 0)) \\n    qe = QueueEntry() \\n    while queue: \\n        qe = queue.pop(0) \\n        v = qe.v \\n        if v == N - 1: \\n            break\\n        j = v + 1\\n        while j <= v + 6 and j < N: \\n            if visited[j] is False: \\n                a = QueueEntry() \\n                a.dist = qe.dist + 1\\n                visited[j] = True\\n                a.v = move[j] if move[j] != -1 else j \\n                queue.append(a) \\n            j += 1\\n    return qe.dist \\nN = 30\\nmoves = [-1] * N \\n\\n# Ladders \\nmoves[2] = 21\\nmoves[4] = 7\\nmoves[10] = 25\\nmoves[19] = 28\\n\\n# Snakes \\nmoves[26] = 0\\nmoves[20] = 8\\nmoves[16] = 3\\nmoves[18] = 6\\n\\nprint(\\"Min Dice throws required is {0}\\". \\n      format(getMinDiceThrows(moves, N))) \\n","orden":8,"suborden":36,"fecha_creacion":"2020-12-06 19:51:46","fecha_modificacion":"2022-03-08 12:28:52"},{"ID":233,"supergrupo":"Grafos","tema":"Camino m\xe1s corto desde m\xfaltiples or\xedgenes","texto":"Suponga que hay n ciudades conectadas por m caminos bidireccionales. Entre ellos hay varios pueblos con una comisar\xeda. Queremos saber la distancia de cada pueblo a la comisar\xeda m\xe1s cercana. Si el pueblo tiene uno, la distancia es 0.\\nEjemplo:\\nEntrada:\\nN\xfamero de v\xe9rtices = 6\\nN\xfamero de aristas = 9\\nLocalidades con Comisar\xeda: 1, 5\\nAristas:\\n1 2\\n1 6\\n2 6\\n2 3\\n3 6\\n5 4\\n6 5\\n3 4\\n5 3\\n\\n \\nSalida:\\n1 0\\n2 1\\n3 1\\n4 1\\n5 0\\n6 1\\n \\nEnfoque ingenuo: podemos recorrer los v\xe9rtices y desde cada v\xe9rtice ejecutar un BFS para encontrar la ciudad m\xe1s cercana con la estaci\xf3n de polic\xeda de ese v\xe9rtice. Esto tomar\xe1 O (V.E).\\n\\nM\xe9todo eficiente Un m\xe9todo mejor es utilizar el algoritmo de Djikstra de forma modificada. Consideremos una de las fuentes como la fuente original y las otras fuentes como v\xe9rtices con 0 rutas de costo desde la fuente original. Por lo tanto, empujamos todas las fuentes a la cola de Djikstra con distancia = 0 y el resto de los v\xe9rtices con distancia = infinito. La distancia m\xednima de cada v\xe9rtice desde la fuente original ahora calculada usando el algoritmo de Dijkstra son ahora esencialmente las distancias desde la fuente m\xe1s cercana.\\n\\nExplicaci\xf3n: La implementaci\xf3n utiliza un conjunto de pares (distancia desde la fuente, v\xe9rtice) ordenados seg\xfan la distancia desde la fuente. Inicialmente, el conjunto contiene las fuentes con distancia = 0 y todos los dem\xe1s v\xe9rtices con distancia = infinito.\\nEn cada paso, iremos al v\xe9rtice con distancia m\xednima (d) desde la fuente, es decir, el primer elemento del conjunto (la propia fuente en el primer paso con distancia = 0). Pasamos por todos sus v\xe9rtices adyacentes y si la distancia de cualquier v\xe9rtice es> d + 1 reemplazamos su entrada en el conjunto con la nueva distancia. Luego eliminamos el v\xe9rtice actual del conjunto. Continuamos esto hasta que el conjunto est\xe9 vac\xedo.\\nLa idea es que no puede haber una ruta m\xe1s corta al v\xe9rtice en la parte delantera del conjunto que la actual, ya que cualquier otra ruta ser\xe1 la suma de una ruta m\xe1s larga (> = su longitud) y una longitud de ruta no negativa (a menos que est\xe1n considerando aristas negativos).\\nDado que todas las fuentes tienen una distancia = 0, al principio, los v\xe9rtices adyacentes que no son fuentes obtendr\xe1n una distancia = 1. Todos los v\xe9rtices obtendr\xe1n distancia = distancia desde su fuente m\xe1s cercana.\\n\\nEnfoque m\xe1s eficiente: Un m\xe9todo a\xfan mejor es usar el BFS de m\xfaltiples fuentes, que es una modificaci\xf3n de BFS. Pondremos todos los v\xe9rtices de origen en la cola al principio en lugar de un solo v\xe9rtice que era en el caso de BFS est\xe1ndar. primero visitar\xe1 todos los v\xe9rtices de origen. Despu\xe9s de eso, visitar\xe1 los v\xe9rtices que est\xe1n a una distancia de 1 de todos los v\xe9rtices de origen, luego a una distancia de 2 de todos los v\xe9rtices de origen, y as\xed sucesivamente.\\n\\n","complejidad_tiempo":null,"java":"// Programa para demostrar BFS de m\xfaltiples fuentes\\n\\nimport java.util.ArrayList;\\nimport java.util.Arrays;\\nimport java.util.LinkedList;\\n\\npublic class MultiSourceSPUnweighted {\\n\\n    static final int N = 1000000;\\n    // Esta matriz almacena las distancias de los \\n    // v\xe9rtices desde la fuente m\xe1s cercana.\\n    static int dist[] = new int[N];\\n    // Esta matriz booleana es verdadera si se visita el \\n    // v\xe9rtice actual; de lo contrario, es falsa\\n    static boolean visited[] = new boolean[N];\\n\\n    static void addEdge(ArrayList<Integer> graph[], int u, int v) {\\n        // Funci\xf3n para agregar 2 aristas en un gr\xe1fico no dirigido\\n        graph[u].add(v);\\n        graph[v].add(u);\\n    }\\n\\n    // Funci\xf3n BFS de m\xfaltiples fuentes\\n    static void Multisource_BFS(ArrayList<Integer> graph[], LinkedList<Integer> q) {\\n        while (!q.isEmpty()) {\\n            int k = q.getFirst();\\n            q.pollFirst();\\n            for (Integer i : graph[k]) {\\n                if (!visited[i]) {\\n                    // Empujar los v\xe9rtices adyacentes no visitados con la \\n                    // distancia de la fuente actual = la distancia de este v\xe9rtice + 1\\n                    q.push(i);\\n                    dist[i] = dist[k] + 1;\\n                    visited[i] = true;\\n                }\\n            }\\n        }\\n    }\\n\\n    // Esta funci\xf3n calcula la distancia de cada v\xe9rtice desde la fuente m\xe1s cercana\\n    static void nearestTown(ArrayList<Integer> graph[], int n, int sources[], int s) {\\n        // Crea una cola para BFS \\n        LinkedList<Integer> q = new LinkedList<>();\\n        // Marque todos los v\xe9rtices de origen como visitados y col\xf3quelos\\n        for (int i = 0; i < s; i++) {\\n            q.push(sources[i]);\\n            visited[sources[i]] = true;\\n        }\\n        Multisource_BFS(graph, q);\\n        // Imprimiendo las distancias\\n        for (int i = 1; i <= n; i++) {\\n            System.out.println(i + \\" \\" + dist[i]);\\n        }\\n    }\\n\\n    public static void main(String[] args) {\\n        // N\xfamero de v\xe9rtices\\n        int n = 6;\\n        ArrayList<Integer> graph[] = new ArrayList[n + 1];\\n        Arrays.fill(graph, new ArrayList<>());\\n        // Caminos \\n        addEdge(graph, 1, 2);\\n        addEdge(graph, 1, 6);\\n        addEdge(graph, 2, 6);\\n        addEdge(graph, 2, 3);\\n        addEdge(graph, 3, 6);\\n        addEdge(graph, 5, 4);\\n        addEdge(graph, 6, 5);\\n        addEdge(graph, 3, 4);\\n        addEdge(graph, 5, 3);\\n        // Origenes\\n        int sources[] = {1, 5};\\n        int S = sources.length;\\n        nearestTown(graph, n, sources, S);\\n    }\\n}\\n","cpp":"#include<bits/stdc++.h> \\nusing namespace std;\\n#define N 1000000 \\n\\nint dist[N];\\nbool visited[N];\\n\\nvoid addEdge(vector<int> graph[], int u, int v) {\\n    graph[u].push_back(v);\\n    graph[v].push_back(u);\\n}\\n\\nvoid Multisource_BFS(vector<int> graph[], queue<int>q) {\\n    while (!q.empty()) {\\n        int k = q.front();\\n        q.pop();\\n\\n        for (auto i : graph[k]) {\\n            if (!visited[i]) {\\n                q.push(i);\\n                dist[i] = dist[k] + 1;\\n                visited[i] = true;\\n            }\\n        }\\n    }\\n}\\n\\nvoid nearestTown(vector<int> graph[], int n, int sources[], int s) {\\n    queue<int> q;\\n    for (int i = 0; i < s; i++) {\\n        q.push(sources[i]);\\n        visited[sources[i]] = true;\\n    }\\n    Multisource_BFS(graph, q);\\n    for (int i = 1; i <= n; i++) {\\n        cout << i << \\" \\" << dist[i] << endl;\\n    }\\n\\n}\\n\\nint main() {\\n    int n = 6;\\n    vector<int> graph[n + 1];\\n    addEdge(graph, 1, 2);\\n    addEdge(graph, 1, 6);\\n    addEdge(graph, 2, 6);\\n    addEdge(graph, 2, 3);\\n    addEdge(graph, 3, 6);\\n    addEdge(graph, 5, 4);\\n    addEdge(graph, 6, 5);\\n    addEdge(graph, 3, 4);\\n    addEdge(graph, 5, 3);\\n    int sources[] = {1, 5};\\n    int S = sizeof (sources) / sizeof (sources[0]);\\n    nearestTown(graph, n, sources, S);\\n    return 0;\\n}\\n","py":"N = 1000000\\ndist = [0 for _ in range (N)]\\nvisited = [0 for _ in range (N)]\\n\\ndef addEdge(graph, u, v):\\n    graph[u].append(v)\\n    graph[v].append(u)\\n\\ndef multisourceBFS(graph, q):\\n    while (len(q) != 0):\\n        k = q[0]\\n        q = q[1:]\\n        for i in graph[k]:\\n            if (visited[i] == False):\\n                q.append(i)\\n                dist[i] = dist[k] + 1\\n                visited[i] = True\\n  \\ndef nearestTown(graph, n, sources, s):\\n    q = []\\n    for i in range(s):\\n        q.append(sources[i])\\n        visited[sources[i]] = True\\n    multisourceBFS(graph, q)\\n    for i in range (1, n + 1):\\n        print(str(i) + \\" \\" + str(dist[i]))\\n        \\n        \\nn = 6\\ngraph = [[] for _ in range (n + 1)]\\naddEdge(graph, 1, 2);\\naddEdge(graph, 1, 6);\\naddEdge(graph, 2, 6);\\naddEdge(graph, 2, 3);\\naddEdge(graph, 3, 6);\\naddEdge(graph, 5, 4);\\naddEdge(graph, 6, 5);\\naddEdge(graph, 3, 4);\\naddEdge(graph, 5, 3);\\nsources = [1, 5]\\nS = len(sources)\\nnearestTown(graph, n, sources, S);\\n","orden":8,"suborden":37,"fecha_creacion":"2020-12-06 19:51:46","fecha_modificacion":"2022-03-08 12:28:52"},{"ID":234,"supergrupo":"Grafos","tema":"Camino m\xe1s corto en un grafo multi etapas","texto":"Un gr\xe1fico de etapas m\xfaltiples es un gr\xe1fico dirigido en el que los nodos se pueden dividir en un conjunto de etapas de modo que todos las aristas sean de una etapa a la siguiente solo (en otras palabras, no hay arista entre los v\xe9rtices de la misma etapa y desde un v\xe9rtice de la corriente etapa a etapa anterior).\\nNos dan un gr\xe1fico de varias etapas, una fuente y un destino, necesitamos encontrar la ruta m\xe1s corta desde la fuente hasta el destino. Por convenci\xf3n, consideramos el origen en la etapa 1 y el destino como \xfaltima etapa.\\nA continuaci\xf3n se muestra un gr\xe1fico de ejemplo\\n \\nAhora hay varias estrategias que podemos aplicar: -\\n\u2022 El m\xe9todo de fuerza bruta para encontrar todos los caminos posibles entre el origen y el destino y luego encontrar el m\xednimo. Esa es la PEOR estrategia posible.\\n\u2022 Algoritmo de Dijkstra de rutas m\xe1s cortas de fuente \xfanica. Este m\xe9todo encontrar\xe1 las rutas m\xe1s cortas desde la fuente a todos los dem\xe1s nodos, lo que no es necesario en este caso. Por lo tanto, llevar\xe1 mucho tiempo y ni siquiera utiliza la funci\xf3n ESPECIAL que tiene este gr\xe1fico MULTI-ETAPA.\\n\u2022 M\xe9todo codicioso simple: en cada nodo, elija la ruta de salida m\xe1s corta. Si aplicamos este enfoque al gr\xe1fico de ejemplo anterior, obtenemos la soluci\xf3n como 1 + 4 + 18 = 23. Pero un vistazo r\xe1pido al gr\xe1fico mostrar\xe1 caminos mucho m\xe1s cortos disponibles que 23. \xa1Entonces el m\xe9todo codicioso falla!\\n\u2022 La mejor opci\xf3n es la Programaci\xf3n din\xe1mica. Por lo tanto, debemos encontrar la subestructura \xf3ptima, las ecuaciones recursivas y los subproblemas superpuestos.\\nSubestructura \xf3ptima y ecuaci\xf3n recursiva: -\\n\\nDefinimos la notaci\xf3n: - M (x, y) como el costo m\xednimo para T (nodo objetivo) de la Etapa x, Nodo y.\\n\\nDistancia m\xe1s corta desde la etapa 1, nodo 0 a\\ndestino, es decir, 7 es M (1, 0).\\n\\n// De 0, podemos pasar a 1 o 2 o 3 a\\n// llegar a 7.\\nM (1, 0) = m\xednimo (1 + M (2, 1),\\n              2 + M (2, 2),\\n              5 + M (2, 3))\\nEsto significa que nuestro problema de 0 -> 7 ahora se subdivide en 3 subproblemas: -\\nEntonces, si tenemos un total de \'n\' etapas y el objetivo\\ncomo T, entonces la condici\xf3n de parada ser\xe1: -\\nM (n-1, yo) = yo ---\x3e T + M (n, T) = yo ---\x3e T\\n\xc1rbol de recursividad y subproblemas superpuestos: -\\nEntonces, la jerarqu\xeda de evaluaciones M (x, y) se ver\xe1 as\xed: -\\nEn M (i, j), i es el n\xfamero de etapa y\\nj es el n\xfamero de nodo\\n\\n                   M (1, 0)\\n           / | \\\\\\n          / | \\\\\\n       M (2, 1) M (2, 2) M (2, 3)\\n    / \\\\ / \\\\ / \\\\\\nM (3, 4) M (3, 5) M (3, 4) M (3, 5) M (3, 6) M (3, 6)\\n . . . . . .\\n . . . . . .\\n . . . . . .\\nEntonces, aqu\xed hemos dibujado una parte muy peque\xf1a del \xe1rbol de recursividad y ya podemos ver subproblemas superpuestos. Podemos reducir en gran medida el n\xfamero de evaluaciones M (x, y) mediante la programaci\xf3n din\xe1mica.\\nDetalles de implementacion:\\nLa siguiente implementaci\xf3n asume que los nodos est\xe1n numerados de 0 a N-1 desde la primera etapa (origen) hasta la \xfaltima etapa (destino). Tambi\xe9n asumimos que el gr\xe1fico de entrada es de varias etapas.\\n","complejidad_tiempo":null,"java":"// Programa Java para encontrar la distancia m\xe1s \\n// corta en un gr\xe1fico de varias etapas.\\n\\npublic class MultiStageGraphSP {\\n\\n    static int N = 8;\\n    static int INF = Integer.MAX_VALUE;\\n\\n    // Devuelve la distancia m\xe1s corta de 0 a N-1.\\n    public static int shortestDist(int[][] graph) {\\n        // dist [i] va a almacenar la distancia m\xe1s corta del nodo i al nodo N-1.\\n        int[] dist = new int[N];\\n        dist[N - 1] = 0;\\n\\n        // Calcular la ruta m\xe1s corta para el resto de los nodos\\n        for (int i = N - 2; i >= 0; i--) {\\n\\n            // Inicializar la distancia desde i hasta el destino (N-1)\\n            dist[i] = INF;\\n\\n            // Compruebe todos los nodos de las siguientes etapas \\n            // para encontrar la distancia m\xe1s corta de i a N-1.\\n            for (int j = i; j < N; j++) {\\n                // Rechazar si no existe camino\\n                if (graph[i][j] == INF) {\\n                    continue;\\n                }\\n                // Aplicamos la ecuaci\xf3n recursiva a la distancia al objetivo a \\n                // trav\xe9s de j. y compare con la distancia m\xednima hasta ahora.\\n                dist[i] = Math.min(dist[i], graph[i][j]\\n                        + dist[j]);\\n            }\\n        }\\n\\n        return dist[0];\\n    }\\n\\n    public static void main(String[] args) {\\n        // Gr\xe1fico almacenado en forma de matriz de adyacencia\\n        int[][] graph = new int[][]{\\n            {INF, 1, 2, 5, INF, INF, INF, INF},\\n            {INF, INF, INF, INF, 4, 11, INF, INF},\\n            {INF, INF, INF, INF, 9, 5, 16, INF},\\n            {INF, INF, INF, INF, INF, INF, 2, INF},\\n            {INF, INF, INF, INF, INF, INF, INF, 18},\\n            {INF, INF, INF, INF, INF, INF, INF, 13},\\n            {INF, INF, INF, INF, INF, INF, INF, 2}};\\n\\n        System.out.println(shortestDist(graph));\\n    }\\n}\\n","cpp":"#include<bits/stdc++.h> \\nusing namespace std;\\n#define N 8\\n#define INF INT_MAX\\n\\nint shortestDist(int graph[7][8]) {\\n    int dist [N];\\n    dist[N - 1] = 0;\\n\\n    for (int i = N - 2; i >= 0; i--) {\\n        dist[i] = INF;\\n        for (int j = i; j < N; j++) {\\n            if (graph[i][j] == INF) {\\n                continue;\\n            }\\n            dist[i] = min(dist[i], graph[i][j]\\n                    + dist[j]);\\n        }\\n    }\\n    return dist[0];\\n}\\n\\nint main() {\\n    int graph[7][8] = {\\n        {INF, 1, 2, 5, INF, INF, INF, INF},\\n        {INF, INF, INF, INF, 4, 11, INF, INF},\\n        {INF, INF, INF, INF, 9, 5, 16, INF},\\n        {INF, INF, INF, INF, INF, INF, 2, INF},\\n        {INF, INF, INF, INF, INF, INF, INF, 18},\\n        {INF, INF, INF, INF, INF, INF, INF, 13},\\n        {INF, INF, INF, INF, INF, INF, INF, 2}\\n    };\\n\\n    cout << shortestDist(graph) << endl;\\n    return 0;\\n}\\n","py":"N=8\\nINF=1<<32\\ndef shortestDist(graph):\\n    dist=[0 for i in range (N)]\\n    dist[N - 1] = 0\\n    for i in range (N-2,-1,-1):\\n        dist[i] = INF\\n        for j in range (N):\\n            if (graph[i][j] == INF):\\n                continue\\n            dist[i] = min(dist[i], graph[i][j]+ dist[j])\\n    return dist[0]\\n\\n\\ngraph= [\\n    [INF, 1, 2, 5, INF, INF, INF, INF],\\n    [INF, INF, INF, INF, 4, 11, INF, INF],\\n    [INF, INF, INF, INF, 9, 5, 16, INF],\\n    [INF, INF, INF, INF, INF, INF, 2, INF],\\n    [INF, INF, INF, INF, INF, INF, INF, 18],\\n    [INF, INF, INF, INF, INF, INF, INF, 13],\\n    [INF, INF, INF, INF, INF, INF, INF, 2]];\\nprint(shortestDist(graph))\\n","orden":8,"suborden":38,"fecha_creacion":"2020-12-06 19:51:47","fecha_modificacion":"2022-03-08 12:28:52"},{"ID":235,"supergrupo":"Grafos","tema":"Camino mas corto de k aristas","texto":"Dada una direcci\xf3n y dos v\xe9rtices \\"u\\" y \\"v\\" en ella, encuentre la ruta m\xe1s corta de \\"u\\" a \\"v\\" con exactamente k aristas en la ruta.\\nEl gr\xe1fico se da como representaci\xf3n de matriz de adyacencia donde el valor del gr\xe1fico [i] [j] indica el peso de una arista desde el v\xe9rtice i hasta el v\xe9rtice j y un valor INF (infinito) indica que no hay arista de i a j.\\n \\nLa idea es navegar a trav\xe9s de todas las rutas de longitud k desde u hasta v utilizando el enfoque discutido en la publicaci\xf3n anterior y devolver el peso de la ruta m\xe1s corta. Una soluci\xf3n simple es comenzar desde u, ir a todos los v\xe9rtices adyacentes y repetir para los v\xe9rtices adyacentes con k como k-1, origen como v\xe9rtice adyacente y destino como v.\\n\\nLa complejidad de tiempo del peor caso de la funci\xf3n anterior es O (Vk) donde V es el n\xfamero de v\xe9rtices en el gr\xe1fico dado. Simplemente podemos analizar la complejidad del tiempo dibujando un \xe1rbol de recursividad. Lo peor ocurre para un gr\xe1fico completo. En el peor de los casos, cada nodo interno del \xe1rbol de recursividad tendr\xeda exactamente V hijos.\\nPodemos optimizar la soluci\xf3n anterior mediante la programaci\xf3n din\xe1mica. La idea es construir una tabla 3D donde la primera dimensi\xf3n es la fuente, la segunda dimensi\xf3n es el destino, la tercera dimensi\xf3n es el n\xfamero de aristas desde el origen hasta el destino y el valor es el recuento de paseos. Al igual que otros problemas de programaci\xf3n din\xe1mica, llenamos la tabla 3D de abajo hacia arriba.\\nLa complejidad temporal de la soluci\xf3n basada en DP anterior es O (V3K), que es mucho mejor que la soluci\xf3n ingenua.\\n","complejidad_tiempo":null,"java":"// Programa Java basado en programaci\xf3n din\xe1mica para encontrar \\n// la ruta m\xe1s corta con exactamente k caminos\\n\\npublic class ShortestPathKEdges {\\n    // Definir n\xfamero de v\xe9rtices en el gr\xe1fico y valor no finito\\n\\n    static final int V = 4;\\n    static final int INF = Integer.MAX_VALUE;\\n\\n    // Una funci\xf3n recursiva ingenua para contar paseos de u a v con k aristas\\n    static int shortestPath(int graph[][], int u, int v, int k) {\\n        // Casos base\\n        if (k == 0 && u == v) {\\n            return 0;\\n        }\\n        if (k == 1 && graph[u][v] != INF) {\\n            return graph[u][v];\\n        }\\n        if (k <= 0) {\\n            return INF;\\n        }\\n\\n        // Inicializar resultado\\n        int res = INF;\\n\\n        // Ir a todos los adyacentes de u y repetir\\n        for (int i = 0; i < V; i++) {\\n            if (graph[u][i] != INF && u != i && v != i) {\\n                int rec_res = shortestPath(graph, i, v, k - 1);\\n                if (rec_res != INF) {\\n                    res = Math.min(res, graph[u][i] + rec_res);\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n\\n    public static void main(String[] args) {\\n        /* Creemos el grafo que se muestra en el diagrama anterior.*/\\n        int graph[][] = new int[][]{{0, 10, 3, 2},\\n        {INF, 0, INF, 7},\\n        {INF, INF, 0, 6},\\n        {INF, INF, INF, 0}\\n        };\\n        int u = 0, v = 3, k = 2;\\n        System.out.println(\\"Weight of the shortest path is \\"\\n                + shortestPath(graph, u, v, k));\\n    }\\n}\\n","cpp":"#include <bits/stdc++.h> \\nusing namespace std;\\n\\n#define V 4 \\n#define INF INT_MAX \\n\\nint shortestPath(int graph[][V], int u, int v, int k) {\\n    if (k == 0 && u == v) return 0;\\n    if (k == 1 && graph[u][v] != INF) return graph[u][v];\\n    if (k <= 0) return INF;\\n    int res = INF;\\n    for (int i = 0; i < V; i++) {\\n        if (graph[u][i] != INF && u != i && v != i) {\\n            int rec_res = shortestPath(graph, i, v, k - 1);\\n            if (rec_res != INF)\\n                res = min(res, graph[u][i] + rec_res);\\n        }\\n    }\\n    return res;\\n}\\n\\nint main() {\\n    int graph[V][V] = {\\n        {0, 10, 3, 2},\\n        {INF, 0, INF, 7},\\n        {INF, INF, 0, 6},\\n        {INF, INF, INF, 0}\\n    };\\n    int u = 0, v = 3, k = 2;\\n    cout << \\"Weight of the shortest path is \\" <<\\n            shortestPath(graph, u, v, k);\\n    return 0;\\n}\\n","py":"def shortestPath(graph, u, v, k): \\n    V = 4\\n    INF = 999999999999\\n    if k == 0 and u == v: \\n        return 0\\n    if k == 1 and graph[u][v] != INF: \\n        return graph[u][v] \\n    if k <= 0: \\n        return INF \\n    res = INF \\n    for i in range(V): \\n        if graph[u][i] != INF and u != i and v != i: \\n            rec_res = shortestPath(graph, i, v, k - 1) \\n            if rec_res != INF: \\n                res = min(res, graph[u][i] + rec_res) \\n    return res \\n\\n\\nINF = 999999999999\\ngraph = [[0, 10, 3, 2], \\n    [INF, 0, INF, 7], \\n    [INF, INF, 0, 6], \\n    [INF, INF, INF, 0]] \\nu = 0\\nv = 3\\nk = 2\\nprint(\\"Weight of the shortest path is\\", \\n      shortestPath(graph, u, v, k)) \\n","orden":8,"suborden":39,"fecha_creacion":"2020-12-06 19:51:47","fecha_modificacion":"2022-03-08 12:28:52"},{"ID":236,"supergrupo":"Grafos","tema":"Algoritmo de Trajano, componentes fuertemente conexas","texto":"Un grafo dirigido est\xe1 fuertemente conectado si hay una ruta entre todos los pares de v\xe9rtices. Un componente fuertemente conectado (SCC strongly conected component) de un gr\xe1fico dirigido es un subgr\xe1fico m\xe1ximo fuertemente conectado. Por ejemplo, hay 3 SCC en el siguiente gr\xe1fico.\\n \\nEl algoritmo de Kosaraju para componentes fuertemente conectados dos recorridos DFS de un gr\xe1fico, el algoritmo de Tarjan requiere solo un recorrido DFS.\\nEl algoritmo de Tarjan se basa en los siguientes hechos:\\n1. La b\xfasqueda DFS produce un \xe1rbol / bosque DFS\\n2. Los componentes fuertemente conectados forman sub\xe1rboles del \xe1rbol DFS.\\n3. Si podemos encontrar el encabezado de tales sub\xe1rboles, podemos imprimir / almacenar todos los nodos en ese sub\xe1rbol (incluido el encabezado) y ese ser\xe1 un SCC.\\n4. No hay arista posterior de un SCC a otro (puede haber aristas transversales, pero las aristas transversales no se utilizar\xe1n al procesar el gr\xe1fico).\\nPara encontrar la cabeza de un SCC, calculamos el disco y la matriz baja (como se hizo para el punto de articulaci\xf3n, puente, componente biconectado). Como se discuti\xf3 en las publicaciones anteriores, bajo [u] indica el v\xe9rtice visitado m\xe1s temprano (el v\xe9rtice con el tiempo m\xednimo de descubrimiento) que se puede alcanzar desde el sub\xe1rbol enraizado con u. Un nodo u es cabeza si disc[u] = low[u].\\n\\nEl componente fuertemente conectado se relaciona solo con el gr\xe1fico dirigido, pero los valores de disc y low se relacionan con el gr\xe1fico dirigido y no dirigido, por lo que en la imagen anterior hemos tomado un gr\xe1fico no dirigido.\\nEn la Figura anterior, hemos mostrado un gr\xe1fico y su \xe1rbol DFS (podr\xeda haber diferentes \xe1rboles DFS en el mismo gr\xe1fico dependiendo del orden en que se atraviesan las aristas).\\nEn el \xe1rbol DFS, las flechas continuas son las aristas del \xe1rbol y las flechas punteadas son las aristas posteriores (DFS Tree Edges\\nLos valores de disc y low se muestran en la Figura para cada nodo como (disc / low).\\ndisc: este es el momento en que se visita un nodo por primera vez durante el recorrido DFS. Para los nodos A, B, C, .., J en el \xe1rbol DFS, los valores del disc son 1, 2, 3, .., 10.\\nlow: en el \xe1rbol DFS, las aristas del \xe1rbol nos llevan hacia adelante, desde el nodo ancestro hasta uno de sus descendientes. Por ejemplo, desde el nodo C, las aristas del \xe1rbol pueden llevarnos al nodo G, al nodo I, etc. Las aristas posteriores nos llevan hacia atr\xe1s, desde un nodo descendiente a uno de sus antepasados. Por ejemplo, desde el nodo G, las aristas posteriores nos llevan a E o C. Si miramos el \xe1rbol y la arista posterior juntos, entonces podemos ver que si comenzamos el recorrido desde un nodo, podemos bajar por el \xe1rbol a trav\xe9s de las aristas del \xe1rbol y luego sube por las aristas traseras. \\n\\nPor ejemplo, desde el nodo E, podemos bajar a G y luego subir a C. De manera similar, desde E, podemos bajar a I o J y luego subir a F. El valor \\"low\\" de un nodo indica el nivel m\xe1s alto alcanzable ancestro (con el valor de disc m\xednimo posible) a trav\xe9s del sub\xe1rbol de ese nodo. Entonces, para cualquier nodo, el valor low es igual a su valor de disc de todos modos (un nodo es antepasado de s\xed mismo). Luego miramos en su sub\xe1rbol y vemos si hay alg\xfan nodo que pueda llevarnos a alguno de sus ancestros. Si hay varias aristas posteriores en el sub\xe1rbol que nos llevan a diferentes ancestros, entonces tomamos el que tiene el valor m\xednimo de disc (es decir, el m\xe1s alto). Si miramos el nodo F, tiene dos sub\xe1rboles. El sub\xe1rbol con el nodo G, nos lleva a E y C. El otro sub\xe1rbol nos lleva de regreso a F solamente. Aqu\xed, el antepasado m\xe1s alto es C, donde F puede alcanzar y, por lo tanto, el valor low de F es 3 (el valor del disc de C).\\nCon base en la discusi\xf3n anterior, debe quedar claro que los valores lows de B, C y D son 1 (ya que A es el nodo m\xe1s alto al que pueden llegar B, C y D). De la misma manera, los valores lows de E, F, G son 3 y los valores lows de H, I, J son 6.\\nPara cualquier nodo u, cuando se inicia DFS, Low se establecer\xe1 en su disc 1st.\\nLuego, m\xe1s adelante, DFS se realizar\xe1 en cada uno de sus hijos v uno por uno, el valor low de u puede cambiarlo en dos casos:\\nCaso1 (arista del \xe1rbol): Si el nodo v a\xfan no se ha visitado, luego de que se complete la DFS de v, el m\xednimo de low [u] y low [v] se actualizar\xe1 a low [u].\\nlow [u] = min (low [u], low [v]);\\nCaso 2 (arista posterior): cuando ya se ha visitado el ni\xf1o v, el m\xednimo de low [u] y el disc [v] se actualizar\xe1n a low [u].\\nlow [u] = min (low [u], disc [v]);\\nEn el caso dos, \xbfpodemos tomar low [v] en lugar del disc [v]? . La respuesta es NO. Si puede pensar por qu\xe9 la respuesta es NO, probablemente haya entendido el concepto Low and Disc.\\n\\nLos mismos valores Low y Disc ayudan a resolver otros problemas de gr\xe1ficos como el punto de articulaci\xf3n, el puente y el componente biconectado.\\nPara rastrear el sub\xe1rbol enraizado en la cabecera, podemos usar una pila (siga presionando el nodo mientras visita). Cuando se encuentre un nodo principal, saque todos los nodos de la pila hasta que salga de la pila.\\nPara asegurarnos, no consideramos las aristas cruzadas, cuando llegamos a un nodo que ya est\xe1 visitado, debemos procesar el nodo visitado solo si est\xe1 presente en la pila; de lo contrario, ignore el nodo.\\n","complejidad_tiempo":null,"java":"// Programa Java para encontrar componentes fuertemente conectados en un \\n// grafo dirigido dado utilizando el algoritmo de Tarjan (DFS \xfanico)\\n\\nimport java.util.*;\\n\\npublic class TarjanStronglyConnectedComponents {\\n\\n    // Esta clase representa un gr\xe1fico dirigido \\n    // utilizando la representaci\xf3n de lista de adyacencia. \\n    static class Graph {\\n\\n        // No de v\xe9rtices \\n        private int V;\\n\\n        //Listas de adyacencia\\n        private LinkedList<Integer> adj[];\\n        private int Time;\\n\\n        Graph(int v) {\\n            V = v;\\n            adj = new LinkedList[v];\\n\\n            for (int i = 0; i < v; ++i) {\\n                adj[i] = new LinkedList();\\n            }\\n\\n            Time = 0;\\n        }\\n\\n        // Funci\xf3n para agregar una arista al gr\xe1fico\\n        void addEdge(int v, int w) {\\n            adj[v].add(w);\\n        }\\n\\n        // Una funci\xf3n recursiva que encuentra e imprime componentes \\n        // fuertemente conectados usando DFS transversal\\n        // u -> El v\xe9rtice a visitar a continuaci\xf3n\\n        // disc[] -> Almacena los tiempos de descubrimiento \\n        // de los v\xe9rtices visitados\\n        // low[] - >> v\xe9rtice visitado m\xe1s temprano (el v\xe9rtice con tiempo \\n        // m\xednimo de descubrimiento) que se puede alcanzar desde el \\n        // sub\xe1rbol enraizado con el v\xe9rtice actual\\n        // st - >> Para almacenar todos los ancestros \\n        // conectados (podr\xeda ser parte de SCC)\\n        // stackMember [] -> matriz de bits / \xedndices para \\n        // comprobar m\xe1s r\xe1pidamente si un nodo est\xe1 en la pila\\n        void SCCUtil(int u, int low[], int disc[],\\n                boolean stackMember[],\\n                Stack<Integer> st) {\\n\\n            // Inicializar el tiempo de descubrimiento y el valor bajo \\n            disc[u] = Time;\\n            low[u] = Time;\\n            Time += 1;\\n            stackMember[u] = true;\\n            st.push(u);\\n            int n;\\n            // Pasa por todos los v\xe9rtices adyacentes a este\\n            Iterator<Integer> i = adj[u].iterator();\\n            while (i.hasNext()) {\\n                n = i.next();\\n                if (disc[n] == -1) {\\n                    SCCUtil(n, low, disc, stackMember, st);\\n                    // Compruebe si el sub\xe1rbol enraizado con v \\n                    // tiene una conexi\xf3n con uno de los antepasados de u\\n                    // Caso 1 (seg\xfan la discusi\xf3n anterior sobre Disc y Low value)  \\n                    low[u] = Math.min(low[u], low[n]);\\n                } else if (stackMember[n] == true) {\\n\\n                    // Actualice el valor bajo de \'u\' solo si \'v\' todav\xeda est\xe1 \\n                    // en la pila (es decir, es un borde posterior, \\n                    // no un borde transversal).\\n                    // Caso 2 (seg\xfan la discusi\xf3n anterior sobre Disc y Low value) \\n                    low[u] = Math.min(low[u], disc[n]);\\n                }\\n            }\\n\\n            // nodo principal encontrado, saque la pila e imprima un \\n            // SCC Para almacenar los v\xe9rtices extra\xeddos de la pila \\n            int w = -1;\\n            if (low[u] == disc[u]) {\\n                while (w != u) {\\n                    w = (int) st.pop();\\n                    System.out.print(w + \\" \\");\\n                    stackMember[w] = false;\\n                }\\n                System.out.println();\\n            }\\n        }\\n\\n        // La funci\xf3n para hacer un recorrido DFS. Utiliza SCCUtil ()\\n        void SCC() {\\n\\n            // Marque todos los v\xe9rtices como no visitados e Inicialice arrsys \\n            // parent y visited, y ap (punto de articulaci\xf3n)\\n            int disc[] = new int[V];\\n            int low[] = new int[V];\\n            for (int i = 0; i < V; i++) {\\n                disc[i] = -1;\\n                low[i] = -1;\\n            }\\n\\n            boolean stackMember[] = new boolean[V];\\n            Stack<Integer> st = new Stack<>();\\n\\n            // Llame a la funci\xf3n auxiliar recursiva para encontrar \\n            // puntos de articulaci\xf3n en el \xe1rbol DFS enraizado \\n            // con el v\xe9rtice \'i\'\\n            for (int i = 0; i < V; i++) {\\n                if (disc[i] == -1) {\\n                    SCCUtil(i, low, disc,\\n                            stackMember, st);\\n                }\\n            }\\n        }\\n\\n    }\\n\\n    public static void main(String args[]) {\\n        Graph g1 = new Graph(5);\\n        g1.addEdge(1, 0);\\n        g1.addEdge(0, 2);\\n        g1.addEdge(2, 1);\\n        g1.addEdge(0, 3);\\n        g1.addEdge(3, 4);\\n        System.out.println(\\"SSC in first graph \\");\\n        g1.SCC();\\n        Graph g2 = new Graph(4);\\n        g2.addEdge(0, 1);\\n        g2.addEdge(1, 2);\\n        g2.addEdge(2, 3);\\n        System.out.println(\\"\\\\nSSC in second graph \\");\\n        g2.SCC();\\n        Graph g3 = new Graph(7);\\n        g3.addEdge(0, 1);\\n        g3.addEdge(1, 2);\\n        g3.addEdge(2, 0);\\n        g3.addEdge(1, 3);\\n        g3.addEdge(1, 4);\\n        g3.addEdge(1, 6);\\n        g3.addEdge(3, 5);\\n        g3.addEdge(4, 5);\\n        System.out.println(\\"\\\\nSSC in third graph \\");\\n        g3.SCC();\\n        Graph g4 = new Graph(11);\\n        g4.addEdge(0, 1);\\n        g4.addEdge(0, 3);\\n        g4.addEdge(1, 2);\\n        g4.addEdge(1, 4);\\n        g4.addEdge(2, 0);\\n        g4.addEdge(2, 6);\\n        g4.addEdge(3, 2);\\n        g4.addEdge(4, 5);\\n        g4.addEdge(4, 6);\\n        g4.addEdge(5, 6);\\n        g4.addEdge(5, 7);\\n        g4.addEdge(5, 8);\\n        g4.addEdge(5, 9);\\n        g4.addEdge(6, 4);\\n        g4.addEdge(7, 9);\\n        g4.addEdge(8, 9);\\n        g4.addEdge(9, 8);\\n        System.out.println(\\"\\\\nSSC in fourth graph \\");\\n        g4.SCC();\\n        Graph g5 = new Graph(5);\\n        g5.addEdge(0, 1);\\n        g5.addEdge(1, 2);\\n        g5.addEdge(2, 3);\\n        g5.addEdge(2, 4);\\n        g5.addEdge(3, 0);\\n        g5.addEdge(4, 2);\\n        System.out.println(\\"\\\\nSSC in fifth graph \\");\\n        g5.SCC();\\n    }\\n}\\n","cpp":"#include<bits/stdc++.h>\\n#include <cstdlib>\\n#define MAX 99999\\n#define NIL -1\\nusing namespace std;\\nlist<int> adj[MAX];\\n\\nstruct Graph {\\n    int V;\\n\\n    void initGraph(int v) {\\n        for (int i = 0; i < v; i++) {\\n            adj[i].clear();\\n        }\\n    }\\n\\n    void addEdge(int v, int w) {\\n        adj[v].push_back(w);\\n    }\\n\\n    void SCCUtil(int u, int disc[], int low[], stack<int>& st, bool stackMember[]) {\\n        static int time = 0;\\n        disc[u] = low[u] = ++time;\\n        st.push(u);\\n        stackMember[u] = true;\\n        for (int i : adj[u]) {\\n            int v = i;\\n\\n            if (disc[v] == -1) {\\n                SCCUtil(v, disc, low, st, stackMember);\\n\\n\\n                low[u] = min(low[u], low[v]);\\n            }\\n\\n            else if (stackMember[v] == true) {\\n                low[u] = min(low[u], disc[v]);\\n            }\\n        }\\n        int w = 0;\\n        if (low[u] == disc[u]) {\\n            while (st.top() != u) {\\n                w = (int) st.top();\\n                cout << w << \\" \\";\\n                stackMember[w] = false;\\n                st.pop();\\n            }\\n            w = (int) st.top();\\n            cout << w << \\"\\\\n\\";\\n            stackMember[w] = false;\\n            st.pop();\\n        }\\n    }\\n\\n    void SCC() {\\n        int disc [V];\\n        int low [V];\\n        bool stackMember [V];\\n        stack<int> st;\\n\\n        for (int i = 0; i < V; i++) {\\n            disc[i] = NIL;\\n            low[i] = NIL;\\n            stackMember[i] = false;\\n        }\\n\\n        for (int i = 0; i < V; i++) {\\n            if (disc[i] == NIL) {\\n                SCCUtil(i, disc, low, st, stackMember);\\n            }\\n        }\\n    }\\n\\n};\\n\\nint main() {\\n    cout << \\"\\\\nSCCs in first graph \\\\n\\";\\n    Graph g1;\\n    g1.V = 5;\\n    g1.initGraph(5);\\n    g1.addEdge(1, 0);\\n    g1.addEdge(0, 2);\\n    g1.addEdge(2, 1);\\n    g1.addEdge(0, 3);\\n    g1.addEdge(3, 4);\\n    g1.SCC();\\n\\n    cout << \\"\\\\nSCCs in second graph \\\\n\\";\\n    Graph g2;\\n    g2.V = 4;\\n    g2.initGraph(4);\\n    g2.addEdge(0, 1);\\n    g2.addEdge(1, 2);\\n    g2.addEdge(2, 3);\\n    g2.SCC();\\n\\n    cout << \\"\\\\nSCCs in third graph \\\\n\\";\\n    Graph g3;\\n    g3.V = 7;\\n    g3.initGraph(7);\\n    g3.addEdge(0, 1);\\n    g3.addEdge(1, 2);\\n    g3.addEdge(2, 0);\\n    g3.addEdge(1, 3);\\n    g3.addEdge(1, 4);\\n    g3.addEdge(1, 6);\\n    g3.addEdge(3, 5);\\n    g3.addEdge(4, 5);\\n    g3.SCC();\\n\\n    cout << \\"\\\\nSCCs in fourth graph \\\\n\\";\\n    Graph g4;\\n    g4.V = 11;\\n    g4.initGraph(11);\\n    g4.addEdge(0, 1);\\n    g4.addEdge(0, 3);\\n    g4.addEdge(1, 2);\\n    g4.addEdge(1, 4);\\n    g4.addEdge(2, 0);\\n    g4.addEdge(2, 6);\\n    g4.addEdge(3, 2);\\n    g4.addEdge(4, 5);\\n    g4.addEdge(4, 6);\\n    g4.addEdge(5, 6);\\n    g4.addEdge(5, 7);\\n    g4.addEdge(5, 8);\\n    g4.addEdge(5, 9);\\n    g4.addEdge(6, 4);\\n    g4.addEdge(7, 9);\\n    g4.addEdge(8, 9);\\n    g4.addEdge(9, 8);\\n    g4.SCC();\\n\\n    cout << \\"\\\\nSCCs in fifth graph \\\\n\\";\\n    Graph g5;\\n    g5.V = 5;\\n    g5.initGraph(5);\\n    g5.addEdge(0, 1);\\n    g5.addEdge(1, 2);\\n    g5.addEdge(2, 3);\\n    g5.addEdge(2, 4);\\n    g5.addEdge(3, 0);\\n    g5.addEdge(4, 2);\\n    g5.SCC();\\n\\n    cout << \\"\\\\nSCCs in sixth graph \\\\n\\";\\n    Graph g6;\\n    g6.V = 5;\\n    g6.initGraph(5);\\n    g6.addEdge(2, 1);\\n    g6.addEdge(0, 2);\\n    g6.addEdge(1, 3);\\n    g6.addEdge(1, 2);\\n    g6.addEdge(2, 3);\\n    g6.addEdge(4, 2);\\n    g6.SCC();\\n\\n    cout << \\"\\\\nSCCs in seventh graph \\\\n\\";\\n    Graph g7;\\n    g7.V = 4;\\n    g7.initGraph(4);\\n    g7.addEdge(0, 1);\\n    g7.addEdge(1, 2);\\n    g7.addEdge(2, 3);\\n    g7.addEdge(0, 3);\\n    g7.addEdge(1, 0);\\n    g7.SCC();\\n\\n\\n    return 0;\\n}\\n","py":"from collections import defaultdict\\n \\n   \\nclass Graph: \\n   \\n    def __init__(self, vertices): \\n        self.V = vertices  \\n        self.graph = defaultdict(list)  \\n        self.Time = 0\\n  \\n    def addEdge(self, u, v): \\n        self.graph[u].append(v) \\n          \\n    def SCCUtil(self, u, low, disc, stackMember, st): \\n  \\n        disc[u] = self.Time \\n        low[u] = self.Time \\n        self.Time += 1\\n        stackMember[u] = True\\n        st.append(u) \\n        for v in self.graph[u]: \\n            if disc[v] == -1: \\n              \\n                self.SCCUtil(v, low, disc, stackMember, st) \\n \\n                low[u] = min(low[u], low[v]) \\n            elif stackMember[v] == True:  \\n                low[u] = min(low[u], disc[v]) \\n  \\n\\n        w = -1 \\n        if low[u] == disc[u]: \\n            while w != u: \\n                w = st.pop() \\n                print w, \\n                stackMember[w] = False\\n                  \\n            print\\"\\" \\n              \\n    def SCC(self): \\n        disc = [-1] * (self.V) \\n        low = [-1] * (self.V) \\n        stackMember = [False] * (self.V) \\n        st = [] \\n        for i in range(self.V): \\n            if disc[i] == -1: \\n                self.SCCUtil(i, low, disc, stackMember, st) \\n\\ng1 = Graph(5) \\ng1.addEdge(1, 0) \\ng1.addEdge(0, 2) \\ng1.addEdge(2, 1) \\ng1.addEdge(0, 3) \\ng1.addEdge(3, 4) \\nprint \\"SSC in first graph \\"\\ng1.SCC() \\n  \\ng2 = Graph(4) \\ng2.addEdge(0, 1) \\ng2.addEdge(1, 2) \\ng2.addEdge(2, 3) \\nprint \\"nSSC in second graph \\"\\ng2.SCC() \\n  \\n   \\ng3 = Graph(7) \\ng3.addEdge(0, 1) \\ng3.addEdge(1, 2) \\ng3.addEdge(2, 0) \\ng3.addEdge(1, 3) \\ng3.addEdge(1, 4) \\ng3.addEdge(1, 6) \\ng3.addEdge(3, 5) \\ng3.addEdge(4, 5) \\nprint \\"nSSC in third graph \\"\\ng3.SCC() \\n  \\ng4 = Graph(11) \\ng4.addEdge(0, 1) \\ng4.addEdge(0, 3) \\ng4.addEdge(1, 2) \\ng4.addEdge(1, 4) \\ng4.addEdge(2, 0) \\ng4.addEdge(2, 6) \\ng4.addEdge(3, 2) \\ng4.addEdge(4, 5) \\ng4.addEdge(4, 6) \\ng4.addEdge(5, 6) \\ng4.addEdge(5, 7) \\ng4.addEdge(5, 8) \\ng4.addEdge(5, 9) \\ng4.addEdge(6, 4) \\ng4.addEdge(7, 9) \\ng4.addEdge(8, 9) \\ng4.addEdge(9, 8) \\nprint \\"nSSC in fourth graph \\"\\ng4.SCC(); \\n  \\n  \\ng5 = Graph (5) \\ng5.addEdge(0, 1) \\ng5.addEdge(1, 2) \\ng5.addEdge(2, 3) \\ng5.addEdge(2, 4) \\ng5.addEdge(3, 0) \\ng5.addEdge(4, 2) \\nprint \\"nSSC in fifth graph \\"\\ng5.SCC();\\n","orden":8,"suborden":40,"fecha_creacion":"2020-12-06 19:51:47","fecha_modificacion":"2022-03-08 12:28:52"},{"ID":237,"supergrupo":"Grafos","tema":"M\xe1ximo cotejamiento bipartito","texto":"Una coincidencia en un gr\xe1fico bipartito es un conjunto de aristas elegidas de tal manera que no haya dos aristas que compartan un punto final. Una coincidencia m\xe1xima es una coincidencia de tama\xf1o m\xe1ximo (n\xfamero m\xe1ximo de aristas). En una coincidencia m\xe1xima, si se le agrega alg\xfana arista, ya no es una coincidencia. Puede haber m\xe1s de una coincidencia m\xe1xima para un gr\xe1fico bipartito determinado.\\n\\nHay muchos problemas del mundo real que pueden formarse como emparejamiento bipartito. Por ejemplo, considere el siguiente problema:\\nHay M solicitantes de empleo y N trabajos. Cada solicitante tiene un subconjunto de trabajos que le interesan. Cada oferta de trabajo solo puede aceptar un solicitante y un solicitante de trabajo puede ser designado para un solo trabajo. Busque una asignaci\xf3n de puestos de trabajo a los solicitantes de manera que la mayor cantidad posible de solicitantes consiga trabajo.\\n\\nProblema de coincidencia m\xe1xima bipartita y flujo m\xe1ximo\\nEl problema de m\xe1xima coincidencia bipartita (MBP) se puede resolver convirti\xe9ndolo en una red de flujo\\nLos siguientes son los pasos.\\n\\n1) Construya una red de flujo\\nDebe haber una fuente y un sumidero en una red de flujo. Entonces agregamos una fuente y agregamos aristas desde la fuente a todos los solicitantes. Del mismo modo, agregue aristas de todos los trabajos para hundirlos. La capacidad de cada arista est\xe1 marcada como 1 unidad.\\n\\n2) Encuentre el flujo m\xe1ximo.\\nUsamos el algoritmo de Ford-Fulkerson para encontrar el flujo m\xe1ximo en la red de flujo construida en el paso 1. El flujo m\xe1ximo es en realidad el MBP que estamos buscando.\\n\\n\xbfC\xf3mo implementar el enfoque anterior?\\nPrimero definamos las formas de entrada y salida. La entrada tiene la forma de matriz de Edmonds, que es una matriz 2D \\"bpGraph [M] [N]\\" con M filas (para M solicitantes de empleo) y N columnas (para N empleos). El valor bpGraph [i] [j] es 1 si el i-\xe9simo solicitante est\xe1 interesado en el j\'th trabajo; de lo contrario, 0.\\nLa salida es el n\xfamero m\xe1ximo de personas que pueden conseguir trabajo.\\nUna forma sencilla de implementar esto es crear una matriz que represente la representaci\xf3n de la matriz de adyacencia de un gr\xe1fico dirigido con M + N + 2 v\xe9rtices. Llame a fordFulkerson () para la matriz. Esta implementaci\xf3n requiere O ((M + N) * (M + N)) espacio extra.\\nEl espacio adicional se puede reducir y el c\xf3digo se puede simplificar utilizando el hecho de que el gr\xe1fico es bipartito y la capacidad de cada arista es 0 o 1. La idea es utilizar el recorrido DFS para encontrar un trabajo para un solicitante (similar a aumentar la ruta en Ford-Fulkerson). Llamamos bpm () para cada solicitante, bpm () es la funci\xf3n basada en DFS que intenta todas las posibilidades para asignar un trabajo al solicitante.\\n\\nEn bpm (), probamos uno por uno todos los trabajos que le interesan a un solicitante \\"u\\" hasta que encontramos un trabajo, o todos los trabajos se prueban sin suerte. Para cada trabajo que intentamos, hacemos lo siguiente.\\nSi un trabajo no se asigna a nadie, simplemente se lo asignamos al solicitante y devolvemos verdadero. Si se asigna un trabajo a otra persona, digamos x, entonces verificamos recursivamente si a x se le puede asignar alg\xfan otro trabajo. Para asegurarnos de que x no obtenga el mismo trabajo nuevamente, marcamos el trabajo \\"v\\" como se ve antes de hacer una llamada recursiva para x. Si x puede conseguir otro trabajo, cambiamos al solicitante del trabajo \\"v\\" y devolvemos verdadero. Usamos una matriz maxR [0..N-1] que almacena los solicitantes asignados a diferentes trabajos.\\nSi bmp () devuelve verdadero, significa que hay una ruta de aumento en la red de flujo y se agrega 1 unidad de flujo al resultado en maxBPM ().\\n","complejidad_tiempo":null,"java":"// Un programa Java para encontrar la m\xe1xima coincidencia bipartita.\\n\\npublic class MaximumBipartiteMatching {\\n\\n    // M es el n\xfamero de solicitantes y N es el n\xfamero de trabajos\\n    static final int M = 6;\\n    static final int N = 6;\\n\\n    // Una funci\xf3n recursiva basada en DFS que devuelve verdadero si es posible una coincidencia para el v\xe9rtice u\\n    static boolean bpm(boolean bpGraph[][], int u,\\n            boolean seen[], int matchR[]) {\\n        // Prueba cada trabajo uno por uno\\n        for (int v = 0; v < N; v++) {\\n            // Si el solicitante u est\xe1 interesado en el trabajo v y v no es visitado\\n            if (bpGraph[u][v] && !seen[v]) {\\n\\n                // Marcar v como visitado\\n                seen[v] = true;\\n\\n                // Si el trabajo \'v\' no est\xe1 asignado a un solicitante OR si \\n                // el solicitante previamente asignado para el trabajo v \\n                // (que es matchR [v]) tiene un trabajo alternativo disponible. \\n                // Dado que v est\xe1 marcado como visitado en la l\xednea anterior, \\n                // matchR [v] en la siguiente llamada recursiva no obtendr\xe1 el \\n                // trabajo \'v\' nuevamente\\n                if (matchR[v] < 0 || bpm(bpGraph, matchR[v],\\n                        seen, matchR)) {\\n                    matchR[v] = u;\\n                    return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n\\n    // Marcar v como visitado Devuelve el n\xfamero m\xe1ximo de \\n    // coincidencias de M a N\\n    static int maxBPM(boolean bpGraph[][]) {\\n        // Una matriz para realizar un seguimiento de los solicitantes \\n        // asignados a los trabajos. El valor de matchR [i] es el n\xfamero de \\n        // solicitante asignado al trabajo i, el valor -1 indica \\n        // que nadie est\xe1 asignado.\\n        int matchR[] = new int[N];\\n\\n        // Inicialmente todos los trabajos est\xe1n disponibles\\n        for (int i = 0; i < N; ++i) {\\n            matchR[i] = -1;\\n        }\\n\\n        // Recuento de trabajos asignados a los solicitantes\\n        int result = 0;\\n        for (int u = 0; u < M; u++) {\\n            // Marque todos los trabajos como no se ven para el pr\xf3ximo solicitante.\\n            boolean seen[] = new boolean[N];\\n            for (int i = 0; i < N; ++i) {\\n                seen[i] = false;\\n            }\\n            // Averig\xfce si el solicitante \'u\' puede conseguir un trabajo\\n            if (bpm(bpGraph, u, seen, matchR)) {\\n                result++;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    public static void main(String[] args)\\n            throws java.lang.Exception {\\n        // Creemos un bpGraph que se muestra en el ejemplo anterior\\n        boolean bpGraph[][] = new boolean[][]{\\n            {false, true, true,false, false, false},\\n            {true, false, false,true, false, false},\\n            {false, false, true, false, false, false},\\n            {false, false, true, true, false, false},\\n            {false, false, false, false, false, false},\\n            {false, false, false, false, false, true}};\\n        System.out.println(\\"Maximum number of applicants that can\\"\\n                + \\" get job is \\" + maxBPM(bpGraph));\\n    }\\n}\\n","cpp":"#include <iostream> \\n#include <string.h> \\nusing namespace std;\\n#define M 6 \\n#define N 6 \\n\\nbool bpm(bool bpGraph[M][N], int u,\\n        bool seen[], int matchR[]) {\\n\\n    for (int v = 0; v < N; v++) {\\n\\n        if (bpGraph[u][v] && !seen[v]) {\\n\\n            seen[v] = true;\\n\\n            if (matchR[v] < 0 || bpm(bpGraph, matchR[v],\\n                    seen, matchR)) {\\n                matchR[v] = u;\\n                return true;\\n            }\\n        }\\n    }\\n    return false;\\n}\\n\\nint maxBPM(bool bpGraph[M][N]) {\\n\\n    int matchR[N];\\n    memset(matchR, -1, sizeof (matchR));\\n\\n    int result = 0;\\n    for (int u = 0; u < M; u++) {\\n        bool seen[N];\\n        memset(seen, 0, sizeof (seen));\\n        if (bpm(bpGraph, u, seen, matchR))\\n            result++;\\n    }\\n    return result;\\n}\\n\\nint main() {\\n\\n    bool bpGraph[M][N] = {\\n        {0, 1, 1, 0, 0, 0},\\n        {1, 0, 0, 1, 0, 0},\\n        {0, 0, 1, 0, 0, 0},\\n        {0, 0, 1, 1, 0, 0},\\n        {0, 0, 0, 0, 0, 0},\\n        {0, 0, 0, 0, 0, 1}\\n    };\\n\\n    cout << \\"Maximum number of applicants that can get job is \\"\\n            << maxBPM(bpGraph);\\n\\n    return 0;\\n} \\n","py":"class MBM: \\n    def __init__(self, graph): \\n        self.graph = graph  \\n        self.ppl = len(graph) \\n        self.jobs = len(graph[0]) \\n    def bpm(self, u, matchR, seen): \\n        for v in range(self.jobs): \\n            if self.graph[u][v] and seen[v] == False: \\n                seen[v] = True \\n                if matchR[v] == -1 or self.bpm(matchR[v], matchR, seen): \\n                    matchR[v] = u \\n                    return True\\n        return False\\n\\n    def maxBPM(self): \\n        matchR = [-1] * self.jobs \\n        result = 0 \\n        for i in range(self.ppl): \\n            seen = [False] * self.jobs \\n            if self.bpm(i, matchR, seen): \\n                result += 1\\n        return result \\n  \\n  \\nbpGraph = [[0, 1, 1, 0, 0, 0], \\n    [1, 0, 0, 1, 0, 0], \\n    [0, 0, 1, 0, 0, 0], \\n    [0, 0, 1, 1, 0, 0], \\n    [0, 0, 0, 0, 0, 0], \\n    [0, 0, 0, 0, 0, 1]] \\n  \\ng = MBM(bpGraph) \\n  \\nprint (\\"Maximum number of applicants that can get job is %d \\" % g.maxBPM()) \\n","orden":8,"suborden":41,"fecha_creacion":"2020-12-06 19:51:48","fecha_modificacion":"2022-03-08 12:28:52"},{"ID":238,"supergrupo":"Grafos","tema":"Lazy Propagation","texto":"Consideremos el siguiente problema para comprender los \xe1rboles de segmentos.\\nTenemos una matriz arr [0. . . n-1]. Deber\xedamos poder\\n1 Encuentre la suma de los elementos del \xedndice la r donde 0 <= l <= r <= n-1\\n2 Cambie el valor de un elemento especificado de la matriz a un nuevo valor x. Necesitamos hacer arr [i] = x donde 0 <= i <= n-1.\\nUna soluci\xf3n simple es ejecutar un ciclo de la ry calcular la suma de elementos en el rango dado. Para actualizar un valor, simplemente haga arr [i] = x. La primera operaci\xf3n toma O (n) tiempo y la segunda operaci\xf3n toma O (1) tiempo.\\nOtra soluci\xf3n es crear otra matriz y almacenar la suma desde el principio hasta la i en el \xedndice i en esta matriz. La suma de un rango dado ahora se puede calcular en O (1) tiempo, pero la operaci\xf3n de actualizaci\xf3n toma O (n) tiempo ahora. Esto funciona bien si el n\xfamero de operaciones de consulta es grande y muy pocas actualizaciones.\\n\\n\xbfQu\xe9 pasa si el n\xfamero de consultas y actualizaciones es igual? \xbfPodemos realizar ambas operaciones en tiempo O (log n) una vez dada la matriz? Podemos usar un \xe1rbol de segmentos para realizar ambas operaciones en tiempo O (Logn).\\nRepresentaci\xf3n de \xe1rboles de segmentos\\n1. Los nodos hoja son los elementos de la matriz de entrada.\\n2. Cada nodo interno representa alguna fusi\xf3n de los nodos hoja. La combinaci\xf3n puede ser diferente para diferentes problemas. Para este problema, la fusi\xf3n es la suma de hojas debajo de un nodo.\\nSe utiliza una representaci\xf3n de matriz de \xe1rbol para representar \xe1rboles de segmento. Para cada nodo en el \xedndice i, el hijo izquierdo est\xe1 en el \xedndice 2 * i + 1, el hijo derecho en 2 * i + 2 y el padre est\xe1 en.\\n \\n\xbfC\xf3mo se ve el \xe1rbol de segmentos anterior en la memoria?\\nAl igual que Heap, el \xe1rbol de segmentos tambi\xe9n se representa como una matriz. La diferencia aqu\xed es que no es un \xe1rbol binario completo. Es m\xe1s bien un \xe1rbol binario completo (cada nodo tiene 0 o 2 hijos) y todos los niveles est\xe1n llenos excepto posiblemente el \xfaltimo nivel. A diferencia de Heap, el \xfaltimo nivel puede tener espacios entre los nodos. A continuaci\xf3n se muestran los valores en la matriz de \xe1rbol de segmentos para el diagrama anterior.\\n\\nA continuaci\xf3n se muestra la representaci\xf3n en memoria del \xe1rbol de segmentos para la matriz de entrada {1, 3, 5, 7, 9, 11}\\nst [] = {36, 9, 27, 4, 5, 16, 11, 1, 3, DUMMY, DUMMY, 7, 9, DUMMY, DUMMY}\\n\\nLos valores ficticios nunca se acceden y no tienen uso. Este es un desperdicio de espacio debido a la simple representaci\xf3n de una matriz. Podemos optimizar este desperdicio usando algunas implementaciones inteligentes, pero el c\xf3digo para suma y actualizaci\xf3n se vuelve m\xe1s complejo.\\nConstrucci\xf3n del \xe1rbol de segmentos a partir de una matriz dada\\nComenzamos con un segmento arr [0. . . n-1]. y cada vez que dividimos el segmento actual en dos mitades (si a\xfan no se ha convertido en un segmento de longitud 1), y luego llamamos al mismo procedimiento en ambas mitades, y para cada segmento, almacenamos la suma en el nodo correspondiente.\\nTodos los niveles del \xe1rbol de segmentos construido se llenar\xe1n por completo excepto el \xfaltimo nivel. Adem\xe1s, el \xe1rbol ser\xe1 un \xe1rbol binario completo porque siempre dividimos los segmentos en dos mitades en cada nivel. Dado que el \xe1rbol construido es siempre un \xe1rbol binario completo con n hojas, habr\xe1 n-1 nodos internos. Entonces, el n\xfamero total de nodos ser\xe1 2 * n - 1. Tenga en cuenta que esto no incluye los nodos ficticios.\\n\\n\xbfCu\xe1l es el tama\xf1o total de la matriz que representa el \xe1rbol de segmentos?\\nSi n es una potencia de 2, entonces no hay nodos ficticios. Entonces, el tama\xf1o del \xe1rbol de segmentos es 2n-1 (n nodos hoja y n-1) nodos internos. Si n no es una potencia de 2, entonces el tama\xf1o del \xe1rbol ser\xe1 2 * x - 1 donde x es la potencia m\xe1s peque\xf1a de 2 mayor que n. Por ejemplo, cuando n = 10, el tama\xf1o de la matriz que representa el \xe1rbol de segmentos es 2 * 16-1 = 31.\\nUna explicaci\xf3n alternativa para el tama\xf1o se basa en la altura. La altura del \xe1rbol de segmentos ser\xe1. Dado que el \xe1rbol se representa mediante una matriz y la relaci\xf3n entre los \xedndices padre e hijo debe mantenerse, el tama\xf1o de la memoria asignada para el \xe1rbol de segmentos ser\xe1.\\nConsulta de la suma del rango dado\\nUna vez que se construye el \xe1rbol, c\xf3mo obtener la suma utilizando el \xe1rbol de segmentos construido. El siguiente es el algoritmo para obtener la suma de elementos.\\nint getSum (nodo, l, r)\\n{\\n   si el rango del nodo est\xe1 dentro de lyr\\n        valor de retorno en el nodo\\n   de lo contrario, si el rango del nodo est\xe1 completamente fuera de lyr\\n        volver 0\\n   m\xe1s\\n    return getSum (hijo izquierdo del nodo, l, r) +\\n           getSum (hijo derecho del nodo, l, r)\\n}\\nActualizar un valor\\nAl igual que la construcci\xf3n de \xe1rboles y las operaciones de consulta, la actualizaci\xf3n tambi\xe9n se puede realizar de forma recursiva. Se nos da un \xedndice que debe actualizarse. Sea diff el valor a agregar. Comenzamos desde la ra\xedz del \xe1rbol de segmentos y agregamos diff a todos los nodos que han dado \xedndice en su rango. Si un nodo no tiene un \xedndice determinado en su rango, no realizamos ning\xfan cambio en ese nodo.\\n\\nPropagaci\xf3n diferida: una optimizaci\xf3n para agilizar las actualizaciones de rango\\nCuando hay muchas actualizaciones y se realizan actualizaciones en un rango, podemos posponer algunas actualizaciones (evitar llamadas recursivas en la actualizaci\xf3n) y hacer esas actualizaciones solo cuando sea necesario.\\nRecuerde que un nodo en el \xe1rbol de segmentos almacena o representa el resultado de una consulta para un rango de \xedndices. Y si el rango de este nodo se encuentra dentro del rango de la operaci\xf3n de actualizaci\xf3n, entonces todos los descendientes del nodo tambi\xe9n deben actualizarse. Por ejemplo, considere el nodo con el valor 27 en el diagrama anterior, este nodo almacena la suma de los valores en los \xedndices de 3 a 5. Si nuestra consulta de actualizaci\xf3n es para el rango 2 a 5, entonces necesitamos actualizar este nodo y todos los descendientes de este nodo. Con la propagaci\xf3n diferida, actualizamos solo el nodo con valor 27 y posponemos las actualizaciones a sus hijos almacenando esta informaci\xf3n de actualizaci\xf3n en nodos separados llamados nodos o valores diferidos. Creamos una matriz lazy [] que representa el nodo perezoso. El tama\xf1o de lazy [] es el mismo que el de la matriz que representa el \xe1rbol de segmentos, que es el \xe1rbol [] en el c\xf3digo siguiente.\\nLa idea es inicializar todos los elementos de lazy [] como 0. Un valor 0 en lazy [i] indica que no hay actualizaciones pendientes en el nodo i en el \xe1rbol de segmentos. Un valor distinto de cero de lazy [i] significa que esta cantidad debe agregarse al nodo i en el \xe1rbol de segmentos antes de realizar cualquier consulta al nodo.\\n\\nA continuaci\xf3n se muestra el m\xe9todo de actualizaci\xf3n modificado.\\n// Para actualizar el \xe1rbol de segmentos para cambiar la matriz\\n// valores en los \xedndices de matriz de nosotros a ue.\\nupdateRange (nosotros, ue)\\n1) Si el nodo del \xe1rbol del segmento actual tiene alg\xfan pendiente\\n   actualizar, luego primero agregue esa actualizaci\xf3n pendiente a\\n   nodo actual.\\n2) Si el rango del nodo actual se encuentra completamente en\\n   actualizar el rango de consultas.\\n.... a) Actualizar el nodo actual\\n.... b) Posponga las actualizaciones para los ni\xf1os estableciendo\\n       valor perezoso para los nodos secundarios.\\n3) Si el rango del nodo actual se superpone con la actualizaci\xf3n\\n   rango, siga el mismo enfoque que el anterior simple\\n   actualizar.\\n... a) Recurrir para ni\xf1os izquierdos y derechos.\\n... b) Actualizar el nodo actual usando los resultados de left\\n      y llamadas correctas.\\n\\n\xbfTambi\xe9n hay alg\xfan cambio en la funci\xf3n de consulta?\\nDado que hemos cambiado la actualizaci\xf3n para posponer sus operaciones, puede haber problemas si se realiza una consulta a un nodo que a\xfan no se ha actualizado. Por lo tanto, tambi\xe9n debemos actualizar nuestro m\xe9todo de consulta, que es getSumUtil en la publicaci\xf3n anterior. GetSumUtil () ahora primero verifica si hay una actualizaci\xf3n pendiente y si la hay, luego actualiza el nodo. Una vez que se asegura de que se realiza la actualizaci\xf3n pendiente, funciona igual que el getSumUtil () anterior.\\n","complejidad_tiempo":null,"java":"// Programa Java para demostrar la propagaci\xf3n diferida en el \xe1rbol de segmentos\\n\\npublic class LazyPropagation {\\n\\n    static final int MAX = 1000;         // Tama\xf1o m\xe1ximo del \xe1rbol\\n    static int tree[] = new int[MAX]; // Para almacenar el \xe1rbol de segmentos\\n    static int lazy[] = new int[MAX]; // Para almacenar actualizaciones pendientes\\n\\n    /*  si -> \xedndice del nodo actual en el \xe1rbol de \\n        segmentos ss y se -> \xcdndices inicial y final de \\n        los elementos para los que los nodos actuales almacenan la suma.\\n        us y eu -> \xedndices de inicio y finalizaci\xf3n de la consulta \\n        de actualizaci\xf3n\\n        ue -> \xedndice final de la consulta de actualizaci\xf3n\\n        diff -> que necesitamos agregar en el rango us to ue */\\n    static void updateRangeUtil(int si, int ss, int se, int us,\\n            int ue, int diff) {\\n        // Si el valor diferido es distinto de cero para el nodo \\n        // actual del \xe1rbol de segmentos, hay algunas actualizaciones \\n        // pendientes. Por lo tanto, debemos asegurarnos de que las \\n        // actualizaciones pendientes se realicen antes de realizar \\n        // nuevas actualizaciones. Porque este valor puede ser \\n        // utilizado por los padres despu\xe9s de llamadas recursivas \\n        // (ver la \xfaltima l\xednea de esta funci\xf3n)\\n        if (lazy[si] != 0) {\\n            // Realice actualizaciones pendientes utilizando el \\n            // valor almacenado en nodos perezosos\\n            tree[si] += (se - ss + 1) * lazy[si];\\n            // comprobando si no es un nodo hoja porque si \\n            // es un nodo hoja entonces no podemos ir m\xe1s lejos\\n            if (ss != se) {\\n                // Podemos posponer la actualizaci\xf3n de los ni\xf1os, \\n                // no necesitamos sus nuevos valores ahora. Dado que \\n                // a\xfan no estamos actualizando los hijos de si,\\n                // necesitamos establecer banderas perezosas para los hijos\\n                lazy[si * 2 + 1] += lazy[si];\\n                lazy[si * 2 + 2] += lazy[si];\\n            }\\n\\n            // Establezca el valor diferido para el nodo actual en 0, ya que se ha actualizado\\n            lazy[si] = 0;\\n        }\\n\\n        // fuera de rango\\n        if (ss > se || ss > ue || se < us) {\\n            return;\\n        }\\n\\n        // El segmento actual est\xe1 completamente dentro del rango\\n        if (ss >= us && se <= ue) {\\n            // Agregar la diferencia al nodo actual\\n            tree[si] += (se - ss + 1) * diff;\\n            // misma l\xf3gica para verificar el nodo hoja o no\\n            if (ss != se) {\\n                // Aqu\xed es donde almacenamos los valores en los nodos \\n                // perezosos, en lugar de actualizar el \xe1rbol de segmentos \\n                // en s\xed. Dado que no necesitamos estos valores actualizados \\n                // ahora posponemos las actualizaciones almacenando \\n                // los valores en lazy []\\n                lazy[si * 2 + 1] += diff;\\n                lazy[si * 2 + 2] += diff;\\n            }\\n            return;\\n        }\\n\\n        // Si no est\xe1 completamente en son\xf3, pero se superpone, repita para los ni\xf1os,\\n        int mid = (ss + se) / 2;\\n        updateRangeUtil(si * 2 + 1, ss, mid, us, ue, diff);\\n        updateRangeUtil(si * 2 + 2, mid + 1, se, us, ue, diff);\\n\\n        // Y use el resultado de las llamadas de los ni\xf1os para actualizar este nodo\\n        tree[si] = tree[si * 2 + 1] + tree[si * 2 + 2];\\n    }\\n\\n    // Funci\xf3n para actualizar un rango de valores en el \xe1rbol de segmentos\\n    /* us y eu -> \xedndices de inicio y finalizaci\xf3n de la consulta de actualizaci\xf3n\\n        ue -> \xedndice final de la consulta de actualizaci\xf3n\\n        diff -> que necesitamos agregar en el rango us to ue */\\n    static void updateRange(int n, int us, int ue, int diff) {\\n        updateRangeUtil(0, 0, n - 1, us, ue, diff);\\n    }\\n\\n    /* Una funci\xf3n recursiva para obtener la suma de valores en un rango dado\\n       de la matriz. Los siguientes son par\xe1metros para esta funci\xf3n.\\n       si -> \xcdndice del nodo actual en el \xe1rbol de segmentos. Inicialmente \\n             se pasa 0 ya que la ra\xedz siempre est\xe1 en el \'\xedndice 0\\n       ss & se -> \xcdndices de inicio y finalizaci\xf3n del segmento \\n                  representado por el nodo actual, es decir, \xe1rbol [si]\\n       qs & qe -> \xcdndices de inicio y finalizaci\xf3n del rango de consulta */\\n    static int getSumUtil(int ss, int se, int qs, int qe, int si) {\\n        // Si se establece el indicador diferido para el nodo actual del \\n        // \xe1rbol de segmentos, hay algunas actualizaciones pendientes. \\n        // Por lo tanto, debemos asegurarnos de que las actualizaciones \\n        // pendientes se realicen antes de procesar la consulta \\n        // de suma secundaria.\\n        if (lazy[si] != 0) {\\n            // Realice actualizaciones pendientes en este nodo. Tenga en \\n            // cuenta que este nodo representa la suma de elementos en \\n            // arr [ss..se] y todos estos elementos deben \\n            // aumentarse mediante lazy [si]\\n            tree[si] += (se - ss + 1) * lazy[si];\\n\\n            // comprobando si no es un nodo hoja porque si es un \\n            // nodo hoja entonces no podemos ir m\xe1s lejos\\n            if (ss != se) {\\n                // Dado que todav\xeda no estamos actualizando el sistema \\n                // operativo de los ni\xf1os, debemos establecer \\n                // valores perezosos para los ni\xf1os.\\n                lazy[si * 2 + 1] += lazy[si];\\n                lazy[si * 2 + 2] += lazy[si];\\n            }\\n\\n            // anule el valor diferido para el nodo actual, \\n            // ya que se ha actualizado\\n            lazy[si] = 0;\\n        }\\n\\n        // Fuera de rango\\n        if (ss > se || ss > qe || se < qs) {\\n            return 0;\\n        }\\n\\n        // En este punto, seguro que se realizan las actualizaciones \\n        // diferidas pendientes para el nodo actual. Entonces podemos \\n        // devolver el valor (igual que para la consulta en nuestra \\n        // publicaci\xf3n anterior) si este segmento se encuentra en el rango\\n        if (ss >= qs && se <= qe) {\\n            return tree[si];\\n        }\\n        // Si una parte de este segmento se superpone con el rango dado\\n        int mid = (ss + se) / 2;\\n        return getSumUtil(ss, mid, qs, qe, 2 * si + 1)\\n                + getSumUtil(mid + 1, se, qs, qe, 2 * si + 2);\\n    }\\n\\n    // Devuelve la suma de los elementos en el rango desde el \xedndice qs \\n    // (inicio de la consulta) hasta qe (final de la consulta). \\n    // Utiliza principalmente getSumUtil ()\\n    static int getSum(int n, int qs, int qe) {\\n        // Compruebe si hay valores de entrada err\xf3neos\\n        if (qs < 0 || qe > n - 1 || qs > qe) {\\n            System.out.println(\\"Invalid Input\\");\\n            return -1;\\n        }\\n\\n        return getSumUtil(0, n - 1, qs, qe, 0);\\n    }\\n\\n    /* Una funci\xf3n recursiva que construye el \xe1rbol de segmentos para \\n       la matriz [ss..se]. si es el \xedndice del nodo actual en el \\n       \xe1rbol de segmentos st. */\\n    static void constructSTUtil(int arr[], int ss, int se, int si) {\\n        // fuera de rango ya que ss nunca puede ser mayor que se\\n        if (ss > se) {\\n            return;\\n        }\\n        /* Si hay un elemento en la matriz, gu\xe1rdelo en\\n        nodo actual del \xe1rbol de segmentos y retorno */\\n        if (ss == se) {\\n            tree[si] = arr[ss];\\n            return;\\n        }\\n\\n        /* Si hay m\xe1s de un elemento, repita para los \\n        sub\xe1rboles izquierdo y derecho y almacene la \\n        suma de valores en este nodo */\\n        int mid = (ss + se) / 2;\\n        constructSTUtil(arr, ss, mid, si * 2 + 1);\\n        constructSTUtil(arr, mid + 1, se, si * 2 + 2);\\n\\n        tree[si] = tree[si * 2 + 1] + tree[si * 2 + 2];\\n    }\\n\\n    /* Funci\xf3n para construir un \xe1rbol de segmentos a partir de una matriz \\n    dada. Esta funci\xf3n asigna memoria para el \xe1rbol de segmentos \\n    y llama a constructSTUtil () para llenar la memoria asignada */\\n    static void constructST(int arr[], int n) {\\n        // Llenar la memoria asignada st\\n        constructSTUtil(arr, 0, n - 1, 0);\\n    }\\n\\n    public static void main(String args[]) {\\n        int arr[] = {1, 3, 5, 7, 9, 11};\\n        int n = arr.length;\\n\\n        // Construir un \xe1rbol de segmentos a partir de una matriz dada\\n        constructST(arr, n);\\n\\n        // Imprimir la suma de valores en la matriz desde el \xedndice 1 al 3\\n        System.out.println(\\"Sum of values in given range = \\"\\n                + getSum(n, 1, 3));\\n\\n        // Agregue 10 a todos los nodos en los \xedndices del 1 al 5.\\n        updateRange(n, 1, 5, 10);\\n\\n        // Encontrar la suma despu\xe9s de actualizar el valor\\n        System.out.println(\\"Updated sum of values in given range = \\"\\n                + getSum(n, 1, 3));\\n    }\\n}\\n","cpp":"#include <stdio.h> \\n#include <math.h> \\n#define MAX 1000 \\n\\nint tree[MAX] = {0};\\nint lazy[MAX] = {0};\\n\\nvoid updateRangeUtil(int si, int ss, int se, int us,\\n        int ue, int diff) {\\n\\n    if (lazy[si] != 0) {\\n        tree[si] += (se - ss + 1) * lazy[si];\\n        if (ss != se) {\\n            lazy[si * 2 + 1] += lazy[si];\\n            lazy[si * 2 + 2] += lazy[si];\\n        }\\n        lazy[si] = 0;\\n    }\\n\\n    if (ss > se || ss > ue || se < us)\\n        return;\\n\\n    if (ss >= us && se <= ue) {\\n        tree[si] += (se - ss + 1) * diff;\\n        if (ss != se) {\\n            lazy[si * 2 + 1] += diff;\\n            lazy[si * 2 + 2] += diff;\\n        }\\n        return;\\n    }\\n\\n    int mid = (ss + se) / 2;\\n    updateRangeUtil(si * 2 + 1, ss, mid, us, ue, diff);\\n    updateRangeUtil(si * 2 + 2, mid + 1, se, us, ue, diff);\\n    tree[si] = tree[si * 2 + 1] + tree[si * 2 + 2];\\n}\\n\\nvoid updateRange(int n, int us, int ue, int diff) {\\n    updateRangeUtil(0, 0, n - 1, us, ue, diff);\\n}\\n\\nint getSumUtil(int ss, int se, int qs, int qe, int si) {\\n\\n    if (lazy[si] != 0) {\\n        tree[si] += (se - ss + 1) * lazy[si];\\n        if (ss != se) {\\n            lazy[si * 2 + 1] += lazy[si];\\n            lazy[si * 2 + 2] += lazy[si];\\n        }\\n        lazy[si] = 0;\\n    }\\n\\n    if (ss > se || ss > qe || se < qs)\\n        return 0;\\n\\n    if (ss >= qs && se <= qe)\\n        return tree[si];\\n\\n    int mid = (ss + se) / 2;\\n    return getSumUtil(ss, mid, qs, qe, 2 * si + 1) +\\n            getSumUtil(mid + 1, se, qs, qe, 2 * si + 2);\\n}\\n\\nint getSum(int n, int qs, int qe) {\\n\\n    if (qs < 0 || qe > n - 1 || qs > qe) {\\n        printf(\\"Invalid Input\\");\\n        return -1;\\n    }\\n\\n    return getSumUtil(0, n - 1, qs, qe, 0);\\n}\\n\\nvoid constructSTUtil(int arr[], int ss, int se, int si) {\\n    if (ss > se)\\n        return;\\n    if (ss == se) {\\n        tree[si] = arr[ss];\\n        return;\\n    }\\n    int mid = (ss + se) / 2;\\n    constructSTUtil(arr, ss, mid, si * 2 + 1);\\n    constructSTUtil(arr, mid + 1, se, si * 2 + 2);\\n\\n    tree[si] = tree[si * 2 + 1] + tree[si * 2 + 2];\\n}\\n\\nvoid constructST(int arr[], int n) {\\n    constructSTUtil(arr, 0, n - 1, 0);\\n}\\n\\nint main() {\\n    int arr[] = {1, 3, 5, 7, 9, 11};\\n    int n = sizeof (arr) / sizeof (arr[0]);\\n    constructST(arr, n);\\n    printf(\\"Sum of values in given range = %d\\\\n\\",\\n            getSum(n, 1, 3));\\n    updateRange(n, 1, 5, 10);\\n    printf(\\"Updated sum of values in given range = %d\\\\n\\",\\n            getSum(n, 1, 3));\\n\\n    return 0;\\n}\\n","py":"MAX = 1000\\ntree = [0] * MAX; \\nlazy = [0] * MAX;\\n\\n\\ndef updateRangeUtil(si, ss, se, us, ue, diff):  \\n    if (lazy[si] != 0): \\n        tree[si] += (se - ss + 1) * lazy[si]; \\n        if (ss != se): \\n            lazy[si * 2 + 1] += lazy[si]; \\n            lazy[si * 2 + 2] += lazy[si]; \\n        lazy[si] = 0; \\n    if (ss > se or ss > ue or se < us): \\n        return; \\n    if (ss >= us and se <= ue): \\n        tree[si] += (se - ss + 1) * diff; \\n        if (ss != se): \\n            lazy[si * 2 + 1] += diff; \\n            lazy[si * 2 + 2] += diff; \\n        return; \\n    mid = (ss + se) // 2; \\n    updateRangeUtil(si * 2 + 1, ss, \\n                    mid, us, ue, diff); \\n    updateRangeUtil(si * 2 + 2, mid + 1, \\n                    se, us, ue, diff); \\n    tree[si] = tree[si * 2 + 1] + \\\\ tree[si * 2 + 2]; \\n\\ndef updateRange(n, us, ue, diff): \\n    updateRangeUtil(0, 0, n - 1, us, ue, diff); \\n\\ndef getSumUtil(ss, se, qs, qe, si): \\n    if (lazy[si] != 0): \\n        tree[si] += (se - ss + 1) * lazy[si]; \\n        if (ss != se): \\n            lazy[si * 2 + 1] += lazy[si]; \\n            lazy[si * 2 + 2] += lazy[si]; \\n        lazy[si] = 0; \\n    if (ss > se or ss > qe or se < qs): \\n        return 0; \\n    if (ss >= qs and se <= qe): \\n        return tree[si]; \\n    mid = (ss + se) // 2; \\n    return (getSumUtil(ss, mid, qs, qe, 2 * si + 1) +\\n            getSumUtil(mid + 1, se, qs, qe, 2 * si + 2)); \\ndef getSum(n, qs, qe): \\n    if (qs < 0 or qe > n - 1 or qs > qe): \\n        print(\\"Invalid Input\\"); \\n        return -1; \\n\\n    return getSumUtil(0, n - 1, qs, qe, 0); \\n\\ndef constructSTUtil(arr, ss, se, si): \\n    if (ss > se): \\n        return; \\n    if (ss == se): \\n        \\n        tree[si] = arr[ss]; \\n        return; \\n    mid = (ss + se) // 2; \\n    constructSTUtil(arr, ss, mid, si * 2 + 1); \\n    constructSTUtil(arr, mid + 1, se, si * 2 + 2); \\n\\n    tree[si] = tree[si * 2 + 1] + tree[si * 2 + 2]; \\n\\ndef constructST(arr, n): \\n    constructSTUtil(arr, 0, n - 1, 0); \\n\\narr = [1, 3, 5, 7, 9, 11]; \\nn = len(arr); \\nconstructST(arr, n); \\nprint(\\"Sum of values in given range =\\", getSum(n, 1, 3)); \\nupdateRange(n, 1, 5, 10); \\nprint(\\"Updated sum of values in given range =\\", getSum(n, 1, 3)); \\n","orden":8,"suborden":42,"fecha_creacion":"2020-12-06 19:51:48","fecha_modificacion":"2022-03-08 12:28:52"},{"ID":239,"supergrupo":"Grafos","tema":"Componentes biconectados ","texto":"Un componente biconectado es un subgrafo biconectado m\xe1ximo.\\nUn grafo no dirigido se llama Biconnectado si hay dos rutas de v\xe9rtice disjunto entre dos v\xe9rtices cualesquiera. En un gr\xe1fico biconectado, hay un ciclo simple a trav\xe9s de dos v\xe9rtices cualesquiera.\\nPor convenci\xf3n, dos nodos conectados por una arista forman un gr\xe1fico biconectado, pero esto no verifica las propiedades anteriores. Para un gr\xe1fico con m\xe1s de dos v\xe9rtices, las propiedades anteriores deben estar ah\xed para que est\xe9 Biconectado.\\nO en otras palabras:\\nSe dice que un gr\xe1fico est\xe1 biconectado si:\\n1) Est\xe1 conectado, es decir, es posible llegar a cada v\xe9rtice desde cualquier otro v\xe9rtice, por un camino simple.\\n2) Incluso despu\xe9s de eliminar cualquier v\xe9rtice, el gr\xe1fico permanece conectado.\\nA continuaci\xf3n se muestran algunos ejemplos. \\n\\nUn gr\xe1fico conectado est\xe1 Biconectado si est\xe1 conectado y no tiene ning\xfan punto de articulaci\xf3n. Principalmente necesitamos verificar dos cosas en un gr\xe1fico.\\n1) El gr\xe1fico est\xe1 conectado.\\n2) No hay punto de articulaci\xf3n en el gr\xe1fico.\\nPartimos de cualquier v\xe9rtice y hacemos un recorrido DFS. En el recorrido DFS, comprobamos si hay alg\xfan punto de articulaci\xf3n. Si no encontramos ning\xfan punto de articulaci\xf3n, entonces el gr\xe1fico est\xe1 Biconectado. Finalmente, debemos verificar si todos los v\xe9rtices fueron accesibles en DFS o no. Si no todos los v\xe9rtices fueran accesibles, entonces el gr\xe1fico ni siquiera est\xe1 conectado.\\n \\nEl algoritmo se basa en el disco y los valores bajos que se describen en el art\xedculo Componentes fuertemente conectados.\\n\\nLa idea es almacenar las aristas visitadas en una pila mientras DFS en un gr\xe1fico y seguir buscando puntos de articulaci\xf3n (resaltados en la figura anterior). Tan pronto como se encuentre un punto de articulaci\xf3n u, todos las aristas visitadas mientras DFS desde el nodo u en adelante formar\xe1n un componente biconectado. Cuando DFS se completa para un componente conectado, todas las aristas presentes en la pila formar\xe1n un componente biconectado.\\nSi no hay un punto de articulaci\xf3n en el gr\xe1fico, entonces el gr\xe1fico est\xe1 biconectado y, por lo tanto, habr\xe1 un componente biconectado que es el gr\xe1fico en s\xed.\\n","complejidad_tiempo":null,"java":"// Un programa Java para encontrar componentes biconectados \\n// en un gr\xe1fico no dirigido dado\\n\\nimport java.util.*;\\n\\npublic class BiconnectedComponents {\\n\\n    // Esta clase representa un gr\xe1fico dirigido utilizando \\n    // la representaci\xf3n de lista de adyacencia.\\n    static class Graph {\\n\\n        private int V, E; // No. de v\xe9rtices y aristas respectivamente\\n        private LinkedList<Integer> adj[]; // Lista de adyacencia\\n        // El recuento es el n\xfamero de componentes biconectados. \\n        // el tiempo se usa para encontrar tiempos de descubrimiento\\n        static int count = 0, time = 0;\\n\\n        class Edge {\\n\\n            int u;\\n            int v;\\n\\n            Edge(int u, int v) {\\n                this.u = u;\\n                this.v = v;\\n            }\\n        };\\n\\n        Graph(int v) {\\n            V = v;\\n            E = 0;\\n            adj = new LinkedList[v];\\n            for (int i = 0; i < v; ++i) {\\n                adj[i] = new LinkedList();\\n            }\\n        }\\n\\n        // Funci\xf3n para agregar una arista al gr\xe1fico\\n        void addEdge(int v, int w) {\\n            adj[v].add(w);\\n            E++;\\n        }\\n\\n        // Una funci\xf3n recursiva que encuentra e imprime fuertemente conectados\\n        // componentes que utilizan DFS transversal\\n        // u -> El v\xe9rtice a visitar a continuaci\xf3n\\n        // disc[] -> Almacena los tiempos de descubrimiento de los v\xe9rtices visitados\\n        // low[] - >> v\xe9rtice visitado m\xe1s temprano (el v\xe9rtice con m\xednimo\\n        // tiempo de descubrimiento) que se puede alcanzar desde el sub\xe1rbol\\n        // arraigado con el v\xe9rtice actual\\n        // * st - >> Para almacenar los bordes visitados\\n        void BCCUtil(int u, int disc[], int low[], LinkedList<Edge> st,\\n                int parent[]) {\\n\\n            // Inicializar el tiempo de descubrimiento y el valor bajo\\n            disc[u] = low[u] = ++time;\\n            int children = 0;\\n\\n            // Pasa por todos los v\xe9rtices adyacentes a este\\n            Iterator<Integer> it = adj[u].iterator();\\n            while (it.hasNext()) {\\n                int v = it.next(); // v es actual adyacente a \'u\'\\n\\n                // Si a\xfan no se ha visitado v, recurra para el\\n                if (disc[v] == -1) {\\n                    children++;\\n                    parent[v] = u;\\n                    // almacenar el borde en la pila\\n                    st.add(new Edge(u, v));\\n                    BCCUtil(v, disc, low, st, parent);\\n                    // Compruebe si el sub\xe1rbol arraigado con \'v\' tiene \\n                    // una conexi\xf3n con uno de los antepasados de \'u\'\\n                    // Caso 1: seg\xfan el art\xedculo sobre componentes \\n                    //fuertemente conectados\\n                    if (low[u] > low[v]) {\\n                        low[u] = low[v];\\n                    }\\n\\n                    // Si u es un punto de articulaci\xf3n, \\n                    // saque todos los bordes de la pila hasta u - v\\n                    if ((disc[u] == 1 && children > 1)\\n                            || (disc[u] > 1 && low[v] >= disc[u])) {\\n                        while (st.getLast().u != u\\n                                || st.getLast().v != v) {\\n                            System.out.print(st.getLast().u\\n                                    + \\"--\\" + st.getLast().v + \\" \\");\\n                            st.removeLast();\\n                        }\\n                        System.out.println(st.getLast().u + \\"--\\"\\n                                + st.getLast().v + \\" \\");\\n                        st.removeLast();\\n\\n                        count++;\\n                    }\\n                } // Actualice el valor bajo de \'u\' solo si \'v\' todav\xeda \\n                // est\xe1 en la pila\\n                // (es decir, es un borde posterior, no un borde transversal).\\n                // Caso 2: seg\xfan el art\xedculo sobre componentes\\n                // fuertemente conectados\\n                else if (v != parent[u] && disc[v] < disc[u]) {\\n                    if (low[u] > disc[v]) {\\n                        low[u] = disc[v];\\n                    }\\n\\n                    st.add(new Edge(u, v));\\n                }\\n            }\\n        }\\n\\n        // La funci\xf3n para hacer un recorrido DFS. Utiliza BCCUtil ()\\n        void BCC() {\\n            int disc[] = new int[V];\\n            int low[] = new int[V];\\n            int parent[] = new int[V];\\n            LinkedList<Edge> st = new LinkedList<Edge>();\\n\\n            // Inicializar matrices de discos y matrices bajas y principales\\n            for (int i = 0; i < V; i++) {\\n                disc[i] = -1;\\n                low[i] = -1;\\n                parent[i] = -1;\\n            }\\n\\n            for (int i = 0; i < V; i++) {\\n                if (disc[i] == -1) {\\n                    BCCUtil(i, disc, low, st, parent);\\n                }\\n                int j = 0;\\n                // Si la pila no est\xe1 vac\xeda, saque todos los bordes de la pila\\n                while (st.size() > 0) {\\n                    j = 1;\\n                    System.out.print(st.getLast().u + \\"--\\"\\n                            + st.getLast().v + \\" \\");\\n                    st.removeLast();\\n                }\\n                if (j == 1) {\\n                    System.out.println();\\n                    count++;\\n                }\\n            }\\n        }\\n    }\\n\\n    public static void main(String args[]) {\\n        Graph g = new Graph(12);\\n        g.addEdge(0, 1);\\n        g.addEdge(1, 0);\\n        g.addEdge(1, 2);\\n        g.addEdge(2, 1);\\n        g.addEdge(1, 3);\\n        g.addEdge(3, 1);\\n        g.addEdge(2, 3);\\n        g.addEdge(3, 2);\\n        g.addEdge(2, 4);\\n        g.addEdge(4, 2);\\n        g.addEdge(3, 4);\\n        g.addEdge(4, 3);\\n        g.addEdge(1, 5);\\n        g.addEdge(5, 1);\\n        g.addEdge(0, 6);\\n        g.addEdge(6, 0);\\n        g.addEdge(5, 6);\\n        g.addEdge(6, 5);\\n        g.addEdge(5, 7);\\n        g.addEdge(7, 5);\\n        g.addEdge(5, 8);\\n        g.addEdge(8, 5);\\n        g.addEdge(7, 8);\\n        g.addEdge(8, 7);\\n        g.addEdge(8, 9);\\n        g.addEdge(9, 8);\\n        g.addEdge(10, 11);\\n        g.addEdge(11, 10);\\n        g.BCC();\\n        System.out.println(\\"Above are \\" + g.count + \\" biconnected components in graph\\");\\n    }\\n}\\n","cpp":"#include <iostream> \\n#include <list> \\n#include <stack> \\n#define NIL -1 \\nusing namespace std;\\nint count = 0;\\n\\nclass Edge {\\npublic:\\n    int u;\\n    int v;\\n    Edge(int u, int v);\\n};\\n\\nEdge::Edge(int u, int v) {\\n    this->u = u;\\n    this->v = v;\\n}\\n\\nclass Graph {\\n    int V;\\n    int E;\\n    list<int>* adj;\\n    void BCCUtil(int u, int disc[], int low[],\\n            list<Edge>* st, int parent[]);\\n\\npublic:\\n    Graph(int V);\\n    void addEdge(int v, int w);\\n    void BCC();\\n};\\n\\nGraph::Graph(int V) {\\n    this->V = V;\\n    this->E = 0;\\n    adj = new list<int>[V];\\n}\\n\\nvoid Graph::addEdge(int v, int w) {\\n    adj[v].push_back(w);\\n    E++;\\n}\\n\\nvoid Graph::BCCUtil(int u, int disc[], int low[], list<Edge>* st,\\n        int parent[]) {\\n    static int time = 0;\\n    disc[u] = low[u] = ++time;\\n    int children = 0;\\n    list<int>::iterator i;\\n    for (i = adj[u].begin(); i != adj[u].end(); ++i) {\\n        int v = *i;\\n        if (disc[v] == -1) {\\n            children++;\\n            parent[v] = u;\\n            st->push_back(Edge(u, v));\\n            BCCUtil(v, disc, low, st, parent);\\n            low[u] = min(low[u], low[v]);\\n            if ((disc[u] == 1 && children > 1) || (disc[u] > 1 && low[v] >= disc[u])) {\\n                while (st->back().u != u || st->back().v != v) {\\n                    cout << st->back().u << \\"--\\" << st->back().v << \\" \\";\\n                    st->pop_back();\\n                }\\n                cout << st->back().u << \\"--\\" << st->back().v;\\n                st->pop_back();\\n                cout << endl;\\n                count++;\\n            }\\n        } else if (v != parent[u]) {\\n            low[u] = min(low[u], disc[v]);\\n            if (disc[v] < disc[u]) {\\n                st->push_back(Edge(u, v));\\n            }\\n        }\\n    }\\n}\\n\\nvoid Graph::BCC() {\\n    int* disc = new int[V];\\n    int* low = new int[V];\\n    int* parent = new int[V];\\n    list<Edge>* st = new list<Edge>[E];\\n    for (int i = 0; i < V; i++) {\\n        disc[i] = NIL;\\n        low[i] = NIL;\\n        parent[i] = NIL;\\n    }\\n\\n    for (int i = 0; i < V; i++) {\\n        if (disc[i] == NIL)\\n            BCCUtil(i, disc, low, st, parent);\\n\\n        int j = 0;\\n        while (st->size() > 0) {\\n            j = 1;\\n            cout << st->back().u << \\"--\\" << st->back().v << \\" \\";\\n            st->pop_back();\\n        }\\n        if (j == 1) {\\n            cout << endl;\\n            count++;\\n        }\\n    }\\n}\\n\\nint main() {\\n    Graph g(12);\\n    g.addEdge(0, 1);\\n    g.addEdge(1, 0);\\n    g.addEdge(1, 2);\\n    g.addEdge(2, 1);\\n    g.addEdge(1, 3);\\n    g.addEdge(3, 1);\\n    g.addEdge(2, 3);\\n    g.addEdge(3, 2);\\n    g.addEdge(2, 4);\\n    g.addEdge(4, 2);\\n    g.addEdge(3, 4);\\n    g.addEdge(4, 3);\\n    g.addEdge(1, 5);\\n    g.addEdge(5, 1);\\n    g.addEdge(0, 6);\\n    g.addEdge(6, 0);\\n    g.addEdge(5, 6);\\n    g.addEdge(6, 5);\\n    g.addEdge(5, 7);\\n    g.addEdge(7, 5);\\n    g.addEdge(5, 8);\\n    g.addEdge(8, 5);\\n    g.addEdge(7, 8);\\n    g.addEdge(8, 7);\\n    g.addEdge(8, 9);\\n    g.addEdge(9, 8);\\n    g.addEdge(10, 11);\\n    g.addEdge(11, 10);\\n    g.BCC();\\n    cout << \\"Above are \\" << count << \\" biconnected components in graph\\";\\n    return 0;\\n}\\n","py":"from collections import defaultdict\\n \\nclass Graph: \\n\\n    def __init__(self, vertices): \\n        self.V = vertices \\n        self.graph = defaultdict(list) \\n        self.Time = 0\\n        self.count = 0\\n\\n    def addEdge(self, u, v): \\n        self.graph[u].append(v) \\n        self.graph[v].append(u) \\n\\n    def BCCUtil(self, u, parent, low, disc, st): \\n        children = 0\\n        disc[u] = self.Time \\n        low[u] = self.Time \\n        self.Time += 1\\n        for v in self.graph[u]: \\n            if disc[v] == -1: \\n                parent[v] = u \\n                children += 1\\n                st.append((u, v)) \\n                self.BCCUtil(v, parent, low, disc, st) \\n                low[u] = min(low[u], low[v]) \\n                if parent[u] == -1 and children > 1 or parent[u] != -1 and low[v] >= disc[u]: \\n                    self.count += 1 \\n                    w = -1\\n                    while w != (u, v): \\n                        w = st.pop() \\n                        print w, \\n                    print\\"\\" \\n                        \\n            elif v != parent[u] and low[u] > disc[v]: \\n                low[u] = min(low [u], disc[v]) \\n                st.append((u, v)) \\n\\n    def BCC(self): \\n        disc = [-1] * (self.V) \\n        low = [-1] * (self.V) \\n        parent = [-1] * (self.V) \\n        st = [] \\n        for i in range(self.V): \\n            if disc[i] == -1: \\n                self.BCCUtil(i, parent, low, disc, st) \\n            if st: \\n                self.count = self.count + 1\\n                while st: \\n                    w = st.pop() \\n                    print w, \\n                print \\"\\" \\n\\ng = Graph(12) \\ng.addEdge(0, 1) \\ng.addEdge(1, 2) \\ng.addEdge(1, 3) \\ng.addEdge(2, 3) \\ng.addEdge(2, 4) \\ng.addEdge(3, 4) \\ng.addEdge(1, 5) \\ng.addEdge(0, 6) \\ng.addEdge(5, 6) \\ng.addEdge(5, 7) \\ng.addEdge(5, 8) \\ng.addEdge(7, 8) \\ng.addEdge(8, 9) \\ng.addEdge(10, 11) \\n\\ng.BCC(); \\nprint (\\"Above are % d biconnected components in graph\\" % (g.count)); \\n\\n","orden":8,"suborden":43,"fecha_creacion":"2020-12-06 19:51:48","fecha_modificacion":"2022-03-08 14:36:15"},{"ID":240,"supergrupo":"Estructuras","tema":"Vector circular","texto":"Range Minimum Query (RMQ)","complejidad_tiempo":null,"java":"// Programa Java para demostrar el uso de una array circular utilizando \\n// espacio de memoria adicional\\n\\npublic class CircularArray {\\n\\n    // funci\xf3n para imprimir una lista circular a partir del \xedndice ind.\\n    public static void print(char a[], int n,\\n            int ind) {\\n        // imprimir desde el \xedndice ind-\xe9simo hasta el \xedndice (n + i) \xe9simo.\\n        for (int i = ind; i < n + ind; i++) {\\n            System.out.print(a[(i % n)] + \\" \\");\\n        }\\n    }\\n\\n    public static void main(String argc[]) {\\n        char[] a = new char[]{\'A\', \'B\', \'C\',\\n            \'D\', \'E\', \'F\'};\\n        int n = 6;\\n        print(a, n, 3);\\n    }\\n}\\n","cpp":"#include <bits/stdc++.h> \\nusing namespace std;\\n\\nvoid print(char a[], int n, int ind) {\\n\\n    for (int i = ind; i < n + ind; i++)\\n        cout << a[(i % n)] << \\" \\";\\n}\\n\\nint main() {\\n    char a[] = {\'A\', \'B\', \'C\', \'D\', \'E\', \'F\'};\\n    int n = sizeof (a) / sizeof (a[0]);\\n    print(a, n, 3);\\n    return 0;\\n}\\n","py":"def prints(a, n, ind): \\n        i = ind \\n        while i < n + ind : \\n                print(a[(i % n)], end = \\" \\") \\n                i = i + 1\\na = [\'A\', \'B\', \'C\', \'D\', \'E\', \'F\'] \\nn = len(a); \\nprints(a, n, 3); \\n","orden":1,"suborden":1,"fecha_creacion":"2020-12-06 19:51:49","fecha_modificacion":"2022-03-08 14:26:59"},{"ID":241,"supergrupo":"Estructuras","tema":"\xc1rbol de Fenwick","texto":"Consideremos el siguiente problema para entender el \xe1rbol indexado binario.\\nTenemos una matriz arr [0. . . n-1]. Nos gustar\xeda\\n1 Calcule la suma de los primeros i elementos.\\n2 Modifique el valor de un elemento especificado de la matriz arr [i] = x donde 0 <= i <= n-1.\\nUna soluci\xf3n simple es ejecutar un ciclo de 0 a i-1 y calcular la suma de los elementos. Para actualizar un valor, simplemente haga arr [i] = x. La primera operaci\xf3n toma O (n) tiempo y la segunda operaci\xf3n toma O (1) tiempo. Otra soluci\xf3n simple es crear una matriz adicional y almacenar la suma de los primeros elementos i-\xe9simo en el \xedndice i-\xe9simo en esta nueva matriz. La suma de un rango dado ahora se puede calcular en O (1) tiempo, pero la operaci\xf3n de actualizaci\xf3n toma O (n) tiempo ahora. Esto funciona bien si hay una gran cantidad de operaciones de consulta pero muy pocas operaciones de actualizaci\xf3n.\\n\xbfPodr\xedamos realizar las operaciones de consulta y actualizaci\xf3n en tiempo O (log n)?\\nUna soluci\xf3n eficaz es utilizar Segment Tree que realiza ambas operaciones en tiempo O (Logn).\\nUna soluci\xf3n alternativa es Binary Indexed Tree, que tambi\xe9n logra una complejidad de tiempo O (Logn) para ambas operaciones. En comparaci\xf3n con el \xe1rbol de segmentos, el \xe1rbol indexado binario requiere menos espacio y es m\xe1s f\xe1cil de implementar.\\n\\nRepresentaci\xf3n\\nEl \xe1rbol indexado binario se representa como una matriz. Deje que la matriz sea BITree []. Cada nodo del \xe1rbol indexado binario almacena la suma de algunos elementos de la matriz de entrada. El tama\xf1o del \xe1rbol indexado binario es igual al tama\xf1o de la matriz de entrada, denotado como n. En el siguiente c\xf3digo, usamos un tama\xf1o de n + 1 para facilitar la implementaci\xf3n.\\nConstrucci\xf3n\\nInicializamos todos los valores en BITree [] como 0. Luego llamamos update () para todos los \xedndices, la operaci\xf3n update () se analiza a continuaci\xf3n.\\nOperaciones\\ngetSum (x): Devuelve la suma de la submatriz arr [0,\u2026, x]\\n// Devuelve la suma del subarreglo arr [0,\u2026, x] usando BITree [0..n], que se construye a partir de arr [0..n-1]\\n1) Inicialice la suma de salida como 0, el \xedndice actual como x + 1.\\n2) Haga lo siguiente mientras el \xedndice actual sea mayor que 0.\\n\u2026 A) Agregue BITree [\xedndice] a la suma\\n\u2026 B) Vaya al padre de BITree [\xedndice]. El padre se puede obtener eliminando\\nel \xfaltimo bit establecido del \xedndice actual, es decir, index = index - (index & (-index))\\n3) Devoluci\xf3n de la suma.\\n\\nEl diagrama anterior proporciona un ejemplo de c\xf3mo funciona getSum (). Aqu\xed hay algunas observaciones importantes.\\nBITree [0] es un nodo ficticio.\\nBITree [y] es el padre de BITree [x], si y solo si se puede obtener y eliminando el \xfaltimo bit establecido de la representaci\xf3n binaria de x, es decir y = x - (x & (-x)).\\nEl nodo hijo BITree [x] del nodo BITree [y] almacena la suma de los elementos entre y (inclusive) yx (exclusivo): arr [y,\u2026, x).\\n\\nupdate (x, val): actualiza el \xe1rbol indexado binario (BIT) realizando arr [index] + = val\\n// Tenga en cuenta que la operaci\xf3n de actualizaci\xf3n (x, val) no cambiar\xe1 arr []. Solo realiza cambios en BITree []\\n1) Inicialice el \xedndice actual como x + 1.\\n2) Haga lo siguiente mientras el \xedndice actual sea menor o igual que n.\\n\u2026 A) Agregue el valor a BITree [\xedndice]\\n\u2026 B) Vaya al padre de BITree [\xedndice]. El padre se puede obtener incrementando el \xfaltimo bit establecido del \xedndice actual, es decir, \xedndice = \xedndice + (\xedndice & (-\xedndice))\\n \\nLa funci\xf3n de actualizaci\xf3n necesita asegurarse de que se actualicen todos los nodos BITree que contienen arr [i] dentro de sus rangos. Pasamos por encima de dichos nodos en BITree agregando repetidamente el n\xfamero decimal correspondiente al \xfaltimo bit establecido del \xedndice actual.\\n\\n\xbfC\xf3mo funciona el \xe1rbol indexado binario?\\nLa idea se basa en el hecho de que todos los enteros positivos se pueden representar como la suma de potencias de 2. Por ejemplo, 19 se puede representar como 16 + 2 + 1. Cada nodo del BITree almacena la suma de n elementos donde n es un potencia de 2. Por ejemplo, en el primer diagrama anterior (el diagrama para getSum ()), la suma de los primeros 12 elementos se puede obtener mediante la suma de los \xfaltimos 4 elementos (de 9 a 12) m\xe1s la suma de 8 elementos (de 1 a 8). El n\xfamero de bits establecidos en la representaci\xf3n binaria de un n\xfamero n es O (Logn). Por lo tanto, recorremos como m\xe1ximo los nodos O (Logn) en las operaciones getSum () y update (). La complejidad temporal de la construcci\xf3n es O (nLogn), ya que llama a update () para todos los n elementos.\\n","complejidad_tiempo":null,"java":"//Estructura de datos que permite procesar \\n//consultas por rangos y actualizaciones \\n//individuales sobre un arreglo.\\n\\npublic class FenwickTree {\\n\\n    // Tama\xf1o m\xe1ximo del \xe1rbol\\n    final static int MAX = 1000;\\n    static int BITree[] = new int[MAX];\\n\\n    /* n -> No. de elementos presentes en el array de entrada.\\n        BITree [0..n] -> array que representa el \xe1rbol indexado binario.\\n        arr [0..n-1] -> array de entrada para la que se eval\xfaa la suma \\n        de prefijo. */\\n    // Devuelve la suma de arr [0..index]. Esta funci\xf3n asume que el array est\xe1 \\n    // preprocesado y las sumas parciales de los elementos del array \\n    // se almacenan en BITree [].\\n    static int getSum(int index) {\\n        int sum = 0; // Inicializar resultado\\n        // el \xedndice en BITree [] es 1 m\xe1s que el \xedndice en arr []\\n        index = index + 1;\\n        // Antepasados transversales de BITree [\xedndice]\\n        while (index > 0) {\\n            // Agregar el elemento actual de BITree a la suma\\n            sum += BITree[index];\\n            // Mover el \xedndice al nodo principal en la vista getSum\\n            index -= index & (-index);\\n        }\\n        return sum;\\n    }\\n\\n    // Actualiza un nodo en Binary Index Tree (BITree) en un \xedndice \\n    // dado en BITree. El valor dado \'val\' se agrega a BITree [i] y \\n    // todos sus ancestros en tree. \\n    public static void updateBIT(int n, int index,\\n            int val) {\\n        // el \xedndice en BITree [] es 1 m\xe1s que el \xedndice en arr []\\n        index = index + 1;\\n        // Atraviesa a todos los antepasados y agrega \'val\'\\n        while (index <= n) {\\n            // Agregue \'val\' al nodo actual del \xe1rbol\\n            BITree[index] += val;\\n            // Actualizar el \xedndice al del padre en la vista de actualizaci\xf3n\\n            index += index & (-index);\\n        }\\n    }\\n\\n    /* Funci\xf3n para construir el \xe1rbol de fenwick a partir de un array dada.*/\\n    static void constructBITree(int arr[], int n) {\\n        // Inicializar BITree [] como 0\\n        for (int i = 1; i <= n; i++) {\\n            BITree[i] = 0;\\n        }\\n        // Almacene el valor actual en BITree [] usando update ()\\n        for (int i = 0; i < n; i++) {\\n            updateBIT(n, i, arr[i]);\\n        }\\n    }\\n\\n    public static void main(String args[]) {\\n        int freq[] = {2, 1, 1, 3, 2, 3,\\n            4, 5, 6, 7, 8, 9};\\n        int n = freq.length;\\n        // Construye el \xe1rbol fenwick a partir de una matriz dada\\n        constructBITree(freq, n);\\n        System.out.println(\\"Sum of elements in arr[0..5]\\"\\n                + \\" is \\" + getSum(5));\\n        freq[3] += 6;\\n        // Actualizar BIT para el cambio anterior en arr []\\n        updateBIT(n, 3, 6);\\n        // Encontrar la suma despu\xe9s de actualizar el valor\\n        System.out.println(\\"Sum of elements in arr[0..5]\\"\\n                + \\" after update is \\" + getSum(5));\\n    }\\n}\\n","cpp":"#include <bits/stdc++.h> \\n#include <cstdlib>\\nusing namespace std;\\nconst int MAX = 1000;\\nint BITree[MAX];\\n\\nint getSum(int index) {\\n    int sum = 0;\\n    index = index + 1;\\n    while (index > 0) {\\n        sum += BITree[index];\\n        index -= index & (-index);\\n    }\\n    return sum;\\n}\\n\\nvoid updateBIT(int n, int index, int val) {\\n    index = index + 1;\\n    while (index <= n) {\\n        BITree[index] += val;\\n        index += index & (-index);\\n    }\\n}\\n\\nvoid constructBITree(int arr[], int n) {\\n    for (int i = 1; i <= n; i++) {\\n        BITree[i] = 0;\\n    }\\n    for (int i = 0; i < n; i++) {\\n        updateBIT(n, i, arr[i]);\\n    }\\n}\\n\\nint main() {\\n    int freq[] = {2, 1, 1, 3, 2, 3, 4, 5, 6, 7, 8, 9};\\n    int n = sizeof (freq) / sizeof (freq[0]);\\n    constructBITree(freq, n);\\n    cout << \\"Sum of elements in arr[0..5] is \\" << getSum(5) << endl;\\n    freq[3] += 6;\\n    updateBIT(n, 3, 6);\\n    cout << \\"Sum of elements in arr[0..5] after update is \\" << getSum(5)\\n            << endl;\\n}\\n\\n","py":"BITree = [0 for x in range (1000)]\\ndef getSum(index):\\n    sum = 0\\n    index = index + 1\\n    while (index > 0):\\n        sum += BITree[index]\\n        index -= index & (-index)\\n    return sum\\n\\ndef updateBIT(n, index, val):\\n    index = index + 1\\n    while (index <= n):\\n        BITree[index] += val\\n        index += index & (-index)\\n\\ndef constructBITree(arr, n):\\n    for i in range (1, n + 1):\\n        BITree[i] = 0\\n    for i in range (n):\\n        updateBIT(n, i, arr[i])\\n\\nfreq = [2, 1, 1, 3, 2, 3, 4, 5, 6, 7, 8, 9]\\nn = len(freq)\\nconstructBITree(freq, n);\\nprint(\\"Sum of elements in arr[0..5] is \\" + str(getSum(5)))\\nfreq[3] += 6\\nupdateBIT(n, 3, 6);\\nprint(\\"Sum of elements in arr[0..5] after update is \\" + str(getSum(5)))\\n","orden":1,"suborden":2,"fecha_creacion":"2020-12-06 19:51:49","fecha_modificacion":"2022-03-08 14:26:59"},{"ID":242,"supergrupo":"Estructuras","tema":"Range Minimum Query (RMQ)","texto":"Consideremos el siguiente problema para comprender los \xe1rboles de segmentos.\\nTenemos una matriz arr [0. . . n-1]. Deber\xedamos poder\\n1 Encuentre la suma de los elementos del \xedndice la r donde 0 <= l <= r <= n-1\\n2 Cambie el valor de un elemento especificado de la matriz a un nuevo valor x. Necesitamos hacer arr [i] = x donde 0 <= i <= n-1.\\n\\nUna soluci\xf3n simple es ejecutar un ciclo de la ry calcular la suma de elementos en el rango dado. Para actualizar un valor, simplemente haga arr [i] = x. La primera operaci\xf3n toma O (n) tiempo y la segunda operaci\xf3n toma O (1) tiempo.\\nOtra soluci\xf3n es crear otra matriz y almacenar la suma desde el principio hasta la i en el \xedndice i en esta matriz. La suma de un rango dado ahora se puede calcular en O (1) tiempo, pero la operaci\xf3n de actualizaci\xf3n toma O (n) tiempo ahora. Esto funciona bien si el n\xfamero de operaciones de consulta es grande y muy pocas actualizaciones.\\n\\n\xbfQu\xe9 pasa si el n\xfamero de consultas y actualizaciones es igual? \xbfPodemos realizar ambas operaciones en tiempo O (log n) una vez dada la matriz? Podemos usar un \xe1rbol de segmentos para realizar ambas operaciones en tiempo O (Logn).\\nRepresentaci\xf3n de \xe1rboles de segmentos\\n1. Los nodos hoja son los elementos de la matriz de entrada.\\n2. Cada nodo interno representa alguna fusi\xf3n de los nodos hoja. La combinaci\xf3n puede ser diferente para diferentes problemas. Para este problema, la fusi\xf3n es la suma de hojas debajo de un nodo.\\n \\n\xbfC\xf3mo se ve el \xe1rbol de segmentos anterior en la memoria?\\nAl igual que Heap, el \xe1rbol de segmentos tambi\xe9n se representa como una matriz. La diferencia aqu\xed es que no es un \xe1rbol binario completo. Es m\xe1s bien un \xe1rbol binario completo (cada nodo tiene 0 o 2 hijos) y todos los niveles est\xe1n llenos excepto posiblemente el \xfaltimo nivel. A diferencia de Heap, el \xfaltimo nivel puede tener espacios entre los nodos. A continuaci\xf3n se muestran los valores en la matriz de \xe1rbol de segmentos para el diagrama anterior.\\n\\nA continuaci\xf3n se muestra la representaci\xf3n en memoria del \xe1rbol de segmentos para la matriz de entrada {1, 3, 5, 7, 9, 11}\\n\\nst [] = {36, 9, 27, 4, 5, 16, 11, 1, 3, DUMMY, DUMMY, 7, 9, DUMMY, DUMMY}\\n\\nLos valores ficticios nunca se acceden y no tienen uso. Este es un desperdicio de espacio debido a la simple representaci\xf3n de una matriz. Podemos optimizar este desperdicio usando algunas implementaciones inteligentes, pero el c\xf3digo para suma y actualizaci\xf3n se vuelve m\xe1s complejo.\\nConstrucci\xf3n del \xe1rbol de segmentos a partir de una matriz dada\\nComenzamos con un segmento arr [0. . . n-1]. y cada vez que dividimos el segmento actual en dos mitades (si a\xfan no se ha convertido en un segmento de longitud 1), y luego llamamos al mismo procedimiento en ambas mitades, y para cada segmento, almacenamos la suma en el nodo correspondiente.\\nTodos los niveles del \xe1rbol de segmentos construido se llenar\xe1n por completo excepto el \xfaltimo nivel. Adem\xe1s, el \xe1rbol ser\xe1 un \xe1rbol binario completo porque siempre dividimos los segmentos en dos mitades en cada nivel. Dado que el \xe1rbol construido es siempre un \xe1rbol binario completo con n hojas, habr\xe1 n-1 nodos internos. Entonces, el n\xfamero total de nodos ser\xe1 2 * n - 1. Tenga en cuenta que esto no incluye los nodos ficticios.\\n\\n\xbfCu\xe1l es el tama\xf1o total de la matriz que representa el \xe1rbol de segmentos?\\nSi n es una potencia de 2, entonces no hay nodos ficticios. Entonces, el tama\xf1o del \xe1rbol de segmentos es 2n-1 (n nodos hoja y n-1) nodos internos. Si n no es una potencia de 2, entonces el tama\xf1o del \xe1rbol ser\xe1 2 * x - 1 donde x es la potencia m\xe1s peque\xf1a de 2 mayor que n. Por ejemplo, cuando n = 10, el tama\xf1o de la matriz que representa el \xe1rbol de segmentos es 2 * 16-1 = 31.\\nUna explicaci\xf3n alternativa para el tama\xf1o se basa en la altura. La altura del \xe1rbol de segmentos ser\xe1  . Dado que el \xe1rbol se representa mediante una matriz y la relaci\xf3n entre los \xedndices padre e hijo debe mantenerse, el tama\xf1o de la memoria asignada para el \xe1rbol de segmentos ser\xe1  \\n. \\nConsulta de la suma del rango dado\\nUna vez que se construye el \xe1rbol, c\xf3mo obtener la suma utilizando el \xe1rbol de segmentos construido. El siguiente es el algoritmo para obtener la suma de elementos.\\nint getSum (nodo, l, r)\\n{\\n   si el rango del nodo est\xe1 dentro de lyr\\n        valor de retorno en el nodo\\n   de lo contrario, si el rango del nodo est\xe1 completamente fuera de lyr\\n        volver 0\\n   m\xe1s\\n    return getSum (hijo izquierdo del nodo, l, r) +\\n           getSum (hijo derecho del nodo, l, r)\\n}\\n\\nActualizar un valor\\nAl igual que la construcci\xf3n de \xe1rboles y las operaciones de consulta, la actualizaci\xf3n tambi\xe9n se puede realizar de forma recursiva. Se nos da un \xedndice que debe actualizarse. Sea diff el valor a agregar. Comenzamos desde la ra\xedz del \xe1rbol de segmentos y agregamos diff a todos los nodos que han dado \xedndice en su rango. Si un nodo no tiene un \xedndice determinado en su rango, no realizamos ning\xfan cambio en ese nodo.\\nImplementaci\xf3n:\\nA continuaci\xf3n se muestra la implementaci\xf3n del \xe1rbol de segmentos. El programa implementa la construcci\xf3n de un \xe1rbol de segmentos para cualquier arreglo. Tambi\xe9n implementa operaciones de consulta y actualizaci\xf3n.\\n\\nTenemos una matriz arr [0. . . n-1]. Deber\xedamos poder encontrar de manera eficiente el valor m\xednimo desde el \xedndice qs (inicio de la consulta) hasta qe (final de la consulta) donde 0 <= qs <= qe <= n-1.\\n\\nUna soluci\xf3n simple es ejecutar un ciclo de qs a qe y encontrar el elemento m\xednimo en un rango dado. Esta soluci\xf3n lleva O (n) tiempo en el peor de los casos.\\nOtra soluci\xf3n es crear una matriz 2D donde una entrada [i, j] almacena el valor m\xednimo en el rango arr [i..j]. Ahora se puede calcular el m\xednimo de un rango dado en O (1) tiempo, pero el preprocesamiento toma O (n ^ 2) tiempo. Adem\xe1s, este enfoque necesita O (n ^ 2) espacio adicional que puede volverse enorme para matrices de entrada grandes.\\n\\nEl \xe1rbol de segmentos se puede utilizar para realizar preprocesamiento y consultas en un tiempo moderado. Con el \xe1rbol de segmentos, el tiempo de preprocesamiento es O (n) y el tiempo para la consulta m\xednima de rango es O (Logn). El espacio adicional requerido es O (n) para almacenar el \xe1rbol de segmentos.\\n\\nRepresentaci\xf3n de \xe1rboles de segmentos\\n1. Los nodos hoja son los elementos de la matriz de entrada.\\n2. Cada nodo interno representa el m\xednimo de todas las hojas debajo de \xe9l.\\n \\nConstrucci\xf3n del \xe1rbol de segmentos a partir de una matriz dada\\nComenzamos con un segmento arr [0. . . n-1]. y cada vez que dividimos el segmento actual en dos mitades (si a\xfan no se ha convertido en un segmento de longitud 1), y luego llamamos al mismo procedimiento en ambas mitades, y para cada segmento, almacenamos el valor m\xednimo en un \xe1rbol de segmentos nodo.\\nTodos los niveles del \xe1rbol de segmentos construido se llenar\xe1n por completo excepto el \xfaltimo nivel. Adem\xe1s, el \xe1rbol ser\xe1 un \xe1rbol binario completo porque siempre dividimos los segmentos en dos mitades en cada nivel. Dado que el \xe1rbol construido es siempre un \xe1rbol binario completo con n hojas, habr\xe1 n-1 nodos internos. Entonces, el n\xfamero total de nodos ser\xe1 2 * n - 1.\\nLa altura del \xe1rbol de segmentos ser\xe1. Dado que el \xe1rbol se representa mediante una matriz y la relaci\xf3n entre los \xedndices padre e hijo debe mantenerse, el tama\xf1o de la memoria asignada para el \xe1rbol de segmentos ser\xe1  .\\n\\nConsultar el valor m\xednimo del rango dado\\nUna vez que se construye el \xe1rbol, c\xf3mo hacer una consulta de rango m\xednimo usando el \xe1rbol de segmento construido. A continuaci\xf3n se muestra el algoritmo para obtener el m\xednimo.\\n// qs -> \xedndice de inicio de consulta, qe -> \xedndice de fin de consulta\\nint RMQ (nodo, qs, qe)\\n{\\n    si el rango del nodo est\xe1 dentro de qs y qe\\n         valor de retorno en el nodo\\n    de lo contrario, si el rango del nodo est\xe1 completamente fuera de qs y qe\\n         volver INFINITO\\n    m\xe1s\\n     return min (RMQ (hijo izquierdo del nodo, qs, qe), RMQ (hijo derecho del nodo, qs, qe))\\n}","complejidad_tiempo":null,"java":"// Programa Java para implementar \xe1rbol de segmentos iterativos.\\n\\npublic class RangeMinimumQuery {\\n\\n    static void construct_segment_tree(int[] segtree,\\n            int[] a, int n) {\\n\\n        // asignar valores a las hojas del \xe1rbol de segmentos\\n        for (int i = 0; i < n; i++) {\\n            segtree[n + i] = a[i];\\n        }\\n\\n        // asignar valores a los nodos internos para calcular el m\xednimo en un rango dado\\n        for (int i = n - 1; i >= 1; i--) {\\n            segtree[i] = Math.min(segtree[2 * i], segtree[2 * i + 1]);\\n        }\\n    }\\n\\n    static void update(int[] segtree, int pos, int value, int n) {\\n\\n        // cambie el \xedndice al nodo hoja primero\\n        pos += n;\\n        // actualizar el valor en el nodo hoja en el \xedndice exacto\\n        segtree[pos] = value;\\n        while (pos > 1) {\\n            // subir un nivel a la vez en el \xe1rbol\\n            pos >>= 1;\\n            // actualizar los valores en los nodos en el siguiente nivel superior\\n            segtree[pos] = Math.min(segtree[2 * pos],\\n                    segtree[2 * pos + 1]);\\n        }\\n    }\\n\\n    static int range_query(int[] segtree, int left,\\n            int right, int n) {\\n\\n        /* \\n        B\xe1sicamente, los \xedndices izquierdo y derecho se mover\xe1n\\n         hacia derecha e izquierda respectivamente y con\\n         cada cada siguiente nivel superior y calcular el\\n         m\xednimo en cada altura.\\n         */\\n        // cambie el \xedndice al nodo hoja primero\\n        left += n;\\n        right += n;\\n        // inicializar m\xednimo a un valor muy alto\\n        int mi = (int) 1e9;\\n\\n        while (left < right) {\\n\\n            // si se deja el \xedndice en impar\\n            if ((left & 1) == 1) {\\n                mi = Math.min(mi, segtree[left]);\\n\\n                // hacer par \xedndice izquierdo\\n                left++;\\n            }\\n\\n            // si el \xedndice correcto es impar\\n            if ((right & 1) == 1) {\\n\\n                // hacer par \xedndice derecho\\n                right--;\\n\\n                mi = Math.min(mi, segtree[right]);\\n            }\\n\\n            // pasar al siguiente nivel superior\\n            left /= 2;\\n            right /= 2;\\n        }\\n        return mi;\\n    }\\n\\n    public static void main(String[] args) {\\n        int[] a = {2, 6, 10, 4, 7, 28, 9, 11, 6, 33};\\n        int n = a.length;\\n\\n        /*  \\n         Construya el \xe1rbol de segmentos asignando\\n          los valores a los nodos internos\\n         */\\n        int[] segtree = new int[2 * n];\\n        construct_segment_tree(segtree, a, n);\\n\\n        // calcular el m\xednimo en el rango de izquierda a derecha\\n        int left = 0, right = 5;\\n        System.out.printf(\\"Minimum in range %d to %d is %d\\\\n\\",\\n                left, right, range_query(segtree,\\n                        left, right + 1, n));\\n\\n        // actualizar el valor del \xedndice 3 a 1\\n        int index = 3, value = 1;\\n\\n        // a[3] = 1;  \\n        // Contenido del array : {2, 6, 10, 1, 7, 28, 9, 11, 6, 33} \\n        update(segtree, index, value, n); // actualizaci\xf3n de puntos\\n\\n        // calcular el m\xednimo en el rango de izquierda a derecha \\n        left = 2;\\n        right = 6;\\n        System.out.printf(\\"Minimum in range %d to %d is %d\\\\n\\",\\n                left, right, range_query(segtree,\\n                        left, right + 1, n));\\n    }\\n}\\n","cpp":"#include <bits/stdc++.h> \\n#define ll long long \\n\\nusing namespace std;\\n\\nvoid construct_segment_tree(vector<int>& segtree,\\n        vector<int> &a, int n) {\\n    for (int i = 0; i < n; i++)\\n        segtree[n + i] = a[i];\\n    for (int i = n - 1; i >= 1; i--)\\n        segtree[i] = min(segtree[2 * i],\\n            segtree[2 * i + 1]);\\n}\\n\\nvoid update(vector<int>& segtree, int pos, int value,\\n        int n) {\\n    pos += n;\\n    segtree[pos] = value;\\n    while (pos > 1) {\\n        pos >>= 1;\\n        segtree[pos] = min(segtree[2 * pos],\\n                segtree[2 * pos + 1]);\\n    }\\n}\\n\\nint range_query(vector<int>& segtree, int left, int\\n        right, int n) {\\n    left += n;\\n    right += n;\\n    int mi = (int) 1e9;\\n\\n    while (left < right) {\\n        if (left & 1) {\\n            mi = min(mi, segtree[left]);\\n            left++;\\n        }\\n        if (right & 1) {\\n            right--;\\n            mi = min(mi, segtree[right]);\\n        }\\n        left /= 2;\\n        right /= 2;\\n    }\\n    return mi;\\n}\\n\\nint main() {\\n    vector<int> a = {2, 6, 10, 4, 7, 28, 9, 11, 6, 33};\\n    int n = a.size();\\n    vector<int> segtree(2 * n);\\n    construct_segment_tree(segtree, a, n);\\n    int left = 0, right = 5;\\n    cout << \\"Minimum in range \\" << left << \\" to \\"\\n            << right << \\" is \\" << range_query(segtree, left,\\n            right + 1, n) << \\"\\\\n\\";\\n\\n    int index = 3, value = 1;\\n    update(segtree, index, value, n);\\n    left = 2, right = 6;\\n    cout << \\"Minimum in range \\" << left << \\" to \\"\\n            << right << \\" is \\" << range_query(segtree,\\n            left, right + 1, n) << \\"\\\\n\\";\\n\\n    return 0;\\n} \\n","py":"def construct_segment_tree(segtree, a, n):  \\n    for i in range(n):  \\n        segtree[n + i] = a[i];  \\n    for i in range(n - 1, 0, -1):  \\n        segtree[i] = min(segtree[2 * i], \\n                         segtree[2 * i + 1])  \\n                          \\ndef range_query(segtree, left, right, n): \\n    left += n  \\n    right += n \\n    mi = 1e9 \\n    while (left < right): \\n        if (left & 1): \\n            mi = min(mi, segtree[left]) \\n            left = left + 1\\n        if (right & 1): \\n            right -= 1\\n            mi = min(mi, segtree[right]) \\n        left = left // 2\\n        right = right // 2\\n    return mi \\n  \\ndef update(segtree, pos, value, n): \\n    pos += n  \\n    segtree[pos] = value  \\n    while (pos > 1):  \\n        pos >>= 1;  \\n        segtree[pos] = min(segtree[2 * pos], \\n                           segtree[2 * pos + 1])  \\na = [2, 6, 10, 4, 7, 28, 9, 11, 6, 33] \\nn = len(a)  \\nsegtree = [0 for i in range(2 * n)]  \\nconstruct_segment_tree(segtree, a, n); \\nleft = 0\\nright = 5 \\nprint (\\"Minimum in range\\", left, \\"to\\", right, \\"is\\", \\n       range_query(segtree, left, right + 1, n)) \\n \\nindex = 3 \\nvalue = 1\\nupdate(segtree, index, value, n); \\nleft = 2\\nright = 6 \\nprint(\\"Minimum in range\\", left, \\"to\\", right, \\"is\\", \\n      range_query(segtree, left, right + 1, n)) \\n","orden":1,"suborden":3,"fecha_creacion":"2020-12-06 19:51:49","fecha_modificacion":"2022-03-08 14:26:59"},{"ID":243,"supergrupo":"Estructuras","tema":"Sparse Table","texto":"El concepto de tabla dispersa se utiliza para consultas r\xe1pidas sobre un conjunto de datos est\xe1ticos (los elementos no cambian). Realiza un preprocesamiento para que las consultas se puedan responder de manera eficiente.\\n \\nProblema de ejemplo 1: consulta de rango m\xednimo\\n\\nTenemos una array arr [0. . . n-1]. Necesitamos encontrar de manera eficiente el valor m\xednimo desde el \xedndice L (inicio de la consulta) hasta R (final de la consulta) donde 0 <= L <= R <= n-1. Considere una situaci\xf3n en la que hay muchas consultas de rango.\\nEjemplo:\\nEntrada: arr [] = {7, 2, 3, 0, 5, 10, 3, 12, 18};\\n        consulta [] = [0, 4], [4, 7], [7, 8]\\n\\nSalida: el m\xednimo de [0, 4] es 0\\n        El m\xednimo de [4, 7] es 3\\n        El m\xednimo de [7, 8] es 12\\nLa idea es precalcular el m\xednimo de todos los subarreglos de tama\xf1o 2j donde j var\xeda de 0 a Log n. Hacemos una b\xfasqueda de tabla [i] [j] tal que la b\xfasqueda [i] [j] contiene un rango m\xednimo a partir de i y de tama\xf1o 2j. Por ejemplo, la b\xfasqueda [0] [3] contiene un m\xednimo de rango [0, 7] (comenzando con 0 y de tama\xf1o 23)\\n\xbfC\xf3mo llenar esta tabla de b\xfasqueda o escasa?\\nLa idea es simple, complete de forma ascendente utilizando valores previamente calculados. Calculamos rangos con una potencia actual de 2 utilizando valores de menor potencia de dos. Por ejemplo, para encontrar un m\xednimo de rango [0, 7] (el tama\xf1o del rango es una potencia de 3), podemos usar el m\xednimo de los siguientes dos.\\na) M\xednimo de rango [0, 3] (el tama\xf1o del rango es una potencia de 2)\\nb) M\xednimo de rango [4, 7] (el tama\xf1o del rango es una potencia de 2)\\nBasado en el ejemplo anterior, a continuaci\xf3n se muestra la f\xf3rmula,\\n// El m\xednimo de subarreglos de un solo elemento es el mismo\\n// como \xfanico elemento.\\nbuscar [i] [0] = arr [i]\\n\\n// Si buscar [0] [2] <= buscar [4] [2],\\n// luego buscar [0] [3] = buscar [0] [2]\\nSi b\xfasqueda [i] [j-1] <= b\xfasqueda [i + 2j-1] [j-1]\\n   buscar [i] [j] = buscar [i] [j-1]\\n\\n// Si buscar [0] [2]> buscar [4] [2],\\n// luego buscar [0] [3] = buscar [4] [2]\\nM\xe1s\\n   buscar [i] [j] = buscar [i + 2j-1] [j-1]\\n\\n \\nPara cualquier rango arbitrario [l, R], necesitamos usar rangos que est\xe9n en potencias de 2. La idea es usar la potencia m\xe1s cercana de 2. Siempre necesitamos hacer como m\xe1ximo una comparaci\xf3n (compare el m\xednimo de dos rangos que son potencias de 2). Un rango comienza con L y termina con \\"L + potencia m\xe1s cercana de 2\\". El otro rango termina en R y comienza con \u201cR - misma potencia m\xe1s cercana de 2 + 1\u201d. Por ejemplo, si el rango dado es (2, 10), comparamos el m\xednimo de dos rangos (2, 9) y (3, 10).\\nBasado en el ejemplo anterior, a continuaci\xf3n se muestra la f\xf3rmula,\\n\\n\\n// Para (2, 10), j = piso (Log2 (10-2 + 1)) = 3\\nj = floor (Log (R-L + 1))\\n\\n// Si lookup [2] [3] <= lookup [3] [3],\\n// luego min (2, 10) = lookup [2] [3]\\nSi b\xfasqueda [L] [j] <= b\xfasqueda [R- (int) pow (2, j) +1] [j]\\n   min (L, R) = buscar [L] [j]\\n\\n// Si lookup [2] [3]> arr [lookup [3] [3],\\n// luego min (2, 10) = lookup [3] [3]\\nM\xe1s\\n   min (L, R) = b\xfasqueda [R- (int) pow (2, j) +1] [j]\\nDado que solo hacemos una comparaci\xf3n, la complejidad de tiempo de la consulta es O (1).\\nProblema de ejemplo 2: Consulta GCD de rango\\n\\nTenemos una array arr [0. . . n-1]. Necesitamos encontrar el m\xe1ximo com\xfan divisor en el rango L y R donde 0 <= L <= R <= n-1. Considere una situaci\xf3n en la que hay muchas querys de rango\\nEjemplos:\\nEntrada: arr [] = {2, 3, 5, 4, 6, 8}\\n        querys [] = {(0, 2), (3, 5), (2, 3)}\\nSalida: 1\\n         2\\n         1\\nUsamos las siguientes propiedades de GCD:\\n\u2022 La funci\xf3n GCD es asociativa [GCD (a, b, c) = GCD (GCD (a, b), c) = GCD (a, GCD (b, c))], podemos calcular GCD de un rango usando GCD de subrangos.\\n\u2022 Si tomamos GCD de un rango superpuesto m\xe1s de una vez, entonces no cambia la respuesta. Por ejemplo, GCD (a, b, c) = GCD (GCD (a, b), GCD (b, c)). Por lo tanto, como problema de consulta de rango m\xednimo, necesitamos hacer solo una comparaci\xf3n para encontrar GCD del rango dado.\\nConstruimos una tabla dispersa usando la misma l\xf3gica que arriba. Despu\xe9s de construir la tabla dispersa, podemos encontrar todos los MCD rompiendo el rango dado en potencias de 2 y agregando el MCD de cada pieza a la respuesta actual.\\n","complejidad_tiempo":null,"java":"// Programa Java para realizar consultas de rango m\xednimo en O (1) \\n// tiempo con O (n * n) espacio extra y O (n * n) tiempo de preprocesamiento.\\n\\npublic class SpaseTableSquareRootDecomposition {\\n\\n    static int MAX = 500;\\n    // lookup [i] [j] va a almacenar el \xedndice de valor m\xednimo en arr [i..j]\\n    static int[][] lookup = new int[MAX][MAX];\\n\\n    // Estructura para representar un rango de consulta \\n    static class Query {\\n\\n        int L, R;\\n\\n        public Query(int L, int R) {\\n            this.L = L;\\n            this.R = R;\\n        }\\n    };\\n\\n    // Llena la b\xfasqueda de matriz de b\xfasqueda [n] [n] para todos \\n    // los valores posibles de los rangos de consulta\\n    static void preprocess(int arr[], int n) {\\n        // Inicialice la b\xfasqueda [] [] para los intervalos con longitud 1\\n        for (int i = 0; i < n; i++) {\\n            lookup[i][i] = i;\\n        }\\n\\n        // Complete el resto de las entradas de abajo hacia arriba\\n        for (int i = 0; i < n; i++) {\\n            for (int j = i + 1; j < n; j++) // Para encontrar un m\xednimo de [0,4],\\n            // comparamos el m\xednimo de arr [lookup [0] [3]] con arr [4].\\n            {\\n                if (arr[lookup[i][j - 1]] < arr[j]) {\\n                    lookup[i][j] = lookup[i][j - 1];\\n                } else {\\n                    lookup[i][j] = j;\\n                }\\n            }\\n        }\\n    }\\n\\n    // Imprime un m\xednimo de m rangos de consulta dados en arr [0..n-1]\\n    static void RMQ(int arr[], int n,\\n            Query q[], int m) {\\n        // Llenar la tabla de b\xfasqueda para todas las consultas de entrada posibles\\n        preprocess(arr, n);\\n\\n        // Calcula una por una la suma de todas las consultas\\n        for (int i = 0; i < m; i++) {\\n            // L\xedmites izquierdo y derecho del rango actual\\n            int L = q[i].L, R = q[i].R;\\n\\n            // Imprimir la suma del rango de consulta actual\\n            System.out.println(\\"Minimum of [\\" + L\\n                    + \\", \\" + R + \\"] is \\"\\n                    + arr[lookup[L][R]]);\\n        }\\n    }\\n\\n    public static void main(String[] args) {\\n        int a[] = {7, 2, 3, 0, 5, 10, 3, 12, 18};\\n        int n = a.length;\\n        Query q[] = {new Query(0, 4),\\n            new Query(4, 7),\\n            new Query(7, 8)};\\n        int m = q.length;\\n        RMQ(a, n, q, m);\\n    }\\n}\\n","cpp":"#include<bits/stdc++.h> \\nusing namespace std;\\n#define MAX 500 \\n\\nint lookup[MAX][MAX];\\n\\nstruct Query {\\n    int L, R;\\n};\\n\\nvoid preprocess(int arr[], int n) {\\n    for (int i = 0; i < n; i++)\\n        lookup[i][0] = i;\\n\\n    for (int j = 1; (1 << j) <= n; j++) {\\n        for (int i = 0; (i + (1 << j) - 1) < n; i++) {\\n            if (arr[lookup[i][j - 1]] < arr[lookup[i + (1 << (j - 1))][j - 1]])\\n                lookup[i][j] = lookup[i][j - 1];\\n            else\\n                lookup[i][j] = lookup[i + (1 << (j - 1))][j - 1];\\n        }\\n    }\\n}\\n\\nint query(int arr[], int L, int R) {\\n    int j = (int) log2(R - L + 1);\\n    if (arr[lookup[L][j]] <= arr[lookup[R - (1 << j) + 1][j]])\\n        return arr[lookup[L][j]];\\n\\n    else return arr[lookup[R - (1 << j) + 1][j]];\\n}\\n\\nvoid RMQ(int arr[], int n, Query q[], int m) {\\n    preprocess(arr, n);\\n    for (int i = 0; i < m; i++) {\\n        int L = q[i].L, R = q[i].R;\\n        cout << \\"Minimum of [\\" << L << \\", \\"\\n                << R << \\"] is \\" << query(arr, L, R) << endl;\\n    }\\n}\\n\\nint main() {\\n    int a[] = {7, 2, 3, 0, 5, 10, 3, 12, 18};\\n    int n = sizeof (a) / sizeof (a[0]);\\n    Query q[] = {\\n        {0, 4},\\n        {4, 7},\\n        {7, 8}\\n    };\\n    int m = sizeof (q) / sizeof (q[0]);\\n    RMQ(a, n, q, m);\\n    return 0;\\n}\\n","py":"from math import log2\\n \\nMAX = 500\\nlookup = [[0 for i in range(500)] \\n    for j in range(500)] \\n\\n\\nclass Query: \\n    def __init__(self, l, r): \\n        self.L = l \\n        self.R = r \\n\\ndef preprocess(arr: list, n: int): \\n    global lookup \\n    for i in range(n): \\n        lookup[i][0] = i \\n    j = 1\\n    while (1 << j) <= n: \\n        i = 0\\n        while i + (1 << j) - 1 < n: \\n            if (arr[lookup[i][j - 1]] < \\n                arr[lookup[i + (1 << (j - 1))][j - 1]]): \\n                lookup[i][j] = lookup[i][j - 1] \\n            else: \\n                lookup[i][j] = lookup[i +\\n                    (1 << (j - 1))][j - 1] \\n\\n            i += 1\\n        j += 1\\n\\ndef query(arr: list, L: int, R: int): \\n    global lookup \\n    j = int(log2(R - L + 1)) \\n    if (arr[lookup[L][j]] <=\\n        arr[lookup[R - (1 << j) + 1][j]]): \\n        return arr[lookup[L][j]] \\n    else: \\n        return arr[lookup[R - (1 << j) + 1][j]] \\ndef RMQ(arr: list, n: int, q: list, m: int): \\n    preprocess(arr, n) \\n    for i in range(m): \\n        L = q[i].L \\n        R = q[i].R \\n        print(\\"Minimum of [%d, %d] is %d\\" %\\n              (L, R, query(arr, L, R))) \\n\\n\\na = [7, 2, 3, 0, 5, 10, 3, 12, 18] \\nn = len(a) \\nq = [Query(0, 4), Query(4, 7), \\n    Query(7, 8)] \\nm = len(q) \\nRMQ(a, n, q, m) \\n","orden":1,"suborden":4,"fecha_creacion":"2020-12-06 19:51:50","fecha_modificacion":"2022-03-08 14:28:36"},{"ID":244,"supergrupo":"Estructuras","tema":"Heap Sort","texto":"La clasificaci\xf3n de mont\xf3n es una t\xe9cnica de clasificaci\xf3n basada en comparaci\xf3n basada en la estructura de datos de mont\xf3n binario. Es similar al ordenamiento por selecci\xf3n donde primero encontramos el elemento m\xe1ximo y colocamos el elemento m\xe1ximo al final. Repetimos el mismo proceso para el resto de elementos.\\n\\n\xbfQu\xe9 es el mont\xf3n binario?\\nPrimero definamos un \xe1rbol binario completo. Un \xe1rbol binario completo es un \xe1rbol binario en el que cada nivel, excepto posiblemente el \xfaltimo, est\xe1 completamente lleno y todos los nodos est\xe1n lo m\xe1s a la izquierda posible.\\nUn mont\xf3n binario es un \xe1rbol binario completo donde los elementos se almacenan en un orden especial de modo que el valor en un nodo principal es mayor (o menor) que los valores en sus dos nodos secundarios. El primero se llama max heap y el \xfaltimo se llama min-heap. El mont\xf3n se puede representar mediante un \xe1rbol o matriz binaria.\\n\\n\xbfPor qu\xe9 la representaci\xf3n basada en matrices para Binary Heap?\\nDado que un mont\xf3n binario es un \xe1rbol binario completo, se puede representar f\xe1cilmente como una matriz y la representaci\xf3n basada en matriz es eficiente en el espacio. Si el nodo padre se almacena en el \xedndice I, el hijo de la izquierda se puede calcular por 2 * I + 1 y el hijo de la derecha por 2 * I + 2 (asumiendo que la indexaci\xf3n comienza en 0).\\n\\nAlgoritmo de clasificaci\xf3n de mont\xf3n para clasificar en orden creciente:\\n1. Cree un mont\xf3n m\xe1ximo a partir de los datos de entrada.\\n2. En este punto, el elemento m\xe1s grande se almacena en la ra\xedz del mont\xf3n. Reempl\xe1celo con el \xfaltimo elemento del mont\xf3n y luego reduzca el tama\xf1o del mont\xf3n en 1. Finalmente, apile la ra\xedz del \xe1rbol.\\n3. Repita el paso 2 mientras el tama\xf1o del mont\xf3n sea mayor que 1.\\n\xbfC\xf3mo construir el mont\xf3n?\\nEl procedimiento Heapify se puede aplicar a un nodo solo si sus nodos secundarios est\xe1n heapified. Por tanto, la heapificaci\xf3n debe realizarse en orden ascendente.\\nEntendamos con la ayuda de un ejemplo:\\n\\nDatos de entrada: 4, 10, 3, 5, 1\\n         4 (0)\\n        / \\\\\\n     10 (1) 3 (2)\\n    / \\\\\\n 5 (3) 1 (4)\\n\\nLos n\xfameros entre par\xe9ntesis representan los \xedndices de la matriz.\\nrepresentaci\xf3n de datos.\\n\\nAplicar el procedimiento de heapify al \xedndice 1:\\n         4 (0)\\n        / \\\\\\n    10 (1) 3 (2)\\n    / \\\\\\n5 (3) 1 (4)\\n\\nAplicando el procedimiento de heapify al \xedndice 0:\\n        10 (0)\\n        / \\\\\\n     5 (1) 3 (2)\\n    / \\\\\\n 4 (3) 1 (4)\\nEl procedimiento de heapify se llama a s\xed mismo de forma recursiva para construir el mont\xf3n\\n de arriba hacia abajo.\\nNotas:\\nLa ordenaci\xf3n de pila es un algoritmo in situ.\\nSu implementaci\xf3n t\xedpica no es estable, pero puede estabilizarse\\n\\nAplicaciones de HeapSort\\n1. Ordene una matriz casi ordenada (o ordenada por K)\\n2. k elementos m\xe1s grandes (o m\xe1s peque\xf1os) en una matriz\\nEl algoritmo de ordenaci\xf3n de pila tiene usos limitados porque Quicksort y Mergesort son mejores en la pr\xe1ctica. Sin embargo, la estructura de datos de Heap en s\xed se utiliza enormemente. Instant\xe1neas:\\n","complejidad_tiempo":null,"java":"// Programa Java para la implementaci\xf3n de Heap Sort\\n\\npublic class HeapSort {\\n\\n    public void sort(int arr[]) {\\n        int n = arr.length;\\n\\n        // Construir mont\xf3n (reorganizar la matriz)\\n        for (int i = n / 2 - 1; i >= 0; i--) {\\n            heapify(arr, n, i);\\n        }\\n\\n        // Uno por uno extrae un elemento del mont\xf3n\\n        for (int i = n - 1; i > 0; i--) {\\n            // Mover la ra\xedz actual al final\\n            int temp = arr[0];\\n            arr[0] = arr[i];\\n            arr[i] = temp;\\n            // llamar a max heapify en el mont\xf3n reducido\\n            heapify(arr, i, 0);\\n        }\\n    }\\n\\n    // Para apilar un sub\xe1rbol enraizado con el nodo i, \\n    // que es un \xedndice en arr []. n es el tama\xf1o del mont\xf3n\\n    void heapify(int arr[], int n, int i) {\\n        int largest = i; // Inicializar m\xe1s grande como ra\xedz\\n        int l = 2 * i + 1; // left = 2*i + 1 \\n        int r = 2 * i + 2; // right = 2*i + 2 \\n\\n        // Si el ni\xf1o izquierdo es m\xe1s grande que la ra\xedz\\n        if (l < n && arr[l] > arr[largest]) {\\n            largest = l;\\n        }\\n\\n        // Si el ni\xf1o derecho es m\xe1s grande que el m\xe1s grande hasta ahora \\n        if (r < n && arr[r] > arr[largest]) {\\n            largest = r;\\n        }\\n\\n        // Si el m\xe1s grande no es ra\xedz\\n        if (largest != i) {\\n            int swap = arr[i];\\n            arr[i] = arr[largest];\\n            arr[largest] = swap;\\n\\n            // Apila de forma recursiva el sub\xe1rbol afectado\\n            heapify(arr, n, largest);\\n        }\\n    }\\n\\n    /* Una funci\xf3n de utilidad para imprimir una matriz de tama\xf1o n */\\n    static void printArray(int arr[]) {\\n        int n = arr.length;\\n        for (int i = 0; i < n; ++i) {\\n            System.out.print(arr[i] + \\" \\");\\n        }\\n        System.out.println();\\n    }\\n\\n    public static void main(String args[]) {\\n        int arr[] = {12, 11, 13, 5, 6, 7};\\n        int n = arr.length;\\n\\n        HeapSort ob = new HeapSort();\\n        ob.sort(arr);\\n\\n        System.out.println(\\"Sorted array is\\");\\n        printArray(arr);\\n    }\\n}\\n","cpp":"#include <iostream> \\n\\nusing namespace std;\\n\\nvoid heapify(int arr[], int n, int i) {\\n    int largest = i;\\n    int l = 2 * i + 1;\\n    int r = 2 * i + 2;\\n    if (l < n && arr[l] > arr[largest])\\n        largest = l;\\n    if (r < n && arr[r] > arr[largest])\\n        largest = r;\\n    if (largest != i) {\\n        swap(arr[i], arr[largest]);\\n        heapify(arr, n, largest);\\n    }\\n}\\n\\nvoid heapSort(int arr[], int n) {\\n    for (int i = n / 2 - 1; i >= 0; i--)\\n        heapify(arr, n, i);\\n\\n    for (int i = n - 1; i > 0; i--) {\\n        swap(arr[0], arr[i]);\\n        heapify(arr, i, 0);\\n    }\\n}\\n\\nvoid printArray(int arr[], int n) {\\n    for (int i = 0; i < n; ++i)\\n        cout << arr[i] << \\" \\";\\n    cout << \\"\\\\n\\";\\n}\\n\\nint main() {\\n    int arr[] = {12, 11, 13, 5, 6, 7};\\n    int n = sizeof (arr) / sizeof (arr[0]);\\n\\n    heapSort(arr, n);\\n\\n    cout << \\"Sorted array is \\\\n\\";\\n    printArray(arr, n);\\n}\\n","py":"def heapify(arr, n, i): \\n    largest = i \\n    l = 2 * i + 1        \\n    r = 2 * i + 2        \\n    if l < n and arr[i] < arr[l]: \\n        largest = l \\n    if r < n and arr[largest] < arr[r]: \\n        largest = r \\n    if largest != i: \\n        arr[i], arr[largest] = arr[largest], arr[i] # swap . \\n        heapify(arr, n, largest) \\n\\ndef heapSort(arr): \\n    n = len(arr)  \\n    for i in range(n // 2 - 1, -1, -1): \\n        heapify(arr, n, i) \\n    for i in range(n-1, 0, -1): \\n        arr[i], arr[0] = arr[0], arr[i] # swap \\n        heapify(arr, i, 0) \\n\\narr = [12, 11, 13, 5, 6, 7] \\nheapSort(arr) \\nn = len(arr) \\nprint (\\"Sorted array is\\") \\nfor i in range(n): \\n    print (\\"%d\\" % arr[i]), \\n","orden":1,"suborden":5,"fecha_creacion":"2020-12-06 19:51:50","fecha_modificacion":"2022-03-08 14:28:36"},{"ID":245,"supergrupo":"Estructuras","tema":"QuickSelect","texto":null,"complejidad_tiempo":null,"java":"import java.util.*;\\n\\nclass QuickSelect {\\n\\n    static int Partition(int A[], int l, int r) {\\n        int p = A[l]; // p es el pivote\\n        int m = l; // S1 y S2 est\xe1n vac\xedos\\n        int temp;\\n        for (int k = l + 1; k <= r; ++k) { // explorar una regi\xf3n desconocida\\n            if (A[k] < p) { // caso 2\\n                m++;\\n                temp = A[k];\\n                A[k] = A[m];\\n                A[m] = temp;\\n            } // observe que no hacemos nada en el caso 1: a [k]> = p\\n        }\\n        temp = A[l];\\n        A[l] = A[m];\\n        A[m] = temp; // intercambiar pivote con una [m]\\n        return m; // retorno de \xedndice de pivote\\n    }\\n\\n    static int RandPartition(int[] A, int l, int r) {\\n        Random rnd = new Random();\\n        int p = l + rnd.nextInt(r - l + 1); // seleccionar un pivote aleatorio\\n        int temp = A[l];\\n        A[l] = A[p];\\n        A[p] = temp;   // intercambiar A [p] con A [l]\\n        return Partition(A, l, r);\\n    }\\n\\n    static int QuickSelect(int[] A, int l, int r, int k) {\\n        if (l == r) {\\n            return A[l];\\n        }\\n        int q = RandPartition(A, l, r);\\n        if (q + 1 == k) {\\n            return A[q];\\n        } else if (q + 1 > k) {\\n            return QuickSelect(A, l, q - 1, k);\\n        } else {\\n            return QuickSelect(A, q + 1, r, k);\\n        }\\n    }\\n\\n    public static void main(String[] args) {\\n        int[] A = new int[]{2, 8, 7, 1, 5, 4, 6, 3}; // permutaci\xf3n de [1..8]\\n\\n        System.out.println(QuickSelect(A, 0, 7, 8)); // la salida debe ser 8\\n        System.out.println(QuickSelect(A, 0, 7, 7)); // la salida debe ser 7\\n        System.out.println(QuickSelect(A, 0, 7, 6)); // la salida debe ser 6\\n        System.out.println(QuickSelect(A, 0, 7, 5)); // la salida debe ser 5\\n        System.out.println(QuickSelect(A, 0, 7, 4)); // la salida debe ser 4\\n        System.out.println(QuickSelect(A, 0, 7, 3)); // la salida debe ser 3\\n        System.out.println(QuickSelect(A, 0, 7, 2)); // la salida debe ser 2\\n        System.out.println(QuickSelect(A, 0, 7, 1)); // la salida debe ser 1\\n    }\\n}\\n","cpp":"#include <bits/stdc++.h>\\nusing namespace std;\\n\\nint Partition(int A[], int l, int r) {\\n    int p = A[l]; // p es el pivote\\n    int m = l; // S1 y S2 est\xe1n vac\xedos\\n    for (int k = l + 1; k <= r; ++k) { // explorar una regi\xf3n desconocida\\n        if (A[k] < p) { // case 2\\n            ++m;\\n            swap(A[k], A[m]);\\n        } // observe que no hacemos nada en el caso 1: a [k]> = p\\n    }\\n    swap(A[l], A[m]); // intercambiar pivote con una [m]\\n    return m; // retorno de \xedndice de pivote\\n}\\n\\nint RandPartition(int A[], int l, int r) {\\n    int p = l + rand() % (r - l + 1); // seleccionar un pivote aleatorio\\n    swap(A[l], A[p]); // intercambiar A [p] con A [l]\\n    return Partition(A, l, r);\\n}\\n\\nint QuickSelect(int A[], int l, int r, int k) { // esperado O (n)\\n    if (l == r) return A[l];\\n    int q = RandPartition(A, l, r); // O(n)\\n    if (q + 1 == k)\\n        return A[q];\\n    else if (q + 1 > k)\\n        return QuickSelect(A, l, q - 1, k);\\n    else\\n        return QuickSelect(A, q + 1, r, k);\\n}\\n\\nint main() {\\n    int A[] = {2, 8, 7, 1, 5, 4, 6, 3}; // permutaci\xf3n de [1..8]\\n\\n    printf(\\"%d\\\\n\\", QuickSelect(A, 0, 7, 8)); // la salida debe ser 8\\n    printf(\\"%d\\\\n\\", QuickSelect(A, 0, 7, 7)); // la salida debe ser 7\\n    printf(\\"%d\\\\n\\", QuickSelect(A, 0, 7, 6)); // la salida debe ser 6\\n    printf(\\"%d\\\\n\\", QuickSelect(A, 0, 7, 5)); // la salida debe ser 5\\n    printf(\\"%d\\\\n\\", QuickSelect(A, 0, 7, 4)); // la salida debe ser 4\\n    printf(\\"%d\\\\n\\", QuickSelect(A, 0, 7, 3)); // la salida debe ser 3\\n    printf(\\"%d\\\\n\\", QuickSelect(A, 0, 7, 2)); // la salida debe ser 2\\n    printf(\\"%d\\\\n\\", QuickSelect(A, 0, 7, 1)); // la salida debe ser 1\\n    return 0;\\n}\\n","py":"import random\\n\\ndef swap(A, i, j): \\n    A[i], A[j] = A[j], A[i] \\n    return A\\n\\ndef Partition(A, l, r):\\n    p = A[l] # p es el pivote\\n    m = l   # S1 y S2 est\xe1n vac\xedos\\n    for k in range(l + 1, r + 1):  # explorar una regi\xf3n desconocida\\n        if A[k] < p:   # caso 2\\n            m += 1\\n            swap(A, k, m)\\n        # observe que no hacemos nada en el caso 1: a [k]> = p\\n    swap(A, l, m)  # intercambiar pivote con una [m]\\n    return m # retorno de \xedndice de pivote\\n\\ndef RandPartition(A, l, r):\\n    p = random.randint(l, r)# seleccionar un pivote aleatorio\\n    swap(A, l, p)  # intercambiar A [p] con A [l]\\n    return Partition(A, l, r)\\n\\ndef QuickSelect(A, l, r, k):# esperado O (n)\\n    if l == r:\\n        return A[l]\\n    q = RandPartition(A, l, r) # O(n)\\n    if q + 1 == k:\\n        return A[q]\\n    elif q + 1 > k:\\n        return QuickSelect(A, l, q-1, k)\\n    else:\\n        return QuickSelect(A, q + 1, r, k)\\n\\ndef main():\\n    A = [2, 8, 7, 1, 5, 4, 6, 3] # permutaci\xf3n de [1..8]\\n\\n    print(\\"{}\\".format(QuickSelect(A, 0, 7, 8)))  # la salida debe ser 8\\n    print(\\"{}\\".format(QuickSelect(A, 0, 7, 7)))  # la salida debe ser 7\\n    print(\\"{}\\".format(QuickSelect(A, 0, 7, 6)))  # la salida debe ser 6\\n    print(\\"{}\\".format(QuickSelect(A, 0, 7, 5)))  # la salida debe ser 5\\n    print(\\"{}\\".format(QuickSelect(A, 0, 7, 4)))  # la salida debe ser 4\\n    print(\\"{}\\".format(QuickSelect(A, 0, 7, 3)))  # la salida debe ser 3\\n    print(\\"{}\\".format(QuickSelect(A, 0, 7, 2)))  # la salida debe ser 2\\n    print(\\"{}\\".format(QuickSelect(A, 0, 7, 1)))  # la salida debe ser 1\\n\\nmain()\\n","orden":1,"suborden":6,"fecha_creacion":"2020-12-06 19:51:50","fecha_modificacion":"2020-12-06 21:01:17"},{"ID":246,"supergrupo":"Formateos","tema":"Formatear fechas y horas","texto":null,"complejidad_tiempo":"No aplica","java":"JAVA\\nimport java.text.ParseException;\\nimport java.text.SimpleDateFormat;\\nimport java.util.Date;\\n\\npublic class DateFormatter {\\n\\n    public static void main(String args[]) throws ParseException {\\n        // Formateo seg\xfan el patr\xf3n dado en el argumento\\n        SimpleDateFormat ft = new SimpleDateFormat(\\"dd-MM-yyyy\\");\\n        String str = ft.format(new Date());\\n        System.out.println(\\"Formatted Date : \\" + str);\\n\\n        // parseando una cadena determinada\\n        str = \\"02/18/1995\\";\\n        ft = new SimpleDateFormat(\\"MM/dd/yyyy\\");\\n        Date date = ft.parse(str);\\n\\n        // esto imprimir\xe1 la fecha seg\xfan la cadena parseada\\n        System.out.println(\\"Parsed Date : \\" + date);\\n    }\\n}\\n","cpp":null,"py":null,"orden":10,"suborden":1,"fecha_creacion":"2020-12-06 19:51:51","fecha_modificacion":"2020-12-06 20:33:40"},{"ID":247,"supergrupo":"Formateos","tema":"Formatear n\xfameros decimales y enteros","texto":null,"complejidad_tiempo":"No aplica","java":"// Programa Java para demostrar el funcionamiento de DecimalFormat\\n\\nimport java.text.DecimalFormat;\\n\\npublic class JavaDecimalFormatter {\\n\\n    public static void main(String args[]) {\\n        double num = 123.4567;\\n\\n        // imprime solo la parte num\xe9rica de un n\xfamero flotante\\n        DecimalFormat ft = new DecimalFormat(\\"####\\");\\n        System.out.println(\\"Without fraction part: num = \\" + ft.format(num));\\n\\n        // esto lo imprimir\xe1 hasta 2 lugares decimales\\n        ft = new DecimalFormat(\\"#.##\\");\\n        System.out.println(\\"Formatted to Give precison: num = \\" + ft.format(num));\\n\\n        // agrega autom\xe1ticamente cero a la parte m\xe1s a la derecha del decimal \\n        // en lugar de #, usamos el d\xedgito 0\\n        ft = new DecimalFormat(\\"#.000000\\");\\n        System.out.println(\\"appended zeroes to right: num = \\" + ft.format(num));\\n\\n        // agrega autom\xe1ticamente cero al extremo izquierdo del n\xfamero decimal \\n        // en lugar de #, usamos el d\xedgito 0\\n        ft = new DecimalFormat(\\"00000.00\\");\\n        System.out.println(\\"formatting Numeric part : num = \\" + ft.format(num));\\n\\n        // formatear dinero en d\xf3lares\\n        double income = 23456.789;\\n        ft = new DecimalFormat(\\"$###,###.##\\");\\n        System.out.println(\\"your Formatted Dream Income : \\" + ft.format(income));\\n    }\\n}\\n","cpp":null,"py":null,"orden":10,"suborden":2,"fecha_creacion":"2020-12-06 19:51:51","fecha_modificacion":"2020-12-06 20:33:41"},{"ID":248,"supergrupo":"Generadores","tema":"N\xfameros aleatorios","texto":null,"complejidad_tiempo":"No aplica","java":"// Un programa Java para generar casos de prueba para n\xfameros aleatorios\\n\\nimport java.io.*;\\nimport java.util.Random;\\n\\npublic class TestCasesGeneratingRandomNumbers {\\n\\n    // el n\xfamero de ejecuciones de los datos de prueba generados\\n    static int requiredNumbers = 5;\\n    // rango m\xednimo de n\xfameros aleatorios\\n    static int lowerBound = 0;\\n    // rango m\xe1ximo de n\xfameros aleatorios\\n    static int upperBound = 1000;\\n\\n    static void randomNumbers() {\\n        Random random = new Random();\\n        for (int i = 0; i < requiredNumbers; i++) {\\n            int a = random.nextInt(upperBound - lowerBound)\\n                    + lowerBound;\\n            System.out.println(a);\\n        }\\n    }\\n\\n    public static void main(String[] args) throws IOException {\\n        randomNumbers();\\n    }\\n}\\n","cpp":"#include <cstdlib>\\n#include <bits/stdc++.h> \\nusing namespace std;\\n\\nstatic int requiredNumbers = 5;\\nstatic int lowerBound = 0;\\nstatic int upperBound = 1000;\\n\\nvoid randomNumbers() {\\n    for (int i = 0; i < requiredNumbers; i++) {\\n        int a = (rand()) % upperBound;\\n        cout << a << \\" \\";\\n    }\\n}\\n\\nint main() {\\n    randomNumbers();\\n}\\n","py":"import random as r\\nrequiredNumbers = 5\\nlowerBound = 0\\nupperBound = 1000\\n\\ndef randomNumbers():\\n    for i in range (requiredNumbers):\\n        a = r.randint(lowerBound, upperBound)\\n        print(a)\\nrandomNumbers()\\n","orden":11,"suborden":0,"fecha_creacion":"2020-12-06 19:51:51","fecha_modificacion":"2020-12-06 20:34:17"},{"ID":249,"supergrupo":"Generadores","tema":"Vectores num\xe9ricos aleatorios","texto":null,"complejidad_tiempo":"No aplica","java":"// Un programa Java para generar casos de prueba para \\n// matrices llenas de n\xfameros aleatorios\\n\\nimport java.io.*;\\nimport java.util.Random;\\n\\npublic class TestCasesGeneratingRandomArrays {\\n\\n    static int RUN = 5;\\n    // rango m\xednimo de n\xfameros aleatorios\\n    static int lowerBound = 0;\\n    // rango m\xe1ximo de n\xfameros aleatorios\\n    static int upperBound = 1000;\\n    // tama\xf1o m\xednimo de la matriz reqd\\n    static int minSize = 10;\\n    // tama\xf1o m\xe1ximo de la matriz reqd\\n    static int maxSize = 20;\\n\\n    static void randomArray() {\\n        Random random = new Random();\\n        for (int i = 0; i < RUN; i++) {\\n            int size = random.nextInt(maxSize - minSize)\\n                    + minSize;\\n            int[] array = new int[size];\\n\\n            System.out.println(size);\\n\\n            for (int j = 0; j < size; j++) {\\n                int a = random.nextInt(upperBound - lowerBound)\\n                        + lowerBound;\\n                System.out.print(a + \\" \\");\\n            }\\n            System.out.println();\\n        }\\n    }\\n\\n    public static void main(String[] args) throws IOException {\\n        randomArray();\\n    }\\n}\\n","cpp":"#include <cstdlib>\\n#include <bits/stdc++.h> \\nusing namespace std;\\n\\nint RUN = 5;\\nint lowerBound = 0;\\nint upperBound = 1000;\\nint minSize = 10;\\nint maxSize = 20;\\n\\nvoid randomArray() {\\n    for (int i = 0; i < RUN; i++) {\\n        int size = maxSize - (rand() % minSize);\\n        int array[size];\\n        cout << size << endl;\\n        for (int j = 0; j < size; j++) {\\n            int a = upperBound - (rand() % upperBound);\\n            cout << a << \\" \\";\\n        }\\n        cout << endl;\\n    }\\n}\\n\\nint main() {\\n    randomArray();\\n}\\n","py":"import random as r\\nRUN = 5;\\nlowerBound = 0;\\nupperBound = 1000;\\nminSize = 10;\\nmaxSize = 20;\\ndef randomArray():\\n    for i in range (RUN):\\n        size = r.randint(minSize, maxSize)\\n        array = [0 for j in range(size)]\\n        print(size)\\n        str1 = \\"\\"\\n        for j in range (size):\\n            a = r.randint(lowerBound, upperBound)\\n            str1 += str(a) + \\" \\" \\n        print(str1)\\nrandomArray()        \\n","orden":11,"suborden":1,"fecha_creacion":"2020-12-06 19:51:52","fecha_modificacion":"2020-12-06 20:34:18"},{"ID":250,"supergrupo":"Generadores","tema":"Matrices num\xe9ricas aleatorias","texto":null,"complejidad_tiempo":"No aplica","java":"// Un programa Java para generar casos de prueba para \\n// matrices llenas de n\xfameros aleatorios\\n\\nimport java.io.IOException;\\nimport java.util.Random;\\n\\npublic class TestCasesGeneratingRandomMatrix {\\n\\n    // el n\xfamero de ejecuciones de los datos de prueba generados\\n    static int RUN = 5;\\n    // rango m\xednimo de n\xfameros aleatorios\\n    static int lowerBound = 0;\\n    // rango m\xe1ximo de n\xfameros aleatorios\\n    static int upperBound = 1000;\\n    // tama\xf1o m\xe1ximo de columna \\n    static int maxColomn = 10;\\n    // tama\xf1o m\xednimo de columna\\n    static int minColomn = 1;\\n    // tama\xf1o m\xednimo de fila\\n    static int minRow = 1;\\n    // tama\xf1o m\xe1ximo de fila\\n    static int maxRow = 10;\\n\\n    static void randomArray() {\\n        Random random = new Random();\\n\\n        for (int i = 0; i < RUN; i++) {\\n            int row = random.nextInt(maxRow - minRow)\\n                    + minRow;\\n            int colomn = random.nextInt(maxColomn - minColomn)\\n                    + minColomn;\\n\\n            int[][] matrix = new int[row][colomn];\\n\\n            System.out.println(row + \\" \\" + colomn);\\n\\n            for (int j = 0; j < row; j++) {\\n                for (int k = 0; k < colomn; k++) {\\n                    int a = random.nextInt(upperBound - lowerBound)\\n                            + lowerBound;\\n                    System.out.print(a + \\" \\");\\n                }\\n                System.out.println();\\n            }\\n            System.out.println();\\n        }\\n    }\\n\\n    public static void main(String[] args) throws IOException {\\n        randomArray();\\n    }\\n}\\n","cpp":"#include <cstdlib>\\n#include <bits/stdc++.h> \\nusing namespace std;\\n\\nint RUN = 5;\\nint lowerBound = 0;\\nint upperBound = 1000;\\nint maxColumn = 10;\\nint minColumn = 1;\\nint minRow = 1;\\nint maxRow = 10;\\n\\nvoid randomMatrix() {\\n    for (int i = 0; i < RUN; i++) {\\n        int row = maxRow - (rand() % maxRow) - minRow;\\n        int column = maxColumn - (rand() % maxColumn) - minColumn;\\n        int matrix[row][column];\\n        cout << row << \\" \\" << column << endl;\\n        for (int j = 0; j < row; j++) {\\n            for (int k = 0; k < column; k++) {\\n                int a = upperBound - (rand() % upperBound);\\n                cout << a << \\" \\";\\n            }\\n            cout << endl;\\n        }\\n        cout << endl;\\n    }\\n}\\n\\nint main() {\\n    randomMatrix();\\n}\\n","py":"import random as r\\nRUN = 5;\\nlowerBound = 0\\nupperBound = 1000\\nmaxColumn = 10\\nminColumn = 1\\nminRow = 1\\nmaxRow = 10\\ndef randomMatrix():\\n    for _ in range (RUN):\\n        row = r.randint(minRow,maxRow)\\n        column = r.randint(minColumn,maxColumn)\\n        matrix=[[0 for x in range(row)]for y in range (column)];\\n        print(str(row) + \\" \\" + str(column))\\n        str1=\\"\\"\\n        for i in range (row):\\n            for j in range (column):\\n                a = r.randint(lowerBound,upperBound)\\n                str1+=str(a)+\\" \\" \\n            print(str1)\\n            str1=\\"\\"\\nrandomMatrix()\\n","orden":11,"suborden":2,"fecha_creacion":"2020-12-06 19:51:52","fecha_modificacion":"2020-12-06 20:34:18"},{"ID":251,"supergrupo":"Generadores","tema":"Vectores num\xe9ricos ordenados aleatorios","texto":null,"complejidad_tiempo":"No aplica","java":"// Programa para generar casos de prueba para arrays llenos de n\xfameros aleatorios\\n\\nimport java.util.Arrays;\\nimport java.util.Random;\\n\\npublic class TestCasesRandomSortedArray {\\n\\n    // Define el n\xfamero de corridas para los datos de prueba generados.\\n    static int RUN = 5;\\n    // Define el rango de los datos de prueba generados\\n    static int MAX = 100000;\\n    // Define el n\xfamero m\xe1ximo de elementos de la matriz\\n    static int MAXNUM = 100;\\n\\n    static void randSortedArray() {\\n        Random r = new Random();\\n        int NUM; // N\xfamero de elementos de la matriz\\n        for (int i = 1; i <= RUN; i++) {\\n            NUM = 1 + r.nextInt(MAXNUM);\\n            int[] arr = new int[NUM];\\n            // Primero imprima el n\xfamero de elementos de la matriz\\n            System.out.printf(\\"%d\\\\n\\", NUM);\\n            for (int j = 0; j < NUM; j++) {\\n                arr[j] = r.nextInt(MAX);\\n            }\\n            // Ordenar la arrya aleatoria generada\\n            Arrays.sort(arr);\\n            // Imprime la array aleatoria ordenada\\n            for (int j = 0; j < NUM; j++) {\\n                System.out.printf(\\"%d \\", arr[j]);\\n            }\\n            System.out.printf(\\"\\\\n\\");\\n        }\\n    }\\n\\n    public static void main(String[] args) {\\n        randSortedArray();\\n    }\\n}\\n","cpp":"#include<bits/stdc++.h> \\nusing namespace std;\\n\\n#define RUN 5 \\n#define MAX 100000 \\n#define MAXNUM 100 \\n\\nvoid randSortedArray() {\\n    srand(time(NULL));\\n    int NUM; \\n    for (int i = 1; i <= RUN; i++) {\\n        NUM = 1 + rand() % MAXNUM;\\n        int arr[NUM];\\n        printf(\\"%d\\\\n\\", NUM);\\n        for (int j = 0; j < NUM; j++)\\n            arr[j] = rand() % MAX;\\n        sort(arr, arr + NUM);\\n        for (int j = 0; j < NUM; j++)\\n            printf(\\"%d \\", arr[j]);\\n\\n        printf(\\"\\\\n\\");\\n    }\\n}\\n\\nint main() {\\n    randSortedArray();\\n}\\n","py":"import random as r\\nRUN =5\\nMAX=100000\\nMAXNUM=100\\n\\ndef randSortedArray():\\n    for i in range(RUN):\\n        NUM=1+r.randint(0,MAXNUM)\\n        arr=[]\\n        print(NUM)\\n        for j in range(NUM):\\n            arr.append(r.randint(0,MAX))\\n        arr.sort()\\n        print(arr)\\n        \\nrandSortedArray()\\n","orden":11,"suborden":3,"fecha_creacion":"2020-12-06 19:51:52","fecha_modificacion":"2020-12-06 20:34:19"},{"ID":252,"supergrupo":"Generadores","tema":"Caracteres aleatorios","texto":null,"complejidad_tiempo":"No aplica","java":"// Programa para generar casos de prueba para caracteres aleatorios\\n\\nimport java.util.Random;\\n\\npublic class TestCasesRandomChars {\\n\\n    // Definir el n\xfamero de corridas para los datos de prueba generados.\\n    static int RUN = 5;\\n    // Defina el rango de los datos de prueba generados Aqu\xed es de \'a\' a \'z\' \\n    static int MAX = 25;\\n\\n    static void randomChars() {\\n        Random r = new Random();\\n        for (int i = 1; i <= RUN; i++) {\\n            System.out.printf(\\"%c\\\\n\\", (char) (\'a\' + r.nextInt(25)));\\n        }\\n    }\\n\\n    public static void main(String[] args) {\\n        randomChars();\\n    }\\n}\\n","cpp":"#include<bits/stdc++.h> \\nusing namespace std;\\n\\n#define RUN 5 \\n#define MAX 25 \\n\\nvoid randomChars() {\\n    srand(time(NULL));\\n    for (int i = 1; i <= RUN; i++)\\n        printf(\\"%c\\\\n\\", \'a\' + rand() % MAX);\\n}\\n\\nint main() {\\n    randomChars();\\n}\\n","py":"import random as r\\nRUN=5\\nMAX=25\\n\\ndef randomChars():\\n    for i in range(RUN):\\n        print(chr(ord(\'a\')+r.randint(0,MAX)))\\n        \\nrandomChars()\\n","orden":11,"suborden":4,"fecha_creacion":"2020-12-06 19:51:53","fecha_modificacion":"2020-12-06 20:34:20"},{"ID":253,"supergrupo":"Generadores","tema":"Cadenas de caracteres aleatorias","texto":null,"complejidad_tiempo":"No aplica","java":"// Programa para generar casos de prueba para cadenas aleatorias\\n\\nimport java.util.Random;\\npublic class TestCasesRandomStrings {\\n\\n    // Definir el n\xfamero de corridas para los datos de prueba generados.\\n    static int RUN = 5;\\n    // Definir el rango de los datos de prueba generados\\n    // Aqu\xed est\xe1 de \'a\' a la \'z\'\\n    static int MAX = 25;\\n    // Definir la longitud m\xe1xima de la cuerda\\n    static int MAXLEN = 100;\\n\\n    static void randString() {\\n        //Para valores aleatorios cada vez\\n        Random r = new Random();\\n        int LEN; // tama\xf1o de la cadena\\n        for (int i = 1; i <= RUN; i++) {\\n            LEN = 1 + r.nextInt(MAXLEN);\\n            // Primero imprime la longitud de la cadena\\n            System.out.printf(\\"%d\\\\n\\", LEN);\\n            // Luego imprime los caracteres de la cadena\\n            for (int j = 1; j <= LEN; j++) {\\n                System.out.printf(\\"%c\\", (char)(\'a\' + r.nextInt(MAX)));\\n            }\\n            System.out.printf(\\"\\\\n\\");\\n        }\\n    }\\n\\n    public static void main(String[] args) {\\n        randString();\\n    }\\n\\n}\\n","cpp":"#include<bits/stdc++.h> \\nusing namespace std;\\n\\n#define RUN 5\\n#define MAX 25 \\n#define MAXLEN 100 \\n\\nvoid randString() {\\n    srand(time(NULL));\\n    int LEN; \\n    for (int i = 1; i <= RUN; i++) {\\n        LEN = 1 + rand() % MAXLEN;\\n        printf(\\"%d\\\\n\\", LEN);\\n        for (int j = 1; j <= LEN; j++)\\n            printf(\\"%c\\", \'a\' + rand() % MAX);\\n        printf(\\"\\\\n\\");\\n    }\\n}\\n\\nint main() {\\n    randString();\\n}\\n","py":"import random as r\\nRUN=5\\nMAX=25\\nMAXLEN=100\\ndef randString():\\n    for i in range(RUN):\\n        LEN=1+r.randint(0,MAXLEN)\\n        print(LEN)\\n        STR=\\"\\"\\n        for j in range(LEN):\\n            STR+=chr(ord(\'a\') + r.randint(0,MAX))\\n        print(STR)\\n        \\nrandString()\\n","orden":11,"suborden":5,"fecha_creacion":"2020-12-06 19:51:53","fecha_modificacion":"2020-12-06 20:34:20"},{"ID":254,"supergrupo":"Generadores","tema":"Vectores de cadenas de caracteres aleatorias","texto":null,"complejidad_tiempo":"No aplica","java":"// Un programa java para generar casos de prueba para cadenas aleatorias\\n\\nimport java.util.Random;\\npublic class TestCasesRandomArrayStrings {\\n\\n    // Define el n\xfamero de corridas para los datos de prueba generados.\\n    static int RUN = 1000;\\n    // Define el rango de los datos de prueba generados Aqu\xed es de \'a\' a \'z\'\\n    static int MAX = 25;\\n    // Definie el rango de n\xfamero de cadenas en la matriz.\\n    static int MAXNUM = 20;\\n    // Define la longitud m\xe1xima de la cadena\\n    static int MAXLEN = 20;\\n\\n    static void randomStrArr() {\\n        Random r = new Random();\\n        int NUM; // N\xfamero de cadenas en la matriz\\n        int LEN; // Longitud de la cadena\\n        for (int i = 1; i <= RUN; i++) {\\n            NUM = 1 + r.nextInt(MAXNUM);\\n            System.out.printf(\\"%d\\\\n\\", NUM);\\n            for (int k = 1; k <= NUM; k++) {\\n                LEN = 1 + r.nextInt(MAXLEN);;\\n                // Luego imprime los caracteres de la cadena\\n                for (int j = 1; j <= LEN; j++) {\\n                    System.out.printf(\\"%c\\", \'a\' + r.nextInt(MAX));\\n                }\\n                System.out.printf(\\" \\");\\n            }\\n            System.out.printf(\\"\\\\n\\");\\n        }\\n    }\\n\\n    public static void main(String[] args) {\\n        randomStrArr();\\n    }\\n}\\n","cpp":"#include<bits/stdc++.h> \\nusing namespace std;\\n\\n\\n#define RUN 1000 \\n#define MAX 25 \\n#define MAXNUM 20\\n#define MAXLEN 20 \\n\\nvoid randomStrArr() {\\n    srand(time(NULL));\\n    int NUM; \\n    int LEN;\\n    for (int i = 1; i <= RUN; i++) {\\n        NUM = 1 + rand() % MAXNUM;\\n        printf(\\"%d\\\\n\\", NUM);\\n\\n        for (int k = 1; k <= NUM; k++) {\\n            LEN = 1 + rand() % MAXLEN;\\n            for (int j = 1; j <= LEN; j++)\\n                printf(\\"%c\\", \'a\' + rand() % MAX);\\n\\n            printf(\\" \\");\\n        }\\n        printf(\\"\\\\n\\");\\n    }\\n}\\n\\nint main() {\\n    randomStrArr();\\n    return (0);\\n}\\n","py":"import random as r\\nRUN = 1000 \\nMAX = 25 \\nMAXNUM = 20\\nMAXLEN =  20 \\ndef randomStrArr():\\n    for i in range (1,RUN+1):\\n        NUM = r.randint(1,MAXNUM)\\n        print(NUM)\\n        for k in range (1,NUM):\\n            LEN = r.randint(1,MAXLEN)\\n            str1=\\"\\"\\n            for J in range (1,LEN):\\n                str1+=chr(ord(\'a\')+r.randint(0,MAX))+\\"\\";\\n            print (str1)\\n            str1=\\"\\"\\n\\nrandomStrArr()\\n","orden":11,"suborden":6,"fecha_creacion":"2020-12-06 19:51:53","fecha_modificacion":"2020-12-06 20:34:21"},{"ID":255,"supergrupo":"Generadores","tema":"Pal\xedndromos aleatorios","texto":null,"complejidad_tiempo":"No aplica","java":"import java.util.LinkedList;\\nimport java.util.Random;\\n\\npublic class TestCasesRandomPalindromes {\\n\\n    static int RUN = 5;\\n    static int MAX = 25;\\n    static int MAXLEN = 50;\\n\\n    static void randPalindrome() {\\n        Random r = new Random();\\n        // Un recipiente para almacenar los pal\xedndromos. \\n        LinkedList<Character> container = new LinkedList<>();\\n        int LEN; // Longitud de la cadena\\n        for (int i = 1; i <= RUN; i++) {\\n            LEN = 1 + r.nextInt(MAXLEN);\\n            // Primero imprime la longitud de la cadena\\n            System.out.printf(\\"%d\\\\n\\", LEN);\\n            // Si es un pal\xedndromo de longitud impar\\n            if (LEN % 2 == 1) {\\n                container.addLast((char) (\'a\' + r.nextInt(MAX)));\\n            }\\n            // Luego imprime los caracteres de la cadena palindr\xf3mica\\n            for (int j = 1; j <= LEN / 2; j++) {\\n                char ch = (char) (\'a\' + r.nextInt(MAX));\\n                container.addLast(ch);\\n                container.addFirst(ch);\\n            }\\n            for (Character c : container) {\\n                System.out.printf(\\"%c\\", c);\\n            }\\n            container.clear();\\n            System.out.printf(\\"\\\\n\\");\\n        }\\n    }\\n\\n    public static void main(String[] args) {\\n        randPalindrome();\\n    }\\n\\n}\\n","cpp":"#include<bits/stdc++.h> \\nusing namespace std;\\n\\n#define RUN 5 \\n#define MAX 25 \\n#define MAXLEN 50 \\n\\nvoid randPalindrome(){\\n    srand(time(NULL));\\n    deque<char> container;\\n    deque<char>::iterator it;\\n    int LEN; \\n    for (int i = 1; i <= RUN; i++) {\\n        LEN = 1 + rand() % MAXLEN;\\n        printf(\\"%d\\\\n\\", LEN);\\n        if (LEN % 2)\\n            container.push_back(\'a\' + rand() % MAX);\\n\\n        for (int j = 1; j <= LEN / 2; j++) {\\n            char ch = \'a\' + rand() % MAX;\\n            container.push_back(ch);\\n            container.push_front(ch);\\n        }\\n        for (it = container.begin(); it != container.end(); ++it)\\n            printf(\\"%c\\", *it);\\n\\n        container.clear();\\n        printf(\\"\\\\n\\");\\n    } \\n}\\n\\nint main() {\\n    randPalindrome();\\n}\\n","py":"import random as r\\n\\nRUN=5\\nMAX=25\\nMAXLEN=25\\ndef randPalindrome():\\n    container=[]\\n    for i in range(RUN):\\n        LEN=1+r.randint(0,MAXLEN)\\n        print(LEN)\\n        if LEN%2==1:\\n            container.append(chr(ord(\'a\')+r.randint(0,MAX)))\\n        for j in range (1,LEN/2+1):\\n            ch=chr(ord(\'a\')+r.randint(0,MAX))\\n            container.append(ch)\\n            container.insert(0,ch)\\n        palin=str(container)\\n        palin=palin.replace(\\"[\\", \\"\\")\\n        palin=palin.replace(\\"]\\", \\"\\")\\n        palin=palin.replace(\\"\'\\", \\"\\")\\n        palin=palin.replace(\\",\\", \\"\\")\\n        palin=palin.replace(\\" \\", \\"\\")\\n        print(palin)\\n        \\nrandPalindrome()\\n","orden":11,"suborden":7,"fecha_creacion":"2020-12-06 19:51:54","fecha_modificacion":"2020-12-06 20:34:22"},{"ID":256,"supergrupo":"Generadores","tema":"Grafos no ponderados aleatorios","texto":null,"complejidad_tiempo":"No aplica","java":"// Program to generate test cases for an unweighted directed graph \\n\\nimport java.util.HashSet;\\nimport java.util.Random;\\nimport java.util.Set;\\n\\npublic class TestCasesUnweightedDirectedGraph {\\n\\n    // Definir el n\xfamero de corridas para los datos de prueba generados. \\n    static int RUN = 5;\\n    // Definir el n\xfamero m\xe1ximo de v\xe9rtices del grafo.\\n    static int MAX_VERTICES = 20;\\n    // Definir el n\xfamero m\xe1ximo de aristas\\n    static int MAX_EDGES = 20;\\n\\n    static class Pair {\\n\\n        int first, second;\\n\\n        public Pair(int first, int second) {\\n            this.first = first;\\n            this.second = second;\\n        }\\n\\n    }\\n\\n    static int getIndex(Set<Pair> set, Pair value) {\\n        int result = 0;\\n        for (Object entry : set) {\\n            if (entry.equals(value)) {\\n                return result;\\n            }\\n            result++;\\n        }\\n        return set.size() + 1;\\n    }\\n\\n    public static void main(String[] args) {\\n        Set<Pair> container = new HashSet<>();\\n        //Para valores aleatorios cada vez\\n        Random r = new Random();\\n\\n        int VERTICES; // N\xfamero de v\xe9rtices\\n        int NUMEDGE; // N\xfamero de bordes\\n\\n        for (int i = 1; i <= RUN; i++) {\\n            VERTICES = 1 + r.nextInt(MAX_VERTICES);\\n            // Definir el n\xfamero m\xe1ximo de aristas del grafo Dado que el grafo \\n            // m\xe1s denso puede tener N * (N-1) / 2 aristas donde \\n            // N = n\xfamero de v\xe9rtices en el gr\xe1fico\\n            NUMEDGE = 1 + r.nextInt(MAX_EDGES);\\n            while (NUMEDGE > VERTICES * (VERTICES - 1) / 2) {\\n                NUMEDGE = 1 + r.nextInt(MAX_EDGES);\\n            }\\n            // Primero imprime el n\xfamero de v\xe9rtices y aristas\\n            System.out.printf(\\"%d %d\\\\n\\", VERTICES, NUMEDGE);\\n            // Luego imprima los bordes del formulario (a b) \\n            // donde \'a\' est\xe1 conectado a \'b\'\\n            for (int j = 1; j <= NUMEDGE; j++) {\\n                int a = 1 + r.nextInt(VERTICES);\\n                int b = 1 + r.nextInt(VERTICES);\\n                Pair p = new Pair(a, b);\\n                // Busca una ventaja \\"nueva\\" aleatoria cada vez\\n                // Nota: en un \xe1rbol, el borde (a, b) es el mismo que el borde (b, a)\\n                while (getIndex(container, p) != container.size() + 1) {\\n                    a = 1 + r.nextInt(VERTICES);\\n                    b = 1 + r.nextInt(VERTICES);\\n                    p = new Pair(a, b);\\n                }\\n                container.add(p);\\n            }\\n            for (Pair p : container) {\\n                System.out.printf(\\"%d %d\\\\n\\", p.first - 1, p.second - 1);\\n            }\\n            container.clear();\\n            System.out.printf(\\"\\\\n\\");\\n        }\\n\\n    }\\n}\\n","cpp":"#include<bits/stdc++.h> \\nusing namespace std;\\n\\n#define RUN 5 \\n#define MAX_VERTICES 20 \\n#define MAX_EDGES 20 \\n\\nint main() {\\n    set<pair<int, int>> container;\\n    srand(time(NULL));\\n    int VERTICES;\\n    int NUMEDGE;\\n    for (int i = 1; i <= RUN; i++) {\\n        VERTICES = 1 + rand() % MAX_VERTICES;\\n        NUMEDGE = 1 + rand() % MAX_EDGES;\\n        while (NUMEDGE > VERTICES * (VERTICES - 1) / 2)\\n            NUMEDGE = 1 + rand() % MAX_EDGES;\\n        printf(\\"%d %d\\\\n\\", VERTICES, NUMEDGE);\\n        for (int j = 1; j <= NUMEDGE; j++) {\\n            int a = 1 + rand() % VERTICES;\\n            int b = 1 + rand() % VERTICES;\\n            pair<int, int> p = make_pair(a, b);\\n            while (container.find(p) != container.end()) {\\n                a = 1 + rand() % VERTICES;\\n                b = 1 + rand() % VERTICES;\\n                p = make_pair(a, b);\\n            }\\n            container.insert(p);\\n        }\\n        for (pair<int, int> p : container) {\\n            printf(\\"%d %d\\\\n\\", p.first - 1, p.second - 1);\\n        }\\n        container.clear();\\n        printf(\\"\\\\n\\");\\n    }\\n    return (0);\\n}\\n","py":"import random as r\\nRUN = 5\\nMAX_VERTICES = 20\\nMAX_EDGES = 20\\nclass Pair:\\n    def __init__(self, first, second):\\n        self.first = first\\n        self.second = second\\n        \\ndef getIndex(setin, value):\\n    result = 0;\\n    for entry in setin:\\n        if (entry == value):\\n            return result\\n        result += 1;\\n    return len(setin) + 1;\\n    \\ncontainer = {}\\nfor i in range (RUN):\\n    VERTICES = 1 + r.randint(0, MAX_VERTICES)\\n    NUMEDGE = 1 + r.randint(0, MAX_EDGES)\\n    while (NUMEDGE > VERTICES * (VERTICES - 1) / 2):\\n        NUMEDGE = 1 + r.randint(0, MAX_EDGES)\\n    print(str(VERTICES) + \\" \\" + str(NUMEDGE)) \\n    for j in range (NUMEDGE):\\n        a = 1 + r.randint(0, VERTICES);\\n        b = 1 + r.randint(0, VERTICES);\\n        p = Pair(a, b)\\n        while (getIndex(container, p) != len(container) + 1):\\n            a = 1 + r.randint(0, VERTICES)\\n            b = 1 + r.randint(0, VERTICES)\\n            p = Pair()\\n            p.first = a\\n            p.second = b\\n        container[j] = p\\n    for p in container:\\n        print(str(container[p].first) + \\" \\" + str(container[p].second))\\n    container.clear();\\n    print(\\"\\")\\n","orden":11,"suborden":8,"fecha_creacion":"2020-12-06 19:51:54","fecha_modificacion":"2020-12-06 20:34:22"},{"ID":257,"supergrupo":"Generadores","tema":"Grafos ponderados aleatorios","texto":null,"complejidad_tiempo":"No aplica","java":"// Programa para generar casos de prueba para un gr\xe1fico dirigido no ponderado \\n\\nimport java.util.HashSet;\\nimport java.util.Random;\\nimport java.util.Set;\\n\\npublic class TestCasesWeightedDirectedGraph {\\n\\n    // Definir el n\xfamero de corridas para los datos de prueba generados.\\n    static int RUN = 5;\\n    // Definir el n\xfamero m\xe1ximo de v\xe9rtices del gr\xe1fico.\\n    static int MAX_VERTICES = 20;\\n    // Definir el n\xfamero m\xe1ximo de aristas\\n    static int MAX_EDGES = 20;\\n    static int MAXWEIGHT = 200;\\n\\n    static class Pair {\\n\\n        int first, second;\\n\\n        public Pair(int first, int second) {\\n            this.first = first;\\n            this.second = second;\\n        }\\n\\n    }\\n\\n    static int getIndex(Set<Pair> set, Pair value) {\\n        int result = 0;\\n        for (Object entry : set) {\\n            if (entry.equals(value)) {\\n                return result;\\n            }\\n            result++;\\n        }\\n        return set.size() + 1;\\n    }\\n\\n    public static void main(String[] args) {\\n        Set<Pair> container = new HashSet<>();\\n        //Para valores aleatorios cada vez\\n        Random r = new Random();\\n\\n        int VERTICES; // N\xfamero de v\xe9rtices\\n        int NUMEDGE; // N\xfamero de caminos\\n\\n        for (int i = 1; i <= RUN; i++) {\\n            VERTICES = 1 + r.nextInt(MAX_VERTICES);\\n            // Definir el n\xfamero m\xe1ximo de aristas del grafo Dado que el grafo \\n            // m\xe1s denso puede tener N * (N-1) / 2 aristas donde \\n            // N = n\xfamero de v\xe9rtices en el grafo\\n            NUMEDGE = 1 + r.nextInt(MAX_EDGES);\\n            while (NUMEDGE > VERTICES * (VERTICES - 1) / 2) {\\n                NUMEDGE = 1 + r.nextInt(MAX_EDGES);\\n            }\\n            // Primero imprime el n\xfamero de v\xe9rtices y aristas\\n            System.out.printf(\\"%d %d\\\\n\\", VERTICES, NUMEDGE);\\n            // Luego imprima los bordes del formulario (a b) donde \'a\' est\xe1 conectado a \'b\'\\n            for (int j = 1; j <= NUMEDGE; j++) {\\n                int a = 1 + r.nextInt(VERTICES);\\n                int b = 1 + r.nextInt(VERTICES);\\n                Pair p = new Pair(a, b);\\n                // Busque una ventaja \\"nueva\\" aleatoria cada vez\\n                // Nota: en un \xe1rbol, el borde (a, b) es el mismo que el borde (b, a)\\n                while (getIndex(container, p) != container.size() + 1) {\\n                    a = 1 + r.nextInt(VERTICES);\\n                    b = 1 + r.nextInt(VERTICES);\\n                    p = new Pair(a, b);\\n                }\\n                container.add(p);\\n            }\\n            for (Pair p : container) {\\n                int wt = 1 + r.nextInt(MAXWEIGHT);\\n                System.out.printf(\\"%d %d %d\\\\n\\", p.first - 1, p.second - 1, wt);\\n            }\\n            container.clear();\\n            System.out.printf(\\"\\\\n\\");\\n        }\\n\\n    }\\n}\\n","cpp":"#include<bits/stdc++.h> \\nusing namespace std;\\n\\n#define RUN 5 \\n#define MAX_VERTICES 20 \\n#define MAX_EDGES 20 \\n#define MAXWEIGHT 200 \\n\\nint main() {\\n    set<pair<int, int>> container;\\n    srand(time(NULL));\\n    int VERTICES;\\n    int NUMEDGE;\\n    for (int i = 1; i <= RUN; i++) {\\n        VERTICES = 1 + rand() % MAX_VERTICES;\\n        NUMEDGE = 1 + rand() % MAX_EDGES;\\n        while (NUMEDGE > VERTICES * (VERTICES - 1) / 2)\\n            NUMEDGE = 1 + rand() % MAX_EDGES;\\n        printf(\\"%d %d\\\\n\\", VERTICES, NUMEDGE);\\n        for (int j = 1; j <= NUMEDGE; j++) {\\n            int a = 1 + rand() % VERTICES;\\n            int b = 1 + rand() % VERTICES;\\n            pair<int, int> p = make_pair(a, b);\\n            while (container.find(p) != container.end()) {\\n                a = 1 + rand() % VERTICES;\\n                b = 1 + rand() % VERTICES;\\n                p = make_pair(a, b);\\n            }\\n            container.insert(p);\\n        }\\n\\n        for (pair<int, int> p : container) {\\n            int wt = 1 + rand() % MAXWEIGHT;\\n            printf(\\"%d %d %d\\\\n\\", p.first - 1, p.second - 1, wt);\\n        }\\n        container.clear();\\n        printf(\\"\\\\n\\");\\n    }\\n    return (0);\\n}\\n","py":"import random as r\\nRUN = 5\\nMAX_VERTICES = 20\\nMAX_EDGES = 20\\nMAXWEIGHT = 200\\nclass Pair:\\n    def __init__(self, first, second):\\n        self.first = first\\n        self.second = second\\n        \\ndef getIndex(setin, value):\\n    result = 0;\\n    for entry in setin:\\n        if (entry == value):\\n            return result\\n        result += 1;\\n    return len(setin) + 1;\\n    \\ncontainer = {}\\nfor i in range (RUN):\\n    VERTICES = 1 + r.randint(0, MAX_VERTICES)\\n    NUMEDGE = 1 + r.randint(0, MAX_EDGES)\\n    while (NUMEDGE > VERTICES * (VERTICES - 1) / 2):\\n        NUMEDGE = 1 + r.randint(0, MAX_EDGES)\\n    print(str(VERTICES) + \\" \\" + str(NUMEDGE)) \\n    for j in range (NUMEDGE):\\n        a = 1 + r.randint(0, VERTICES);\\n        b = 1 + r.randint(0, VERTICES);\\n        p = Pair(a, b)\\n        while (getIndex(container, p) != len(container) + 1):\\n            a = 1 + r.randint(0, VERTICES)\\n            b = 1 + r.randint(0, VERTICES)\\n            p = Pair()\\n            p.first = a\\n            p.second = b\\n        container[j] = p\\n    for p in container:\\n        wt = 1 + r.randint(0, MAXWEIGHT);\\n        print(str(container[p].first) + \\" \\" + str(container[p].second) + \\" \\" + str(wt))\\n    container.clear();\\n    print(\\"\\")\\n","orden":11,"suborden":9,"fecha_creacion":"2020-12-06 19:51:54","fecha_modificacion":"2020-12-06 20:34:23"},{"ID":278,"supergrupo":"Estructuras","tema":"Estructuras de datos b\xe1sicas","texto":"Una estructura de datos es una colecci\xf3n de valores, la relaci\xf3n que existe entre estos valores y las operaciones que podemos hacer sobre ellos se refieren a c\xf3mo los datos est\xe1n organizados y c\xf3mo se pueden administrar. Una estructura de datos describe el formato en que los valores van a ser almacenados, c\xf3mo van a ser accedidos y modificados, pudiendo as\xed existir una gran cantidad de estructuras de datos.\\nLo habitual es que un vector tenga una cantidad fija de memoria asignada, aunque dependiendo del tipo de vector y del lenguaje de programaci\xf3n un vector podr\xeda tener una cantidad variable de datos. En este caso, se les denomina vectores din\xe1micos, en oposici\xf3n, a los vectores con una cantidad fija de memoria asignada se los denomina vectores est\xe1ticos. El uso de vectores din\xe1micos requiere realizar una apropiada gesti\xf3n de memoria din\xe1mica. Un uso incorrecto de los vectores din\xe1micos, o mejor dicho, una mala gesti\xf3n de la memoria din\xe1mica, puede conducir a una fuga de memoria. Al utilizar vectores din\xe1micos siempre habr\xe1 que liberar la memoria utilizada cuando \xe9sta ya no se vaya a seguir utilizando.\\nLenguajes m\xe1s modernos y de m\xe1s alto nivel, cuentan con un mecanismo denominado recolector de basura que permiten que el programa decida si debe liberar el espacio bas\xe1ndose en si se va a utilizar en el futuro o no un determinado objeto.\\n\\nVector tama\xf1o fijo (Array):\\n \\nSe le denomina vector o arreglo (en ingl\xe9s Array) a una zona de almacenamiento contiguo que contiene una serie de elementos del mismo tipo, los elementos de la matriz. Desde el punto de vista l\xf3gico una matriz se puede ver como un conjunto de elementos ordenados en fila.\\nEstas estructuras de datos son adecuadas para situaciones en las que el acceso a los datos se realice de forma aleatoria e impredecible. Por el contrario, si los elementos pueden estar ordenados y se va a utilizar acceso secuencial ser\xeda m\xe1s adecuado utilizar una lista, ya que esta estructura puede cambiar de tama\xf1o f\xe1cilmente durante la ejecuci\xf3n de un programa.\\n\\nVector tama\xf1o din\xe1mico o lista (ArrayList):\\nEn programaci\xf3n, un arreglo din\xe1mico o Array din\xe1mico, es un Array de elementos que crece o mengua din\xe1micamente conforme los elementos se agregan o se eliminan. Se suministra como librer\xedas est\xe1ndar en muchos lenguajes modernos de programaci\xf3n.\\n\\nVector sin repetici\xf3n (Set):\\nEs una colecci\xf3n desordenada de objetos en la que no se pueden almacenar valores duplicados. \\n\\nMatriz (Matrix):\\n \\nEs una tabla bidimensional de n\xfameros consistentes en cantidades abstractas con las que se pueden realizar diferentes operaciones, como por ejemplo la suma, multiplicaci\xf3n y descomposici\xf3n de las mismas de varias formas, lo que tambi\xe9n las hace un concepto clave en el campo del \xe1lgebra lineal. Las matrices se utilizan para describir sistema de ecuaciones lineales, realizar un seguimiento de los coeficientes de una aplicaci\xf3n lineal y registrar los datos que dependen de varios par\xe1metros.\\n\\nDiccionario o mapa (HashMap, TreeMap o Map):\\nLos mapas son contenedores asociativos que almacenan elementos de forma mapeada. Cada elemento tiene un valor clave y un valor asignado. No hay dos valores asignados que puedan tener los mismos valores clave.\\n\\nPila (Stack):\\n \\nEs una lista ordenada o estructura de datos que permite almacenar y recuperar datos, el modo de acceso a sus elementos es de tipo LIFO (del ingl\xe9s Last In, First Out, \xab\xfaltimo en entrar, primero en salir\xbb). Esta estructura se aplica en multitud de problemas en el \xe1rea de inform\xe1tica debido a su simplicidad y capacidad de dar respuesta a numerosos procesos.\\n\\nCola (Queue):\\n \\nEs una estructura de datos, caracterizada por ser una secuencia de elementos en la que la operaci\xf3n de inserci\xf3n push se realiza por un extremo y la operaci\xf3n de extracci\xf3n pop por el otro. Tambi\xe9n se le llama estructura FIFO (del ingl\xe9s First In First Out), debido a que el primer elemento en entrar ser\xe1 tambi\xe9n el primero en salir.\\n","complejidad_tiempo":null,"java":"import java.util.*;\\n\\npublic class Main {\\n\\n    public static Random r = new Random();\\n    public static int i, j;\\n    public static void main(String args[]) {\\n        Scanner sc = new Scanner(System.in);\\n        System.out.println(\\"Inserte cantidad de datos\\");\\n        int n = sc.nextInt();\\n        System.out.println(\\"Que estructura quiere utilizar? (Los n\xfameros son aleatorios\\");\\n        System.out.println(\\"1) Vector fijo \\");\\n        System.out.println(\\"2) Vector din\xe1mico\\");\\n        System.out.println(\\"3) Vector sin repetici\xf3n\\");\\n        System.out.println(\\"4) Matriz\\");\\n        System.out.println(\\"5) Diccionario\\");\\n        System.out.println(\\"6) Pila\\");\\n        System.out.println(\\"7) Cola\\");\\n        int aux = sc.nextInt();\\n        switch (aux) {\\n            case 1:\\n                vectorfijo(n);\\n                break;\\n            case 2:\\n                vectordinamico(n);\\n                break;\\n            case 3:\\n                vectorsinrepeticion(n);\\n                break;\\n            case 4:\\n                matriz(n);\\n                break;\\n            case 5:\\n                Diccionario(n);\\n                break;\\n            case 6:\\n                pila(n);\\n                break;\\n            case 7:\\n                cola(n);\\n                break;\\n        }\\n    }\\n    public static void vectordinamico(int n) {\\n        ArrayList<Integer> arreglo = new ArrayList<>();\\n        for (i = 0; i < n; i++) {\\n            arreglo.add(r.nextInt());\\n        }\\n        for (i = 0; i < n; i++) {\\n            System.out.println(arreglo.get(i));\\n        }\\n    }\\n    public static void vectorfijo(int n) {\\n        int[] n\xfameros = new int[n];\\n        for (i = 0; i < n; i++) {\\n            n\xfameros[i] = r.nextInt();\\n        }\\n        for (i = 0; i < n; i++) {\\n            System.out.println(n\xfameros[i]);\\n        }\\n    }\\n    public static void matriz(int n) {\\n        int[][] matrix = new int[n][n];\\n        for (i = 0; i < n; i++) {\\n            for (j = 0; j < n; j++) {\\n                matrix[i][j] = r.nextInt(50);\\n            }\\n        }\\n        for (i = 0; i < n; i++) {\\n            for (j = 0; j < n; j++) {\\n                System.out.print(matrix[i][j] + \\" \\");\\n            }\\n            System.out.println(\\"\\");\\n        }\\n    }\\n    public static void vectorsinrepeticion(int n) {\\n        HashSet<Integer> sinrep = new HashSet<>();\\n        for (i = 0; i < n; i++) {\\n            sinrep.add(r.nextInt(50));\\n        }\\n        Iterator it = sinrep.iterator();\\n        while (it.hasNext()) {\\n            System.out.println(it.next());\\n        }\\n    }\\n    public static void Diccionario(int n) {\\n TreeMap<String, String> dicc = new TreeMap<>();\\n        dicc.put(\\"Programar\\", \\"Utilizacion de codigo para ejecutar un programa\\");\\n        dicc.put(\\"Futbol\\", \\"Deporte con una pelota y arcos\\");\\n        dicc.put(\\"helado\\", \\"crema helada\\");\\n        dicc.put(\\"Sargento mayor Johnson\\", \\"Practicar con palos y piedras\\");\\n        for (String concepto : dicc.keySet()) {\\n            String key = concepto;\\n            String value = dicc.get(concepto);\\n            System.out.println(key + \\"->\\" + value);\\n        }\\n    }\\n    public static void pila(int n) {\\n        Stack<Integer> mipila = new Stack<>();\\n        for (i = 0; i < n; i++) {\\n            mipila.push(r.nextInt(50));\\n        }\\n        while (!mipila.isEmpty()) {\\n            System.out.println(mipila.pop());\\n        }\\n    }\\n    public static void cola(int n) {\\n        Queue<Integer> micola = new LinkedList<>();\\n        for (i = 0; i < n; i++) {\\n            micola.offer(r.nextInt(50));\\n        }\\n        while (!micola.isEmpty()) {\\n            System.out.println(micola.poll());\\n        }\\n    }\\n}\\n","cpp":"#include<bits/stdc++.h>\\n#include<cstdlib>\\nusing namespace std;\\nint i, j;\\nvoid vectordinamico(int n) {\\n    vector<int> arreglo;\\n    for (i = 0; i < n; i++) {\\n        arreglo.push_back(rand() % 100);\\n    }\\n    for (i = 0; i < n; i++) {\\n        cout << arreglo.at(i) << endl;\\n    }\\n\\n}\\n\\nvoid vectorfijo(int n) {\\n    int n\xfameros[n];\\n    for (i = 0; i < n; i++) {\\n        n\xfameros[i] = rand() % 100;\\n    }\\n    for (i = 0; i < n; i++) {\\n        cout << n\xfameros[i] << endl;\\n    }\\n}\\n\\nvoid matriz(int n) {\\n    int matrix [n][n];\\n    for (i = 0; i < n; i++) {\\n        for (j = 0; j < n; j++) {\\n            matrix[i][j] = rand() % 100;\\n        }\\n    }\\n    for (i = 0; i < n; i++) {\\n        for (j = 0; j < n; j++) {\\n            cout << matrix[i][j] << \\" \\";\\n        }\\n        cout << endl;\\n    }\\n}\\n\\nvoid vectorsinrepeticion(int n) {\\n    set<int> sinrep;\\n    for (i = 0; i < n; i++) {\\n        sinrep.insert(rand() % 100);\\n    }\\n    for (auto itr = sinrep.begin(); itr != sinrep.end(); ++itr) {\\n        cout << *itr << endl;\\n    }\\n}\\n\\nvoid Diccionario(int n) {\\n      map <string, int> mapa;\\n    int cantidad;\\n    cin>>cantidad;\\n    for (int i = 0; i < cantidad; i++) {\\n        string dato1;\\n        int dato2;\\n        cin >> dato1>>dato2;\\n        mapa.insert(type_pair(dato1, dato2));\\n    }\\n    cout << endl;\\n    for (type_pair j : mapa) {\\n        cout << j.first << \\" \\" << j.second << endl;\\n    }\\n}\\n\\nvoid pila(int n) {\\n    stack<int> mipila;\\n\\n    for (i = 0; i < n; i++) {\\n        mipila.push(rand() % 100);\\n    }\\n    while (!mipila.empty()) {\\n        cout << mipila.top() << endl;\\n        mipila.pop();\\n    }\\n}\\n\\nvoid cola(int n) {\\n    queue<int> micola;\\n    for (i = 0; i < n; i++) {\\n        micola.push(rand() % 100);\\n    }\\n    while (!micola.empty()) {\\n        cout << micola.front() << endl;\\n        micola.pop();\\n    }\\n}\\n\\nint main(int argc, char *argv[]) {\\n    cout << \\"Inserte cantidad de datos\\" << endl;\\n    int n;\\n    cin>>n;\\n    cout << \\"Que estructura quiere utilizar? (Los n\xfameros son aleatorios\\" << endl;\\n    cout << \\"1) Vector fijo \\" << endl;\\n    cout << \\"2) Vector dinamico\\" << endl;\\n    cout << \\"3) Vector sin repeticion\\" << endl;\\n    cout << \\"4) Matriz\\" << endl;\\n    cout << \\"5) Diccionario\\" << endl;\\n    cout << \\"6) Pila\\" << endl;\\n    cout << \\"7) Cola\\" << endl;\\n    int aux;\\n    cin>>aux;\\n    switch (aux) {\\n        case 1:\\n            vectorfijo(n);\\n            break;\\n        case 2:\\n            vectordinamico(n);\\n            break;\\n        case 3:\\n            vectorsinrepeticion(n);\\n            break;\\n        case 4:\\n            matriz(n);\\n            break;\\n        case 5:\\n            Diccionario(n);\\n            break;\\n        case 6:\\n            pila(n);\\n            break;\\n        case 7:\\n            cola(n);\\n            break;\\n    }\\n    return 0;\\n}\\n","py":"from collections import deque\\nimport random\\ndef vector(n):\\n    arreglo = []\\n    for i in (0, n):\\n        arreglo.append(random.randint(0, 100))\\n        \\n    for i in (arreglo):\\n        print(i)\\n\\ndef matriz(n):\\n    matrix = []\\n    for i in range(n):\\n        row = []\\n        for j in range(n):\\n            row.append(random.randint(0, 100))\\n        matrix.append(row)\\n    for i in range(n):\\n        for j in range(n):\\n            print(matrix[i][j]+\\" \\")\\n        print()    \\n\\ndef vectorsinrepeticion(n):\\n    sinrep = {0}\\n    for i in range(n):\\n        sinrep.add(random.randint(0, 100))\\n    sinrep.remove(0)    \\n    for i in sinrep:\\n        print(i)\\n\\ndef Diccionario(n):\\n    dicc = {}\\n       dicc[\'Programar\'] = \'Utilizacion de codigo para ejecutar un programa\\ndicc[\'Futbol\'] = \'Deporte con una pelota y arcos\'\\n\\nfor concepto, definicion in dicc.items():\\n    print(f\'{concepto} -> {definicion}\')\\n        \\ndef pila(n):\\n    mipila = []\\n    for i in range(n):\\n        mipila.append(random.randint(0, 100))\\n    while(len(mipila) != 0):\\n        print(mipila.pop())\\n\\ndef cola(n): \\n    micola = deque([])\\n    for i in range(n):\\n        micola.append(random.randint(0, 100))\\n\\n    while(len(micola) != 0):\\n        print(micola.popleft())\\nprint(\\"Inserte cantidad de datos\\")\\nn = int(input())\\n#No existe switch en python\\nprint(\\"Vector\\")\\nvector(n)\\nprint(\\"Vector sin repetici\xf3n\\")\\nvectorsinrepeticion(n)\\nprint(\\"Diccionario\\")\\nDiccionario(n)\\nprint(\\"Pila\\")\\npila(n)\\nprint(\\"Cola\\")\\ncola(n);\\nprint(\\"Matriz\\")\\nmatriz(n)\\n","orden":1,"suborden":0,"fecha_creacion":"2020-12-06 20:56:45","fecha_modificacion":"2022-03-08 14:36:15"}]');var Z4={prefix:"far",iconName:"arrow-alt-circle-right",icon:[512,512,[],"f35a","M504 256C504 119 393 8 256 8S8 119 8 256s111 248 248 248 248-111 248-248zm-448 0c0-110.5 89.5-200 200-200s200 89.5 200 200-89.5 200-200 200S56 366.5 56 256zm72 20v-40c0-6.6 5.4-12 12-12h116v-67c0-10.7 12.9-16 20.5-8.5l99 99c4.7 4.7 4.7 12.3 0 17l-99 99c-7.6 7.6-20.5 2.2-20.5-8.5v-67H140c-6.6 0-12-5.4-12-12z"]},Pi=Q(801),cc=Q(9444);const np=["ref"];function V7(r){return r&&r.replace(/\r\n|\r/g,"\n")}let t3=(()=>{class r{constructor(e,c){this._differs=e,this._ngZone=c,this.className="",this.name="codemirror",this.autoFocus=!1,this.preserveScrollPosition=!1,this.cursorActivity=new d.vpe,this.focusChange=new d.vpe,this.scroll=new d.vpe,this.drop=new d.vpe,this.value="",this.disabled=!1,this.isFocused=!1,this.onChange=m=>{},this.onTouched=()=>{}}set options(e){this._options=e,!this._differ&&e&&(this._differ=this._differs.find(e).create())}get codeMirrorGlobal(){return this._codeMirror||(this._codeMirror="undefined"!=typeof CodeMirror?CodeMirror:Promise.resolve().then(Q.t.bind(Q,8266,19))),this._codeMirror}ngAfterViewInit(){this._ngZone.runOutsideAngular(()=>function I7(r,a,e,c){return new(e||(e=Promise))(function(v,S){function A(ae){try{q(c.next(ae))}catch(ze){S(ze)}}function H(ae){try{q(c.throw(ae))}catch(ze){S(ze)}}function q(ae){ae.done?v(ae.value):function m(v){return v instanceof e?v:new e(function(S){S(v)})}(ae.value).then(A,H)}q((c=c.apply(r,a||[])).next())})}(this,void 0,void 0,function*(){const e=yield this.codeMirrorGlobal;this.codeMirror=((null==e?void 0:e.default)?e.default:e).fromTextArea(this.ref.nativeElement,this._options),this.codeMirror.on("cursorActivity",m=>this._ngZone.run(()=>this.cursorActive(m))),this.codeMirror.on("scroll",this.scrollChanged.bind(this)),this.codeMirror.on("blur",()=>this._ngZone.run(()=>this.focusChanged(!1))),this.codeMirror.on("focus",()=>this._ngZone.run(()=>this.focusChanged(!0))),this.codeMirror.on("change",(m,v)=>this._ngZone.run(()=>this.codemirrorValueChanged(m,v))),this.codeMirror.on("drop",(m,v)=>{this._ngZone.run(()=>this.dropFiles(m,v))}),this.codeMirror.setValue(this.value)}))}ngDoCheck(){if(!this._differ)return;const e=this._differ.diff(this._options);e&&(e.forEachChangedItem(c=>this.setOptionIfChanged(c.key,c.currentValue)),e.forEachAddedItem(c=>this.setOptionIfChanged(c.key,c.currentValue)),e.forEachRemovedItem(c=>this.setOptionIfChanged(c.key,c.currentValue)))}ngOnDestroy(){this.codeMirror&&this.codeMirror.toTextArea()}codemirrorValueChanged(e,c){const m=e.getValue();this.value!==m&&(this.value=m,this.onChange(this.value))}setOptionIfChanged(e,c){!this.codeMirror||this.codeMirror.setOption(e,c)}focusChanged(e){this.onTouched(),this.isFocused=e,this.focusChange.emit(e)}scrollChanged(e){this.scroll.emit(e.getScrollInfo())}cursorActive(e){this.cursorActivity.emit(e)}dropFiles(e,c){this.drop.emit([e,c])}writeValue(e){if(null==e)return;if(!this.codeMirror)return void(this.value=e);const c=this.codeMirror.getValue();if(e!==c&&V7(c)!==V7(e))if(this.value=e,this.preserveScrollPosition){const m=this.codeMirror.getScrollInfo();this.codeMirror.setValue(this.value),this.codeMirror.scrollTo(m.left,m.top)}else this.codeMirror.setValue(this.value)}registerOnChange(e){this.onChange=e}registerOnTouched(e){this.onTouched=e}setDisabledState(e){this.disabled=e,this.setOptionIfChanged("readOnly",this.disabled)}}return r.\u0275fac=function(e){return new(e||r)(d.Y36(d.aQg),d.Y36(d.R0b))},r.\u0275cmp=d.Xpm({type:r,selectors:[["ngx-codemirror"]],viewQuery:function(e,c){if(1&e&&d.Gf(np,5),2&e){let m;d.iGM(m=d.CRH())&&(c.ref=m.first)}},inputs:{className:"className",name:"name",autoFocus:"autoFocus",options:"options",preserveScrollPosition:"preserveScrollPosition"},outputs:{cursorActivity:"cursorActivity",focusChange:"focusChange",scroll:"scroll",drop:"drop"},features:[d._Bn([{provide:N1.JU,useExisting:(0,d.Gpc)(()=>r),multi:!0}])],decls:3,vars:7,consts:[["autocomplete","off",3,"name","autofocus"],["ref",""]],template:function(e,c){1&e&&(d.TgZ(0,"textarea",0,1),d._uU(2,"    "),d.qZA()),2&e&&(d.Gre("ngx-codemirror ",c.className,""),d.ekj("ngx-codemirror--focused",c.isFocused),d.Q6J("name",c.name)("autofocus",c.autoFocus))},encapsulation:2,changeDetection:0}),r})(),tp=(()=>{class r{}return r.\u0275fac=function(e){return new(e||r)},r.\u0275mod=d.oAB({type:r}),r.\u0275inj=d.cJS({}),r})();function H7(r,a){if(1&r){const e=d.EpF();d.TgZ(0,"tr",40)(1,"td",41),d._uU(2),d.qZA(),d.TgZ(3,"td",41),d._uU(4),d.qZA(),d.TgZ(5,"td",41),d._uU(6),d.qZA(),d.TgZ(7,"td",41)(8,"button",42),d.NdJ("click",function(){const v=d.CHM(e).$implicit,S=d.oxw(),A=d.MAs(141);return S.open(A,v.ID)}),d._UZ(9,"fa-icon",43),d.qZA()()()}if(2&r){const e=a.$implicit,c=a.index,m=d.oxw();d.xp6(2),d.Oqu(c),d.xp6(2),d.Oqu(e.tema),d.xp6(2),d.Oqu(e.supergrupo),d.xp6(2),d.Q6J("id",e.ID),d.xp6(1),d.Q6J("icon",m.fachevron)}}function ip(r,a){if(1&r){const e=d.EpF();d.TgZ(0,"tr",40)(1,"td",41),d._uU(2),d.qZA(),d.TgZ(3,"td",41),d._uU(4),d.qZA(),d.TgZ(5,"td",41),d._uU(6),d.qZA(),d.TgZ(7,"td",41)(8,"button",42),d.NdJ("click",function(){const v=d.CHM(e).$implicit,S=d.oxw(),A=d.MAs(141);return S.open(A,v.ID)}),d._UZ(9,"fa-icon",43),d.qZA()()()}if(2&r){const e=a.$implicit,c=a.index,m=d.oxw();d.xp6(2),d.Oqu(c),d.xp6(2),d.Oqu(e.tema),d.xp6(2),d.Oqu(e.supergrupo),d.xp6(2),d.Q6J("id",e.ID),d.xp6(1),d.Q6J("icon",m.fachevron)}}function R7(r,a){if(1&r){const e=d.EpF();d.TgZ(0,"tr",40)(1,"td",41),d._uU(2),d.qZA(),d.TgZ(3,"td",41),d._uU(4),d.qZA(),d.TgZ(5,"td",41),d._uU(6),d.qZA(),d.TgZ(7,"td",41)(8,"button",42),d.NdJ("click",function(){const v=d.CHM(e).$implicit,S=d.oxw(),A=d.MAs(141);return S.open(A,v.ID)}),d._UZ(9,"fa-icon",43),d.qZA()()()}if(2&r){const e=a.$implicit,c=a.index,m=d.oxw();d.xp6(2),d.Oqu(c),d.xp6(2),d.Oqu(e.tema),d.xp6(2),d.Oqu(e.supergrupo),d.xp6(2),d.Q6J("id",e.ID),d.xp6(1),d.Q6J("icon",m.fachevron)}}function ap(r,a){if(1&r){const e=d.EpF();d.TgZ(0,"tr",40)(1,"td",41),d._uU(2),d.qZA(),d.TgZ(3,"td",41),d._uU(4),d.qZA(),d.TgZ(5,"td",41),d._uU(6),d.qZA(),d.TgZ(7,"td",41)(8,"button",42),d.NdJ("click",function(){const v=d.CHM(e).$implicit,S=d.oxw(),A=d.MAs(141);return S.open(A,v.ID)}),d._UZ(9,"fa-icon",43),d.qZA()()()}if(2&r){const e=a.$implicit,c=a.index,m=d.oxw();d.xp6(2),d.Oqu(c),d.xp6(2),d.Oqu(e.tema),d.xp6(2),d.Oqu(e.supergrupo),d.xp6(2),d.Q6J("id",e.ID),d.xp6(1),d.Q6J("icon",m.fachevron)}}function F7(r,a){if(1&r){const e=d.EpF();d.TgZ(0,"tr",40)(1,"td",41),d._uU(2),d.qZA(),d.TgZ(3,"td",41),d._uU(4),d.qZA(),d.TgZ(5,"td",41),d._uU(6),d.qZA(),d.TgZ(7,"td",41)(8,"button",42),d.NdJ("click",function(){const v=d.CHM(e).$implicit,S=d.oxw(),A=d.MAs(141);return S.open(A,v.ID)}),d._UZ(9,"fa-icon",43),d.qZA()()()}if(2&r){const e=a.$implicit,c=a.index,m=d.oxw();d.xp6(2),d.Oqu(c),d.xp6(2),d.Oqu(e.tema),d.xp6(2),d.Oqu(e.supergrupo),d.xp6(2),d.Q6J("id",e.ID),d.xp6(1),d.Q6J("icon",m.fachevron)}}function rp(r,a){if(1&r){const e=d.EpF();d.TgZ(0,"tr",40)(1,"td",41),d._uU(2),d.qZA(),d.TgZ(3,"td",41),d._uU(4),d.qZA(),d.TgZ(5,"td",41),d._uU(6),d.qZA(),d.TgZ(7,"td",41)(8,"button",42),d.NdJ("click",function(){const v=d.CHM(e).$implicit,S=d.oxw(),A=d.MAs(141);return S.open(A,v.ID)}),d._UZ(9,"fa-icon",43),d.qZA()()()}if(2&r){const e=a.$implicit,c=a.index,m=d.oxw();d.xp6(2),d.Oqu(c),d.xp6(2),d.Oqu(e.tema),d.xp6(2),d.Oqu(e.supergrupo),d.xp6(2),d.Q6J("id",e.ID),d.xp6(1),d.Q6J("icon",m.fachevron)}}function zd(r,a){if(1&r){const e=d.EpF();d.TgZ(0,"tr",40)(1,"td",41),d._uU(2),d.qZA(),d.TgZ(3,"td",41),d._uU(4),d.qZA(),d.TgZ(5,"td",41),d._uU(6),d.qZA(),d.TgZ(7,"td",41)(8,"button",42),d.NdJ("click",function(){const v=d.CHM(e).$implicit,S=d.oxw(),A=d.MAs(141);return S.open(A,v.ID)}),d._UZ(9,"fa-icon",43),d.qZA()()()}if(2&r){const e=a.$implicit,c=a.index,m=d.oxw();d.xp6(2),d.Oqu(c),d.xp6(2),d.Oqu(e.tema),d.xp6(2),d.Oqu(e.supergrupo),d.xp6(2),d.Q6J("id",e.ID),d.xp6(1),d.Q6J("icon",m.fachevron)}}function op(r,a){if(1&r){const e=d.EpF();d.TgZ(0,"tr",40)(1,"td",41),d._uU(2),d.qZA(),d.TgZ(3,"td",41),d._uU(4),d.qZA(),d.TgZ(5,"td",41),d._uU(6),d.qZA(),d.TgZ(7,"td",41)(8,"button",42),d.NdJ("click",function(){const v=d.CHM(e).$implicit,S=d.oxw(),A=d.MAs(141);return S.open(A,v.ID)}),d._UZ(9,"fa-icon",43),d.qZA()()()}if(2&r){const e=a.$implicit,c=a.index,m=d.oxw();d.xp6(2),d.Oqu(c),d.xp6(2),d.Oqu(e.tema),d.xp6(2),d.Oqu(e.supergrupo),d.xp6(2),d.Q6J("id",e.ID),d.xp6(1),d.Q6J("icon",m.fachevron)}}function q7(r,a){if(1&r){const e=d.EpF();d.TgZ(0,"tr",40)(1,"td",41),d._uU(2),d.qZA(),d.TgZ(3,"td",41),d._uU(4),d.qZA(),d.TgZ(5,"td",41),d._uU(6),d.qZA(),d.TgZ(7,"td",41)(8,"button",42),d.NdJ("click",function(){const v=d.CHM(e).$implicit,S=d.oxw(),A=d.MAs(141);return S.open(A,v.ID)}),d._UZ(9,"fa-icon",43),d.qZA()()()}if(2&r){const e=a.$implicit,c=a.index,m=d.oxw();d.xp6(2),d.Oqu(c),d.xp6(2),d.Oqu(e.tema),d.xp6(2),d.Oqu(e.supergrupo),d.xp6(2),d.Q6J("id",e.ID),d.xp6(1),d.Q6J("icon",m.fachevron)}}function B7(r,a){if(1&r){const e=d.EpF();d.TgZ(0,"tr",40)(1,"td",41),d._uU(2),d.qZA(),d.TgZ(3,"td",41),d._uU(4),d.qZA(),d.TgZ(5,"td",41),d._uU(6),d.qZA(),d.TgZ(7,"td",41)(8,"button",42),d.NdJ("click",function(){const v=d.CHM(e).$implicit,S=d.oxw(),A=d.MAs(141);return S.open(A,v.ID)}),d._UZ(9,"fa-icon",43),d.qZA()()()}if(2&r){const e=a.$implicit,c=a.index,m=d.oxw();d.xp6(2),d.Oqu(c),d.xp6(2),d.Oqu(e.tema),d.xp6(2),d.Oqu(e.supergrupo),d.xp6(2),d.Q6J("id",e.ID),d.xp6(1),d.Q6J("icon",m.fachevron)}}function sp(r,a){if(1&r){const e=d.EpF();d.TgZ(0,"tr",40)(1,"td",41),d._uU(2),d.qZA(),d.TgZ(3,"td",41),d._uU(4),d.qZA(),d.TgZ(5,"td",41),d._uU(6),d.qZA(),d.TgZ(7,"td",41)(8,"button",42),d.NdJ("click",function(){const v=d.CHM(e).$implicit,S=d.oxw(),A=d.MAs(141);return S.open(A,v.ID)}),d._UZ(9,"fa-icon",43),d.qZA()()()}if(2&r){const e=a.$implicit,c=a.index,m=d.oxw();d.xp6(2),d.Oqu(c),d.xp6(2),d.Oqu(e.tema),d.xp6(2),d.Oqu(e.supergrupo),d.xp6(2),d.Q6J("id",e.ID),d.xp6(1),d.Q6J("icon",m.fachevron)}}function cp(r,a){if(1&r){const e=d.EpF();d.TgZ(0,"tr",40)(1,"td",41),d._uU(2),d.qZA(),d.TgZ(3,"td",41),d._uU(4),d.qZA(),d.TgZ(5,"td",41),d._uU(6),d.qZA(),d.TgZ(7,"td",41)(8,"button",42),d.NdJ("click",function(){const v=d.CHM(e).$implicit,S=d.oxw(),A=d.MAs(141);return S.open(A,v.ID)}),d._UZ(9,"fa-icon",43),d.qZA()()()}if(2&r){const e=a.$implicit,c=a.index,m=d.oxw();d.xp6(2),d.Oqu(c),d.xp6(2),d.Oqu(e.tema),d.xp6(2),d.Oqu(e.supergrupo),d.xp6(2),d.Q6J("id",e.ID),d.xp6(1),d.Q6J("icon",m.fachevron)}}const lp=function(){return{theme:"seti",mode:"text/x-java",readOnly:!0}};function Nd(r,a){if(1&r){const e=d.EpF();d.TgZ(0,"div",1)(1,"div",2)(2,"h4",3),d._UZ(3,"img",53),d._uU(4,"Java"),d.qZA(),d.TgZ(5,"ngx-codemirror",54),d.NdJ("ngModelChange",function(m){return d.CHM(e),d.oxw(2).codejava=m}),d.qZA()()()}if(2&r){const e=d.oxw(2);d.xp6(5),d.Q6J("ngModel",e.codejava)("options",d.DdM(2,lp))}}const dp=function(){return{theme:"seti",mode:"text/x-c++src",readOnly:!0}};function U7(r,a){if(1&r){const e=d.EpF();d.TgZ(0,"div",1)(1,"div",2)(2,"h4",3),d._UZ(3,"img",55),d._uU(4," C++"),d.qZA(),d.TgZ(5,"ngx-codemirror",54),d.NdJ("ngModelChange",function(m){return d.CHM(e),d.oxw(2).codecpp=m}),d.qZA()()()}if(2&r){const e=d.oxw(2);d.xp6(5),d.Q6J("ngModel",e.codecpp)("options",d.DdM(2,dp))}}const up=function(){return{theme:"seti",mode:"text/x-python",readOnly:!0}};function fp(r,a){if(1&r){const e=d.EpF();d.TgZ(0,"div",1)(1,"div",2)(2,"h4",3),d._UZ(3,"img",56),d._uU(4," Python"),d.qZA(),d.TgZ(5,"ngx-codemirror",54),d.NdJ("ngModelChange",function(m){return d.CHM(e),d.oxw(2).codepython=m}),d.qZA()()()}if(2&r){const e=d.oxw(2);d.xp6(5),d.Q6J("ngModel",e.codepython)("options",d.DdM(2,up))}}function pp(r,a){if(1&r){const e=d.EpF();d.TgZ(0,"div",44)(1,"h4",45),d._uU(2),d.qZA(),d.TgZ(3,"button",46),d.NdJ("click",function(){return d.CHM(e).$implicit.dismiss("Cross click")}),d.TgZ(4,"span",47),d._uU(5,"\xd7"),d.qZA()()(),d.TgZ(6,"div",48),d._UZ(7,"div",49),d.YNc(8,Nd,6,3,"div",50),d.YNc(9,U7,6,3,"div",50),d.YNc(10,fp,6,3,"div",50),d.qZA(),d.TgZ(11,"div",51)(12,"button",52),d.NdJ("click",function(){return d.CHM(e).$implicit.close("Save click")}),d._uU(13,"Ok"),d.qZA()()}if(2&r){const e=d.oxw();d.xp6(2),d.Oqu(e.titulotema),d.xp6(5),d.Q6J("innerHtml",e.textotema,d.oJD),d.xp6(1),d.Q6J("ngIf",null!=e.codejava),d.xp6(1),d.Q6J("ngIf",null!=e.codecpp),d.xp6(1),d.Q6J("ngIf",null!=e.codepython)}}let mp=(()=>{class r{constructor(e){this.modalService=e,this.fachevron=Z4,this.fatodotemario=Pi.Xj,this.fateoria=Pi.QRb,this.fabusquedas=Pi.wn1,this.faordenamientos=Pi.EvU,this.fastrings=Pi.lEy,this.fabitwise=Pi.zkM,this.faestructuras=Pi.B3e,this.famatematicas=Pi.r8p,this.fageometria=Pi.qLl,this.fagrafos=Pi.o4t,this.fadinamica=Pi.X8G,this.faotros=Pi.Jw3,this.listatemas=W4,this.listateoria=[],this.listabusquedas=[],this.listaordenamientos=[],this.listastrings=[],this.listamatematica=[],this.listageometria=[],this.listabitwise=[],this.listagrafos=[],this.listadp=[],this.listaestructuras=[],this.listaeotros=[],this.titulotema="Sin tituto disponible",this.textotema="Sin texto disponible",this.codejava="",this.codepython="",this.codecpp="",this.dtOptions=[],this.dtTrigger=new se.xQ,this.closeResult=""}ngOnInit(){this.dtOptions[0]=this.buildDtOptions(),this.dtOptions[1]=this.buildDtOptions();for(let e of this.listatemas)switch(e.orden){case 0:this.listateoria.push(e);break;case 1:this.listaestructuras.push(e);break;case 2:this.listabusquedas.push(e);break;case 3:this.listaordenamientos.push(e);break;case 4:this.listabitwise.push(e);break;case 5:this.listastrings.push(e);break;case 6:this.listamatematica.push(e);break;case 7:this.listageometria.push(e);break;case 8:this.listagrafos.push(e);break;case 9:this.listadp.push(e);break;default:this.listaeotros.push(e)}}ngAfterContentInit(){this.codejava="",this.codepython="",this.codecpp=""}ngOnDestroy(){this.dtTrigger.unsubscribe()}buildDtOptions(){return{pagingType:"full_numbers",columns:[{title:"#",orderable:!0},{title:"Tema / Algoritmo",orderable:!1},{title:"Tipo"},{title:"Ir ",orderable:!1}],responsive:!0,language:{processing:"Procesando...",search:"Buscar:",lengthMenu:"Mostrar _MENU_ elementos",info:"Mostrando desde _START_ al _END_ de _TOTAL_ elementos",infoEmpty:"Mostrando ning\xfan elemento.",infoFiltered:"(filtrado _MAX_ elementos total)",infoPostFix:"",loadingRecords:"Cargando registros...",zeroRecords:"No se encontraron registros",emptyTable:"No hay datos disponibles en la tabla",paginate:{first:"Primero",previous:"Anterior",next:"Siguiente",last:"\xdaltimo"},aria:{sortAscending:": Activar para ordenar la tabla en orden ascendente",sortDescending:": Activar para ordenar la tabla en orden descendente"}}}}obtenerCode(e,c){switch(e){case 0:for(let m of this.listatemas)if(m.ID==c)return m.tema;break;case 1:for(let m of this.listatemas)if(m.ID==c)return m.java;break;case 2:for(let m of this.listatemas)if(m.ID==c)return m.cpp;break;case 3:for(let m of this.listatemas)if(m.ID==c)return m.py;break;case 4:for(let m of this.listatemas)if(m.ID==c){let S=m.texto.split("\n"),A="",H=0;for(let q in S)A+=S[H],A+="<br></br>",H++;return A}}}open(e,c){this.textotema=this.obtenerCode(4,c),this.titulotema=this.obtenerCode(0,c),this.codejava=this.obtenerCode(1,c),this.codecpp=this.obtenerCode(2,c),this.codepython=this.obtenerCode(3,c),this.modalService.open(e,{size:"xl",ariaLabelledBy:"modal-basic-title"}).result.then(m=>{this.closeResult=`Closed with: ${m}`},m=>{this.closeResult=`Dismissed ${this.getDismissReason(m)}`})}getDismissReason(e){return e===Ss.ESC?"by pressing ESC":e===Ss.BACKDROP_CLICK?"by clicking on a backdrop":`with: ${e}`}}return r.\u0275fac=function(e){return new(e||r)(d.Y36(vo))},r.\u0275cmp=d.Xpm({type:r,selectors:[["app-biblioteca"]],viewQuery:function(e,c){if(1&e&&d.Gf(G4,5),2&e){let m;d.iGM(m=d.CRH())&&(c.dtElements=m)}},decls:142,vars:36,consts:[[1,"row","animate__animated","animate__bounceInLeft"],[1,"card"],[1,"card-body"],[1,"card-title"],["id","accordionExample",1,"accordion"],[1,"accordion-item"],["id","headingOne",1,"accordion-header"],["type","button","data-bs-toggle","collapse","data-bs-target","#collapseOne","aria-expanded","true","aria-controls","collapseOne",1,"accordion-button"],["size","1x",2,"padding-right","5px",3,"icon"],["id","collapseOne","aria-labelledby","headingOne","data-bs-parent","#accordionExample",1,"accordion-collapse","collapse"],[1,"accordion-body"],[1,"table-responsive"],["datatable","",1,"table","table-hover","align-middle","text-nowrap","table-bordered","table-striped",3,"dtOptions"],["class","",4,"ngFor","ngForOf"],["id","headingTwo",1,"accordion-header"],["type","button","data-bs-toggle","collapse","data-bs-target","#collapseTwo","aria-expanded","false","aria-controls","collapseTwo",1,"accordion-button","collapsed"],["id","collapseTwo","aria-labelledby","headingTwo","data-bs-parent","#accordionExample",1,"accordion-collapse","collapse"],["id","headingThree",1,"accordion-header"],["type","button","data-bs-toggle","collapse","data-bs-target","#collapseThree","aria-expanded","false","aria-controls","collapseThree",1,"accordion-button","collapsed"],["id","collapseThree","aria-labelledby","headingThree","data-bs-parent","#accordionExample",1,"accordion-collapse","collapse"],["id","heading4",1,"accordion-header"],["type","button","data-bs-toggle","collapse","data-bs-target","#collapse4","aria-expanded","false","aria-controls","collapse4",1,"accordion-button","collapsed"],["id","collapse4","aria-labelledby","headingThree","data-bs-parent","#accordionExample",1,"accordion-collapse","collapse"],["type","button","data-bs-toggle","collapse","data-bs-target","#collapse5","aria-expanded","false","aria-controls","collapseThree",1,"accordion-button","collapsed"],["id","collapse5","aria-labelledby","headingThree","data-bs-parent","#accordionExample",1,"accordion-collapse","collapse"],["type","button","data-bs-toggle","collapse","data-bs-target","#collapse6","aria-expanded","false","aria-controls","collapseThree",1,"accordion-button","collapsed"],["id","collapse6","aria-labelledby","headingThree","data-bs-parent","#accordionExample",1,"accordion-collapse","collapse"],["type","button","data-bs-toggle","collapse","data-bs-target","#collapse7","aria-expanded","false","aria-controls","collapseThree",1,"accordion-button","collapsed"],["id","collapse7","aria-labelledby","headingThree","data-bs-parent","#accordionExample",1,"accordion-collapse","collapse"],["type","button","data-bs-toggle","collapse","data-bs-target","#collapse8","aria-expanded","false","aria-controls","collapseThree",1,"accordion-button","collapsed"],["id","collapse8","aria-labelledby","headingThree","data-bs-parent","#accordionExample",1,"accordion-collapse","collapse"],["type","button","data-bs-toggle","collapse","data-bs-target","#collapse9","aria-expanded","false","aria-controls","collapseThree",1,"accordion-button","collapsed"],["id","collapse9","aria-labelledby","headingThree","data-bs-parent","#accordionExample",1,"accordion-collapse","collapse"],["type","button","data-bs-toggle","collapse","data-bs-target","#collapse10","aria-expanded","false","aria-controls","collapseThree",1,"accordion-button","collapsed"],["id","collapse10","aria-labelledby","headingThree","data-bs-parent","#accordionExample",1,"accordion-collapse","collapse"],["type","button","data-bs-toggle","collapse","data-bs-target","#collapse11","aria-expanded","false","aria-controls","collapseThree",1,"accordion-button","collapsed"],["id","collapse11","aria-labelledby","headingThree","data-bs-parent","#accordionExample",1,"accordion-collapse","collapse"],["type","button","data-bs-toggle","collapse","data-bs-target","#collapse12","aria-expanded","false","aria-controls","collapseThree",1,"accordion-button","collapsed"],["id","collapse12","aria-labelledby","headingThree","data-bs-parent","#accordionExample",1,"accordion-collapse","collapse"],["mymodal",""],[1,""],[1,"text-center"],[1,"btn","btn-success","btn-sm",3,"id","click"],["size","1x",3,"icon"],[1,"modal-header","modal-xl"],["id","modal-basic-title",1,"modal-title"],["type","button","aria-label","Close",1,"close",3,"click"],["aria-hidden","true"],[1,"modal-body","modal-xl"],[3,"innerHtml"],["class","card",4,"ngIf"],[1,"modal-footer"],["type","button",1,"btn","btn-outline-dark",3,"click"],["src","https://cdn-icons-png.flaticon.com/512/226/226777.png","width","60","height","60"],[3,"ngModel","options","ngModelChange"],["src","https://upload.wikimedia.org/wikipedia/commons/thumb/1/18/ISO_C%2B%2B_Logo.svg/1822px-ISO_C%2B%2B_Logo.svg.png","width","60","height","60"],["src","https://www.devacademy.es/wp-content/uploads/2018/10/python-logo.png","width","60","height","60"]],template:function(e,c){1&e&&(d.TgZ(0,"div",0)(1,"div",1)(2,"div",2)(3,"h4",3),d._uU(4,"Temarios separados por grupos"),d.qZA(),d.TgZ(5,"div",4)(6,"div",5)(7,"h2",6)(8,"button",7),d._UZ(9,"fa-icon",8),d._uU(10," Todo el temario "),d.qZA()(),d.TgZ(11,"div",9)(12,"div",10)(13,"div",11)(14,"table",12)(15,"tbody"),d.YNc(16,H7,10,5,"tr",13),d.qZA(),d._uU(17,"s "),d.qZA()()()()(),d.TgZ(18,"div",5)(19,"h2",14)(20,"button",15),d._UZ(21,"fa-icon",8),d._uU(22," Teor\xeda b\xe1sica "),d.qZA()(),d.TgZ(23,"div",16)(24,"div",10)(25,"div",11)(26,"table",12)(27,"tbody"),d.YNc(28,ip,10,5,"tr",13),d.qZA()()()()()(),d.TgZ(29,"div",5)(30,"h2",17)(31,"button",18),d._UZ(32,"fa-icon",8),d._uU(33," Algoritmos de b\xfasqueda "),d.qZA()(),d.TgZ(34,"div",19)(35,"div",10)(36,"div",11)(37,"table",12)(38,"tbody"),d.YNc(39,R7,10,5,"tr",13),d.qZA()()()()()(),d.TgZ(40,"div",5)(41,"h2",20)(42,"button",21),d._UZ(43,"fa-icon",8),d._uU(44," Algoritmos de ordenamiento "),d.qZA()(),d.TgZ(45,"div",22)(46,"div",10)(47,"div",11)(48,"table",12)(49,"tbody"),d.YNc(50,ap,10,5,"tr",13),d.qZA()()()()()(),d.TgZ(51,"div",5)(52,"h2",17)(53,"button",23),d._UZ(54,"fa-icon",8),d._uU(55," Manipulaci\xf3n de cadenas de caracteres y matching "),d.qZA()(),d.TgZ(56,"div",24)(57,"div",10)(58,"div",11)(59,"table",12)(60,"tbody"),d.YNc(61,F7,10,5,"tr",13),d.qZA()()()()()(),d.TgZ(62,"div",5)(63,"h2",17)(64,"button",25),d._UZ(65,"fa-icon",8),d._uU(66," Manejo binario y bitwise "),d.qZA()(),d.TgZ(67,"div",26)(68,"div",10)(69,"div",11)(70,"table",12)(71,"tbody"),d.YNc(72,rp,10,5,"tr",13),d.qZA()()()()()(),d.TgZ(73,"div",5)(74,"h2",17)(75,"button",27),d._UZ(76,"fa-icon",8),d._uU(77,"Estructuras de datos b\xe1sicas y avanzadas "),d.qZA()(),d.TgZ(78,"div",28)(79,"div",10)(80,"div",11)(81,"table",12)(82,"tbody"),d.YNc(83,zd,10,5,"tr",13),d.qZA()()()()()(),d.TgZ(84,"div",5)(85,"h2",17)(86,"button",29),d._UZ(87,"fa-icon",8),d._uU(88," Matem\xe1ticas "),d.qZA()(),d.TgZ(89,"div",30)(90,"div",10)(91,"div",11)(92,"table",12)(93,"tbody"),d.YNc(94,op,10,5,"tr",13),d.qZA()()()()()(),d.TgZ(95,"div",5)(96,"h2",17)(97,"button",31),d._UZ(98,"fa-icon",8),d._uU(99," Geometr\xeda "),d.qZA()(),d.TgZ(100,"div",32)(101,"div",10)(102,"div",11)(103,"table",12)(104,"tbody"),d.YNc(105,q7,10,5,"tr",13),d.qZA()()()()()(),d.TgZ(106,"div",5)(107,"h2",17)(108,"button",33),d._UZ(109,"fa-icon",8),d._uU(110,"Teor\xeda de grafos, arboles y redes "),d.qZA()(),d.TgZ(111,"div",34)(112,"div",10)(113,"div",11)(114,"table",12)(115,"tbody"),d.YNc(116,B7,10,5,"tr",13),d.qZA()()()()()(),d.TgZ(117,"div",5)(118,"h2",17)(119,"button",35),d._UZ(120,"fa-icon",8),d._uU(121,"Programaci\xf3n din\xe1mica "),d.qZA()(),d.TgZ(122,"div",36)(123,"div",10)(124,"div",11)(125,"table",12)(126,"tbody"),d.YNc(127,sp,10,5,"tr",13),d.qZA()()()()()(),d.TgZ(128,"div",5)(129,"h2",17)(130,"button",37),d._UZ(131,"fa-icon",8),d._uU(132,"Generadores de casos de prueba y otros "),d.qZA()(),d.TgZ(133,"div",38)(134,"div",10)(135,"div",11)(136,"table",12)(137,"tbody"),d.YNc(138,cp,10,5,"tr",13),d.qZA()()()()()()()()()(),d.TgZ(139,"div",0),d.YNc(140,pp,14,5,"ng-template",null,39,d.W1O),d.qZA()),2&e&&(d.xp6(9),d.Q6J("icon",c.fatodotemario),d.xp6(5),d.Q6J("dtOptions",c.dtOptions[0]),d.xp6(2),d.Q6J("ngForOf",c.listatemas),d.xp6(5),d.Q6J("icon",c.fateoria),d.xp6(5),d.Q6J("dtOptions",c.dtOptions[0]),d.xp6(2),d.Q6J("ngForOf",c.listateoria),d.xp6(4),d.Q6J("icon",c.fabusquedas),d.xp6(5),d.Q6J("dtOptions",c.dtOptions[0]),d.xp6(2),d.Q6J("ngForOf",c.listabusquedas),d.xp6(4),d.Q6J("icon",c.faordenamientos),d.xp6(5),d.Q6J("dtOptions",c.dtOptions[0]),d.xp6(2),d.Q6J("ngForOf",c.listaordenamientos),d.xp6(4),d.Q6J("icon",c.fastrings),d.xp6(5),d.Q6J("dtOptions",c.dtOptions[0]),d.xp6(2),d.Q6J("ngForOf",c.listastrings),d.xp6(4),d.Q6J("icon",c.fabitwise),d.xp6(5),d.Q6J("dtOptions",c.dtOptions[0]),d.xp6(2),d.Q6J("ngForOf",c.listabitwise),d.xp6(4),d.Q6J("icon",c.faestructuras),d.xp6(5),d.Q6J("dtOptions",c.dtOptions[0]),d.xp6(2),d.Q6J("ngForOf",c.listaestructuras),d.xp6(4),d.Q6J("icon",c.famatematicas),d.xp6(5),d.Q6J("dtOptions",c.dtOptions[0]),d.xp6(2),d.Q6J("ngForOf",c.listamatematica),d.xp6(4),d.Q6J("icon",c.fageometria),d.xp6(5),d.Q6J("dtOptions",c.dtOptions[0]),d.xp6(2),d.Q6J("ngForOf",c.listageometria),d.xp6(4),d.Q6J("icon",c.fagrafos),d.xp6(5),d.Q6J("dtOptions",c.dtOptions[0]),d.xp6(2),d.Q6J("ngForOf",c.listagrafos),d.xp6(4),d.Q6J("icon",c.fadinamica),d.xp6(5),d.Q6J("dtOptions",c.dtOptions[0]),d.xp6(2),d.Q6J("ngForOf",c.listadp),d.xp6(4),d.Q6J("icon",c.faotros),d.xp6(5),d.Q6J("dtOptions",c.dtOptions[0]),d.xp6(2),d.Q6J("ngForOf",c.listaeotros))},directives:[cc.BN,G4,Hn.sg,Hn.O5,t3,N1.JJ,N1.On],styles:[""]}),r})(),hp=(()=>{class r{constructor(){}ngOnInit(){}}return r.\u0275fac=function(e){return new(e||r)},r.\u0275cmp=d.Xpm({type:r,selectors:[["app-competencias"]],decls:4,vars:0,consts:[[1,"card"],[1,"card-body"],[1,"card-title"]],template:function(e,c){1&e&&(d.TgZ(0,"div",0)(1,"div",1)(2,"h4",2),d._uU(3,"Sitio en construcci\xf3n, vuelve pronto :D"),d.qZA()()())},styles:[""]}),r})(),gp=(()=>{class r{constructor(){}ngOnInit(){}}return r.\u0275fac=function(e){return new(e||r)},r.\u0275cmp=d.Xpm({type:r,selectors:[["app-estadisticas"]],decls:4,vars:0,consts:[[1,"card"],[1,"card-body"],[1,"card-title"]],template:function(e,c){1&e&&(d.TgZ(0,"div",0)(1,"div",1)(2,"h4",2),d._uU(3,"Sitio en construcci\xf3n, vuelve pronto :D"),d.qZA()()())},styles:[""]}),r})(),vp=(()=>{class r{constructor(){}ngOnInit(){}}return r.\u0275fac=function(e){return new(e||r)},r.\u0275cmp=d.Xpm({type:r,selectors:[["app-eventos"]],decls:4,vars:0,consts:[[1,"card"],[1,"card-body"],[1,"card-title"]],template:function(e,c){1&e&&(d.TgZ(0,"div",0)(1,"div",1)(2,"h4",2),d._uU(3,"Sitio en construcci\xf3n, vuelve pronto :D"),d.qZA()()())},styles:[""]}),r})(),bp=(()=>{class r{constructor(){}ngOnInit(){}}return r.\u0275fac=function(e){return new(e||r)},r.\u0275cmp=d.Xpm({type:r,selectors:[["app-libros"]],decls:4,vars:0,consts:[[1,"card"],[1,"card-body"],[1,"card-title"]],template:function(e,c){1&e&&(d.TgZ(0,"div",0)(1,"div",1)(2,"h4",2),d._uU(3,"Sitio en construcci\xf3n, vuelve pronto :D"),d.qZA()()())},styles:[""]}),r})(),G7=(()=>{class r{constructor(){}ngOnInit(){}}return r.\u0275fac=function(e){return new(e||r)},r.\u0275cmp=d.Xpm({type:r,selectors:[["app-links"]],decls:4,vars:0,consts:[[1,"card"],[1,"card-body"],[1,"card-title"]],template:function(e,c){1&e&&(d.TgZ(0,"div",0)(1,"div",1)(2,"h4",2),d._uU(3,"Sitio en construcci\xf3n, vuelve pronto :D"),d.qZA()()())},styles:[""]}),r})(),W7=(()=>{class r{constructor(){}ngOnInit(){}}return r.\u0275fac=function(e){return new(e||r)},r.\u0275cmp=d.Xpm({type:r,selectors:[["app-problemas"]],decls:4,vars:0,consts:[[1,"card"],[1,"card-body"],[1,"card-title"]],template:function(e,c){1&e&&(d.TgZ(0,"div",0)(1,"div",1)(2,"h4",2),d._uU(3,"Sitio en construcci\xf3n, vuelve pronto :D"),d.qZA()()())},styles:[""]}),r})();var y9={prefix:"fab",iconName:"discord",icon:[640,512,[],"f392","M524.531,69.836a1.5,1.5,0,0,0-.764-.7A485.065,485.065,0,0,0,404.081,32.03a1.816,1.816,0,0,0-1.923.91,337.461,337.461,0,0,0-14.9,30.6,447.848,447.848,0,0,0-134.426,0,309.541,309.541,0,0,0-15.135-30.6,1.89,1.89,0,0,0-1.924-.91A483.689,483.689,0,0,0,116.085,69.137a1.712,1.712,0,0,0-.788.676C39.068,183.651,18.186,294.69,28.43,404.354a2.016,2.016,0,0,0,.765,1.375A487.666,487.666,0,0,0,176.02,479.918a1.9,1.9,0,0,0,2.063-.676A348.2,348.2,0,0,0,208.12,430.4a1.86,1.86,0,0,0-1.019-2.588,321.173,321.173,0,0,1-45.868-21.853,1.885,1.885,0,0,1-.185-3.126c3.082-2.309,6.166-4.711,9.109-7.137a1.819,1.819,0,0,1,1.9-.256c96.229,43.917,200.41,43.917,295.5,0a1.812,1.812,0,0,1,1.924.233c2.944,2.426,6.027,4.851,9.132,7.16a1.884,1.884,0,0,1-.162,3.126,301.407,301.407,0,0,1-45.89,21.83,1.875,1.875,0,0,0-1,2.611,391.055,391.055,0,0,0,30.014,48.815,1.864,1.864,0,0,0,2.063.7A486.048,486.048,0,0,0,610.7,405.729a1.882,1.882,0,0,0,.765-1.352C623.729,277.594,590.933,167.465,524.531,69.836ZM222.491,337.58c-28.972,0-52.844-26.587-52.844-59.239S193.056,219.1,222.491,219.1c29.665,0,53.306,26.82,52.843,59.239C275.334,310.993,251.924,337.58,222.491,337.58Zm195.38,0c-28.971,0-52.843-26.587-52.843-59.239S388.437,219.1,417.871,219.1c29.667,0,53.307,26.82,52.844,59.239C470.715,310.993,447.538,337.58,417.871,337.58Z"]},Tm={prefix:"fab",iconName:"github",icon:[496,512,[],"f09b","M165.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3.3-5.6-1.3-5.6-3.6 0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6zm-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6 0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5.3-6.2 2.3zm44.2-1.7c-2.9.7-4.9 2.6-4.6 4.9.3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9zM244.8 8C106.1 8 0 113.3 0 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1 0-6.2-.3-40.4-.3-61.4 0 0-70 15-84.7-29.8 0 0-11.4-29.1-27.8-36.6 0 0-22.9-15.7 1.6-15.4 0 0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5 0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9 0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4 0 33.7-.3 75.4-.3 83.6 0 6.5 4.6 14.4 17.3 12.1C428.2 457.8 496 362.9 496 252 496 113.3 383.5 8 244.8 8zM97.2 352.9c-1.3 1-1 3.3.7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1zm-10.8-8.1c-.7 1.3.3 2.9 2.3 3.9 1.6 1 3.6.7 4.3-.7.7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3.7zm32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3.7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1zm-11.4-14.7c-1.6 1-1.6 3.6 0 5.9 1.6 2.3 4.3 3.3 5.6 2.3 1.6-1.3 1.6-3.9 0-6.2-1.4-2.3-4-3.3-5.6-2z"]},Yd={prefix:"fab",iconName:"google",icon:[488,512,[],"f1a0","M488 261.8C488 403.3 391.1 504 248 504 110.8 504 0 393.2 0 256S110.8 8 248 8c66.8 0 123 24.5 166.3 64.9l-67.5 64.9C258.5 52.6 94.3 116.6 94.3 256c0 86.5 69.1 156.6 153.7 156.6 98.2 0 135-70.4 140.8-106.9H248v-85.3h236.1c2.3 12.7 3.9 24.9 3.9 41.4z"]};let wy=(()=>{class r{constructor(e){this.modalService=e,this.toggleSidebar=new d.vpe,this.fahome=Pi.J9Y,this.facircleinfo=Pi.sqG,this.facode=Pi.dT$,this.fagavel=Pi.JHj,this.fapizza=Pi.tU6,this.faworld=Pi.Xj,this.faonline=Pi.lIc,this.config={},this.showSearch=!1,this.notifications=[{btn:"btn-danger",icon:"ti-link",title:"Luanch Admin",subject:"Just see the my new admin!",time:"9:30 AM"},{btn:"btn-success",icon:"ti-calendar",title:"Event today",subject:"Just a reminder that you have event",time:"9:10 AM"},{btn:"btn-info",icon:"ti-settings",title:"Settings",subject:"You can customize this template as you want",time:"9:08 AM"},{btn:"btn-warning",icon:"ti-user",title:"Pavan kumar",subject:"Just see the my admin!",time:"9:00 AM"}],this.mymessages=[{useravatar:"assets/images/users/user1.jpg",status:"online",from:"Pavan kumar",subject:"Just see the my admin!",time:"9:30 AM"},{useravatar:"assets/images/users/user2.jpg",status:"busy",from:"Sonu Nigam",subject:"I have sung a song! See you at",time:"9:10 AM"},{useravatar:"assets/images/users/user2.jpg",status:"away",from:"Arijit Sinh",subject:"I am a singer!",time:"9:08 AM"},{useravatar:"assets/images/users/user4.jpg",status:"offline",from:"Pavan kumar",subject:"Just see the my admin!",time:"9:00 AM"}],this.selectedLanguage={language:"Espa\xf1ol",code:"es",type:"CO",icon:"es"},this.languages=[{language:"English",code:"en",type:"US",icon:"us"},{language:"Espa\xf1ol",code:"es",icon:"es"},{language:"Fran\xe7ais",code:"fr",icon:"fr"},{language:"German",code:"de",icon:"de"}]}ngAfterViewInit(){}}return r.\u0275fac=function(e){return new(e||r)(d.Y36(vo))},r.\u0275cmp=d.Xpm({type:r,selectors:[["app-navigation"]],outputs:{toggleSidebar:"toggleSidebar"},decls:26,vars:6,consts:[[1,"navbar-nav","float-start","me-auto"],[1,"nav-item"],["href","",1,"nav-link","waves-effect","waves-dark"],[3,"icon"],["ngbDropdown","","placement","bottom-end",1,"nav-item"],["ngbDropdownToggle","","href","javascript:void(0)","data-toggle","dropdown","aria-haspopup","true","aria-expanded","false",1,"nav-link","waves-effect","waves-dark"],["ngbDropdownMenu",""],["href","https://domjudgeroca12.sa.ngrok.io",1,"dropdown-item"],["href","https://domjudgeroca12.sa.ngrok.io/domjudge",1,"dropdown-item"],["href","https://www.codechef.com/",1,"dropdown-item"],["href","https://vjudge.net/group/cuevadelprofdiego",1,"dropdown-item"],["href","https://onlinejudge.org/",1,"dropdown-item"],[1,"navbar-nav","float-end"]],template:function(e,c){1&e&&(d.TgZ(0,"ul",0)(1,"li",1)(2,"a",2),d._UZ(3,"fa-icon",3),d._uU(4," Inicio "),d.qZA()(),d.TgZ(5,"li",4)(6,"a",5)(7,"span"),d._uU(8,"Ir a..."),d.qZA()(),d.TgZ(9,"div",6)(10,"a",7),d._UZ(11,"fa-icon",3),d._uU(12," Inicio competitiva"),d.qZA(),d.TgZ(13,"a",8),d._UZ(14,"fa-icon",3),d._uU(15," DomJudge"),d.qZA(),d.TgZ(16,"a",9),d._UZ(17,"fa-icon",3),d._uU(18," CodeChef"),d.qZA(),d.TgZ(19,"a",10),d._UZ(20,"fa-icon",3),d._uU(21," Vjudge"),d.qZA(),d.TgZ(22,"a",11),d._UZ(23,"fa-icon",3),d._uU(24," Online Judge"),d.qZA()()()(),d._UZ(25,"ul",12)),2&e&&(d.xp6(3),d.Q6J("icon",c.fahome),d.xp6(8),d.Q6J("icon",c.facode),d.xp6(3),d.Q6J("icon",c.fagavel),d.xp6(3),d.Q6J("icon",c.fapizza),d.xp6(3),d.Q6J("icon",c.faworld),d.xp6(3),d.Q6J("icon",c.faonline))},directives:[cc.BN,ac,il,b0],encapsulation:2}),r})();const zy=[{path:"/temario",title:"Temario",icon:"bi bi-collection",class:"",extralink:!1,submenu:[]},{path:"/problemas",title:"Problemas",icon:"bi bi-question-square-fill",class:"",extralink:!1,submenu:[]},{path:"/libros",title:"Libros",icon:"bi bi-book",class:"",extralink:!1,submenu:[]},{path:"/links",title:"Links valiosos",icon:"bi bi-box-arrow-up-right",class:"",extralink:!1,submenu:[]},{path:"/estadisticas",title:"Estadisticas",icon:"bi bi-bar-chart-line",class:"",extralink:!1,submenu:[]},{path:"/eventos",title:"Eventos",icon:"bi bi-calendar-date",class:"",extralink:!1,submenu:[]},{path:"/competencias",title:"Competencias",icon:"bi bi-trophy",class:"",extralink:!1,submenu:[]},{path:"/about",title:"Acerca de ...",icon:"bi bi-trophy",class:"",extralink:!1,submenu:[]}];function Ny(r,a){if(1&r&&(d.TgZ(0,"div",6),d._uU(1),d.qZA()),2&r){const e=d.oxw().$implicit;d.xp6(1),d.Oqu(e.title)}}const Ch=function(r){return[r]};function Dy(r,a){if(1&r){const e=d.EpF();d.TgZ(0,"a",7),d.NdJ("click",function(){d.CHM(e);const m=d.oxw().$implicit;return d.oxw().addExpandClass(m.title)}),d._UZ(1,"i",8),d.TgZ(2,"span",9),d._uU(3),d.qZA()()}if(2&r){const e=d.oxw().$implicit;d.Q6J("routerLink",""===e.class?d.VKq(5,Ch,e.path):null)("ngClass",d.VKq(7,Ch,e.class))("routerLinkActive",0!=e.submenu.length?"":"active"),d.xp6(1),d.Q6J("ngClass",d.VKq(9,Ch,e.icon)),d.xp6(2),d.Oqu(e.title)}}function Ey(r,a){if(1&r&&(d.TgZ(0,"li",3),d.YNc(1,Ny,2,1,"div",4),d.YNc(2,Dy,4,11,"a",5),d.qZA()),2&r){const e=a.$implicit,c=d.oxw();d.ekj("active",c.showMenu===e.title),d.Q6J("routerLinkActive",0!=e.submenu.length?"":"active"),d.xp6(1),d.Q6J("ngIf",!0===e.extralink),d.xp6(1),d.Q6J("ngIf",!e.extralink)}}let Ay=(()=>{class r{constructor(e,c,m){this.modalService=e,this.router=c,this.route=m,this.showMenu="",this.showSubMenu="",this.sidebarnavItems=[]}addExpandClass(e){this.showMenu=e===this.showMenu?"0":e}ngOnInit(){this.sidebarnavItems=zy.filter(e=>e)}}return r.\u0275fac=function(e){return new(e||r)(d.Y36(vo),d.Y36(G.F0),d.Y36(G.gz))},r.\u0275cmp=d.Xpm({type:r,selectors:[["app-sidebar"]],decls:3,vars:1,consts:[[1,"sidebar-nav",2,"padding-top","10%"],["id","sidebarnav"],["class","sidebar-item",3,"active","routerLinkActive",4,"ngFor","ngForOf"],[1,"sidebar-item",3,"routerLinkActive"],["class","nav-small-cap",4,"ngIf"],["class","sidebar-link waves-effect waves-dark",3,"routerLink","ngClass","routerLinkActive","click",4,"ngIf"],[1,"nav-small-cap"],[1,"sidebar-link","waves-effect","waves-dark",3,"routerLink","ngClass","routerLinkActive","click"],[3,"ngClass"],[1,"hide-menu"]],template:function(e,c){1&e&&(d.TgZ(0,"nav",0)(1,"ul",1),d.YNc(2,Ey,3,5,"li",2),d.qZA()()),2&e&&(d.xp6(2),d.Q6J("ngForOf",c.sidebarnavItems))},directives:[Hn.sg,G.Od,Hn.O5,G.yS,Hn.mk],encapsulation:2}),r})();const Ly=function(r){return{"show-sidebar":r}},Ty=[{path:"",component:(()=>{class r{constructor(e){this.router=e,this.fadiscord=y9,this.fagithub=Tm,this.famail=Yd,this.isCollapsed=!1,this.innerWidth=0,this.defaultSidebar="",this.showMobileMenu=!1,this.expandLogo=!1,this.sidebartype="full"}Logo(){this.expandLogo=!this.expandLogo}ngOnInit(){"/"===this.router.url&&this.router.navigate(["/dashboard"]),this.defaultSidebar=this.sidebartype,this.handleSidebar()}onResize(){this.handleSidebar()}handleSidebar(){this.innerWidth=window.innerWidth,this.sidebartype=this.innerWidth<1170?"full":this.defaultSidebar}toggleSidebarType(){switch(this.sidebartype){case"full":this.sidebartype="mini-sidebar";break;case"mini-sidebar":this.sidebartype="full"}}}return r.\u0275fac=function(e){return new(e||r)(d.Y36(G.F0))},r.\u0275cmp=d.Xpm({type:r,selectors:[["app-full-layout"]],hostBindings:function(e,c){1&e&&d.NdJ("resize",function(v){return c.onResize(v)},!1,d.Jf7)},decls:22,vars:9,consts:[["id","main-wrapper","dir","ltr","data-theme","light","data-layout","vertical","data-sidebar-position","absolute","data-header-position","absolute","data-boxed-layout","full",3,"ngClass"],["data-navbarbg","skin5",1,"topbar"],[1,"d-flex","top-navbar","navbar-expand-lg","navbar-light"],["data-logobg","skin5",1,"navbar-header",3,"ngClass"],["href","javascript:void(0)",1,"nav-toggler","waves-effect","waves-light","d-block","d-lg-none",3,"click"],[3,"ngClass"],["href","/",1,"navbar-brand"],[1,"logo-text"],["src","assets/images/logos/propuestas logo 1 artemisa-02.png","alt","homepage","width","100%",1,"light-logo"],["href","javascript:void(0)","data-toggle","collapse","data-target","#navbarSupportedContent","aria-controls","navbarSupportedContent","aria-expanded","false","aria-label","Toggle navigation",1,"topbartoggler","d-block","d-lg-none","waves-effect","waves-light",3,"click"],[1,"bi","bi-text-right","fs-6"],["id","navbarSupportedContent","data-navbarbg","skin6",1,"navbar-collapse","collapse",3,"ngbCollapse"],[1,"w-100",3,"toggleSidebar"],["data-sidebarbg","skin5",1,"left-sidebar",3,"mouseover","mouseout"],[1,"page-wrapper"],[1,"container-fluid"],[1,"footer","text-center"],["size","2x",3,"icon"]],template:function(e,c){1&e&&(d.TgZ(0,"div",0)(1,"header",1)(2,"nav",2)(3,"div",3)(4,"a",4),d.NdJ("click",function(){return c.showMobileMenu=!c.showMobileMenu}),d._UZ(5,"i",5),d.qZA(),d.TgZ(6,"a",6)(7,"span",7),d._UZ(8,"img",8),d.qZA()(),d.TgZ(9,"a",9),d.NdJ("click",function(){return c.isCollapsed=!c.isCollapsed}),d._UZ(10,"i",10),d.qZA()(),d.TgZ(11,"div",11)(12,"app-navigation",12),d.NdJ("toggleSidebar",function(){return c.toggleSidebarType()}),d.qZA()()()(),d.TgZ(13,"aside",13),d.NdJ("mouseover",function(){return c.Logo()})("mouseout",function(){return c.Logo()}),d._UZ(14,"app-sidebar"),d.qZA(),d.TgZ(15,"div",14)(16,"div",15),d._UZ(17,"router-outlet"),d.qZA(),d.TgZ(18,"footer",16),d._uU(19," Dise\xf1ado y administrado por "),d._UZ(20,"fa-icon",17),d._uU(21," Diego Rodriguez 2022 "),d.qZA()()()),2&e&&(d.Q6J("ngClass",d.VKq(7,Ly,c.showMobileMenu)),d.uIk("data-sidebartype",c.sidebartype),d.xp6(3),d.Q6J("ngClass",c.expandLogo?"expand-logo":""),d.xp6(2),d.Q6J("ngClass","bi bi-text-left fs-6"),d.xp6(4),d.uIk("aria-expanded",!c.isCollapsed),d.xp6(2),d.Q6J("ngbCollapse",!c.isCollapsed),d.xp6(9),d.Q6J("icon",c.fagithub))},directives:[Hn.mk,Uo,wy,Ay,G.lC,cc.BN],styles:[".max-width[_ngcontent-%COMP%]{max-width:1440px;margin:0 auto}@media (max-width: 991px){.container-fluid[_ngcontent-%COMP%]{padding-top:20%}}"]}),r})(),children:[{path:"dashboard",redirectTo:"",pathMatch:"full"},{path:"",loadChildren:()=>Q.e(230).then(Q.bind(Q,5230)).then(r=>r.DashboardModule)},{path:"about",component:cl},{path:"temario",component:mp},{path:"problemas",component:W7},{path:"libros",component:bp},{path:"links",component:G7},{path:"estadisticas",component:gp},{path:"eventos",component:vp},{path:"competencias",component:hp}]},{path:"**",redirectTo:"/dashboard"}];function jy(r,a){1&r&&(d.TgZ(0,"div",1)(1,"div",2),d._UZ(2,"div",3)(3,"div",4),d.qZA()())}let ky=(()=>{class r{constructor(e,c){this.router=e,this.document=c,this.isSpinnerVisible=!0,this.backgroundColor="rgba(0, 115, 170, 0.69)",this.router.events.subscribe(m=>{m instanceof G.OD?this.isSpinnerVisible=!0:(m instanceof G.m2||m instanceof G.gk||m instanceof G.Q3)&&(this.isSpinnerVisible=!1)},()=>{this.isSpinnerVisible=!1})}ngOnDestroy(){this.isSpinnerVisible=!1}}return r.\u0275fac=function(e){return new(e||r)(d.Y36(G.F0),d.Y36(Hn.K0))},r.\u0275cmp=d.Xpm({type:r,selectors:[["app-spinner"]],inputs:{backgroundColor:"backgroundColor"},decls:1,vars:1,consts:[["class","preloader",4,"ngIf"],[1,"preloader"],[1,"spinner"],[1,"double-bounce1"],[1,"double-bounce2"]],template:function(e,c){1&e&&d.YNc(0,jy,4,0,"div",0),2&e&&d.Q6J("ngIf",c.isSpinnerVisible)},directives:[Hn.O5],encapsulation:2}),r})(),Py=(()=>{class r{constructor(){this.title="app"}}return r.\u0275fac=function(e){return new(e||r)},r.\u0275cmp=d.Xpm({type:r,selectors:[["app-root"]],decls:2,vars:0,template:function(e,c){1&e&&(d.TgZ(0,"router-outlet"),d._UZ(1,"app-spinner"),d.qZA())},directives:[G.lC,ky],styles:[""]}),r})();function lc(r){return getComputedStyle(r)}function Z2(r,a){for(var e in a){var c=a[e];"number"==typeof c&&(c+="px"),r.style[e]=c}return r}function Cf(r){var a=document.createElement("div");return a.className=r,a}Q(6787);var Pg="undefined"!=typeof Element&&(Element.prototype.matches||Element.prototype.webkitMatchesSelector||Element.prototype.mozMatchesSelector||Element.prototype.msMatchesSelector);function c3(r,a){if(!Pg)throw new Error("No element matching method supported");return Pg.call(r,a)}function i8(r){r.remove?r.remove():r.parentNode&&r.parentNode.removeChild(r)}function Ig(r,a){return Array.prototype.filter.call(r.children,function(e){return c3(e,a)})}var tr_element_thumb=function(r){return"ps__thumb-"+r},tr_element_rail=function(r){return"ps__rail-"+r},tr_element_consuming="ps__child--consume",tr_state_focus="ps--focus",tr_state_clicking="ps--clicking",tr_state_active=function(r){return"ps--active-"+r},tr_state_scrolling=function(r){return"ps--scrolling-"+r},Og={x:null,y:null};function Vg(r,a){var e=r.element.classList,c=tr_state_scrolling(a);e.contains(c)?clearTimeout(Og[a]):e.add(c)}function Hg(r,a){Og[a]=setTimeout(function(){return r.isAlive&&r.element.classList.remove(tr_state_scrolling(a))},r.settings.scrollingThreshold)}var _u=function(a){this.element=a,this.handlers={}},Rg={isEmpty:{configurable:!0}};_u.prototype.bind=function(a,e){void 0===this.handlers[a]&&(this.handlers[a]=[]),this.handlers[a].push(e),this.element.addEventListener(a,e,!1)},_u.prototype.unbind=function(a,e){var c=this;this.handlers[a]=this.handlers[a].filter(function(m){return!(!e||m===e)||(c.element.removeEventListener(a,m,!1),!1)})},_u.prototype.unbindAll=function(){for(var a in this.handlers)this.unbind(a)},Rg.isEmpty.get=function(){var r=this;return Object.keys(this.handlers).every(function(a){return 0===r.handlers[a].length})},Object.defineProperties(_u.prototype,Rg);var a8=function(){this.eventElements=[]};function Sf(r){if("function"==typeof window.CustomEvent)return new CustomEvent(r);var a=document.createEvent("CustomEvent");return a.initCustomEvent(r,!1,!1,void 0),a}function Mf(r,a,e,c,m){var v;if(void 0===c&&(c=!0),void 0===m&&(m=!1),"top"===a)v=["contentHeight","containerHeight","scrollTop","y","up","down"];else{if("left"!==a)throw new Error("A proper axis should be provided");v=["contentWidth","containerWidth","scrollLeft","x","left","right"]}!function Gy(r,a,e,c,m){var v=e[0],S=e[1],A=e[2],H=e[3],q=e[4],ae=e[5];void 0===c&&(c=!0),void 0===m&&(m=!1);var ze=r.element;r.reach[H]=null,ze[A]<1&&(r.reach[H]="start"),ze[A]>r[v]-r[S]-1&&(r.reach[H]="end"),a&&(ze.dispatchEvent(Sf("ps-scroll-"+H)),a<0?ze.dispatchEvent(Sf("ps-scroll-"+q)):a>0&&ze.dispatchEvent(Sf("ps-scroll-"+ae)),c&&function Uy(r,a){Vg(r,a),Hg(r,a)}(r,H)),r.reach[H]&&(a||m)&&ze.dispatchEvent(Sf("ps-"+H+"-reach-"+r.reach[H]))}(r,e,v,c,m)}function fa(r){return parseInt(r,10)||0}a8.prototype.eventElement=function(a){var e=this.eventElements.filter(function(c){return c.element===a})[0];return e||(e=new _u(a),this.eventElements.push(e)),e},a8.prototype.bind=function(a,e,c){this.eventElement(a).bind(e,c)},a8.prototype.unbind=function(a,e,c){var m=this.eventElement(a);m.unbind(e,c),m.isEmpty&&this.eventElements.splice(this.eventElements.indexOf(m),1)},a8.prototype.unbindAll=function(){this.eventElements.forEach(function(a){return a.unbindAll()}),this.eventElements=[]},a8.prototype.once=function(a,e,c){var m=this.eventElement(a),v=function(S){m.unbind(e,v),c(S)};m.bind(e,v)};var r8={isWebKit:"undefined"!=typeof document&&"WebkitAppearance"in document.documentElement.style,supportsTouch:"undefined"!=typeof window&&("ontouchstart"in window||"maxTouchPoints"in window.navigator&&window.navigator.maxTouchPoints>0||window.DocumentTouch&&document instanceof window.DocumentTouch),supportsIePointer:"undefined"!=typeof navigator&&navigator.msMaxTouchPoints,isChrome:"undefined"!=typeof navigator&&/Chrome/i.test(navigator&&navigator.userAgent)};function Zc(r){var a=r.element,e=Math.floor(a.scrollTop),c=a.getBoundingClientRect();r.containerWidth=Math.ceil(c.width),r.containerHeight=Math.ceil(c.height),r.contentWidth=a.scrollWidth,r.contentHeight=a.scrollHeight,a.contains(r.scrollbarXRail)||(Ig(a,tr_element_rail("x")).forEach(function(m){return i8(m)}),a.appendChild(r.scrollbarXRail)),a.contains(r.scrollbarYRail)||(Ig(a,tr_element_rail("y")).forEach(function(m){return i8(m)}),a.appendChild(r.scrollbarYRail)),!r.settings.suppressScrollX&&r.containerWidth+r.settings.scrollXMarginOffset<r.contentWidth?(r.scrollbarXActive=!0,r.railXWidth=r.containerWidth-r.railXMarginWidth,r.railXRatio=r.containerWidth/r.railXWidth,r.scrollbarXWidth=Fg(r,fa(r.railXWidth*r.containerWidth/r.contentWidth)),r.scrollbarXLeft=fa((r.negativeScrollAdjustment+a.scrollLeft)*(r.railXWidth-r.scrollbarXWidth)/(r.contentWidth-r.containerWidth))):r.scrollbarXActive=!1,!r.settings.suppressScrollY&&r.containerHeight+r.settings.scrollYMarginOffset<r.contentHeight?(r.scrollbarYActive=!0,r.railYHeight=r.containerHeight-r.railYMarginHeight,r.railYRatio=r.containerHeight/r.railYHeight,r.scrollbarYHeight=Fg(r,fa(r.railYHeight*r.containerHeight/r.contentHeight)),r.scrollbarYTop=fa(e*(r.railYHeight-r.scrollbarYHeight)/(r.contentHeight-r.containerHeight))):r.scrollbarYActive=!1,r.scrollbarXLeft>=r.railXWidth-r.scrollbarXWidth&&(r.scrollbarXLeft=r.railXWidth-r.scrollbarXWidth),r.scrollbarYTop>=r.railYHeight-r.scrollbarYHeight&&(r.scrollbarYTop=r.railYHeight-r.scrollbarYHeight),function $y(r,a){var e={width:a.railXWidth},c=Math.floor(r.scrollTop);e.left=a.isRtl?a.negativeScrollAdjustment+r.scrollLeft+a.containerWidth-a.contentWidth:r.scrollLeft,a.isScrollbarXUsingBottom?e.bottom=a.scrollbarXBottom-c:e.top=a.scrollbarXTop+c,Z2(a.scrollbarXRail,e);var m={top:c,height:a.railYHeight};a.isScrollbarYUsingRight?m.right=a.isRtl?a.contentWidth-(a.negativeScrollAdjustment+r.scrollLeft)-a.scrollbarYRight-a.scrollbarYOuterWidth-9:a.scrollbarYRight-r.scrollLeft:m.left=a.isRtl?a.negativeScrollAdjustment+r.scrollLeft+2*a.containerWidth-a.contentWidth-a.scrollbarYLeft-a.scrollbarYOuterWidth:a.scrollbarYLeft+r.scrollLeft,Z2(a.scrollbarYRail,m),Z2(a.scrollbarX,{left:a.scrollbarXLeft,width:a.scrollbarXWidth-a.railBorderXWidth}),Z2(a.scrollbarY,{top:a.scrollbarYTop,height:a.scrollbarYHeight-a.railBorderYWidth})}(a,r),r.scrollbarXActive?a.classList.add(tr_state_active("x")):(a.classList.remove(tr_state_active("x")),r.scrollbarXWidth=0,r.scrollbarXLeft=0,a.scrollLeft=!0===r.isRtl?r.contentWidth:0),r.scrollbarYActive?a.classList.add(tr_state_active("y")):(a.classList.remove(tr_state_active("y")),r.scrollbarYHeight=0,r.scrollbarYTop=0,a.scrollTop=0)}function Fg(r,a){return r.settings.minScrollbarLength&&(a=Math.max(a,r.settings.minScrollbarLength)),r.settings.maxScrollbarLength&&(a=Math.min(a,r.settings.maxScrollbarLength)),a}function qg(r,a){var e=a[0],c=a[1],m=a[2],v=a[3],S=a[4],A=a[5],H=a[6],q=a[7],ae=a[8],ze=r.element,Se=null,Ne=null,Ee=null;function Ve(bn){bn.touches&&bn.touches[0]&&(bn[m]=bn.touches[0].pageY),ze[H]=Se+Ee*(bn[m]-Ne),Vg(r,q),Zc(r),bn.stopPropagation(),bn.preventDefault()}function Mn(){Hg(r,q),r[ae].classList.remove(tr_state_clicking),r.event.unbind(r.ownerDocument,"mousemove",Ve)}function hn(bn,rt){Se=ze[H],rt&&bn.touches&&(bn[m]=bn.touches[0].pageY),Ne=bn[m],Ee=(r[c]-r[e])/(r[v]-r[A]),rt?r.event.bind(r.ownerDocument,"touchmove",Ve):(r.event.bind(r.ownerDocument,"mousemove",Ve),r.event.once(r.ownerDocument,"mouseup",Mn),bn.preventDefault()),r[ae].classList.add(tr_state_clicking),bn.stopPropagation()}r.event.bind(r[S],"mousedown",function(bn){hn(bn)}),r.event.bind(r[S],"touchstart",function(bn){hn(bn,!0)})}var n_={"click-rail":function Xy(r){r.event.bind(r.scrollbarY,"mousedown",function(e){return e.stopPropagation()}),r.event.bind(r.scrollbarYRail,"mousedown",function(e){var c=e.pageY-window.pageYOffset-r.scrollbarYRail.getBoundingClientRect().top;r.element.scrollTop+=(c>r.scrollbarYTop?1:-1)*r.containerHeight,Zc(r),e.stopPropagation()}),r.event.bind(r.scrollbarX,"mousedown",function(e){return e.stopPropagation()}),r.event.bind(r.scrollbarXRail,"mousedown",function(e){var c=e.pageX-window.pageXOffset-r.scrollbarXRail.getBoundingClientRect().left;r.element.scrollLeft+=(c>r.scrollbarXLeft?1:-1)*r.containerWidth,Zc(r),e.stopPropagation()})},"drag-thumb":function Yy(r){qg(r,["containerWidth","contentWidth","pageX","railXWidth","scrollbarX","scrollbarXWidth","scrollLeft","x","scrollbarXRail"]),qg(r,["containerHeight","contentHeight","pageY","railYHeight","scrollbarY","scrollbarYHeight","scrollTop","y","scrollbarYRail"])},keyboard:function Qy(r){var a=r.element;r.event.bind(r.ownerDocument,"keydown",function(v){if(!(v.isDefaultPrevented&&v.isDefaultPrevented()||v.defaultPrevented)&&(c3(a,":hover")||c3(r.scrollbarX,":focus")||c3(r.scrollbarY,":focus"))){var S=document.activeElement?document.activeElement:r.ownerDocument.activeElement;if(S){if("IFRAME"===S.tagName)S=S.contentDocument.activeElement;else for(;S.shadowRoot;)S=S.shadowRoot.activeElement;if(function Wy(r){return c3(r,"input,[contenteditable]")||c3(r,"select,[contenteditable]")||c3(r,"textarea,[contenteditable]")||c3(r,"button,[contenteditable]")}(S))return}var A=0,H=0;switch(v.which){case 37:A=v.metaKey?-r.contentWidth:v.altKey?-r.containerWidth:-30;break;case 38:H=v.metaKey?r.contentHeight:v.altKey?r.containerHeight:30;break;case 39:A=v.metaKey?r.contentWidth:v.altKey?r.containerWidth:30;break;case 40:H=v.metaKey?-r.contentHeight:v.altKey?-r.containerHeight:-30;break;case 32:H=v.shiftKey?r.containerHeight:-r.containerHeight;break;case 33:H=r.containerHeight;break;case 34:H=-r.containerHeight;break;case 36:H=r.contentHeight;break;case 35:H=-r.contentHeight;break;default:return}r.settings.suppressScrollX&&0!==A||r.settings.suppressScrollY&&0!==H||(a.scrollTop-=H,a.scrollLeft+=A,Zc(r),function m(v,S){var A=Math.floor(a.scrollTop);if(0===v){if(!r.scrollbarYActive)return!1;if(0===A&&S>0||A>=r.contentHeight-r.containerHeight&&S<0)return!r.settings.wheelPropagation}var H=a.scrollLeft;if(0===S){if(!r.scrollbarXActive)return!1;if(0===H&&v<0||H>=r.contentWidth-r.containerWidth&&v>0)return!r.settings.wheelPropagation}return!0}(A,H)&&v.preventDefault())}})},wheel:function Jy(r){var a=r.element;function v(S){var A=function c(S){var A=S.deltaX,H=-1*S.deltaY;return(void 0===A||void 0===H)&&(A=-1*S.wheelDeltaX/6,H=S.wheelDeltaY/6),S.deltaMode&&1===S.deltaMode&&(A*=10,H*=10),A!=A&&H!=H&&(A=0,H=S.wheelDelta),S.shiftKey?[-H,-A]:[A,H]}(S),H=A[0],q=A[1];if(!function m(S,A,H){if(!r8.isWebKit&&a.querySelector("select:focus"))return!0;if(!a.contains(S))return!1;for(var q=S;q&&q!==a;){if(q.classList.contains(tr_element_consuming))return!0;var ae=lc(q);if(H&&ae.overflowY.match(/(scroll|auto)/)){var ze=q.scrollHeight-q.clientHeight;if(ze>0&&(q.scrollTop>0&&H<0||q.scrollTop<ze&&H>0))return!0}if(A&&ae.overflowX.match(/(scroll|auto)/)){var Se=q.scrollWidth-q.clientWidth;if(Se>0&&(q.scrollLeft>0&&A<0||q.scrollLeft<Se&&A>0))return!0}q=q.parentNode}return!1}(S.target,H,q)){var ae=!1;r.settings.useBothWheelAxes?r.scrollbarYActive&&!r.scrollbarXActive?(q?a.scrollTop-=q*r.settings.wheelSpeed:a.scrollTop+=H*r.settings.wheelSpeed,ae=!0):r.scrollbarXActive&&!r.scrollbarYActive&&(H?a.scrollLeft+=H*r.settings.wheelSpeed:a.scrollLeft-=q*r.settings.wheelSpeed,ae=!0):(a.scrollTop-=q*r.settings.wheelSpeed,a.scrollLeft+=H*r.settings.wheelSpeed),Zc(r),ae=ae||function e(S,A){var H=Math.floor(a.scrollTop),q=0===a.scrollTop,ae=H+a.offsetHeight===a.scrollHeight,ze=0===a.scrollLeft,Se=a.scrollLeft+a.offsetWidth===a.scrollWidth;return!(Math.abs(A)>Math.abs(S)?q||ae:ze||Se)||!r.settings.wheelPropagation}(H,q),ae&&!S.ctrlKey&&(S.stopPropagation(),S.preventDefault())}}void 0!==window.onwheel?r.event.bind(a,"wheel",v):void 0!==window.onmousewheel&&r.event.bind(a,"mousewheel",v)},touch:function Ky(r){if(r8.supportsTouch||r8.supportsIePointer){var a=r.element,m={},v=0,S={},A=null;r8.supportsTouch?(r.event.bind(a,"touchstart",ae),r.event.bind(a,"touchmove",Se),r.event.bind(a,"touchend",Ne)):r8.supportsIePointer&&(window.PointerEvent?(r.event.bind(a,"pointerdown",ae),r.event.bind(a,"pointermove",Se),r.event.bind(a,"pointerup",Ne)):window.MSPointerEvent&&(r.event.bind(a,"MSPointerDown",ae),r.event.bind(a,"MSPointerMove",Se),r.event.bind(a,"MSPointerUp",Ne)))}function c(Ee,Ve){a.scrollTop-=Ve,a.scrollLeft-=Ee,Zc(r)}function H(Ee){return Ee.targetTouches?Ee.targetTouches[0]:Ee}function q(Ee){return!(Ee.pointerType&&"pen"===Ee.pointerType&&0===Ee.buttons||!(Ee.targetTouches&&1===Ee.targetTouches.length||Ee.pointerType&&"mouse"!==Ee.pointerType&&Ee.pointerType!==Ee.MSPOINTER_TYPE_MOUSE))}function ae(Ee){if(q(Ee)){var Ve=H(Ee);m.pageX=Ve.pageX,m.pageY=Ve.pageY,v=(new Date).getTime(),null!==A&&clearInterval(A)}}function Se(Ee){if(q(Ee)){var Ve=H(Ee),Mn={pageX:Ve.pageX,pageY:Ve.pageY},hn=Mn.pageX-m.pageX,bn=Mn.pageY-m.pageY;if(function ze(Ee,Ve,Mn){if(!a.contains(Ee))return!1;for(var hn=Ee;hn&&hn!==a;){if(hn.classList.contains(tr_element_consuming))return!0;var bn=lc(hn);if(Mn&&bn.overflowY.match(/(scroll|auto)/)){var rt=hn.scrollHeight-hn.clientHeight;if(rt>0&&(hn.scrollTop>0&&Mn<0||hn.scrollTop<rt&&Mn>0))return!0}if(Ve&&bn.overflowX.match(/(scroll|auto)/)){var nt=hn.scrollWidth-hn.clientWidth;if(nt>0&&(hn.scrollLeft>0&&Ve<0||hn.scrollLeft<nt&&Ve>0))return!0}hn=hn.parentNode}return!1}(Ee.target,hn,bn))return;c(hn,bn),m=Mn;var rt=(new Date).getTime(),nt=rt-v;nt>0&&(S.x=hn/nt,S.y=bn/nt,v=rt),function e(Ee,Ve){var Mn=Math.floor(a.scrollTop),hn=a.scrollLeft,bn=Math.abs(Ee),rt=Math.abs(Ve);if(rt>bn){if(Ve<0&&Mn===r.contentHeight-r.containerHeight||Ve>0&&0===Mn)return 0===window.scrollY&&Ve>0&&r8.isChrome}else if(bn>rt&&(Ee<0&&hn===r.contentWidth-r.containerWidth||Ee>0&&0===hn))return!0;return!0}(hn,bn)&&Ee.preventDefault()}}function Ne(){r.settings.swipeEasing&&(clearInterval(A),A=setInterval(function(){r.isInitialized?clearInterval(A):S.x||S.y?Math.abs(S.x)<.01&&Math.abs(S.y)<.01?clearInterval(A):(c(30*S.x,30*S.y),S.x*=.8,S.y*=.8):clearInterval(A)},10))}}},xu=function(a,e){var c=this;if(void 0===e&&(e={}),"string"==typeof a&&(a=document.querySelector(a)),!a||!a.nodeName)throw new Error("no element is specified to initialize PerfectScrollbar");for(var m in this.element=a,a.classList.add("ps"),this.settings={handlers:["click-rail","drag-thumb","keyboard","wheel","touch"],maxScrollbarLength:null,minScrollbarLength:null,scrollingThreshold:1e3,scrollXMarginOffset:0,scrollYMarginOffset:0,suppressScrollX:!1,suppressScrollY:!1,swipeEasing:!0,useBothWheelAxes:!1,wheelPropagation:!0,wheelSpeed:1},e)this.settings[m]=e[m];this.containerWidth=null,this.containerHeight=null,this.contentWidth=null,this.contentHeight=null;var ae,q,v=function(){return a.classList.add(tr_state_focus)},S=function(){return a.classList.remove(tr_state_focus)};this.isRtl="rtl"===lc(a).direction,!0===this.isRtl&&a.classList.add("ps__rtl"),this.isNegativeScroll=(q=a.scrollLeft,a.scrollLeft=-1,ae=a.scrollLeft<0,a.scrollLeft=q,ae),this.negativeScrollAdjustment=this.isNegativeScroll?a.scrollWidth-a.clientWidth:0,this.event=new a8,this.ownerDocument=a.ownerDocument||document,this.scrollbarXRail=Cf(tr_element_rail("x")),a.appendChild(this.scrollbarXRail),this.scrollbarX=Cf(tr_element_thumb("x")),this.scrollbarXRail.appendChild(this.scrollbarX),this.scrollbarX.setAttribute("tabindex",0),this.event.bind(this.scrollbarX,"focus",v),this.event.bind(this.scrollbarX,"blur",S),this.scrollbarXActive=null,this.scrollbarXWidth=null,this.scrollbarXLeft=null;var A=lc(this.scrollbarXRail);this.scrollbarXBottom=parseInt(A.bottom,10),isNaN(this.scrollbarXBottom)?(this.isScrollbarXUsingBottom=!1,this.scrollbarXTop=fa(A.top)):this.isScrollbarXUsingBottom=!0,this.railBorderXWidth=fa(A.borderLeftWidth)+fa(A.borderRightWidth),Z2(this.scrollbarXRail,{display:"block"}),this.railXMarginWidth=fa(A.marginLeft)+fa(A.marginRight),Z2(this.scrollbarXRail,{display:""}),this.railXWidth=null,this.railXRatio=null,this.scrollbarYRail=Cf(tr_element_rail("y")),a.appendChild(this.scrollbarYRail),this.scrollbarY=Cf(tr_element_thumb("y")),this.scrollbarYRail.appendChild(this.scrollbarY),this.scrollbarY.setAttribute("tabindex",0),this.event.bind(this.scrollbarY,"focus",v),this.event.bind(this.scrollbarY,"blur",S),this.scrollbarYActive=null,this.scrollbarYHeight=null,this.scrollbarYTop=null;var H=lc(this.scrollbarYRail);this.scrollbarYRight=parseInt(H.right,10),isNaN(this.scrollbarYRight)?(this.isScrollbarYUsingRight=!1,this.scrollbarYLeft=fa(H.left)):this.isScrollbarYUsingRight=!0,this.scrollbarYOuterWidth=this.isRtl?function Zy(r){var a=lc(r);return fa(a.width)+fa(a.paddingLeft)+fa(a.paddingRight)+fa(a.borderLeftWidth)+fa(a.borderRightWidth)}(this.scrollbarY):null,this.railBorderYWidth=fa(H.borderTopWidth)+fa(H.borderBottomWidth),Z2(this.scrollbarYRail,{display:"block"}),this.railYMarginHeight=fa(H.marginTop)+fa(H.marginBottom),Z2(this.scrollbarYRail,{display:""}),this.railYHeight=null,this.railYRatio=null,this.reach={x:a.scrollLeft<=0?"start":a.scrollLeft>=this.contentWidth-this.containerWidth?"end":null,y:a.scrollTop<=0?"start":a.scrollTop>=this.contentHeight-this.containerHeight?"end":null},this.isAlive=!0,this.settings.handlers.forEach(function(q){return n_[q](c)}),this.lastScrollTop=Math.floor(a.scrollTop),this.lastScrollLeft=a.scrollLeft,this.event.bind(this.element,"scroll",function(q){return c.onScroll(q)}),Zc(this)};xu.prototype.update=function(){!this.isAlive||(this.negativeScrollAdjustment=this.isNegativeScroll?this.element.scrollWidth-this.element.clientWidth:0,Z2(this.scrollbarXRail,{display:"block"}),Z2(this.scrollbarYRail,{display:"block"}),this.railXMarginWidth=fa(lc(this.scrollbarXRail).marginLeft)+fa(lc(this.scrollbarXRail).marginRight),this.railYMarginHeight=fa(lc(this.scrollbarYRail).marginTop)+fa(lc(this.scrollbarYRail).marginBottom),Z2(this.scrollbarXRail,{display:"none"}),Z2(this.scrollbarYRail,{display:"none"}),Zc(this),Mf(this,"top",0,!1,!0),Mf(this,"left",0,!1,!0),Z2(this.scrollbarXRail,{display:""}),Z2(this.scrollbarYRail,{display:""}))},xu.prototype.onScroll=function(a){!this.isAlive||(Zc(this),Mf(this,"top",this.element.scrollTop-this.lastScrollTop),Mf(this,"left",this.element.scrollLeft-this.lastScrollLeft),this.lastScrollTop=Math.floor(this.element.scrollTop),this.lastScrollLeft=this.element.scrollLeft)},xu.prototype.destroy=function(){!this.isAlive||(this.event.unbindAll(),i8(this.scrollbarX),i8(this.scrollbarY),i8(this.scrollbarXRail),i8(this.scrollbarYRail),this.removePsClasses(),this.element=null,this.scrollbarX=null,this.scrollbarY=null,this.scrollbarXRail=null,this.scrollbarYRail=null,this.isAlive=!1)},xu.prototype.removePsClasses=function(){this.element.className=this.element.className.split(" ").filter(function(a){return!a.match(/^ps([-_].+|)$/)}).join(" ")};var Bg=function(){if("undefined"!=typeof Map)return Map;function r(a,e){var c=-1;return a.some(function(m,v){return m[0]===e&&(c=v,!0)}),c}return function(){function a(){this.__entries__=[]}return Object.defineProperty(a.prototype,"size",{get:function(){return this.__entries__.length},enumerable:!0,configurable:!0}),a.prototype.get=function(e){var c=r(this.__entries__,e),m=this.__entries__[c];return m&&m[1]},a.prototype.set=function(e,c){var m=r(this.__entries__,e);~m?this.__entries__[m][1]=c:this.__entries__.push([e,c])},a.prototype.delete=function(e){var c=this.__entries__,m=r(c,e);~m&&c.splice(m,1)},a.prototype.has=function(e){return!!~r(this.__entries__,e)},a.prototype.clear=function(){this.__entries__.splice(0)},a.prototype.forEach=function(e,c){void 0===c&&(c=null);for(var m=0,v=this.__entries__;m<v.length;m++){var S=v[m];e.call(c,S[1],S[0])}},a}()}(),Mh="undefined"!=typeof window&&"undefined"!=typeof document&&window.document===document,wf="undefined"!=typeof global&&global.Math===Math?global:"undefined"!=typeof self&&self.Math===Math?self:"undefined"!=typeof window&&window.Math===Math?window:Function("return this")(),i_="function"==typeof requestAnimationFrame?requestAnimationFrame.bind(wf):function(r){return setTimeout(function(){return r(Date.now())},1e3/60)},s_=["top","right","bottom","left","width","height","size","weight"],c_="undefined"!=typeof MutationObserver,l_=function(){function r(){this.connected_=!1,this.mutationEventsAdded_=!1,this.mutationsObserver_=null,this.observers_=[],this.onTransitionEnd_=this.onTransitionEnd_.bind(this),this.refresh=function r_(r,a){var e=!1,c=!1,m=0;function v(){e&&(e=!1,r()),c&&A()}function S(){i_(v)}function A(){var H=Date.now();if(e){if(H-m<2)return;c=!0}else e=!0,c=!1,setTimeout(S,a);m=H}return A}(this.refresh.bind(this),20)}return r.prototype.addObserver=function(a){~this.observers_.indexOf(a)||this.observers_.push(a),this.connected_||this.connect_()},r.prototype.removeObserver=function(a){var e=this.observers_,c=e.indexOf(a);~c&&e.splice(c,1),!e.length&&this.connected_&&this.disconnect_()},r.prototype.refresh=function(){this.updateObservers_()&&this.refresh()},r.prototype.updateObservers_=function(){var a=this.observers_.filter(function(e){return e.gatherActive(),e.hasActive()});return a.forEach(function(e){return e.broadcastActive()}),a.length>0},r.prototype.connect_=function(){!Mh||this.connected_||(document.addEventListener("transitionend",this.onTransitionEnd_),window.addEventListener("resize",this.refresh),c_?(this.mutationsObserver_=new MutationObserver(this.refresh),this.mutationsObserver_.observe(document,{attributes:!0,childList:!0,characterData:!0,subtree:!0})):(document.addEventListener("DOMSubtreeModified",this.refresh),this.mutationEventsAdded_=!0),this.connected_=!0)},r.prototype.disconnect_=function(){!Mh||!this.connected_||(document.removeEventListener("transitionend",this.onTransitionEnd_),window.removeEventListener("resize",this.refresh),this.mutationsObserver_&&this.mutationsObserver_.disconnect(),this.mutationEventsAdded_&&document.removeEventListener("DOMSubtreeModified",this.refresh),this.mutationsObserver_=null,this.mutationEventsAdded_=!1,this.connected_=!1)},r.prototype.onTransitionEnd_=function(a){var e=a.propertyName,c=void 0===e?"":e;s_.some(function(v){return!!~c.indexOf(v)})&&this.refresh()},r.getInstance=function(){return this.instance_||(this.instance_=new r),this.instance_},r.instance_=null,r}(),Ug=function(r,a){for(var e=0,c=Object.keys(a);e<c.length;e++){var m=c[e];Object.defineProperty(r,m,{value:a[m],enumerable:!1,writable:!1,configurable:!0})}return r},o8=function(r){return r&&r.ownerDocument&&r.ownerDocument.defaultView||wf},Gg=Nf(0,0,0,0);function zf(r){return parseFloat(r)||0}function Wg(r){for(var a=[],e=1;e<arguments.length;e++)a[e-1]=arguments[e];return a.reduce(function(c,m){return c+zf(r["border-"+m+"-width"])},0)}var p_="undefined"!=typeof SVGGraphicsElement?function(r){return r instanceof o8(r).SVGGraphicsElement}:function(r){return r instanceof o8(r).SVGElement&&"function"==typeof r.getBBox};function h_(r){return Mh?p_(r)?function u_(r){var a=r.getBBox();return Nf(0,0,a.width,a.height)}(r):function f_(r){var a=r.clientWidth,e=r.clientHeight;if(!a&&!e)return Gg;var c=o8(r).getComputedStyle(r),m=function d_(r){for(var e={},c=0,m=["top","right","bottom","left"];c<m.length;c++){var v=m[c];e[v]=zf(r["padding-"+v])}return e}(c),v=m.left+m.right,S=m.top+m.bottom,A=zf(c.width),H=zf(c.height);if("border-box"===c.boxSizing&&(Math.round(A+v)!==a&&(A-=Wg(c,"left","right")+v),Math.round(H+S)!==e&&(H-=Wg(c,"top","bottom")+S)),!function m_(r){return r===o8(r).document.documentElement}(r)){var q=Math.round(A+v)-a,ae=Math.round(H+S)-e;1!==Math.abs(q)&&(A-=q),1!==Math.abs(ae)&&(H-=ae)}return Nf(m.left,m.top,A,H)}(r):Gg}function Nf(r,a,e,c){return{x:r,y:a,width:e,height:c}}var v_=function(){function r(a){this.broadcastWidth=0,this.broadcastHeight=0,this.contentRect_=Nf(0,0,0,0),this.target=a}return r.prototype.isActive=function(){var a=h_(this.target);return this.contentRect_=a,a.width!==this.broadcastWidth||a.height!==this.broadcastHeight},r.prototype.broadcastRect=function(){var a=this.contentRect_;return this.broadcastWidth=a.width,this.broadcastHeight=a.height,a},r}(),b_=function r(a,e){var c=function g_(r){var a=r.x,e=r.y,c=r.width,m=r.height,v="undefined"!=typeof DOMRectReadOnly?DOMRectReadOnly:Object,S=Object.create(v.prototype);return Ug(S,{x:a,y:e,width:c,height:m,top:e,right:a+c,bottom:m+e,left:a}),S}(e);Ug(this,{target:a,contentRect:c})},y_=function(){function r(a,e,c){if(this.activeObservations_=[],this.observations_=new Bg,"function"!=typeof a)throw new TypeError("The callback provided as parameter 1 is not a function.");this.callback_=a,this.controller_=e,this.callbackCtx_=c}return r.prototype.observe=function(a){if(!arguments.length)throw new TypeError("1 argument required, but only 0 present.");if("undefined"!=typeof Element&&Element instanceof Object){if(!(a instanceof o8(a).Element))throw new TypeError('parameter 1 is not of type "Element".');var e=this.observations_;e.has(a)||(e.set(a,new v_(a)),this.controller_.addObserver(this),this.controller_.refresh())}},r.prototype.unobserve=function(a){if(!arguments.length)throw new TypeError("1 argument required, but only 0 present.");if("undefined"!=typeof Element&&Element instanceof Object){if(!(a instanceof o8(a).Element))throw new TypeError('parameter 1 is not of type "Element".');var e=this.observations_;!e.has(a)||(e.delete(a),e.size||this.controller_.removeObserver(this))}},r.prototype.disconnect=function(){this.clearActive(),this.observations_.clear(),this.controller_.removeObserver(this)},r.prototype.gatherActive=function(){var a=this;this.clearActive(),this.observations_.forEach(function(e){e.isActive()&&a.activeObservations_.push(e)})},r.prototype.broadcastActive=function(){if(this.hasActive()){var a=this.callbackCtx_,e=this.activeObservations_.map(function(c){return new b_(c.target,c.broadcastRect())});this.callback_.call(a,e,a),this.clearActive()}},r.prototype.clearActive=function(){this.activeObservations_.splice(0)},r.prototype.hasActive=function(){return this.activeObservations_.length>0},r}(),Zg="undefined"!=typeof WeakMap?new WeakMap:new Bg,$g=function r(a){if(!(this instanceof r))throw new TypeError("Cannot call a class as a function.");if(!arguments.length)throw new TypeError("1 argument required, but only 0 present.");var e=l_.getInstance(),c=new y_(a,e,this);Zg.set(this,c)};["observe","unobserve","disconnect"].forEach(function(r){$g.prototype[r]=function(){var a;return(a=Zg.get(this))[r].apply(a,arguments)}});const wh=new d.OlP("PERFECT_SCROLLBAR_CONFIG");let z_=(()=>{let r=class{};return r.\u0275fac=function(e){return new(e||r)},r.\u0275mod=d.oAB({type:r}),r.\u0275inj=d.cJS({imports:[[Hn.ez],Hn.ez]}),r})();const N_={suppressScrollX:!0,wheelSpeed:1,wheelPropagation:!0,minScrollbarLength:20};let D_=(()=>{class r{}return r.\u0275fac=function(e){return new(e||r)},r.\u0275mod=d.oAB({type:r,bootstrap:[Py]}),r.\u0275inj=d.cJS({providers:[{provide:Hn.S$,useClass:Hn.Do},{provide:wh,useValue:N_}],imports:[[Hn.ez,M.b2,Y1,N1.u5,N1.UX,_,V0,G.Bz.forRoot(Ty,{useHash:!1,relativeLinkResolution:"legacy"}),z_,cc.uH,L5,tp]]}),r})();Q(3993),Q(7270),Q(5255),(0,d.G48)(),M.q6().bootstrapModule(D_).catch(r=>console.log(r))},8266:function(Xn){Xn.exports=function(){"use strict";var He=navigator.userAgent,Q=navigator.platform,M=/gecko\/\d/i.test(He),d=/MSIE \d/.test(He),Ue=/Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(He),Oe=/Edge\/(\d+)/.exec(He),ye=d||Ue||Oe,he=ye&&(d?document.documentMode||6:+(Oe||Ue)[1]),oe=!Oe&&/WebKit\//.test(He),ce=oe&&/Qt\/\d+\.\d+/.test(He),fe=!Oe&&/Chrome\//.test(He),le=/Opera\//.test(He),pe=/Apple Computer/.test(navigator.vendor),Me=/Mac OS X 1\d\D([8-9]|\d\d)\D/.test(He),Ae=/PhantomJS/.test(He),dn=pe&&(/Mobile\/\w+/.test(He)||navigator.maxTouchPoints>2),rn=/Android/.test(He),Ke=dn||rn||/webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(He),Qe=dn||/Mac/.test(Q),ot=/\bCrOS\b/.test(He),Dn=/win/i.test(Q),yn=le&&He.match(/Version\/(\d*\.\d*)/);yn&&(yn=Number(yn[1])),yn&&yn>=15&&(le=!1,oe=!0);var ut=Qe&&(ce||le&&(null==yn||yn<12.11)),cn=M||ye&&he>=9;function fn(i){return new RegExp("(^|\\s)"+i+"(?:$|\\s)\\s*")}var tt,g1=function(i,s){var f=i.className,u=fn(s).exec(f);if(u){var h=f.slice(u.index+u[0].length);i.className=f.slice(0,u.index)+(h?u[1]+h:"")}};function mt(i){for(var s=i.childNodes.length;s>0;--s)i.removeChild(i.firstChild);return i}function l1(i,s){return mt(i).appendChild(s)}function tn(i,s,f,u){var h=document.createElement(i);if(f&&(h.className=f),u&&(h.style.cssText=u),"string"==typeof s)h.appendChild(document.createTextNode(s));else if(s)for(var y=0;y<s.length;++y)h.appendChild(s[y]);return h}function Yn(i,s,f,u){var h=tn(i,s,f,u);return h.setAttribute("role","presentation"),h}function Un(i,s){if(3==s.nodeType&&(s=s.parentNode),i.contains)return i.contains(s);do{if(11==s.nodeType&&(s=s.host),s==i)return!0}while(s=s.parentNode)}function Le(){var i;try{i=document.activeElement}catch(s){i=document.body||null}for(;i&&i.shadowRoot&&i.shadowRoot.activeElement;)i=i.shadowRoot.activeElement;return i}function De(i,s){var f=i.className;fn(s).test(f)||(i.className+=(f?" ":"")+s)}function ge(i,s){for(var f=i.split(" "),u=0;u<f.length;u++)f[u]&&!fn(f[u]).test(s)&&(s+=" "+f[u]);return s}tt=document.createRange?function(i,s,f,u){var h=document.createRange();return h.setEnd(u||i,f),h.setStart(i,s),h}:function(i,s,f){var u=document.body.createTextRange();try{u.moveToElementText(i.parentNode)}catch(h){return u}return u.collapse(!0),u.moveEnd("character",f),u.moveStart("character",s),u};var me=function(i){i.select()};function Xe(i){var s=Array.prototype.slice.call(arguments,1);return function(){return i.apply(null,s)}}function En(i,s,f){for(var u in s||(s={}),i)i.hasOwnProperty(u)&&(!1!==f||!s.hasOwnProperty(u))&&(s[u]=i[u]);return s}function Ln(i,s,f,u,h){null==s&&-1==(s=i.search(/[^\s\u00a0]/))&&(s=i.length);for(var y=u||0,w=h||0;;){var E=i.indexOf("\t",y);if(E<0||E>=s)return w+(s-y);w+=E-y,w+=f-w%f,y=E+1}}dn?me=function(i){i.selectionStart=0,i.selectionEnd=i.value.length}:ye&&(me=function(i){try{i.select()}catch(s){}});var lt=function(){this.id=null,this.f=null,this.time=0,this.handler=Xe(this.onTimeout,this)};function Rt(i,s){for(var f=0;f<i.length;++f)if(i[f]==s)return f;return-1}lt.prototype.onTimeout=function(i){i.id=0,i.time<=+new Date?i.f():setTimeout(i.handler,i.time-+new Date)},lt.prototype.set=function(i,s){this.f=s;var f=+new Date+i;(!this.id||f<this.time)&&(clearTimeout(this.id),this.id=setTimeout(this.handler,i),this.time=f)};var Bt={toString:function(){return"CodeMirror.Pass"}},st={scroll:!1},zt={origin:"*mouse"},Lt={origin:"+move"};function $i(i,s,f){for(var u=0,h=0;;){var y=i.indexOf("\t",u);-1==y&&(y=i.length);var w=y-u;if(y==i.length||h+w>=s)return u+Math.min(w,s-h);if(h+=y-u,u=y+1,(h+=f-h%f)>=s)return u}}var Ut=[""];function y1(i){for(;Ut.length<=i;)Ut.push(qn(Ut)+" ");return Ut[i]}function qn(i){return i[i.length-1]}function pi(i,s){for(var f=[],u=0;u<i.length;u++)f[u]=s(i[u],u);return f}function j1(){}function Gt(i,s){var f;return Object.create?f=Object.create(i):(j1.prototype=i,f=new j1),s&&En(s,f),f}var a1=/[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/;function q1(i){return/\w/.test(i)||i>"\x80"&&(i.toUpperCase()!=i.toLowerCase()||a1.test(i))}function xt(i,s){return s?!!(s.source.indexOf("\\w")>-1&&q1(i))||s.test(i):q1(i)}function Mi(i){for(var s in i)if(i.hasOwnProperty(s)&&i[s])return!1;return!0}var wa=/[\u0300-\u036f\u0483-\u0489\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u065e\u0670\u06d6-\u06dc\u06de-\u06e4\u06e7\u06e8\u06ea-\u06ed\u0711\u0730-\u074a\u07a6-\u07b0\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0900-\u0902\u093c\u0941-\u0948\u094d\u0951-\u0955\u0962\u0963\u0981\u09bc\u09be\u09c1-\u09c4\u09cd\u09d7\u09e2\u09e3\u0a01\u0a02\u0a3c\u0a41\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a70\u0a71\u0a75\u0a81\u0a82\u0abc\u0ac1-\u0ac5\u0ac7\u0ac8\u0acd\u0ae2\u0ae3\u0b01\u0b3c\u0b3e\u0b3f\u0b41-\u0b44\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b82\u0bbe\u0bc0\u0bcd\u0bd7\u0c3e-\u0c40\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0cbc\u0cbf\u0cc2\u0cc6\u0ccc\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0d3e\u0d41-\u0d44\u0d4d\u0d57\u0d62\u0d63\u0dca\u0dcf\u0dd2-\u0dd4\u0dd6\u0ddf\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0f18\u0f19\u0f35\u0f37\u0f39\u0f71-\u0f7e\u0f80-\u0f84\u0f86\u0f87\u0f90-\u0f97\u0f99-\u0fbc\u0fc6\u102d-\u1030\u1032-\u1037\u1039\u103a\u103d\u103e\u1058\u1059\u105e-\u1060\u1071-\u1074\u1082\u1085\u1086\u108d\u109d\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b7-\u17bd\u17c6\u17c9-\u17d3\u17dd\u180b-\u180d\u18a9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193b\u1a17\u1a18\u1a56\u1a58-\u1a5e\u1a60\u1a62\u1a65-\u1a6c\u1a73-\u1a7c\u1a7f\u1b00-\u1b03\u1b34\u1b36-\u1b3a\u1b3c\u1b42\u1b6b-\u1b73\u1b80\u1b81\u1ba2-\u1ba5\u1ba8\u1ba9\u1c2c-\u1c33\u1c36\u1c37\u1cd0-\u1cd2\u1cd4-\u1ce0\u1ce2-\u1ce8\u1ced\u1dc0-\u1de6\u1dfd-\u1dff\u200c\u200d\u20d0-\u20f0\u2cef-\u2cf1\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua66f-\ua672\ua67c\ua67d\ua6f0\ua6f1\ua802\ua806\ua80b\ua825\ua826\ua8c4\ua8e0-\ua8f1\ua926-\ua92d\ua947-\ua951\ua980-\ua982\ua9b3\ua9b6-\ua9b9\ua9bc\uaa29-\uaa2e\uaa31\uaa32\uaa35\uaa36\uaa43\uaa4c\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uabe5\uabe8\uabed\udc00-\udfff\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\uff9e\uff9f]/;function $n(i){return i.charCodeAt(0)>=768&&wa.test(i)}function wi(i,s,f){for(;(f<0?s>0:s<i.length)&&$n(i.charAt(s));)s+=f;return s}function Rn(i,s,f){for(var u=s>f?-1:1;;){if(s==f)return s;var h=(s+f)/2,y=u<0?Math.ceil(h):Math.floor(h);if(y==s)return i(y)?s:f;i(y)?f=y:s=y+u}}var _n=null;function on(i,s,f){var u;_n=null;for(var h=0;h<i.length;++h){var y=i[h];if(y.from<s&&y.to>s)return h;y.to==s&&(y.from!=y.to&&"before"==f?u=h:_n=h),y.from==s&&(y.from!=y.to&&"before"!=f?u=h:_n=h)}return null!=u?u:_n}var ln=function(){function f(F){return F<=247?"bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN".charAt(F):1424<=F&&F<=1524?"R":1536<=F&&F<=1785?"nnnnnnNNr%%r,rNNmmmmmmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmmmnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmnNmmmmmmrrmmNmmmmrr1111111111".charAt(F-1536):1774<=F&&F<=2220?"r":8192<=F&&F<=8203?"w":8204==F?"b":"L"}var u=/[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/,h=/[stwN]/,y=/[LRr]/,w=/[Lb1n]/,E=/[1n]/;function I(F,J,ie){this.level=F,this.from=J,this.to=ie}return function(F,J){var ie="ltr"==J?"L":"R";if(0==F.length||"ltr"==J&&!u.test(F))return!1;for(var _e=F.length,be=[],Te=0;Te<_e;++Te)be.push(f(F.charCodeAt(Te)));for(var Ge=0,an=ie;Ge<_e;++Ge){var pn=be[Ge];"m"==pn?be[Ge]=an:an=pn}for(var Cn=0,gn=ie;Cn<_e;++Cn){var Nn=be[Cn];"1"==Nn&&"r"==gn?be[Cn]="n":y.test(Nn)&&(gn=Nn,"r"==Nn&&(be[Cn]="R"))}for(var Wn=1,Bn=be[0];Wn<_e-1;++Wn){var Et=be[Wn];"+"==Et&&"1"==Bn&&"1"==be[Wn+1]?be[Wn]="1":","==Et&&Bn==be[Wn+1]&&("1"==Bn||"n"==Bn)&&(be[Wn]=Bn),Bn=Et}for(var t1=0;t1<_e;++t1){var ci=be[t1];if(","==ci)be[t1]="N";else if("%"==ci){var F1=void 0;for(F1=t1+1;F1<_e&&"%"==be[F1];++F1);for(var nr=t1&&"!"==be[t1-1]||F1<_e&&"1"==be[F1]?"1":"N",la=t1;la<F1;++la)be[la]=nr;t1=F1-1}}for(var li=0,Ha=ie;li<_e;++li){var Wi=be[li];"L"==Ha&&"1"==Wi?be[li]="L":y.test(Wi)&&(Ha=Wi)}for(var xi=0;xi<_e;++xi)if(h.test(be[xi])){var di=void 0;for(di=xi+1;di<_e&&h.test(be[di]);++di);for(var Q1="L"==(xi?be[xi-1]:ie),R2=Q1==("L"==(di<_e?be[di]:ie))?Q1?"L":"R":ie,$r=xi;$r<di;++$r)be[$r]=R2;xi=di-1}for(var l2,ki=[],Ci=0;Ci<_e;)if(w.test(be[Ci])){var Js=Ci;for(++Ci;Ci<_e&&w.test(be[Ci]);++Ci);ki.push(new I(0,Js,Ci))}else{var d2=Ci,ur=ki.length,F2="rtl"==J?1:0;for(++Ci;Ci<_e&&"L"!=be[Ci];++Ci);for(var da=d2;da<Ci;)if(E.test(be[da])){d2<da&&(ki.splice(ur,0,new I(1,d2,da)),ur+=F2);var Ro=da;for(++da;da<Ci&&E.test(be[da]);++da);ki.splice(ur,0,new I(2,Ro,da)),ur+=F2,d2=da}else++da;d2<Ci&&ki.splice(ur,0,new I(1,d2,Ci))}return"ltr"==J&&(1==ki[0].level&&(l2=F.match(/^\s+/))&&(ki[0].from=l2[0].length,ki.unshift(new I(0,0,l2[0].length))),1==qn(ki).level&&(l2=F.match(/\s+$/))&&(qn(ki).to-=l2[0].length,ki.push(new I(0,_e-l2[0].length,_e)))),"rtl"==J?ki.reverse():ki}}();function sn(i,s){var f=i.order;return null==f&&(f=i.order=ln(i.text,s)),f}var zi=[],jn=function(i,s,f){if(i.addEventListener)i.addEventListener(s,f,!1);else if(i.attachEvent)i.attachEvent("on"+s,f);else{var u=i._handlers||(i._handlers={});u[s]=(u[s]||zi).concat(f)}};function Nt(i,s){return i._handlers&&i._handlers[s]||zi}function On(i,s,f){if(i.removeEventListener)i.removeEventListener(s,f,!1);else if(i.detachEvent)i.detachEvent("on"+s,f);else{var u=i._handlers,h=u&&u[s];if(h){var y=Rt(h,f);y>-1&&(u[s]=h.slice(0,y).concat(h.slice(y+1)))}}}function ht(i,s){var f=Nt(i,s);if(f.length)for(var u=Array.prototype.slice.call(arguments,2),h=0;h<f.length;++h)f[h].apply(null,u)}function Wt(i,s,f){return"string"==typeof s&&(s={type:s,preventDefault:function(){this.defaultPrevented=!0}}),ht(i,f||s.type,i,s),et(s)||s.codemirrorIgnore}function e1(i){var s=i._handlers&&i._handlers.cursorActivity;if(s)for(var f=i.curOp.cursorActivityHandlers||(i.curOp.cursorActivityHandlers=[]),u=0;u<s.length;++u)-1==Rt(f,s[u])&&f.push(s[u])}function gt(i,s){return Nt(i,s).length>0}function Mt(i){i.prototype.on=function(s,f){jn(this,s,f)},i.prototype.off=function(s,f){On(this,s,f)}}function _1(i){i.preventDefault?i.preventDefault():i.returnValue=!1}function m1(i){i.stopPropagation?i.stopPropagation():i.cancelBubble=!0}function et(i){return null!=i.defaultPrevented?i.defaultPrevented:0==i.returnValue}function k1(i){_1(i),m1(i)}function ma(i){return i.target||i.srcElement}function Ni(i){var s=i.which;return null==s&&(1&i.button?s=1:2&i.button?s=3:4&i.button&&(s=2)),Qe&&i.ctrlKey&&1==s&&(s=3),s}var kt,Yi,Di=function(){if(ye&&he<9)return!1;var i=tn("div");return"draggable"in i||"dragDrop"in i}();function r1(i){if(null==kt){var s=tn("span","\u200b");l1(i,tn("span",[s,document.createTextNode("x")])),0!=i.firstChild.offsetHeight&&(kt=s.offsetWidth<=1&&s.offsetHeight>2&&!(ye&&he<8))}var f=kt?tn("span","\u200b"):tn("span","\xa0",null,"display: inline-block; width: 1px; margin-right: -1px");return f.setAttribute("cm-text",""),f}function za(i){if(null!=Yi)return Yi;var s=l1(i,document.createTextNode("A\u062eA")),f=tt(s,0,1).getBoundingClientRect(),u=tt(s,1,2).getBoundingClientRect();return mt(i),!(!f||f.left==f.right)&&(Yi=u.right-f.right<3)}var i,Na=3!="\n\nb".split(/\n/).length?function(i){for(var s=0,f=[],u=i.length;s<=u;){var h=i.indexOf("\n",s);-1==h&&(h=i.length);var y=i.slice(s,"\r"==i.charAt(h-1)?h-1:h),w=y.indexOf("\r");-1!=w?(f.push(y.slice(0,w)),s+=w+1):(f.push(y),s=h+1)}return f}:function(i){return i.split(/\r\n?|\n/)},we=window.getSelection?function(i){try{return i.selectionStart!=i.selectionEnd}catch(s){return!1}}:function(i){var s;try{s=i.ownerDocument.selection.createRange()}catch(f){}return!(!s||s.parentElement()!=i)&&0!=s.compareEndPoints("StartToEnd",s)},de="oncopy"in(i=tn("div"))||(i.setAttribute("oncopy","return;"),"function"==typeof i.oncopy),ee=null;var Re={},Vn={};function it(i,s){arguments.length>2&&(s.dependencies=Array.prototype.slice.call(arguments,2)),Re[i]=s}function Sn(i){if("string"==typeof i&&Vn.hasOwnProperty(i))i=Vn[i];else if(i&&"string"==typeof i.name&&Vn.hasOwnProperty(i.name)){var s=Vn[i.name];"string"==typeof s&&(s={name:s}),(i=Gt(s,i)).name=s.name}else{if("string"==typeof i&&/^[\w\-]+\/[\w\-]+\+xml$/.test(i))return Sn("application/xml");if("string"==typeof i&&/^[\w\-]+\/[\w\-]+\+json$/.test(i))return Sn("application/json")}return"string"==typeof i?{name:i}:i||{name:"null"}}function Zt(i,s){s=Sn(s);var f=Re[s.name];if(!f)return Zt(i,"text/plain");var u=f(i,s);if(x1.hasOwnProperty(s.name)){var h=x1[s.name];for(var y in h)!h.hasOwnProperty(y)||(u.hasOwnProperty(y)&&(u["_"+y]=u[y]),u[y]=h[y])}if(u.name=s.name,s.helperType&&(u.helperType=s.helperType),s.modeProps)for(var w in s.modeProps)u[w]=s.modeProps[w];return u}var x1={};function $t(i,s){En(s,x1.hasOwnProperty(i)?x1[i]:x1[i]={})}function P1(i,s){if(!0===s)return s;if(i.copyState)return i.copyState(s);var f={};for(var u in s){var h=s[u];h instanceof Array&&(h=h.concat([])),f[u]=h}return f}function M1(i,s){for(var f;i.innerMode&&(f=i.innerMode(s))&&f.mode!=i;)s=f.state,i=f.mode;return f||{mode:i,state:s}}function Ei(i,s,f){return!i.startState||i.startState(s,f)}var Ft=function(i,s,f){this.pos=this.start=0,this.string=i,this.tabSize=s||8,this.lastColumnPos=this.lastColumnValue=0,this.lineStart=0,this.lineOracle=f};function mn(i,s){if((s-=i.first)<0||s>=i.size)throw new Error("There is no line "+(s+i.first)+" in the document.");for(var f=i;!f.lines;)for(var u=0;;++u){var h=f.children[u],y=h.chunkSize();if(s<y){f=h;break}s-=y}return f.lines[s]}function bt(i,s,f){var u=[],h=s.line;return i.iter(s.line,f.line+1,function(y){var w=y.text;h==f.line&&(w=w.slice(0,f.ch)),h==s.line&&(w=w.slice(s.ch)),u.push(w),++h}),u}function Ai(i,s,f){var u=[];return i.iter(s,f,function(h){u.push(h.text)}),u}function qt(i,s){var f=s-i.height;if(f)for(var u=i;u;u=u.parent)u.height+=f}function Ze(i){if(null==i.parent)return null;for(var s=i.parent,f=Rt(s.lines,i),u=s.parent;u;s=u,u=u.parent)for(var h=0;u.children[h]!=s;++h)f+=u.children[h].chunkSize();return f+s.first}function Gn(i,s){var f=i.first;e:do{for(var u=0;u<i.children.length;++u){var h=i.children[u],y=h.height;if(s<y){i=h;continue e}s-=y,f+=h.chunkSize()}return f}while(!i.lines);for(var w=0;w<i.lines.length;++w){var I=i.lines[w].height;if(s<I)break;s-=I}return f+w}function yt(i,s){return s>=i.first&&s<i.first+i.size}function v1(i,s){return String(i.lineNumberFormatter(s+i.firstLineNumber))}function We(i,s,f){if(void 0===f&&(f=null),!(this instanceof We))return new We(i,s,f);this.line=i,this.ch=s,this.sticky=f}function wn(i,s){return i.line-s.line||i.ch-s.ch}function mi(i,s){return i.sticky==s.sticky&&0==wn(i,s)}function n1(i){return We(i.line,i.ch)}function J1(i,s){return wn(i,s)<0?s:i}function d1(i,s){return wn(i,s)<0?i:s}function Qn(i,s){return Math.max(i.first,Math.min(s,i.first+i.size-1))}function Pn(i,s){if(s.line<i.first)return We(i.first,0);var f=i.first+i.size-1;return s.line>f?We(f,mn(i,f).text.length):function Li(i,s){var f=i.ch;return null==f||f>s?We(i.line,s):f<0?We(i.line,0):i}(s,mn(i,s.line).text.length)}function ha(i,s){for(var f=[],u=0;u<s.length;u++)f[u]=Pn(i,s[u]);return f}Ft.prototype.eol=function(){return this.pos>=this.string.length},Ft.prototype.sol=function(){return this.pos==this.lineStart},Ft.prototype.peek=function(){return this.string.charAt(this.pos)||void 0},Ft.prototype.next=function(){if(this.pos<this.string.length)return this.string.charAt(this.pos++)},Ft.prototype.eat=function(i){var s=this.string.charAt(this.pos);if("string"==typeof i?s==i:s&&(i.test?i.test(s):i(s)))return++this.pos,s},Ft.prototype.eatWhile=function(i){for(var s=this.pos;this.eat(i););return this.pos>s},Ft.prototype.eatSpace=function(){for(var i=this.pos;/[\s\u00a0]/.test(this.string.charAt(this.pos));)++this.pos;return this.pos>i},Ft.prototype.skipToEnd=function(){this.pos=this.string.length},Ft.prototype.skipTo=function(i){var s=this.string.indexOf(i,this.pos);if(s>-1)return this.pos=s,!0},Ft.prototype.backUp=function(i){this.pos-=i},Ft.prototype.column=function(){return this.lastColumnPos<this.start&&(this.lastColumnValue=Ln(this.string,this.start,this.tabSize,this.lastColumnPos,this.lastColumnValue),this.lastColumnPos=this.start),this.lastColumnValue-(this.lineStart?Ln(this.string,this.lineStart,this.tabSize):0)},Ft.prototype.indentation=function(){return Ln(this.string,null,this.tabSize)-(this.lineStart?Ln(this.string,this.lineStart,this.tabSize):0)},Ft.prototype.match=function(i,s,f){if("string"!=typeof i){var y=this.string.slice(this.pos).match(i);return y&&y.index>0?null:(y&&!1!==s&&(this.pos+=y[0].length),y)}var u=function(w){return f?w.toLowerCase():w};if(u(this.string.substr(this.pos,i.length))==u(i))return!1!==s&&(this.pos+=i.length),!0},Ft.prototype.current=function(){return this.string.slice(this.start,this.pos)},Ft.prototype.hideFirstChars=function(i,s){this.lineStart+=i;try{return s()}finally{this.lineStart-=i}},Ft.prototype.lookAhead=function(i){var s=this.lineOracle;return s&&s.lookAhead(i)},Ft.prototype.baseToken=function(){var i=this.lineOracle;return i&&i.baseToken(this.pos)};var Qi=function(i,s){this.state=i,this.lookAhead=s},Xt=function(i,s,f,u){this.state=s,this.doc=i,this.line=f,this.maxLookAhead=u||0,this.baseTokens=null,this.baseTokenPos=1};function Ji(i,s,f,u){var h=[i.state.modeGen],y={};Ki(i,s.text,i.doc.mode,f,function(F,J){return h.push(F,J)},y,u);for(var w=f.state,E=function(F){f.baseTokens=h;var J=i.state.overlays[F],ie=1,_e=0;f.state=!0,Ki(i,s.text,J.mode,f,function(be,Te){for(var Ge=ie;_e<be;){var an=h[ie];an>be&&h.splice(ie,1,be,h[ie+1],an),ie+=2,_e=Math.min(be,an)}if(Te)if(J.opaque)h.splice(Ge,ie-Ge,be,"overlay "+Te),ie=Ge+2;else for(;Ge<ie;Ge+=2){var pn=h[Ge+1];h[Ge+1]=(pn?pn+" ":"")+"overlay "+Te}},y),f.state=w,f.baseTokens=null,f.baseTokenPos=1},I=0;I<i.state.overlays.length;++I)E(I);return{styles:h,classes:y.bgClass||y.textClass?y:null}}function B1(i,s,f){if(!s.styles||s.styles[0]!=i.state.modeGen){var u=o1(i,Ze(s)),h=s.text.length>i.options.maxHighlightLength&&P1(i.doc.mode,u.state),y=Ji(i,s,u);h&&(u.state=h),s.stateAfter=u.save(!h),s.styles=y.styles,y.classes?s.styleClasses=y.classes:s.styleClasses&&(s.styleClasses=null),f===i.doc.highlightFrontier&&(i.doc.modeFrontier=Math.max(i.doc.modeFrontier,++i.doc.highlightFrontier))}return s.styles}function o1(i,s,f){var u=i.doc,h=i.display;if(!u.mode.startState)return new Xt(u,!0,s);var y=function X1(i,s,f){for(var u,h,y=i.doc,w=f?-1:s-(i.doc.mode.innerMode?1e3:100),E=s;E>w;--E){if(E<=y.first)return y.first;var I=mn(y,E-1),F=I.stateAfter;if(F&&(!f||E+(F instanceof Qi?F.lookAhead:0)<=y.modeFrontier))return E;var J=Ln(I.text,null,i.options.tabSize);(null==h||u>J)&&(h=E-1,u=J)}return h}(i,s,f),w=y>u.first&&mn(u,y-1).stateAfter,E=w?Xt.fromSaved(u,w,y):new Xt(u,Ei(u.mode),y);return u.iter(y,s,function(I){Ht(i,I.text,E);var F=E.line;I.stateAfter=F==s-1||F%5==0||F>=h.viewFrom&&F<h.viewTo?E.save():null,E.nextLine()}),f&&(u.modeFrontier=E.line),E}function Ht(i,s,f,u){var h=i.doc.mode,y=new Ft(s,i.options.tabSize,f);for(y.start=y.pos=u||0,""==s&&Ar(h,f.state);!y.eol();)qa(h,y,f.state),y.start=y.pos}function Ar(i,s){if(i.blankLine)return i.blankLine(s);if(i.innerMode){var f=M1(i,s);if(f.mode.blankLine)return f.mode.blankLine(f.state)}}function qa(i,s,f,u){for(var h=0;h<10;h++){u&&(u[0]=M1(i,f).mode);var y=i.token(s,f);if(s.pos>s.start)return y}throw new Error("Mode "+i.name+" failed to advance stream.")}Xt.prototype.lookAhead=function(i){var s=this.doc.getLine(this.line+i);return null!=s&&i>this.maxLookAhead&&(this.maxLookAhead=i),s},Xt.prototype.baseToken=function(i){if(!this.baseTokens)return null;for(;this.baseTokens[this.baseTokenPos]<=i;)this.baseTokenPos+=2;var s=this.baseTokens[this.baseTokenPos+1];return{type:s&&s.replace(/( |^)overlay .*/,""),size:this.baseTokens[this.baseTokenPos]-i}},Xt.prototype.nextLine=function(){this.line++,this.maxLookAhead>0&&this.maxLookAhead--},Xt.fromSaved=function(i,s,f){return s instanceof Qi?new Xt(i,P1(i.mode,s.state),f,s.lookAhead):new Xt(i,P1(i.mode,s),f)},Xt.prototype.save=function(i){var s=!1!==i?P1(this.doc.mode,this.state):this.state;return this.maxLookAhead>0?new Qi(s,this.maxLookAhead):s};var u1=function(i,s,f){this.start=i.start,this.end=i.pos,this.string=i.current(),this.type=s||null,this.state=f};function I1(i,s,f,u){var w,J,h=i.doc,y=h.mode,E=mn(h,(s=Pn(h,s)).line),I=o1(i,s.line,f),F=new Ft(E.text,i.options.tabSize,I);for(u&&(J=[]);(u||F.pos<s.ch)&&!F.eol();)F.start=F.pos,w=qa(y,F,I.state),u&&J.push(new u1(F,w,P1(h.mode,I.state)));return u?J:new u1(F,w,I.state)}function Da(i,s){if(i)for(;;){var f=i.match(/(?:^|\s+)line-(background-)?(\S+)/);if(!f)break;i=i.slice(0,f.index)+i.slice(f.index+f[0].length);var u=f[1]?"bgClass":"textClass";null==s[u]?s[u]=f[2]:new RegExp("(?:^|\\s)"+f[2]+"(?:$|\\s)").test(s[u])||(s[u]+=" "+f[2])}return i}function Ki(i,s,f,u,h,y,w){var E=f.flattenSpans;null==E&&(E=i.options.flattenSpans);var ie,I=0,F=null,J=new Ft(s,i.options.tabSize,u),_e=i.options.addModeClass&&[null];for(""==s&&Da(Ar(f,u.state),y);!J.eol();){if(J.pos>i.options.maxHighlightLength?(E=!1,w&&Ht(i,s,u,J.pos),J.pos=s.length,ie=null):ie=Da(qa(f,J,u.state,_e),y),_e){var be=_e[0].name;be&&(ie="m-"+(ie?be+" "+ie:be))}if(!E||F!=ie){for(;I<J.start;)h(I=Math.min(J.start,I+5e3),F);F=ie}J.start=J.pos}for(;I<J.pos;){var Te=Math.min(J.pos,I+5e3);h(Te,F),I=Te}}var Ea=!1,hi=!1;function ga(i,s,f){this.marker=i,this.from=s,this.to=f}function Aa(i,s){if(i)for(var f=0;f<i.length;++f){var u=i[f];if(u.marker==s)return u}}function Lr(i,s){for(var f,u=0;u<i.length;++u)i[u]!=s&&(f||(f=[])).push(i[u]);return f}function va(i,s){if(s.full)return null;var f=yt(i,s.from.line)&&mn(i,s.from.line).markedSpans,u=yt(i,s.to.line)&&mn(i,s.to.line).markedSpans;if(!f&&!u)return null;var h=s.from.ch,y=s.to.ch,w=0==wn(s.from,s.to),E=function Oi(i,s,f){var u;if(i)for(var h=0;h<i.length;++h){var y=i[h],w=y.marker;null!=y.from&&!(w.inclusiveLeft?y.from<=s:y.from<s)&&(y.from!=s||"bookmark"!=w.type||f&&y.marker.insertLeft)||(u||(u=[])).push(new ga(w,y.from,null==y.to||(w.inclusiveRight?y.to>=s:y.to>s)?null:y.to))}return u}(f,h,w),I=function ea(i,s,f){var u;if(i)for(var h=0;h<i.length;++h){var y=i[h],w=y.marker;(null==y.to||(w.inclusiveRight?y.to>=s:y.to>s)||y.from==s&&"bookmark"==w.type&&(!f||y.marker.insertLeft))&&(u||(u=[])).push(new ga(w,null==y.from||(w.inclusiveLeft?y.from<=s:y.from<s)?null:y.from-s,null==y.to?null:y.to-s))}return u}(u,y,w),F=1==s.text.length,J=qn(s.text).length+(F?h:0);if(E)for(var ie=0;ie<E.length;++ie){var _e=E[ie];if(null==_e.to){var be=Aa(I,_e.marker);be?F&&(_e.to=null==be.to?null:be.to+J):_e.to=h}}if(I)for(var Te=0;Te<I.length;++Te){var Ge=I[Te];null!=Ge.to&&(Ge.to+=J),null==Ge.from?Aa(E,Ge.marker)||(Ge.from=J,F&&(E||(E=[])).push(Ge)):(Ge.from+=J,F&&(E||(E=[])).push(Ge))}E&&(E=La(E)),I&&I!=E&&(I=La(I));var pn=[E];if(!F){var gn,Cn=s.text.length-2;if(Cn>0&&E)for(var Nn=0;Nn<E.length;++Nn)null==E[Nn].to&&(gn||(gn=[])).push(new ga(E[Nn].marker,null,null));for(var Wn=0;Wn<Cn;++Wn)pn.push(gn);pn.push(I)}return pn}function La(i){for(var s=0;s<i.length;++s){var f=i[s];null!=f.from&&f.from==f.to&&!1!==f.marker.clearWhenEmpty&&i.splice(s--,1)}return i.length?i:null}function Ua(i){var s=i.markedSpans;if(s){for(var f=0;f<s.length;++f)s[f].marker.detachLine(i);i.markedSpans=null}}function mr(i,s){if(s){for(var f=0;f<s.length;++f)s[f].marker.attachLine(i);i.markedSpans=s}}function Tr(i){return i.inclusiveLeft?-1:0}function rr(i){return i.inclusiveRight?1:0}function hr(i,s){var f=i.lines.length-s.lines.length;if(0!=f)return f;var u=i.find(),h=s.find(),y=wn(u.from,h.from)||Tr(i)-Tr(s);return y?-y:wn(u.to,h.to)||rr(i)-rr(s)||s.id-i.id}function Ga(i,s){var u,f=hi&&i.markedSpans;if(f)for(var h=void 0,y=0;y<f.length;++y)(h=f[y]).marker.collapsed&&null==(s?h.from:h.to)&&(!u||hr(u,h.marker)<0)&&(u=h.marker);return u}function Vi(i){return Ga(i,!0)}function na(i){return Ga(i,!1)}function Ta(i,s){var u,f=hi&&i.markedSpans;if(f)for(var h=0;h<f.length;++h){var y=f[h];y.marker.collapsed&&(null==y.from||y.from<s)&&(null==y.to||y.to>s)&&(!u||hr(u,y.marker)<0)&&(u=y.marker)}return u}function m2(i,s,f,u,h){var y=mn(i,s),w=hi&&y.markedSpans;if(w)for(var E=0;E<w.length;++E){var I=w[E];if(I.marker.collapsed){var F=I.marker.find(0),J=wn(F.from,f)||Tr(I.marker)-Tr(h),ie=wn(F.to,u)||rr(I.marker)-rr(h);if(!(J>=0&&ie<=0||J<=0&&ie>=0)&&(J<=0&&(I.marker.inclusiveRight&&h.inclusiveLeft?wn(F.to,f)>=0:wn(F.to,f)>0)||J>=0&&(I.marker.inclusiveRight&&h.inclusiveLeft?wn(F.from,u)<=0:wn(F.from,u)<0)))return!0}}}function w1(i){for(var s;s=Vi(i);)i=s.find(-1,!0).line;return i}function Ti(i,s){var f=mn(i,s),u=w1(f);return f==u?s:Ze(u)}function Kr(i,s){if(s>i.lastLine())return s;var u,f=mn(i,s);if(!ji(i,f))return s;for(;u=na(f);)f=u.find(1,!0).line;return Ze(f)+1}function ji(i,s){var f=hi&&s.markedSpans;if(f)for(var u=void 0,h=0;h<f.length;++h)if((u=f[h]).marker.collapsed){if(null==u.from)return!0;if(!u.marker.widgetNode&&0==u.from&&u.marker.inclusiveLeft&&ai(i,s,u))return!0}}function ai(i,s,f){if(null==f.to){var u=f.marker.find(1,!0);return ai(i,u.line,Aa(u.line.markedSpans,f.marker))}if(f.marker.inclusiveRight&&f.to==s.text.length)return!0;for(var h=void 0,y=0;y<s.markedSpans.length;++y)if((h=s.markedSpans[y]).marker.collapsed&&!h.marker.widgetNode&&h.from==f.to&&(null==h.to||h.to!=f.from)&&(h.marker.inclusiveLeft||f.marker.inclusiveRight)&&ai(i,s,h))return!0}function Hi(i){for(var s=0,f=(i=w1(i)).parent,u=0;u<f.lines.length;++u){var h=f.lines[u];if(h==i)break;s+=h.height}for(var y=f.parent;y;y=(f=y).parent)for(var w=0;w<y.children.length;++w){var E=y.children[w];if(E==f)break;s+=E.height}return s}function O1(i){if(0==i.height)return 0;for(var f,s=i.text.length,u=i;f=Vi(u);){var h=f.find(0,!0);u=h.from.line,s+=h.from.ch-h.to.ch}for(u=i;f=na(u);){var y=f.find(0,!0);s-=u.text.length-y.from.ch,s+=(u=y.to.line).text.length-y.to.ch}return s}function Wa(i){var s=i.display,f=i.doc;s.maxLine=mn(f,f.first),s.maxLineLength=O1(s.maxLine),s.maxLineChanged=!0,f.iter(function(u){var h=O1(u);h>s.maxLineLength&&(s.maxLineLength=h,s.maxLine=u)})}var ka=function(i,s,f){this.text=i,mr(this,s),this.height=f?f(this):1};function Za(i){i.parent=null,Ua(i)}ka.prototype.lineNo=function(){return Ze(this)},Mt(ka);var ba={},Pa={};function jr(i,s){if(!i||/^\s*$/.test(i))return null;var f=s.addModeClass?Pa:ba;return f[i]||(f[i]=i.replace(/\S+/g,"cm-$&"))}function ya(i,s){var f=Yn("span",null,null,oe?"padding-right: .1px":null),u={pre:Yn("pre",[f],"CodeMirror-line"),content:f,col:0,pos:0,cm:i,trailingSpace:!1,splitSpaces:i.getOption("lineWrapping")};s.measure={};for(var h=0;h<=(s.rest?s.rest.length:0);h++){var y=h?s.rest[h-1]:s.line,w=void 0;u.pos=0,u.addToken=U,za(i.display.measure)&&(w=sn(y,i.doc.direction))&&(u.addToken=X(u.addToken,w)),u.map=[],ke(y,u,B1(i,y,s!=i.display.externalMeasured&&Ze(y))),y.styleClasses&&(y.styleClasses.bgClass&&(u.bgClass=ge(y.styleClasses.bgClass,u.bgClass||"")),y.styleClasses.textClass&&(u.textClass=ge(y.styleClasses.textClass,u.textClass||""))),0==u.map.length&&u.map.push(0,0,u.content.appendChild(r1(i.display.measure))),0==h?(s.measure.map=u.map,s.measure.cache={}):((s.measure.maps||(s.measure.maps=[])).push(u.map),(s.measure.caches||(s.measure.caches=[])).push({}))}if(oe){var I=u.content.lastChild;(/\bcm-tab\b/.test(I.className)||I.querySelector&&I.querySelector(".cm-tab"))&&(u.content.className="cm-tab-wrap-hack")}return ht(i,"renderLine",i,s.line,u.pre),u.pre.className&&(u.textClass=ge(u.pre.className,u.textClass||"")),u}function j(i){var s=tn("span","\u2022","cm-invalidchar");return s.title="\\u"+i.charCodeAt(0).toString(16),s.setAttribute("aria-label",s.title),s}function U(i,s,f,u,h,y,w){if(s){var J,E=i.splitSpaces?function k(i,s){if(i.length>1&&!/  /.test(i))return i;for(var f=s,u="",h=0;h<i.length;h++){var y=i.charAt(h);" "==y&&f&&(h==i.length-1||32==i.charCodeAt(h+1))&&(y="\xa0"),u+=y,f=" "==y}return u}(s,i.trailingSpace):s,I=i.cm.state.specialChars,F=!1;if(I.test(s)){J=document.createDocumentFragment();for(var ie=0;;){I.lastIndex=ie;var _e=I.exec(s),be=_e?_e.index-ie:s.length-ie;if(be){var Te=document.createTextNode(E.slice(ie,ie+be));J.appendChild(ye&&he<9?tn("span",[Te]):Te),i.map.push(i.pos,i.pos+be,Te),i.col+=be,i.pos+=be}if(!_e)break;ie+=be+1;var Ge=void 0;if("\t"==_e[0]){var an=i.cm.options.tabSize,pn=an-i.col%an;(Ge=J.appendChild(tn("span",y1(pn),"cm-tab"))).setAttribute("role","presentation"),Ge.setAttribute("cm-text","\t"),i.col+=pn}else"\r"==_e[0]||"\n"==_e[0]?((Ge=J.appendChild(tn("span","\r"==_e[0]?"\u240d":"\u2424","cm-invalidchar"))).setAttribute("cm-text",_e[0]),i.col+=1):((Ge=i.cm.options.specialCharPlaceholder(_e[0])).setAttribute("cm-text",_e[0]),J.appendChild(ye&&he<9?tn("span",[Ge]):Ge),i.col+=1);i.map.push(i.pos,i.pos+1,Ge),i.pos++}}else i.col+=s.length,J=document.createTextNode(E),i.map.push(i.pos,i.pos+s.length,J),ye&&he<9&&(F=!0),i.pos+=s.length;if(i.trailingSpace=32==E.charCodeAt(s.length-1),f||u||h||F||y||w){var Cn=f||"";u&&(Cn+=u),h&&(Cn+=h);var gn=tn("span",[J],Cn,y);if(w)for(var Nn in w)w.hasOwnProperty(Nn)&&"style"!=Nn&&"class"!=Nn&&gn.setAttribute(Nn,w[Nn]);return i.content.appendChild(gn)}i.content.appendChild(J)}}function X(i,s){return function(f,u,h,y,w,E,I){h=h?h+" cm-force-border":"cm-force-border";for(var F=f.pos,J=F+u.length;;){for(var ie=void 0,_e=0;_e<s.length&&!((ie=s[_e]).to>F&&ie.from<=F);_e++);if(ie.to>=J)return i(f,u,h,y,w,E,I);i(f,u.slice(0,ie.to-F),h,y,null,E,I),y=null,u=u.slice(ie.to-F),F=ie.to}}}function re(i,s,f,u){var h=!u&&f.widgetNode;h&&i.map.push(i.pos,i.pos+s,h),!u&&i.cm.display.input.needsContentAttribute&&(h||(h=i.content.appendChild(document.createElement("span"))),h.setAttribute("cm-marker",f.id)),h&&(i.cm.display.input.setUneditable(h),i.content.appendChild(h)),i.pos+=s,i.trailingSpace=!1}function ke(i,s,f){var u=i.markedSpans,h=i.text,y=0;if(u)for(var ie,_e,Te,Ge,an,pn,Cn,E=h.length,I=0,F=1,J="",be=0;;){if(be==I){Te=Ge=an=_e="",Cn=null,pn=null,be=1/0;for(var gn=[],Nn=void 0,Wn=0;Wn<u.length;++Wn){var Bn=u[Wn],Et=Bn.marker;if("bookmark"==Et.type&&Bn.from==I&&Et.widgetNode)gn.push(Et);else if(Bn.from<=I&&(null==Bn.to||Bn.to>I||Et.collapsed&&Bn.to==I&&Bn.from==I)){if(null!=Bn.to&&Bn.to!=I&&be>Bn.to&&(be=Bn.to,Ge=""),Et.className&&(Te+=" "+Et.className),Et.css&&(_e=(_e?_e+";":"")+Et.css),Et.startStyle&&Bn.from==I&&(an+=" "+Et.startStyle),Et.endStyle&&Bn.to==be&&(Nn||(Nn=[])).push(Et.endStyle,Bn.to),Et.title&&((Cn||(Cn={})).title=Et.title),Et.attributes)for(var t1 in Et.attributes)(Cn||(Cn={}))[t1]=Et.attributes[t1];Et.collapsed&&(!pn||hr(pn.marker,Et)<0)&&(pn=Bn)}else Bn.from>I&&be>Bn.from&&(be=Bn.from)}if(Nn)for(var ci=0;ci<Nn.length;ci+=2)Nn[ci+1]==be&&(Ge+=" "+Nn[ci]);if(!pn||pn.from==I)for(var F1=0;F1<gn.length;++F1)re(s,0,gn[F1]);if(pn&&(pn.from||0)==I){if(re(s,(null==pn.to?E+1:pn.to)-I,pn.marker,null==pn.from),null==pn.to)return;pn.to==I&&(pn=!1)}}if(I>=E)break;for(var nr=Math.min(E,be);;){if(J){var la=I+J.length;if(!pn){var li=la>nr?J.slice(0,nr-I):J;s.addToken(s,li,ie?ie+Te:Te,an,I+li.length==be?Ge:"",_e,Cn)}if(la>=nr){J=J.slice(nr-I),I=nr;break}I=la,an=""}J=h.slice(y,y=f[F++]),ie=jr(f[F++],s.cm.options)}}else for(var w=1;w<f.length;w+=2)s.addToken(s,h.slice(y,y=f[w]),jr(f[w+1],s.cm.options))}function Je(i,s,f){this.line=s,this.rest=function ja(i){for(var s,f;s=na(i);)i=s.find(1,!0).line,(f||(f=[])).push(i);return f}(s),this.size=this.rest?Ze(qn(this.rest))-f+1:1,this.node=this.text=null,this.hidden=ji(i,s)}function nn(i,s,f){for(var h,u=[],y=s;y<f;y=h){var w=new Je(i.doc,mn(i.doc,y),y);h=y+w.size,u.push(w)}return u}var Pt=null;var c1=null;function Jn(i,s){var f=Nt(i,s);if(f.length){var h,u=Array.prototype.slice.call(arguments,2);Pt?h=Pt.delayedCallbacks:c1?h=c1:(h=c1=[],setTimeout(h1,0));for(var y=function(E){h.push(function(){return f[E].apply(null,u)})},w=0;w<f.length;++w)y(w)}}function h1(){var i=c1;c1=null;for(var s=0;s<i.length;++s)i[s]()}function V1(i,s,f,u){for(var h=0;h<s.changes.length;h++){var y=s.changes[h];"text"==y?D(i,s):"gutter"==y?je(i,s,f,u):"class"==y?W(i,s):"widget"==y&&$e(i,s,u)}s.changes=null}function H1(i){return i.node==i.text&&(i.node=tn("div",null,null,"position: relative"),i.text.parentNode&&i.text.parentNode.replaceChild(i.node,i.text),i.node.appendChild(i.text),ye&&he<8&&(i.node.style.zIndex=2)),i.node}function L(i,s){var f=i.display.externalMeasured;return f&&f.line==s.line?(i.display.externalMeasured=null,s.measure=f.measure,f.built):ya(i,s)}function D(i,s){var f=s.text.className,u=L(i,s);s.text==s.node&&(s.node=u.pre),s.text.parentNode.replaceChild(u.pre,s.text),s.text=u.pre,u.bgClass!=s.bgClass||u.textClass!=s.textClass?(s.bgClass=u.bgClass,s.textClass=u.textClass,W(i,s)):f&&(s.text.className=f)}function W(i,s){(function P(i,s){var f=s.bgClass?s.bgClass+" "+(s.line.bgClass||""):s.line.bgClass;if(f&&(f+=" CodeMirror-linebackground"),s.background)f?s.background.className=f:(s.background.parentNode.removeChild(s.background),s.background=null);else if(f){var u=H1(s);s.background=u.insertBefore(tn("div",null,f),u.firstChild),i.display.input.setUneditable(s.background)}})(i,s),s.line.wrapClass?H1(s).className=s.line.wrapClass:s.node!=s.text&&(s.node.className=""),s.text.className=(s.textClass?s.textClass+" "+(s.line.textClass||""):s.line.textClass)||""}function je(i,s,f,u){if(s.gutter&&(s.node.removeChild(s.gutter),s.gutter=null),s.gutterBackground&&(s.node.removeChild(s.gutterBackground),s.gutterBackground=null),s.line.gutterClass){var h=H1(s);s.gutterBackground=tn("div",null,"CodeMirror-gutter-background "+s.line.gutterClass,"left: "+(i.options.fixedGutter?u.fixedPos:-u.gutterTotalWidth)+"px; width: "+u.gutterTotalWidth+"px"),i.display.input.setUneditable(s.gutterBackground),h.insertBefore(s.gutterBackground,s.text)}var y=s.line.gutterMarkers;if(i.options.lineNumbers||y){var w=H1(s),E=s.gutter=tn("div",null,"CodeMirror-gutter-wrapper","left: "+(i.options.fixedGutter?u.fixedPos:-u.gutterTotalWidth)+"px");if(E.setAttribute("aria-hidden","true"),i.display.input.setUneditable(E),w.insertBefore(E,s.text),s.line.gutterClass&&(E.className+=" "+s.line.gutterClass),i.options.lineNumbers&&(!y||!y["CodeMirror-linenumbers"])&&(s.lineNumber=E.appendChild(tn("div",v1(i.options,f),"CodeMirror-linenumber CodeMirror-gutter-elt","left: "+u.gutterLeft["CodeMirror-linenumbers"]+"px; width: "+i.display.lineNumInnerWidth+"px"))),y)for(var I=0;I<i.display.gutterSpecs.length;++I){var F=i.display.gutterSpecs[I].className,J=y.hasOwnProperty(F)&&y[F];J&&E.appendChild(tn("div",[J],"CodeMirror-gutter-elt","left: "+u.gutterLeft[F]+"px; width: "+u.gutterWidth[F]+"px"))}}}function $e(i,s,f){s.alignable&&(s.alignable=null);for(var u=fn("CodeMirror-linewidget"),h=s.node.firstChild,y=void 0;h;h=y)y=h.nextSibling,u.test(h.className)&&s.node.removeChild(h);ri(i,s,f)}function A1(i,s,f,u){var h=L(i,s);return s.text=s.node=h.pre,h.bgClass&&(s.bgClass=h.bgClass),h.textClass&&(s.textClass=h.textClass),W(i,s),je(i,s,f,u),ri(i,s,u),s.node}function ri(i,s,f){if(U1(i,s.line,s,f,!0),s.rest)for(var u=0;u<s.rest.length;u++)U1(i,s.rest[u],s,f,!1)}function U1(i,s,f,u,h){if(s.widgets)for(var y=H1(f),w=0,E=s.widgets;w<E.length;++w){var I=E[w],F=tn("div",[I.node],"CodeMirror-linewidget"+(I.className?" "+I.className:""));I.handleMouseEvents||F.setAttribute("cm-ignore-events","true"),Ri(I,F,f,u),i.display.input.setUneditable(F),h&&I.above?y.insertBefore(F,f.gutter||f.text):y.appendChild(F),Jn(I,"redraw")}}function Ri(i,s,f,u){if(i.noHScroll){(f.alignable||(f.alignable=[])).push(s);var h=u.wrapperWidth;s.style.left=u.fixedPos+"px",i.coverGutter||(h-=u.gutterTotalWidth,s.style.paddingLeft=u.gutterTotalWidth+"px"),s.style.width=h+"px"}i.coverGutter&&(s.style.zIndex=5,s.style.position="relative",i.noHScroll||(s.style.marginLeft=-u.gutterTotalWidth+"px"))}function ta(i){if(null!=i.height)return i.height;var s=i.doc.cm;if(!s)return 0;if(!Un(document.body,i.node)){var f="position: relative;";i.coverGutter&&(f+="margin-left: -"+s.display.gutters.offsetWidth+"px;"),i.noHScroll&&(f+="width: "+s.display.wrapper.clientWidth+"px;"),l1(s.display.measure,tn("div",[i.node],null,f))}return i.height=i.node.parentNode.offsetHeight}function ia(i,s){for(var f=ma(s);f!=i.wrapper;f=f.parentNode)if(!f||1==f.nodeType&&"true"==f.getAttribute("cm-ignore-events")||f.parentNode==i.sizer&&f!=i.mover)return!0}function kr(i){return i.lineSpace.offsetTop}function Ye(i){return i.mover.offsetHeight-i.lineSpace.offsetHeight}function Ct(i){if(i.cachedPaddingH)return i.cachedPaddingH;var s=l1(i.measure,tn("pre","x","CodeMirror-line-like")),f=window.getComputedStyle?window.getComputedStyle(s):s.currentStyle,u={left:parseInt(f.paddingLeft),right:parseInt(f.paddingRight)};return!isNaN(u.left)&&!isNaN(u.right)&&(i.cachedPaddingH=u),u}function Fi(i){return 50-i.display.nativeBarWidth}function b1(i){return i.display.scroller.clientWidth-Fi(i)-i.display.barWidth}function Pr(i){return i.display.scroller.clientHeight-Fi(i)-i.display.barHeight}function gi(i,s,f){if(i.line==s)return{map:i.measure.map,cache:i.measure.cache};if(i.rest){for(var u=0;u<i.rest.length;u++)if(i.rest[u]==s)return{map:i.measure.maps[u],cache:i.measure.caches[u]};for(var h=0;h<i.rest.length;h++)if(Ze(i.rest[h])>f)return{map:i.measure.maps[h],cache:i.measure.caches[h],before:!0}}}function Y2(i,s,f,u){return _a(i,h2(i,s),f,u)}function Hn(i,s){if(s>=i.display.viewFrom&&s<i.display.viewTo)return i.display.view[t2(i,s)];var f=i.display.externalMeasured;return f&&s>=f.lineN&&s<f.lineN+f.size?f:void 0}function h2(i,s){var f=Ze(s),u=Hn(i,f);u&&!u.text?u=null:u&&u.changes&&(V1(i,u,f,e2(i)),i.curOp.forceUpdate=!0),u||(u=function X2(i,s){var f=Ze(s=w1(s)),u=i.display.externalMeasured=new Je(i.doc,s,f);u.lineN=f;var h=u.built=ya(i,u);return u.text=h.pre,l1(i.display.lineMeasure,h.pre),u}(i,s));var h=gi(u,s,f);return{line:s,view:u,rect:null,map:h.map,cache:h.cache,before:h.before,hasHeights:!1}}function _a(i,s,f,u,h){s.before&&(f=-1);var w,y=f+(u||"");return s.cache.hasOwnProperty(y)?w=s.cache[y]:(s.rect||(s.rect=s.view.text.getBoundingClientRect()),s.hasHeights||(function gr(i,s,f){var u=i.options.lineWrapping,h=u&&b1(i);if(!s.measure.heights||u&&s.measure.width!=h){var y=s.measure.heights=[];if(u){s.measure.width=h;for(var w=s.text.firstChild.getClientRects(),E=0;E<w.length-1;E++){var I=w[E],F=w[E+1];Math.abs(I.bottom-F.bottom)>2&&y.push((I.bottom+F.top)/2-f.top)}}y.push(f.bottom-f.top)}}(i,s.view,s.rect),s.hasHeights=!0),(w=function Y(i,s,f,u){var F,h=O(s.map,f,u),y=h.node,w=h.start,E=h.end,I=h.collapse;if(3==y.nodeType){for(var J=0;J<4;J++){for(;w&&$n(s.line.text.charAt(h.coverStart+w));)--w;for(;h.coverStart+E<h.coverEnd&&$n(s.line.text.charAt(h.coverStart+E));)++E;if((F=ye&&he<9&&0==w&&E==h.coverEnd-h.coverStart?y.parentNode.getBoundingClientRect():Z(tt(y,w,E).getClientRects(),u)).left||F.right||0==w)break;E=w,w-=1,I="right"}ye&&he<11&&(F=function ne(i,s){if(!window.screen||null==screen.logicalXDPI||screen.logicalXDPI==screen.deviceXDPI||!function xe(i){if(null!=ee)return ee;var s=l1(i,tn("span","x")),f=s.getBoundingClientRect(),u=tt(s,0,1).getBoundingClientRect();return ee=Math.abs(f.left-u.left)>1}(i))return s;var f=screen.logicalXDPI/screen.deviceXDPI,u=screen.logicalYDPI/screen.deviceYDPI;return{left:s.left*f,right:s.right*f,top:s.top*u,bottom:s.bottom*u}}(i.display.measure,F))}else{var ie;w>0&&(I=u="right"),F=i.options.lineWrapping&&(ie=y.getClientRects()).length>1?ie["right"==u?ie.length-1:0]:y.getBoundingClientRect()}if(ye&&he<9&&!w&&(!F||!F.left&&!F.right)){var _e=y.parentNode.getClientRects()[0];F=_e?{left:_e.left,right:_e.left+It(i.display),top:_e.top,bottom:_e.bottom}:g2}for(var be=F.top-s.rect.top,Te=F.bottom-s.rect.top,Ge=(be+Te)/2,an=s.view.measure.heights,pn=0;pn<an.length-1&&!(Ge<an[pn]);pn++);var Nn={left:("right"==I?F.right:F.left)-s.rect.left,right:("left"==I?F.left:F.right)-s.rect.left,top:pn?an[pn-1]:0,bottom:an[pn]};return!F.left&&!F.right&&(Nn.bogus=!0),i.options.singleCursorHeightPerLine||(Nn.rtop=be,Nn.rbottom=Te),Nn}(i,s,f,u)).bogus||(s.cache[y]=w)),{left:w.left,right:w.right,top:h?w.rtop:w.top,bottom:h?w.rbottom:w.bottom}}var D1,g2={left:0,right:0,top:0,bottom:0};function O(i,s,f){for(var u,h,y,w,E,I,F=0;F<i.length;F+=3)if(I=i[F+1],s<(E=i[F])?(h=0,y=1,w="left"):s<I?y=1+(h=s-E):(F==i.length-3||s==I&&i[F+3]>s)&&(h=(y=I-E)-1,s>=I&&(w="right")),null!=h){if(u=i[F+2],E==I&&f==(u.insertLeft?"left":"right")&&(w=f),"left"==f&&0==h)for(;F&&i[F-2]==i[F-3]&&i[F-1].insertLeft;)u=i[2+(F-=3)],w="left";if("right"==f&&h==I-E)for(;F<i.length-3&&i[F+3]==i[F+4]&&!i[F+5].insertLeft;)u=i[(F+=3)+2],w="right";break}return{node:u,start:h,end:y,collapse:w,coverStart:E,coverEnd:I}}function Z(i,s){var f=g2;if("left"==s)for(var u=0;u<i.length&&(f=i[u]).left==f.right;u++);else for(var h=i.length-1;h>=0&&(f=i[h]).left==f.right;h--);return f}function ve(i){if(i.measure&&(i.measure.cache={},i.measure.heights=null,i.rest))for(var s=0;s<i.rest.length;s++)i.measure.caches[s]={}}function Pe(i){i.display.externalMeasure=null,mt(i.display.lineMeasure);for(var s=0;s<i.display.view.length;s++)ve(i.display.view[s])}function Fe(i){Pe(i),i.display.cachedCharWidth=i.display.cachedTextHeight=i.display.cachedPaddingH=null,i.options.lineWrapping||(i.display.maxLineChanged=!0),i.display.lineNumChars=null}function Be(){return fe&&rn?-(document.body.getBoundingClientRect().left-parseInt(getComputedStyle(document.body).marginLeft)):window.pageXOffset||(document.documentElement||document.body).scrollLeft}function An(){return fe&&rn?-(document.body.getBoundingClientRect().top-parseInt(getComputedStyle(document.body).marginTop)):window.pageYOffset||(document.documentElement||document.body).scrollTop}function dt(i){var f=w1(i).widgets,u=0;if(f)for(var h=0;h<f.length;++h)f[h].above&&(u+=ta(f[h]));return u}function ft(i,s,f,u,h){if(!h){var y=dt(s);f.top+=y,f.bottom+=y}if("line"==u)return f;u||(u="local");var w=Hi(s);if("local"==u?w+=kr(i.display):w-=i.display.viewOffset,"page"==u||"window"==u){var E=i.display.lineSpace.getBoundingClientRect();w+=E.top+("window"==u?0:An());var I=E.left+("window"==u?0:Be());f.left+=I,f.right+=I}return f.top+=w,f.bottom+=w,f}function Tt(i,s,f){if("div"==f)return s;var u=s.left,h=s.top;if("page"==f)u-=Be(),h-=An();else if("local"==f||!f){var y=i.display.sizer.getBoundingClientRect();u+=y.left,h+=y.top}var w=i.display.lineSpace.getBoundingClientRect();return{left:u-w.left,top:h-w.top}}function Yt(i,s,f,u,h){return u||(u=mn(i.doc,s.line)),ft(i,u,Y2(i,u,s.ch,h),f)}function z1(i,s,f,u,h,y){function w(Te,Ge){var an=_a(i,h,Te,Ge?"right":"left",y);return Ge?an.left=an.right:an.right=an.left,ft(i,u,an,f)}u=u||mn(i.doc,s.line),h||(h=h2(i,u));var E=sn(u,i.doc.direction),I=s.ch,F=s.sticky;if(I>=u.text.length?(I=u.text.length,F="before"):I<=0&&(I=0,F="after"),!E)return w("before"==F?I-1:I,"before"==F);function J(Te,Ge,an){return w(an?Te-1:Te,1==E[Ge].level!=an)}var ie=on(E,I,F),_e=_n,be=J(I,ie,"before"==F);return null!=_e&&(be.other=J(I,_e,"before"!=F)),be}function oi(i,s){var f=0;s=Pn(i.doc,s),i.options.lineWrapping||(f=It(i.display)*s.ch);var u=mn(i.doc,s.line),h=Hi(u)+kr(i.display);return{left:f,right:f,top:h,bottom:h+u.height}}function Y1(i,s,f,u,h){var y=We(i,s,f);return y.xRel=h,u&&(y.outside=u),y}function ni(i,s,f){var u=i.doc;if((f+=i.display.viewOffset)<0)return Y1(u.first,0,null,-1,-1);var h=Gn(u,f),y=u.first+u.size-1;if(h>y)return Y1(u.first+u.size-1,mn(u,y).text.length,null,1,1);s<0&&(s=0);for(var w=mn(u,h);;){var E=aa(i,w,h,s,f),I=Ta(w,E.ch+(E.xRel>0||E.outside>0?1:0));if(!I)return E;var F=I.find(1);if(F.line==h)return F;w=mn(u,h=F.line)}}function N1(i,s,f,u){u-=dt(s);var h=s.text.length,y=Rn(function(w){return _a(i,f,w-1).bottom<=u},h,0);return{begin:y,end:h=Rn(function(w){return _a(i,f,w).top>u},y,h)}}function vi(i,s,f,u){return f||(f=h2(i,s)),N1(i,s,f,ft(i,s,_a(i,f,u),"line").top)}function qi(i,s,f,u){return!(i.bottom<=f)&&(i.top>f||(u?i.left:i.right)>s)}function aa(i,s,f,u,h){h-=Hi(s);var y=h2(i,s),w=dt(s),E=0,I=s.text.length,F=!0,J=sn(s,i.doc.direction);if(J){var ie=(i.options.lineWrapping?R1:Ia)(i,s,f,y,J,u,h);E=(F=1!=ie.level)?ie.from:ie.to-1,I=F?ie.to:ie.from-1}var Ge,an,_e=null,be=null,Te=Rn(function(Wn){var Bn=_a(i,y,Wn);return Bn.top+=w,Bn.bottom+=w,!!qi(Bn,u,h,!1)&&(Bn.top<=h&&Bn.left<=u&&(_e=Wn,be=Bn),!0)},E,I),pn=!1;if(be){var Cn=u-be.left<be.right-u,gn=Cn==F;Te=_e+(gn?0:1),an=gn?"after":"before",Ge=Cn?be.left:be.right}else{!F&&(Te==I||Te==E)&&Te++,an=0==Te?"after":Te==s.text.length?"before":_a(i,y,Te-(F?1:0)).bottom+w<=h==F?"after":"before";var Nn=z1(i,We(f,Te,an),"line",s,y);Ge=Nn.left,pn=h<Nn.top?-1:h>=Nn.bottom?1:0}return Y1(f,Te=wi(s.text,Te,1),an,pn,u-Ge)}function Ia(i,s,f,u,h,y,w){var E=Rn(function(ie){var _e=h[ie],be=1!=_e.level;return qi(z1(i,We(f,be?_e.to:_e.from,be?"before":"after"),"line",s,u),y,w,!0)},0,h.length-1),I=h[E];if(E>0){var F=1!=I.level,J=z1(i,We(f,F?I.from:I.to,F?"after":"before"),"line",s,u);qi(J,y,w,!0)&&J.top>w&&(I=h[E-1])}return I}function R1(i,s,f,u,h,y,w){var E=N1(i,s,u,w),I=E.begin,F=E.end;/\s/.test(s.text.charAt(F-1))&&F--;for(var J=null,ie=null,_e=0;_e<h.length;_e++){var be=h[_e];if(!(be.from>=F||be.to<=I)){var Ge=_a(i,u,1!=be.level?Math.min(F,be.to)-1:Math.max(I,be.from)).right,an=Ge<y?y-Ge+1e9:Ge-y;(!J||ie>an)&&(J=be,ie=an)}}return J||(J=h[h.length-1]),J.from<I&&(J={from:I,to:J.to,level:J.level}),J.to>F&&(J={from:J.from,to:F,level:J.level}),J}function bi(i){if(null!=i.cachedTextHeight)return i.cachedTextHeight;if(null==D1){D1=tn("pre",null,"CodeMirror-line-like");for(var s=0;s<49;++s)D1.appendChild(document.createTextNode("x")),D1.appendChild(tn("br"));D1.appendChild(document.createTextNode("x"))}l1(i.measure,D1);var f=D1.offsetHeight/50;return f>3&&(i.cachedTextHeight=f),mt(i.measure),f||1}function It(i){if(null!=i.cachedCharWidth)return i.cachedCharWidth;var s=tn("span","xxxxxxxxxx"),f=tn("pre",[s],"CodeMirror-line-like");l1(i.measure,f);var u=s.getBoundingClientRect(),h=(u.right-u.left)/10;return h>2&&(i.cachedCharWidth=h),h||10}function e2(i){for(var s=i.display,f={},u={},h=s.gutters.clientLeft,y=s.gutters.firstChild,w=0;y;y=y.nextSibling,++w){var E=i.display.gutterSpecs[w].className;f[E]=y.offsetLeft+y.clientLeft+h,u[E]=y.clientWidth}return{fixedPos:Yo(s),gutterTotalWidth:s.gutters.offsetWidth,gutterLeft:f,gutterWidth:u,wrapperWidth:s.wrapper.clientWidth}}function Yo(i){return i.scroller.getBoundingClientRect().left-i.sizer.getBoundingClientRect().left}function xo(i){var s=bi(i.display),f=i.options.lineWrapping,u=f&&Math.max(5,i.display.scroller.clientWidth/It(i.display)-3);return function(h){if(ji(i.doc,h))return 0;var y=0;if(h.widgets)for(var w=0;w<h.widgets.length;w++)h.widgets[w].height&&(y+=h.widgets[w].height);return f?y+(Math.ceil(h.text.length/u)||1)*s:y+s}}function Co(i){var s=i.doc,f=xo(i);s.iter(function(u){var h=f(u);h!=u.height&&qt(u,h)})}function n2(i,s,f,u){var h=i.display;if(!f&&"true"==ma(s).getAttribute("cm-not-content"))return null;var y,w,E=h.lineSpace.getBoundingClientRect();try{y=s.clientX-E.left,w=s.clientY-E.top}catch(ie){return null}var F,I=ni(i,y,w);if(u&&I.xRel>0&&(F=mn(i.doc,I.line).text).length==I.ch){var J=Ln(F,F.length,i.options.tabSize)-F.length;I=We(I.line,Math.max(0,Math.round((y-Ct(i.display).left)/It(i.display))-J))}return I}function t2(i,s){if(s>=i.display.viewTo||(s-=i.display.viewFrom)<0)return null;for(var f=i.display.view,u=0;u<f.length;u++)if((s-=f[u].size)<0)return u}function E1(i,s,f,u){null==s&&(s=i.doc.first),null==f&&(f=i.doc.first+i.doc.size),u||(u=0);var h=i.display;if(u&&f<h.viewTo&&(null==h.updateLineNumbers||h.updateLineNumbers>s)&&(h.updateLineNumbers=s),i.curOp.viewChanged=!0,s>=h.viewTo)hi&&Ti(i.doc,s)<h.viewTo&&$a(i);else if(f<=h.viewFrom)hi&&Kr(i.doc,f+u)>h.viewFrom?$a(i):(h.viewFrom+=u,h.viewTo+=u);else if(s<=h.viewFrom&&f>=h.viewTo)$a(i);else if(s<=h.viewFrom){var y=L2(i,f,f+u,1);y?(h.view=h.view.slice(y.index),h.viewFrom=y.lineN,h.viewTo+=u):$a(i)}else if(f>=h.viewTo){var w=L2(i,s,s,-1);w?(h.view=h.view.slice(0,w.index),h.viewTo=w.lineN):$a(i)}else{var E=L2(i,s,s,-1),I=L2(i,f,f+u,1);E&&I?(h.view=h.view.slice(0,E.index).concat(nn(i,E.lineN,I.lineN)).concat(h.view.slice(I.index)),h.viewTo+=u):$a(i)}var F=h.externalMeasured;F&&(f<F.lineN?F.lineN+=u:s<F.lineN+F.size&&(h.externalMeasured=null))}function vr(i,s,f){i.curOp.viewChanged=!0;var u=i.display,h=i.display.externalMeasured;if(h&&s>=h.lineN&&s<h.lineN+h.size&&(u.externalMeasured=null),!(s<u.viewFrom||s>=u.viewTo)){var y=u.view[t2(i,s)];if(null!=y.node){var w=y.changes||(y.changes=[]);-1==Rt(w,f)&&w.push(f)}}}function $a(i){i.display.viewFrom=i.display.viewTo=i.doc.first,i.display.view=[],i.display.viewOffset=0}function L2(i,s,f,u){var y,h=t2(i,s),w=i.display.view;if(!hi||f==i.doc.first+i.doc.size)return{index:h,lineN:f};for(var E=i.display.viewFrom,I=0;I<h;I++)E+=w[I].size;if(E!=s){if(u>0){if(h==w.length-1)return null;y=E+w[h].size-s,h++}else y=E-s;s+=y,f+=y}for(;Ti(i.doc,f)!=f;){if(h==(u<0?0:w.length-1))return null;f+=u*w[h-(u<0?1:0)].size,h+=u}return{index:h,lineN:f}}function Bi(i){for(var s=i.display.view,f=0,u=0;u<s.length;u++){var h=s[u];!h.hidden&&(!h.node||h.changes)&&++f}return f}function Oa(i){i.display.input.showSelection(i.display.input.prepareSelection())}function Ir(i,s){void 0===s&&(s=!0);var f=i.doc,u={},h=u.cursors=document.createDocumentFragment(),y=u.selection=document.createDocumentFragment(),w=i.options.$customCursor;w&&(s=!0);for(var E=0;E<f.sel.ranges.length;E++)if(s||E!=f.sel.primIndex){var I=f.sel.ranges[E];if(!(I.from().line>=i.display.viewTo||I.to().line<i.display.viewFrom)){var F=I.empty();if(w){var J=w(i,I);J&&br(i,J,h)}else(F||i.options.showCursorWhenSelecting)&&br(i,I.head,h);F||Xa(i,I,y)}}return u}function br(i,s,f){var u=z1(i,s,"div",null,null,!i.options.singleCursorHeightPerLine),h=f.appendChild(tn("div","\xa0","CodeMirror-cursor"));if(h.style.left=u.left+"px",h.style.top=u.top+"px",h.style.height=Math.max(0,u.bottom-u.top)*i.options.cursorHeight+"px",/\bcm-fat-cursor\b/.test(i.getWrapperElement().className)){var y=Yt(i,s,"div",null,null),w=y.right-y.left;h.style.width=(w>0?w:i.defaultCharWidth())+"px"}if(u.other){var E=f.appendChild(tn("div","\xa0","CodeMirror-cursor CodeMirror-secondarycursor"));E.style.display="",E.style.left=u.other.left+"px",E.style.top=u.other.top+"px",E.style.height=.85*(u.other.bottom-u.other.top)+"px"}}function C1(i,s){return i.top-s.top||i.left-s.left}function Xa(i,s,f){var u=i.display,h=i.doc,y=document.createDocumentFragment(),w=Ct(i.display),E=w.left,I=Math.max(u.sizerWidth,b1(i)-u.sizer.offsetLeft)-w.right,F="ltr"==h.direction;function J(gn,Nn,Wn,Bn){Nn<0&&(Nn=0),Nn=Math.round(Nn),Bn=Math.round(Bn),y.appendChild(tn("div",null,"CodeMirror-selected","position: absolute; left: "+gn+"px;\n                             top: "+Nn+"px; width: "+(null==Wn?I-gn:Wn)+"px;\n                             height: "+(Bn-Nn)+"px"))}function ie(gn,Nn,Wn){var t1,ci,Bn=mn(h,gn),Et=Bn.text.length;function F1(li,Ha){return Yt(i,We(gn,li),"div",Bn,Ha)}function nr(li,Ha,Wi){var xi=vi(i,Bn,null,li),di="ltr"==Ha==("after"==Wi)?"left":"right";return F1("after"==Wi?xi.begin:xi.end-(/\s/.test(Bn.text.charAt(xi.end-1))?2:1),di)[di]}var la=sn(Bn,h.direction);return function xn(i,s,f,u){if(!i)return u(s,f,"ltr",0);for(var h=!1,y=0;y<i.length;++y){var w=i[y];(w.from<f&&w.to>s||s==f&&w.to==s)&&(u(Math.max(w.from,s),Math.min(w.to,f),1==w.level?"rtl":"ltr",y),h=!0)}h||u(s,f,"ltr")}(la,Nn||0,null==Wn?Et:Wn,function(li,Ha,Wi,xi){var di="ltr"==Wi,Q1=F1(li,di?"left":"right"),Ca=F1(Ha-1,di?"right":"left"),R2=null==Nn&&0==li,$r=null==Wn&&Ha==Et,ki=0==xi,l2=!la||xi==la.length-1;if(Ca.top-Q1.top<=3){var d2=(F?R2:$r)&&ki?E:(di?Q1:Ca).left;J(d2,Q1.top,((F?$r:R2)&&l2?I:(di?Ca:Q1).right)-d2,Q1.bottom)}else{var F2,da,Ro,Fo;di?(F2=F&&R2&&ki?E:Q1.left,da=F?I:nr(li,Wi,"before"),Ro=F?E:nr(Ha,Wi,"after"),Fo=F&&$r&&l2?I:Ca.right):(F2=F?nr(li,Wi,"before"):E,da=!F&&R2&&ki?I:Q1.right,Ro=!F&&$r&&l2?E:Ca.left,Fo=F?nr(Ha,Wi,"after"):I),J(F2,Q1.top,da-F2,Q1.bottom),Q1.bottom<Ca.top&&J(E,Q1.bottom,null,Ca.top),J(Ro,Ca.top,Fo-Ro,Ca.bottom)}(!t1||C1(Q1,t1)<0)&&(t1=Q1),C1(Ca,t1)<0&&(t1=Ca),(!ci||C1(Q1,ci)<0)&&(ci=Q1),C1(Ca,ci)<0&&(ci=Ca)}),{start:t1,end:ci}}var _e=s.from(),be=s.to();if(_e.line==be.line)ie(_e.line,_e.ch,be.ch);else{var Te=mn(h,_e.line),Ge=mn(h,be.line),an=w1(Te)==w1(Ge),pn=ie(_e.line,_e.ch,an?Te.text.length+1:null).end,Cn=ie(be.line,an?0:null,be.ch).start;an&&(pn.top<Cn.top-2?(J(pn.right,pn.top,null,pn.bottom),J(E,Cn.top,Cn.left,Cn.bottom)):J(pn.right,pn.top,Cn.left-pn.right,pn.bottom)),pn.bottom<Cn.top&&J(E,pn.bottom,null,Cn.top)}f.appendChild(y)}function a2(i){if(i.state.focused){var s=i.display;clearInterval(s.blinker);var f=!0;s.cursorDiv.style.visibility="",i.options.cursorBlinkRate>0?s.blinker=setInterval(function(){i.hasFocus()||T2(i),s.cursorDiv.style.visibility=(f=!f)?"":"hidden"},i.options.cursorBlinkRate):i.options.cursorBlinkRate<0&&(s.cursorDiv.style.visibility="hidden")}}function Q2(i){i.hasFocus()||(i.display.input.focus(),i.state.focused||So(i))}function J2(i){i.state.delayingBlurEvent=!0,setTimeout(function(){i.state.delayingBlurEvent&&(i.state.delayingBlurEvent=!1,i.state.focused&&T2(i))},100)}function So(i,s){i.state.delayingBlurEvent&&!i.state.draggingText&&(i.state.delayingBlurEvent=!1),"nocursor"!=i.options.readOnly&&(i.state.focused||(ht(i,"focus",i,s),i.state.focused=!0,De(i.display.wrapper,"CodeMirror-focused"),!i.curOp&&i.display.selForContextMenu!=i.doc.sel&&(i.display.input.reset(),oe&&setTimeout(function(){return i.display.input.reset(!0)},20)),i.display.input.receivedFocus()),a2(i))}function T2(i,s){i.state.delayingBlurEvent||(i.state.focused&&(ht(i,"blur",i,s),i.state.focused=!1,g1(i.display.wrapper,"CodeMirror-focused")),clearInterval(i.display.blinker),setTimeout(function(){i.state.focused||(i.display.shift=!1)},150))}function Or(i){for(var s=i.display,f=s.lineDiv.offsetTop,u=Math.max(0,s.scroller.getBoundingClientRect().top),h=s.lineDiv.getBoundingClientRect().top,y=0,w=0;w<s.view.length;w++){var E=s.view[w],I=i.options.lineWrapping,F=void 0,J=0;if(!E.hidden){if(h+=E.line.height,ye&&he<8){var ie=E.node.offsetTop+E.node.offsetHeight;F=ie-f,f=ie}else{var _e=E.node.getBoundingClientRect();F=_e.bottom-_e.top,!I&&E.text.firstChild&&(J=E.text.firstChild.getBoundingClientRect().right-_e.left-1)}var be=E.line.height-F;if((be>.005||be<-.005)&&(h<u&&(y-=be),qt(E.line,F),j2(E.line),E.rest))for(var Te=0;Te<E.rest.length;Te++)j2(E.rest[Te]);if(J>i.display.sizerWidth){var Ge=Math.ceil(J/It(i.display));Ge>i.display.maxLineLength&&(i.display.maxLineLength=Ge,i.display.maxLine=E.line,i.display.maxLineChanged=!0)}}}Math.abs(y)>2&&(s.scroller.scrollTop+=y)}function j2(i){if(i.widgets)for(var s=0;s<i.widgets.length;++s){var f=i.widgets[s],u=f.node.parentNode;u&&(f.height=u.offsetHeight)}}function K2(i,s,f){var u=f&&null!=f.top?Math.max(0,f.top):i.scroller.scrollTop;u=Math.floor(u-kr(i));var h=f&&null!=f.bottom?f.bottom:u+i.wrapper.clientHeight,y=Gn(s,u),w=Gn(s,h);if(f&&f.ensure){var E=f.ensure.from.line,I=f.ensure.to.line;E<y?(y=E,w=Gn(s,Hi(mn(s,E))+i.wrapper.clientHeight)):Math.min(I,s.lastLine())>=w&&(y=Gn(s,Hi(mn(s,I))-i.wrapper.clientHeight),w=I)}return{from:y,to:Math.max(w,y+1)}}function v2(i,s){var f=i.display,u=bi(i.display);s.top<0&&(s.top=0);var h=i.curOp&&null!=i.curOp.scrollTop?i.curOp.scrollTop:f.scroller.scrollTop,y=Pr(i),w={};s.bottom-s.top>y&&(s.bottom=s.top+y);var E=i.doc.height+Ye(f),F=s.bottom>E-u;if(s.top<h)w.scrollTop=s.top<u?0:s.top;else if(s.bottom>h+y){var J=Math.min(s.top,(F?E:s.bottom)-y);J!=h&&(w.scrollTop=J)}var ie=i.options.fixedGutter?0:f.gutters.offsetWidth,_e=i.curOp&&null!=i.curOp.scrollLeft?i.curOp.scrollLeft:f.scroller.scrollLeft-ie,be=b1(i)-f.gutters.offsetWidth,Te=s.right-s.left>be;return Te&&(s.right=s.left+be),s.left<10?w.scrollLeft=0:s.left<_e?w.scrollLeft=Math.max(0,s.left+ie-(Te?0:10)):s.right>be+_e-3&&(w.scrollLeft=s.right+(Te?0:10)-be),w}function Os(i,s){null!=s&&(Mo(i),i.curOp.scrollTop=(null==i.curOp.scrollTop?i.doc.scrollTop:i.curOp.scrollTop)+s)}function yr(i){Mo(i);var s=i.getCursor();i.curOp.scrollToPos={from:s,to:s,margin:i.options.cursorScrollMargin}}function k2(i,s,f){(null!=s||null!=f)&&Mo(i),null!=s&&(i.curOp.scrollLeft=s),null!=f&&(i.curOp.scrollTop=f)}function Mo(i){var s=i.curOp.scrollToPos;s&&(i.curOp.scrollToPos=null,Ko(i,oi(i,s.from),oi(i,s.to),s.margin))}function Ko(i,s,f,u){var h=v2(i,{left:Math.min(s.left,f.left),top:Math.min(s.top,f.top)-u,right:Math.max(s.right,f.right),bottom:Math.max(s.bottom,f.bottom)+u});k2(i,h.scrollLeft,h.scrollTop)}function b2(i,s){Math.abs(i.doc.scrollTop-s)<2||(M||uc(i,{top:s}),wo(i,s,!0),M&&uc(i),ra(i,100))}function wo(i,s,f){s=Math.max(0,Math.min(i.display.scroller.scrollHeight-i.display.scroller.clientHeight,s)),(i.display.scroller.scrollTop!=s||f)&&(i.doc.scrollTop=s,i.display.scrollbars.setScrollTop(s),i.display.scroller.scrollTop!=s&&(i.display.scroller.scrollTop=s))}function or(i,s,f,u){s=Math.max(0,Math.min(s,i.display.scroller.scrollWidth-i.display.scroller.clientWidth)),(!(f?s==i.doc.scrollLeft:Math.abs(i.doc.scrollLeft-s)<2)||u)&&(i.doc.scrollLeft=s,pc(i),i.display.scroller.scrollLeft!=s&&(i.display.scroller.scrollLeft=s),i.display.scrollbars.setScrollLeft(s))}function _r(i){var s=i.display,f=s.gutters.offsetWidth,u=Math.round(i.doc.height+Ye(i.display));return{clientHeight:s.scroller.clientHeight,viewHeight:s.wrapper.clientHeight,scrollWidth:s.scroller.scrollWidth,clientWidth:s.scroller.clientWidth,viewWidth:s.wrapper.clientWidth,barLeft:i.options.fixedGutter?f:0,docHeight:u,scrollHeight:u+Fi(i)+s.barHeight,nativeBarWidth:s.nativeBarWidth,gutterWidth:f}}var Hr=function(i,s,f){this.cm=f;var u=this.vert=tn("div",[tn("div",null,null,"min-width: 1px")],"CodeMirror-vscrollbar"),h=this.horiz=tn("div",[tn("div",null,null,"height: 100%; min-height: 1px")],"CodeMirror-hscrollbar");u.tabIndex=h.tabIndex=-1,i(u),i(h),jn(u,"scroll",function(){u.clientHeight&&s(u.scrollTop,"vertical")}),jn(h,"scroll",function(){h.clientWidth&&s(h.scrollLeft,"horizontal")}),this.checkedZeroWidth=!1,ye&&he<8&&(this.horiz.style.minHeight=this.vert.style.minWidth="18px")};Hr.prototype.update=function(i){var s=i.scrollWidth>i.clientWidth+1,f=i.scrollHeight>i.clientHeight+1,u=i.nativeBarWidth;return f?(this.vert.style.display="block",this.vert.style.bottom=s?u+"px":"0",this.vert.firstChild.style.height=Math.max(0,i.scrollHeight-i.clientHeight+(i.viewHeight-(s?u:0)))+"px"):(this.vert.scrollTop=0,this.vert.style.display="",this.vert.firstChild.style.height="0"),s?(this.horiz.style.display="block",this.horiz.style.right=f?u+"px":"0",this.horiz.style.left=i.barLeft+"px",this.horiz.firstChild.style.width=Math.max(0,i.scrollWidth-i.clientWidth+(i.viewWidth-i.barLeft-(f?u:0)))+"px"):(this.horiz.style.display="",this.horiz.firstChild.style.width="0"),!this.checkedZeroWidth&&i.clientHeight>0&&(0==u&&this.zeroWidthHack(),this.checkedZeroWidth=!0),{right:f?u:0,bottom:s?u:0}},Hr.prototype.setScrollLeft=function(i){this.horiz.scrollLeft!=i&&(this.horiz.scrollLeft=i),this.disableHoriz&&this.enableZeroWidthBar(this.horiz,this.disableHoriz,"horiz")},Hr.prototype.setScrollTop=function(i){this.vert.scrollTop!=i&&(this.vert.scrollTop=i),this.disableVert&&this.enableZeroWidthBar(this.vert,this.disableVert,"vert")},Hr.prototype.zeroWidthHack=function(){this.horiz.style.height=this.vert.style.width=Qe&&!Me?"12px":"18px",this.horiz.style.pointerEvents=this.vert.style.pointerEvents="none",this.disableHoriz=new lt,this.disableVert=new lt},Hr.prototype.enableZeroWidthBar=function(i,s,f){i.style.pointerEvents="auto",s.set(1e3,function u(){var h=i.getBoundingClientRect();("vert"==f?document.elementFromPoint(h.right-1,(h.top+h.bottom)/2):document.elementFromPoint((h.right+h.left)/2,h.bottom-1))!=i?i.style.pointerEvents="none":s.set(1e3,u)})},Hr.prototype.clear=function(){var i=this.horiz.parentNode;i.removeChild(this.horiz),i.removeChild(this.vert)};var xr=function(){};function Rr(i,s){s||(s=_r(i));var f=i.display.barWidth,u=i.display.barHeight;es(i,s);for(var h=0;h<4&&f!=i.display.barWidth||u!=i.display.barHeight;h++)f!=i.display.barWidth&&i.options.lineWrapping&&Or(i),es(i,_r(i)),f=i.display.barWidth,u=i.display.barHeight}function es(i,s){var f=i.display,u=f.scrollbars.update(s);f.sizer.style.paddingRight=(f.barWidth=u.right)+"px",f.sizer.style.paddingBottom=(f.barHeight=u.bottom)+"px",f.heightForcer.style.borderBottom=u.bottom+"px solid transparent",u.right&&u.bottom?(f.scrollbarFiller.style.display="block",f.scrollbarFiller.style.height=u.bottom+"px",f.scrollbarFiller.style.width=u.right+"px"):f.scrollbarFiller.style.display="",u.bottom&&i.options.coverGutterNextToScrollbar&&i.options.fixedGutter?(f.gutterFiller.style.display="block",f.gutterFiller.style.height=u.bottom+"px",f.gutterFiller.style.width=s.gutterWidth+"px"):f.gutterFiller.style.display=""}xr.prototype.update=function(){return{bottom:0,right:0}},xr.prototype.setScrollLeft=function(){},xr.prototype.setScrollTop=function(){},xr.prototype.clear=function(){};var z={native:Hr,null:xr};function x(i){i.display.scrollbars&&(i.display.scrollbars.clear(),i.display.scrollbars.addClass&&g1(i.display.wrapper,i.display.scrollbars.addClass)),i.display.scrollbars=new z[i.options.scrollbarStyle](function(s){i.display.wrapper.insertBefore(s,i.display.scrollbarFiller),jn(s,"mousedown",function(){i.state.focused&&setTimeout(function(){return i.display.input.focus()},0)}),s.setAttribute("cm-not-content","true")},function(s,f){"horizontal"==f?or(i,s):b2(i,s)},i),i.display.scrollbars.addClass&&De(i.display.wrapper,i.display.scrollbars.addClass)}var _=0;function T(i){i.curOp={cm:i,viewChanged:!1,startHeight:i.doc.height,forceUpdate:!1,updateInput:0,typing:!1,changeObjs:null,cursorActivityHandlers:null,cursorActivityCalled:0,selectionChanged:!1,updateMaxLine:!1,scrollLeft:null,scrollTop:null,scrollToPos:null,focus:!1,id:++_,markArrays:null},function s1(i){Pt?Pt.ops.push(i):i.ownsGroup=Pt={ops:[i],delayedCallbacks:[]}}(i.curOp)}function V(i){var s=i.curOp;s&&function kn(i,s){var f=i.ownsGroup;if(f)try{!function Dt(i){var s=i.delayedCallbacks,f=0;do{for(;f<s.length;f++)s[f].call(null);for(var u=0;u<i.ops.length;u++){var h=i.ops[u];if(h.cursorActivityHandlers)for(;h.cursorActivityCalled<h.cursorActivityHandlers.length;)h.cursorActivityHandlers[h.cursorActivityCalled++].call(null,h.cm)}}while(f<s.length)}(f)}finally{Pt=null,s(f)}}(s,function(f){for(var u=0;u<f.ops.length;u++)f.ops[u].cm.curOp=null;!function G(i){for(var s=i.ops,f=0;f<s.length;f++)te(s[f]);for(var u=0;u<s.length;u++)se(s[u]);for(var h=0;h<s.length;h++)Ie(s[h]);for(var y=0;y<s.length;y++)In(s[y]);for(var w=0;w<s.length;w++)Ot(s[w])}(f)})}function te(i){var s=i.cm,f=s.display;(function sr(i){var s=i.display;!s.scrollbarsClipped&&s.scroller.offsetWidth&&(s.nativeBarWidth=s.scroller.offsetWidth-s.scroller.clientWidth,s.heightForcer.style.height=Fi(i)+"px",s.sizer.style.marginBottom=-s.nativeBarWidth+"px",s.sizer.style.borderRightWidth=Fi(i)+"px",s.scrollbarsClipped=!0)})(s),i.updateMaxLine&&Wa(s),i.mustUpdate=i.viewChanged||i.forceUpdate||null!=i.scrollTop||i.scrollToPos&&(i.scrollToPos.from.line<f.viewFrom||i.scrollToPos.to.line>=f.viewTo)||f.maxLineChanged&&s.options.lineWrapping,i.update=i.mustUpdate&&new oa(s,i.mustUpdate&&{top:i.scrollTop,ensure:i.scrollToPos},i.forceUpdate)}function se(i){i.updatedDisplay=i.mustUpdate&&Fr(i.cm,i.update)}function Ie(i){var s=i.cm,f=s.display;i.updatedDisplay&&Or(s),i.barMeasure=_r(s),f.maxLineChanged&&!s.options.lineWrapping&&(i.adjustWidthTo=Y2(s,f.maxLine,f.maxLine.text.length).left+3,s.display.sizerWidth=i.adjustWidthTo,i.barMeasure.scrollWidth=Math.max(f.scroller.clientWidth,f.sizer.offsetLeft+i.adjustWidthTo+Fi(s)+s.display.barWidth),i.maxScrollLeft=Math.max(0,f.sizer.offsetLeft+i.adjustWidthTo-b1(s))),(i.updatedDisplay||i.selectionChanged)&&(i.preparedSelection=f.input.prepareSelection())}function In(i){var s=i.cm;null!=i.adjustWidthTo&&(s.display.sizer.style.minWidth=i.adjustWidthTo+"px",i.maxScrollLeft<s.doc.scrollLeft&&or(s,Math.min(s.display.scroller.scrollLeft,i.maxScrollLeft),!0),s.display.maxLineChanged=!1);var f=i.focus&&i.focus==Le();i.preparedSelection&&s.display.input.showSelection(i.preparedSelection,f),(i.updatedDisplay||i.startHeight!=s.doc.height)&&Rr(s,i.barMeasure),i.updatedDisplay&&fc(s,i.barMeasure),i.selectionChanged&&a2(s),s.state.focused&&i.updateInput&&s.display.input.reset(i.typing),f&&Q2(i.cm)}function Ot(i){var s=i.cm,f=s.display,u=s.doc;i.updatedDisplay&&eo(s,i.update),null!=f.wheelStartX&&(null!=i.scrollTop||null!=i.scrollLeft||i.scrollToPos)&&(f.wheelStartX=f.wheelStartY=null),null!=i.scrollTop&&wo(s,i.scrollTop,i.forceScroll),null!=i.scrollLeft&&or(s,i.scrollLeft,!0,!0),i.scrollToPos&&function Vr(i,s){if(!Wt(i,"scrollCursorIntoView")){var f=i.display,u=f.sizer.getBoundingClientRect(),h=null;if(s.top+u.top<0?h=!0:s.bottom+u.top>(window.innerHeight||document.documentElement.clientHeight)&&(h=!1),null!=h&&!Ae){var y=tn("div","\u200b",null,"position: absolute;\n                         top: "+(s.top-f.viewOffset-kr(i.display))+"px;\n                         height: "+(s.bottom-s.top+Fi(i)+f.barHeight)+"px;\n                         left: "+s.left+"px; width: "+Math.max(2,s.right-s.left)+"px;");i.display.lineSpace.appendChild(y),y.scrollIntoView(h),i.display.lineSpace.removeChild(y)}}}(s,function Is(i,s,f,u){var h;null==u&&(u=0),!i.options.lineWrapping&&s==f&&(f="before"==s.sticky?We(s.line,s.ch+1,"before"):s,s=s.ch?We(s.line,"before"==s.sticky?s.ch-1:s.ch,"after"):s);for(var y=0;y<5;y++){var w=!1,E=z1(i,s),I=f&&f!=s?z1(i,f):E,F=v2(i,h={left:Math.min(E.left,I.left),top:Math.min(E.top,I.top)-u,right:Math.max(E.left,I.left),bottom:Math.max(E.bottom,I.bottom)+u}),J=i.doc.scrollTop,ie=i.doc.scrollLeft;if(null!=F.scrollTop&&(b2(i,F.scrollTop),Math.abs(i.doc.scrollTop-J)>1&&(w=!0)),null!=F.scrollLeft&&(or(i,F.scrollLeft),Math.abs(i.doc.scrollLeft-ie)>1&&(w=!0)),!w)break}return h}(s,Pn(u,i.scrollToPos.from),Pn(u,i.scrollToPos.to),i.scrollToPos.margin));var y=i.maybeHiddenMarkers,w=i.maybeUnhiddenMarkers;if(y)for(var E=0;E<y.length;++E)y[E].lines.length||ht(y[E],"hide");if(w)for(var I=0;I<w.length;++I)w[I].lines.length&&ht(w[I],"unhide");f.wrapper.offsetHeight&&(u.scrollTop=s.display.scroller.scrollTop),i.changeObjs&&ht(s,"changes",s,i.changeObjs),i.update&&i.update.finish()}function un(i,s){if(i.curOp)return s();T(i);try{return s()}finally{V(i)}}function Kn(i,s){return function(){if(i.curOp)return s.apply(i,arguments);T(i);try{return s.apply(i,arguments)}finally{V(i)}}}function _t(i){return function(){if(this.curOp)return i.apply(this,arguments);T(this);try{return i.apply(this,arguments)}finally{V(this)}}}function S1(i){return function(){var s=this.cm;if(!s||s.curOp)return i.apply(this,arguments);T(s);try{return i.apply(this,arguments)}finally{V(s)}}}function ra(i,s){i.doc.highlightFrontier<i.display.viewTo&&i.state.highlight.set(s,Xe(Ya,i))}function Ya(i){var s=i.doc;if(!(s.highlightFrontier>=i.display.viewTo)){var f=+new Date+i.options.workTime,u=o1(i,s.highlightFrontier),h=[];s.iter(u.line,Math.min(s.first+s.size,i.display.viewTo+500),function(y){if(u.line>=i.display.viewFrom){var w=y.styles,E=y.text.length>i.options.maxHighlightLength?P1(s.mode,u.state):null,I=Ji(i,y,u,!0);E&&(u.state=E),y.styles=I.styles;var F=y.styleClasses,J=I.classes;J?y.styleClasses=J:F&&(y.styleClasses=null);for(var ie=!w||w.length!=y.styles.length||F!=J&&(!F||!J||F.bgClass!=J.bgClass||F.textClass!=J.textClass),_e=0;!ie&&_e<w.length;++_e)ie=w[_e]!=y.styles[_e];ie&&h.push(u.line),y.stateAfter=u.save(),u.nextLine()}else y.text.length<=i.options.maxHighlightLength&&Ht(i,y.text,u),y.stateAfter=u.line%5==0?u.save():null,u.nextLine();if(+new Date>f)return ra(i,i.options.workDelay),!0}),s.highlightFrontier=u.line,s.modeFrontier=Math.max(s.modeFrontier,u.line),h.length&&un(i,function(){for(var y=0;y<h.length;y++)vr(i,h[y],"text")})}}var oa=function(i,s,f){var u=i.display;this.viewport=s,this.visible=K2(u,i.doc,s),this.editorIsHidden=!u.wrapper.offsetWidth,this.wrapperHeight=u.wrapper.clientHeight,this.wrapperWidth=u.wrapper.clientWidth,this.oldDisplayWidth=b1(i),this.force=f,this.dims=e2(i),this.events=[]};function Fr(i,s){var f=i.display,u=i.doc;if(s.editorIsHidden)return $a(i),!1;if(!s.force&&s.visible.from>=f.viewFrom&&s.visible.to<=f.viewTo&&(null==f.updateLineNumbers||f.updateLineNumbers>=f.viewTo)&&f.renderedView==f.view&&0==Bi(i))return!1;u3(i)&&($a(i),s.dims=e2(i));var h=u.first+u.size,y=Math.max(s.visible.from-i.options.viewportMargin,u.first),w=Math.min(h,s.visible.to+i.options.viewportMargin);f.viewFrom<y&&y-f.viewFrom<20&&(y=Math.max(u.first,f.viewFrom)),f.viewTo>w&&f.viewTo-w<20&&(w=Math.min(h,f.viewTo)),hi&&(y=Ti(i.doc,y),w=Kr(i.doc,w));var E=y!=f.viewFrom||w!=f.viewTo||f.lastWrapHeight!=s.wrapperHeight||f.lastWrapWidth!=s.wrapperWidth;(function Qo(i,s,f){var u=i.display;0==u.view.length||s>=u.viewTo||f<=u.viewFrom?(u.view=nn(i,s,f),u.viewFrom=s):(u.viewFrom>s?u.view=nn(i,s,u.viewFrom).concat(u.view):u.viewFrom<s&&(u.view=u.view.slice(t2(i,s))),u.viewFrom=s,u.viewTo<f?u.view=u.view.concat(nn(i,u.viewTo,f)):u.viewTo>f&&(u.view=u.view.slice(0,t2(i,f)))),u.viewTo=f})(i,y,w),f.viewOffset=Hi(mn(i.doc,f.viewFrom)),i.display.mover.style.top=f.viewOffset+"px";var I=Bi(i);if(!E&&0==I&&!s.force&&f.renderedView==f.view&&(null==f.updateLineNumbers||f.updateLineNumbers>=f.viewTo))return!1;var F=function Cr(i){if(i.hasFocus())return null;var s=Le();if(!s||!Un(i.display.lineDiv,s))return null;var f={activeElt:s};if(window.getSelection){var u=window.getSelection();u.anchorNode&&u.extend&&Un(i.display.lineDiv,u.anchorNode)&&(f.anchorNode=u.anchorNode,f.anchorOffset=u.anchorOffset,f.focusNode=u.focusNode,f.focusOffset=u.focusOffset)}return f}(i);return I>4&&(f.lineDiv.style.display="none"),function ti(i,s,f){var u=i.display,h=i.options.lineNumbers,y=u.lineDiv,w=y.firstChild;function E(Te){var Ge=Te.nextSibling;return oe&&Qe&&i.display.currentWheelTarget==Te?Te.style.display="none":Te.parentNode.removeChild(Te),Ge}for(var I=u.view,F=u.viewFrom,J=0;J<I.length;J++){var ie=I[J];if(!ie.hidden)if(ie.node&&ie.node.parentNode==y){for(;w!=ie.node;)w=E(w);var be=h&&null!=s&&s<=F&&ie.lineNumber;ie.changes&&(Rt(ie.changes,"gutter")>-1&&(be=!1),V1(i,ie,F,f)),be&&(mt(ie.lineNumber),ie.lineNumber.appendChild(document.createTextNode(v1(i.options,F)))),w=ie.node.nextSibling}else{var _e=A1(i,ie,F,f);y.insertBefore(_e,w)}F+=ie.size}for(;w;)w=E(w)}(i,f.updateLineNumbers,s.dims),I>4&&(f.lineDiv.style.display=""),f.renderedView=f.view,function y2(i){if(i&&i.activeElt&&i.activeElt!=Le()&&(i.activeElt.focus(),!/^(INPUT|TEXTAREA)$/.test(i.activeElt.nodeName)&&i.anchorNode&&Un(document.body,i.anchorNode)&&Un(document.body,i.focusNode))){var s=window.getSelection(),f=document.createRange();f.setEnd(i.anchorNode,i.anchorOffset),f.collapse(!1),s.removeAllRanges(),s.addRange(f),s.extend(i.focusNode,i.focusOffset)}}(F),mt(f.cursorDiv),mt(f.selectionDiv),f.gutters.style.height=f.sizer.style.minHeight=0,E&&(f.lastWrapHeight=s.wrapperHeight,f.lastWrapWidth=s.wrapperWidth,ra(i,400)),f.updateLineNumbers=null,!0}function eo(i,s){for(var f=s.viewport,u=!0;;u=!1){if(u&&i.options.lineWrapping&&s.oldDisplayWidth!=b1(i))u&&(s.visible=K2(i.display,i.doc,f));else if(f&&null!=f.top&&(f={top:Math.min(i.doc.height+Ye(i.display)-Pr(i),f.top)}),s.visible=K2(i.display,i.doc,f),s.visible.from>=i.display.viewFrom&&s.visible.to<=i.display.viewTo)break;if(!Fr(i,s))break;Or(i);var h=_r(i);Oa(i),Rr(i,h),fc(i,h),s.force=!1}s.signal(i,"update",i),(i.display.viewFrom!=i.display.reportedViewFrom||i.display.viewTo!=i.display.reportedViewTo)&&(s.signal(i,"viewportChange",i,i.display.viewFrom,i.display.viewTo),i.display.reportedViewFrom=i.display.viewFrom,i.display.reportedViewTo=i.display.viewTo)}function uc(i,s){var f=new oa(i,s);if(Fr(i,f)){Or(i),eo(i,f);var u=_r(i);Oa(i),Rr(i,u),fc(i,u),f.finish()}}function Vs(i){i.sizer.style.marginLeft=i.gutters.offsetWidth+"px",Jn(i,"gutterChanged",i)}function fc(i,s){i.display.sizer.style.minHeight=s.docHeight+"px",i.display.heightForcer.style.top=s.docHeight+"px",i.display.gutters.style.height=s.docHeight+i.display.barHeight+Fi(i)+"px"}function pc(i){var s=i.display,f=s.view;if(s.alignWidgets||s.gutters.firstChild&&i.options.fixedGutter){for(var u=Yo(s)-s.scroller.scrollLeft+i.doc.scrollLeft,h=s.gutters.offsetWidth,y=u+"px",w=0;w<f.length;w++)if(!f[w].hidden){i.options.fixedGutter&&(f[w].gutter&&(f[w].gutter.style.left=y),f[w].gutterBackground&&(f[w].gutterBackground.style.left=y));var E=f[w].alignable;if(E)for(var I=0;I<E.length;I++)E[I].style.left=y}i.options.fixedGutter&&(s.gutters.style.left=u+h+"px")}}function u3(i){if(!i.options.lineNumbers)return!1;var s=i.doc,f=v1(i.options,s.first+s.size-1),u=i.display;if(f.length!=u.lineNumChars){var h=u.measure.appendChild(tn("div",[tn("div",f)],"CodeMirror-linenumber CodeMirror-gutter-elt")),y=h.firstChild.offsetWidth,w=h.offsetWidth-y;return u.lineGutter.style.width="",u.lineNumInnerWidth=Math.max(y,u.lineGutter.offsetWidth-w)+1,u.lineNumWidth=u.lineNumInnerWidth+w,u.lineNumChars=u.lineNumInnerWidth?f.length:-1,u.lineGutter.style.width=u.lineNumWidth+"px",Vs(i.display),!0}return!1}function Xc(i,s){for(var f=[],u=!1,h=0;h<i.length;h++){var y=i[h],w=null;if("string"!=typeof y&&(w=y.style,y=y.className),"CodeMirror-linenumbers"==y){if(!s)continue;u=!0}f.push({className:y,style:w})}return s&&!u&&f.push({className:"CodeMirror-linenumbers",style:null}),f}function no(i){var s=i.gutters,f=i.gutterSpecs;mt(s),i.lineGutter=null;for(var u=0;u<f.length;++u){var h=f[u],y=h.className,w=h.style,E=s.appendChild(tn("div",null,"CodeMirror-gutter "+y));w&&(E.style.cssText=w),"CodeMirror-linenumbers"==y&&(i.lineGutter=E,E.style.width=(i.lineNumWidth||1)+"px")}s.style.display=f.length?"":"none",Vs(i)}function zo(i){no(i.display),E1(i),pc(i)}function ns(i,s,f,u){var h=this;this.input=f,h.scrollbarFiller=tn("div",null,"CodeMirror-scrollbar-filler"),h.scrollbarFiller.setAttribute("cm-not-content","true"),h.gutterFiller=tn("div",null,"CodeMirror-gutter-filler"),h.gutterFiller.setAttribute("cm-not-content","true"),h.lineDiv=Yn("div",null,"CodeMirror-code"),h.selectionDiv=tn("div",null,null,"position: relative; z-index: 1"),h.cursorDiv=tn("div",null,"CodeMirror-cursors"),h.measure=tn("div",null,"CodeMirror-measure"),h.lineMeasure=tn("div",null,"CodeMirror-measure"),h.lineSpace=Yn("div",[h.measure,h.lineMeasure,h.selectionDiv,h.cursorDiv,h.lineDiv],null,"position: relative; outline: none");var y=Yn("div",[h.lineSpace],"CodeMirror-lines");h.mover=tn("div",[y],null,"position: relative"),h.sizer=tn("div",[h.mover],"CodeMirror-sizer"),h.sizerWidth=null,h.heightForcer=tn("div",null,null,"position: absolute; height: 50px; width: 1px;"),h.gutters=tn("div",null,"CodeMirror-gutters"),h.lineGutter=null,h.scroller=tn("div",[h.sizer,h.heightForcer,h.gutters],"CodeMirror-scroll"),h.scroller.setAttribute("tabIndex","-1"),h.wrapper=tn("div",[h.scrollbarFiller,h.gutterFiller,h.scroller],"CodeMirror"),h.wrapper.setAttribute("translate","no"),ye&&he<8&&(h.gutters.style.zIndex=-1,h.scroller.style.paddingRight=0),!oe&&!(M&&Ke)&&(h.scroller.draggable=!0),i&&(i.appendChild?i.appendChild(h.wrapper):i(h.wrapper)),h.viewFrom=h.viewTo=s.first,h.reportedViewFrom=h.reportedViewTo=s.first,h.view=[],h.renderedView=null,h.externalMeasured=null,h.viewOffset=0,h.lastWrapHeight=h.lastWrapWidth=0,h.updateLineNumbers=null,h.nativeBarWidth=h.barHeight=h.barWidth=0,h.scrollbarsClipped=!1,h.lineNumWidth=h.lineNumInnerWidth=h.lineNumChars=null,h.alignWidgets=!1,h.cachedCharWidth=h.cachedTextHeight=h.cachedPaddingH=null,h.maxLine=null,h.maxLineLength=0,h.maxLineChanged=!1,h.wheelDX=h.wheelDY=h.wheelStartX=h.wheelStartY=null,h.shift=!1,h.selForContextMenu=null,h.activeTouch=null,h.gutterSpecs=Xc(u.gutters,u.lineNumbers),no(h),f.init(h)}oa.prototype.signal=function(i,s){gt(i,s)&&this.events.push(arguments)},oa.prototype.finish=function(){for(var i=0;i<this.events.length;i++)ht.apply(null,this.events[i])};var Hs=0,L1=null;function P2(i){var s=i.wheelDeltaX,f=i.wheelDeltaY;return null==s&&i.detail&&i.axis==i.HORIZONTAL_AXIS&&(s=i.detail),null==f&&i.detail&&i.axis==i.VERTICAL_AXIS?f=i.detail:null==f&&(f=i.wheelDelta),{x:s,y:f}}function I2(i){var s=P2(i);return s.x*=L1,s.y*=L1,s}function _2(i,s){var f=P2(s),u=f.x,h=f.y,y=L1;0===s.deltaMode&&(u=s.deltaX,h=s.deltaY,y=1);var w=i.display,E=w.scroller,F=E.scrollHeight>E.clientHeight;if(u&&E.scrollWidth>E.clientWidth||h&&F){if(h&&Qe&&oe)e:for(var J=s.target,ie=w.view;J!=E;J=J.parentNode)for(var _e=0;_e<ie.length;_e++)if(ie[_e].node==J){i.display.currentWheelTarget=J;break e}if(u&&!M&&!le&&null!=y)return h&&F&&b2(i,Math.max(0,E.scrollTop+h*y)),or(i,Math.max(0,E.scrollLeft+u*y)),(!h||h&&F)&&_1(s),void(w.wheelStartX=null);if(h&&null!=y){var be=h*y,Te=i.doc.scrollTop,Ge=Te+w.wrapper.clientHeight;be<0?Te=Math.max(0,Te+be-50):Ge=Math.min(i.doc.height,Ge+be+50),uc(i,{top:Te,bottom:Ge})}Hs<20&&0!==s.deltaMode&&(null==w.wheelStartX?(w.wheelStartX=E.scrollLeft,w.wheelStartY=E.scrollTop,w.wheelDX=u,w.wheelDY=h,setTimeout(function(){if(null!=w.wheelStartX){var an=E.scrollLeft-w.wheelStartX,pn=E.scrollTop-w.wheelStartY,Cn=pn&&w.wheelDY&&pn/w.wheelDY||an&&w.wheelDX&&an/w.wheelDX;w.wheelStartX=w.wheelStartY=null,Cn&&(L1=(L1*Hs+Cn)/(Hs+1),++Hs)}},200)):(w.wheelDX+=u,w.wheelDY+=h))}}ye?L1=-.53:M?L1=15:fe?L1=-.7:pe&&(L1=-1/3);var xa=function(i,s){this.ranges=i,this.primIndex=s};xa.prototype.primary=function(){return this.ranges[this.primIndex]},xa.prototype.equals=function(i){if(i==this)return!0;if(i.primIndex!=this.primIndex||i.ranges.length!=this.ranges.length)return!1;for(var s=0;s<this.ranges.length;s++){var f=this.ranges[s],u=i.ranges[s];if(!mi(f.anchor,u.anchor)||!mi(f.head,u.head))return!1}return!0},xa.prototype.deepCopy=function(){for(var i=[],s=0;s<this.ranges.length;s++)i[s]=new St(n1(this.ranges[s].anchor),n1(this.ranges[s].head));return new xa(i,this.primIndex)},xa.prototype.somethingSelected=function(){for(var i=0;i<this.ranges.length;i++)if(!this.ranges[i].empty())return!0;return!1},xa.prototype.contains=function(i,s){s||(s=i);for(var f=0;f<this.ranges.length;f++){var u=this.ranges[f];if(wn(s,u.from())>=0&&wn(i,u.to())<=0)return f}return-1};var St=function(i,s){this.anchor=i,this.head=s};function yi(i,s,f){var u=i&&i.options.selectionsMayTouch,h=s[f];s.sort(function(_e,be){return wn(_e.from(),be.from())}),f=Rt(s,h);for(var y=1;y<s.length;y++){var w=s[y],E=s[y-1],I=wn(E.to(),w.from());if(u&&!w.empty()?I>0:I>=0){var F=d1(E.from(),w.from()),J=J1(E.to(),w.to()),ie=E.empty()?w.from()==w.head:E.from()==E.head;y<=f&&--f,s.splice(--y,2,new St(ie?J:F,ie?F:J))}}return new xa(s,f)}function x2(i,s){return new xa([new St(i,s||i)],0)}function qr(i){return i.text?We(i.from.line+i.text.length-1,qn(i.text).length+(1==i.text.length?i.from.ch:0)):i.to}function No(i,s){if(wn(i,s.from)<0)return i;if(wn(i,s.to)<=0)return qr(s);var f=i.line+s.text.length-(s.to.line-s.from.line)-1,u=i.ch;return i.line==s.to.line&&(u+=qr(s).ch-s.to.ch),We(f,u)}function Rs(i,s){for(var f=[],u=0;u<i.sel.ranges.length;u++){var h=i.sel.ranges[u];f.push(new St(No(h.anchor,s),No(h.head,s)))}return yi(i.cm,f,i.sel.primIndex)}function Yc(i,s,f){return i.line==s.line?We(f.line,i.ch-s.ch+f.ch):We(f.line+(i.line-s.line),i.ch)}function Qc(i){i.doc.mode=Zt(i.options,i.doc.modeOption),Fs(i)}function Fs(i){i.doc.iter(function(s){s.stateAfter&&(s.stateAfter=null),s.styles&&(s.styles=null)}),i.doc.modeFrontier=i.doc.highlightFrontier=i.doc.first,ra(i,100),i.state.modeGen++,i.curOp&&E1(i)}function Sr(i,s){return 0==s.from.ch&&0==s.to.ch&&""==qn(s.text)&&(!i.cm||i.cm.options.wholeLineUpdateBefore)}function sa(i,s,f,u){function h(Cn){return f?f[Cn]:null}function y(Cn,gn,Nn){(function ei(i,s,f,u){i.text=s,i.stateAfter&&(i.stateAfter=null),i.styles&&(i.styles=null),null!=i.order&&(i.order=null),Ua(i),mr(i,f);var h=u?u(i):1;h!=i.height&&qt(i,h)})(Cn,gn,Nn,u),Jn(Cn,"change",Cn,s)}function w(Cn,gn){for(var Nn=[],Wn=Cn;Wn<gn;++Wn)Nn.push(new ka(F[Wn],h(Wn),u));return Nn}var E=s.from,I=s.to,F=s.text,J=mn(i,E.line),ie=mn(i,I.line),_e=qn(F),be=h(F.length-1),Te=I.line-E.line;if(s.full)i.insert(0,w(0,F.length)),i.remove(F.length,i.size-F.length);else if(Sr(i,s)){var Ge=w(0,F.length-1);y(ie,ie.text,be),Te&&i.remove(E.line,Te),Ge.length&&i.insert(E.line,Ge)}else if(J==ie)if(1==F.length)y(J,J.text.slice(0,E.ch)+_e+J.text.slice(I.ch),be);else{var an=w(1,F.length-1);an.push(new ka(_e+J.text.slice(I.ch),be,u)),y(J,J.text.slice(0,E.ch)+F[0],h(0)),i.insert(E.line+1,an)}else if(1==F.length)y(J,J.text.slice(0,E.ch)+F[0]+ie.text.slice(I.ch),h(0)),i.remove(E.line+1,Te);else{y(J,J.text.slice(0,E.ch)+F[0],h(0)),y(ie,_e+ie.text.slice(I.ch),be);var pn=w(1,F.length-1);Te>1&&i.remove(E.line+1,Te-1),i.insert(E.line+1,pn)}Jn(i,"change",i,s)}function cr(i,s,f){!function u(h,y,w){if(h.linked)for(var E=0;E<h.linked.length;++E){var I=h.linked[E];if(I.doc!=y){var F=w&&I.sharedHist;f&&!F||(s(I.doc,F),u(I.doc,h,F))}}}(i,null,!0)}function to(i,s){if(s.cm)throw new Error("This document is already in use.");i.doc=s,s.cm=i,Co(i),Qc(i),f3(i),i.options.direction=s.direction,i.options.lineWrapping||Wa(i),i.options.mode=s.modeOption,E1(i)}function f3(i){("rtl"==i.doc.direction?De:g1)(i.display.lineDiv,"CodeMirror-rtl")}function ts(i){this.done=[],this.undone=[],this.undoDepth=i?i.undoDepth:1/0,this.lastModTime=this.lastSelTime=0,this.lastOp=this.lastSelOp=null,this.lastOrigin=this.lastSelOrigin=null,this.generation=this.maxGeneration=i?i.maxGeneration:1}function is(i,s){var f={from:n1(s.from),to:qr(s),text:bt(i,s.from,s.to)};return m3(i,f,s.from.line,s.to.line+1),cr(i,function(u){return m3(u,f,s.from.line,s.to.line+1)},!0),f}function Jc(i){for(;i.length&&qn(i).ranges;)i.pop()}function Kc(i,s,f,u){var h=i.history;h.undone.length=0;var w,E,y=+new Date;if((h.lastOp==u||h.lastOrigin==s.origin&&s.origin&&("+"==s.origin.charAt(0)&&h.lastModTime>y-(i.cm?i.cm.options.historyEventDelay:500)||"*"==s.origin.charAt(0)))&&(w=function p3(i,s){return s?(Jc(i.done),qn(i.done)):i.done.length&&!qn(i.done).ranges?qn(i.done):i.done.length>1&&!i.done[i.done.length-2].ranges?(i.done.pop(),qn(i.done)):void 0}(h,h.lastOp==u)))E=qn(w.changes),0==wn(s.from,s.to)&&0==wn(s.from,E.to)?E.to=qr(s):w.changes.push(is(i,s));else{var I=qn(h.done);for((!I||!I.ranges)&&ca(i.sel,h.done),w={changes:[is(i,s)],generation:h.generation},h.done.push(w);h.done.length>h.undoDepth;)h.done.shift(),h.done[0].ranges||h.done.shift()}h.done.push(f),h.generation=++h.maxGeneration,h.lastModTime=h.lastSelTime=y,h.lastOp=h.lastSelOp=u,h.lastOrigin=h.lastSelOrigin=s.origin,E||ht(i,"historyAdded")}function n4(i,s,f,u){var h=i.history,y=u&&u.origin;f==h.lastSelOp||y&&h.lastSelOrigin==y&&(h.lastModTime==h.lastSelTime&&h.lastOrigin==y||function e4(i,s,f,u){var h=s.charAt(0);return"*"==h||"+"==h&&f.ranges.length==u.ranges.length&&f.somethingSelected()==u.somethingSelected()&&new Date-i.history.lastSelTime<=(i.cm?i.cm.options.historyEventDelay:500)}(i,y,qn(h.done),s))?h.done[h.done.length-1]=s:ca(s,h.done),h.lastSelTime=+new Date,h.lastSelOrigin=y,h.lastSelOp=f,u&&!1!==u.clearRedo&&Jc(h.undone)}function ca(i,s){var f=qn(s);f&&f.ranges&&f.equals(i)||s.push(i)}function m3(i,s,f,u){var h=s["spans_"+i.id],y=0;i.iter(Math.max(i.first,f),Math.min(i.first+i.size,u),function(w){w.markedSpans&&((h||(h=s["spans_"+i.id]={}))[y]=w.markedSpans),++y})}function as(i){if(!i)return null;for(var s,f=0;f<i.length;++f)i[f].marker.explicitlyCleared?s||(s=i.slice(0,f)):s&&s.push(i[f]);return s?s.length?s:null:i}function os(i,s){var f=function rs(i,s){var f=s["spans_"+i.id];if(!f)return null;for(var u=[],h=0;h<s.text.length;++h)u.push(as(f[h]));return u}(i,s),u=va(i,s);if(!f)return u;if(!u)return f;for(var h=0;h<f.length;++h){var y=f[h],w=u[h];if(y&&w)e:for(var E=0;E<w.length;++E){for(var I=w[E],F=0;F<y.length;++F)if(y[F].marker==I.marker)continue e;y.push(I)}else w&&(f[h]=w)}return f}function Do(i,s,f){for(var u=[],h=0;h<i.length;++h){var y=i[h];if(y.ranges)u.push(f?xa.prototype.deepCopy.call(y):y);else{var w=y.changes,E=[];u.push({changes:E});for(var I=0;I<w.length;++I){var F=w[I],J=void 0;if(E.push({from:F.from,to:F.to,text:F.text}),s)for(var ie in F)(J=ie.match(/^spans_(\d+)$/))&&Rt(s,Number(J[1]))>-1&&(qn(E)[ie]=F[ie],delete F[ie])}}}return u}function hc(i,s,f,u){if(u){var h=i.anchor;if(f){var y=wn(s,h)<0;y!=wn(f,h)<0?(h=s,s=f):y!=wn(s,f)<0&&(s=f)}return new St(h,s)}return new St(f||s,s)}function qs(i,s,f,u,h){null==h&&(h=i.cm&&(i.cm.display.shift||i.extend)),vt(i,new xa([hc(i.sel.primary(),s,f,h)],0),u)}function gc(i,s,f){for(var u=[],h=i.cm&&(i.cm.display.shift||i.extend),y=0;y<i.sel.ranges.length;y++)u[y]=hc(i.sel.ranges[y],s[y],null,h);vt(i,yi(i.cm,u,i.sel.primIndex),f)}function Eo(i,s,f,u){var h=i.sel.ranges.slice(0);h[s]=f,vt(i,yi(i.cm,h,i.sel.primIndex),u)}function Qa(i,s,f,u){vt(i,x2(s,f),u)}function vc(i,s,f){var u=i.history.done,h=qn(u);h&&h.ranges?(u[u.length-1]=s,Va(i,s,f)):vt(i,s,f)}function vt(i,s,f){Va(i,s,f),n4(i,i.sel,i.cm?i.cm.curOp.id:NaN,f)}function Va(i,s,f){(gt(i,"beforeSelectionChange")||i.cm&&gt(i.cm,"beforeSelectionChange"))&&(s=function t4(i,s,f){var u={ranges:s.ranges,update:function(h){this.ranges=[];for(var y=0;y<h.length;y++)this.ranges[y]=new St(Pn(i,h[y].anchor),Pn(i,h[y].head))},origin:f&&f.origin};return ht(i,"beforeSelectionChange",i,u),i.cm&&ht(i.cm,"beforeSelectionChange",i.cm,u),u.ranges!=s.ranges?yi(i.cm,u.ranges,u.ranges.length-1):s}(i,s,f));var u=f&&f.bias||(wn(s.primary().head,i.sel.primary().head)<0?-1:1);Br(i,O2(i,s,u,!0)),(!f||!1!==f.scroll)&&i.cm&&"nocursor"!=i.cm.getOption("readOnly")&&yr(i.cm)}function Br(i,s){s.equals(i.sel)||(i.sel=s,i.cm&&(i.cm.curOp.updateInput=1,i.cm.curOp.selectionChanged=!0,e1(i.cm)),Jn(i,"cursorActivity",i))}function Ja(i){Br(i,O2(i,i.sel,null,!1))}function O2(i,s,f,u){for(var h,y=0;y<s.ranges.length;y++){var w=s.ranges[y],E=s.ranges.length==i.sel.ranges.length&&i.sel.ranges[y],I=C2(i,w.anchor,E&&E.anchor,f,u),F=C2(i,w.head,E&&E.head,f,u);(h||I!=w.anchor||F!=w.head)&&(h||(h=s.ranges.slice(0,y)),h[y]=new St(I,F))}return h?yi(i.cm,h,s.primIndex):s}function r2(i,s,f,u,h){var y=mn(i,s.line);if(y.markedSpans)for(var w=0;w<y.markedSpans.length;++w){var E=y.markedSpans[w],I=E.marker,F="selectLeft"in I?!I.selectLeft:I.inclusiveLeft,J="selectRight"in I?!I.selectRight:I.inclusiveRight;if((null==E.from||(F?E.from<=s.ch:E.from<s.ch))&&(null==E.to||(J?E.to>=s.ch:E.to>s.ch))){if(h&&(ht(I,"beforeCursorEnter"),I.explicitlyCleared)){if(y.markedSpans){--w;continue}break}if(!I.atomic)continue;if(f){var ie=I.find(u<0?1:-1),_e=void 0;if((u<0?J:F)&&(ie=Ao(i,ie,-u,ie&&ie.line==s.line?y:null)),ie&&ie.line==s.line&&(_e=wn(ie,f))&&(u<0?_e<0:_e>0))return r2(i,ie,s,u,h)}var be=I.find(u<0?-1:1);return(u<0?F:J)&&(be=Ao(i,be,u,be.line==s.line?y:null)),be?r2(i,be,s,u,h):null}}return s}function C2(i,s,f,u,h){var y=u||1;return r2(i,s,f,y,h)||!h&&r2(i,s,f,y,!0)||r2(i,s,f,-y,h)||!h&&r2(i,s,f,-y,!0)||(i.cantEdit=!0,We(i.first,0))}function Ao(i,s,f,u){return f<0&&0==s.ch?s.line>i.first?Pn(i,We(s.line-1)):null:f>0&&s.ch==(u||mn(i,s.line)).text.length?s.line<i.first+i.size-1?We(s.line+1,0):null:new We(s.line,s.ch+f)}function ss(i){i.setSelection(We(i.firstLine(),0),We(i.lastLine()),st)}function io(i,s,f){var u={canceled:!1,from:s.from,to:s.to,text:s.text,origin:s.origin,cancel:function(){return u.canceled=!0}};return f&&(u.update=function(h,y,w,E){h&&(u.from=Pn(i,h)),y&&(u.to=Pn(i,y)),w&&(u.text=w),void 0!==E&&(u.origin=E)}),ht(i,"beforeChange",i,u),i.cm&&ht(i.cm,"beforeChange",i.cm,u),u.canceled?(i.cm&&(i.cm.curOp.updateInput=2),null):{from:u.from,to:u.to,text:u.text,origin:u.origin}}function Ur(i,s,f){if(i.cm){if(!i.cm.curOp)return Kn(i.cm,Ur)(i,s,f);if(i.cm.state.suppressEdits)return}if(!(gt(i,"beforeChange")||i.cm&&gt(i.cm,"beforeChange"))||(s=io(i,s,!0))){var u=Ea&&!f&&function Qr(i,s,f){var u=null;if(i.iter(s.line,f.line+1,function(be){if(be.markedSpans)for(var Te=0;Te<be.markedSpans.length;++Te){var Ge=be.markedSpans[Te].marker;Ge.readOnly&&(!u||-1==Rt(u,Ge))&&(u||(u=[])).push(Ge)}}),!u)return null;for(var h=[{from:s,to:f}],y=0;y<u.length;++y)for(var w=u[y],E=w.find(0),I=0;I<h.length;++I){var F=h[I];if(!(wn(F.to,E.from)<0||wn(F.from,E.to)>0)){var J=[I,1],ie=wn(F.from,E.from),_e=wn(F.to,E.to);(ie<0||!w.inclusiveLeft&&!ie)&&J.push({from:F.from,to:E.from}),(_e>0||!w.inclusiveRight&&!_e)&&J.push({from:E.to,to:F.to}),h.splice.apply(h,J),I+=J.length-3}}return h}(i,s.from,s.to);if(u)for(var h=u.length-1;h>=0;--h)Lo(i,{from:u[h].from,to:u[h].to,text:h?[""]:s.text,origin:s.origin});else Lo(i,s)}}function Lo(i,s){if(1!=s.text.length||""!=s.text[0]||0!=wn(s.from,s.to)){var f=Rs(i,s);Kc(i,s,f,i.cm?i.cm.curOp.id:NaN),V2(i,s,f,va(i,s));var u=[];cr(i,function(h,y){!y&&-1==Rt(u,h.history)&&(ro(h.history,s),u.push(h.history)),V2(h,s,null,va(h,s))})}}function cs(i,s,f){var u=i.cm&&i.cm.state.suppressEdits;if(!u||f){for(var y,h=i.history,w=i.sel,E="undo"==s?h.done:h.undone,I="undo"==s?h.undone:h.done,F=0;F<E.length&&(y=E[F],!(f?y.ranges&&!y.equals(i.sel):!y.ranges));F++);if(F!=E.length){for(h.lastOrigin=h.lastSelOrigin=null;;){if(!(y=E.pop()).ranges){if(u)return void E.push(y);break}if(ca(y,I),f&&!y.equals(i.sel))return void vt(i,y,{clearRedo:!1});w=y}var J=[];ca(w,I),I.push({changes:J,generation:h.generation}),h.generation=y.generation||++h.maxGeneration;for(var ie=gt(i,"beforeChange")||i.cm&&gt(i.cm,"beforeChange"),_e=function(Ge){var an=y.changes[Ge];if(an.origin=s,ie&&!io(i,an,!1))return E.length=0,{};J.push(is(i,an));var pn=Ge?Rs(i,an):qn(E);V2(i,an,pn,os(i,an)),!Ge&&i.cm&&i.cm.scrollIntoView({from:an.from,to:qr(an)});var Cn=[];cr(i,function(gn,Nn){!Nn&&-1==Rt(Cn,gn.history)&&(ro(gn.history,an),Cn.push(gn.history)),V2(gn,an,null,os(gn,an))})},be=y.changes.length-1;be>=0;--be){var Te=_e(be);if(Te)return Te.v}}}}function bc(i,s){if(0!=s&&(i.first+=s,i.sel=new xa(pi(i.sel.ranges,function(h){return new St(We(h.anchor.line+s,h.anchor.ch),We(h.head.line+s,h.head.ch))}),i.sel.primIndex),i.cm)){E1(i.cm,i.first,i.first-s,s);for(var f=i.cm.display,u=f.viewFrom;u<f.viewTo;u++)vr(i.cm,u,"gutter")}}function V2(i,s,f,u){if(i.cm&&!i.cm.curOp)return Kn(i.cm,V2)(i,s,f,u);if(s.to.line<i.first)bc(i,s.text.length-1-(s.to.line-s.from.line));else if(!(s.from.line>i.lastLine())){if(s.from.line<i.first){var h=s.text.length-1-(i.first-s.from.line);bc(i,h),s={from:We(i.first,0),to:We(s.to.line+h,s.to.ch),text:[qn(s.text)],origin:s.origin}}var y=i.lastLine();s.to.line>y&&(s={from:s.from,to:We(y,mn(i,y).text.length),text:[s.text[0]],origin:s.origin}),s.removed=bt(i,s.from,s.to),f||(f=Rs(i,s)),i.cm?function Bs(i,s,f){var u=i.doc,h=i.display,y=s.from,w=s.to,E=!1,I=y.line;i.options.lineWrapping||(I=Ze(w1(mn(u,y.line))),u.iter(I,w.line+1,function(be){if(be==h.maxLine)return E=!0,!0})),u.sel.contains(s.from,s.to)>-1&&e1(i),sa(u,s,f,xo(i)),i.options.lineWrapping||(u.iter(I,y.line+s.text.length,function(be){var Te=O1(be);Te>h.maxLineLength&&(h.maxLine=be,h.maxLineLength=Te,h.maxLineChanged=!0,E=!1)}),E&&(i.curOp.updateMaxLine=!0)),function K1(i,s){if(i.modeFrontier=Math.min(i.modeFrontier,s),!(i.highlightFrontier<s-10)){for(var f=i.first,u=s-1;u>f;u--){var h=mn(i,u).stateAfter;if(h&&(!(h instanceof Qi)||u+h.lookAhead<s)){f=u+1;break}}i.highlightFrontier=Math.min(i.highlightFrontier,f)}}(u,y.line),ra(i,400);var F=s.text.length-(w.line-y.line)-1;s.full?E1(i):y.line!=w.line||1!=s.text.length||Sr(i.doc,s)?E1(i,y.line,w.line+1,F):vr(i,y.line,"text");var J=gt(i,"changes"),ie=gt(i,"change");if(ie||J){var _e={from:y,to:w,text:s.text,removed:s.removed,origin:s.origin};ie&&Jn(i,"change",i,_e),J&&(i.curOp.changeObjs||(i.curOp.changeObjs=[])).push(_e)}i.display.selForContextMenu=null}(i.cm,s,u):sa(i,s,u),Va(i,f,st),i.cantEdit&&C2(i,We(i.firstLine(),0))&&(i.cantEdit=!1)}}function ao(i,s,f,u,h){var y;u||(u=f),wn(u,f)<0&&(f=(y=[u,f])[0],u=y[1]),"string"==typeof s&&(s=i.splitLines(s)),Ur(i,{from:f,to:u,text:s,origin:h})}function i4(i,s,f,u){f<i.line?i.line+=u:s<i.line&&(i.line=s,i.ch=0)}function a4(i,s,f,u){for(var h=0;h<i.length;++h){var y=i[h],w=!0;if(y.ranges){y.copied||((y=i[h]=y.deepCopy()).copied=!0);for(var E=0;E<y.ranges.length;E++)i4(y.ranges[E].anchor,s,f,u),i4(y.ranges[E].head,s,f,u)}else{for(var I=0;I<y.changes.length;++I){var F=y.changes[I];if(f<F.from.line)F.from=We(F.from.line+u,F.from.ch),F.to=We(F.to.line+u,F.to.ch);else if(s<=F.to.line){w=!1;break}}w||(i.splice(0,h+1),h=0)}}}function ro(i,s){var f=s.from.line,u=s.to.line,h=s.text.length-(u-f)-1;a4(i.done,f,u,h),a4(i.undone,f,u,h)}function S2(i,s,f,u){var h=s,y=s;return"number"==typeof s?y=mn(i,Qn(i,s)):h=Ze(s),null==h?null:(u(y,h)&&i.cm&&vr(i.cm,h,f),y)}function ls(i){this.lines=i,this.parent=null;for(var s=0,f=0;f<i.length;++f)i[f].parent=this,s+=i[f].height;this.height=s}function Us(i){this.children=i;for(var s=0,f=0,u=0;u<i.length;++u){var h=i[u];s+=h.chunkSize(),f+=h.height,h.parent=this}this.size=s,this.height=f,this.parent=null}St.prototype.from=function(){return d1(this.anchor,this.head)},St.prototype.to=function(){return J1(this.anchor,this.head)},St.prototype.empty=function(){return this.head.line==this.anchor.line&&this.head.ch==this.anchor.ch},ls.prototype={chunkSize:function(){return this.lines.length},removeInner:function(i,s){for(var f=i,u=i+s;f<u;++f){var h=this.lines[f];this.height-=h.height,Za(h),Jn(h,"delete")}this.lines.splice(i,s)},collapse:function(i){i.push.apply(i,this.lines)},insertInner:function(i,s,f){this.height+=f,this.lines=this.lines.slice(0,i).concat(s).concat(this.lines.slice(i));for(var u=0;u<s.length;++u)s[u].parent=this},iterN:function(i,s,f){for(var u=i+s;i<u;++i)if(f(this.lines[i]))return!0}},Us.prototype={chunkSize:function(){return this.size},removeInner:function(i,s){this.size-=s;for(var f=0;f<this.children.length;++f){var u=this.children[f],h=u.chunkSize();if(i<h){var y=Math.min(s,h-i),w=u.height;if(u.removeInner(i,y),this.height-=w-u.height,h==y&&(this.children.splice(f--,1),u.parent=null),0==(s-=y))break;i=0}else i-=h}if(this.size-s<25&&(this.children.length>1||!(this.children[0]instanceof ls))){var E=[];this.collapse(E),this.children=[new ls(E)],this.children[0].parent=this}},collapse:function(i){for(var s=0;s<this.children.length;++s)this.children[s].collapse(i)},insertInner:function(i,s,f){this.size+=s.length,this.height+=f;for(var u=0;u<this.children.length;++u){var h=this.children[u],y=h.chunkSize();if(i<=y){if(h.insertInner(i,s,f),h.lines&&h.lines.length>50){for(var w=h.lines.length%25+25,E=w;E<h.lines.length;){var I=new ls(h.lines.slice(E,E+=25));h.height-=I.height,this.children.splice(++u,0,I),I.parent=this}h.lines=h.lines.slice(0,w),this.maybeSpill()}break}i-=y}},maybeSpill:function(){if(!(this.children.length<=10)){var i=this;do{var f=new Us(i.children.splice(i.children.length-5,5));if(i.parent){i.size-=f.size,i.height-=f.height;var h=Rt(i.parent.children,i);i.parent.children.splice(h+1,0,f)}else{var u=new Us(i.children);u.parent=i,i.children=[u,f],i=u}f.parent=i.parent}while(i.children.length>10);i.parent.maybeSpill()}},iterN:function(i,s,f){for(var u=0;u<this.children.length;++u){var h=this.children[u],y=h.chunkSize();if(i<y){var w=Math.min(s,y-i);if(h.iterN(i,w,f))return!0;if(0==(s-=w))break;i=0}else i-=y}}};var To=function(i,s,f){if(f)for(var u in f)f.hasOwnProperty(u)&&(this[u]=f[u]);this.doc=i,this.node=s};function Mr(i,s,f){Hi(s)<(i.curOp&&i.curOp.scrollTop||i.doc.scrollTop)&&Os(i,f)}To.prototype.clear=function(){var i=this.doc.cm,s=this.line.widgets,f=this.line,u=Ze(f);if(null!=u&&s){for(var h=0;h<s.length;++h)s[h]==this&&s.splice(h--,1);s.length||(f.widgets=null);var y=ta(this);qt(f,Math.max(0,f.height-y)),i&&(un(i,function(){Mr(i,f,-y),vr(i,u,"widget")}),Jn(i,"lineWidgetCleared",i,this,u))}},To.prototype.changed=function(){var i=this,s=this.height,f=this.doc.cm,u=this.line;this.height=null;var h=ta(this)-s;!h||(ji(this.doc,u)||qt(u,u.height+h),f&&un(f,function(){f.curOp.forceUpdate=!0,Mr(f,u,h),Jn(f,"lineWidgetChanged",f,i,Ze(u))}))},Mt(To);var lr=0,o2=function(i,s){this.lines=[],this.type=s,this.doc=i,this.id=++lr};function dr(i,s,f,u,h){if(u&&u.shared)return function jo(i,s,f,u,h){(u=En(u)).shared=!1;var y=[dr(i,s,f,u,h)],w=y[0],E=u.widgetNode;return cr(i,function(I){E&&(u.widgetNode=E.cloneNode(!0)),y.push(dr(I,Pn(I,s),Pn(I,f),u,h));for(var F=0;F<I.linked.length;++F)if(I.linked[F].isParent)return;w=qn(y)}),new Ka(y,w)}(i,s,f,u,h);if(i.cm&&!i.cm.curOp)return Kn(i.cm,dr)(i,s,f,u,h);var y=new o2(i,h),w=wn(s,f);if(u&&En(u,y,!1),w>0||0==w&&!1!==y.clearWhenEmpty)return y;if(y.replacedWith&&(y.collapsed=!0,y.widgetNode=Yn("span",[y.replacedWith],"CodeMirror-widget"),u.handleMouseEvents||y.widgetNode.setAttribute("cm-ignore-events","true"),u.insertLeft&&(y.widgetNode.insertLeft=!0)),y.collapsed){if(m2(i,s.line,s,f,y)||s.line!=f.line&&m2(i,f.line,s,f,y))throw new Error("Inserting collapsed marker partially overlapping an existing one");!function Ba(){hi=!0}()}y.addToHistory&&Kc(i,{from:s,to:f,origin:"markText"},i.sel,NaN);var F,E=s.line,I=i.cm;if(i.iter(E,f.line+1,function(ie){I&&y.collapsed&&!I.options.lineWrapping&&w1(ie)==I.display.maxLine&&(F=!0),y.collapsed&&E!=s.line&&qt(ie,0),function pr(i,s,f){var u=f&&window.WeakSet&&(f.markedSpans||(f.markedSpans=new WeakSet));u&&u.has(i.markedSpans)?i.markedSpans.push(s):(i.markedSpans=i.markedSpans?i.markedSpans.concat([s]):[s],u&&u.add(i.markedSpans)),s.marker.attachLine(i)}(ie,new ga(y,E==s.line?s.ch:null,E==f.line?f.ch:null),i.cm&&i.cm.curOp),++E}),y.collapsed&&i.iter(s.line,f.line+1,function(ie){ji(i,ie)&&qt(ie,0)}),y.clearOnEnter&&jn(y,"beforeCursorEnter",function(){return y.clear()}),y.readOnly&&(function ar(){Ea=!0}(),(i.history.done.length||i.history.undone.length)&&i.clearHistory()),y.collapsed&&(y.id=++lr,y.atomic=!0),I){if(F&&(I.curOp.updateMaxLine=!0),y.collapsed)E1(I,s.line,f.line+1);else if(y.className||y.startStyle||y.endStyle||y.css||y.attributes||y.title)for(var J=s.line;J<=f.line;J++)vr(I,J,"text");y.atomic&&Ja(I.doc),Jn(I,"markerAdded",I,y)}return y}o2.prototype.clear=function(){if(!this.explicitlyCleared){var i=this.doc.cm,s=i&&!i.curOp;if(s&&T(i),gt(this,"clear")){var f=this.find();f&&Jn(this,"clear",f.from,f.to)}for(var u=null,h=null,y=0;y<this.lines.length;++y){var w=this.lines[y],E=Aa(w.markedSpans,this);i&&!this.collapsed?vr(i,Ze(w),"text"):i&&(null!=E.to&&(h=Ze(w)),null!=E.from&&(u=Ze(w))),w.markedSpans=Lr(w.markedSpans,E),null==E.from&&this.collapsed&&!ji(this.doc,w)&&i&&qt(w,bi(i.display))}if(i&&this.collapsed&&!i.options.lineWrapping)for(var I=0;I<this.lines.length;++I){var F=w1(this.lines[I]),J=O1(F);J>i.display.maxLineLength&&(i.display.maxLine=F,i.display.maxLineLength=J,i.display.maxLineChanged=!0)}null!=u&&i&&this.collapsed&&E1(i,u,h+1),this.lines.length=0,this.explicitlyCleared=!0,this.atomic&&this.doc.cantEdit&&(this.doc.cantEdit=!1,i&&Ja(i.doc)),i&&Jn(i,"markerCleared",i,this,u,h),s&&V(i),this.parent&&this.parent.clear()}},o2.prototype.find=function(i,s){null==i&&"bookmark"==this.type&&(i=1);for(var f,u,h=0;h<this.lines.length;++h){var y=this.lines[h],w=Aa(y.markedSpans,this);if(null!=w.from&&(f=We(s?y:Ze(y),w.from),-1==i))return f;if(null!=w.to&&(u=We(s?y:Ze(y),w.to),1==i))return u}return f&&{from:f,to:u}},o2.prototype.changed=function(){var i=this,s=this.find(-1,!0),f=this,u=this.doc.cm;!s||!u||un(u,function(){var h=s.line,y=Ze(s.line),w=Hn(u,y);if(w&&(ve(w),u.curOp.selectionChanged=u.curOp.forceUpdate=!0),u.curOp.updateMaxLine=!0,!ji(f.doc,h)&&null!=f.height){var E=f.height;f.height=null;var I=ta(f)-E;I&&qt(h,h.height+I)}Jn(u,"markerChanged",u,i)})},o2.prototype.attachLine=function(i){if(!this.lines.length&&this.doc.cm){var s=this.doc.cm.curOp;(!s.maybeHiddenMarkers||-1==Rt(s.maybeHiddenMarkers,this))&&(s.maybeUnhiddenMarkers||(s.maybeUnhiddenMarkers=[])).push(this)}this.lines.push(i)},o2.prototype.detachLine=function(i){if(this.lines.splice(Rt(this.lines,i),1),!this.lines.length&&this.doc.cm){var s=this.doc.cm.curOp;(s.maybeHiddenMarkers||(s.maybeHiddenMarkers=[])).push(this)}},Mt(o2);var Ka=function(i,s){this.markers=i,this.primary=s;for(var f=0;f<i.length;++f)i[f].parent=this};function wr(i){return i.findMarks(We(i.first,0),i.clipPos(We(i.lastLine())),function(s){return s.parent})}function yc(i){for(var s=function(u){var h=i[u],y=[h.primary.doc];cr(h.primary.doc,function(I){return y.push(I)});for(var w=0;w<h.markers.length;w++){var E=h.markers[w];-1==Rt(y,E.doc)&&(E.parent=null,h.markers.splice(w--,1))}},f=0;f<i.length;f++)s(f)}Ka.prototype.clear=function(){if(!this.explicitlyCleared){this.explicitlyCleared=!0;for(var i=0;i<this.markers.length;++i)this.markers[i].clear();Jn(this,"clear")}},Ka.prototype.find=function(i,s){return this.primary.find(i,s)},Mt(Ka);var r4=0,Ui=function(i,s,f,u,h){if(!(this instanceof Ui))return new Ui(i,s,f,u,h);null==f&&(f=0),Us.call(this,[new ls([new ka("",null)])]),this.first=f,this.scrollTop=this.scrollLeft=0,this.cantEdit=!1,this.cleanGeneration=1,this.modeFrontier=this.highlightFrontier=f;var y=We(f,0);this.sel=x2(y),this.history=new ts(null),this.id=++r4,this.modeOption=s,this.lineSep=u,this.direction="rtl"==h?"rtl":"ltr",this.extend=!1,"string"==typeof i&&(i=this.splitLines(i)),sa(this,{from:y,to:y,text:i}),vt(this,x2(y),st)};Ui.prototype=Gt(Us.prototype,{constructor:Ui,iter:function(i,s,f){f?this.iterN(i-this.first,s-i,f):this.iterN(this.first,this.first+this.size,i)},insert:function(i,s){for(var f=0,u=0;u<s.length;++u)f+=s[u].height;this.insertInner(i-this.first,s,f)},remove:function(i,s){this.removeInner(i-this.first,s)},getValue:function(i){var s=Ai(this,this.first,this.first+this.size);return!1===i?s:s.join(i||this.lineSeparator())},setValue:S1(function(i){var s=We(this.first,0),f=this.first+this.size-1;Ur(this,{from:s,to:We(f,mn(this,f).text.length),text:this.splitLines(i),origin:"setValue",full:!0},!0),this.cm&&k2(this.cm,0,0),vt(this,x2(s),st)}),replaceRange:function(i,s,f,u){ao(this,i,s=Pn(this,s),f=f?Pn(this,f):s,u)},getRange:function(i,s,f){var u=bt(this,Pn(this,i),Pn(this,s));return!1===f?u:u.join(""===f?"":f||this.lineSeparator())},getLine:function(i){var s=this.getLineHandle(i);return s&&s.text},getLineHandle:function(i){if(yt(this,i))return mn(this,i)},getLineNumber:function(i){return Ze(i)},getLineHandleVisualStart:function(i){return"number"==typeof i&&(i=mn(this,i)),w1(i)},lineCount:function(){return this.size},firstLine:function(){return this.first},lastLine:function(){return this.first+this.size-1},clipPos:function(i){return Pn(this,i)},getCursor:function(i){var s=this.sel.primary();return null==i||"head"==i?s.head:"anchor"==i?s.anchor:"end"==i||"to"==i||!1===i?s.to():s.from()},listSelections:function(){return this.sel.ranges},somethingSelected:function(){return this.sel.somethingSelected()},setCursor:S1(function(i,s,f){Qa(this,Pn(this,"number"==typeof i?We(i,s||0):i),null,f)}),setSelection:S1(function(i,s,f){Qa(this,Pn(this,i),Pn(this,s||i),f)}),extendSelection:S1(function(i,s,f){qs(this,Pn(this,i),s&&Pn(this,s),f)}),extendSelections:S1(function(i,s){gc(this,ha(this,i),s)}),extendSelectionsBy:S1(function(i,s){gc(this,ha(this,pi(this.sel.ranges,i)),s)}),setSelections:S1(function(i,s,f){if(i.length){for(var u=[],h=0;h<i.length;h++)u[h]=new St(Pn(this,i[h].anchor),Pn(this,i[h].head||i[h].anchor));null==s&&(s=Math.min(i.length-1,this.sel.primIndex)),vt(this,yi(this.cm,u,s),f)}}),addSelection:S1(function(i,s,f){var u=this.sel.ranges.slice(0);u.push(new St(Pn(this,i),Pn(this,s||i))),vt(this,yi(this.cm,u,u.length-1),f)}),getSelection:function(i){for(var f,s=this.sel.ranges,u=0;u<s.length;u++){var h=bt(this,s[u].from(),s[u].to());f=f?f.concat(h):h}return!1===i?f:f.join(i||this.lineSeparator())},getSelections:function(i){for(var s=[],f=this.sel.ranges,u=0;u<f.length;u++){var h=bt(this,f[u].from(),f[u].to());!1!==i&&(h=h.join(i||this.lineSeparator())),s[u]=h}return s},replaceSelection:function(i,s,f){for(var u=[],h=0;h<this.sel.ranges.length;h++)u[h]=i;this.replaceSelections(u,s,f||"+input")},replaceSelections:S1(function(i,s,f){for(var u=[],h=this.sel,y=0;y<h.ranges.length;y++){var w=h.ranges[y];u[y]={from:w.from(),to:w.to(),text:this.splitLines(i[y]),origin:f}}for(var E=s&&"end"!=s&&function G1(i,s,f){for(var u=[],h=We(i.first,0),y=h,w=0;w<s.length;w++){var E=s[w],I=Yc(E.from,h,y),F=Yc(qr(E),h,y);if(h=E.to,y=F,"around"==f){var J=i.sel.ranges[w],ie=wn(J.head,J.anchor)<0;u[w]=new St(ie?F:I,ie?I:F)}else u[w]=new St(I,I)}return new xa(u,i.sel.primIndex)}(this,u,s),I=u.length-1;I>=0;I--)Ur(this,u[I]);E?vc(this,E):this.cm&&yr(this.cm)}),undo:S1(function(){cs(this,"undo")}),redo:S1(function(){cs(this,"redo")}),undoSelection:S1(function(){cs(this,"undo",!0)}),redoSelection:S1(function(){cs(this,"redo",!0)}),setExtending:function(i){this.extend=i},getExtending:function(){return this.extend},historySize:function(){for(var i=this.history,s=0,f=0,u=0;u<i.done.length;u++)i.done[u].ranges||++s;for(var h=0;h<i.undone.length;h++)i.undone[h].ranges||++f;return{undo:s,redo:f}},clearHistory:function(){var i=this;this.history=new ts(this.history),cr(this,function(s){return s.history=i.history},!0)},markClean:function(){this.cleanGeneration=this.changeGeneration(!0)},changeGeneration:function(i){return i&&(this.history.lastOp=this.history.lastSelOp=this.history.lastOrigin=null),this.history.generation},isClean:function(i){return this.history.generation==(i||this.cleanGeneration)},getHistory:function(){return{done:Do(this.history.done),undone:Do(this.history.undone)}},setHistory:function(i){var s=this.history=new ts(this.history);s.done=Do(i.done.slice(0),null,!0),s.undone=Do(i.undone.slice(0),null,!0)},setGutterMarker:S1(function(i,s,f){return S2(this,i,"gutter",function(u){var h=u.gutterMarkers||(u.gutterMarkers={});return h[s]=f,!f&&Mi(h)&&(u.gutterMarkers=null),!0})}),clearGutter:S1(function(i){var s=this;this.iter(function(f){f.gutterMarkers&&f.gutterMarkers[i]&&S2(s,f,"gutter",function(){return f.gutterMarkers[i]=null,Mi(f.gutterMarkers)&&(f.gutterMarkers=null),!0})})}),lineInfo:function(i){var s;if("number"==typeof i){if(!(yt(this,i)&&(s=i,i=mn(this,i))))return null}else if(null==(s=Ze(i)))return null;return{line:s,handle:i,text:i.text,gutterMarkers:i.gutterMarkers,textClass:i.textClass,bgClass:i.bgClass,wrapClass:i.wrapClass,widgets:i.widgets}},addLineClass:S1(function(i,s,f){return S2(this,i,"gutter"==s?"gutter":"class",function(u){var h="text"==s?"textClass":"background"==s?"bgClass":"gutter"==s?"gutterClass":"wrapClass";if(u[h]){if(fn(f).test(u[h]))return!1;u[h]+=" "+f}else u[h]=f;return!0})}),removeLineClass:S1(function(i,s,f){return S2(this,i,"gutter"==s?"gutter":"class",function(u){var h="text"==s?"textClass":"background"==s?"bgClass":"gutter"==s?"gutterClass":"wrapClass",y=u[h];if(!y)return!1;if(null==f)u[h]=null;else{var w=y.match(fn(f));if(!w)return!1;var E=w.index+w[0].length;u[h]=y.slice(0,w.index)+(w.index&&E!=y.length?" ":"")+y.slice(E)||null}return!0})}),addLineWidget:S1(function(i,s,f){return function ds(i,s,f,u){var h=new To(i,f,u),y=i.cm;return y&&h.noHScroll&&(y.display.alignWidgets=!0),S2(i,s,"widget",function(w){var E=w.widgets||(w.widgets=[]);if(null==h.insertAt?E.push(h):E.splice(Math.min(E.length,Math.max(0,h.insertAt)),0,h),h.line=w,y&&!ji(i,w)){var I=Hi(w)<i.scrollTop;qt(w,w.height+ta(h)),I&&Os(y,h.height),y.curOp.forceUpdate=!0}return!0}),y&&Jn(y,"lineWidgetAdded",y,h,"number"==typeof s?s:Ze(s)),h}(this,i,s,f)}),removeLineWidget:function(i){i.clear()},markText:function(i,s,f){return dr(this,Pn(this,i),Pn(this,s),f,f&&f.type||"range")},setBookmark:function(i,s){var f={replacedWith:s&&(null==s.nodeType?s.widget:s),insertLeft:s&&s.insertLeft,clearWhenEmpty:!1,shared:s&&s.shared,handleMouseEvents:s&&s.handleMouseEvents};return dr(this,i=Pn(this,i),i,f,"bookmark")},findMarksAt:function(i){var s=[],f=mn(this,(i=Pn(this,i)).line).markedSpans;if(f)for(var u=0;u<f.length;++u){var h=f[u];(null==h.from||h.from<=i.ch)&&(null==h.to||h.to>=i.ch)&&s.push(h.marker.parent||h.marker)}return s},findMarks:function(i,s,f){i=Pn(this,i),s=Pn(this,s);var u=[],h=i.line;return this.iter(i.line,s.line+1,function(y){var w=y.markedSpans;if(w)for(var E=0;E<w.length;E++){var I=w[E];!(null!=I.to&&h==i.line&&i.ch>=I.to||null==I.from&&h!=i.line||null!=I.from&&h==s.line&&I.from>=s.ch)&&(!f||f(I.marker))&&u.push(I.marker.parent||I.marker)}++h}),u},getAllMarks:function(){var i=[];return this.iter(function(s){var f=s.markedSpans;if(f)for(var u=0;u<f.length;++u)null!=f[u].from&&i.push(f[u].marker)}),i},posFromIndex:function(i){var s,f=this.first,u=this.lineSeparator().length;return this.iter(function(h){var y=h.text.length+u;if(y>i)return s=i,!0;i-=y,++f}),Pn(this,We(f,s))},indexFromPos:function(i){var s=(i=Pn(this,i)).ch;if(i.line<this.first||i.ch<0)return 0;var f=this.lineSeparator().length;return this.iter(this.first,i.line,function(u){s+=u.text.length+f}),s},copy:function(i){var s=new Ui(Ai(this,this.first,this.first+this.size),this.modeOption,this.first,this.lineSep,this.direction);return s.scrollTop=this.scrollTop,s.scrollLeft=this.scrollLeft,s.sel=this.sel,s.extend=!1,i&&(s.history.undoDepth=this.history.undoDepth,s.setHistory(this.getHistory())),s},linkedDoc:function(i){i||(i={});var s=this.first,f=this.first+this.size;null!=i.from&&i.from>s&&(s=i.from),null!=i.to&&i.to<f&&(f=i.to);var u=new Ui(Ai(this,s,f),i.mode||this.modeOption,s,this.lineSep,this.direction);return i.sharedHist&&(u.history=this.history),(this.linked||(this.linked=[])).push({doc:u,sharedHist:i.sharedHist}),u.linked=[{doc:this,isParent:!0,sharedHist:i.sharedHist}],function ko(i,s){for(var f=0;f<s.length;f++){var u=s[f],h=u.find(),y=i.clipPos(h.from),w=i.clipPos(h.to);if(wn(y,w)){var E=dr(i,y,w,u.primary,u.primary.type);u.markers.push(E),E.parent=u}}}(u,wr(this)),u},unlinkDoc:function(i){if(i instanceof jt&&(i=i.doc),this.linked)for(var s=0;s<this.linked.length;++s)if(this.linked[s].doc==i){this.linked.splice(s,1),i.unlinkDoc(this),yc(wr(this));break}if(i.history==this.history){var u=[i.id];cr(i,function(h){return u.push(h.id)},!0),i.history=new ts(null),i.history.done=Do(this.history.done,u),i.history.undone=Do(this.history.undone,u)}},iterLinkedDocs:function(i){cr(this,i)},getMode:function(){return this.mode},getEditor:function(){return this.cm},splitLines:function(i){return this.lineSep?i.split(this.lineSep):Na(i)},lineSeparator:function(){return this.lineSep||"\n"},setDirection:S1(function(i){"rtl"!=i&&(i="ltr"),i!=this.direction&&(this.direction=i,this.iter(function(s){return s.order=null}),this.cm&&function mc(i){un(i,function(){f3(i),E1(i)})}(this.cm))})}),Ui.prototype.eachLine=Ui.prototype.iter;var zr=0;function o4(i){var s=this;if(s2(s),!Wt(s,i)&&!ia(s.display,i)){_1(i),ye&&(zr=+new Date);var f=n2(s,i,!0),u=i.dataTransfer.files;if(f&&!s.isReadOnly())if(u&&u.length&&window.FileReader&&window.File)for(var h=u.length,y=Array(h),w=0,E=function(){++w==h&&Kn(s,function(){var be={from:f=Pn(s.doc,f),to:f,text:s.doc.splitLines(y.filter(function(Te){return null!=Te}).join(s.doc.lineSeparator())),origin:"paste"};Ur(s.doc,be),vc(s.doc,x2(Pn(s.doc,f),Pn(s.doc,qr(be))))})()},I=function(be,Te){if(s.options.allowDropFileTypes&&-1==Rt(s.options.allowDropFileTypes,be.type))E();else{var Ge=new FileReader;Ge.onerror=function(){return E()},Ge.onload=function(){var an=Ge.result;/[\x00-\x08\x0e-\x1f]{2}/.test(an)||(y[Te]=an),E()},Ge.readAsText(be)}},F=0;F<u.length;F++)I(u[F],F);else{if(s.state.draggingText&&s.doc.sel.contains(f)>-1)return s.state.draggingText(i),void setTimeout(function(){return s.display.input.focus()},20);try{var J=i.dataTransfer.getData("Text");if(J){var ie;if(s.state.draggingText&&!s.state.draggingText.copy&&(ie=s.listSelections()),Va(s.doc,x2(f,f)),ie)for(var _e=0;_e<ie.length;++_e)ao(s.doc,"",ie[_e].anchor,ie[_e].head,"drag");s.replaceSelection(J,"around","paste"),s.display.input.focus()}}catch(be){}}}}function s2(i){i.display.dragCursor&&(i.display.lineSpace.removeChild(i.display.dragCursor),i.display.dragCursor=null)}function _c(i){if(document.getElementsByClassName){for(var s=document.getElementsByClassName("CodeMirror"),f=[],u=0;u<s.length;u++){var h=s[u].CodeMirror;h&&f.push(h)}f.length&&f[0].operation(function(){for(var y=0;y<f.length;y++)i(f[y])})}}var Po=!1;function h3(){Po||(function s4(){var i;jn(window,"resize",function(){null==i&&(i=setTimeout(function(){i=null,_c(g3)},100))}),jn(window,"blur",function(){return _c(T2)})}(),Po=!0)}function g3(i){var s=i.display;s.cachedCharWidth=s.cachedTextHeight=s.cachedPaddingH=null,s.scrollbarsClipped=!1,i.setSize()}for(var _i={3:"Pause",8:"Backspace",9:"Tab",13:"Enter",16:"Shift",17:"Ctrl",18:"Alt",19:"Pause",20:"CapsLock",27:"Esc",32:"Space",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"Left",38:"Up",39:"Right",40:"Down",44:"PrintScrn",45:"Insert",46:"Delete",59:";",61:"=",91:"Mod",92:"Mod",93:"Mod",106:"*",107:"=",109:"-",110:".",111:"/",145:"ScrollLock",173:"-",186:";",187:"=",188:",",189:"-",190:".",191:"/",192:"`",219:"[",220:"\\",221:"]",222:"'",224:"Mod",63232:"Up",63233:"Down",63234:"Left",63235:"Right",63272:"Delete",63273:"Home",63275:"End",63276:"PageUp",63277:"PageDown",63302:"Insert"},Wr=0;Wr<10;Wr++)_i[Wr+48]=_i[Wr+96]=String(Wr);for(var oo=65;oo<=90;oo++)_i[oo]=String.fromCharCode(oo);for(var fs=1;fs<=12;fs++)_i[fs+111]=_i[fs+63235]="F"+fs;var c2={};function v3(i){var s=i.split(/-(?!$)/);i=s[s.length-1];for(var f,u,h,y,w=0;w<s.length-1;w++){var E=s[w];if(/^(cmd|meta|m)$/i.test(E))y=!0;else if(/^a(lt)?$/i.test(E))f=!0;else if(/^(c|ctrl|control)$/i.test(E))u=!0;else{if(!/^s(hift)?$/i.test(E))throw new Error("Unrecognized modifier name: "+E);h=!0}}return f&&(i="Alt-"+i),u&&(i="Ctrl-"+i),y&&(i="Cmd-"+i),h&&(i="Shift-"+i),i}function b3(i){var s={};for(var f in i)if(i.hasOwnProperty(f)){var u=i[f];if(/^(name|fallthrough|(de|at)tach)$/.test(f))continue;if("..."==u){delete i[f];continue}for(var h=pi(f.split(" "),v3),y=0;y<h.length;y++){var w=void 0,E=void 0;y==h.length-1?(E=h.join(" "),w=u):(E=h.slice(0,y+1).join(" "),w="...");var I=s[E];if(I){if(I!=w)throw new Error("Inconsistent bindings for "+E)}else s[E]=w}delete i[f]}for(var F in s)i[F]=s[F];return i}function Zr(i,s,f,u){var h=(s=ms(s)).call?s.call(i,u):s[i];if(!1===h)return"nothing";if("..."===h)return"multi";if(null!=h&&f(h))return"handled";if(s.fallthrough){if("[object Array]"!=Object.prototype.toString.call(s.fallthrough))return Zr(i,s.fallthrough,f,u);for(var y=0;y<s.fallthrough.length;y++){var w=Zr(i,s.fallthrough[y],f,u);if(w)return w}}}function ps(i){var s="string"==typeof i?i:_i[i.keyCode];return"Ctrl"==s||"Alt"==s||"Shift"==s||"Mod"==s}function xc(i,s,f){var u=i;return s.altKey&&"Alt"!=u&&(i="Alt-"+i),(ut?s.metaKey:s.ctrlKey)&&"Ctrl"!=u&&(i="Ctrl-"+i),(ut?s.ctrlKey:s.metaKey)&&"Mod"!=u&&(i="Cmd-"+i),!f&&s.shiftKey&&"Shift"!=u&&(i="Shift-"+i),i}function Cc(i,s){if(le&&34==i.keyCode&&i.char)return!1;var f=_i[i.keyCode];return null!=f&&!i.altGraphKey&&(3==i.keyCode&&i.code&&(f=i.code),xc(f,i,s))}function ms(i){return"string"==typeof i?c2[i]:i}function so(i,s){for(var f=i.doc.sel.ranges,u=[],h=0;h<f.length;h++){for(var y=s(f[h]);u.length&&wn(y.from,qn(u).to)<=0;){var w=u.pop();if(wn(w.from,y.from)<0){y.from=w.from;break}}u.push(y)}un(i,function(){for(var E=u.length-1;E>=0;E--)ao(i.doc,"",u[E].from,u[E].to,"+delete");yr(i)})}function Gs(i,s,f){var u=wi(i.text,s+f,f);return u<0||u>i.text.length?null:u}function Sc(i,s,f){var u=Gs(i,s.ch,f);return null==u?null:new We(s.line,u,f<0?"after":"before")}function co(i,s,f,u,h){if(i){"rtl"==s.doc.direction&&(h=-h);var y=sn(f,s.doc.direction);if(y){var F,w=h<0?qn(y):y[0],I=h<0==(1==w.level)?"after":"before";if(w.level>0||"rtl"==s.doc.direction){var J=h2(s,f),ie=_a(s,J,F=h<0?f.text.length-1:0).top;F=Rn(function(_e){return _a(s,J,_e).top==ie},h<0==(1==w.level)?w.from:w.to-1,F),"before"==I&&(F=Gs(f,F,1))}else F=h<0?w.to:w.from;return new We(u,F,I)}}return new We(u,h<0?f.text.length:0,h<0?"before":"after")}c2.basic={Left:"goCharLeft",Right:"goCharRight",Up:"goLineUp",Down:"goLineDown",End:"goLineEnd",Home:"goLineStartSmart",PageUp:"goPageUp",PageDown:"goPageDown",Delete:"delCharAfter",Backspace:"delCharBefore","Shift-Backspace":"delCharBefore",Tab:"defaultTab","Shift-Tab":"indentAuto",Enter:"newlineAndIndent",Insert:"toggleOverwrite",Esc:"singleSelection"},c2.pcDefault={"Ctrl-A":"selectAll","Ctrl-D":"deleteLine","Ctrl-Z":"undo","Shift-Ctrl-Z":"redo","Ctrl-Y":"redo","Ctrl-Home":"goDocStart","Ctrl-End":"goDocEnd","Ctrl-Up":"goLineUp","Ctrl-Down":"goLineDown","Ctrl-Left":"goGroupLeft","Ctrl-Right":"goGroupRight","Alt-Left":"goLineStart","Alt-Right":"goLineEnd","Ctrl-Backspace":"delGroupBefore","Ctrl-Delete":"delGroupAfter","Ctrl-S":"save","Ctrl-F":"find","Ctrl-G":"findNext","Shift-Ctrl-G":"findPrev","Shift-Ctrl-F":"replace","Shift-Ctrl-R":"replaceAll","Ctrl-[":"indentLess","Ctrl-]":"indentMore","Ctrl-U":"undoSelection","Shift-Ctrl-U":"redoSelection","Alt-U":"redoSelection",fallthrough:"basic"},c2.emacsy={"Ctrl-F":"goCharRight","Ctrl-B":"goCharLeft","Ctrl-P":"goLineUp","Ctrl-N":"goLineDown","Ctrl-A":"goLineStart","Ctrl-E":"goLineEnd","Ctrl-V":"goPageDown","Shift-Ctrl-V":"goPageUp","Ctrl-D":"delCharAfter","Ctrl-H":"delCharBefore","Alt-Backspace":"delWordBefore","Ctrl-K":"killLine","Ctrl-T":"transposeChars","Ctrl-O":"openLine"},c2.macDefault={"Cmd-A":"selectAll","Cmd-D":"deleteLine","Cmd-Z":"undo","Shift-Cmd-Z":"redo","Cmd-Y":"redo","Cmd-Home":"goDocStart","Cmd-Up":"goDocStart","Cmd-End":"goDocEnd","Cmd-Down":"goDocEnd","Alt-Left":"goGroupLeft","Alt-Right":"goGroupRight","Cmd-Left":"goLineLeft","Cmd-Right":"goLineRight","Alt-Backspace":"delGroupBefore","Ctrl-Alt-Backspace":"delGroupAfter","Alt-Delete":"delGroupAfter","Cmd-S":"save","Cmd-F":"find","Cmd-G":"findNext","Shift-Cmd-G":"findPrev","Cmd-Alt-F":"replace","Shift-Cmd-Alt-F":"replaceAll","Cmd-[":"indentLess","Cmd-]":"indentMore","Cmd-Backspace":"delWrappedLineLeft","Cmd-Delete":"delWrappedLineRight","Cmd-U":"undoSelection","Shift-Cmd-U":"redoSelection","Ctrl-Up":"goDocStart","Ctrl-Down":"goDocEnd",fallthrough:["basic","emacsy"]},c2.default=Qe?c2.macDefault:c2.pcDefault;var er={selectAll:ss,singleSelection:function(i){return i.setSelection(i.getCursor("anchor"),i.getCursor("head"),st)},killLine:function(i){return so(i,function(s){if(s.empty()){var f=mn(i.doc,s.head.line).text.length;return s.head.ch==f&&s.head.line<i.lastLine()?{from:s.head,to:We(s.head.line+1,0)}:{from:s.head,to:We(s.head.line,f)}}return{from:s.from(),to:s.to()}})},deleteLine:function(i){return so(i,function(s){return{from:We(s.from().line,0),to:Pn(i.doc,We(s.to().line+1,0))}})},delLineLeft:function(i){return so(i,function(s){return{from:We(s.from().line,0),to:s.from()}})},delWrappedLineLeft:function(i){return so(i,function(s){var f=i.charCoords(s.head,"div").top+5;return{from:i.coordsChar({left:0,top:f},"div"),to:s.from()}})},delWrappedLineRight:function(i){return so(i,function(s){var f=i.charCoords(s.head,"div").top+5,u=i.coordsChar({left:i.display.lineDiv.offsetWidth+100,top:f},"div");return{from:s.from(),to:u}})},undo:function(i){return i.undo()},redo:function(i){return i.redo()},undoSelection:function(i){return i.undoSelection()},redoSelection:function(i){return i.redoSelection()},goDocStart:function(i){return i.extendSelection(We(i.firstLine(),0))},goDocEnd:function(i){return i.extendSelection(We(i.lastLine()))},goLineStart:function(i){return i.extendSelectionsBy(function(s){return Io(i,s.head.line)},{origin:"+move",bias:1})},goLineStartSmart:function(i){return i.extendSelectionsBy(function(s){return Mc(i,s.head)},{origin:"+move",bias:1})},goLineEnd:function(i){return i.extendSelectionsBy(function(s){return function Oo(i,s){var f=mn(i.doc,s),u=function Jr(i){for(var s;s=na(i);)i=s.find(1,!0).line;return i}(f);return u!=f&&(s=Ze(u)),co(!0,i,f,s,-1)}(i,s.head.line)},{origin:"+move",bias:-1})},goLineRight:function(i){return i.extendSelectionsBy(function(s){var f=i.cursorCoords(s.head,"div").top+5;return i.coordsChar({left:i.display.lineDiv.offsetWidth+100,top:f},"div")},Lt)},goLineLeft:function(i){return i.extendSelectionsBy(function(s){var f=i.cursorCoords(s.head,"div").top+5;return i.coordsChar({left:0,top:f},"div")},Lt)},goLineLeftSmart:function(i){return i.extendSelectionsBy(function(s){var f=i.cursorCoords(s.head,"div").top+5,u=i.coordsChar({left:0,top:f},"div");return u.ch<i.getLine(u.line).search(/\S/)?Mc(i,s.head):u},Lt)},goLineUp:function(i){return i.moveV(-1,"line")},goLineDown:function(i){return i.moveV(1,"line")},goPageUp:function(i){return i.moveV(-1,"page")},goPageDown:function(i){return i.moveV(1,"page")},goCharLeft:function(i){return i.moveH(-1,"char")},goCharRight:function(i){return i.moveH(1,"char")},goColumnLeft:function(i){return i.moveH(-1,"column")},goColumnRight:function(i){return i.moveH(1,"column")},goWordLeft:function(i){return i.moveH(-1,"word")},goGroupRight:function(i){return i.moveH(1,"group")},goGroupLeft:function(i){return i.moveH(-1,"group")},goWordRight:function(i){return i.moveH(1,"word")},delCharBefore:function(i){return i.deleteH(-1,"codepoint")},delCharAfter:function(i){return i.deleteH(1,"char")},delWordBefore:function(i){return i.deleteH(-1,"word")},delWordAfter:function(i){return i.deleteH(1,"word")},delGroupBefore:function(i){return i.deleteH(-1,"group")},delGroupAfter:function(i){return i.deleteH(1,"group")},indentAuto:function(i){return i.indentSelection("smart")},indentMore:function(i){return i.indentSelection("add")},indentLess:function(i){return i.indentSelection("subtract")},insertTab:function(i){return i.replaceSelection("\t")},insertSoftTab:function(i){for(var s=[],f=i.listSelections(),u=i.options.tabSize,h=0;h<f.length;h++){var y=f[h].from(),w=Ln(i.getLine(y.line),y.ch,u);s.push(y1(u-w%u))}i.replaceSelections(s)},defaultTab:function(i){i.somethingSelected()?i.indentSelection("add"):i.execCommand("insertTab")},transposeChars:function(i){return un(i,function(){for(var s=i.listSelections(),f=[],u=0;u<s.length;u++)if(s[u].empty()){var h=s[u].head,y=mn(i.doc,h.line).text;if(y)if(h.ch==y.length&&(h=new We(h.line,h.ch-1)),h.ch>0)h=new We(h.line,h.ch+1),i.replaceRange(y.charAt(h.ch-1)+y.charAt(h.ch-2),We(h.line,h.ch-2),h,"+transpose");else if(h.line>i.doc.first){var w=mn(i.doc,h.line-1).text;w&&(h=new We(h.line,1),i.replaceRange(y.charAt(0)+i.doc.lineSeparator()+w.charAt(w.length-1),We(h.line-1,w.length-1),h,"+transpose"))}f.push(new St(h,h))}i.setSelections(f)})},newlineAndIndent:function(i){return un(i,function(){for(var s=i.listSelections(),f=s.length-1;f>=0;f--)i.replaceRange(i.doc.lineSeparator(),s[f].anchor,s[f].head,"+input");s=i.listSelections();for(var u=0;u<s.length;u++)i.indentLine(s[u].from().line,null,!0);yr(i)})},openLine:function(i){return i.replaceSelection("\n","start")},toggleOverwrite:function(i){return i.toggleOverwrite()}};function Io(i,s){var f=mn(i.doc,s),u=w1(f);return u!=f&&(s=Ze(u)),co(!0,i,u,s,1)}function Mc(i,s){var f=Io(i,s.line),u=mn(i.doc,f.line),h=sn(u,i.doc.direction);if(!h||0==h[0].level){var y=Math.max(f.ch,u.text.search(/\S/));return We(f.line,s.line==f.line&&s.ch<=y&&s.ch?0:y,f.sticky)}return f}function lo(i,s,f){if("string"==typeof s&&!(s=er[s]))return!1;i.display.input.ensurePolled();var u=i.display.shift,h=!1;try{i.isReadOnly()&&(i.state.suppressEdits=!0),f&&(i.display.shift=!1),h=s(i)!=Bt}finally{i.display.shift=u,i.state.suppressEdits=!1}return h}var Tl=new lt;function Ws(i,s,f,u){var h=i.state.keySeq;if(h){if(ps(s))return"handled";if(/\'$/.test(s)?i.state.keySeq=null:Tl.set(50,function(){i.state.keySeq==h&&(i.state.keySeq=null,i.display.input.reset())}),Zs(i,h+" "+s,f,u))return!0}return Zs(i,s,f,u)}function Zs(i,s,f,u){var h=function Ll(i,s,f){for(var u=0;u<i.state.keyMaps.length;u++){var h=Zr(s,i.state.keyMaps[u],f,i);if(h)return h}return i.options.extraKeys&&Zr(s,i.options.extraKeys,f,i)||Zr(s,i.options.keyMap,f,i)}(i,s,u);return"multi"==h&&(i.state.keySeq=s),"handled"==h&&Jn(i,"keyHandled",i,s,f),("handled"==h||"multi"==h)&&(_1(f),a2(i)),!!h}function $s(i,s){var f=Cc(s,!0);return!!f&&(s.shiftKey&&!i.state.keySeq?Ws(i,"Shift-"+f,s,function(u){return lo(i,u,!0)})||Ws(i,f,s,function(u){if("string"==typeof u?/^go[A-Z]/.test(u):u.motion)return lo(i,u)}):Ws(i,f,s,function(u){return lo(i,u)}))}var l4=null;function y3(i){var s=this;if(!(i.target&&i.target!=s.display.input.getField()||(s.curOp.focus=Le(),Wt(s,i)))){ye&&he<11&&27==i.keyCode&&(i.returnValue=!1);var f=i.keyCode;s.display.shift=16==f||i.shiftKey;var u=$s(s,i);le&&(l4=u?f:null,!u&&88==f&&!de&&(Qe?i.metaKey:i.ctrlKey)&&s.replaceSelection("",null,"cut")),M&&!Qe&&!u&&46==f&&i.shiftKey&&!i.ctrlKey&&document.execCommand&&document.execCommand("cut"),18==f&&!/\bCodeMirror-crosshair\b/.test(s.display.lineDiv.className)&&function d4(i){var s=i.display.lineDiv;function f(u){(18==u.keyCode||!u.altKey)&&(g1(s,"CodeMirror-crosshair"),On(document,"keyup",f),On(document,"mouseover",f))}De(s,"CodeMirror-crosshair"),jn(document,"keyup",f),jn(document,"mouseover",f)}(s)}}function u4(i){16==i.keyCode&&(this.doc.sel.shift=!1),Wt(this,i)}function f4(i){var s=this;if(!(i.target&&i.target!=s.display.input.getField()||ia(s.display,i)||Wt(s,i)||i.ctrlKey&&!i.altKey||Qe&&i.metaKey)){var f=i.keyCode,u=i.charCode;if(le&&f==l4)return l4=null,void _1(i);if(!le||i.which&&!(i.which<10)||!$s(s,i)){var h=String.fromCharCode(null==u?f:u);"\b"!=h&&(function wc(i,s,f){return Ws(i,"'"+f+"'",s,function(u){return lo(i,u,!0)})}(s,i,h)||s.display.input.onKeyPress(i))}}}var Vo,uo,zc=function(i,s,f){this.time=i,this.pos=s,this.button=f};function hs(i){var s=this,f=s.display;if(!(Wt(s,i)||f.activeTouch&&f.input.supportsTouch())){if(f.input.ensurePolled(),f.shift=i.shiftKey,ia(f,i))return void(oe||(f.scroller.draggable=!1,setTimeout(function(){return f.scroller.draggable=!0},100)));if(!Nc(s,i)){var u=n2(s,i),h=Ni(i),y=u?function x3(i,s){var f=+new Date;return uo&&uo.compare(f,i,s)?(Vo=uo=null,"triple"):Vo&&Vo.compare(f,i,s)?(uo=new zc(f,i,s),Vo=null,"double"):(Vo=new zc(f,i,s),uo=null,"single")}(u,h):"single";window.focus(),1==h&&s.state.selectingText&&s.state.selectingText(i),(!u||!function p4(i,s,f,u,h){var y="Click";return"double"==u?y="Double"+y:"triple"==u&&(y="Triple"+y),Ws(i,xc(y=(1==s?"Left":2==s?"Middle":"Right")+y,h),h,function(w){if("string"==typeof w&&(w=er[w]),!w)return!1;var E=!1;try{i.isReadOnly()&&(i.state.suppressEdits=!0),E=w(i,f)!=Bt}finally{i.state.suppressEdits=!1}return E})}(s,h,u,y,i))&&(1==h?u?function C3(i,s,f,u){ye?setTimeout(Xe(Q2,i),0):i.curOp.focus=Le();var w,h=function si(i,s,f){var u=i.getOption("configureMouse"),h=u?u(i,s,f):{};return null==h.unit&&(h.unit=(ot?f.shiftKey&&f.metaKey:f.altKey)?"rectangle":"single"==s?"char":"double"==s?"word":"line"),(null==h.extend||i.doc.extend)&&(h.extend=i.doc.extend||f.shiftKey),null==h.addNew&&(h.addNew=Qe?f.metaKey:f.ctrlKey),null==h.moveOnDrag&&(h.moveOnDrag=!(Qe?f.altKey:f.ctrlKey)),h}(i,f,u),y=i.doc.sel;i.options.dragDrop&&Di&&!i.isReadOnly()&&"single"==f&&(w=y.contains(s))>-1&&(wn((w=y.ranges[w]).from(),s)<0||s.xRel>0)&&(wn(w.to(),s)>0||s.xRel<0)?function Xs(i,s,f,u){var h=i.display,y=!1,w=Kn(i,function(F){oe&&(h.scroller.draggable=!1),i.state.draggingText=!1,i.state.delayingBlurEvent&&(i.hasFocus()?i.state.delayingBlurEvent=!1:J2(i)),On(h.wrapper.ownerDocument,"mouseup",w),On(h.wrapper.ownerDocument,"mousemove",E),On(h.scroller,"dragstart",I),On(h.scroller,"drop",w),y||(_1(F),u.addNew||qs(i.doc,f,null,null,u.extend),oe&&!pe||ye&&9==he?setTimeout(function(){h.wrapper.ownerDocument.body.focus({preventScroll:!0}),h.input.focus()},20):h.input.focus())}),E=function(F){y=y||Math.abs(s.clientX-F.clientX)+Math.abs(s.clientY-F.clientY)>=10},I=function(){return y=!0};oe&&(h.scroller.draggable=!0),i.state.draggingText=w,w.copy=!u.moveOnDrag,jn(h.wrapper.ownerDocument,"mouseup",w),jn(h.wrapper.ownerDocument,"mousemove",E),jn(h.scroller,"dragstart",I),jn(h.scroller,"drop",w),i.state.delayingBlurEvent=!0,setTimeout(function(){return h.input.focus()},20),h.scroller.dragDrop&&h.scroller.dragDrop()}(i,u,s,h):function m4(i,s,f,u){ye&&J2(i);var h=i.display,y=i.doc;_1(s);var w,E,I=y.sel,F=I.ranges;if(u.addNew&&!u.extend?(E=y.sel.contains(f),w=E>-1?F[E]:new St(f,f)):(w=y.sel.primary(),E=y.sel.primIndex),"rectangle"==u.unit)u.addNew||(w=new St(f,f)),f=n2(i,s,!0,!0),E=-1;else{var J=Ys(i,f,u.unit);w=u.extend?hc(w,J.anchor,J.head,u.extend):J}u.addNew?-1==E?(E=F.length,vt(y,yi(i,F.concat([w]),E),{scroll:!1,origin:"*mouse"})):F.length>1&&F[E].empty()&&"char"==u.unit&&!u.extend?(vt(y,yi(i,F.slice(0,E).concat(F.slice(E+1)),0),{scroll:!1,origin:"*mouse"}),I=y.sel):Eo(y,E,w,zt):(E=0,vt(y,new xa([w],0),zt),I=y.sel);var ie=f;function _e(gn){if(0!=wn(ie,gn))if(ie=gn,"rectangle"==u.unit){for(var Nn=[],Wn=i.options.tabSize,Bn=Ln(mn(y,f.line).text,f.ch,Wn),Et=Ln(mn(y,gn.line).text,gn.ch,Wn),t1=Math.min(Bn,Et),ci=Math.max(Bn,Et),F1=Math.min(f.line,gn.line),nr=Math.min(i.lastLine(),Math.max(f.line,gn.line));F1<=nr;F1++){var la=mn(y,F1).text,li=$i(la,t1,Wn);t1==ci?Nn.push(new St(We(F1,li),We(F1,li))):la.length>li&&Nn.push(new St(We(F1,li),We(F1,$i(la,ci,Wn))))}Nn.length||Nn.push(new St(f,f)),vt(y,yi(i,I.ranges.slice(0,E).concat(Nn),E),{origin:"*mouse",scroll:!1}),i.scrollIntoView(gn)}else{var di,Ha=w,Wi=Ys(i,gn,u.unit),xi=Ha.anchor;wn(Wi.anchor,xi)>0?(di=Wi.head,xi=d1(Ha.from(),Wi.anchor)):(di=Wi.anchor,xi=J1(Ha.to(),Wi.head));var Q1=I.ranges.slice(0);Q1[E]=function S3(i,s){var f=s.anchor,u=s.head,h=mn(i.doc,f.line);if(0==wn(f,u)&&f.sticky==u.sticky)return s;var y=sn(h);if(!y)return s;var w=on(y,f.ch,f.sticky),E=y[w];if(E.from!=f.ch&&E.to!=f.ch)return s;var F,I=w+(E.from==f.ch==(1!=E.level)?0:1);if(0==I||I==y.length)return s;if(u.line!=f.line)F=(u.line-f.line)*("ltr"==i.doc.direction?1:-1)>0;else{var J=on(y,u.ch,u.sticky),ie=J-w||(u.ch-f.ch)*(1==E.level?-1:1);F=J==I-1||J==I?ie<0:ie>0}var _e=y[I+(F?-1:0)],be=F==(1==_e.level),Te=be?_e.from:_e.to,Ge=be?"after":"before";return f.ch==Te&&f.sticky==Ge?s:new St(new We(f.line,Te,Ge),u)}(i,new St(Pn(y,xi),di)),vt(y,yi(i,Q1,E),zt)}}var be=h.wrapper.getBoundingClientRect(),Te=0;function Ge(gn){var Nn=++Te,Wn=n2(i,gn,!0,"rectangle"==u.unit);if(Wn)if(0!=wn(Wn,ie)){i.curOp.focus=Le(),_e(Wn);var Bn=K2(h,y);(Wn.line>=Bn.to||Wn.line<Bn.from)&&setTimeout(Kn(i,function(){Te==Nn&&Ge(gn)}),150)}else{var Et=gn.clientY<be.top?-20:gn.clientY>be.bottom?20:0;Et&&setTimeout(Kn(i,function(){Te==Nn&&(h.scroller.scrollTop+=Et,Ge(gn))}),50)}}function an(gn){i.state.selectingText=!1,Te=1/0,gn&&(_1(gn),h.input.focus()),On(h.wrapper.ownerDocument,"mousemove",pn),On(h.wrapper.ownerDocument,"mouseup",Cn),y.history.lastSelOrigin=null}var pn=Kn(i,function(gn){0!==gn.buttons&&Ni(gn)?Ge(gn):an(gn)}),Cn=Kn(i,an);i.state.selectingText=Cn,jn(h.wrapper.ownerDocument,"mousemove",pn),jn(h.wrapper.ownerDocument,"mouseup",Cn)}(i,u,s,h)}(s,u,y,i):ma(i)==f.scroller&&_1(i):2==h?(u&&qs(s.doc,u),setTimeout(function(){return f.input.focus()},20)):3==h&&(cn?s.display.input.onContextMenu(i):J2(s)))}}}function Ys(i,s,f){if("char"==f)return new St(s,s);if("word"==f)return i.findWordAt(s);if("line"==f)return new St(We(s.line,0),Pn(i.doc,We(s.line+1,0)));var u=f(i,s);return new St(u.from,u.to)}function h4(i,s,f,u){var h,y;if(s.touches)h=s.touches[0].clientX,y=s.touches[0].clientY;else try{h=s.clientX,y=s.clientY}catch(_e){return!1}if(h>=Math.floor(i.display.gutters.getBoundingClientRect().right))return!1;u&&_1(s);var w=i.display,E=w.lineDiv.getBoundingClientRect();if(y>E.bottom||!gt(i,f))return et(s);y-=E.top-w.viewOffset;for(var I=0;I<i.display.gutterSpecs.length;++I){var F=w.gutters.childNodes[I];if(F&&F.getBoundingClientRect().right>=h)return ht(i,f,i,Gn(i.doc,y),i.display.gutterSpecs[I].className,s),et(s)}}function Nc(i,s){return h4(i,s,"gutterClick",!0)}function g4(i,s){ia(i.display,s)||function v4(i,s){return!!gt(i,"gutterContextMenu")&&h4(i,s,"gutterContextMenu",!1)}(i,s)||Wt(i,s,"contextmenu")||cn||i.display.input.onContextMenu(s)}function M3(i){i.display.wrapper.className=i.display.wrapper.className.replace(/\s*cm-s-\S+/g,"")+i.options.theme.replace(/(^|\s)\s*/g," cm-s-"),Fe(i)}zc.prototype.compare=function(i,s,f){return this.time+400>i&&0==wn(s,this.pos)&&f==this.button};var gs={toString:function(){return"CodeMirror.Init"}},Ho={},Gi={};function y4(i,s,f){if(!s!=!(f&&f!=gs)){var h=i.display.dragFunctions,y=s?jn:On;y(i.display.scroller,"dragstart",h.start),y(i.display.scroller,"dragenter",h.enter),y(i.display.scroller,"dragover",h.over),y(i.display.scroller,"dragleave",h.leave),y(i.display.scroller,"drop",h.drop)}}function _4(i){i.options.lineWrapping?(De(i.display.wrapper,"CodeMirror-wrap"),i.display.sizer.style.minWidth="",i.display.sizerWidth=null):(g1(i.display.wrapper,"CodeMirror-wrap"),Wa(i)),Co(i),E1(i),Fe(i),setTimeout(function(){return Rr(i)},100)}function jt(i,s){var f=this;if(!(this instanceof jt))return new jt(i,s);this.options=s=s?En(s):{},En(Ho,s,!1);var u=s.value;"string"==typeof u?u=new Ui(u,s.mode,null,s.lineSeparator,s.direction):s.mode&&(u.modeOption=s.mode),this.doc=u;var h=new jt.inputStyles[s.inputStyle](this),y=this.display=new ns(i,u,h,s);for(var w in y.wrapper.CodeMirror=this,M3(this),s.lineWrapping&&(this.display.wrapper.className+=" CodeMirror-wrap"),x(this),this.state={keyMaps:[],overlays:[],modeGen:0,overwrite:!1,delayingBlurEvent:!1,focused:!1,suppressEdits:!1,pasteIncoming:-1,cutIncoming:-1,selectingText:!1,draggingText:!1,highlight:new lt,keySeq:null,specialChars:null},s.autofocus&&!Ke&&y.input.focus(),ye&&he<11&&setTimeout(function(){return f.display.input.reset(!0)},20),function vs(i){var s=i.display;jn(s.scroller,"mousedown",Kn(i,hs)),jn(s.scroller,"dblclick",ye&&he<11?Kn(i,function(I){if(!Wt(i,I)){var F=n2(i,I);if(F&&!Nc(i,I)&&!ia(i.display,I)){_1(I);var J=i.findWordAt(F);qs(i.doc,J.anchor,J.head)}}}):function(I){return Wt(i,I)||_1(I)}),jn(s.scroller,"contextmenu",function(I){return g4(i,I)}),jn(s.input.getField(),"contextmenu",function(I){s.scroller.contains(I.target)||g4(i,I)});var f,u={end:0};function h(){s.activeTouch&&(f=setTimeout(function(){return s.activeTouch=null},1e3),(u=s.activeTouch).end=+new Date)}function y(I){if(1!=I.touches.length)return!1;var F=I.touches[0];return F.radiusX<=1&&F.radiusY<=1}function w(I,F){if(null==F.left)return!0;var J=F.left-I.left,ie=F.top-I.top;return J*J+ie*ie>400}jn(s.scroller,"touchstart",function(I){if(!Wt(i,I)&&!y(I)&&!Nc(i,I)){s.input.ensurePolled(),clearTimeout(f);var F=+new Date;s.activeTouch={start:F,moved:!1,prev:F-u.end<=300?u:null},1==I.touches.length&&(s.activeTouch.left=I.touches[0].pageX,s.activeTouch.top=I.touches[0].pageY)}}),jn(s.scroller,"touchmove",function(){s.activeTouch&&(s.activeTouch.moved=!0)}),jn(s.scroller,"touchend",function(I){var F=s.activeTouch;if(F&&!ia(s,I)&&null!=F.left&&!F.moved&&new Date-F.start<300){var ie,J=i.coordsChar(s.activeTouch,"page");ie=!F.prev||w(F,F.prev)?new St(J,J):!F.prev.prev||w(F,F.prev.prev)?i.findWordAt(J):new St(We(J.line,0),Pn(i.doc,We(J.line+1,0))),i.setSelection(ie.anchor,ie.head),i.focus(),_1(I)}h()}),jn(s.scroller,"touchcancel",h),jn(s.scroller,"scroll",function(){s.scroller.clientHeight&&(b2(i,s.scroller.scrollTop),or(i,s.scroller.scrollLeft,!0),ht(i,"scroll",i))}),jn(s.scroller,"mousewheel",function(I){return _2(i,I)}),jn(s.scroller,"DOMMouseScroll",function(I){return _2(i,I)}),jn(s.wrapper,"scroll",function(){return s.wrapper.scrollTop=s.wrapper.scrollLeft=0}),s.dragFunctions={enter:function(I){Wt(i,I)||k1(I)},over:function(I){Wt(i,I)||(function us(i,s){var f=n2(i,s);if(f){var u=document.createDocumentFragment();br(i,f,u),i.display.dragCursor||(i.display.dragCursor=tn("div",null,"CodeMirror-cursors CodeMirror-dragcursors"),i.display.lineSpace.insertBefore(i.display.dragCursor,i.display.cursorDiv)),l1(i.display.dragCursor,u)}}(i,I),k1(I))},start:function(I){return function Gr(i,s){if(ye&&(!i.state.draggingText||+new Date-zr<100))k1(s);else if(!Wt(i,s)&&!ia(i.display,s)&&(s.dataTransfer.setData("Text",i.getSelection()),s.dataTransfer.effectAllowed="copyMove",s.dataTransfer.setDragImage&&!pe)){var f=tn("img",null,null,"position: fixed; left: 0; top: 0;");f.src="data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==",le&&(f.width=f.height=1,i.display.wrapper.appendChild(f),f._top=f.offsetTop),s.dataTransfer.setDragImage(f,0,0),le&&f.parentNode.removeChild(f)}}(i,I)},drop:Kn(i,o4),leave:function(I){Wt(i,I)||s2(i)}};var E=s.input.getField();jn(E,"keyup",function(I){return u4.call(i,I)}),jn(E,"keydown",Kn(i,y3)),jn(E,"keypress",Kn(i,f4)),jn(E,"focus",function(I){return So(i,I)}),jn(E,"blur",function(I){return T2(i,I)})}(this),h3(),T(this),this.curOp.forceUpdate=!0,to(this,u),s.autofocus&&!Ke||this.hasFocus()?setTimeout(function(){f.hasFocus()&&!f.state.focused&&So(f)},20):T2(this),Gi)Gi.hasOwnProperty(w)&&Gi[w](this,s[w],gs);u3(this),s.finishInit&&s.finishInit(this);for(var E=0;E<bs.length;++E)bs[E](this);V(this),oe&&s.lineWrapping&&"optimizelegibility"==getComputedStyle(y.lineDiv).textRendering&&(y.lineDiv.style.textRendering="auto")}jt.defaults=Ho,jt.optionHandlers=Gi;var bs=[];function ys(i,s,f,u){var y,h=i.doc;null==f&&(f="add"),"smart"==f&&(h.mode.indent?y=o1(i,s).state:f="prev");var w=i.options.tabSize,E=mn(h,s),I=Ln(E.text,null,w);E.stateAfter&&(E.stateAfter=null);var J,F=E.text.match(/^\s*/)[0];if(u||/\S/.test(E.text)){if("smart"==f&&((J=h.mode.indent(y,E.text.slice(F.length),E.text))==Bt||J>150)){if(!u)return;f="prev"}}else J=0,f="not";"prev"==f?J=s>h.first?Ln(mn(h,s-1).text,null,w):0:"add"==f?J=I+i.options.indentUnit:"subtract"==f?J=I-i.options.indentUnit:"number"==typeof f&&(J=I+f),J=Math.max(0,J);var ie="",_e=0;if(i.options.indentWithTabs)for(var be=Math.floor(J/w);be;--be)_e+=w,ie+="\t";if(_e<J&&(ie+=y1(J-_e)),ie!=F)return ao(h,ie,We(s,0),We(s,F.length),"+input"),E.stateAfter=null,!0;for(var Te=0;Te<h.sel.ranges.length;Te++){var Ge=h.sel.ranges[Te];if(Ge.head.line==s&&Ge.head.ch<F.length){var an=We(s,F.length);Eo(h,Te,new St(an,an));break}}}jt.defineInitHook=function(i){return bs.push(i)};var Nr=null;function _s(i){Nr=i}function Dc(i,s,f,u,h){var y=i.doc;i.display.shift=!1,u||(u=y.sel);var w=+new Date-200,E="paste"==h||i.state.pasteIncoming>w,I=Na(s),F=null;if(E&&u.ranges.length>1)if(Nr&&Nr.text.join("\n")==s){if(u.ranges.length%Nr.text.length==0){F=[];for(var J=0;J<Nr.text.length;J++)F.push(y.splitLines(Nr.text[J]))}}else I.length==u.ranges.length&&i.options.pasteLinesPerSelection&&(F=pi(I,function(pn){return[pn]}));for(var ie=i.curOp.updateInput,_e=u.ranges.length-1;_e>=0;_e--){var be=u.ranges[_e],Te=be.from(),Ge=be.to();be.empty()&&(f&&f>0?Te=We(Te.line,Te.ch-f):i.state.overwrite&&!E?Ge=We(Ge.line,Math.min(mn(y,Ge.line).text.length,Ge.ch+qn(I).length)):E&&Nr&&Nr.lineWise&&Nr.text.join("\n")==I.join("\n")&&(Te=Ge=We(Te.line,0)));var an={from:Te,to:Ge,text:F?F[_e%F.length]:I,origin:h||(E?"paste":i.state.cutIncoming>w?"cut":"+input")};Ur(i.doc,an),Jn(i,"inputRead",i,an)}s&&!E&&C4(i,s),yr(i),i.curOp.updateInput<2&&(i.curOp.updateInput=ie),i.curOp.typing=!0,i.state.pasteIncoming=i.state.cutIncoming=-1}function x4(i,s){var f=i.clipboardData&&i.clipboardData.getData("Text");if(f)return i.preventDefault(),!s.isReadOnly()&&!s.options.disableInput&&un(s,function(){return Dc(s,f,0,null,"paste")}),!0}function C4(i,s){if(i.options.electricChars&&i.options.smartIndent)for(var f=i.doc.sel,u=f.ranges.length-1;u>=0;u--){var h=f.ranges[u];if(!(h.head.ch>100||u&&f.ranges[u-1].head.line==h.head.line)){var y=i.getModeAt(h.head),w=!1;if(y.electricChars){for(var E=0;E<y.electricChars.length;E++)if(s.indexOf(y.electricChars.charAt(E))>-1){w=ys(i,h.head.line,"smart");break}}else y.electricInput&&y.electricInput.test(mn(i.doc,h.head.line).text.slice(0,h.head.ch))&&(w=ys(i,h.head.line,"smart"));w&&Jn(i,"electricInput",i,h.head.line)}}}function Ec(i){for(var s=[],f=[],u=0;u<i.doc.sel.ranges.length;u++){var h=i.doc.sel.ranges[u].head.line,y={anchor:We(h,0),head:We(h+1,0)};f.push(y),s.push(i.getRange(y.anchor,y.head))}return{text:s,ranges:f}}function S4(i,s,f,u){i.setAttribute("autocorrect",f?"":"off"),i.setAttribute("autocapitalize",u?"":"off"),i.setAttribute("spellcheck",!!s)}function M4(){var i=tn("textarea",null,null,"position: absolute; bottom: -1em; padding: 0; width: 1px; height: 1em; min-height: 1em; outline: none"),s=tn("div",[i],null,"overflow: hidden; position: relative; width: 3px; height: 0px;");return oe?i.style.width="1000px":i.setAttribute("wrap","off"),dn&&(i.style.border="1px solid black"),S4(i),s}function Lc(i,s,f,u,h){var y=s,w=f,E=mn(i,s.line),I=h&&"rtl"==i.direction?-f:f;function J(Cn){var gn;if("codepoint"==u){var Nn=E.text.charCodeAt(s.ch+(f>0?0:-1));gn=isNaN(Nn)?null:new We(s.line,Math.max(0,Math.min(E.text.length,s.ch+f*((f>0?Nn>=55296&&Nn<56320:Nn>=56320&&Nn<57343)?2:1))),-f)}else gn=h?function c4(i,s,f,u){var h=sn(s,i.doc.direction);if(!h)return Sc(s,f,u);f.ch>=s.text.length?(f.ch=s.text.length,f.sticky="before"):f.ch<=0&&(f.ch=0,f.sticky="after");var y=on(h,f.ch,f.sticky),w=h[y];if("ltr"==i.doc.direction&&w.level%2==0&&(u>0?w.to>f.ch:w.from<f.ch))return Sc(s,f,u);var I,E=function(pn,Cn){return Gs(s,pn instanceof We?pn.ch:pn,Cn)},F=function(pn){return i.options.lineWrapping?(I=I||h2(i,s),vi(i,s,I,pn)):{begin:0,end:s.text.length}},J=F("before"==f.sticky?E(f,-1):f.ch);if("rtl"==i.doc.direction||1==w.level){var ie=1==w.level==u<0,_e=E(f,ie?1:-1);if(null!=_e&&(ie?_e<=w.to&&_e<=J.end:_e>=w.from&&_e>=J.begin))return new We(f.line,_e,ie?"before":"after")}var Te=function(pn,Cn,gn){for(;pn>=0&&pn<h.length;pn+=Cn){var Wn=h[pn],Bn=Cn>0==(1!=Wn.level),Et=Bn?gn.begin:E(gn.end,-1);if(Wn.from<=Et&&Et<Wn.to||(Et=Bn?Wn.from:E(Wn.to,-1),gn.begin<=Et&&Et<gn.end))return t1=Et,Bn?new We(f.line,E(t1,1),"before"):new We(f.line,t1,"after")}var t1},Ge=Te(y+u,u,J);if(Ge)return Ge;var an=u>0?J.end:E(J.begin,-1);return null==an||u>0&&an==s.text.length||!(Ge=Te(u>0?0:h.length-1,u,F(an)))?null:Ge}(i.cm,E,s,f):Sc(E,s,f);if(null==gn){if(Cn||!function F(){var Cn=s.line+I;return!(Cn<i.first||Cn>=i.first+i.size)&&(s=new We(Cn,s.ch,s.sticky),E=mn(i,Cn))}())return!1;s=co(h,i.cm,E,s.line,I)}else s=gn;return!0}if("char"==u||"codepoint"==u)J();else if("column"==u)J(!0);else if("word"==u||"group"==u)for(var ie=null,_e="group"==u,be=i.cm&&i.cm.getHelper(s,"wordChars"),Te=!0;!(f<0)||J(!Te);Te=!1){var Ge=E.text.charAt(s.ch)||"\n",an=xt(Ge,be)?"w":_e&&"\n"==Ge?"n":!_e||/\s/.test(Ge)?null:"p";if(_e&&!Te&&!an&&(an="s"),ie&&ie!=an){f<0&&(f=1,J(),s.sticky="after");break}if(an&&(ie=an),f>0&&!J(!Te))break}var pn=C2(i,s,y,w,!0);return mi(y,pn)&&(pn.hitSide=!0),pn}function w3(i,s,f,u){var w,F,h=i.doc,y=s.left;if("page"==u){var E=Math.min(i.display.wrapper.clientHeight,window.innerHeight||document.documentElement.clientHeight),I=Math.max(E-.5*bi(i.display),3);w=(f>0?s.bottom:s.top)+f*I}else"line"==u&&(w=f>0?s.bottom+3:s.top-3);for(;(F=ni(i,y,w)).outside;){if(f<0?w<=0:w>=h.height){F.hitSide=!0;break}w+=5*f}return F}var f1=function(i){this.cm=i,this.lastAnchorNode=this.lastAnchorOffset=this.lastFocusNode=this.lastFocusOffset=null,this.polling=new lt,this.composing=null,this.gracePeriod=!1,this.readDOMTimeout=null};function z3(i,s){var f=Hn(i,s.line);if(!f||f.hidden)return null;var u=mn(i.doc,s.line),h=gi(f,u,s.line),y=sn(u,i.doc.direction),w="left";y&&(w=on(y,s.ch)%2?"right":"left");var I=O(h.map,s.ch,w);return I.offset="right"==I.collapse?I.end:I.start,I}function H2(i,s){return s&&(i.bad=!0),i}function Qs(i,s,f){var u;if(s==i.display.lineDiv){if(!(u=i.display.lineDiv.childNodes[f]))return H2(i.clipPos(We(i.display.viewTo-1)),!0);s=null,f=0}else for(u=s;;u=u.parentNode){if(!u||u==i.display.lineDiv)return null;if(u.parentNode&&u.parentNode==i.display.lineDiv)break}for(var h=0;h<i.display.view.length;h++){var y=i.display.view[h];if(y.node==u)return N3(y,s,f)}}function N3(i,s,f){var u=i.text.firstChild,h=!1;if(!s||!Un(u,s))return H2(We(Ze(i.line),0),!0);if(s==u&&(h=!0,s=u.childNodes[f],f=0,!s)){var y=i.rest?qn(i.rest):i.line;return H2(We(Ze(y),y.text.length),h)}var w=3==s.nodeType?s:null,E=s;for(!w&&1==s.childNodes.length&&3==s.firstChild.nodeType&&(w=s.firstChild,f&&(f=w.nodeValue.length));E.parentNode!=u;)E=E.parentNode;var I=i.measure,F=I.maps;function J(an,pn,Cn){for(var gn=-1;gn<(F?F.length:0);gn++)for(var Nn=gn<0?I.map:F[gn],Wn=0;Wn<Nn.length;Wn+=3){var Bn=Nn[Wn+2];if(Bn==an||Bn==pn){var Et=Ze(gn<0?i.line:i.rest[gn]),t1=Nn[Wn]+Cn;return(Cn<0||Bn!=an)&&(t1=Nn[Wn+(Cn?1:0)]),We(Et,t1)}}}var ie=J(w,E,f);if(ie)return H2(ie,h);for(var _e=E.nextSibling,be=w?w.nodeValue.length-f:0;_e;_e=_e.nextSibling){if(ie=J(_e,_e.firstChild,0))return H2(We(ie.line,ie.ch-be),h);be+=_e.textContent.length}for(var Te=E.previousSibling,Ge=f;Te;Te=Te.previousSibling){if(ie=J(Te,Te.firstChild,-1))return H2(We(ie.line,ie.ch+Ge),h);Ge+=Te.textContent.length}}f1.prototype.init=function(i){var s=this,f=this,u=f.cm,h=f.div=i.lineDiv;function y(E){for(var I=E.target;I;I=I.parentNode){if(I==h)return!0;if(/\bCodeMirror-(?:line)?widget\b/.test(I.className))break}return!1}function w(E){if(y(E)&&!Wt(u,E)){if(u.somethingSelected())_s({lineWise:!1,text:u.getSelections()}),"cut"==E.type&&u.replaceSelection("",null,"cut");else{if(!u.options.lineWiseCopyCut)return;var I=Ec(u);_s({lineWise:!0,text:I.text}),"cut"==E.type&&u.operation(function(){u.setSelections(I.ranges,0,st),u.replaceSelection("",null,"cut")})}if(E.clipboardData){E.clipboardData.clearData();var F=Nr.text.join("\n");if(E.clipboardData.setData("Text",F),E.clipboardData.getData("Text")==F)return void E.preventDefault()}var J=M4(),ie=J.firstChild;u.display.lineSpace.insertBefore(J,u.display.lineSpace.firstChild),ie.value=Nr.text.join("\n");var _e=Le();me(ie),setTimeout(function(){u.display.lineSpace.removeChild(J),_e.focus(),_e==h&&f.showPrimarySelection()},50)}}h.contentEditable=!0,S4(h,u.options.spellcheck,u.options.autocorrect,u.options.autocapitalize),jn(h,"paste",function(E){!y(E)||Wt(u,E)||x4(E,u)||he<=11&&setTimeout(Kn(u,function(){return s.updateFromDOM()}),20)}),jn(h,"compositionstart",function(E){s.composing={data:E.data,done:!1}}),jn(h,"compositionupdate",function(E){s.composing||(s.composing={data:E.data,done:!1})}),jn(h,"compositionend",function(E){s.composing&&(E.data!=s.composing.data&&s.readFromDOMSoon(),s.composing.done=!0)}),jn(h,"touchstart",function(){return f.forceCompositionEnd()}),jn(h,"input",function(){s.composing||s.readFromDOMSoon()}),jn(h,"copy",w),jn(h,"cut",w)},f1.prototype.screenReaderLabelChanged=function(i){i?this.div.setAttribute("aria-label",i):this.div.removeAttribute("aria-label")},f1.prototype.prepareSelection=function(){var i=Ir(this.cm,!1);return i.focus=Le()==this.div,i},f1.prototype.showSelection=function(i,s){!i||!this.cm.display.view.length||((i.focus||s)&&this.showPrimarySelection(),this.showMultipleSelections(i))},f1.prototype.getSelection=function(){return this.cm.display.wrapper.ownerDocument.getSelection()},f1.prototype.showPrimarySelection=function(){var i=this.getSelection(),s=this.cm,f=s.doc.sel.primary(),u=f.from(),h=f.to();if(s.display.viewTo==s.display.viewFrom||u.line>=s.display.viewTo||h.line<s.display.viewFrom)i.removeAllRanges();else{var y=Qs(s,i.anchorNode,i.anchorOffset),w=Qs(s,i.focusNode,i.focusOffset);if(!y||y.bad||!w||w.bad||0!=wn(d1(y,w),u)||0!=wn(J1(y,w),h)){var E=s.display.view,I=u.line>=s.display.viewFrom&&z3(s,u)||{node:E[0].measure.map[2],offset:0},F=h.line<s.display.viewTo&&z3(s,h);if(!F){var J=E[E.length-1].measure,ie=J.maps?J.maps[J.maps.length-1]:J.map;F={node:ie[ie.length-1],offset:ie[ie.length-2]-ie[ie.length-3]}}if(!I||!F)return void i.removeAllRanges();var be,_e=i.rangeCount&&i.getRangeAt(0);try{be=tt(I.node,I.offset,F.offset,F.node)}catch(Te){}be&&(!M&&s.state.focused?(i.collapse(I.node,I.offset),be.collapsed||(i.removeAllRanges(),i.addRange(be))):(i.removeAllRanges(),i.addRange(be)),_e&&null==i.anchorNode?i.addRange(_e):M&&this.startGracePeriod()),this.rememberSelection()}}},f1.prototype.startGracePeriod=function(){var i=this;clearTimeout(this.gracePeriod),this.gracePeriod=setTimeout(function(){i.gracePeriod=!1,i.selectionChanged()&&i.cm.operation(function(){return i.cm.curOp.selectionChanged=!0})},20)},f1.prototype.showMultipleSelections=function(i){l1(this.cm.display.cursorDiv,i.cursors),l1(this.cm.display.selectionDiv,i.selection)},f1.prototype.rememberSelection=function(){var i=this.getSelection();this.lastAnchorNode=i.anchorNode,this.lastAnchorOffset=i.anchorOffset,this.lastFocusNode=i.focusNode,this.lastFocusOffset=i.focusOffset},f1.prototype.selectionInEditor=function(){var i=this.getSelection();if(!i.rangeCount)return!1;var s=i.getRangeAt(0).commonAncestorContainer;return Un(this.div,s)},f1.prototype.focus=function(){"nocursor"!=this.cm.options.readOnly&&((!this.selectionInEditor()||Le()!=this.div)&&this.showSelection(this.prepareSelection(),!0),this.div.focus())},f1.prototype.blur=function(){this.div.blur()},f1.prototype.getField=function(){return this.div},f1.prototype.supportsTouch=function(){return!0},f1.prototype.receivedFocus=function(){var i=this,s=this;this.selectionInEditor()?setTimeout(function(){return i.pollSelection()},20):un(this.cm,function(){return s.cm.curOp.selectionChanged=!0}),this.polling.set(this.cm.options.pollInterval,function f(){s.cm.state.focused&&(s.pollSelection(),s.polling.set(s.cm.options.pollInterval,f))})},f1.prototype.selectionChanged=function(){var i=this.getSelection();return i.anchorNode!=this.lastAnchorNode||i.anchorOffset!=this.lastAnchorOffset||i.focusNode!=this.lastFocusNode||i.focusOffset!=this.lastFocusOffset},f1.prototype.pollSelection=function(){if(null==this.readDOMTimeout&&!this.gracePeriod&&this.selectionChanged()){var i=this.getSelection(),s=this.cm;if(rn&&fe&&this.cm.display.gutterSpecs.length&&function jl(i){for(var s=i;s;s=s.parentNode)if(/CodeMirror-gutter-wrapper/.test(s.className))return!0;return!1}(i.anchorNode))return this.cm.triggerOnKeyDown({type:"keydown",keyCode:8,preventDefault:Math.abs}),this.blur(),void this.focus();if(!this.composing){this.rememberSelection();var f=Qs(s,i.anchorNode,i.anchorOffset),u=Qs(s,i.focusNode,i.focusOffset);f&&u&&un(s,function(){vt(s.doc,x2(f,u),st),(f.bad||u.bad)&&(s.curOp.selectionChanged=!0)})}}},f1.prototype.pollContent=function(){null!=this.readDOMTimeout&&(clearTimeout(this.readDOMTimeout),this.readDOMTimeout=null);var y,w,E,i=this.cm,s=i.display,f=i.doc.sel.primary(),u=f.from(),h=f.to();if(0==u.ch&&u.line>i.firstLine()&&(u=We(u.line-1,mn(i.doc,u.line-1).length)),h.ch==mn(i.doc,h.line).text.length&&h.line<i.lastLine()&&(h=We(h.line+1,0)),u.line<s.viewFrom||h.line>s.viewTo-1)return!1;u.line==s.viewFrom||0==(y=t2(i,u.line))?(w=Ze(s.view[0].line),E=s.view[0].node):(w=Ze(s.view[y].line),E=s.view[y-1].node.nextSibling);var F,J,I=t2(i,h.line);if(I==s.view.length-1?(F=s.viewTo-1,J=s.lineDiv.lastChild):(F=Ze(s.view[I+1].line)-1,J=s.view[I+1].node.previousSibling),!E)return!1;for(var ie=i.doc.splitLines(function kl(i,s,f,u,h){var y="",w=!1,E=i.doc.lineSeparator(),I=!1;function J(){w&&(y+=E,I&&(y+=E),w=I=!1)}function ie(be){be&&(J(),y+=be)}function _e(be){if(1==be.nodeType){var Te=be.getAttribute("cm-text");if(Te)return void ie(Te);var an,Ge=be.getAttribute("cm-marker");if(Ge){var pn=i.findMarks(We(u,0),We(h+1,0),function F(be){return function(Te){return Te.id==be}}(+Ge));return void(pn.length&&(an=pn[0].find(0))&&ie(bt(i.doc,an.from,an.to).join(E)))}if("false"==be.getAttribute("contenteditable"))return;var Cn=/^(pre|div|p|li|table|br)$/i.test(be.nodeName);if(!/^br$/i.test(be.nodeName)&&0==be.textContent.length)return;Cn&&J();for(var gn=0;gn<be.childNodes.length;gn++)_e(be.childNodes[gn]);/^(pre|p)$/i.test(be.nodeName)&&(I=!0),Cn&&(w=!0)}else 3==be.nodeType&&ie(be.nodeValue.replace(/\u200b/g,"").replace(/\u00a0/g," "))}for(;_e(s),s!=f;)s=s.nextSibling,I=!1;return y}(i,E,J,w,F)),_e=bt(i.doc,We(w,0),We(F,mn(i.doc,F).text.length));ie.length>1&&_e.length>1;)if(qn(ie)==qn(_e))ie.pop(),_e.pop(),F--;else{if(ie[0]!=_e[0])break;ie.shift(),_e.shift(),w++}for(var be=0,Te=0,Ge=ie[0],an=_e[0],pn=Math.min(Ge.length,an.length);be<pn&&Ge.charCodeAt(be)==an.charCodeAt(be);)++be;for(var Cn=qn(ie),gn=qn(_e),Nn=Math.min(Cn.length-(1==ie.length?be:0),gn.length-(1==_e.length?be:0));Te<Nn&&Cn.charCodeAt(Cn.length-Te-1)==gn.charCodeAt(gn.length-Te-1);)++Te;if(1==ie.length&&1==_e.length&&w==u.line)for(;be&&be>u.ch&&Cn.charCodeAt(Cn.length-Te-1)==gn.charCodeAt(gn.length-Te-1);)be--,Te++;ie[ie.length-1]=Cn.slice(0,Cn.length-Te).replace(/^\u200b+/,""),ie[0]=ie[0].slice(be).replace(/\u200b+$/,"");var Wn=We(w,be),Bn=We(F,_e.length?qn(_e).length-Te:0);return ie.length>1||ie[0]||wn(Wn,Bn)?(ao(i.doc,ie,Wn,Bn,"+input"),!0):void 0},f1.prototype.ensurePolled=function(){this.forceCompositionEnd()},f1.prototype.reset=function(){this.forceCompositionEnd()},f1.prototype.forceCompositionEnd=function(){!this.composing||(clearTimeout(this.readDOMTimeout),this.composing=null,this.updateFromDOM(),this.div.blur(),this.div.focus())},f1.prototype.readFromDOMSoon=function(){var i=this;null==this.readDOMTimeout&&(this.readDOMTimeout=setTimeout(function(){if(i.readDOMTimeout=null,i.composing){if(!i.composing.done)return;i.composing=null}i.updateFromDOM()},80))},f1.prototype.updateFromDOM=function(){var i=this;(this.cm.isReadOnly()||!this.pollContent())&&un(this.cm,function(){return E1(i.cm)})},f1.prototype.setUneditable=function(i){i.contentEditable="false"},f1.prototype.onKeyPress=function(i){0==i.charCode||this.composing||(i.preventDefault(),this.cm.isReadOnly()||Kn(this.cm,Dc)(this.cm,String.fromCharCode(null==i.charCode?i.keyCode:i.charCode),0))},f1.prototype.readOnlyChanged=function(i){this.div.contentEditable=String("nocursor"!=i)},f1.prototype.onContextMenu=function(){},f1.prototype.resetPosition=function(){},f1.prototype.needsContentAttribute=!0;var ii=function(i){this.cm=i,this.prevInput="",this.pollingFast=!1,this.polling=new lt,this.hasSelection=!1,this.composing=null};ii.prototype.init=function(i){var s=this,f=this,u=this.cm;this.createField(i);var h=this.textarea;function y(w){if(!Wt(u,w)){if(u.somethingSelected())_s({lineWise:!1,text:u.getSelections()});else{if(!u.options.lineWiseCopyCut)return;var E=Ec(u);_s({lineWise:!0,text:E.text}),"cut"==w.type?u.setSelections(E.ranges,null,st):(f.prevInput="",h.value=E.text.join("\n"),me(h))}"cut"==w.type&&(u.state.cutIncoming=+new Date)}}i.wrapper.insertBefore(this.wrapper,i.wrapper.firstChild),dn&&(h.style.width="0px"),jn(h,"input",function(){ye&&he>=9&&s.hasSelection&&(s.hasSelection=null),f.poll()}),jn(h,"paste",function(w){Wt(u,w)||x4(w,u)||(u.state.pasteIncoming=+new Date,f.fastPoll())}),jn(h,"cut",y),jn(h,"copy",y),jn(i.scroller,"paste",function(w){if(!ia(i,w)&&!Wt(u,w)){if(!h.dispatchEvent)return u.state.pasteIncoming=+new Date,void f.focus();var E=new Event("paste");E.clipboardData=w.clipboardData,h.dispatchEvent(E)}}),jn(i.lineSpace,"selectstart",function(w){ia(i,w)||_1(w)}),jn(h,"compositionstart",function(){var w=u.getCursor("from");f.composing&&f.composing.range.clear(),f.composing={start:w,range:u.markText(w,u.getCursor("to"),{className:"CodeMirror-composing"})}}),jn(h,"compositionend",function(){f.composing&&(f.poll(),f.composing.range.clear(),f.composing=null)})},ii.prototype.createField=function(i){this.wrapper=M4(),this.textarea=this.wrapper.firstChild},ii.prototype.screenReaderLabelChanged=function(i){i?this.textarea.setAttribute("aria-label",i):this.textarea.removeAttribute("aria-label")},ii.prototype.prepareSelection=function(){var i=this.cm,s=i.display,f=i.doc,u=Ir(i);if(i.options.moveInputWithCursor){var h=z1(i,f.sel.primary().head,"div"),y=s.wrapper.getBoundingClientRect(),w=s.lineDiv.getBoundingClientRect();u.teTop=Math.max(0,Math.min(s.wrapper.clientHeight-10,h.top+w.top-y.top)),u.teLeft=Math.max(0,Math.min(s.wrapper.clientWidth-10,h.left+w.left-y.left))}return u},ii.prototype.showSelection=function(i){var f=this.cm.display;l1(f.cursorDiv,i.cursors),l1(f.selectionDiv,i.selection),null!=i.teTop&&(this.wrapper.style.top=i.teTop+"px",this.wrapper.style.left=i.teLeft+"px")},ii.prototype.reset=function(i){if(!this.contextMenuPending&&!this.composing){var s=this.cm;if(s.somethingSelected()){this.prevInput="";var f=s.getSelection();this.textarea.value=f,s.state.focused&&me(this.textarea),ye&&he>=9&&(this.hasSelection=f)}else i||(this.prevInput=this.textarea.value="",ye&&he>=9&&(this.hasSelection=null))}},ii.prototype.getField=function(){return this.textarea},ii.prototype.supportsTouch=function(){return!1},ii.prototype.focus=function(){if("nocursor"!=this.cm.options.readOnly&&(!Ke||Le()!=this.textarea))try{this.textarea.focus()}catch(i){}},ii.prototype.blur=function(){this.textarea.blur()},ii.prototype.resetPosition=function(){this.wrapper.style.top=this.wrapper.style.left=0},ii.prototype.receivedFocus=function(){this.slowPoll()},ii.prototype.slowPoll=function(){var i=this;this.pollingFast||this.polling.set(this.cm.options.pollInterval,function(){i.poll(),i.cm.state.focused&&i.slowPoll()})},ii.prototype.fastPoll=function(){var i=!1,s=this;s.pollingFast=!0,s.polling.set(20,function f(){s.poll()||i?(s.pollingFast=!1,s.slowPoll()):(i=!0,s.polling.set(60,f))})},ii.prototype.poll=function(){var i=this,s=this.cm,f=this.textarea,u=this.prevInput;if(this.contextMenuPending||!s.state.focused||we(f)&&!u&&!this.composing||s.isReadOnly()||s.options.disableInput||s.state.keySeq)return!1;var h=f.value;if(h==u&&!s.somethingSelected())return!1;if(ye&&he>=9&&this.hasSelection===h||Qe&&/[\uf700-\uf7ff]/.test(h))return s.display.input.reset(),!1;if(s.doc.sel==s.display.selForContextMenu){var y=h.charCodeAt(0);if(8203==y&&!u&&(u="\u200b"),8666==y)return this.reset(),this.cm.execCommand("undo")}for(var w=0,E=Math.min(u.length,h.length);w<E&&u.charCodeAt(w)==h.charCodeAt(w);)++w;return un(s,function(){Dc(s,h.slice(w),u.length-w,null,i.composing?"*compose":null),h.length>1e3||h.indexOf("\n")>-1?f.value=i.prevInput="":i.prevInput=h,i.composing&&(i.composing.range.clear(),i.composing.range=s.markText(i.composing.start,s.getCursor("to"),{className:"CodeMirror-composing"}))}),!0},ii.prototype.ensurePolled=function(){this.pollingFast&&this.poll()&&(this.pollingFast=!1)},ii.prototype.onKeyPress=function(){ye&&he>=9&&(this.hasSelection=null),this.fastPoll()},ii.prototype.onContextMenu=function(i){var s=this,f=s.cm,u=f.display,h=s.textarea;s.contextMenuPending&&s.contextMenuPending();var y=n2(f,i),w=u.scroller.scrollTop;if(y&&!le){f.options.resetSelectionOnContextMenu&&-1==f.doc.sel.contains(y)&&Kn(f,vt)(f.doc,x2(y),st);var ie,I=h.style.cssText,F=s.wrapper.style.cssText,J=s.wrapper.offsetParent.getBoundingClientRect();if(s.wrapper.style.cssText="position: static",h.style.cssText="position: absolute; width: 30px; height: 30px;\n      top: "+(i.clientY-J.top-5)+"px; left: "+(i.clientX-J.left-5)+"px;\n      z-index: 1000; background: "+(ye?"rgba(255, 255, 255, .05)":"transparent")+";\n      outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);",oe&&(ie=window.scrollY),u.input.focus(),oe&&window.scrollTo(null,ie),u.input.reset(),f.somethingSelected()||(h.value=s.prevInput=" "),s.contextMenuPending=be,u.selForContextMenu=f.doc.sel,clearTimeout(u.detectingSelectAll),ye&&he>=9&&_e(),cn){k1(i);var Te=function(){On(window,"mouseup",Te),setTimeout(be,20)};jn(window,"mouseup",Te)}else setTimeout(be,50)}function _e(){if(null!=h.selectionStart){var Ge=f.somethingSelected(),an="\u200b"+(Ge?h.value:"");h.value="\u21da",h.value=an,s.prevInput=Ge?"":"\u200b",h.selectionStart=1,h.selectionEnd=an.length,u.selForContextMenu=f.doc.sel}}function be(){if(s.contextMenuPending==be&&(s.contextMenuPending=!1,s.wrapper.style.cssText=F,h.style.cssText=I,ye&&he<9&&u.scrollbars.setScrollTop(u.scroller.scrollTop=w),null!=h.selectionStart)){(!ye||ye&&he<9)&&_e();var Ge=0,an=function(){u.selForContextMenu==f.doc.sel&&0==h.selectionStart&&h.selectionEnd>0&&"\u200b"==s.prevInput?Kn(f,ss)(f):Ge++<10?u.detectingSelectAll=setTimeout(an,500):(u.selForContextMenu=null,u.input.reset())};u.detectingSelectAll=setTimeout(an,200)}}},ii.prototype.readOnlyChanged=function(i){i||this.reset(),this.textarea.disabled="nocursor"==i,this.textarea.readOnly=!!i},ii.prototype.setUneditable=function(){},ii.prototype.needsContentAttribute=!1,function b4(i){var s=i.optionHandlers;function f(u,h,y,w){i.defaults[u]=h,y&&(s[u]=w?function(E,I,F){F!=gs&&y(E,I,F)}:y)}i.defineOption=f,i.Init=gs,f("value","",function(u,h){return u.setValue(h)},!0),f("mode",null,function(u,h){u.doc.modeOption=h,Qc(u)},!0),f("indentUnit",2,Qc,!0),f("indentWithTabs",!1),f("smartIndent",!0),f("tabSize",4,function(u){Fs(u),Fe(u),E1(u)},!0),f("lineSeparator",null,function(u,h){if(u.doc.lineSep=h,h){var y=[],w=u.doc.first;u.doc.iter(function(I){for(var F=0;;){var J=I.text.indexOf(h,F);if(-1==J)break;F=J+h.length,y.push(We(w,J))}w++});for(var E=y.length-1;E>=0;E--)ao(u.doc,h,y[E],We(y[E].line,y[E].ch+h.length))}}),f("specialChars",/[\u0000-\u001f\u007f-\u009f\u00ad\u061c\u200b\u200e\u200f\u2028\u2029\ufeff\ufff9-\ufffc]/g,function(u,h,y){u.state.specialChars=new RegExp(h.source+(h.test("\t")?"":"|\t"),"g"),y!=gs&&u.refresh()}),f("specialCharPlaceholder",j,function(u){return u.refresh()},!0),f("electricChars",!0),f("inputStyle",Ke?"contenteditable":"textarea",function(){throw new Error("inputStyle can not (yet) be changed in a running editor")},!0),f("spellcheck",!1,function(u,h){return u.getInputField().spellcheck=h},!0),f("autocorrect",!1,function(u,h){return u.getInputField().autocorrect=h},!0),f("autocapitalize",!1,function(u,h){return u.getInputField().autocapitalize=h},!0),f("rtlMoveVisually",!Dn),f("wholeLineUpdateBefore",!0),f("theme","default",function(u){M3(u),zo(u)},!0),f("keyMap","default",function(u,h,y){var w=ms(h),E=y!=gs&&ms(y);E&&E.detach&&E.detach(u,w),w.attach&&w.attach(u,E||null)}),f("extraKeys",null),f("configureMouse",null),f("lineWrapping",!1,_4,!0),f("gutters",[],function(u,h){u.display.gutterSpecs=Xc(h,u.options.lineNumbers),zo(u)},!0),f("fixedGutter",!0,function(u,h){u.display.gutters.style.left=h?Yo(u.display)+"px":"0",u.refresh()},!0),f("coverGutterNextToScrollbar",!1,function(u){return Rr(u)},!0),f("scrollbarStyle","native",function(u){x(u),Rr(u),u.display.scrollbars.setScrollTop(u.doc.scrollTop),u.display.scrollbars.setScrollLeft(u.doc.scrollLeft)},!0),f("lineNumbers",!1,function(u,h){u.display.gutterSpecs=Xc(u.options.gutters,h),zo(u)},!0),f("firstLineNumber",1,zo,!0),f("lineNumberFormatter",function(u){return u},zo,!0),f("showCursorWhenSelecting",!1,Oa,!0),f("resetSelectionOnContextMenu",!0),f("lineWiseCopyCut",!0),f("pasteLinesPerSelection",!0),f("selectionsMayTouch",!1),f("readOnly",!1,function(u,h){"nocursor"==h&&(T2(u),u.display.input.blur()),u.display.input.readOnlyChanged(h)}),f("screenReaderLabel",null,function(u,h){u.display.input.screenReaderLabelChanged(h=""===h?null:h)}),f("disableInput",!1,function(u,h){h||u.display.input.reset()},!0),f("dragDrop",!0,y4),f("allowDropFileTypes",null),f("cursorBlinkRate",530),f("cursorScrollMargin",0),f("cursorHeight",1,Oa,!0),f("singleCursorHeightPerLine",!0,Oa,!0),f("workTime",100),f("workDelay",100),f("flattenSpans",!0,Fs,!0),f("addModeClass",!1,Fs,!0),f("pollInterval",100),f("undoDepth",200,function(u,h){return u.doc.history.undoDepth=h}),f("historyEventDelay",1250),f("viewportMargin",10,function(u){return u.refresh()},!0),f("maxHighlightLength",1e4,Fs,!0),f("moveInputWithCursor",!0,function(u,h){h||u.display.input.resetPosition()}),f("tabindex",null,function(u,h){return u.display.input.getField().tabIndex=h||""}),f("autofocus",null),f("direction","ltr",function(u,h){return u.doc.setDirection(h)},!0),f("phrases",null)}(jt),function Ac(i){var s=i.optionHandlers,f=i.helpers={};i.prototype={constructor:i,focus:function(){window.focus(),this.display.input.focus()},setOption:function(u,h){var y=this.options,w=y[u];y[u]==h&&"mode"!=u||(y[u]=h,s.hasOwnProperty(u)&&Kn(this,s[u])(this,h,w),ht(this,"optionChange",this,u))},getOption:function(u){return this.options[u]},getDoc:function(){return this.doc},addKeyMap:function(u,h){this.state.keyMaps[h?"push":"unshift"](ms(u))},removeKeyMap:function(u){for(var h=this.state.keyMaps,y=0;y<h.length;++y)if(h[y]==u||h[y].name==u)return h.splice(y,1),!0},addOverlay:_t(function(u,h){var y=u.token?u:i.getMode(this.options,u);if(y.startState)throw new Error("Overlays may not be stateful.");(function Xi(i,s,f){for(var u=0,h=f(s);u<i.length&&f(i[u])<=h;)u++;i.splice(u,0,s)})(this.state.overlays,{mode:y,modeSpec:u,opaque:h&&h.opaque,priority:h&&h.priority||0},function(w){return w.priority}),this.state.modeGen++,E1(this)}),removeOverlay:_t(function(u){for(var h=this.state.overlays,y=0;y<h.length;++y){var w=h[y].modeSpec;if(w==u||"string"==typeof u&&w.name==u)return h.splice(y,1),this.state.modeGen++,void E1(this)}}),indentLine:_t(function(u,h,y){"string"!=typeof h&&"number"!=typeof h&&(h=null==h?this.options.smartIndent?"smart":"prev":h?"add":"subtract"),yt(this.doc,u)&&ys(this,u,h,y)}),indentSelection:_t(function(u){for(var h=this.doc.sel.ranges,y=-1,w=0;w<h.length;w++){var E=h[w];if(E.empty())E.head.line>y&&(ys(this,E.head.line,u,!0),y=E.head.line,w==this.doc.sel.primIndex&&yr(this));else{var I=E.from(),F=E.to(),J=Math.max(y,I.line);y=Math.min(this.lastLine(),F.line-(F.ch?0:1))+1;for(var ie=J;ie<y;++ie)ys(this,ie,u);var _e=this.doc.sel.ranges;0==I.ch&&h.length==_e.length&&_e[w].from().ch>0&&Eo(this.doc,w,new St(I,_e[w].to()),st)}}}),getTokenAt:function(u,h){return I1(this,u,h)},getLineTokens:function(u,h){return I1(this,We(u),h,!0)},getTokenTypeAt:function(u){u=Pn(this.doc,u);var I,h=B1(this,mn(this.doc,u.line)),y=0,w=(h.length-1)/2,E=u.ch;if(0==E)I=h[2];else for(;;){var F=y+w>>1;if((F?h[2*F-1]:0)>=E)w=F;else{if(!(h[2*F+1]<E)){I=h[2*F+2];break}y=F+1}}var J=I?I.indexOf("overlay "):-1;return J<0?I:0==J?null:I.slice(0,J-1)},getModeAt:function(u){var h=this.doc.mode;return h.innerMode?i.innerMode(h,this.getTokenAt(u).state).mode:h},getHelper:function(u,h){return this.getHelpers(u,h)[0]},getHelpers:function(u,h){var y=[];if(!f.hasOwnProperty(h))return y;var w=f[h],E=this.getModeAt(u);if("string"==typeof E[h])w[E[h]]&&y.push(w[E[h]]);else if(E[h])for(var I=0;I<E[h].length;I++){var F=w[E[h][I]];F&&y.push(F)}else E.helperType&&w[E.helperType]?y.push(w[E.helperType]):w[E.name]&&y.push(w[E.name]);for(var J=0;J<w._global.length;J++){var ie=w._global[J];ie.pred(E,this)&&-1==Rt(y,ie.val)&&y.push(ie.val)}return y},getStateAfter:function(u,h){var y=this.doc;return o1(this,(u=Qn(y,null==u?y.first+y.size-1:u))+1,h).state},cursorCoords:function(u,h){var w=this.doc.sel.primary();return z1(this,null==u?w.head:"object"==typeof u?Pn(this.doc,u):u?w.from():w.to(),h||"page")},charCoords:function(u,h){return Yt(this,Pn(this.doc,u),h||"page")},coordsChar:function(u,h){return ni(this,(u=Tt(this,u,h||"page")).left,u.top)},lineAtHeight:function(u,h){return u=Tt(this,{top:u,left:0},h||"page").top,Gn(this.doc,u+this.display.viewOffset)},heightAtLine:function(u,h,y){var E,w=!1;if("number"==typeof u){var I=this.doc.first+this.doc.size-1;u<this.doc.first?u=this.doc.first:u>I&&(u=I,w=!0),E=mn(this.doc,u)}else E=u;return ft(this,E,{top:0,left:0},h||"page",y||w).top+(w?this.doc.height-Hi(E):0)},defaultTextHeight:function(){return bi(this.display)},defaultCharWidth:function(){return It(this.display)},getViewport:function(){return{from:this.display.viewFrom,to:this.display.viewTo}},addWidget:function(u,h,y,w,E){var I=this.display,F=(u=z1(this,Pn(this.doc,u))).bottom,J=u.left;if(h.style.position="absolute",h.setAttribute("cm-ignore-events","true"),this.display.input.setUneditable(h),I.sizer.appendChild(h),"over"==w)F=u.top;else if("above"==w||"near"==w){var ie=Math.max(I.wrapper.clientHeight,this.doc.height),_e=Math.max(I.sizer.clientWidth,I.lineSpace.clientWidth);("above"==w||u.bottom+h.offsetHeight>ie)&&u.top>h.offsetHeight?F=u.top-h.offsetHeight:u.bottom+h.offsetHeight<=ie&&(F=u.bottom),J+h.offsetWidth>_e&&(J=_e-h.offsetWidth)}h.style.top=F+"px",h.style.left=h.style.right="","right"==E?(J=I.sizer.clientWidth-h.offsetWidth,h.style.right="0px"):("left"==E?J=0:"middle"==E&&(J=(I.sizer.clientWidth-h.offsetWidth)/2),h.style.left=J+"px"),y&&function dc(i,s){var f=v2(i,s);null!=f.scrollTop&&b2(i,f.scrollTop),null!=f.scrollLeft&&or(i,f.scrollLeft)}(this,{left:J,top:F,right:J+h.offsetWidth,bottom:F+h.offsetHeight})},triggerOnKeyDown:_t(y3),triggerOnKeyPress:_t(f4),triggerOnKeyUp:u4,triggerOnMouseDown:_t(hs),execCommand:function(u){if(er.hasOwnProperty(u))return er[u].call(null,this)},triggerElectric:_t(function(u){C4(this,u)}),findPosH:function(u,h,y,w){var E=1;h<0&&(E=-1,h=-h);for(var I=Pn(this.doc,u),F=0;F<h&&!(I=Lc(this.doc,I,E,y,w)).hitSide;++F);return I},moveH:_t(function(u,h){var y=this;this.extendSelectionsBy(function(w){return y.display.shift||y.doc.extend||w.empty()?Lc(y.doc,w.head,u,h,y.options.rtlMoveVisually):u<0?w.from():w.to()},Lt)}),deleteH:_t(function(u,h){var w=this.doc;this.doc.sel.somethingSelected()?w.replaceSelection("",null,"+delete"):so(this,function(E){var I=Lc(w,E.head,u,h,!1);return u<0?{from:I,to:E.head}:{from:E.head,to:I}})}),findPosV:function(u,h,y,w){var E=1,I=w;h<0&&(E=-1,h=-h);for(var F=Pn(this.doc,u),J=0;J<h;++J){var ie=z1(this,F,"div");if(null==I?I=ie.left:ie.left=I,(F=w3(this,ie,E,y)).hitSide)break}return F},moveV:_t(function(u,h){var y=this,w=this.doc,E=[],I=!this.display.shift&&!w.extend&&w.sel.somethingSelected();if(w.extendSelectionsBy(function(J){if(I)return u<0?J.from():J.to();var ie=z1(y,J.head,"div");null!=J.goalColumn&&(ie.left=J.goalColumn),E.push(ie.left);var _e=w3(y,ie,u,h);return"page"==h&&J==w.sel.primary()&&Os(y,Yt(y,_e,"div").top-ie.top),_e},Lt),E.length)for(var F=0;F<w.sel.ranges.length;F++)w.sel.ranges[F].goalColumn=E[F]}),findWordAt:function(u){var y=mn(this.doc,u.line).text,w=u.ch,E=u.ch;if(y){var I=this.getHelper(u,"wordChars");"before"!=u.sticky&&E!=y.length||!w?++E:--w;for(var F=y.charAt(w),J=xt(F,I)?function(ie){return xt(ie,I)}:/\s/.test(F)?function(ie){return/\s/.test(ie)}:function(ie){return!/\s/.test(ie)&&!xt(ie)};w>0&&J(y.charAt(w-1));)--w;for(;E<y.length&&J(y.charAt(E));)++E}return new St(We(u.line,w),We(u.line,E))},toggleOverwrite:function(u){null!=u&&u==this.state.overwrite||((this.state.overwrite=!this.state.overwrite)?De(this.display.cursorDiv,"CodeMirror-overwrite"):g1(this.display.cursorDiv,"CodeMirror-overwrite"),ht(this,"overwriteToggle",this,this.state.overwrite))},hasFocus:function(){return this.display.input.getField()==Le()},isReadOnly:function(){return!(!this.options.readOnly&&!this.doc.cantEdit)},scrollTo:_t(function(u,h){k2(this,u,h)}),getScrollInfo:function(){var u=this.display.scroller;return{left:u.scrollLeft,top:u.scrollTop,height:u.scrollHeight-Fi(this)-this.display.barHeight,width:u.scrollWidth-Fi(this)-this.display.barWidth,clientHeight:Pr(this),clientWidth:b1(this)}},scrollIntoView:_t(function(u,h){null==u?(u={from:this.doc.sel.primary().head,to:null},null==h&&(h=this.options.cursorScrollMargin)):"number"==typeof u?u={from:We(u,0),to:null}:null==u.from&&(u={from:u,to:null}),u.to||(u.to=u.from),u.margin=h||0,null!=u.from.line?function Jo(i,s){Mo(i),i.curOp.scrollToPos=s}(this,u):Ko(this,u.from,u.to,u.margin)}),setSize:_t(function(u,h){var y=this,w=function(I){return"number"==typeof I||/^\d+$/.test(String(I))?I+"px":I};null!=u&&(this.display.wrapper.style.width=w(u)),null!=h&&(this.display.wrapper.style.height=w(h)),this.options.lineWrapping&&Pe(this);var E=this.display.viewFrom;this.doc.iter(E,this.display.viewTo,function(I){if(I.widgets)for(var F=0;F<I.widgets.length;F++)if(I.widgets[F].noHScroll){vr(y,E,"widget");break}++E}),this.curOp.forceUpdate=!0,ht(this,"refresh",this)}),operation:function(u){return un(this,u)},startOperation:function(){return T(this)},endOperation:function(){return V(this)},refresh:_t(function(){var u=this.display.cachedTextHeight;E1(this),this.curOp.forceUpdate=!0,Fe(this),k2(this,this.doc.scrollLeft,this.doc.scrollTop),Vs(this.display),(null==u||Math.abs(u-bi(this.display))>.5||this.options.lineWrapping)&&Co(this),ht(this,"refresh",this)}),swapDoc:_t(function(u){var h=this.doc;return h.cm=null,this.state.selectingText&&this.state.selectingText(),to(this,u),Fe(this),this.display.input.reset(),k2(this,u.scrollLeft,u.scrollTop),this.curOp.forceScroll=!0,Jn(this,"swapDoc",this,h),h}),phrase:function(u){var h=this.options.phrases;return h&&Object.prototype.hasOwnProperty.call(h,u)?h[u]:u},getInputField:function(){return this.display.input.getField()},getWrapperElement:function(){return this.display.wrapper},getScrollerElement:function(){return this.display.scroller},getGutterElement:function(){return this.display.gutters}},Mt(i),i.registerHelper=function(u,h,y){f.hasOwnProperty(u)||(f[u]=i[u]={_global:[]}),f[u][h]=y},i.registerGlobalHelper=function(u,h,y,w){i.registerHelper(u,h,w),f[u]._global.push({pred:y,val:w})}}(jt);var Il="iter insert remove copy getEditor constructor".split(" ");for(var Tc in Ui.prototype)Ui.prototype.hasOwnProperty(Tc)&&Rt(Il,Tc)<0&&(jt.prototype[Tc]=function(i){return function(){return i.apply(this.doc,arguments)}}(Ui.prototype[Tc]));return Mt(Ui),jt.inputStyles={textarea:ii,contenteditable:f1},jt.defineMode=function(i){!jt.defaults.mode&&"null"!=i&&(jt.defaults.mode=i),it.apply(this,arguments)},jt.defineMIME=function wt(i,s){Vn[i]=s},jt.defineMode("null",function(){return{token:function(i){return i.skipToEnd()}}}),jt.defineMIME("text/plain","null"),jt.defineExtension=function(i,s){jt.prototype[i]=s},jt.defineDocExtension=function(i,s){Ui.prototype[i]=s},jt.fromTextArea=function Pl(i,s){if((s=s?En(s):{}).value=i.value,!s.tabindex&&i.tabIndex&&(s.tabindex=i.tabIndex),!s.placeholder&&i.placeholder&&(s.placeholder=i.placeholder),null==s.autofocus){var f=Le();s.autofocus=f==i||null!=i.getAttribute("autofocus")&&f==document.body}function u(){i.value=E.getValue()}var h;if(i.form&&(jn(i.form,"submit",u),!s.leaveSubmitMethodAlone)){var y=i.form;h=y.submit;try{var w=y.submit=function(){u(),y.submit=h,y.submit(),y.submit=w}}catch(I){}}s.finishInit=function(I){I.save=u,I.getTextArea=function(){return i},I.toTextArea=function(){I.toTextArea=isNaN,u(),i.parentNode.removeChild(I.getWrapperElement()),i.style.display="",i.form&&(On(i.form,"submit",u),!s.leaveSubmitMethodAlone&&"function"==typeof i.form.submit&&(i.form.submit=h))}},i.style.display="none";var E=jt(function(I){return i.parentNode.insertBefore(I,i.nextSibling)},s);return E},function D3(i){i.off=On,i.on=jn,i.wheelEventPixels=I2,i.Doc=Ui,i.splitLines=Na,i.countColumn=Ln,i.findColumn=$i,i.isWordChar=q1,i.Pass=Bt,i.signal=ht,i.Line=ka,i.changeEnd=qr,i.scrollbarModel=z,i.Pos=We,i.cmpPos=wn,i.modes=Re,i.mimeModes=Vn,i.resolveMode=Sn,i.getMode=Zt,i.modeExtensions=x1,i.extendMode=$t,i.copyState=P1,i.startState=Ei,i.innerMode=M1,i.commands=er,i.keyMap=c2,i.keyName=Cc,i.isModifierKey=ps,i.lookupKey=Zr,i.normalizeKeyMap=b3,i.StringStream=Ft,i.SharedTextMarker=Ka,i.TextMarker=o2,i.LineWidget=To,i.e_preventDefault=_1,i.e_stopPropagation=m1,i.e_stop=k1,i.addClass=De,i.contains=Un,i.rmClass=g1,i.keyNames=_i}(jt),jt.version="5.65.2",jt}()},7270:(Xn,He,Q)=>{!function(M){"use strict";function d(ge,me,Xe,En,Ln,lt){this.indented=ge,this.column=me,this.type=Xe,this.info=En,this.align=Ln,this.prev=lt}function Ue(ge,me,Xe,En){var Ln=ge.indented;return ge.context&&"statement"==ge.context.type&&"statement"!=Xe&&(Ln=ge.context.indented),ge.context=new d(Ln,me,Xe,En,null,ge.context)}function Oe(ge){var me=ge.context.type;return(")"==me||"]"==me||"}"==me)&&(ge.indented=ge.context.indented),ge.context=ge.context.prev}function ye(ge,me,Xe){if("variable"==me.prevToken||"type"==me.prevToken||/\S(?:[^- ]>|[*\]])\s*$|\*$/.test(ge.string.slice(0,Xe))||me.typeAtEndOfLine&&ge.column()==ge.indentation())return!0}function he(ge){for(;;){if(!ge||"top"==ge.type)return!0;if("}"==ge.type&&"namespace"!=ge.prev.info)return!1;ge=ge.prev}}function oe(ge){for(var me={},Xe=ge.split(" "),En=0;En<Xe.length;++En)me[Xe[En]]=!0;return me}function ce(ge,me){return"function"==typeof ge?ge(me):ge.propertyIsEnumerable(me)}M.defineMode("clike",function(ge,me){var xt,Mi,Xe=ge.indentUnit,En=me.statementIndentUnit||Xe,Ln=me.dontAlignCalls,lt=me.keywords||{},Rt=me.types||{},Zi=me.builtin||{},Bt=me.blockKeywords||{},st=me.defKeywords||{},zt=me.atoms||{},Lt=me.hooks||{},$i=me.multiLineStrings,Ut=!1!==me.indentStatements,qn=me.namespaceSeparator,pi=me.isPunctuationChar||/[\[\]{}\(\),;\:\.]/,Xi=me.numberStart||/[\d\.]/,j1=me.number||/^(?:0x[a-f\d]+|0b[01]+|(?:\d+\.?\d*|\.\d+)(?:e[-+]?\d+)?)(u|ll?|l|f)?/i,Gt=me.isOperatorChar||/[+\-*&%=<>!?|\/]/,a1=me.isIdentifierChar||/[\w\$_\xa1-\uffff]/,q1=me.isReservedIdentifier||!1;function wa(xn,_n){var on=xn.next();if(Lt[on]){var ln=Lt[on](xn,_n);if(!1!==ln)return ln}if('"'==on||"'"==on)return _n.tokenize=function $n(xn){return function(_n,on){for(var sn,ln=!1,zi=!1;null!=(sn=_n.next());){if(sn==xn&&!ln){zi=!0;break}ln=!ln&&"\\"==sn}return(zi||!(ln||$i))&&(on.tokenize=null),"string"}}(on),_n.tokenize(xn,_n);if(Xi.test(on)){if(xn.backUp(1),xn.match(j1))return"number";xn.next()}if(pi.test(on))return xt=on,null;if("/"==on){if(xn.eat("*"))return _n.tokenize=wi,wi(xn,_n);if(xn.eat("/"))return xn.skipToEnd(),"comment"}if(Gt.test(on)){for(;!xn.match(/^\/[\/*]/,!1)&&xn.eat(Gt););return"operator"}if(xn.eatWhile(a1),qn)for(;xn.match(qn);)xn.eatWhile(a1);var sn=xn.current();return ce(lt,sn)?(ce(Bt,sn)&&(xt="newstatement"),ce(st,sn)&&(Mi=!0),"keyword"):ce(Rt,sn)?"type":ce(Zi,sn)||q1&&q1(sn)?(ce(Bt,sn)&&(xt="newstatement"),"builtin"):ce(zt,sn)?"atom":"variable"}function wi(xn,_n){for(var ln,on=!1;ln=xn.next();){if("/"==ln&&on){_n.tokenize=null;break}on="*"==ln}return"comment"}function Rn(xn,_n){me.typeFirstDefinitions&&xn.eol()&&he(_n.context)&&(_n.typeAtEndOfLine=ye(xn,_n,xn.pos))}return{startState:function(xn){return{tokenize:null,context:new d((xn||0)-Xe,0,"top",null,!1),indented:0,startOfLine:!0,prevToken:null}},token:function(xn,_n){var on=_n.context;if(xn.sol()&&(null==on.align&&(on.align=!1),_n.indented=xn.indentation(),_n.startOfLine=!0),xn.eatSpace())return Rn(xn,_n),null;xt=Mi=null;var ln=(_n.tokenize||wa)(xn,_n);if("comment"==ln||"meta"==ln)return ln;if(null==on.align&&(on.align=!0),";"==xt||":"==xt||","==xt&&xn.match(/^\s*(?:\/\/.*)?$/,!1))for(;"statement"==_n.context.type;)Oe(_n);else if("{"==xt)Ue(_n,xn.column(),"}");else if("["==xt)Ue(_n,xn.column(),"]");else if("("==xt)Ue(_n,xn.column(),")");else if("}"==xt){for(;"statement"==on.type;)on=Oe(_n);for("}"==on.type&&(on=Oe(_n));"statement"==on.type;)on=Oe(_n)}else xt==on.type?Oe(_n):Ut&&(("}"==on.type||"top"==on.type)&&";"!=xt||"statement"==on.type&&"newstatement"==xt)&&Ue(_n,xn.column(),"statement",xn.current());if("variable"==ln&&("def"==_n.prevToken||me.typeFirstDefinitions&&ye(xn,_n,xn.start)&&he(_n.context)&&xn.match(/^\s*\(/,!1))&&(ln="def"),Lt.token){var sn=Lt.token(xn,_n,ln);void 0!==sn&&(ln=sn)}return"def"==ln&&!1===me.styleDefs&&(ln="variable"),_n.startOfLine=!1,_n.prevToken=Mi?"def":ln||xt,Rn(xn,_n),ln},indent:function(xn,_n){if(xn.tokenize!=wa&&null!=xn.tokenize||xn.typeAtEndOfLine)return M.Pass;var on=xn.context,ln=_n&&_n.charAt(0),sn=ln==on.type;if("statement"==on.type&&"}"==ln&&(on=on.prev),me.dontIndentStatements)for(;"statement"==on.type&&me.dontIndentStatements.test(on.info);)on=on.prev;if(Lt.indent){var zi=Lt.indent(xn,on,_n,Xe);if("number"==typeof zi)return zi}var jn=on.prev&&"switch"==on.prev.info;if(me.allmanIndentation&&/[{(]/.test(ln)){for(;"top"!=on.type&&"}"!=on.type;)on=on.prev;return on.indented}return"statement"==on.type?on.indented+("{"==ln?0:En):!on.align||Ln&&")"==on.type?")"!=on.type||sn?on.indented+(sn?0:Xe)+(sn||!jn||/^(?:case|default)\b/.test(_n)?0:Xe):on.indented+En:on.column+(sn?0:1)},electricInput:!1!==me.indentSwitch?/^\s*(?:case .*?:|default:|\{\}?|\})$/:/^\s*[{}]$/,blockCommentStart:"/*",blockCommentEnd:"*/",blockCommentContinue:" * ",lineComment:"//",fold:"brace"}});var fe="auto if break case register continue return default do sizeof static else struct switch extern typedef union for goto while enum const volatile inline restrict asm fortran",le="alignas alignof and and_eq audit axiom bitand bitor catch class compl concept constexpr const_cast decltype delete dynamic_cast explicit export final friend import module mutable namespace new noexcept not not_eq operator or or_eq override private protected public reinterpret_cast requires static_assert static_cast template this thread_local throw try typeid typename using virtual xor xor_eq",pe="bycopy byref in inout oneway out self super atomic nonatomic retain copy readwrite readonly strong weak assign typeof nullable nonnull null_resettable _cmd @interface @implementation @end @protocol @encode @property @synthesize @dynamic @class @public @package @private @protected @required @optional @try @catch @finally @import @selector @encode @defs @synchronized @autoreleasepool @compatibility_alias @available",Me="FOUNDATION_EXPORT FOUNDATION_EXTERN NS_INLINE NS_FORMAT_FUNCTION  NS_RETURNS_RETAINEDNS_ERROR_ENUM NS_RETURNS_NOT_RETAINED NS_RETURNS_INNER_POINTER NS_DESIGNATED_INITIALIZER NS_ENUM NS_OPTIONS NS_REQUIRES_NIL_TERMINATION NS_ASSUME_NONNULL_BEGIN NS_ASSUME_NONNULL_END NS_SWIFT_NAME NS_REFINED_FOR_SWIFT",Ae=oe("int long char short double float unsigned signed void bool"),dn=oe("SEL instancetype id Class Protocol BOOL");function rn(ge){return ce(Ae,ge)||/.+_t$/.test(ge)}function Ke(ge){return rn(ge)||ce(dn,ge)}var Qe="case do else for if switch while struct enum union",ot="struct enum union";function Dn(ge,me){if(!me.startOfLine)return!1;for(var Xe,En=null;Xe=ge.peek();){if("\\"==Xe&&ge.match(/^.$/)){En=Dn;break}if("/"==Xe&&ge.match(/^\/[\/\*]/,!1))break;ge.next()}return me.tokenize=En,"meta"}function yn(ge,me){return"type"==me.prevToken&&"type"}function ut(ge){return!(!ge||ge.length<2||"_"!=ge[0]||"_"!=ge[1]&&ge[1]===ge[1].toLowerCase())}function cn(ge){return ge.eatWhile(/[\w\.']/),"number"}function fn(ge,me){if(ge.backUp(1),ge.match(/^(?:R|u8R|uR|UR|LR)/)){var Xe=ge.match(/^"([^\s\\()]{0,16})\(/);return!!Xe&&(me.cpp11RawStringDelim=Xe[1],me.tokenize=l1,l1(ge,me))}return ge.match(/^(?:u8|u|U|L)/)?!!ge.match(/^["']/,!1)&&"string":(ge.next(),!1)}function g1(ge){var me=/(\w+)::~?(\w+)$/.exec(ge);return me&&me[1]==me[2]}function mt(ge,me){for(var Xe;null!=(Xe=ge.next());)if('"'==Xe&&!ge.eat('"')){me.tokenize=null;break}return"string"}function l1(ge,me){var Xe=me.cpp11RawStringDelim.replace(/[^\w\s]/g,"\\$&");return ge.match(new RegExp(".*?\\)"+Xe+'"'))?me.tokenize=null:ge.skipToEnd(),"string"}function tn(ge,me){"string"==typeof ge&&(ge=[ge]);var Xe=[];function En(lt){if(lt)for(var Rt in lt)lt.hasOwnProperty(Rt)&&Xe.push(Rt)}En(me.keywords),En(me.types),En(me.builtin),En(me.atoms),Xe.length&&(me.helperType=ge[0],M.registerHelper("hintWords",ge[0],Xe));for(var Ln=0;Ln<ge.length;++Ln)M.defineMIME(ge[Ln],me)}function Yn(ge,me){for(var Xe=!1;!ge.eol();){if(!Xe&&ge.match('"""')){me.tokenize=null;break}Xe="\\"==ge.next()&&!Xe}return"string"}function tt(ge){return function(me,Xe){for(var En;En=me.next();){if("*"==En&&me.eat("/")){if(1==ge){Xe.tokenize=null;break}return Xe.tokenize=tt(ge-1),Xe.tokenize(me,Xe)}if("/"==En&&me.eat("*"))return Xe.tokenize=tt(ge+1),Xe.tokenize(me,Xe)}return"comment"}}tn(["text/x-csrc","text/x-c","text/x-chdr"],{name:"clike",keywords:oe(fe),types:rn,blockKeywords:oe(Qe),defKeywords:oe(ot),typeFirstDefinitions:!0,atoms:oe("NULL true false"),isReservedIdentifier:ut,hooks:{"#":Dn,"*":yn},modeProps:{fold:["brace","include"]}}),tn(["text/x-c++src","text/x-c++hdr"],{name:"clike",keywords:oe(fe+" "+le),types:rn,blockKeywords:oe(Qe+" class try catch"),defKeywords:oe(ot+" class namespace"),typeFirstDefinitions:!0,atoms:oe("true false NULL nullptr"),dontIndentStatements:/^template$/,isIdentifierChar:/[\w\$_~\xa1-\uffff]/,isReservedIdentifier:ut,hooks:{"#":Dn,"*":yn,u:fn,U:fn,L:fn,R:fn,0:cn,1:cn,2:cn,3:cn,4:cn,5:cn,6:cn,7:cn,8:cn,9:cn,token:function(ge,me,Xe){if("variable"==Xe&&"("==ge.peek()&&(";"==me.prevToken||null==me.prevToken||"}"==me.prevToken)&&g1(ge.current()))return"def"}},namespaceSeparator:"::",modeProps:{fold:["brace","include"]}}),tn("text/x-java",{name:"clike",keywords:oe("abstract assert break case catch class const continue default do else enum extends final finally for goto if implements import instanceof interface native new package private protected public return static strictfp super switch synchronized this throw throws transient try volatile while @interface"),types:oe("var byte short int long float double boolean char void Boolean Byte Character Double Float Integer Long Number Object Short String StringBuffer StringBuilder Void"),blockKeywords:oe("catch class do else finally for if switch try while"),defKeywords:oe("class interface enum @interface"),typeFirstDefinitions:!0,atoms:oe("true false null"),number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,hooks:{"@":function(ge){return!ge.match("interface",!1)&&(ge.eatWhile(/[\w\$_]/),"meta")},'"':function(ge,me){return!!ge.match('""\n')&&(me.tokenize=Yn,me.tokenize(ge,me))}},modeProps:{fold:["brace","import"]}}),tn("text/x-csharp",{name:"clike",keywords:oe("abstract as async await base break case catch checked class const continue default delegate do else enum event explicit extern finally fixed for foreach goto if implicit in interface internal is lock namespace new operator out override params private protected public readonly ref return sealed sizeof stackalloc static struct switch this throw try typeof unchecked unsafe using virtual void volatile while add alias ascending descending dynamic from get global group into join let orderby partial remove select set value var yield"),types:oe("Action Boolean Byte Char DateTime DateTimeOffset Decimal Double Func Guid Int16 Int32 Int64 Object SByte Single String Task TimeSpan UInt16 UInt32 UInt64 bool byte char decimal double short int long object sbyte float string ushort uint ulong"),blockKeywords:oe("catch class do else finally for foreach if struct switch try while"),defKeywords:oe("class interface namespace struct var"),typeFirstDefinitions:!0,atoms:oe("true false null"),hooks:{"@":function(ge,me){return ge.eat('"')?(me.tokenize=mt,mt(ge,me)):(ge.eatWhile(/[\w\$_]/),"meta")}}}),tn("text/x-scala",{name:"clike",keywords:oe("abstract case catch class def do else extends final finally for forSome if implicit import lazy match new null object override package private protected return sealed super this throw trait try type val var while with yield _ assert assume require print println printf readLine readBoolean readByte readShort readChar readInt readLong readFloat readDouble"),types:oe("AnyVal App Application Array BufferedIterator BigDecimal BigInt Char Console Either Enumeration Equiv Error Exception Fractional Function IndexedSeq Int Integral Iterable Iterator List Map Numeric Nil NotNull Option Ordered Ordering PartialFunction PartialOrdering Product Proxy Range Responder Seq Serializable Set Specializable Stream StringBuilder StringContext Symbol Throwable Traversable TraversableOnce Tuple Unit Vector Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),multiLineStrings:!0,blockKeywords:oe("catch class enum do else finally for forSome if match switch try while"),defKeywords:oe("class enum def object package trait type val var"),atoms:oe("true false null"),indentStatements:!1,indentSwitch:!1,isOperatorChar:/[+\-*&%=<>!?|\/#:@]/,hooks:{"@":function(ge){return ge.eatWhile(/[\w\$_]/),"meta"},'"':function(ge,me){return!!ge.match('""')&&(me.tokenize=Yn,me.tokenize(ge,me))},"'":function(ge){return ge.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},"=":function(ge,me){var Xe=me.context;return!("}"!=Xe.type||!Xe.align||!ge.eat(">"))&&(me.context=new d(Xe.indented,Xe.column,Xe.type,Xe.info,null,Xe.prev),"operator")},"/":function(ge,me){return!!ge.eat("*")&&(me.tokenize=tt(1),me.tokenize(ge,me))}},modeProps:{closeBrackets:{pairs:'()[]{}""',triples:'"'}}}),tn("text/x-kotlin",{name:"clike",keywords:oe("package as typealias class interface this super val operator var fun for is in This throw return annotation break continue object if else while do try when !in !is as? file import where by get set abstract enum open inner override private public internal protected catch finally out final vararg reified dynamic companion constructor init sealed field property receiver param sparam lateinit data inline noinline tailrec external annotation crossinline const operator infix suspend actual expect setparam value"),types:oe("Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void Annotation Any BooleanArray ByteArray Char CharArray DeprecationLevel DoubleArray Enum FloatArray Function Int IntArray Lazy LazyThreadSafetyMode LongArray Nothing ShortArray Unit"),intendSwitch:!1,indentStatements:!1,multiLineStrings:!0,number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+(\.\d+)?|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,blockKeywords:oe("catch class do else finally for if where try while enum"),defKeywords:oe("class val var object interface fun"),atoms:oe("true false null this"),hooks:{"@":function(ge){return ge.eatWhile(/[\w\$_]/),"meta"},"*":function(ge,me){return"."==me.prevToken?"variable":"operator"},'"':function(ge,me){return me.tokenize=function Un(ge){return function(me,Xe){for(var Ln,En=!1,lt=!1;!me.eol();){if(!ge&&!En&&me.match('"')){lt=!0;break}if(ge&&me.match('"""')){lt=!0;break}Ln=me.next(),!En&&"$"==Ln&&me.match("{")&&me.skipTo("}"),En=!En&&"\\"==Ln&&!ge}return(lt||!ge)&&(Xe.tokenize=null),"string"}}(ge.match('""')),me.tokenize(ge,me)},"/":function(ge,me){return!!ge.eat("*")&&(me.tokenize=tt(1),me.tokenize(ge,me))},indent:function(ge,me,Xe,En){var Ln=Xe&&Xe.charAt(0);return"}"!=ge.prevToken&&")"!=ge.prevToken||""!=Xe?"operator"==ge.prevToken&&"}"!=Xe&&"}"!=ge.context.type||"variable"==ge.prevToken&&"."==Ln||("}"==ge.prevToken||")"==ge.prevToken)&&"."==Ln?2*En+me.indented:me.align&&"}"==me.type?me.indented+(ge.context.type==(Xe||"").charAt(0)?0:En):void 0:ge.indented}},modeProps:{closeBrackets:{triples:'"'}}}),tn(["x-shader/x-vertex","x-shader/x-fragment"],{name:"clike",keywords:oe("sampler1D sampler2D sampler3D samplerCube sampler1DShadow sampler2DShadow const attribute uniform varying break continue discard return for while do if else struct in out inout"),types:oe("float int bool void vec2 vec3 vec4 ivec2 ivec3 ivec4 bvec2 bvec3 bvec4 mat2 mat3 mat4"),blockKeywords:oe("for while do if else struct"),builtin:oe("radians degrees sin cos tan asin acos atan pow exp log exp2 sqrt inversesqrt abs sign floor ceil fract mod min max clamp mix step smoothstep length distance dot cross normalize ftransform faceforward reflect refract matrixCompMult lessThan lessThanEqual greaterThan greaterThanEqual equal notEqual any all not texture1D texture1DProj texture1DLod texture1DProjLod texture2D texture2DProj texture2DLod texture2DProjLod texture3D texture3DProj texture3DLod texture3DProjLod textureCube textureCubeLod shadow1D shadow2D shadow1DProj shadow2DProj shadow1DLod shadow2DLod shadow1DProjLod shadow2DProjLod dFdx dFdy fwidth noise1 noise2 noise3 noise4"),atoms:oe("true false gl_FragColor gl_SecondaryColor gl_Normal gl_Vertex gl_MultiTexCoord0 gl_MultiTexCoord1 gl_MultiTexCoord2 gl_MultiTexCoord3 gl_MultiTexCoord4 gl_MultiTexCoord5 gl_MultiTexCoord6 gl_MultiTexCoord7 gl_FogCoord gl_PointCoord gl_Position gl_PointSize gl_ClipVertex gl_FrontColor gl_BackColor gl_FrontSecondaryColor gl_BackSecondaryColor gl_TexCoord gl_FogFragCoord gl_FragCoord gl_FrontFacing gl_FragData gl_FragDepth gl_ModelViewMatrix gl_ProjectionMatrix gl_ModelViewProjectionMatrix gl_TextureMatrix gl_NormalMatrix gl_ModelViewMatrixInverse gl_ProjectionMatrixInverse gl_ModelViewProjectionMatrixInverse gl_TextureMatrixTranspose gl_ModelViewMatrixInverseTranspose gl_ProjectionMatrixInverseTranspose gl_ModelViewProjectionMatrixInverseTranspose gl_TextureMatrixInverseTranspose gl_NormalScale gl_DepthRange gl_ClipPlane gl_Point gl_FrontMaterial gl_BackMaterial gl_LightSource gl_LightModel gl_FrontLightModelProduct gl_BackLightModelProduct gl_TextureColor gl_EyePlaneS gl_EyePlaneT gl_EyePlaneR gl_EyePlaneQ gl_FogParameters gl_MaxLights gl_MaxClipPlanes gl_MaxTextureUnits gl_MaxTextureCoords gl_MaxVertexAttribs gl_MaxVertexUniformComponents gl_MaxVaryingFloats gl_MaxVertexTextureImageUnits gl_MaxTextureImageUnits gl_MaxFragmentUniformComponents gl_MaxCombineTextureImageUnits gl_MaxDrawBuffers"),indentSwitch:!1,hooks:{"#":Dn},modeProps:{fold:["brace","include"]}}),tn("text/x-nesc",{name:"clike",keywords:oe(fe+" as atomic async call command component components configuration event generic implementation includes interface module new norace nx_struct nx_union post provides signal task uses abstract extends"),types:rn,blockKeywords:oe(Qe),atoms:oe("null true false"),hooks:{"#":Dn},modeProps:{fold:["brace","include"]}}),tn("text/x-objectivec",{name:"clike",keywords:oe(fe+" "+pe),types:Ke,builtin:oe(Me),blockKeywords:oe(Qe+" @synthesize @try @catch @finally @autoreleasepool @synchronized"),defKeywords:oe(ot+" @interface @implementation @protocol @class"),dontIndentStatements:/^@.*$/,typeFirstDefinitions:!0,atoms:oe("YES NO NULL Nil nil true false nullptr"),isReservedIdentifier:ut,hooks:{"#":Dn,"*":yn},modeProps:{fold:["brace","include"]}}),tn("text/x-objectivec++",{name:"clike",keywords:oe(fe+" "+pe+" "+le),types:Ke,builtin:oe(Me),blockKeywords:oe(Qe+" @synthesize @try @catch @finally @autoreleasepool @synchronized class try catch"),defKeywords:oe(ot+" @interface @implementation @protocol @class class namespace"),dontIndentStatements:/^@.*$|^template$/,typeFirstDefinitions:!0,atoms:oe("YES NO NULL Nil nil true false nullptr"),isReservedIdentifier:ut,hooks:{"#":Dn,"*":yn,u:fn,U:fn,L:fn,R:fn,0:cn,1:cn,2:cn,3:cn,4:cn,5:cn,6:cn,7:cn,8:cn,9:cn,token:function(ge,me,Xe){if("variable"==Xe&&"("==ge.peek()&&(";"==me.prevToken||null==me.prevToken||"}"==me.prevToken)&&g1(ge.current()))return"def"}},namespaceSeparator:"::",modeProps:{fold:["brace","include"]}}),tn("text/x-squirrel",{name:"clike",keywords:oe("base break clone continue const default delete enum extends function in class foreach local resume return this throw typeof yield constructor instanceof static"),types:rn,blockKeywords:oe("case catch class else for foreach if switch try while"),defKeywords:oe("function local class"),typeFirstDefinitions:!0,atoms:oe("true false null"),hooks:{"#":Dn},modeProps:{fold:["brace","include"]}});var Le=null;function De(ge){return function(me,Xe){for(var Ln,En=!1,lt=!1;!me.eol();){if(!En&&me.match('"')&&("single"==ge||me.match('""'))){lt=!0;break}if(!En&&me.match("``")){Le=De(ge),lt=!0;break}Ln=me.next(),En="single"==ge&&!En&&"\\"==Ln}return lt&&(Xe.tokenize=null),"string"}}tn("text/x-ceylon",{name:"clike",keywords:oe("abstracts alias assembly assert assign break case catch class continue dynamic else exists extends finally for function given if import in interface is let module new nonempty object of out outer package return satisfies super switch then this throw try value void while"),types:function(ge){var me=ge.charAt(0);return me===me.toUpperCase()&&me!==me.toLowerCase()},blockKeywords:oe("case catch class dynamic else finally for function if interface module new object switch try while"),defKeywords:oe("class dynamic function interface module object package value"),builtin:oe("abstract actual aliased annotation by default deprecated doc final formal late license native optional sealed see serializable shared suppressWarnings tagged throws variable"),isPunctuationChar:/[\[\]{}\(\),;\:\.`]/,isOperatorChar:/[+\-*&%=<>!?|^~:\/]/,numberStart:/[\d#$]/,number:/^(?:#[\da-fA-F_]+|\$[01_]+|[\d_]+[kMGTPmunpf]?|[\d_]+\.[\d_]+(?:[eE][-+]?\d+|[kMGTPmunpf]|)|)/i,multiLineStrings:!0,typeFirstDefinitions:!0,atoms:oe("true false null larger smaller equal empty finished"),indentSwitch:!1,styleDefs:!1,hooks:{"@":function(ge){return ge.eatWhile(/[\w\$_]/),"meta"},'"':function(ge,me){return me.tokenize=De(ge.match('""')?"triple":"single"),me.tokenize(ge,me)},"`":function(ge,me){return!(!Le||!ge.match("`"))&&(me.tokenize=Le,Le=null,me.tokenize(ge,me))},"'":function(ge){return ge.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},token:function(ge,me,Xe){if(("variable"==Xe||"type"==Xe)&&"."==me.prevToken)return"variable-2"}},modeProps:{fold:["brace","import"],closeBrackets:{triples:'"'}}})}(Q(8266))},3993:(Xn,He,Q)=>{!function(M){"use strict";M.defineMode("jinja2",function(){var d=["and","as","block","endblock","by","cycle","debug","else","elif","extends","filter","endfilter","firstof","for","endfor","if","endif","ifchanged","endifchanged","ifequal","endifequal","ifnotequal","endifnotequal","in","include","load","not","now","or","parsed","regroup","reversed","spaceless","endspaceless","ssi","templatetag","openblock","closeblock","openvariable","closevariable","openbrace","closebrace","opencomment","closecomment","widthratio","url","with","endwith","get_current_language","trans","endtrans","noop","blocktrans","endblocktrans","get_available_languages","get_current_language_bidi","plural"],Ue=/^[+\-*&%=<>!?|~^]/,Oe=/^[:\[\(\{]/,ye=["true","false"],he=/^(\d[+\-\*\/])?\d+(\.\d+)?/;function oe(ce,fe){var le=ce.peek();if(fe.incomment)return ce.skipTo("#}")?(ce.eatWhile(/\#|}/),fe.incomment=!1):ce.skipToEnd(),"comment";if(fe.intag){if(fe.operator){if(fe.operator=!1,ce.match(ye))return"atom";if(ce.match(he))return"number"}if(fe.sign){if(fe.sign=!1,ce.match(ye))return"atom";if(ce.match(he))return"number"}if(fe.instring)return le==fe.instring&&(fe.instring=!1),ce.next(),"string";if("'"==le||'"'==le)return fe.instring=le,ce.next(),"string";if(ce.match(fe.intag+"}")||ce.eat("-")&&ce.match(fe.intag+"}"))return fe.intag=!1,"tag";if(ce.match(Ue))return fe.operator=!0,"operator";if(ce.match(Oe))fe.sign=!0;else if(ce.eat(" ")||ce.sol()){if(ce.match(d))return"keyword";if(ce.match(ye))return"atom";if(ce.match(he))return"number";ce.sol()&&ce.next()}else ce.next();return"variable"}if(ce.eat("{")){if(ce.eat("#"))return fe.incomment=!0,ce.skipTo("#}")?(ce.eatWhile(/\#|}/),fe.incomment=!1):ce.skipToEnd(),"comment";if(le=ce.eat(/\{|%/))return fe.intag=le,"{"==le&&(fe.intag="}"),ce.eat("-"),"tag"}ce.next()}return d=new RegExp("(("+d.join(")|(")+"))\\b"),ye=new RegExp("(("+ye.join(")|(")+"))\\b"),{startState:function(){return{tokenize:oe}},token:function(ce,fe){return fe.tokenize(ce,fe)},blockCommentStart:"{#",blockCommentEnd:"#}"}}),M.defineMIME("text/jinja2","jinja2")}(Q(8266))},5255:(Xn,He,Q)=>{!function(M){"use strict";function d(ce){return new RegExp("^(("+ce.join(")|(")+"))\\b")}var Ue=d(["and","or","not","is"]),Oe=["as","assert","break","class","continue","def","del","elif","else","except","finally","for","from","global","if","import","lambda","pass","raise","return","try","while","with","yield","in"],ye=["abs","all","any","bin","bool","bytearray","callable","chr","classmethod","compile","complex","delattr","dict","dir","divmod","enumerate","eval","filter","float","format","frozenset","getattr","globals","hasattr","hash","help","hex","id","input","int","isinstance","issubclass","iter","len","list","locals","map","max","memoryview","min","next","object","oct","open","ord","pow","property","range","repr","reversed","round","set","setattr","slice","sorted","staticmethod","str","sum","super","tuple","type","vars","zip","__import__","NotImplemented","Ellipsis","__debug__"];function he(ce){return ce.scopes[ce.scopes.length-1]}M.registerHelper("hintWords","python",Oe.concat(ye)),M.defineMode("python",function(ce,fe){for(var le="error",pe=fe.delimiters||fe.singleDelimiters||/^[\(\)\[\]\{\}@,:`=;\.\\]/,Me=[fe.singleOperators,fe.doubleOperators,fe.doubleDelimiters,fe.tripleDelimiters,fe.operators||/^([-+*/%\/&|^]=?|[<>=]+|\/\/=?|\*\*=?|!=|[~!@]|\.\.\.)/],Ae=0;Ae<Me.length;Ae++)Me[Ae]||Me.splice(Ae--,1);var dn=fe.hangingIndent||ce.indentUnit,rn=Oe,Ke=ye;null!=fe.extra_keywords&&(rn=rn.concat(fe.extra_keywords)),null!=fe.extra_builtins&&(Ke=Ke.concat(fe.extra_builtins));var Qe=!(fe.version&&Number(fe.version)<3);if(Qe){var ot=fe.identifiers||/^[_A-Za-z\u00A1-\uFFFF][_A-Za-z0-9\u00A1-\uFFFF]*/;rn=rn.concat(["nonlocal","False","True","None","async","await"]),Ke=Ke.concat(["ascii","bytes","exec","print"]);var Dn=new RegExp("^(([rbuf]|(br)|(rb)|(fr)|(rf))?('{3}|\"{3}|['\"]))","i")}else ot=fe.identifiers||/^[_A-Za-z][_A-Za-z0-9]*/,rn=rn.concat(["exec","print"]),Ke=Ke.concat(["apply","basestring","buffer","cmp","coerce","execfile","file","intern","long","raw_input","reduce","reload","unichr","unicode","xrange","False","True","None"]),Dn=new RegExp("^(([rubf]|(ur)|(br))?('{3}|\"{3}|['\"]))","i");var yn=d(rn),ut=d(Ke);function cn(Le,De){var ge=Le.sol()&&"\\"!=De.lastToken;if(ge&&(De.indent=Le.indentation()),ge&&"py"==he(De).type){var me=he(De).offset;if(Le.eatSpace()){var Xe=Le.indentation();return Xe>me?l1(De):Xe<me&&Yn(Le,De)&&"#"!=Le.peek()&&(De.errorToken=!0),null}var En=fn(Le,De);return me>0&&Yn(Le,De)&&(En+=" "+le),En}return fn(Le,De)}function fn(Le,De,ge){if(Le.eatSpace())return null;if(!ge&&Le.match(/^#.*/))return"comment";if(Le.match(/^[0-9\.]/,!1)){var me=!1;if(Le.match(/^[\d_]*\.\d+(e[\+\-]?\d+)?/i)&&(me=!0),Le.match(/^[\d_]+\.\d*/)&&(me=!0),Le.match(/^\.\d+/)&&(me=!0),me)return Le.eat(/J/i),"number";var Xe=!1;if(Le.match(/^0x[0-9a-f_]+/i)&&(Xe=!0),Le.match(/^0b[01_]+/i)&&(Xe=!0),Le.match(/^0o[0-7_]+/i)&&(Xe=!0),Le.match(/^[1-9][\d_]*(e[\+\-]?[\d_]+)?/)&&(Le.eat(/J/i),Xe=!0),Le.match(/^0(?![\dx])/i)&&(Xe=!0),Xe)return Le.eat(/L/i),"number"}if(Le.match(Dn))return-1!==Le.current().toLowerCase().indexOf("f")?(De.tokenize=function g1(Le,De){for(;"rubf".indexOf(Le.charAt(0).toLowerCase())>=0;)Le=Le.substr(1);var ge=1==Le.length,me="string";function Xe(Ln){return function(lt,Rt){var Zi=fn(lt,Rt,!0);return"punctuation"==Zi&&("{"==lt.current()?Rt.tokenize=Xe(Ln+1):"}"==lt.current()&&(Rt.tokenize=Ln>1?Xe(Ln-1):En)),Zi}}function En(Ln,lt){for(;!Ln.eol();)if(Ln.eatWhile(/[^'"\{\}\\]/),Ln.eat("\\")){if(Ln.next(),ge&&Ln.eol())return me}else{if(Ln.match(Le))return lt.tokenize=De,me;if(Ln.match("{{"))return me;if(Ln.match("{",!1))return lt.tokenize=Xe(0),Ln.current()?me:lt.tokenize(Ln,lt);if(Ln.match("}}"))return me;if(Ln.match("}"))return le;Ln.eat(/['"]/)}if(ge){if(fe.singleLineStringErrors)return le;lt.tokenize=De}return me}return En.isString=!0,En}(Le.current(),De.tokenize),De.tokenize(Le,De)):(De.tokenize=function mt(Le,De){for(;"rubf".indexOf(Le.charAt(0).toLowerCase())>=0;)Le=Le.substr(1);var ge=1==Le.length,me="string";function Xe(En,Ln){for(;!En.eol();)if(En.eatWhile(/[^'"\\]/),En.eat("\\")){if(En.next(),ge&&En.eol())return me}else{if(En.match(Le))return Ln.tokenize=De,me;En.eat(/['"]/)}if(ge){if(fe.singleLineStringErrors)return le;Ln.tokenize=De}return me}return Xe.isString=!0,Xe}(Le.current(),De.tokenize),De.tokenize(Le,De));for(var Ln=0;Ln<Me.length;Ln++)if(Le.match(Me[Ln]))return"operator";return Le.match(pe)?"punctuation":"."==De.lastToken&&Le.match(ot)?"property":Le.match(yn)||Le.match(Ue)?"keyword":Le.match(ut)?"builtin":Le.match(/^(self|cls)\b/)?"variable-2":Le.match(ot)?"def"==De.lastToken||"class"==De.lastToken?"def":"variable":(Le.next(),ge?null:le)}function l1(Le){for(;"py"!=he(Le).type;)Le.scopes.pop();Le.scopes.push({offset:he(Le).offset+ce.indentUnit,type:"py",align:null})}function Yn(Le,De){for(var ge=Le.indentation();De.scopes.length>1&&he(De).offset>ge;){if("py"!=he(De).type)return!0;De.scopes.pop()}return he(De).offset!=ge}function tt(Le,De){Le.sol()&&(De.beginningOfLine=!0,De.dedent=!1);var ge=De.tokenize(Le,De),me=Le.current();if(De.beginningOfLine&&"@"==me)return Le.match(ot,!1)?"meta":Qe?"operator":le;if(/\S/.test(me)&&(De.beginningOfLine=!1),("variable"==ge||"builtin"==ge)&&"meta"==De.lastToken&&(ge="meta"),("pass"==me||"return"==me)&&(De.dedent=!0),"lambda"==me&&(De.lambda=!0),":"==me&&!De.lambda&&"py"==he(De).type&&Le.match(/^\s*(?:#|$)/,!1)&&l1(De),1==me.length&&!/string|comment/.test(ge)){var Xe="[({".indexOf(me);if(-1!=Xe&&function tn(Le,De,ge){var me=Le.match(/^[\s\[\{\(]*(?:#|$)/,!1)?null:Le.column()+1;De.scopes.push({offset:De.indent+dn,type:ge,align:me})}(Le,De,"])}".slice(Xe,Xe+1)),-1!=(Xe="])}".indexOf(me))){if(he(De).type!=me)return le;De.indent=De.scopes.pop().offset-dn}}return De.dedent&&Le.eol()&&"py"==he(De).type&&De.scopes.length>1&&De.scopes.pop(),ge}return{startState:function(Le){return{tokenize:cn,scopes:[{offset:Le||0,type:"py",align:null}],indent:Le||0,lastToken:null,lambda:!1,dedent:0}},token:function(Le,De){var ge=De.errorToken;ge&&(De.errorToken=!1);var me=tt(Le,De);return me&&"comment"!=me&&(De.lastToken="keyword"==me||"punctuation"==me?Le.current():me),"punctuation"==me&&(me=null),Le.eol()&&De.lambda&&(De.lambda=!1),ge?me+" "+le:me},indent:function(Le,De){if(Le.tokenize!=cn)return Le.tokenize.isString?M.Pass:0;var ge=he(Le),me=ge.type==De.charAt(0)||"py"==ge.type&&!Le.dedent&&/^(else:|elif |except |finally:)/.test(De);return null!=ge.align?ge.align-(me?1:0):ge.offset-(me?dn:0)},electricInput:/^\s*([\}\]\)]|else:|elif |except |finally:)$/,closeBrackets:{triples:"'\""},lineComment:"#",fold:"indent"}}),M.defineMIME("text/x-python","python"),M.defineMIME("text/x-cython",{name:"python",extra_keywords:"by cdef cimport cpdef ctypedef enum except extern gil include nogil property public readonly struct union DEF IF ELIF ELSE".split(" ")})}(Q(8266))},591:(Xn,He,Q)=>{"use strict";Q.d(He,{X:()=>Ue});var M=Q(5529),d=Q(5279);class Ue extends M.xQ{constructor(ye){super(),this._value=ye}get value(){return this.getValue()}_subscribe(ye){const he=super._subscribe(ye);return he&&!he.closed&&ye.next(this._value),he}getValue(){if(this.hasError)throw this.thrownError;if(this.closed)throw new d.N;return this._value}next(ye){super.next(this._value=ye)}}},2916:(Xn,He,Q)=>{"use strict";Q.d(He,{y:()=>pe});var M=Q(3489),Ue=Q(7668),Oe=Q(3292),he=Q(3821),oe=Q(5379);var le=Q(2830);let pe=(()=>{class Ae{constructor(rn){this._isScalar=!1,rn&&(this._subscribe=rn)}lift(rn){const Ke=new Ae;return Ke.source=this,Ke.operator=rn,Ke}subscribe(rn,Ke,Qe){const{operator:ot}=this,Dn=function ye(Ae,dn,rn){if(Ae){if(Ae instanceof M.L)return Ae;if(Ae[Ue.b])return Ae[Ue.b]()}return Ae||dn||rn?new M.L(Ae,dn,rn):new M.L(Oe.c)}(rn,Ke,Qe);if(Dn.add(ot?ot.call(Dn,this.source):this.source||le.v.useDeprecatedSynchronousErrorHandling&&!Dn.syncErrorThrowable?this._subscribe(Dn):this._trySubscribe(Dn)),le.v.useDeprecatedSynchronousErrorHandling&&Dn.syncErrorThrowable&&(Dn.syncErrorThrowable=!1,Dn.syncErrorThrown))throw Dn.syncErrorValue;return Dn}_trySubscribe(rn){try{return this._subscribe(rn)}catch(Ke){le.v.useDeprecatedSynchronousErrorHandling&&(rn.syncErrorThrown=!0,rn.syncErrorValue=Ke),function d(Ae){for(;Ae;){const{closed:dn,destination:rn,isStopped:Ke}=Ae;if(dn||Ke)return!1;Ae=rn&&rn instanceof M.L?rn:null}return!0}(rn)?rn.error(Ke):console.warn(Ke)}}forEach(rn,Ke){return new(Ke=Me(Ke))((Qe,ot)=>{let Dn;Dn=this.subscribe(yn=>{try{rn(yn)}catch(ut){ot(ut),Dn&&Dn.unsubscribe()}},ot,Qe)})}_subscribe(rn){const{source:Ke}=this;return Ke&&Ke.subscribe(rn)}[he.L](){return this}pipe(...rn){return 0===rn.length?this:function fe(Ae){return 0===Ae.length?oe.y:1===Ae.length?Ae[0]:function(rn){return Ae.reduce((Ke,Qe)=>Qe(Ke),rn)}}(rn)(this)}toPromise(rn){return new(rn=Me(rn))((Ke,Qe)=>{let ot;this.subscribe(Dn=>ot=Dn,Dn=>Qe(Dn),()=>Ke(ot))})}}return Ae.create=dn=>new Ae(dn),Ae})();function Me(Ae){if(Ae||(Ae=le.v.Promise||Promise),!Ae)throw new Error("no Promise impl found");return Ae}},3292:(Xn,He,Q)=>{"use strict";Q.d(He,{c:()=>Ue});var M=Q(2830),d=Q(2782);const Ue={closed:!0,next(Oe){},error(Oe){if(M.v.useDeprecatedSynchronousErrorHandling)throw Oe;(0,d.z)(Oe)},complete(){}}},826:(Xn,He,Q)=>{"use strict";Q.d(He,{L:()=>d});var M=Q(3489);class d extends M.L{notifyNext(Oe,ye,he,oe,ce){this.destination.next(ye)}notifyError(Oe,ye){this.destination.error(Oe)}notifyComplete(Oe){this.destination.complete()}}},5529:(Xn,He,Q)=>{"use strict";Q.d(He,{xQ:()=>ce,Yc:()=>oe});var M=Q(2916),d=Q(3489),Ue=Q(2654),Oe=Q(5279);class ye extends Ue.w{constructor(pe,Me){super(),this.subject=pe,this.subscriber=Me,this.closed=!1}unsubscribe(){if(this.closed)return;this.closed=!0;const pe=this.subject,Me=pe.observers;if(this.subject=null,!Me||0===Me.length||pe.isStopped||pe.closed)return;const Ae=Me.indexOf(this.subscriber);-1!==Ae&&Me.splice(Ae,1)}}var he=Q(7668);class oe extends d.L{constructor(pe){super(pe),this.destination=pe}}let ce=(()=>{class le extends M.y{constructor(){super(),this.observers=[],this.closed=!1,this.isStopped=!1,this.hasError=!1,this.thrownError=null}[he.b](){return new oe(this)}lift(Me){const Ae=new fe(this,this);return Ae.operator=Me,Ae}next(Me){if(this.closed)throw new Oe.N;if(!this.isStopped){const{observers:Ae}=this,dn=Ae.length,rn=Ae.slice();for(let Ke=0;Ke<dn;Ke++)rn[Ke].next(Me)}}error(Me){if(this.closed)throw new Oe.N;this.hasError=!0,this.thrownError=Me,this.isStopped=!0;const{observers:Ae}=this,dn=Ae.length,rn=Ae.slice();for(let Ke=0;Ke<dn;Ke++)rn[Ke].error(Me);this.observers.length=0}complete(){if(this.closed)throw new Oe.N;this.isStopped=!0;const{observers:Me}=this,Ae=Me.length,dn=Me.slice();for(let rn=0;rn<Ae;rn++)dn[rn].complete();this.observers.length=0}unsubscribe(){this.isStopped=!0,this.closed=!0,this.observers=null}_trySubscribe(Me){if(this.closed)throw new Oe.N;return super._trySubscribe(Me)}_subscribe(Me){if(this.closed)throw new Oe.N;return this.hasError?(Me.error(this.thrownError),Ue.w.EMPTY):this.isStopped?(Me.complete(),Ue.w.EMPTY):(this.observers.push(Me),new ye(this,Me))}asObservable(){const Me=new M.y;return Me.source=this,Me}}return le.create=(pe,Me)=>new fe(pe,Me),le})();class fe extends ce{constructor(pe,Me){super(),this.destination=pe,this.source=Me}next(pe){const{destination:Me}=this;Me&&Me.next&&Me.next(pe)}error(pe){const{destination:Me}=this;Me&&Me.error&&this.destination.error(pe)}complete(){const{destination:pe}=this;pe&&pe.complete&&this.destination.complete()}_subscribe(pe){const{source:Me}=this;return Me?this.source.subscribe(pe):Ue.w.EMPTY}}},3489:(Xn,He,Q)=>{"use strict";Q.d(He,{L:()=>oe});var M=Q(7043),d=Q(3292),Ue=Q(2654),Oe=Q(7668),ye=Q(2830),he=Q(2782);class oe extends Ue.w{constructor(le,pe,Me){switch(super(),this.syncErrorValue=null,this.syncErrorThrown=!1,this.syncErrorThrowable=!1,this.isStopped=!1,arguments.length){case 0:this.destination=d.c;break;case 1:if(!le){this.destination=d.c;break}if("object"==typeof le){le instanceof oe?(this.syncErrorThrowable=le.syncErrorThrowable,this.destination=le,le.add(this)):(this.syncErrorThrowable=!0,this.destination=new ce(this,le));break}default:this.syncErrorThrowable=!0,this.destination=new ce(this,le,pe,Me)}}[Oe.b](){return this}static create(le,pe,Me){const Ae=new oe(le,pe,Me);return Ae.syncErrorThrowable=!1,Ae}next(le){this.isStopped||this._next(le)}error(le){this.isStopped||(this.isStopped=!0,this._error(le))}complete(){this.isStopped||(this.isStopped=!0,this._complete())}unsubscribe(){this.closed||(this.isStopped=!0,super.unsubscribe())}_next(le){this.destination.next(le)}_error(le){this.destination.error(le),this.unsubscribe()}_complete(){this.destination.complete(),this.unsubscribe()}_unsubscribeAndRecycle(){const{_parentOrParents:le}=this;return this._parentOrParents=null,this.unsubscribe(),this.closed=!1,this.isStopped=!1,this._parentOrParents=le,this}}class ce extends oe{constructor(le,pe,Me,Ae){super(),this._parentSubscriber=le;let dn,rn=this;(0,M.m)(pe)?dn=pe:pe&&(dn=pe.next,Me=pe.error,Ae=pe.complete,pe!==d.c&&(rn=Object.create(pe),(0,M.m)(rn.unsubscribe)&&this.add(rn.unsubscribe.bind(rn)),rn.unsubscribe=this.unsubscribe.bind(this))),this._context=rn,this._next=dn,this._error=Me,this._complete=Ae}next(le){if(!this.isStopped&&this._next){const{_parentSubscriber:pe}=this;ye.v.useDeprecatedSynchronousErrorHandling&&pe.syncErrorThrowable?this.__tryOrSetError(pe,this._next,le)&&this.unsubscribe():this.__tryOrUnsub(this._next,le)}}error(le){if(!this.isStopped){const{_parentSubscriber:pe}=this,{useDeprecatedSynchronousErrorHandling:Me}=ye.v;if(this._error)Me&&pe.syncErrorThrowable?(this.__tryOrSetError(pe,this._error,le),this.unsubscribe()):(this.__tryOrUnsub(this._error,le),this.unsubscribe());else if(pe.syncErrorThrowable)Me?(pe.syncErrorValue=le,pe.syncErrorThrown=!0):(0,he.z)(le),this.unsubscribe();else{if(this.unsubscribe(),Me)throw le;(0,he.z)(le)}}}complete(){if(!this.isStopped){const{_parentSubscriber:le}=this;if(this._complete){const pe=()=>this._complete.call(this._context);ye.v.useDeprecatedSynchronousErrorHandling&&le.syncErrorThrowable?(this.__tryOrSetError(le,pe),this.unsubscribe()):(this.__tryOrUnsub(pe),this.unsubscribe())}else this.unsubscribe()}}__tryOrUnsub(le,pe){try{le.call(this._context,pe)}catch(Me){if(this.unsubscribe(),ye.v.useDeprecatedSynchronousErrorHandling)throw Me;(0,he.z)(Me)}}__tryOrSetError(le,pe,Me){if(!ye.v.useDeprecatedSynchronousErrorHandling)throw new Error("bad call");try{pe.call(this._context,Me)}catch(Ae){return ye.v.useDeprecatedSynchronousErrorHandling?(le.syncErrorValue=Ae,le.syncErrorThrown=!0,!0):((0,he.z)(Ae),!0)}return!1}_unsubscribe(){const{_parentSubscriber:le}=this;this._context=null,this._parentSubscriber=null,le.unsubscribe()}}},2654:(Xn,He,Q)=>{"use strict";Q.d(He,{w:()=>he});var M=Q(6688),d=Q(7830),Ue=Q(7043);const ye=(()=>{function ce(fe){return Error.call(this),this.message=fe?`${fe.length} errors occurred during unsubscription:\n${fe.map((le,pe)=>`${pe+1}) ${le.toString()}`).join("\n  ")}`:"",this.name="UnsubscriptionError",this.errors=fe,this}return ce.prototype=Object.create(Error.prototype),ce})();class he{constructor(fe){this.closed=!1,this._parentOrParents=null,this._subscriptions=null,fe&&(this._ctorUnsubscribe=!0,this._unsubscribe=fe)}unsubscribe(){let fe;if(this.closed)return;let{_parentOrParents:le,_ctorUnsubscribe:pe,_unsubscribe:Me,_subscriptions:Ae}=this;if(this.closed=!0,this._parentOrParents=null,this._subscriptions=null,le instanceof he)le.remove(this);else if(null!==le)for(let dn=0;dn<le.length;++dn)le[dn].remove(this);if((0,Ue.m)(Me)){pe&&(this._unsubscribe=void 0);try{Me.call(this)}catch(dn){fe=dn instanceof ye?oe(dn.errors):[dn]}}if((0,M.k)(Ae)){let dn=-1,rn=Ae.length;for(;++dn<rn;){const Ke=Ae[dn];if((0,d.K)(Ke))try{Ke.unsubscribe()}catch(Qe){fe=fe||[],Qe instanceof ye?fe=fe.concat(oe(Qe.errors)):fe.push(Qe)}}}if(fe)throw new ye(fe)}add(fe){let le=fe;if(!fe)return he.EMPTY;switch(typeof fe){case"function":le=new he(fe);case"object":if(le===this||le.closed||"function"!=typeof le.unsubscribe)return le;if(this.closed)return le.unsubscribe(),le;if(!(le instanceof he)){const Ae=le;le=new he,le._subscriptions=[Ae]}break;default:throw new Error("unrecognized teardown "+fe+" added to Subscription.")}let{_parentOrParents:pe}=le;if(null===pe)le._parentOrParents=this;else if(pe instanceof he){if(pe===this)return le;le._parentOrParents=[pe,this]}else{if(-1!==pe.indexOf(this))return le;pe.push(this)}const Me=this._subscriptions;return null===Me?this._subscriptions=[le]:Me.push(le),le}remove(fe){const le=this._subscriptions;if(le){const pe=le.indexOf(fe);-1!==pe&&le.splice(pe,1)}}}var ce;function oe(ce){return ce.reduce((fe,le)=>fe.concat(le instanceof ye?le.errors:le),[])}he.EMPTY=((ce=new he).closed=!0,ce)},2830:(Xn,He,Q)=>{"use strict";Q.d(He,{v:()=>d});let M=!1;const d={Promise:void 0,set useDeprecatedSynchronousErrorHandling(Ue){if(Ue){const Oe=new Error;console.warn("DEPRECATED! RxJS was set to use deprecated synchronous error handling behavior by code at: \n"+Oe.stack)}else M&&console.log("RxJS: Back to a better error behavior. Thank you. <3");M=Ue},get useDeprecatedSynchronousErrorHandling(){return M}}},1177:(Xn,He,Q)=>{"use strict";Q.d(He,{IY:()=>Oe,Ds:()=>he,ft:()=>ce});var M=Q(3489),d=Q(2916),Ue=Q(9249);class Oe extends M.L{constructor(le){super(),this.parent=le}_next(le){this.parent.notifyNext(le)}_error(le){this.parent.notifyError(le),this.unsubscribe()}_complete(){this.parent.notifyComplete(),this.unsubscribe()}}class he extends M.L{notifyNext(le){this.destination.next(le)}notifyError(le){this.destination.error(le)}notifyComplete(){this.destination.complete()}}function ce(fe,le){if(le.closed)return;if(fe instanceof d.y)return fe.subscribe(le);let pe;try{pe=(0,Ue.s)(fe)(le)}catch(Me){le.error(Me)}return pe}},1762:(Xn,He,Q)=>{"use strict";Q.d(He,{c:()=>ye,N:()=>he});var M=Q(5529),d=Q(2916),Ue=Q(2654),Oe=Q(4327);class ye extends d.y{constructor(pe,Me){super(),this.source=pe,this.subjectFactory=Me,this._refCount=0,this._isComplete=!1}_subscribe(pe){return this.getSubject().subscribe(pe)}getSubject(){const pe=this._subject;return(!pe||pe.isStopped)&&(this._subject=this.subjectFactory()),this._subject}connect(){let pe=this._connection;return pe||(this._isComplete=!1,pe=this._connection=new Ue.w,pe.add(this.source.subscribe(new oe(this.getSubject(),this))),pe.closed&&(this._connection=null,pe=Ue.w.EMPTY)),pe}refCount(){return(0,Oe.x)()(this)}}const he=(()=>{const le=ye.prototype;return{operator:{value:null},_refCount:{value:0,writable:!0},_subject:{value:null,writable:!0},_connection:{value:null,writable:!0},_subscribe:{value:le._subscribe},_isComplete:{value:le._isComplete,writable:!0},getSubject:{value:le.getSubject},connect:{value:le.connect},refCount:{value:le.refCount}}})();class oe extends M.Yc{constructor(pe,Me){super(pe),this.connectable=Me}_error(pe){this._unsubscribe(),super._error(pe)}_complete(){this.connectable._isComplete=!0,this._unsubscribe(),super._complete()}_unsubscribe(){const pe=this.connectable;if(pe){this.connectable=null;const Me=pe._connection;pe._refCount=0,pe._subject=null,pe._connection=null,Me&&Me.unsubscribe()}}}},6053:(Xn,He,Q)=>{"use strict";Q.d(He,{aj:()=>oe});var M=Q(2866),d=Q(6688),Ue=Q(826),Oe=Q(448),ye=Q(3009);const he={};function oe(...le){let pe,Me;return(0,M.K)(le[le.length-1])&&(Me=le.pop()),"function"==typeof le[le.length-1]&&(pe=le.pop()),1===le.length&&(0,d.k)(le[0])&&(le=le[0]),(0,ye.n)(le,Me).lift(new ce(pe))}class ce{constructor(pe){this.resultSelector=pe}call(pe,Me){return Me.subscribe(new fe(pe,this.resultSelector))}}class fe extends Ue.L{constructor(pe,Me){super(pe),this.resultSelector=Me,this.active=0,this.values=[],this.observables=[]}_next(pe){this.values.push(he),this.observables.push(pe)}_complete(){const pe=this.observables,Me=pe.length;if(0===Me)this.destination.complete();else{this.active=Me,this.toRespond=Me;for(let Ae=0;Ae<Me;Ae++)this.add((0,Oe.D)(this,pe[Ae],void 0,Ae))}}notifyComplete(pe){0==(this.active-=1)&&this.destination.complete()}notifyNext(pe,Me,Ae){const dn=this.values,Ke=this.toRespond?dn[Ae]===he?--this.toRespond:this.toRespond:0;dn[Ae]=Me,0===Ke&&(this.resultSelector?this._tryResultSelector(dn):this.destination.next(dn.slice()))}_tryResultSelector(pe){let Me;try{Me=this.resultSelector.apply(this,pe)}catch(Ae){return void this.destination.error(Ae)}this.destination.next(Me)}}},1221:(Xn,He,Q)=>{"use strict";Q.d(He,{z:()=>Oe});var M=Q(1086),d=Q(9146);function Oe(...ye){return function Ue(){return(0,d.J)(1)}()((0,M.of)(...ye))}},8896:(Xn,He,Q)=>{"use strict";Q.d(He,{E:()=>d,c:()=>Ue});var M=Q(2916);const d=new M.y(ye=>ye.complete());function Ue(ye){return ye?function Oe(ye){return new M.y(he=>ye.schedule(()=>he.complete()))}(ye):d}},5254:(Xn,He,Q)=>{"use strict";Q.d(He,{D:()=>rn});var M=Q(2916),d=Q(9249),Ue=Q(2654),Oe=Q(3821),oe=Q(6454),ce=Q(5430),pe=Q(8955),Me=Q(8515);function rn(Ke,Qe){return Qe?function dn(Ke,Qe){if(null!=Ke){if(function le(Ke){return Ke&&"function"==typeof Ke[Oe.L]}(Ke))return function ye(Ke,Qe){return new M.y(ot=>{const Dn=new Ue.w;return Dn.add(Qe.schedule(()=>{const yn=Ke[Oe.L]();Dn.add(yn.subscribe({next(ut){Dn.add(Qe.schedule(()=>ot.next(ut)))},error(ut){Dn.add(Qe.schedule(()=>ot.error(ut)))},complete(){Dn.add(Qe.schedule(()=>ot.complete()))}}))})),Dn})}(Ke,Qe);if((0,pe.t)(Ke))return function he(Ke,Qe){return new M.y(ot=>{const Dn=new Ue.w;return Dn.add(Qe.schedule(()=>Ke.then(yn=>{Dn.add(Qe.schedule(()=>{ot.next(yn),Dn.add(Qe.schedule(()=>ot.complete()))}))},yn=>{Dn.add(Qe.schedule(()=>ot.error(yn)))}))),Dn})}(Ke,Qe);if((0,Me.z)(Ke))return(0,oe.r)(Ke,Qe);if(function Ae(Ke){return Ke&&"function"==typeof Ke[ce.hZ]}(Ke)||"string"==typeof Ke)return function fe(Ke,Qe){if(!Ke)throw new Error("Iterable cannot be null");return new M.y(ot=>{const Dn=new Ue.w;let yn;return Dn.add(()=>{yn&&"function"==typeof yn.return&&yn.return()}),Dn.add(Qe.schedule(()=>{yn=Ke[ce.hZ](),Dn.add(Qe.schedule(function(){if(ot.closed)return;let ut,cn;try{const fn=yn.next();ut=fn.value,cn=fn.done}catch(fn){return void ot.error(fn)}cn?ot.complete():(ot.next(ut),this.schedule())}))})),Dn})}(Ke,Qe)}throw new TypeError((null!==Ke&&typeof Ke||Ke)+" is not observable")}(Ke,Qe):Ke instanceof M.y?Ke:new M.y((0,d.s)(Ke))}},3009:(Xn,He,Q)=>{"use strict";Q.d(He,{n:()=>Oe});var M=Q(2916),d=Q(3650),Ue=Q(6454);function Oe(ye,he){return he?(0,Ue.r)(ye,he):new M.y((0,d.V)(ye))}},6787:(Xn,He,Q)=>{"use strict";Q.d(He,{T:()=>ye});var M=Q(2916),d=Q(2866),Ue=Q(9146),Oe=Q(3009);function ye(...he){let oe=Number.POSITIVE_INFINITY,ce=null,fe=he[he.length-1];return(0,d.K)(fe)?(ce=he.pop(),he.length>1&&"number"==typeof he[he.length-1]&&(oe=he.pop())):"number"==typeof fe&&(oe=he.pop()),null===ce&&1===he.length&&he[0]instanceof M.y?he[0]:(0,Ue.J)(oe)((0,Oe.n)(he,ce))}},1086:(Xn,He,Q)=>{"use strict";Q.d(He,{of:()=>Oe});var M=Q(2866),d=Q(3009),Ue=Q(6454);function Oe(...ye){let he=ye[ye.length-1];return(0,M.K)(he)?(ye.pop(),(0,Ue.r)(ye,he)):(0,d.n)(ye)}},1737:(Xn,He,Q)=>{"use strict";Q.d(He,{_:()=>d});var M=Q(2916);function d(Oe,ye){return new M.y(ye?he=>ye.schedule(Ue,0,{error:Oe,subscriber:he}):he=>he.error(Oe))}function Ue({error:Oe,subscriber:ye}){ye.error(Oe)}},1406:(Xn,He,Q)=>{"use strict";Q.d(He,{b:()=>d});var M=Q(1709);function d(Ue,Oe){return(0,M.zg)(Ue,Oe,1)}},2198:(Xn,He,Q)=>{"use strict";Q.d(He,{h:()=>d});var M=Q(3489);function d(ye,he){return function(ce){return ce.lift(new Ue(ye,he))}}class Ue{constructor(he,oe){this.predicate=he,this.thisArg=oe}call(he,oe){return oe.subscribe(new Oe(he,this.predicate,this.thisArg))}}class Oe extends M.L{constructor(he,oe,ce){super(he),this.predicate=oe,this.thisArg=ce,this.count=0}_next(he){let oe;try{oe=this.predicate.call(this.thisArg,he,this.count++)}catch(ce){return void this.destination.error(ce)}oe&&this.destination.next(he)}}},4850:(Xn,He,Q)=>{"use strict";Q.d(He,{U:()=>d});var M=Q(3489);function d(ye,he){return function(ce){if("function"!=typeof ye)throw new TypeError("argument is not a function. Are you looking for `mapTo()`?");return ce.lift(new Ue(ye,he))}}class Ue{constructor(he,oe){this.project=he,this.thisArg=oe}call(he,oe){return oe.subscribe(new Oe(he,this.project,this.thisArg))}}class Oe extends M.L{constructor(he,oe,ce){super(he),this.project=oe,this.count=0,this.thisArg=ce||this}_next(he){let oe;try{oe=this.project.call(this.thisArg,he,this.count++)}catch(ce){return void this.destination.error(ce)}this.destination.next(oe)}}},9146:(Xn,He,Q)=>{"use strict";Q.d(He,{J:()=>Ue});var M=Q(1709),d=Q(5379);function Ue(Oe=Number.POSITIVE_INFINITY){return(0,M.zg)(d.y,Oe)}},1709:(Xn,He,Q)=>{"use strict";Q.d(He,{zg:()=>Oe});var M=Q(4850),d=Q(5254),Ue=Q(1177);function Oe(ce,fe,le=Number.POSITIVE_INFINITY){return"function"==typeof fe?pe=>pe.pipe(Oe((Me,Ae)=>(0,d.D)(ce(Me,Ae)).pipe((0,M.U)((dn,rn)=>fe(Me,dn,Ae,rn))),le)):("number"==typeof fe&&(le=fe),pe=>pe.lift(new ye(ce,le)))}class ye{constructor(fe,le=Number.POSITIVE_INFINITY){this.project=fe,this.concurrent=le}call(fe,le){return le.subscribe(new he(fe,this.project,this.concurrent))}}class he extends Ue.Ds{constructor(fe,le,pe=Number.POSITIVE_INFINITY){super(fe),this.project=le,this.concurrent=pe,this.hasCompleted=!1,this.buffer=[],this.active=0,this.index=0}_next(fe){this.active<this.concurrent?this._tryNext(fe):this.buffer.push(fe)}_tryNext(fe){let le;const pe=this.index++;try{le=this.project(fe,pe)}catch(Me){return void this.destination.error(Me)}this.active++,this._innerSub(le)}_innerSub(fe){const le=new Ue.IY(this),pe=this.destination;pe.add(le);const Me=(0,Ue.ft)(fe,le);Me!==le&&pe.add(Me)}_complete(){this.hasCompleted=!0,0===this.active&&0===this.buffer.length&&this.destination.complete(),this.unsubscribe()}notifyNext(fe){this.destination.next(fe)}notifyComplete(){const fe=this.buffer;this.active--,fe.length>0?this._next(fe.shift()):0===this.active&&this.hasCompleted&&this.destination.complete()}}},4327:(Xn,He,Q)=>{"use strict";Q.d(He,{x:()=>d});var M=Q(3489);function d(){return function(he){return he.lift(new Ue(he))}}class Ue{constructor(he){this.connectable=he}call(he,oe){const{connectable:ce}=this;ce._refCount++;const fe=new Oe(he,ce),le=oe.subscribe(fe);return fe.closed||(fe.connection=ce.connect()),le}}class Oe extends M.L{constructor(he,oe){super(he),this.connectable=oe}_unsubscribe(){const{connectable:he}=this;if(!he)return void(this.connection=null);this.connectable=null;const oe=he._refCount;if(oe<=0)return void(this.connection=null);if(he._refCount=oe-1,oe>1)return void(this.connection=null);const{connection:ce}=this,fe=he._connection;this.connection=null,fe&&(!ce||fe===ce)&&fe.unsubscribe()}}},1059:(Xn,He,Q)=>{"use strict";Q.d(He,{O:()=>Ue});var M=Q(1221),d=Q(2866);function Ue(...Oe){const ye=Oe[Oe.length-1];return(0,d.K)(ye)?(Oe.pop(),he=>(0,M.z)(Oe,he,ye)):he=>(0,M.z)(Oe,he)}},7545:(Xn,He,Q)=>{"use strict";Q.d(He,{w:()=>Oe});var M=Q(4850),d=Q(5254),Ue=Q(1177);function Oe(oe,ce){return"function"==typeof ce?fe=>fe.pipe(Oe((le,pe)=>(0,d.D)(oe(le,pe)).pipe((0,M.U)((Me,Ae)=>ce(le,Me,pe,Ae))))):fe=>fe.lift(new ye(oe))}class ye{constructor(ce){this.project=ce}call(ce,fe){return fe.subscribe(new he(ce,this.project))}}class he extends Ue.Ds{constructor(ce,fe){super(ce),this.project=fe,this.index=0}_next(ce){let fe;const le=this.index++;try{fe=this.project(ce,le)}catch(pe){return void this.destination.error(pe)}this._innerSub(fe)}_innerSub(ce){const fe=this.innerSubscription;fe&&fe.unsubscribe();const le=new Ue.IY(this),pe=this.destination;pe.add(le),this.innerSubscription=(0,Ue.ft)(ce,le),this.innerSubscription!==le&&pe.add(this.innerSubscription)}_complete(){const{innerSubscription:ce}=this;(!ce||ce.closed)&&super._complete(),this.unsubscribe()}_unsubscribe(){this.innerSubscription=void 0}notifyComplete(){this.innerSubscription=void 0,this.isStopped&&super._complete()}notifyNext(ce){this.destination.next(ce)}}},2986:(Xn,He,Q)=>{"use strict";Q.d(He,{q:()=>Oe});var M=Q(3489),d=Q(4231),Ue=Q(8896);function Oe(oe){return ce=>0===oe?(0,Ue.c)():ce.lift(new ye(oe))}class ye{constructor(ce){if(this.total=ce,this.total<0)throw new d.W}call(ce,fe){return fe.subscribe(new he(ce,this.total))}}class he extends M.L{constructor(ce,fe){super(ce),this.total=fe,this.count=0}_next(ce){const fe=this.total,le=++this.count;le<=fe&&(this.destination.next(ce),le===fe&&(this.destination.complete(),this.unsubscribe()))}}},2994:(Xn,He,Q)=>{"use strict";Q.d(He,{b:()=>Oe});var M=Q(3489),d=Q(7876),Ue=Q(7043);function Oe(oe,ce,fe){return function(pe){return pe.lift(new ye(oe,ce,fe))}}class ye{constructor(ce,fe,le){this.nextOrObserver=ce,this.error=fe,this.complete=le}call(ce,fe){return fe.subscribe(new he(ce,this.nextOrObserver,this.error,this.complete))}}class he extends M.L{constructor(ce,fe,le,pe){super(ce),this._tapNext=d.Z,this._tapError=d.Z,this._tapComplete=d.Z,this._tapError=le||d.Z,this._tapComplete=pe||d.Z,(0,Ue.m)(fe)?(this._context=this,this._tapNext=fe):fe&&(this._context=fe,this._tapNext=fe.next||d.Z,this._tapError=fe.error||d.Z,this._tapComplete=fe.complete||d.Z)}_next(ce){try{this._tapNext.call(this._context,ce)}catch(fe){return void this.destination.error(fe)}this.destination.next(ce)}_error(ce){try{this._tapError.call(this._context,ce)}catch(fe){return void this.destination.error(fe)}this.destination.error(ce)}_complete(){try{this._tapComplete.call(this._context)}catch(ce){return void this.destination.error(ce)}return this.destination.complete()}}},6454:(Xn,He,Q)=>{"use strict";Q.d(He,{r:()=>Ue});var M=Q(2916),d=Q(2654);function Ue(Oe,ye){return new M.y(he=>{const oe=new d.w;let ce=0;return oe.add(ye.schedule(function(){ce!==Oe.length?(he.next(Oe[ce++]),he.closed||oe.add(this.schedule())):he.complete()})),oe})}},6686:(Xn,He,Q)=>{"use strict";Q.d(He,{o:()=>Ue});var M=Q(2654);class d extends M.w{constructor(ye,he){super()}schedule(ye,he=0){return this}}class Ue extends d{constructor(ye,he){super(ye,he),this.scheduler=ye,this.work=he,this.pending=!1}schedule(ye,he=0){if(this.closed)return this;this.state=ye;const oe=this.id,ce=this.scheduler;return null!=oe&&(this.id=this.recycleAsyncId(ce,oe,he)),this.pending=!0,this.delay=he,this.id=this.id||this.requestAsyncId(ce,this.id,he),this}requestAsyncId(ye,he,oe=0){return setInterval(ye.flush.bind(ye,this),oe)}recycleAsyncId(ye,he,oe=0){if(null!==oe&&this.delay===oe&&!1===this.pending)return he;clearInterval(he)}execute(ye,he){if(this.closed)return new Error("executing a cancelled action");this.pending=!1;const oe=this._execute(ye,he);if(oe)return oe;!1===this.pending&&null!=this.id&&(this.id=this.recycleAsyncId(this.scheduler,this.id,null))}_execute(ye,he){let ce,oe=!1;try{this.work(ye)}catch(fe){oe=!0,ce=!!fe&&fe||new Error(fe)}if(oe)return this.unsubscribe(),ce}_unsubscribe(){const ye=this.id,he=this.scheduler,oe=he.actions,ce=oe.indexOf(this);this.work=null,this.state=null,this.pending=!1,this.scheduler=null,-1!==ce&&oe.splice(ce,1),null!=ye&&(this.id=this.recycleAsyncId(he,ye,null)),this.delay=null}}},2268:(Xn,He,Q)=>{"use strict";Q.d(He,{v:()=>d});let M=(()=>{class Ue{constructor(ye,he=Ue.now){this.SchedulerAction=ye,this.now=he}schedule(ye,he=0,oe){return new this.SchedulerAction(this,ye).schedule(oe,he)}}return Ue.now=()=>Date.now(),Ue})();class d extends M{constructor(Oe,ye=M.now){super(Oe,()=>d.delegate&&d.delegate!==this?d.delegate.now():ye()),this.actions=[],this.active=!1,this.scheduled=void 0}schedule(Oe,ye=0,he){return d.delegate&&d.delegate!==this?d.delegate.schedule(Oe,ye,he):super.schedule(Oe,ye,he)}flush(Oe){const{actions:ye}=this;if(this.active)return void ye.push(Oe);let he;this.active=!0;do{if(he=Oe.execute(Oe.state,Oe.delay))break}while(Oe=ye.shift());if(this.active=!1,he){for(;Oe=ye.shift();)Oe.unsubscribe();throw he}}}},5430:(Xn,He,Q)=>{"use strict";Q.d(He,{hZ:()=>d});const d=function M(){return"function"==typeof Symbol&&Symbol.iterator?Symbol.iterator:"@@iterator"}()},3821:(Xn,He,Q)=>{"use strict";Q.d(He,{L:()=>M});const M="function"==typeof Symbol&&Symbol.observable||"@@observable"},7668:(Xn,He,Q)=>{"use strict";Q.d(He,{b:()=>M});const M="function"==typeof Symbol?Symbol("rxSubscriber"):"@@rxSubscriber_"+Math.random()},4231:(Xn,He,Q)=>{"use strict";Q.d(He,{W:()=>d});const d=(()=>{function Ue(){return Error.call(this),this.message="argument out of range",this.name="ArgumentOutOfRangeError",this}return Ue.prototype=Object.create(Error.prototype),Ue})()},5279:(Xn,He,Q)=>{"use strict";Q.d(He,{N:()=>d});const d=(()=>{function Ue(){return Error.call(this),this.message="object unsubscribed",this.name="ObjectUnsubscribedError",this}return Ue.prototype=Object.create(Error.prototype),Ue})()},2782:(Xn,He,Q)=>{"use strict";function M(d){setTimeout(()=>{throw d},0)}Q.d(He,{z:()=>M})},5379:(Xn,He,Q)=>{"use strict";function M(d){return d}Q.d(He,{y:()=>M})},6688:(Xn,He,Q)=>{"use strict";Q.d(He,{k:()=>M});const M=Array.isArray||(d=>d&&"number"==typeof d.length)},8515:(Xn,He,Q)=>{"use strict";Q.d(He,{z:()=>M});const M=d=>d&&"number"==typeof d.length&&"function"!=typeof d},7043:(Xn,He,Q)=>{"use strict";function M(d){return"function"==typeof d}Q.d(He,{m:()=>M})},7830:(Xn,He,Q)=>{"use strict";function M(d){return null!==d&&"object"==typeof d}Q.d(He,{K:()=>M})},8955:(Xn,He,Q)=>{"use strict";function M(d){return!!d&&"function"!=typeof d.subscribe&&"function"==typeof d.then}Q.d(He,{t:()=>M})},2866:(Xn,He,Q)=>{"use strict";function M(d){return d&&"function"==typeof d.schedule}Q.d(He,{K:()=>M})},7876:(Xn,He,Q)=>{"use strict";function M(){}Q.d(He,{Z:()=>M})},9249:(Xn,He,Q)=>{"use strict";Q.d(He,{s:()=>pe});var M=Q(3650),d=Q(2782),Oe=Q(5430),he=Q(3821),ce=Q(8515),fe=Q(8955),le=Q(7830);const pe=Me=>{if(Me&&"function"==typeof Me[he.L])return(Me=>Ae=>{const dn=Me[he.L]();if("function"!=typeof dn.subscribe)throw new TypeError("Provided object does not correctly implement Symbol.observable");return dn.subscribe(Ae)})(Me);if((0,ce.z)(Me))return(0,M.V)(Me);if((0,fe.t)(Me))return(Me=>Ae=>(Me.then(dn=>{Ae.closed||(Ae.next(dn),Ae.complete())},dn=>Ae.error(dn)).then(null,d.z),Ae))(Me);if(Me&&"function"==typeof Me[Oe.hZ])return(Me=>Ae=>{const dn=Me[Oe.hZ]();for(;;){let rn;try{rn=dn.next()}catch(Ke){return Ae.error(Ke),Ae}if(rn.done){Ae.complete();break}if(Ae.next(rn.value),Ae.closed)break}return"function"==typeof dn.return&&Ae.add(()=>{dn.return&&dn.return()}),Ae})(Me);{const dn=`You provided ${(0,le.K)(Me)?"an invalid object":`'${Me}'`} where a stream was expected. You can provide an Observable, Promise, Array, or Iterable.`;throw new TypeError(dn)}}},3650:(Xn,He,Q)=>{"use strict";Q.d(He,{V:()=>M});const M=d=>Ue=>{for(let Oe=0,ye=d.length;Oe<ye&&!Ue.closed;Oe++)Ue.next(d[Oe]);Ue.complete()}},448:(Xn,He,Q)=>{"use strict";Q.d(He,{D:()=>ye});var M=Q(3489);class d extends M.L{constructor(oe,ce,fe){super(),this.parent=oe,this.outerValue=ce,this.outerIndex=fe,this.index=0}_next(oe){this.parent.notifyNext(this.outerValue,oe,this.outerIndex,this.index++,this)}_error(oe){this.parent.notifyError(oe,this),this.unsubscribe()}_complete(){this.parent.notifyComplete(this),this.unsubscribe()}}var Ue=Q(9249),Oe=Q(2916);function ye(he,oe,ce,fe,le=new d(he,ce,fe)){if(!le.closed)return oe instanceof Oe.y?oe.subscribe(le):(0,Ue.s)(oe)(le)}},9808:(Xn,He,Q)=>{"use strict";Q.d(He,{mr:()=>Dn,ez:()=>Jr,K0:()=>oe,Do:()=>ut,V_:()=>le,Ye:()=>cn,S$:()=>Qe,mk:()=>n1,sg:()=>Qn,O5:()=>ha,tP:()=>Da,b0:()=>yn,lw:()=>ce,EM:()=>ei,JF:()=>ya,NF:()=>ai,w_:()=>he,bD:()=>ja,q:()=>Ue,Mx:()=>mi,HT:()=>ye});var M=Q(6435);let d=null;function Ue(){return d}function ye(j){d||(d=j)}class he{}const oe=new M.OlP("DocumentToken");let ce=(()=>{class j{historyGo(k){throw new Error("Not implemented")}}return j.\u0275fac=function(k){return new(k||j)},j.\u0275prov=M.Yz7({token:j,factory:function(){return function fe(){return(0,M.LFG)(pe)}()},providedIn:"platform"}),j})();const le=new M.OlP("Location Initialized");let pe=(()=>{class j extends ce{constructor(k){super(),this._doc=k,this._init()}_init(){this.location=window.location,this._history=window.history}getBaseHrefFromDOM(){return Ue().getBaseHref(this._doc)}onPopState(k){const X=Ue().getGlobalEventTarget(this._doc,"window");return X.addEventListener("popstate",k,!1),()=>X.removeEventListener("popstate",k)}onHashChange(k){const X=Ue().getGlobalEventTarget(this._doc,"window");return X.addEventListener("hashchange",k,!1),()=>X.removeEventListener("hashchange",k)}get href(){return this.location.href}get protocol(){return this.location.protocol}get hostname(){return this.location.hostname}get port(){return this.location.port}get pathname(){return this.location.pathname}get search(){return this.location.search}get hash(){return this.location.hash}set pathname(k){this.location.pathname=k}pushState(k,X,re){Me()?this._history.pushState(k,X,re):this.location.hash=re}replaceState(k,X,re){Me()?this._history.replaceState(k,X,re):this.location.hash=re}forward(){this._history.forward()}back(){this._history.back()}historyGo(k=0){this._history.go(k)}getState(){return this._history.state}}return j.\u0275fac=function(k){return new(k||j)(M.LFG(oe))},j.\u0275prov=M.Yz7({token:j,factory:function(){return function Ae(){return new pe((0,M.LFG)(oe))}()},providedIn:"platform"}),j})();function Me(){return!!window.history.pushState}function dn(j,U){if(0==j.length)return U;if(0==U.length)return j;let k=0;return j.endsWith("/")&&k++,U.startsWith("/")&&k++,2==k?j+U.substring(1):1==k?j+U:j+"/"+U}function rn(j){const U=j.match(/#|\?|$/),k=U&&U.index||j.length;return j.slice(0,k-("/"===j[k-1]?1:0))+j.slice(k)}function Ke(j){return j&&"?"!==j[0]?"?"+j:j}let Qe=(()=>{class j{historyGo(k){throw new Error("Not implemented")}}return j.\u0275fac=function(k){return new(k||j)},j.\u0275prov=M.Yz7({token:j,factory:function(){return function ot(j){const U=(0,M.LFG)(oe).location;return new yn((0,M.LFG)(ce),U&&U.origin||"")}()},providedIn:"root"}),j})();const Dn=new M.OlP("appBaseHref");let yn=(()=>{class j extends Qe{constructor(k,X){if(super(),this._platformLocation=k,this._removeListenerFns=[],null==X&&(X=this._platformLocation.getBaseHrefFromDOM()),null==X)throw new Error("No base href set. Please provide a value for the APP_BASE_HREF token or add a base element to the document.");this._baseHref=X}ngOnDestroy(){for(;this._removeListenerFns.length;)this._removeListenerFns.pop()()}onPopState(k){this._removeListenerFns.push(this._platformLocation.onPopState(k),this._platformLocation.onHashChange(k))}getBaseHref(){return this._baseHref}prepareExternalUrl(k){return dn(this._baseHref,k)}path(k=!1){const X=this._platformLocation.pathname+Ke(this._platformLocation.search),re=this._platformLocation.hash;return re&&k?`${X}${re}`:X}pushState(k,X,re,ke){const Je=this.prepareExternalUrl(re+Ke(ke));this._platformLocation.pushState(k,X,Je)}replaceState(k,X,re,ke){const Je=this.prepareExternalUrl(re+Ke(ke));this._platformLocation.replaceState(k,X,Je)}forward(){this._platformLocation.forward()}back(){this._platformLocation.back()}historyGo(k=0){var X,re;null===(re=(X=this._platformLocation).historyGo)||void 0===re||re.call(X,k)}}return j.\u0275fac=function(k){return new(k||j)(M.LFG(ce),M.LFG(Dn,8))},j.\u0275prov=M.Yz7({token:j,factory:j.\u0275fac}),j})(),ut=(()=>{class j extends Qe{constructor(k,X){super(),this._platformLocation=k,this._baseHref="",this._removeListenerFns=[],null!=X&&(this._baseHref=X)}ngOnDestroy(){for(;this._removeListenerFns.length;)this._removeListenerFns.pop()()}onPopState(k){this._removeListenerFns.push(this._platformLocation.onPopState(k),this._platformLocation.onHashChange(k))}getBaseHref(){return this._baseHref}path(k=!1){let X=this._platformLocation.hash;return null==X&&(X="#"),X.length>0?X.substring(1):X}prepareExternalUrl(k){const X=dn(this._baseHref,k);return X.length>0?"#"+X:X}pushState(k,X,re,ke){let Je=this.prepareExternalUrl(re+Ke(ke));0==Je.length&&(Je=this._platformLocation.pathname),this._platformLocation.pushState(k,X,Je)}replaceState(k,X,re,ke){let Je=this.prepareExternalUrl(re+Ke(ke));0==Je.length&&(Je=this._platformLocation.pathname),this._platformLocation.replaceState(k,X,Je)}forward(){this._platformLocation.forward()}back(){this._platformLocation.back()}historyGo(k=0){var X,re;null===(re=(X=this._platformLocation).historyGo)||void 0===re||re.call(X,k)}}return j.\u0275fac=function(k){return new(k||j)(M.LFG(ce),M.LFG(Dn,8))},j.\u0275prov=M.Yz7({token:j,factory:j.\u0275fac}),j})(),cn=(()=>{class j{constructor(k,X){this._subject=new M.vpe,this._urlChangeListeners=[],this._platformStrategy=k;const re=this._platformStrategy.getBaseHref();this._platformLocation=X,this._baseHref=rn(mt(re)),this._platformStrategy.onPopState(ke=>{this._subject.emit({url:this.path(!0),pop:!0,state:ke.state,type:ke.type})})}path(k=!1){return this.normalize(this._platformStrategy.path(k))}getState(){return this._platformLocation.getState()}isCurrentPathEqualTo(k,X=""){return this.path()==this.normalize(k+Ke(X))}normalize(k){return j.stripTrailingSlash(function g1(j,U){return j&&U.startsWith(j)?U.substring(j.length):U}(this._baseHref,mt(k)))}prepareExternalUrl(k){return k&&"/"!==k[0]&&(k="/"+k),this._platformStrategy.prepareExternalUrl(k)}go(k,X="",re=null){this._platformStrategy.pushState(re,"",k,X),this._notifyUrlChangeListeners(this.prepareExternalUrl(k+Ke(X)),re)}replaceState(k,X="",re=null){this._platformStrategy.replaceState(re,"",k,X),this._notifyUrlChangeListeners(this.prepareExternalUrl(k+Ke(X)),re)}forward(){this._platformStrategy.forward()}back(){this._platformStrategy.back()}historyGo(k=0){var X,re;null===(re=(X=this._platformStrategy).historyGo)||void 0===re||re.call(X,k)}onUrlChange(k){this._urlChangeListeners.push(k),this._urlChangeSubscription||(this._urlChangeSubscription=this.subscribe(X=>{this._notifyUrlChangeListeners(X.url,X.state)}))}_notifyUrlChangeListeners(k="",X){this._urlChangeListeners.forEach(re=>re(k,X))}subscribe(k,X,re){return this._subject.subscribe({next:k,error:X,complete:re})}}return j.normalizeQueryParams=Ke,j.joinWithSlash=dn,j.stripTrailingSlash=rn,j.\u0275fac=function(k){return new(k||j)(M.LFG(Qe),M.LFG(ce))},j.\u0275prov=M.Yz7({token:j,factory:function(){return function fn(){return new cn((0,M.LFG)(Qe),(0,M.LFG)(ce))}()},providedIn:"root"}),j})();function mt(j){return j.replace(/\/index.html$/,"")}function mi(j,U){U=encodeURIComponent(U);for(const k of j.split(";")){const X=k.indexOf("="),[re,ke]=-1==X?[k,""]:[k.slice(0,X),k.slice(X+1)];if(re.trim()===U)return decodeURIComponent(ke)}return null}let n1=(()=>{class j{constructor(k,X,re,ke){this._iterableDiffers=k,this._keyValueDiffers=X,this._ngEl=re,this._renderer=ke,this._iterableDiffer=null,this._keyValueDiffer=null,this._initialClasses=[],this._rawClass=null}set klass(k){this._removeClasses(this._initialClasses),this._initialClasses="string"==typeof k?k.split(/\s+/):[],this._applyClasses(this._initialClasses),this._applyClasses(this._rawClass)}set ngClass(k){this._removeClasses(this._rawClass),this._applyClasses(this._initialClasses),this._iterableDiffer=null,this._keyValueDiffer=null,this._rawClass="string"==typeof k?k.split(/\s+/):k,this._rawClass&&((0,M.sIi)(this._rawClass)?this._iterableDiffer=this._iterableDiffers.find(this._rawClass).create():this._keyValueDiffer=this._keyValueDiffers.find(this._rawClass).create())}ngDoCheck(){if(this._iterableDiffer){const k=this._iterableDiffer.diff(this._rawClass);k&&this._applyIterableChanges(k)}else if(this._keyValueDiffer){const k=this._keyValueDiffer.diff(this._rawClass);k&&this._applyKeyValueChanges(k)}}_applyKeyValueChanges(k){k.forEachAddedItem(X=>this._toggleClass(X.key,X.currentValue)),k.forEachChangedItem(X=>this._toggleClass(X.key,X.currentValue)),k.forEachRemovedItem(X=>{X.previousValue&&this._toggleClass(X.key,!1)})}_applyIterableChanges(k){k.forEachAddedItem(X=>{if("string"!=typeof X.item)throw new Error(`NgClass can only toggle CSS classes expressed as strings, got ${(0,M.AaK)(X.item)}`);this._toggleClass(X.item,!0)}),k.forEachRemovedItem(X=>this._toggleClass(X.item,!1))}_applyClasses(k){k&&(Array.isArray(k)||k instanceof Set?k.forEach(X=>this._toggleClass(X,!0)):Object.keys(k).forEach(X=>this._toggleClass(X,!!k[X])))}_removeClasses(k){k&&(Array.isArray(k)||k instanceof Set?k.forEach(X=>this._toggleClass(X,!1)):Object.keys(k).forEach(X=>this._toggleClass(X,!1)))}_toggleClass(k,X){(k=k.trim())&&k.split(/\s+/g).forEach(re=>{X?this._renderer.addClass(this._ngEl.nativeElement,re):this._renderer.removeClass(this._ngEl.nativeElement,re)})}}return j.\u0275fac=function(k){return new(k||j)(M.Y36(M.ZZ4),M.Y36(M.aQg),M.Y36(M.SBq),M.Y36(M.Qsj))},j.\u0275dir=M.lG2({type:j,selectors:[["","ngClass",""]],inputs:{klass:["class","klass"],ngClass:"ngClass"}}),j})();class d1{constructor(U,k,X,re){this.$implicit=U,this.ngForOf=k,this.index=X,this.count=re}get first(){return 0===this.index}get last(){return this.index===this.count-1}get even(){return this.index%2==0}get odd(){return!this.even}}let Qn=(()=>{class j{constructor(k,X,re){this._viewContainer=k,this._template=X,this._differs=re,this._ngForOf=null,this._ngForOfDirty=!0,this._differ=null}set ngForOf(k){this._ngForOf=k,this._ngForOfDirty=!0}set ngForTrackBy(k){this._trackByFn=k}get ngForTrackBy(){return this._trackByFn}set ngForTemplate(k){k&&(this._template=k)}ngDoCheck(){if(this._ngForOfDirty){this._ngForOfDirty=!1;const k=this._ngForOf;!this._differ&&k&&(this._differ=this._differs.find(k).create(this.ngForTrackBy))}if(this._differ){const k=this._differ.diff(this._ngForOf);k&&this._applyChanges(k)}}_applyChanges(k){const X=this._viewContainer;k.forEachOperation((re,ke,Je)=>{if(null==re.previousIndex)X.createEmbeddedView(this._template,new d1(re.item,this._ngForOf,-1,-1),null===Je?void 0:Je);else if(null==Je)X.remove(null===ke?void 0:ke);else if(null!==ke){const nn=X.get(ke);X.move(nn,Je),Pn(nn,re)}});for(let re=0,ke=X.length;re<ke;re++){const nn=X.get(re).context;nn.index=re,nn.count=ke,nn.ngForOf=this._ngForOf}k.forEachIdentityChange(re=>{Pn(X.get(re.currentIndex),re)})}static ngTemplateContextGuard(k,X){return!0}}return j.\u0275fac=function(k){return new(k||j)(M.Y36(M.s_b),M.Y36(M.Rgc),M.Y36(M.ZZ4))},j.\u0275dir=M.lG2({type:j,selectors:[["","ngFor","","ngForOf",""]],inputs:{ngForOf:"ngForOf",ngForTrackBy:"ngForTrackBy",ngForTemplate:"ngForTemplate"}}),j})();function Pn(j,U){j.context.$implicit=U.item}let ha=(()=>{class j{constructor(k,X){this._viewContainer=k,this._context=new Qi,this._thenTemplateRef=null,this._elseTemplateRef=null,this._thenViewRef=null,this._elseViewRef=null,this._thenTemplateRef=X}set ngIf(k){this._context.$implicit=this._context.ngIf=k,this._updateView()}set ngIfThen(k){Xt("ngIfThen",k),this._thenTemplateRef=k,this._thenViewRef=null,this._updateView()}set ngIfElse(k){Xt("ngIfElse",k),this._elseTemplateRef=k,this._elseViewRef=null,this._updateView()}_updateView(){this._context.$implicit?this._thenViewRef||(this._viewContainer.clear(),this._elseViewRef=null,this._thenTemplateRef&&(this._thenViewRef=this._viewContainer.createEmbeddedView(this._thenTemplateRef,this._context))):this._elseViewRef||(this._viewContainer.clear(),this._thenViewRef=null,this._elseTemplateRef&&(this._elseViewRef=this._viewContainer.createEmbeddedView(this._elseTemplateRef,this._context)))}static ngTemplateContextGuard(k,X){return!0}}return j.\u0275fac=function(k){return new(k||j)(M.Y36(M.s_b),M.Y36(M.Rgc))},j.\u0275dir=M.lG2({type:j,selectors:[["","ngIf",""]],inputs:{ngIf:"ngIf",ngIfThen:"ngIfThen",ngIfElse:"ngIfElse"}}),j})();class Qi{constructor(){this.$implicit=null,this.ngIf=null}}function Xt(j,U){if(U&&!U.createEmbeddedView)throw new Error(`${j} must be a TemplateRef, but received '${(0,M.AaK)(U)}'.`)}let Da=(()=>{class j{constructor(k){this._viewContainerRef=k,this._viewRef=null,this.ngTemplateOutletContext=null,this.ngTemplateOutlet=null}ngOnChanges(k){if(k.ngTemplateOutlet){const X=this._viewContainerRef;this._viewRef&&X.remove(X.indexOf(this._viewRef)),this._viewRef=this.ngTemplateOutlet?X.createEmbeddedView(this.ngTemplateOutlet,this.ngTemplateOutletContext):null}else this._viewRef&&k.ngTemplateOutletContext&&this.ngTemplateOutletContext&&(this._viewRef.context=this.ngTemplateOutletContext)}}return j.\u0275fac=function(k){return new(k||j)(M.Y36(M.s_b))},j.\u0275dir=M.lG2({type:j,selectors:[["","ngTemplateOutlet",""]],inputs:{ngTemplateOutletContext:"ngTemplateOutletContext",ngTemplateOutlet:"ngTemplateOutlet"},features:[M.TTD]}),j})(),Jr=(()=>{class j{}return j.\u0275fac=function(k){return new(k||j)},j.\u0275mod=M.oAB({type:j}),j.\u0275inj=M.cJS({}),j})();const ja="browser";function ai(j){return j===ja}let ei=(()=>{class j{}return j.\u0275prov=(0,M.Yz7)({token:j,providedIn:"root",factory:()=>new Za((0,M.LFG)(oe),window)}),j})();class Za{constructor(U,k){this.document=U,this.window=k,this.offset=()=>[0,0]}setOffset(U){this.offset=Array.isArray(U)?()=>U:U}getScrollPosition(){return this.supportsScrolling()?[this.window.pageXOffset,this.window.pageYOffset]:[0,0]}scrollToPosition(U){this.supportsScrolling()&&this.window.scrollTo(U[0],U[1])}scrollToAnchor(U){if(!this.supportsScrolling())return;const k=function Pa(j,U){const k=j.getElementById(U)||j.getElementsByName(U)[0];if(k)return k;if("function"==typeof j.createTreeWalker&&j.body&&(j.body.createShadowRoot||j.body.attachShadow)){const X=j.createTreeWalker(j.body,NodeFilter.SHOW_ELEMENT);let re=X.currentNode;for(;re;){const ke=re.shadowRoot;if(ke){const Je=ke.getElementById(U)||ke.querySelector(`[name="${U}"]`);if(Je)return Je}re=X.nextNode()}}return null}(this.document,U);k&&(this.scrollToElement(k),k.focus())}setHistoryScrollRestoration(U){if(this.supportScrollRestoration()){const k=this.window.history;k&&k.scrollRestoration&&(k.scrollRestoration=U)}}scrollToElement(U){const k=U.getBoundingClientRect(),X=k.left+this.window.pageXOffset,re=k.top+this.window.pageYOffset,ke=this.offset();this.window.scrollTo(X-ke[0],re-ke[1])}supportScrollRestoration(){try{if(!this.supportsScrolling())return!1;const U=ba(this.window.history)||ba(Object.getPrototypeOf(this.window.history));return!(!U||!U.writable&&!U.set)}catch(U){return!1}}supportsScrolling(){try{return!!this.window&&!!this.window.scrollTo&&"pageXOffset"in this.window}catch(U){return!1}}}function ba(j){return Object.getOwnPropertyDescriptor(j,"scrollRestoration")}class ya{}},6435:(Xn,He,Q)=>{"use strict";Q.d(He,{deG:()=>Vs,tb:()=>X9,AFp:()=>Yd,ip1:()=>G9,CZH:()=>Xd,hGG:()=>_h,z2F:()=>iu,sBO:()=>ah,Sil:()=>Hm,_Vd:()=>Z6,EJc:()=>Om,SBq:()=>Cl,qLn:()=>H2,vpe:()=>$o,pfw:()=>Pm,tBr:()=>ss,XFs:()=>$n,OlP:()=>ti,zs3:()=>Dr,IIB:()=>jm,ZZ4:()=>lu,aQg:()=>du,soG:()=>Jd,YKP:()=>t9,h0i:()=>r3,PXZ:()=>Qm,R0b:()=>bo,FiY:()=>io,r_U:()=>km,Lbi:()=>$9,g9A:()=>Z9,Qsj:()=>Lp,FYo:()=>J7,JOm:()=>_e,q3G:()=>si,tp0:()=>Lo,Rgc:()=>zl,dDg:()=>K9,GfV:()=>K7,i9L:()=>zo,s_b:()=>Y6,ifc:()=>Nt,eFA:()=>tf,G48:()=>ih,Gpc:()=>Ke,_c5:()=>yh,VLi:()=>$m,c2e:()=>Y9,zSh:()=>P4,wAp:()=>ct,vHH:()=>yn,EiD:()=>x3,mCW:()=>co,qzn:()=>Wr,JVY:()=>fs,pB0:()=>Zr,eBb:()=>v3,L6k:()=>c2,LAX:()=>b3,cg1:()=>_l,kL8:()=>O6,yhl:()=>oo,dqk:()=>gt,sIi:()=>Fc,CqO:()=>F0,QGY:()=>$4,F4k:()=>R0,RDi:()=>U,AaK:()=>Ae,z3N:()=>_i,qOj:()=>y0,TTD:()=>ja,_Bn:()=>X7,xp6:()=>C8,uIk:()=>S0,Tol:()=>l6,Gre:()=>w6,MT6:()=>z6,ekj:()=>gl,Suo:()=>S9,Xpm:()=>za,lG2:()=>it,Yz7:()=>Ut,cJS:()=>qn,oAB:()=>xe,Yjl:()=>wt,Y36:()=>Bc,_UZ:()=>dl,qZA:()=>ll,TgZ:()=>W4,EpF:()=>H0,n5z:()=>_t,Ikx:()=>yl,SDv:()=>yp,QtT:()=>Z7,pQV:()=>Dd,LFG:()=>vt,$8M:()=>ra,$Z:()=>V0,NdJ:()=>pl,CRH:()=>M9,oxw:()=>G0,Hsn:()=>Z0,F$t:()=>W0,Q6J:()=>cl,s9C:()=>hl,MGl:()=>X4,DdM:()=>o9,VKq:()=>s9,WLB:()=>c9,kEZ:()=>l9,iGM:()=>x9,MAs:()=>C5,Jf7:()=>u,CHM:()=>Fi,oJD:()=>C3,LSH:()=>Ys,kYT:()=>Re,Udp:()=>Y4,YNc:()=>x5,W1O:()=>D9,_uU:()=>g6,Oqu:()=>bl,hij:()=>J4,Gf:()=>C9});var M=Q(5529),d=Q(2654),Ue=Q(2916),Oe=Q(6787),ye=Q(1762);class oe{constructor(t,o){this.subjectFactory=t,this.selector=o}call(t,o){const{selector:l}=this,p=this.subjectFactory(),g=l(p).subscribe(t);return g.add(o.subscribe(p)),g}}var ce=Q(4327);function fe(){return new M.xQ}function pe(n){for(let t in n)if(n[t]===pe)return t;throw Error("Could not find renamed property on target object.")}function Me(n,t){for(const o in t)t.hasOwnProperty(o)&&!n.hasOwnProperty(o)&&(n[o]=t[o])}function Ae(n){if("string"==typeof n)return n;if(Array.isArray(n))return"["+n.map(Ae).join(", ")+"]";if(null==n)return""+n;if(n.overriddenName)return`${n.overriddenName}`;if(n.name)return`${n.name}`;const t=n.toString();if(null==t)return""+t;const o=t.indexOf("\n");return-1===o?t:t.substring(0,o)}function dn(n,t){return null==n||""===n?null===t?"":t:null==t||""===t?n:n+" "+t}const rn=pe({__forward_ref__:pe});function Ke(n){return n.__forward_ref__=Ke,n.toString=function(){return Ae(this())},n}function Qe(n){return ot(n)?n():n}function ot(n){return"function"==typeof n&&n.hasOwnProperty(rn)&&n.__forward_ref__===Ke}class yn extends Error{constructor(t,o){super(function ut(n,t){return`NG0${Math.abs(n)}${t?": "+t:""}`}(t,o)),this.code=t}}function cn(n){return"string"==typeof n?n:null==n?"":String(n)}function fn(n){return"function"==typeof n?n.name||n.toString():"object"==typeof n&&null!=n&&"function"==typeof n.type?n.type.name||n.type.toString():cn(n)}function tn(n,t){const o=t?` in ${t}`:"";throw new yn(-201,`No provider for ${fn(n)} found${o}`)}function st(n,t,o,l){throw new Error(`ASSERTION ERROR: ${n}`+(null==l?"":` [Expected=> ${o} ${l} ${t} <=Actual]`))}function Ut(n){return{token:n.token,providedIn:n.providedIn||null,factory:n.factory,value:void 0}}function qn(n){return{providers:n.providers||[],imports:n.imports||[]}}function pi(n){return Xi(n,q1)||Xi(n,Mi)}function Xi(n,t){return n.hasOwnProperty(t)?n[t]:null}function a1(n){return n&&(n.hasOwnProperty(xt)||n.hasOwnProperty(wa))?n[xt]:null}const q1=pe({\u0275prov:pe}),xt=pe({\u0275inj:pe}),Mi=pe({ngInjectableDef:pe}),wa=pe({ngInjectorDef:pe});var $n=(()=>(($n=$n||{})[$n.Default=0]="Default",$n[$n.Host=1]="Host",$n[$n.Self=2]="Self",$n[$n.SkipSelf=4]="SkipSelf",$n[$n.Optional=8]="Optional",$n))();let wi;function xn(n){const t=wi;return wi=n,t}function _n(n,t,o){const l=pi(n);return l&&"root"==l.providedIn?void 0===l.value?l.value=l.factory():l.value:o&$n.Optional?null:void 0!==t?t:void tn(Ae(n),"Injector")}function ln(n){return{toString:n}.toString()}var sn=(()=>((sn=sn||{})[sn.OnPush=0]="OnPush",sn[sn.Default=1]="Default",sn))(),Nt=(()=>{return(n=Nt||(Nt={}))[n.Emulated=0]="Emulated",n[n.None=2]="None",n[n.ShadowDom=3]="ShadowDom",Nt;var n})();const On="undefined"!=typeof globalThis&&globalThis,ht="undefined"!=typeof window&&window,Wt="undefined"!=typeof self&&"undefined"!=typeof WorkerGlobalScope&&self instanceof WorkerGlobalScope&&self,gt=On||"undefined"!=typeof global&&global||ht||Wt,m1={},et=[],k1=pe({\u0275cmp:pe}),ma=pe({\u0275dir:pe}),Ni=pe({\u0275pipe:pe}),Di=pe({\u0275mod:pe}),kt=pe({\u0275fac:pe}),r1=pe({__NG_ELEMENT_ID__:pe});let Yi=0;function za(n){return ln(()=>{const o={},l={type:n.type,providersResolver:null,decls:n.decls,vars:n.vars,factory:null,template:n.template||null,consts:n.consts||null,ngContentSelectors:n.ngContentSelectors,hostBindings:n.hostBindings||null,hostVars:n.hostVars||0,hostAttrs:n.hostAttrs||null,contentQueries:n.contentQueries||null,declaredInputs:o,inputs:null,outputs:null,exportAs:n.exportAs||null,onPush:n.changeDetection===sn.OnPush,directiveDefs:null,pipeDefs:null,selectors:n.selectors||et,viewQuery:n.viewQuery||null,features:n.features||null,data:n.data||{},encapsulation:n.encapsulation||Nt.Emulated,id:"c",styles:n.styles||et,_:null,setInput:null,schemas:n.schemas||null,tView:null},p=n.directives,g=n.features,b=n.pipes;return l.id+=Yi++,l.inputs=Vn(n.inputs,o),l.outputs=Vn(n.outputs),g&&g.forEach(C=>C(l)),l.directiveDefs=p?()=>("function"==typeof p?p():p).map(we):null,l.pipeDefs=b?()=>("function"==typeof b?b():b).map(de):null,l})}function we(n){return Sn(n)||function Zt(n){return n[ma]||null}(n)}function de(n){return function x1(n){return n[Ni]||null}(n)}const ee={};function xe(n){return ln(()=>{const t={type:n.type,bootstrap:n.bootstrap||et,declarations:n.declarations||et,imports:n.imports||et,exports:n.exports||et,transitiveCompileScopes:null,schemas:n.schemas||null,id:n.id||null};return null!=n.id&&(ee[n.id]=n.type),t})}function Re(n,t){return ln(()=>{const o=$t(n,!0);o.declarations=t.declarations||et,o.imports=t.imports||et,o.exports=t.exports||et})}function Vn(n,t){if(null==n)return m1;const o={};for(const l in n)if(n.hasOwnProperty(l)){let p=n[l],g=p;Array.isArray(p)&&(g=p[1],p=p[0]),o[p]=l,t&&(t[p]=g)}return o}const it=za;function wt(n){return{type:n.type,name:n.name,factory:null,pure:!1!==n.pure,onDestroy:n.type.prototype.ngOnDestroy||null}}function Sn(n){return n[k1]||null}function $t(n,t){const o=n[Di]||null;if(!o&&!0===t)throw new Error(`Type ${Ae(n)} does not have '\u0275mod' property.`);return o}function u1(n){return Array.isArray(n)&&"object"==typeof n[1]}function I1(n){return Array.isArray(n)&&!0===n[1]}function Da(n){return 0!=(8&n.flags)}function Ki(n){return 2==(2&n.flags)}function X1(n){return 1==(1&n.flags)}function K1(n){return null!==n.template}function Ea(n){return 0!=(512&n[2])}function w1(n,t){return n.hasOwnProperty(kt)?n[kt]:null}class Jr{constructor(t,o,l){this.previousValue=t,this.currentValue=o,this.firstChange=l}isFirstChange(){return this.firstChange}}function ja(){return Ti}function Ti(n){return n.type.prototype.ngOnChanges&&(n.setInput=ji),Kr}function Kr(){const n=Hi(this),t=null==n?void 0:n.current;if(t){const o=n.previous;if(o===m1)n.previous=t;else for(let l in t)o[l]=t[l];n.current=null,this.ngOnChanges(t)}}function ji(n,t,o,l){const p=Hi(n)||function O1(n,t){return n[ai]=t}(n,{previous:m1,current:null}),g=p.current||(p.current={}),b=p.previous,C=this.declaredInputs[o],N=b[C];g[C]=new Jr(N&&N.currentValue,t,b===m1),n[l]=t}ja.ngInherit=!0;const ai="__ngSimpleChanges__";function Hi(n){return n[ai]||null}let j;function U(n){j=n}function k(){return void 0!==j?j:"undefined"!=typeof document?document:void 0}function re(n){return!!n.listen}const ke={createRenderer:(n,t)=>k()};function nn(n){for(;Array.isArray(n);)n=n[0];return n}function Dt(n,t){return nn(t[n])}function kn(n,t){return nn(t[n.index])}function Jn(n,t){return n.data[t]}function V1(n,t){const o=t[n];return u1(o)?o:o[0]}function H1(n){return 4==(4&n[2])}function P(n){return 128==(128&n[2])}function D(n,t){return null==t?null:n[t]}function W(n){n[18]=0}function je(n,t){n[5]+=t;let o=n,l=n[3];for(;null!==l&&(1===t&&1===o[5]||-1===t&&0===o[5]);)l[5]+=t,o=l,l=l[3]}const $e={lFrame:N1(null),bindingsEnabled:!0,isInCheckNoChangesMode:!1};function ta(){return $e.bindingsEnabled}function Ye(){return $e.lFrame.lView}function Ct(){return $e.lFrame.tView}function Fi(n){return $e.lFrame.contextLView=n,n[8]}function b1(){let n=Pr();for(;null!==n&&64===n.type;)n=n.parent;return n}function Pr(){return $e.lFrame.currentTNode}function gr(){const n=$e.lFrame,t=n.currentTNode;return n.isParent?t:t.parent}function gi(n,t){const o=$e.lFrame;o.currentTNode=n,o.isParent=t}function X2(){return $e.lFrame.isParent}function Y2(){$e.lFrame.isParent=!1}function _a(){return $e.isInCheckNoChangesMode}function g2(n){$e.isInCheckNoChangesMode=n}function O(){const n=$e.lFrame;let t=n.bindingRootIndex;return-1===t&&(t=n.bindingRootIndex=n.tView.bindingStartIndex),t}function Z(){return $e.lFrame.bindingIndex}function ne(){return $e.lFrame.bindingIndex++}function ve(n){const t=$e.lFrame,o=t.bindingIndex;return t.bindingIndex=t.bindingIndex+n,o}function Fe(n){$e.lFrame.inI18n=n}function Be(n,t){const o=$e.lFrame;o.bindingIndex=o.bindingRootIndex=n,dt(t)}function dt(n){$e.lFrame.currentDirectiveIndex=n}function Tt(){return $e.lFrame.currentQueryIndex}function Yt(n){$e.lFrame.currentQueryIndex=n}function z1(n){const t=n[1];return 2===t.type?t.declTNode:1===t.type?n[6]:null}function oi(n,t,o){if(o&$n.SkipSelf){let p=t,g=n;for(;!(p=p.parent,null!==p||o&$n.Host||(p=z1(g),null===p||(g=g[15],10&p.type))););if(null===p)return!1;t=p,n=g}const l=$e.lFrame=ni();return l.currentTNode=t,l.lView=n,!0}function Y1(n){const t=ni(),o=n[1];$e.lFrame=t,t.currentTNode=o.firstChild,t.lView=n,t.tView=o,t.contextLView=n,t.bindingIndex=o.bindingStartIndex,t.inI18n=!1}function ni(){const n=$e.lFrame,t=null===n?null:n.child;return null===t?N1(n):t}function N1(n){const t={currentTNode:null,isParent:!0,lView:null,tView:null,selectedIndex:-1,contextLView:null,elementDepthCount:0,currentNamespace:null,currentDirectiveIndex:-1,bindingRootIndex:-1,bindingIndex:-1,currentQueryIndex:0,parent:n,child:null,inI18n:!1};return null!==n&&(n.child=t),t}function vi(){const n=$e.lFrame;return $e.lFrame=n.parent,n.currentTNode=null,n.lView=null,n}const qi=vi;function aa(){const n=vi();n.isParent=!0,n.tView=null,n.selectedIndex=-1,n.contextLView=null,n.elementDepthCount=0,n.currentDirectiveIndex=-1,n.currentNamespace=null,n.bindingRootIndex=-1,n.bindingIndex=-1,n.currentQueryIndex=0}function D1(){return $e.lFrame.selectedIndex}function bi(n){$e.lFrame.selectedIndex=n}function It(){const n=$e.lFrame;return Jn(n.tView,n.selectedIndex)}function E1(n,t){for(let o=t.directiveStart,l=t.directiveEnd;o<l;o++){const g=n.data[o].type.prototype,{ngAfterContentInit:b,ngAfterContentChecked:C,ngAfterViewInit:N,ngAfterViewChecked:R,ngOnDestroy:B}=g;b&&(n.contentHooks||(n.contentHooks=[])).push(-o,b),C&&((n.contentHooks||(n.contentHooks=[])).push(o,C),(n.contentCheckHooks||(n.contentCheckHooks=[])).push(o,C)),N&&(n.viewHooks||(n.viewHooks=[])).push(-o,N),R&&((n.viewHooks||(n.viewHooks=[])).push(o,R),(n.viewCheckHooks||(n.viewCheckHooks=[])).push(o,R)),null!=B&&(n.destroyHooks||(n.destroyHooks=[])).push(o,B)}}function vr(n,t,o){Qo(n,t,3,o)}function $a(n,t,o,l){(3&n[2])===o&&Qo(n,t,o,l)}function L2(n,t){let o=n[2];(3&o)===t&&(o&=2047,o+=1,n[2]=o)}function Qo(n,t,o,l){const g=null!=l?l:-1,b=t.length-1;let C=0;for(let N=void 0!==l?65535&n[18]:0;N<b;N++)if("number"==typeof t[N+1]){if(C=t[N],null!=l&&C>=l)break}else t[N]<0&&(n[18]+=65536),(C<g||-1==g)&&(Bi(n,o,t,N),n[18]=(4294901760&n[18])+N+2),N++}function Bi(n,t,o,l){const p=o[l]<0,g=o[l+1],C=n[p?-o[l]:o[l]];if(p){if(n[2]>>11<n[18]>>16&&(3&n[2])===t){n[2]+=2048;try{g.call(C)}finally{}}}else try{g.call(C)}finally{}}class Ir{constructor(t,o,l){this.factory=t,this.resolving=!1,this.canSeeViewProviders=o,this.injectImpl=l}}function Or(n,t,o){const l=re(n);let p=0;for(;p<o.length;){const g=o[p];if("number"==typeof g){if(0!==g)break;p++;const b=o[p++],C=o[p++],N=o[p++];l?n.setAttribute(t,C,N,b):t.setAttributeNS(b,C,N)}else{const b=g,C=o[++p];K2(b)?l&&n.setProperty(t,b,C):l?n.setAttribute(t,b,C):t.setAttribute(b,C),p++}}return p}function j2(n){return 3===n||4===n||6===n}function K2(n){return 64===n.charCodeAt(0)}function Vr(n,t){if(null!==t&&0!==t.length)if(null===n||0===n.length)n=t.slice();else{let o=-1;for(let l=0;l<t.length;l++){const p=t[l];"number"==typeof p?o=p:0===o||Is(n,o,p,null,-1===o||2===o?t[++l]:null)}}return n}function Is(n,t,o,l,p){let g=0,b=n.length;if(-1===t)b=-1;else for(;g<n.length;){const C=n[g++];if("number"==typeof C){if(C===t){b=-1;break}if(C>t){b=g-1;break}}}for(;g<n.length;){const C=n[g];if("number"==typeof C)break;if(C===o){if(null===l)return void(null!==p&&(n[g+1]=p));if(l===n[g+1])return void(n[g+2]=p)}g++,null!==l&&g++,null!==p&&g++}-1!==b&&(n.splice(b,0,t),g=b+1),n.splice(g++,0,o),null!==l&&n.splice(g++,0,l),null!==p&&n.splice(g++,0,p)}function dc(n){return-1!==n}function v2(n){return 32767&n}function yr(n,t){let o=function Os(n){return n>>16}(n),l=t;for(;o>0;)l=l[15],o--;return l}let k2=!0;function Jo(n){const t=k2;return k2=n,t}let wo=0;function _r(n,t){const o=xr(n,t);if(-1!==o)return o;const l=t[1];l.firstCreatePass&&(n.injectorIndex=t.length,Hr(l.data,n),Hr(t,null),Hr(l.blueprint,null));const p=Rr(n,t),g=n.injectorIndex;if(dc(p)){const b=v2(p),C=yr(p,t),N=C[1].data;for(let R=0;R<8;R++)t[g+R]=C[b+R]|N[b+R]}return t[g+8]=p,g}function Hr(n,t){n.push(0,0,0,0,0,0,0,0,t)}function xr(n,t){return-1===n.injectorIndex||n.parent&&n.parent.injectorIndex===n.injectorIndex||null===t[n.injectorIndex+8]?-1:n.injectorIndex}function Rr(n,t){if(n.parent&&-1!==n.parent.injectorIndex)return n.parent.injectorIndex;let o=0,l=null,p=t;for(;null!==p;){const g=p[1],b=g.type;if(l=2===b?g.declTNode:1===b?p[6]:null,null===l)return-1;if(o++,p=p[15],-1!==l.injectorIndex)return l.injectorIndex|o<<16}return-1}function es(n,t,o){!function or(n,t,o){let l;"string"==typeof o?l=o.charCodeAt(0)||0:o.hasOwnProperty(r1)&&(l=o[r1]),null==l&&(l=o[r1]=wo++);const p=255&l;t.data[n+(p>>5)]|=1<<p}(n,t,o)}function x(n,t,o){if(o&$n.Optional)return n;tn(t,"NodeInjector")}function _(n,t,o,l){if(o&$n.Optional&&void 0===l&&(l=null),0==(o&($n.Self|$n.Host))){const p=n[9],g=xn(void 0);try{return p?p.get(t,l,o&$n.Optional):_n(t,l,o&$n.Optional)}finally{xn(g)}}return x(l,t,o)}function T(n,t,o,l=$n.Default,p){if(null!==n){const g=function In(n){if("string"==typeof n)return n.charCodeAt(0)||0;const t=n.hasOwnProperty(r1)?n[r1]:void 0;return"number"==typeof t?t>=0?255&t:G:t}(o);if("function"==typeof g){if(!oi(t,n,l))return l&$n.Host?x(p,o,l):_(t,o,l,p);try{const b=g(l);if(null!=b||l&$n.Optional)return b;tn(o)}finally{qi()}}else if("number"==typeof g){let b=null,C=xr(n,t),N=-1,R=l&$n.Host?t[16][6]:null;for((-1===C||l&$n.SkipSelf)&&(N=-1===C?Rr(n,t):t[C+8],-1!==N&&un(l,!1)?(b=t[1],C=v2(N),t=yr(N,t)):C=-1);-1!==C;){const B=t[1];if(Ot(g,C,B.data)){const K=te(C,t,o,b,l,R);if(K!==V)return K}N=t[C+8],-1!==N&&un(l,t[1].data[C+8]===R)&&Ot(g,C,t)?(b=B,C=v2(N),t=yr(N,t)):C=-1}}}return _(t,o,l,p)}const V={};function G(){return new Kn(b1(),Ye())}function te(n,t,o,l,p,g){const b=t[1],C=b.data[n+8],B=se(C,b,o,null==l?Ki(C)&&k2:l!=b&&0!=(3&C.type),p&$n.Host&&g===C);return null!==B?Ie(t,b,B,C):V}function se(n,t,o,l,p){const g=n.providerIndexes,b=t.data,C=1048575&g,N=n.directiveStart,B=g>>20,ue=p?C+B:n.directiveEnd;for(let Ce=l?C:C+B;Ce<ue;Ce++){const qe=b[Ce];if(Ce<N&&o===qe||Ce>=N&&qe.type===o)return Ce}if(p){const Ce=b[N];if(Ce&&K1(Ce)&&Ce.type===o)return N}return null}function Ie(n,t,o,l){let p=n[o];const g=t.data;if(function br(n){return n instanceof Ir}(p)){const b=p;b.resolving&&function g1(n,t){const o=t?`. Dependency path: ${t.join(" > ")} > ${n}`:"";throw new yn(-200,`Circular dependency in DI detected for ${n}${o}`)}(fn(g[o]));const C=Jo(b.canSeeViewProviders);b.resolving=!0;const N=b.injectImpl?xn(b.injectImpl):null;oi(n,l,$n.Default);try{p=n[o]=b.factory(void 0,g,n,l),t.firstCreatePass&&o>=l.directiveStart&&function t2(n,t,o){const{ngOnChanges:l,ngOnInit:p,ngDoCheck:g}=t.type.prototype;if(l){const b=Ti(t);(o.preOrderHooks||(o.preOrderHooks=[])).push(n,b),(o.preOrderCheckHooks||(o.preOrderCheckHooks=[])).push(n,b)}p&&(o.preOrderHooks||(o.preOrderHooks=[])).push(0-n,p),g&&((o.preOrderHooks||(o.preOrderHooks=[])).push(n,g),(o.preOrderCheckHooks||(o.preOrderCheckHooks=[])).push(n,g))}(o,g[o],t)}finally{null!==N&&xn(N),Jo(C),b.resolving=!1,qi()}}return p}function Ot(n,t,o){return!!(o[t+(n>>5)]&1<<n)}function un(n,t){return!(n&$n.Self||n&$n.Host&&t)}class Kn{constructor(t,o){this._tNode=t,this._lView=o}get(t,o,l){return T(this._tNode,this._lView,t,l,o)}}function _t(n){return ln(()=>{const t=n.prototype.constructor,o=t[kt]||S1(t),l=Object.prototype;let p=Object.getPrototypeOf(n.prototype).constructor;for(;p&&p!==l;){const g=p[kt]||S1(p);if(g&&g!==o)return g;p=Object.getPrototypeOf(p)}return g=>new g})}function S1(n){return ot(n)?()=>{const t=S1(Qe(n));return t&&t()}:w1(n)}function ra(n){return function z(n,t){if("class"===t)return n.classes;if("style"===t)return n.styles;const o=n.attrs;if(o){const l=o.length;let p=0;for(;p<l;){const g=o[p];if(j2(g))break;if(0===g)p+=2;else if("number"==typeof g)for(p++;p<l&&"string"==typeof o[p];)p++;else{if(g===t)return o[p+1];p+=2}}}return null}(b1(),n)}const oa="__parameters__",sr="__prop__metadata__";function y2(n){return function(...o){if(n){const l=n(...o);for(const p in l)this[p]=l[p]}}}function Fr(n,t,o){return ln(()=>{const l=y2(t);function p(...g){if(this instanceof p)return l.apply(this,g),this;const b=new p(...g);return C.annotation=b,C;function C(N,R,B){const K=N.hasOwnProperty(oa)?N[oa]:Object.defineProperty(N,oa,{value:[]})[oa];for(;K.length<=B;)K.push(null);return(K[B]=K[B]||[]).push(b),N}}return o&&(p.prototype=Object.create(o.prototype)),p.prototype.ngMetadataName=n,p.annotationCls=p,p})}function eo(n,t,o,l){return ln(()=>{const p=y2(t);function g(...b){if(this instanceof g)return p.apply(this,b),this;const C=new g(...b);return function N(R,B){const K=R.constructor,ue=K.hasOwnProperty(sr)?K[sr]:Object.defineProperty(K,sr,{value:{}})[sr];ue[B]=ue.hasOwnProperty(B)&&ue[B]||[],ue[B].unshift(C),l&&l(R,B,...b)}}return o&&(g.prototype=Object.create(o.prototype)),g.prototype.ngMetadataName=n,g.annotationCls=g,g})}class ti{constructor(t,o){this._desc=t,this.ngMetadataName="InjectionToken",this.\u0275prov=void 0,"number"==typeof o?this.__NG_ELEMENT_ID__=o:void 0!==o&&(this.\u0275prov=Ut({token:this,providedIn:o.providedIn||"root",factory:o.factory}))}toString(){return`InjectionToken ${this._desc}`}}const Vs=new ti("AnalyzeForEntryComponents");class pc{}const zo=eo("ViewChild",(n,t)=>Object.assign({selector:n,first:!0,isViewQuery:!0,descendants:!0},t),pc);function St(n,t){void 0===t&&(t=n);for(let o=0;o<n.length;o++){let l=n[o];Array.isArray(l)?(t===n&&(t=n.slice(0,o)),St(l,t)):t!==n&&t.push(l)}return t}function yi(n,t){n.forEach(o=>Array.isArray(o)?yi(o,t):t(o))}function x2(n,t,o){t>=n.length?n.push(o):n.splice(t,0,o)}function qr(n,t){return t>=n.length-1?n.pop():n.splice(t,1)[0]}function No(n,t){const o=[];for(let l=0;l<n;l++)o.push(t);return o}function sa(n,t,o){let l=to(n,t);return l>=0?n[1|l]=o:(l=~l,function G1(n,t,o,l){let p=n.length;if(p==t)n.push(o,l);else if(1===p)n.push(l,n[0]),n[0]=o;else{for(p--,n.push(n[p-1],n[p]);p>t;)n[p]=n[p-2],p--;n[t]=o,n[t+1]=l}}(n,l,t,o)),l}function cr(n,t){const o=to(n,t);if(o>=0)return n[1|o]}function to(n,t){return function mc(n,t,o){let l=0,p=n.length>>o;for(;p!==l;){const g=l+(p-l>>1),b=n[g<<o];if(t===b)return g<<o;b>t?p=g:l=g+1}return~(p<<o)}(n,t,1)}const as={},rs="__NG_DI_FLAG__",os="ngTempTokenPath",hc=/\n/gm,gc="__source",Eo=pe({provide:String,useValue:pe});let Qa;function t4(n){const t=Qa;return Qa=n,t}function vc(n,t=$n.Default){if(void 0===Qa)throw new yn(203,"");return null===Qa?_n(n,void 0,t):Qa.get(n,t&$n.Optional?null:void 0,t)}function vt(n,t=$n.Default){return(function Rn(){return wi}()||vc)(Qe(n),t)}const Br=vt;function Ja(n){const t=[];for(let o=0;o<n.length;o++){const l=Qe(n[o]);if(Array.isArray(l)){if(0===l.length)throw new yn(900,"");let p,g=$n.Default;for(let b=0;b<l.length;b++){const C=l[b],N=r2(C);"number"==typeof N?-1===N?p=C.token:g|=N:p=C}t.push(vt(p,g))}else t.push(vt(l))}return t}function O2(n,t){return n[rs]=t,n.prototype[rs]=t,n}function r2(n){return n[rs]}const ss=O2(Fr("Inject",n=>({token:n})),-1),io=O2(Fr("Optional"),8),Lo=O2(Fr("SkipSelf"),4);let Ka,Ui;function wr(n){var t;return(null===(t=function jo(){if(void 0===Ka&&(Ka=null,gt.trustedTypes))try{Ka=gt.trustedTypes.createPolicy("angular",{createHTML:n=>n,createScript:n=>n,createScriptURL:n=>n})}catch(n){}return Ka}())||void 0===t?void 0:t.createHTML(n))||n}function o4(n){var t;return(null===(t=function zr(){if(void 0===Ui&&(Ui=null,gt.trustedTypes))try{Ui=gt.trustedTypes.createPolicy("angular#unsafe-bypass",{createHTML:n=>n,createScript:n=>n,createScriptURL:n=>n})}catch(n){}return Ui}())||void 0===t?void 0:t.createHTML(n))||n}class s2{constructor(t){this.changingThisBreaksApplicationSecurity=t}toString(){return`SafeValue must use [property]=binding: ${this.changingThisBreaksApplicationSecurity} (see https://g.co/ng/security#xss)`}}class _c extends s2{getTypeName(){return"HTML"}}class Po extends s2{getTypeName(){return"Style"}}class h3 extends s2{getTypeName(){return"Script"}}class s4 extends s2{getTypeName(){return"URL"}}class g3 extends s2{getTypeName(){return"ResourceURL"}}function _i(n){return n instanceof s2?n.changingThisBreaksApplicationSecurity:n}function Wr(n,t){const o=oo(n);if(null!=o&&o!==t){if("ResourceURL"===o&&"URL"===t)return!0;throw new Error(`Required a safe ${t}, got a ${o} (see https://g.co/ng/security#xss)`)}return o===t}function oo(n){return n instanceof s2&&n.getTypeName()||null}function fs(n){return new _c(n)}function c2(n){return new Po(n)}function v3(n){return new h3(n)}function b3(n){return new s4(n)}function Zr(n){return new g3(n)}function ps(n){const t=new Cc(n);return function ms(){try{return!!(new window.DOMParser).parseFromString(wr(""),"text/html")}catch(n){return!1}}()?new xc(t):t}class xc{constructor(t){this.inertDocumentHelper=t}getInertBodyElement(t){t="<body><remove></remove>"+t;try{const o=(new window.DOMParser).parseFromString(wr(t),"text/html").body;return null===o?this.inertDocumentHelper.getInertBodyElement(t):(o.removeChild(o.firstChild),o)}catch(o){return null}}}class Cc{constructor(t){if(this.defaultDoc=t,this.inertDocument=this.defaultDoc.implementation.createHTMLDocument("sanitization-inert"),null==this.inertDocument.body){const o=this.inertDocument.createElement("html");this.inertDocument.appendChild(o);const l=this.inertDocument.createElement("body");o.appendChild(l)}}getInertBodyElement(t){const o=this.inertDocument.createElement("template");if("content"in o)return o.innerHTML=wr(t),o;const l=this.inertDocument.createElement("body");return l.innerHTML=wr(t),this.defaultDoc.documentMode&&this.stripCustomNsAttrs(l),l}stripCustomNsAttrs(t){const o=t.attributes;for(let p=o.length-1;0<p;p--){const b=o.item(p).name;("xmlns:ns1"===b||0===b.indexOf("ns1:"))&&t.removeAttribute(b)}let l=t.firstChild;for(;l;)l.nodeType===Node.ELEMENT_NODE&&this.stripCustomNsAttrs(l),l=l.nextSibling}}const so=/^(?:(?:https?|mailto|ftp|tel|file|sms):|[^&:/?#]*(?:[/?#]|$))/gi,Sc=/^data:(?:image\/(?:bmp|gif|jpeg|jpg|png|tiff|webp)|video\/(?:mpeg|mp4|ogg|webm)|audio\/(?:mp3|oga|ogg|opus));base64,[a-z0-9+\/]+=*$/i;function co(n){return(n=String(n)).match(so)||n.match(Sc)?n:"unsafe:"+n}function c4(n){return(n=String(n)).split(",").map(t=>co(t.trim())).join(", ")}function er(n){const t={};for(const o of n.split(","))t[o]=!0;return t}function Io(...n){const t={};for(const o of n)for(const l in o)o.hasOwnProperty(l)&&(t[l]=!0);return t}const Oo=er("area,br,col,hr,img,wbr"),Mc=er("colgroup,dd,dt,li,p,tbody,td,tfoot,th,thead,tr"),lo=er("rp,rt"),Zs=Io(Oo,Io(Mc,er("address,article,aside,blockquote,caption,center,del,details,dialog,dir,div,dl,figure,figcaption,footer,h1,h2,h3,h4,h5,h6,header,hgroup,hr,ins,main,map,menu,nav,ol,pre,section,summary,table,ul")),Io(lo,er("a,abbr,acronym,audio,b,bdi,bdo,big,br,cite,code,del,dfn,em,font,i,img,ins,kbd,label,map,mark,picture,q,ruby,rp,rt,s,samp,small,source,span,strike,strong,sub,sup,time,track,tt,u,var,video")),Io(lo,Mc)),$s=er("background,cite,href,itemtype,longdesc,poster,src,xlink:href"),wc=er("srcset"),d4=Io($s,wc,er("abbr,accesskey,align,alt,autoplay,axis,bgcolor,border,cellpadding,cellspacing,class,clear,color,cols,colspan,compact,controls,coords,datetime,default,dir,download,face,headers,height,hidden,hreflang,hspace,ismap,itemscope,itemprop,kind,label,lang,language,loop,media,muted,nohref,nowrap,open,preload,rel,rev,role,rows,rowspan,rules,scope,scrolling,shape,size,sizes,span,srclang,start,summary,tabindex,target,title,translate,type,usemap,valign,value,vspace,width"),er("aria-activedescendant,aria-atomic,aria-autocomplete,aria-busy,aria-checked,aria-colcount,aria-colindex,aria-colspan,aria-controls,aria-current,aria-describedby,aria-details,aria-disabled,aria-dropeffect,aria-errormessage,aria-expanded,aria-flowto,aria-grabbed,aria-haspopup,aria-hidden,aria-invalid,aria-keyshortcuts,aria-label,aria-labelledby,aria-level,aria-live,aria-modal,aria-multiline,aria-multiselectable,aria-orientation,aria-owns,aria-placeholder,aria-posinset,aria-pressed,aria-readonly,aria-relevant,aria-required,aria-roledescription,aria-rowcount,aria-rowindex,aria-rowspan,aria-selected,aria-setsize,aria-sort,aria-valuemax,aria-valuemin,aria-valuenow,aria-valuetext")),u4=er("script,style,template");class f4{constructor(){this.sanitizedSomething=!1,this.buf=[]}sanitizeChildren(t){let o=t.firstChild,l=!0;for(;o;)if(o.nodeType===Node.ELEMENT_NODE?l=this.startElement(o):o.nodeType===Node.TEXT_NODE?this.chars(o.nodeValue):this.sanitizedSomething=!0,l&&o.firstChild)o=o.firstChild;else for(;o;){o.nodeType===Node.ELEMENT_NODE&&this.endElement(o);let p=this.checkClobberedElement(o,o.nextSibling);if(p){o=p;break}o=this.checkClobberedElement(o,o.parentNode)}return this.buf.join("")}startElement(t){const o=t.nodeName.toLowerCase();if(!Zs.hasOwnProperty(o))return this.sanitizedSomething=!0,!u4.hasOwnProperty(o);this.buf.push("<"),this.buf.push(o);const l=t.attributes;for(let p=0;p<l.length;p++){const g=l.item(p),b=g.name,C=b.toLowerCase();if(!d4.hasOwnProperty(C)){this.sanitizedSomething=!0;continue}let N=g.value;$s[C]&&(N=co(N)),wc[C]&&(N=c4(N)),this.buf.push(" ",b,'="',Vo(N),'"')}return this.buf.push(">"),!0}endElement(t){const o=t.nodeName.toLowerCase();Zs.hasOwnProperty(o)&&!Oo.hasOwnProperty(o)&&(this.buf.push("</"),this.buf.push(o),this.buf.push(">"))}chars(t){this.buf.push(Vo(t))}checkClobberedElement(t,o){if(o&&(t.compareDocumentPosition(o)&Node.DOCUMENT_POSITION_CONTAINED_BY)===Node.DOCUMENT_POSITION_CONTAINED_BY)throw new Error(`Failed to sanitize html because the element is clobbered: ${t.outerHTML}`);return o}}const _3=/[\uD800-\uDBFF][\uDC00-\uDFFF]/g,zc=/([^\#-~ |!])/g;function Vo(n){return n.replace(/&/g,"&amp;").replace(_3,function(t){return"&#"+(1024*(t.charCodeAt(0)-55296)+(t.charCodeAt(1)-56320)+65536)+";"}).replace(zc,function(t){return"&#"+t.charCodeAt(0)+";"}).replace(/</g,"&lt;").replace(/>/g,"&gt;")}let uo;function x3(n,t){let o=null;try{uo=uo||ps(n);let l=t?String(t):"";o=uo.getInertBodyElement(l);let p=5,g=l;do{if(0===p)throw new Error("Failed to sanitize html because the input is unstable");p--,l=g,g=o.innerHTML,o=uo.getInertBodyElement(l)}while(l!==g);return wr((new f4).sanitizeChildren(hs(o)||o))}finally{if(o){const l=hs(o)||o;for(;l.firstChild;)l.removeChild(l.firstChild)}}}function hs(n){return"content"in n&&function p4(n){return n.nodeType===Node.ELEMENT_NODE&&"TEMPLATE"===n.nodeName}(n)?n.content:null}var si=(()=>((si=si||{})[si.NONE=0]="NONE",si[si.HTML=1]="HTML",si[si.STYLE=2]="STYLE",si[si.SCRIPT=3]="SCRIPT",si[si.URL=4]="URL",si[si.RESOURCE_URL=5]="RESOURCE_URL",si))();function C3(n){const t=Ho();return t?o4(t.sanitize(si.HTML,n)||""):Wr(n,"HTML")?o4(_i(n)):x3(k(),cn(n))}function Ys(n){const t=Ho();return t?t.sanitize(si.URL,n)||"":Wr(n,"URL")?_i(n):co(cn(n))}function Ho(){const n=Ye();return n&&n[12]}const _4="__ngContext__";function jt(n,t){n[_4]=t}function bs(n){const t=function vs(n){return n[_4]||null}(n);return t?Array.isArray(t)?t:t.lView:null}function f1(n){return n.ngOriginalError}function jl(n,...t){n.error(...t)}class H2{constructor(){this._console=console}handleError(t){const o=this._findOriginalError(t),l=function z3(n){return n&&n.ngErrorLogger||jl}(t);l(this._console,"ERROR",t),o&&l(this._console,"ORIGINAL ERROR",o)}_findOriginalError(t){let o=t&&f1(t);for(;o&&f1(o);)o=f1(o);return o||null}}const N3=/^>|^->|<!--|-->|--!>|<!-$/g,ii=/(<|>)/;const f=(()=>("undefined"!=typeof requestAnimationFrame&&requestAnimationFrame||setTimeout).bind(gt))();function u(n){return n.ownerDocument.defaultView}function E(n){return n instanceof Function?n():n}var _e=(()=>((_e=_e||{})[_e.Important=1]="Important",_e[_e.DashCase=2]="DashCase",_e))();let be;function Te(n,t){return be(n,t)}function pn(n){const t=n[3];return I1(t)?t[3]:t}function Nn(n){return Bn(n[13])}function Wn(n){return Bn(n[4])}function Bn(n){for(;null!==n&&!I1(n);)n=n[4];return n}function t1(n,t,o,l,p){if(null!=l){let g,b=!1;I1(l)?g=l:u1(l)&&(b=!0,l=l[0]);const C=nn(l);0===n&&null!==o?null==p?F2(t,o,C):ur(t,o,C,p||null,!0):1===n&&null!==o?ur(t,o,C,p||null,!0):2===n?u8(t,C,b):3===n&&t.destroyNode(C),null!=g&&function Cu(n,t,o,l,p){const g=o[7];g!==nn(o)&&t1(t,n,l,g,p);for(let C=10;C<o.length;C++){const N=o[C];jc(N[1],N,n,t,l,g)}}(t,n,g,o,p)}}function ci(n,t){return re(n)?n.createText(t):n.createTextNode(t)}function F1(n,t,o){re(n)?n.setValue(t,o):t.textContent=o}function nr(n,t){return n.createComment(function D3(n){return n.replace(N3,t=>t.replace(ii,"\u200b$1\u200b"))}(t))}function la(n,t,o){if(re(n))return n.createElement(t,o);{const l=null!==o?function ya(n){const t=n.toLowerCase();return"svg"===t?"http://www.w3.org/2000/svg":"math"===t?"http://www.w3.org/1998/MathML/":null}(o):null;return null===l?n.createElement(t):n.createElementNS(l,t)}}function Ca(n,t){const o=n[9],l=o.indexOf(t),p=t[3];1024&t[2]&&(t[2]&=-1025,je(p,-1)),o.splice(l,1)}function R2(n,t){if(n.length<=10)return;const o=10+t,l=n[o];if(l){const p=l[17];null!==p&&p!==n&&Ca(p,l),t>0&&(n[o-1][4]=l[4]);const g=qr(n,10+t);!function li(n,t){jc(n,t,t[11],2,null,null),t[0]=null,t[6]=null}(l[1],l);const b=g[19];null!==b&&b.detachView(g[1]),l[3]=null,l[4]=null,l[2]&=-129}return l}function $r(n,t){if(!(256&t[2])){const o=t[11];re(o)&&o.destroyNode&&jc(n,t,o,3,null,null),function xi(n){let t=n[13];if(!t)return ki(n[1],n);for(;t;){let o=null;if(u1(t))o=t[13];else{const l=t[10];l&&(o=l)}if(!o){for(;t&&!t[4]&&t!==n;)u1(t)&&ki(t[1],t),t=t[3];null===t&&(t=n),u1(t)&&ki(t[1],t),o=t&&t[4]}t=o}}(t)}}function ki(n,t){if(!(256&t[2])){t[2]&=-129,t[2]|=256,function Ci(n,t){let o;if(null!=n&&null!=(o=n.destroyHooks))for(let l=0;l<o.length;l+=2){const p=t[o[l]];if(!(p instanceof Ir)){const g=o[l+1];if(Array.isArray(g))for(let b=0;b<g.length;b+=2){const C=p[g[b]],N=g[b+1];try{N.call(C)}finally{}}else try{g.call(p)}finally{}}}}(n,t),function l2(n,t){const o=n.cleanup,l=t[7];let p=-1;if(null!==o)for(let g=0;g<o.length-1;g+=2)if("string"==typeof o[g]){const b=o[g+1],C="function"==typeof b?b(t):nn(t[b]),N=l[p=o[g+2]],R=o[g+3];"boolean"==typeof R?C.removeEventListener(o[g],N,R):R>=0?l[p=R]():l[p=-R].unsubscribe(),g+=2}else{const b=l[p=o[g+1]];o[g].call(b)}if(null!==l){for(let g=p+1;g<l.length;g++)l[g]();t[7]=null}}(n,t),1===t[1].type&&re(t[11])&&t[11].destroy();const o=t[17];if(null!==o&&I1(t[3])){o!==t[3]&&Ca(o,t);const l=t[19];null!==l&&l.detachView(n)}}}function Js(n,t,o){return d2(n,t.parent,o)}function d2(n,t,o){let l=t;for(;null!==l&&40&l.type;)l=(t=l).parent;if(null===l)return o[0];if(2&l.flags){const p=n.data[l.directiveStart].encapsulation;if(p===Nt.None||p===Nt.Emulated)return null}return kn(l,o)}function ur(n,t,o,l,p){re(n)?n.insertBefore(t,o,l,p):t.insertBefore(o,l,p)}function F2(n,t,o){re(n)?n.appendChild(t,o):t.appendChild(o)}function da(n,t,o,l,p){null!==l?ur(n,t,o,l,p):F2(n,t,o)}function Fo(n,t){return re(n)?n.parentNode(t):t.parentNode}function Ol(n,t,o){return l8(n,t,o)}function c8(n,t,o){return 40&n.type?kn(n,o):null}let E3,l8=c8;function Vl(n,t){l8=n,E3=t}function A3(n,t,o,l){const p=Js(n,l,t),g=t[11],C=Ol(l.parent||t[6],l,t);if(null!=p)if(Array.isArray(o))for(let N=0;N<o.length;N++)da(g,p,o[N],C,!1);else da(g,p,o,C,!1);void 0!==E3&&E3(g,l,t,o,p)}function L3(n,t){if(null!==t){const o=t.type;if(3&o)return kn(t,n);if(4&o)return Hl(-1,n[t.index]);if(8&o){const l=t.child;if(null!==l)return L3(n,l);{const p=n[t.index];return I1(p)?Hl(-1,p):nn(p)}}if(32&o)return Te(t,n)()||nn(n[t.index]);{const l=d8(n,t);return null!==l?Array.isArray(l)?l[0]:L3(pn(n[16]),l):L3(n,t.next)}}return null}function d8(n,t){return null!==t?n[16][6].projection[t.projection]:null}function Hl(n,t){const o=10+n+1;if(o<t.length){const l=t[o],p=l[1].firstChild;if(null!==p)return L3(l,p)}return t[7]}function u8(n,t,o){const l=Fo(n,t);l&&function Ro(n,t,o,l){re(n)?n.removeChild(t,o,l):t.removeChild(o)}(n,l,t,o)}function Rl(n,t,o,l,p,g,b){for(;null!=o;){const C=l[o.index],N=o.type;if(b&&0===t&&(C&&jt(nn(C),l),o.flags|=4),64!=(64&o.flags))if(8&N)Rl(n,t,o.child,l,p,g,!1),t1(t,n,p,C,g);else if(32&N){const R=Te(o,l);let B;for(;B=R();)t1(t,n,p,B,g);t1(t,n,p,C,g)}else 16&N?p8(n,t,l,o,p,g):t1(t,n,p,C,g);o=b?o.projectionNext:o.next}}function jc(n,t,o,l,p,g){Rl(o,l,n.firstChild,t,p,g,!1)}function p8(n,t,o,l,p,g){const b=o[16],N=b[6].projection[l.projection];if(Array.isArray(N))for(let R=0;R<N.length;R++)t1(t,n,p,N[R],g);else Rl(n,t,N,b[3],p,g,!0)}function Fl(n,t,o){re(n)?n.setAttribute(t,"style",o):t.style.cssText=o}function ql(n,t,o){re(n)?""===o?n.removeAttribute(t,"class"):n.setAttribute(t,"class",o):t.className=o}function h8(n,t,o){let l=n.length;for(;;){const p=n.indexOf(t,o);if(-1===p)return p;if(0===p||n.charCodeAt(p-1)<=32){const g=t.length;if(p+g===l||n.charCodeAt(p+g)<=32)return p}o=p+1}}const g8="ng-template";function v8(n,t,o){let l=0;for(;l<n.length;){let p=n[l++];if(o&&"class"===p){if(p=n[l],-1!==h8(p.toLowerCase(),t,0))return!0}else if(1===p){for(;l<n.length&&"string"==typeof(p=n[l++]);)if(p.toLowerCase()===t)return!0;return!1}}return!1}function Bl(n){return 4===n.type&&n.value!==g8}function Mu(n,t,o){return t===(4!==n.type||o?n.value:g8)}function wu(n,t,o){let l=4;const p=n.attrs||[],g=function zu(n){for(let t=0;t<n.length;t++)if(j2(n[t]))return t;return n.length}(p);let b=!1;for(let C=0;C<t.length;C++){const N=t[C];if("number"!=typeof N){if(!b)if(4&l){if(l=2|1&l,""!==N&&!Mu(n,N,o)||""===N&&1===t.length){if(M2(l))return!1;b=!0}}else{const R=8&l?N:t[++C];if(8&l&&null!==n.attrs){if(!v8(n.attrs,R,o)){if(M2(l))return!1;b=!0}continue}const K=b8(8&l?"class":N,p,Bl(n),o);if(-1===K){if(M2(l))return!1;b=!0;continue}if(""!==R){let ue;ue=K>g?"":p[K+1].toLowerCase();const Ce=8&l?ue:null;if(Ce&&-1!==h8(Ce,R,0)||2&l&&R!==ue){if(M2(l))return!1;b=!0}}}}else{if(!b&&!M2(l)&&!M2(N))return!1;if(b&&M2(N))continue;b=!1,l=N|1&l}}return M2(l)||b}function M2(n){return 0==(1&n)}function b8(n,t,o,l){if(null===t)return-1;let p=0;if(l||!o){let g=!1;for(;p<t.length;){const b=t[p];if(b===n)return p;if(3===b||6===b)g=!0;else{if(1===b||2===b){let C=t[++p];for(;"string"==typeof C;)C=t[++p];continue}if(4===b)break;if(0===b){p+=4;continue}}p+=g?1:2}return-1}return function _8(n,t){let o=n.indexOf(4);if(o>-1)for(o++;o<n.length;){const l=n[o];if("number"==typeof l)return-1;if(l===t)return o;o++}return-1}(t,n)}function y8(n,t,o=!1){for(let l=0;l<t.length;l++)if(wu(n,t[l],o))return!0;return!1}function Ul(n,t){e:for(let o=0;o<t.length;o++){const l=t[o];if(n.length===l.length){for(let p=0;p<n.length;p++)if(n[p]!==l[p])continue e;return!0}}return!1}function q2(n,t){return n?":not("+t.trim()+")":t}function T3(n){let t=n[0],o=1,l=2,p="",g=!1;for(;o<n.length;){let b=n[o];if("string"==typeof b)if(2&l){const C=n[++o];p+="["+b+(C.length>0?'="'+C+'"':"")+"]"}else 8&l?p+="."+b:4&l&&(p+=" "+b);else""!==p&&!M2(b)&&(t+=q2(g,p),p=""),l=b,g=g||!M2(l);o++}return""!==p&&(t+=q2(g,p)),t}const At={};function C8(n){S8(Ct(),Ye(),D1()+n,_a())}function S8(n,t,o,l){if(!l)if(3==(3&t[2])){const g=n.preOrderCheckHooks;null!==g&&vr(t,g,o)}else{const g=n.preOrderHooks;null!==g&&$a(t,g,0,o)}bi(o)}function fo(n,t){return n<<17|t<<2}function w2(n){return n>>17&32767}function z4(n){return 2|n}function po(n){return(131068&n)>>2}function j3(n,t){return-131069&n|t<<2}function Sa(n){return 1|n}function Kl(n,t){const o=n.contentQueries;if(null!==o)for(let l=0;l<o.length;l+=2){const p=o[l],g=o[l+1];if(-1!==g){const b=n.data[g];Yt(p),b.contentQueries(2,t[g],g)}}}function T4(n,t,o,l,p,g,b,C,N,R){const B=t.blueprint.slice();return B[0]=p,B[2]=140|l,W(B),B[3]=B[15]=n,B[8]=o,B[10]=b||n&&n[10],B[11]=C||n&&n[11],B[12]=N||n&&n[12]||null,B[9]=R||n&&n[9]||null,B[6]=g,B[16]=2==t.type?n[16]:B,B}function Pc(n,t,o,l,p){let g=n.data[t];if(null===g)g=q3(n,t,o,l,p),function Pe(){return $e.lFrame.inI18n}()&&(g.flags|=64);else if(64&g.type){g.type=o,g.value=l,g.attrs=p;const b=gr();g.injectorIndex=null===b?-1:b.injectorIndex}return gi(g,!0),g}function q3(n,t,o,l,p){const g=Pr(),b=X2(),N=n.data[t]=function H8(n,t,o,l,p,g){return{type:o,index:l,insertBeforeIndex:null,injectorIndex:t?t.injectorIndex:-1,directiveStart:-1,directiveEnd:-1,directiveStylingLast:-1,propertyBindings:null,flags:0,providerIndexes:0,value:p,attrs:g,mergedAttrs:null,localNames:null,initialInputs:void 0,inputs:null,outputs:null,tViews:null,next:null,projectionNext:null,child:null,parent:t,projection:null,styles:null,stylesWithoutHost:null,residualStyles:void 0,classes:null,classesWithoutHost:null,residualClasses:void 0,classBindings:0,styleBindings:0}}(0,b?g:g&&g.parent,o,t,l,p);return null===n.firstChild&&(n.firstChild=N),null!==g&&(b?null==g.child&&null!==N.parent&&(g.child=N):null===g.next&&(g.next=N)),N}function Ic(n,t,o,l){if(0===o)return-1;const p=t.length;for(let g=0;g<o;g++)t.push(l),n.blueprint.push(l),n.data.push(null);return p}function j4(n,t,o){Y1(t);try{const l=n.viewQuery;null!==l&&m0(1,l,o);const p=n.template;null!==p&&e0(n,t,p,1,o),n.firstCreatePass&&(n.firstCreatePass=!1),n.staticContentQueries&&Kl(n,t),n.staticViewQueries&&m0(2,n.viewQuery,o);const g=n.components;null!==g&&function ku(n,t){for(let o=0;o<t.length;o++)qu(n,t[o])}(t,g)}catch(l){throw n.firstCreatePass&&(n.incompleteFirstPass=!0,n.firstCreatePass=!1),l}finally{t[2]&=-5,aa()}}function Oc(n,t,o,l){const p=t[2];if(256==(256&p))return;Y1(t);const g=_a();try{W(t),function Y(n){return $e.lFrame.bindingIndex=n}(n.bindingStartIndex),null!==o&&e0(n,t,o,2,l);const b=3==(3&p);if(!g)if(b){const R=n.preOrderCheckHooks;null!==R&&vr(t,R,null)}else{const R=n.preOrderHooks;null!==R&&$a(t,R,0,null),L2(t,0)}if(function u0(n){for(let t=Nn(n);null!==t;t=Wn(t)){if(!t[2])continue;const o=t[9];for(let l=0;l<o.length;l++){const p=o[l],g=p[3];0==(1024&p[2])&&je(g,1),p[2]|=1024}}}(t),function X8(n){for(let t=Nn(n);null!==t;t=Wn(t))for(let o=10;o<t.length;o++){const l=t[o],p=l[1];P(l)&&Oc(p,l,p.template,l[8])}}(t),null!==n.contentQueries&&Kl(n,t),!g)if(b){const R=n.contentCheckHooks;null!==R&&vr(t,R)}else{const R=n.contentHooks;null!==R&&$a(t,R,1),L2(t,1)}!function Tu(n,t){const o=n.hostBindingOpCodes;if(null!==o)try{for(let l=0;l<o.length;l++){const p=o[l];if(p<0)bi(~p);else{const g=p,b=o[++l],C=o[++l];Be(b,g),C(2,t[g])}}}finally{bi(-1)}}(n,t);const C=n.components;null!==C&&function ju(n,t){for(let o=0;o<t.length;o++)W3(n,t[o])}(t,C);const N=n.viewQuery;if(null!==N&&m0(2,N,l),!g)if(b){const R=n.viewCheckHooks;null!==R&&vr(t,R)}else{const R=n.viewHooks;null!==R&&$a(t,R,2),L2(t,2)}!0===n.firstUpdatePass&&(n.firstUpdatePass=!1),g||(t[2]&=-73),1024&t[2]&&(t[2]&=-1025,je(t[3],-1))}finally{aa()}}function j8(n,t,o,l){const p=t[10],g=!_a(),b=H1(t);try{g&&!b&&p.begin&&p.begin(),b&&j4(n,t,l),Oc(n,t,o,l)}finally{g&&!b&&p.end&&p.end()}}function e0(n,t,o,l,p){const g=D1(),b=2&l;try{bi(-1),b&&t.length>20&&S8(n,t,20,_a()),o(l,p)}finally{bi(g)}}function n0(n,t,o){!ta()||(function B8(n,t,o,l){const p=o.directiveStart,g=o.directiveEnd;n.firstCreatePass||_r(o,t),jt(l,t);const b=o.initialInputs;for(let C=p;C<g;C++){const N=n.data[C],R=K1(N);R&&Z8(t,o,N);const B=Ie(t,n,C,o);jt(B,t),null!==b&&$8(0,C-p,B,N,0,b),R&&(V1(o.index,t)[8]=B)}}(n,t,o,kn(o,t)),128==(128&o.flags)&&function U8(n,t,o){const l=o.directiveStart,p=o.directiveEnd,b=o.index,C=function An(){return $e.lFrame.currentDirectiveIndex}();try{bi(b);for(let N=l;N<p;N++){const R=n.data[N],B=t[N];dt(N),(null!==R.hostBindings||0!==R.hostVars||null!==R.hostAttrs)&&U3(R,B)}}finally{bi(-1),dt(C)}}(n,t,o))}function t0(n,t,o=kn){const l=t.localNames;if(null!==l){let p=t.index+1;for(let g=0;g<l.length;g+=2){const b=l[g+1],C=-1===b?o(t,n):n[b];n[p++]=C}}}function P8(n){const t=n.tView;return null===t||t.incompleteFirstPass?n.tView=k4(1,null,n.template,n.decls,n.vars,n.directiveDefs,n.pipeDefs,n.viewQuery,n.schemas,n.consts):t}function k4(n,t,o,l,p,g,b,C,N,R){const B=20+l,K=B+p,ue=function Pu(n,t){const o=[];for(let l=0;l<t;l++)o.push(l<n?null:At);return o}(B,K),Ce="function"==typeof R?R():R;return ue[1]={type:n,blueprint:ue,template:o,queries:null,viewQuery:C,declTNode:t,data:ue.slice().fill(null,B),bindingStartIndex:B,expandoStartIndex:K,hostBindingOpCodes:null,firstCreatePass:!0,firstUpdatePass:!0,staticViewQueries:!1,staticContentQueries:!1,preOrderHooks:null,preOrderCheckHooks:null,contentHooks:null,contentCheckHooks:null,viewHooks:null,viewCheckHooks:null,destroyHooks:null,cleanup:null,contentQueries:null,components:null,directiveRegistry:"function"==typeof g?g():g,pipeRegistry:"function"==typeof b?b():b,firstChild:null,schemas:N,consts:Ce,incompleteFirstPass:!1}}function V8(n,t,o,l){const p=Q8(t);null===o?p.push(l):(p.push(o),n.firstCreatePass&&J8(n).push(l,p.length-1))}function R8(n,t,o){for(let l in n)if(n.hasOwnProperty(l)){const p=n[l];(o=null===o?{}:o).hasOwnProperty(l)?o[l].push(t,p):o[l]=[t,p]}return o}function u2(n,t,o,l,p,g,b,C){const N=kn(t,o);let B,R=t.inputs;!C&&null!=R&&(B=R[l])?(n5(n,o,B,l,p),Ki(t)&&function Vu(n,t){const o=V1(t,n);16&o[2]||(o[2]|=64)}(o,t.index)):3&t.type&&(l=function F8(n){return"class"===n?"className":"for"===n?"htmlFor":"formaction"===n?"formAction":"innerHtml"===n?"innerHTML":"readonly"===n?"readOnly":"tabindex"===n?"tabIndex":n}(l),p=null!=b?b(p,t.value||"",l):p,re(g)?g.setProperty(N,l,p):K2(l)||(N.setProperty?N.setProperty(l,p):N[l]=p))}function ec(n,t,o,l){let p=!1;if(ta()){const g=function r0(n,t,o){const l=n.directiveRegistry;let p=null;if(l)for(let g=0;g<l.length;g++){const b=l[g];y8(o,b.selectors,!1)&&(p||(p=[]),es(_r(o,t),n,b.type),K1(b)?(o0(n,o),p.unshift(b)):p.push(b))}return p}(n,t,o),b=null===l?null:{"":-1};if(null!==g){p=!0,s0(o,n.data.length,g.length);for(let B=0;B<g.length;B++){const K=g[B];K.providersResolver&&K.providersResolver(K)}let C=!1,N=!1,R=Ic(n,t,g.length,null);for(let B=0;B<g.length;B++){const K=g[B];o.mergedAttrs=Vr(o.mergedAttrs,K.hostAttrs),c0(n,o,t,R,K),W8(R,K,b),null!==K.contentQueries&&(o.flags|=8),(null!==K.hostBindings||null!==K.hostAttrs||0!==K.hostVars)&&(o.flags|=128);const ue=K.type.prototype;!C&&(ue.ngOnChanges||ue.ngOnInit||ue.ngDoCheck)&&((n.preOrderHooks||(n.preOrderHooks=[])).push(o.index),C=!0),!N&&(ue.ngOnChanges||ue.ngDoCheck)&&((n.preOrderCheckHooks||(n.preOrderCheckHooks=[])).push(o.index),N=!0),R++}!function Ou(n,t){const l=t.directiveEnd,p=n.data,g=t.attrs,b=[];let C=null,N=null;for(let R=t.directiveStart;R<l;R++){const B=p[R],K=B.inputs,ue=null===g||Bl(t)?null:l0(K,g);b.push(ue),C=R8(K,R,C),N=R8(B.outputs,R,N)}null!==C&&(C.hasOwnProperty("class")&&(t.flags|=16),C.hasOwnProperty("style")&&(t.flags|=32)),t.initialInputs=b,t.inputs=C,t.outputs=N}(n,o)}b&&function G8(n,t,o){if(t){const l=n.localNames=[];for(let p=0;p<t.length;p+=2){const g=o[t[p+1]];if(null==g)throw new yn(-301,!1);l.push(t[p],g)}}}(o,l,b)}return o.mergedAttrs=Vr(o.mergedAttrs,o.attrs),p}function B3(n,t,o,l,p,g){const b=g.hostBindings;if(b){let C=n.hostBindingOpCodes;null===C&&(C=n.hostBindingOpCodes=[]);const N=~t.index;(function q8(n){let t=n.length;for(;t>0;){const o=n[--t];if("number"==typeof o&&o<0)return o}return 0})(C)!=N&&C.push(N),C.push(l,p,b)}}function U3(n,t){null!==n.hostBindings&&n.hostBindings(1,t)}function o0(n,t){t.flags|=2,(n.components||(n.components=[])).push(t.index)}function W8(n,t,o){if(o){if(t.exportAs)for(let l=0;l<t.exportAs.length;l++)o[t.exportAs[l]]=n;K1(t)&&(o[""]=n)}}function s0(n,t,o){n.flags|=1,n.directiveStart=t,n.directiveEnd=t+o,n.providerIndexes=t}function c0(n,t,o,l,p){n.data[l]=p;const g=p.factory||(p.factory=w1(p.type)),b=new Ir(g,K1(p),null);n.blueprint[l]=b,o[l]=b,B3(n,t,0,l,Ic(n,o,p.hostVars,At),p)}function Z8(n,t,o){const l=kn(t,n),p=P8(o),g=n[10],b=$3(n,T4(n,p,null,o.onPush?64:16,l,t,g,g.createRenderer(l,o),null,null));n[t.index]=b}function G3(n,t,o,l,p,g,b){if(null==g)re(n)?n.removeAttribute(t,p,o):t.removeAttribute(p);else{const C=null==b?cn(g):b(g,l||"",p);re(n)?n.setAttribute(t,p,C,o):o?t.setAttributeNS(o,p,C):t.setAttribute(p,C)}}function $8(n,t,o,l,p,g){const b=g[t];if(null!==b){const C=l.setInput;for(let N=0;N<b.length;){const R=b[N++],B=b[N++],K=b[N++];null!==C?l.setInput(o,K,R,B):o[B]=K}}}function l0(n,t){let o=null,l=0;for(;l<t.length;){const p=t[l];if(0!==p)if(5!==p){if("number"==typeof p)break;n.hasOwnProperty(p)&&(null===o&&(o=[]),o.push(p,n[p],t[l+1])),l+=2}else l+=2;else l+=4}return o}function d0(n,t,o,l){return new Array(n,!0,!1,t,null,0,l,o,null,null)}function W3(n,t){const o=V1(t,n);if(P(o)){const l=o[1];80&o[2]?Oc(l,o,l.template,o[8]):o[5]>0&&Z3(o)}}function Z3(n){for(let l=Nn(n);null!==l;l=Wn(l))for(let p=10;p<l.length;p++){const g=l[p];if(1024&g[2]){const b=g[1];Oc(b,g,b.template,g[8])}else g[5]>0&&Z3(g)}const o=n[1].components;if(null!==o)for(let l=0;l<o.length;l++){const p=V1(o[l],n);P(p)&&p[5]>0&&Z3(p)}}function qu(n,t){const o=V1(t,n),l=o[1];(function Bu(n,t){for(let o=t.length;o<n.blueprint.length;o++)t.push(n.blueprint[o])})(l,o),j4(l,o,o[8])}function $3(n,t){return n[13]?n[14][4]=t:n[13]=t,n[14]=t,t}function X3(n){for(;n;){n[2]|=64;const t=pn(n);if(Ea(n)&&!t)return n;n=t}return null}function p0(n,t,o){const l=t[10];l.begin&&l.begin();try{Oc(n,t,n.template,o)}catch(p){throw e5(t,p),p}finally{l.end&&l.end()}}function Y8(n){!function f0(n){for(let t=0;t<n.components.length;t++){const o=n.components[t],l=bs(o),p=l[1];j8(p,l,p.template,o)}}(n[8])}function m0(n,t,o){Yt(0),t(n,o)}const Zu=(()=>Promise.resolve(null))();function Q8(n){return n[7]||(n[7]=[])}function J8(n){return n.cleanup||(n.cleanup=[])}function e5(n,t){const o=n[9],l=o?o.get(H2,null):null;l&&l.handleError(t)}function n5(n,t,o,l,p){for(let g=0;g<o.length;){const b=o[g++],C=o[g++],N=t[b],R=n.data[b];null!==R.setInput?R.setInput(N,p,l,C):N[C]=p}}function Y3(n,t,o){let l=o?n.styles:null,p=o?n.classes:null,g=0;if(null!==t)for(let b=0;b<t.length;b++){const C=t[b];"number"==typeof C?g=C:1==g?p=dn(p,C):2==g&&(l=dn(l,C+": "+t[++b]+";"))}o?n.styles=l:n.stylesWithoutHost=l,o?n.classes=p:n.classesWithoutHost=p}const h0=new ti("INJECTOR",-1);class t5{get(t,o=as){if(o===as){const l=new Error(`NullInjectorError: No provider for ${Ae(t)}!`);throw l.name="NullInjectorError",l}return o}}const P4=new ti("Set Injector scope."),I4={},z2={};let W1;function O4(){return void 0===W1&&(W1=new t5),W1}function Q3(n,t=null,o=null,l){const p=V4(n,t,o,l);return p._resolveInjectorDefTypes(),p}function V4(n,t=null,o=null,l){return new i5(n,o,t||O4(),l)}class i5{constructor(t,o,l,p=null){this.parent=l,this.records=new Map,this.injectorDefTypes=new Set,this.onDestroy=new Set,this._destroyed=!1;const g=[];o&&yi(o,C=>this.processProvider(C,t,o)),yi([t],C=>this.processInjectorType(C,[],g)),this.records.set(h0,go(void 0,this));const b=this.records.get(P4);this.scope=null!=b?b.value:null,this.source=p||("object"==typeof t?null:Ae(t))}get destroyed(){return this._destroyed}destroy(){this.assertNotDestroyed(),this._destroyed=!0;try{this.onDestroy.forEach(t=>t.ngOnDestroy())}finally{this.records.clear(),this.onDestroy.clear(),this.injectorDefTypes.clear()}}get(t,o=as,l=$n.Default){this.assertNotDestroyed();const p=t4(this),g=xn(void 0);try{if(!(l&$n.SkipSelf)){let C=this.records.get(t);if(void 0===C){const N=function Vc(n){return"function"==typeof n||"object"==typeof n&&n instanceof ti}(t)&&pi(t);C=N&&this.injectableDefInScope(N)?go(J3(t),I4):null,this.records.set(t,C)}if(null!=C)return this.hydrate(t,C)}return(l&$n.Self?O4():this.parent).get(t,o=l&$n.Optional&&o===as?null:o)}catch(b){if("NullInjectorError"===b.name){if((b[os]=b[os]||[]).unshift(Ae(t)),p)throw b;return function C2(n,t,o,l){const p=n[os];throw t[gc]&&p.unshift(t[gc]),n.message=function Ao(n,t,o,l=null){n=n&&"\n"===n.charAt(0)&&"\u0275"==n.charAt(1)?n.substr(2):n;let p=Ae(t);if(Array.isArray(t))p=t.map(Ae).join(" -> ");else if("object"==typeof t){let g=[];for(let b in t)if(t.hasOwnProperty(b)){let C=t[b];g.push(b+":"+("string"==typeof C?JSON.stringify(C):Ae(C)))}p=`{${g.join(", ")}}`}return`${o}${l?"("+l+")":""}[${p}]: ${n.replace(hc,"\n  ")}`}("\n"+n.message,p,o,l),n.ngTokenPath=p,n[os]=null,n}(b,t,"R3InjectorError",this.source)}throw b}finally{xn(g),t4(p)}}_resolveInjectorDefTypes(){this.injectorDefTypes.forEach(t=>this.get(t))}toString(){const t=[];return this.records.forEach((l,p)=>t.push(Ae(p))),`R3Injector[${t.join(", ")}]`}assertNotDestroyed(){if(this._destroyed)throw new yn(205,!1)}processInjectorType(t,o,l){if(!(t=Qe(t)))return!1;let p=a1(t);const g=null==p&&t.ngModule||void 0,b=void 0===g?t:g,C=-1!==l.indexOf(b);if(void 0!==g&&(p=a1(g)),null==p)return!1;if(null!=p.imports&&!C){let B;l.push(b);try{yi(p.imports,K=>{this.processInjectorType(K,o,l)&&(void 0===B&&(B=[]),B.push(K))})}finally{}if(void 0!==B)for(let K=0;K<B.length;K++){const{ngModule:ue,providers:Ce}=B[K];yi(Ce,qe=>this.processProvider(qe,ue,Ce||et))}}this.injectorDefTypes.add(b);const N=w1(b)||(()=>new b);this.records.set(b,go(N,I4));const R=p.providers;if(null!=R&&!C){const B=t;yi(R,K=>this.processProvider(K,B,R))}return void 0!==g&&void 0!==t.providers}processProvider(t,o,l){let p=tc(t=Qe(t))?t:Qe(t&&t.provide);const g=function Yu(n,t,o){return el(n)?go(void 0,n.useValue):go(nc(n),I4)}(t);if(tc(t)||!0!==t.multi)this.records.get(p);else{let b=this.records.get(p);b||(b=go(void 0,I4,!0),b.factory=()=>Ja(b.multi),this.records.set(p,b)),p=t,b.multi.push(t)}this.records.set(p,g)}hydrate(t,o){return o.value===I4&&(o.value=z2,o.value=o.factory()),"object"==typeof o.value&&o.value&&function Go(n){return null!==n&&"object"==typeof n&&"function"==typeof n.ngOnDestroy}(o.value)&&this.onDestroy.add(o.value),o.value}injectableDefInScope(t){if(!t.providedIn)return!1;const o=Qe(t.providedIn);return"string"==typeof o?"any"===o||o===this.scope:this.injectorDefTypes.has(o)}}function J3(n){const t=pi(n),o=null!==t?t.factory:w1(n);if(null!==o)return o;if(n instanceof ti)throw new yn(204,!1);if(n instanceof Function)return function K3(n){const t=n.length;if(t>0)throw No(t,"?"),new yn(204,!1);const o=function j1(n){const t=n&&(n[q1]||n[Mi]);if(t){const o=function Gt(n){if(n.hasOwnProperty("name"))return n.name;const t=(""+n).match(/^function\s*([^\s(]+)/);return null===t?"":t[1]}(n);return console.warn(`DEPRECATED: DI is instantiating a token "${o}" that inherits its @Injectable decorator but does not provide one itself.\nThis will become an error in a future version of Angular. Please add @Injectable() to the "${o}" class.`),t}return null}(n);return null!==o?()=>o.factory(n):()=>new n}(n);throw new yn(204,!1)}function nc(n,t,o){let l;if(tc(n)){const p=Qe(n);return w1(p)||J3(p)}if(el(n))l=()=>Qe(n.useValue);else if(function g0(n){return!(!n||!n.useFactory)}(n))l=()=>n.useFactory(...Ja(n.deps||[]));else if(function a5(n){return!(!n||!n.useExisting)}(n))l=()=>vt(Qe(n.useExisting));else{const p=Qe(n&&(n.useClass||n.provide));if(!function ic(n){return!!n.deps}(n))return w1(p)||J3(p);l=()=>new p(...Ja(n.deps))}return l}function go(n,t,o=!1){return{factory:n,value:t,multi:o?[]:void 0}}function el(n){return null!==n&&"object"==typeof n&&Eo in n}function tc(n){return"function"==typeof n}let Dr=(()=>{class n{static create(o,l){var p;if(Array.isArray(o))return Q3({name:""},l,o,"");{const g=null!==(p=o.name)&&void 0!==p?p:"";return Q3({name:g},o.parent,o.providers,g)}}}return n.THROW_IF_NOT_FOUND=as,n.NULL=new t5,n.\u0275prov=Ut({token:n,providedIn:"any",factory:()=>vt(h0)}),n.__NG_ELEMENT_ID__=-1,n})();function r7(n,t){E1(bs(n)[1],b1())}function y0(n){let t=function Zo(n){return Object.getPrototypeOf(n.prototype).constructor}(n.type),o=!0;const l=[n];for(;t;){let p;if(K1(n))p=t.\u0275cmp||t.\u0275dir;else{if(t.\u0275cmp)throw new yn(903,"");p=t.\u0275dir}if(p){if(o){l.push(p);const b=n;b.inputs=R4(n.inputs),b.declaredInputs=R4(n.declaredInputs),b.outputs=R4(n.outputs);const C=p.hostBindings;C&&m5(n,C);const N=p.viewQuery,R=p.contentQueries;if(N&&p5(n,N),R&&Ss(n,R),Me(n.inputs,p.inputs),Me(n.declaredInputs,p.declaredInputs),Me(n.outputs,p.outputs),K1(p)&&p.data.animation){const B=n.data;B.animation=(B.animation||[]).concat(p.data.animation)}}const g=p.features;if(g)for(let b=0;b<g.length;b++){const C=g[b];C&&C.ngInherit&&C(n),C===y0&&(o=!1)}}t=Object.getPrototypeOf(t)}!function f5(n){let t=0,o=null;for(let l=n.length-1;l>=0;l--){const p=n[l];p.hostVars=t+=p.hostVars,p.hostAttrs=Vr(p.hostAttrs,o=Vr(o,p.hostAttrs))}}(l)}function R4(n){return n===m1?{}:n===et?[]:n}function p5(n,t){const o=n.viewQuery;n.viewQuery=o?(l,p)=>{t(l,p),o(l,p)}:t}function Ss(n,t){const o=n.contentQueries;n.contentQueries=o?(l,p,g)=>{t(l,p,g),o(l,p,g)}:t}function m5(n,t){const o=n.hostBindings;n.hostBindings=o?(l,p)=>{t(l,p),o(l,p)}:t}let F4=null;function vo(){if(!F4){const n=gt.Symbol;if(n&&n.iterator)F4=n.iterator;else{const t=Object.getOwnPropertyNames(Map.prototype);for(let o=0;o<t.length;++o){const l=t[o];"entries"!==l&&"size"!==l&&Map.prototype[l]===Map.prototype.entries&&(F4=l)}}}return F4}function Fc(n){return!!q4(n)&&(Array.isArray(n)||!(n instanceof Map)&&vo()in n)}function q4(n){return null!==n&&("function"==typeof n||"object"==typeof n)}function p2(n,t,o){return n[t]=o}function Ra(n,t,o){return!Object.is(n[t],o)&&(n[t]=o,!0)}function ws(n,t,o,l){const p=Ra(n,t,o);return Ra(n,t+1,l)||p}function S0(n,t,o,l){const p=Ye();return Ra(p,ne(),t)&&(Ct(),function U2(n,t,o,l,p,g){const b=kn(n,t);G3(t[11],b,g,n.value,o,l,p)}(It(),p,n,t,o,l)),S0}function zs(n,t,o,l){return Ra(n,ne(),o)?t+cn(o)+l:At}function x5(n,t,o,l,p,g,b,C){const N=Ye(),R=Ct(),B=n+20,K=R.firstCreatePass?function _5(n,t,o,l,p,g,b,C,N){const R=t.consts,B=Pc(t,n,4,b||null,D(R,C));ec(t,o,B,D(R,N)),E1(t,B);const K=B.tViews=k4(2,B,l,p,g,t.directiveRegistry,t.pipeRegistry,null,t.schemas,R);return null!==t.queries&&(t.queries.template(t,B),K.queries=t.queries.embeddedTView(B)),B}(B,R,N,t,o,l,p,g,b):R.data[B];gi(K,!1);const ue=N[11].createComment("");A3(R,N,ue,K),jt(ue,N),$3(N,N[B]=d0(ue,N,ue,K)),X1(K)&&n0(R,N,K),null!=b&&t0(N,K,C)}function C5(n){return function h1(n,t){return n[t]}(function h2(){return $e.lFrame.contextLView}(),20+n)}function Bc(n,t=$n.Default){const o=Ye();return null===o?vt(n,t):T(b1(),o,Qe(n),t)}function V0(){throw new Error("invalid")}function cl(n,t,o){const l=Ye();return Ra(l,ne(),t)&&u2(Ct(),It(),l,n,t,l[11],o,!1),cl}function G4(n,t,o,l,p){const b=p?"class":"style";n5(n,o,t.inputs[b],b,l)}function W4(n,t,o,l){const p=Ye(),g=Ct(),b=20+n,C=p[11],N=p[b]=la(C,t,function n2(){return $e.lFrame.currentNamespace}()),R=g.firstCreatePass?function L5(n,t,o,l,p,g,b){const C=t.consts,R=Pc(t,n,2,p,D(C,g));return ec(t,o,R,D(C,b)),null!==R.attrs&&Y3(R,R.attrs,!1),null!==R.mergedAttrs&&Y3(R,R.mergedAttrs,!0),null!==t.queries&&t.queries.elementStart(t,R),R}(b,g,p,0,t,o,l):g.data[b];gi(R,!0);const B=R.mergedAttrs;null!==B&&Or(C,N,B);const K=R.classes;null!==K&&ql(C,N,K);const ue=R.styles;return null!==ue&&Fl(C,N,ue),64!=(64&R.flags)&&A3(g,p,N,R),0===function ri(){return $e.lFrame.elementDepthCount}()&&jt(N,p),function U1(){$e.lFrame.elementDepthCount++}(),X1(R)&&(n0(g,p,R),function k8(n,t,o){if(Da(t)){const p=t.directiveEnd;for(let g=t.directiveStart;g<p;g++){const b=n.data[g];b.contentQueries&&b.contentQueries(1,o[g],g)}}}(g,R,p)),null!==l&&t0(p,R),W4}function ll(){let n=b1();X2()?Y2():(n=n.parent,gi(n,!1));const t=n;!function Ri(){$e.lFrame.elementDepthCount--}();const o=Ct();return o.firstCreatePass&&(E1(o,n),Da(n)&&o.queries.elementEnd(n)),null!=t.classesWithoutHost&&function Q2(n){return 0!=(16&n.flags)}(t)&&G4(o,t,Ye(),t.classesWithoutHost,!0),null!=t.stylesWithoutHost&&function J2(n){return 0!=(32&n.flags)}(t)&&G4(o,t,Ye(),t.stylesWithoutHost,!1),ll}function dl(n,t,o,l){return W4(n,t,o,l),ll(),dl}function H0(){return Ye()}function $4(n){return!!n&&"function"==typeof n.then}function R0(n){return!!n&&"function"==typeof n.subscribe}const F0=R0;function pl(n,t,o,l){const p=Ye(),g=Ct(),b=b1();return function B0(n,t,o,l,p,g,b,C){const N=X1(l),B=n.firstCreatePass&&J8(n),K=t[8],ue=Q8(t);let Ce=!0;if(3&l.type||C){const zn=kn(l,t),Fn=C?C(zn):zn,en=ue.length,at=C?i1=>C(nn(i1[l.index])):l.index;if(re(o)){let i1=null;if(!C&&N&&(i1=function j5(n,t,o,l){const p=n.cleanup;if(null!=p)for(let g=0;g<p.length-1;g+=2){const b=p[g];if(b===o&&p[g+1]===l){const C=t[7],N=p[g+2];return C.length>N?C[N]:null}"string"==typeof b&&(g+=2)}return null}(n,t,p,l.index)),null!==i1)(i1.__ngLastListenerFn__||i1).__ngNextListenerFn__=g,i1.__ngLastListenerFn__=g,Ce=!1;else{g=ml(l,t,K,g,!1);const T1=o.listen(Fn,p,g);ue.push(g,T1),B&&B.push(p,at,en,en+1)}}else g=ml(l,t,K,g,!0),Fn.addEventListener(p,g,b),ue.push(g),B&&B.push(p,at,en,b)}else g=ml(l,t,K,g,!1);const qe=l.outputs;let vn;if(Ce&&null!==qe&&(vn=qe[p])){const zn=vn.length;if(zn)for(let Fn=0;Fn<zn;Fn+=2){const E2=t[vn[Fn]][vn[Fn+1]].subscribe(g),Wc=ue.length;ue.push(g,E2),B&&B.push(p,l.index,Wc,-(Wc+1))}}}(g,p,p[11],b,n,t,!!o,l),pl}function U0(n,t,o,l){try{return!1!==o(l)}catch(p){return e5(n,p),!1}}function ml(n,t,o,l,p){return function g(b){if(b===Function)return l;const C=2&n.flags?V1(n.index,t):t;0==(32&t[2])&&X3(C);let N=U0(t,0,l,b),R=g.__ngNextListenerFn__;for(;R;)N=U0(t,0,R,b)&&N,R=R.__ngNextListenerFn__;return p&&!1===N&&(b.preventDefault(),b.returnValue=!1),N}}function G0(n=1){return function Ia(n){return($e.lFrame.contextLView=function R1(n,t){for(;n>0;)t=t[15],n--;return t}(n,$e.lFrame.contextLView))[8]}(n)}function k5(n,t){let o=null;const l=function w4(n){const t=n.attrs;if(null!=t){const o=t.indexOf(5);if(0==(1&o))return t[o+1]}return null}(n);for(let p=0;p<t.length;p++){const g=t[p];if("*"!==g){if(null===l?y8(n,g,!0):Ul(l,g))return p}else o=p}return o}function W0(n){const t=Ye()[16][6];if(!t.projection){const l=t.projection=No(n?n.length:1,null),p=l.slice();let g=t.child;for(;null!==g;){const b=n?k5(g,n):0;null!==b&&(p[b]?p[b].projectionNext=g:l[b]=g,p[b]=g),g=g.next}}}function Z0(n,t=0,o){const l=Ye(),p=Ct(),g=Pc(p,20+n,16,null,o||null);null===g.projection&&(g.projection=t),Y2(),64!=(64&g.flags)&&function f8(n,t,o){p8(t[11],0,t,o,Js(n,o,t),Ol(o.parent||t[6],o,t))}(p,l,g)}function hl(n,t,o){return X4(n,"",t,"",o),hl}function X4(n,t,o,l,p){const g=Ye(),b=zs(g,t,o,l);return b!==At&&u2(Ct(),It(),g,n,b,g[11],p,!1),X4}function t6(n,t,o,l,p){const g=n[o+1],b=null===t;let C=l?w2(g):po(g),N=!1;for(;0!==C&&(!1===N||b);){const B=n[C+1];O5(n[C],t)&&(N=!0,n[C+1]=l?Sa(B):z4(B)),C=l?w2(B):po(B)}N&&(n[o+1]=l?z4(g):Sa(g))}function O5(n,t){return null===n||null==t||(Array.isArray(n)?n[1]:n)===t||!(!Array.isArray(n)||"string"!=typeof t)&&to(n,t)>=0}const ua={textEnd:0,key:0,keyEnd:0,value:0,valueEnd:0};function i6(n){return n.substring(ua.key,ua.keyEnd)}function a6(n,t){const o=ua.textEnd;return o===t?-1:(t=ua.keyEnd=function F5(n,t,o){for(;t<o&&n.charCodeAt(t)>32;)t++;return t}(n,ua.key=t,o),oc(n,t,o))}function oc(n,t,o){for(;t<o&&n.charCodeAt(t)<=32;)t++;return t}function Y4(n,t,o){return N2(n,t,o,!1),Y4}function gl(n,t){return N2(n,t,null,!0),gl}function l6(n){D2(sa,W2,n,!0)}function W2(n,t){for(let o=function H5(n){return function o6(n){ua.key=0,ua.keyEnd=0,ua.value=0,ua.valueEnd=0,ua.textEnd=n.length}(n),a6(n,oc(n,0,ua.textEnd))}(t);o>=0;o=a6(t,o))sa(n,i6(t),!0)}function N2(n,t,o,l){const p=Ye(),g=Ct(),b=ve(2);g.firstUpdatePass&&u6(g,n,b,l),t!==At&&Ra(p,b,t)&&p6(g,g.data[D1()],p,p[11],n,p[b+1]=function Q5(n,t){return null==n||("string"==typeof t?n+=t:"object"==typeof n&&(n=Ae(_i(n)))),n}(t,o),l,b)}function D2(n,t,o,l){const p=Ct(),g=ve(2);p.firstUpdatePass&&u6(p,null,g,l);const b=Ye();if(o!==At&&Ra(b,g,o)){const C=p.data[D1()];if(h6(C,l)&&!d6(p,g)){let N=l?C.classesWithoutHost:C.stylesWithoutHost;null!==N&&(o=dn(N,o||"")),G4(p,C,b,o,l)}else!function Y5(n,t,o,l,p,g,b,C){p===At&&(p=et);let N=0,R=0,B=0<p.length?p[0]:null,K=0<g.length?g[0]:null;for(;null!==B||null!==K;){const ue=N<p.length?p[N+1]:void 0,Ce=R<g.length?g[R+1]:void 0;let vn,qe=null;B===K?(N+=2,R+=2,ue!==Ce&&(qe=K,vn=Ce)):null===K||null!==B&&B<K?(N+=2,qe=B):(R+=2,qe=K,vn=Ce),null!==qe&&p6(n,t,o,l,qe,vn,b,C),B=N<p.length?p[N]:null,K=R<g.length?g[R]:null}}(p,C,b,b[11],b[g+1],b[g+1]=function X5(n,t,o){if(null==o||""===o)return et;const l=[],p=_i(o);if(Array.isArray(p))for(let g=0;g<p.length;g++)n(l,p[g],!0);else if("object"==typeof p)for(const g in p)p.hasOwnProperty(g)&&n(l,g,p[g]);else"string"==typeof p&&t(l,p);return l}(n,t,o),l,g)}}function d6(n,t){return t>=n.expandoStartIndex}function u6(n,t,o,l){const p=n.data;if(null===p[o+1]){const g=p[D1()],b=d6(n,o);h6(g,l)&&null===t&&!b&&(t=!1),t=function G5(n,t,o,l){const p=function ft(n){const t=$e.lFrame.currentDirectiveIndex;return-1===t?null:n[t]}(n);let g=l?t.residualClasses:t.residualStyles;if(null===p)0===(l?t.classBindings:t.styleBindings)&&(o=Uc(o=vl(null,n,t,o,l),t.attrs,l),g=null);else{const b=t.directiveStylingLast;if(-1===b||n[b]!==p)if(o=vl(p,n,t,o,l),null===g){let N=function W5(n,t,o){const l=o?t.classBindings:t.styleBindings;if(0!==po(l))return n[w2(l)]}(n,t,l);void 0!==N&&Array.isArray(N)&&(N=vl(null,n,t,N[1],l),N=Uc(N,t.attrs,l),function Z5(n,t,o,l){n[w2(o?t.classBindings:t.styleBindings)]=l}(n,t,l,N))}else g=function $5(n,t,o){let l;const p=t.directiveEnd;for(let g=1+t.directiveStylingLast;g<p;g++)l=Uc(l,n[g].hostAttrs,o);return Uc(l,t.attrs,o)}(n,t,l)}return void 0!==g&&(l?t.residualClasses=g:t.residualStyles=g),o}(p,g,t,l),function P5(n,t,o,l,p,g){let b=g?t.classBindings:t.styleBindings,C=w2(b),N=po(b);n[l]=o;let B,R=!1;if(Array.isArray(o)){const K=o;B=K[1],(null===B||to(K,B)>0)&&(R=!0)}else B=o;if(p)if(0!==N){const ue=w2(n[C+1]);n[l+1]=fo(ue,C),0!==ue&&(n[ue+1]=j3(n[ue+1],l)),n[C+1]=function w8(n,t){return 131071&n|t<<17}(n[C+1],l)}else n[l+1]=fo(C,0),0!==C&&(n[C+1]=j3(n[C+1],l)),C=l;else n[l+1]=fo(N,0),0===C?C=l:n[N+1]=j3(n[N+1],l),N=l;R&&(n[l+1]=z4(n[l+1])),t6(n,B,l,!0),t6(n,B,l,!1),function I5(n,t,o,l,p){const g=p?n.residualClasses:n.residualStyles;null!=g&&"string"==typeof t&&to(g,t)>=0&&(o[l+1]=Sa(o[l+1]))}(t,B,n,l,g),b=fo(C,N),g?t.classBindings=b:t.styleBindings=b}(p,g,t,o,b,l)}}function vl(n,t,o,l,p){let g=null;const b=o.directiveEnd;let C=o.directiveStylingLast;for(-1===C?C=o.directiveStart:C++;C<b&&(g=t[C],l=Uc(l,g.hostAttrs,p),g!==n);)C++;return null!==n&&(o.directiveStylingLast=C),l}function Uc(n,t,o){const l=o?1:2;let p=-1;if(null!==t)for(let g=0;g<t.length;g++){const b=t[g];"number"==typeof b?p=b:p===l&&(Array.isArray(n)||(n=void 0===n?[]:["",n]),sa(n,b,!!o||t[++g]))}return void 0===n?null:n}function p6(n,t,o,l,p,g,b,C){if(!(3&t.type))return;const N=n.data,R=N[C+1];Q4(function Ks(n){return 1==(1&n)}(R)?m6(N,t,o,p,po(R),b):void 0)||(Q4(g)||function M8(n){return 2==(2&n)}(R)&&(g=m6(N,null,o,p,C,b)),function m8(n,t,o,l,p){const g=re(n);if(t)p?g?n.addClass(o,l):o.classList.add(l):g?n.removeClass(o,l):o.classList.remove(l);else{let b=-1===l.indexOf("-")?void 0:_e.DashCase;if(null==p)g?n.removeStyle(o,l,b):o.style.removeProperty(l);else{const C="string"==typeof p&&p.endsWith("!important");C&&(p=p.slice(0,-10),b|=_e.Important),g?n.setStyle(o,l,p,b):o.style.setProperty(l,p,C?"important":"")}}}(l,b,Dt(D1(),o),p,g))}function m6(n,t,o,l,p,g){const b=null===t;let C;for(;p>0;){const N=n[p],R=Array.isArray(N),B=R?N[1]:N,K=null===B;let ue=o[p+1];ue===At&&(ue=K?et:void 0);let Ce=K?cr(ue,l):B===l?ue:void 0;if(R&&!Q4(Ce)&&(Ce=cr(N,l)),Q4(Ce)&&(C=Ce,b))return C;const qe=n[p+1];p=b?w2(qe):po(qe)}if(null!==t){let N=g?t.residualClasses:t.residualStyles;null!=N&&(C=cr(N,l))}return C}function Q4(n){return void 0!==n}function h6(n,t){return 0!=(n.flags&(t?16:32))}function g6(n,t=""){const o=Ye(),l=Ct(),p=n+20,g=l.firstCreatePass?Pc(l,p,1,t,null):l.data[p],b=o[p]=ci(o[11],t);A3(l,o,b,g),gi(g,!1)}function bl(n){return J4("",n,""),bl}function J4(n,t,o){const l=Ye(),p=zs(l,n,t,o);return p!==At&&function ho(n,t,o){const l=Dt(t,n);F1(n[11],l,o)}(l,D1(),p),J4}function w6(n,t,o){D2(sa,W2,zs(Ye(),n,t,o),!0)}function z6(n,t,o,l,p){D2(sa,W2,function rc(n,t,o,l,p,g){const C=ws(n,Z(),o,p);return ve(2),C?t+cn(o)+l+cn(p)+g:At}(Ye(),n,t,o,l,p),!0)}function yl(n,t,o){const l=Ye();return Ra(l,ne(),t)&&u2(Ct(),It(),l,n,t,l[11],o,!0),yl}const ks=void 0;var hd=["en",[["a","p"],["AM","PM"],ks],[["AM","PM"],ks,ks],[["S","M","T","W","T","F","S"],["Sun","Mon","Tue","Wed","Thu","Fri","Sat"],["Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday"],["Su","Mo","Tu","We","Th","Fr","Sa"]],ks,[["J","F","M","A","M","J","J","A","S","O","N","D"],["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"],["January","February","March","April","May","June","July","August","September","October","November","December"]],ks,[["B","A"],["BC","AD"],["Before Christ","Anno Domini"]],0,[6,0],["M/d/yy","MMM d, y","MMMM d, y","EEEE, MMMM d, y"],["h:mm a","h:mm:ss a","h:mm:ss a z","h:mm:ss a zzzz"],["{1}, {0}",ks,"{1} 'at' {0}",ks],[".",",",";","%","+","-","E","\xd7","\u2030","\u221e","NaN",":"],["#,##0.###","#,##0%","\xa4#,##0.00","#E0"],"USD","$","US Dollar",{},"ltr",function md(n){const o=Math.floor(Math.abs(n)),l=n.toString().replace(/^[^.]*\.?/,"").length;return 1===o&&0===l?1:5}];let sc={};function _l(n){const t=function gd(n){return n.toLowerCase().replace(/_/g,"-")}(n);let o=V6(t);if(o)return o;const l=t.split("-")[0];if(o=V6(l),o)return o;if("en"===l)return hd;throw new Error(`Missing locale data for the locale "${n}".`)}function O6(n){return _l(n)[ct.PluralCase]}function V6(n){return n in sc||(sc[n]=gt.ng&&gt.ng.common&&gt.ng.common.locales&&gt.ng.common.locales[n]),sc[n]}var ct=(()=>((ct=ct||{})[ct.LocaleId=0]="LocaleId",ct[ct.DayPeriodsFormat=1]="DayPeriodsFormat",ct[ct.DayPeriodsStandalone=2]="DayPeriodsStandalone",ct[ct.DaysFormat=3]="DaysFormat",ct[ct.DaysStandalone=4]="DaysStandalone",ct[ct.MonthsFormat=5]="MonthsFormat",ct[ct.MonthsStandalone=6]="MonthsStandalone",ct[ct.Eras=7]="Eras",ct[ct.FirstDayOfWeek=8]="FirstDayOfWeek",ct[ct.WeekendRange=9]="WeekendRange",ct[ct.DateFormat=10]="DateFormat",ct[ct.TimeFormat=11]="TimeFormat",ct[ct.DateTimeFormat=12]="DateTimeFormat",ct[ct.NumberSymbols=13]="NumberSymbols",ct[ct.NumberFormats=14]="NumberFormats",ct[ct.CurrencyCode=15]="CurrencyCode",ct[ct.CurrencySymbol=16]="CurrencySymbol",ct[ct.CurrencyName=17]="CurrencyName",ct[ct.Currencies=18]="Currencies",ct[ct.Directionality=19]="Directionality",ct[ct.PluralCase=20]="PluralCase",ct[ct.ExtraData=21]="ExtraData",ct))();const vd=["zero","one","two","few","many"],K4="en-US",e3={marker:"element"},n3={marker:"ICU"};var Si=(()=>((Si=Si||{})[Si.SHIFT=2]="SHIFT",Si[Si.APPEND_EAGERLY=1]="APPEND_EAGERLY",Si[Si.COMMENT=2]="COMMENT",Si))();let H6=K4;function R6(n,t,o){const l=t.insertBeforeIndex,p=Array.isArray(l)?l[0]:l;return null===p?c8(n,0,o):nn(o[p])}function F6(n,t,o,l,p){const g=t.insertBeforeIndex;if(Array.isArray(g)){let b=l,C=null;if(3&t.type||(C=b,b=p),null!==b&&0==(2&t.flags))for(let N=1;N<g.length;N++)ur(n,b,o[g[N]],C,!1)}}function q6(n,t){if(n.push(t),n.length>1)for(let o=n.length-2;o>=0;o--){const l=n[o];B6(l)||Cd(l,t)&&null===Sd(l)&&L7(l,t.index)}}function B6(n){return!(64&n.type)}function Cd(n,t){return B6(t)||n.index>t.index}function Sd(n){const t=n.insertBeforeIndex;return Array.isArray(t)?t[0]:t}function L7(n,t){const o=n.insertBeforeIndex;Array.isArray(o)?o[0]=t:(Vl(R6,F6),n.insertBeforeIndex=t)}function xl(n,t){const o=n.data[t];return null===o||"string"==typeof o?null:o.hasOwnProperty("currentCaseLViewIndex")?o:o.value}function Wf(n,t,o){const l=q3(n,o,64,null,null);return q6(t,l),l}function U6(n,t){const o=t[n.currentCaseLViewIndex];return null===o?o:o<0?~o:o}function T7(n){return n>>>17}function j7(n){return(131070&n)>>>1}let Pi=0,cc=0;function Zf(n,t,o,l){const p=o[11];let b,g=null;for(let C=0;C<t.length;C++){const N=t[C];if("string"==typeof N){const R=t[++C];null===o[R]&&(o[R]=ci(p,N))}else if("number"==typeof N)switch(1&N){case 0:const R=T7(N);let B,K;if(null===g&&(g=R,b=Fo(p,l)),R===g?(B=l,K=b):(B=null,K=nn(o[R])),null!==K){const vn=j7(N);ur(p,K,o[vn],B,!1);const Fn=xl(n,vn);if(null!==Fn&&"object"==typeof Fn){const en=U6(Fn,o);null!==en&&Zf(n,Fn.create[en],o,o[Fn.anchorIdx])}}break;case 1:const Ce=t[++C],qe=t[++C];G3(p,Dt(N>>>1,o),null,null,Ce,qe,null)}else switch(N){case n3:const R=t[++C],B=t[++C];null===o[B]&&jt(o[B]=nr(p,R),o);break;case e3:const K=t[++C],ue=t[++C];null===o[ue]&&jt(o[ue]=la(p,K,null),o)}}}function $f(n,t,o,l,p){for(let g=0;g<o.length;g++){const b=o[g],C=o[++g];if(b&p){let N="";for(let R=g+1;R<=g+C;R++){const B=o[R];if("string"==typeof B)N+=B;else if("number"==typeof B)if(B<0)N+=cn(t[l-B]);else{const K=B>>>2;switch(3&B){case 1:const ue=o[++R],Ce=o[++R],qe=n.data[K];"string"==typeof qe?G3(t[11],t[K],null,qe,ue,N,Ce):u2(n,qe,t,ue,N,t[11],Ce,!1);break;case 0:const vn=t[K];null!==vn&&F1(t[11],vn,N);break;case 2:Ah(n,xl(n,K),t,N);break;case 3:Xf(n,xl(n,K),l,t)}}}}else{const N=o[g+1];if(N>0&&3==(3&N)){const B=xl(n,N>>>2);t[B.currentCaseLViewIndex]<0&&Xf(n,B,l,t)}}g+=C}}function Xf(n,t,o,l){let p=l[t.currentCaseLViewIndex];if(null!==p){let g=Pi;p<0&&(p=l[t.currentCaseLViewIndex]=~p,g=-1),$f(n,l,t.update[p],o,g)}}function Ah(n,t,o,l){const p=function Lh(n,t){let o=n.cases.indexOf(t);if(-1===o)switch(n.type){case 1:{const l=function bd(n,t){const o=O6(t)(parseInt(n,10)),l=vd[o];return void 0!==l?l:"other"}(t,function xd(){return H6}());o=n.cases.indexOf(l),-1===o&&"other"!==l&&(o=n.cases.indexOf("other"));break}case 0:o=n.cases.indexOf("other")}return-1===o?null:o}(t,l);if(U6(t,o)!==p&&(I7(n,t,o),o[t.currentCaseLViewIndex]=null===p?null:~p,null!==p)){const b=o[t.anchorIdx];b&&Zf(n,t.create[p],o,b)}}function I7(n,t,o){let l=U6(t,o);if(null!==l){const p=t.remove[l];for(let g=0;g<p.length;g++){const b=p[g];if(b>0){const C=Dt(b,o);null!==C&&u8(o[11],C)}else I7(n,xl(n,~b),o)}}}function O7(){const n=[];let o,l,t=-1;function g(C,N){t=0;const R=U6(C,N);l=null!==R?C.remove[R]:et}function b(){if(t<l.length){const C=l[t++];return C>0?o[C]:(n.push(t,l),g(o[1].data[~C],o),b())}return 0===n.length?null:(l=n.pop(),t=n.pop(),b())}return function p(C,N){for(o=N;n.length;)n.pop();return g(C.value,N),b}}const wd=/\ufffd(\d+):?\d*\ufffd/gi,jh=/\ufffd(\d+)\ufffd/,Jf=/^\s*(\ufffd\d+:?\d*\ufffd)\s*,\s*(select|plural)\s*,/,kh=/\ufffd\/?\*(\d+:\d+)\ufffd/gi,Kf=/\ufffd(\/?[#*]\d+):?\d*\ufffd/gi,Ph=/\uE500/g;function ep(n,t,o,l,p,g,b){const C=Ic(n,l,1,null);let N=C<<Si.SHIFT,R=gr();t===R&&(R=null),null===R&&(N|=Si.APPEND_EAGERLY),b&&(N|=Si.COMMENT,function Ge(n){void 0===be&&(be=n())}(O7)),p.push(N,null===g?"":g);const B=q3(n,C,b?32:1,null===g?"":g,null);q6(o,B);const K=B.index;return gi(B,!1),null!==R&&t!==R&&function Gf(n,t){let o=n.insertBeforeIndex;null===o?(Vl(R6,F6),o=n.insertBeforeIndex=[null,t]):(function De(n,t,o){n!=t&&st(o,n,t,"==")}(Array.isArray(o),!0,"Expecting array here"),o.push(t))}(R,K),B}function np(n,t,o,l,p,g,b){const C=b.match(wd),N=ep(n,t,o,g,l,C?null:b,!1);C&&t3(p,b,N.index,null,0,null)}function t3(n,t,o,l,p,g){const b=n.length,C=b+1;n.push(null,null);const N=b+2,R=t.split(wd);let B=0;for(let K=0;K<R.length;K++){const ue=R[K];if(1&K){const Ce=p+parseInt(ue,10);n.push(-1-Ce),B|=H7(Ce)}else""!==ue&&n.push(ue)}return n.push(o<<2|(l?1:0)),l&&n.push(l,g),n[b]=B,n[C]=n.length-N,B}function H7(n){return 1<<Math.min(n,31)}function R7(n){let t,g,o="",l=0,p=!1;for(;null!==(t=kh.exec(n));)p?t[0]===`\ufffd/*${g}\ufffd`&&(l=t.index,p=!1):(o+=n.substring(l,t.index+t[0].length),g=t[1],p=!0);return o+=n.substr(l),o}function F7(n,t,o,l,p,g){let b=0;const C={type:p.type,currentCaseLViewIndex:Ic(n,t,1,null),anchorIdx:g,cases:[],create:[],remove:[],update:[]};(function cp(n,t,o){n.push(H7(t.mainBinding),2,-1-t.mainBinding,o<<2|2)})(o,p,g),function Uf(n,t,o){const l=n.data[t];null===l?n.data[t]=o:l.value=o}(n,g,C);const N=p.values;for(let R=0;R<N.length;R++){const B=N[R],K=[];for(let ue=0;ue<B.length;ue++){const Ce=B[ue];if("string"!=typeof Ce){const qe=K.push(Ce)-1;B[ue]=`\x3c!--\ufffd${qe}\ufffd--\x3e`}}b=op(n,C,t,o,l,p.cases[R],B.join(""),K)|b}b&&function lp(n,t,o){n.push(t,1,o<<2|3)}(o,b,g)}function rp(n){const t=[],o=[];let l=1,p=0;const g=zd(n=n.replace(Jf,function(b,C,N){return l="select"===N?0:1,p=parseInt(C.substr(1),10),""}));for(let b=0;b<g.length;){let C=g[b++].trim();1===l&&(C=C.replace(/\s*(?:=)?(\w+)\s*/,"$1")),C.length&&t.push(C);const N=zd(g[b++]);t.length>o.length&&o.push(N)}return{type:l,mainBinding:p,cases:t,values:o}}function zd(n){if(!n)return[];let t=0;const o=[],l=[],p=/[{}]/g;let g;for(p.lastIndex=0;g=p.exec(n);){const C=g.index;if("}"==g[0]){if(o.pop(),0==o.length){const N=n.substring(t,C);Jf.test(N)?l.push(rp(N)):l.push(N),t=C+1}}else{if(0==o.length){const N=n.substring(t,C);l.push(N),t=C+1}o.push("{")}}const b=n.substring(t);return l.push(b),l}function op(n,t,o,l,p,g,b,C){const N=[],R=[],B=[];t.cases.push(g),t.create.push(N),t.remove.push(R),t.update.push(B);const ue=ps(k()).getInertBodyElement(b),Ce=hs(ue)||ue;return Ce?q7(n,t,o,l,N,R,B,Ce,p,C,0):0}function q7(n,t,o,l,p,g,b,C,N,R,B){let K=0,ue=C.firstChild;for(;ue;){const Ce=Ic(n,o,1,null);switch(ue.nodeType){case Node.ELEMENT_NODE:const qe=ue,vn=qe.tagName.toLowerCase();if(Zs.hasOwnProperty(vn)){Nd(p,e3,vn,N,Ce),n.data[Ce]=vn;const at=qe.attributes;for(let i1=0;i1<at.length;i1++){const T1=at.item(i1),E2=T1.name.toLowerCase();T1.value.match(wd)?d4.hasOwnProperty(E2)&&t3(b,T1.value,Ce,T1.name,0,$s[E2]?co:wc[E2]?c4:null):dp(p,Ce,T1)}K=q7(n,t,o,l,p,g,b,ue,Ce,R,B+1)|K,B7(g,Ce,B)}break;case Node.TEXT_NODE:const zn=ue.textContent||"",Fn=zn.match(wd);Nd(p,null,Fn?"":zn,N,Ce),B7(g,Ce,B),Fn&&(K=t3(b,zn,Ce,null,0,null)|K);break;case Node.COMMENT_NODE:const en=jh.exec(ue.textContent||"");if(en){const i1=R[parseInt(en[1],10)];Nd(p,n3,"",N,Ce),F7(n,o,l,N,i1,Ce),sp(g,Ce,B)}}ue=ue.nextSibling}return K}function B7(n,t,o){0===o&&n.push(t)}function sp(n,t,o){0===o&&(n.push(~t),n.push(t))}function Nd(n,t,o,l,p){null!==t&&n.push(t),n.push(o,p,function Dh(n,t,o){return n|t<<17|o<<1}(0,l,p))}function dp(n,t,o){n.push(t<<1|1,o.name,o.value)}function G7(n,t,o=-1){const l=Ct(),p=Ye(),g=20+n,b=D(l.consts,t),C=gr();l.firstCreatePass&&function Oh(n,t,o,l,p,g){const b=gr(),C=[],N=[],R=[[]];p=function ap(n,t){if(function ip(n){return-1===n}(t))return R7(n);{const o=n.indexOf(`:${t}\ufffd`)+2+t.toString().length,l=n.search(new RegExp(`\ufffd\\/\\*\\d+:${t}\ufffd`));return R7(n.substring(o,l))}}(p,g);const B=function Ih(n){return n.replace(Ph," ")}(p).split(Kf);for(let K=0;K<B.length;K++){let ue=B[K];if(0==(1&K)){const Ce=zd(ue);for(let qe=0;qe<Ce.length;qe++){let vn=Ce[qe];if(0==(1&qe)){const zn=vn;""!==zn&&np(n,b,R[0],C,N,o,zn)}else{const zn=vn;if("object"!=typeof zn)throw new Error(`Unable to parse ICU expression in "${p}" message.`);F7(n,o,N,t,zn,ep(n,b,R[0],o,C,"",!0).index)}}}else{const Ce=47===ue.charCodeAt(0),vn=(ue.charCodeAt(Ce?1:0),20+Number.parseInt(ue.substring(Ce?2:1)));if(Ce)R.shift(),gi(gr(),!1);else{const zn=Wf(n,R[0],vn);R.unshift([]),gi(zn,!0)}}}n.data[l]={create:C,update:N}}(l,null===C?0:C.index,p,g,b,o);const N=l.data[g],B=d2(l,C===p[6]?null:C,p);(function P7(n,t,o,l){const p=n[11];for(let g=0;g<t.length;g++){const b=t[g++],C=t[g],N=(b&Si.COMMENT)===Si.COMMENT,R=(b&Si.APPEND_EAGERLY)===Si.APPEND_EAGERLY,B=b>>>Si.SHIFT;let K=n[B];null===K&&(K=n[B]=N?p.createComment(C):ci(p,C)),R&&null!==o&&ur(p,o,K,l,!1)}})(p,N.create,B,C&&8&C.type?p[C.index]:null),Fe(!0)}function yp(n,t,o){G7(n,t,o),function W7(){Fe(!1)}()}function Dd(n){return function Md(n){n&&(Pi|=1<<Math.min(cc,31)),cc++}(Ra(Ye(),ne(),n)),Dd}function Z7(n){!function Eh(n,t,o){if(cc>0){const l=n.data[o];$f(n,t,Array.isArray(l)?l:l.update,Z()-cc-1,Pi)}Pi=0,cc=0}(Ct(),Ye(),n+20)}function Ed(n,t,o,l,p){if(n=Qe(n),Array.isArray(n))for(let g=0;g<n.length;g++)Ed(n[g],t,o,l,p);else{const g=Ct(),b=Ye();let C=tc(n)?n:Qe(n.provide),N=nc(n);const R=b1(),B=1048575&R.providerIndexes,K=R.directiveStart,ue=R.providerIndexes>>20;if(tc(n)||!n.multi){const Ce=new Ir(N,p,Bc),qe=Ld(C,t,p?B:B+ue,K);-1===qe?(es(_r(R,b),g,C),Ad(g,n,t.length),t.push(C),R.directiveStart++,R.directiveEnd++,p&&(R.providerIndexes+=1048576),o.push(Ce),b.push(Ce)):(o[qe]=Ce,b[qe]=Ce)}else{const Ce=Ld(C,t,B+ue,K),qe=Ld(C,t,B,B+ue),vn=Ce>=0&&o[Ce],zn=qe>=0&&o[qe];if(p&&!zn||!p&&!vn){es(_r(R,b),g,C);const Fn=function wp(n,t,o,l,p){const g=new Ir(n,o,Bc);return g.multi=[],g.index=t,g.componentProviders=0,$7(g,p,l&&!o),g}(p?Mp:Sp,o.length,p,l,N);!p&&zn&&(o[qe].providerFactory=Fn),Ad(g,n,t.length,0),t.push(C),R.directiveStart++,R.directiveEnd++,p&&(R.providerIndexes+=1048576),o.push(Fn),b.push(Fn)}else Ad(g,n,Ce>-1?Ce:qe,$7(o[p?qe:Ce],N,!p&&l));!p&&l&&zn&&o[qe].componentProviders++}}}function Ad(n,t,o,l){const p=tc(t),g=function r5(n){return!!n.useClass}(t);if(p||g){const N=(g?Qe(t.useClass):t).prototype.ngOnDestroy;if(N){const R=n.destroyHooks||(n.destroyHooks=[]);if(!p&&t.multi){const B=R.indexOf(o);-1===B?R.push(o,[l,N]):R[B+1].push(l,N)}else R.push(o,N)}}}function $7(n,t,o){return o&&n.componentProviders++,n.multi.push(t)-1}function Ld(n,t,o,l){for(let p=o;p<l;p++)if(t[p]===n)return p;return-1}function Sp(n,t,o,l){return Td(this.multi,[])}function Mp(n,t,o,l){const p=this.multi;let g;if(this.providerFactory){const b=this.providerFactory.componentProviders,C=Ie(o,o[1],this.providerFactory.index,l);g=C.slice(0,b),Td(p,g);for(let N=b;N<C.length;N++)g.push(C[N])}else g=[],Td(p,g);return g}function Td(n,t){for(let o=0;o<n.length;o++)t.push((0,n[o])());return t}function X7(n,t=[]){return o=>{o.providersResolver=(l,p)=>function Cp(n,t,o){const l=Ct();if(l.firstCreatePass){const p=K1(n);Ed(o,l.data,l.blueprint,p,!0),Ed(t,l.data,l.blueprint,p,!1)}}(l,p?p(n):n,t)}}class Y7{}class Dp{resolveComponentFactory(t){throw function Np(n){const t=Error(`No component factory found for ${Ae(n)}. Did you add it to @NgModule.entryComponents?`);return t.ngComponent=n,t}(t)}}let Z6=(()=>{class n{}return n.NULL=new Dp,n})();function Ep(){return a3(b1(),Ye())}function a3(n,t){return new Cl(kn(n,t))}let Cl=(()=>{class n{constructor(o){this.nativeElement=o}}return n.__NG_ELEMENT_ID__=Ep,n})();function Ap(n){return n instanceof Cl?n.nativeElement:n}class J7{}let Lp=(()=>{class n{}return n.__NG_ELEMENT_ID__=()=>function jp(){const n=Ye(),o=V1(b1().index,n);return function Tp(n){return n[11]}(u1(o)?o:n)}(),n})(),kp=(()=>{class n{}return n.\u0275prov=Ut({token:n,providedIn:"root",factory:()=>null}),n})();class K7{constructor(t){this.full=t,this.major=t.split(".")[0],this.minor=t.split(".")[1],this.patch=t.split(".").slice(2).join(".")}}const Pp=new K7("13.2.5"),jd={};function $6(n,t,o,l,p=!1){for(;null!==o;){const g=t[o.index];if(null!==g&&l.push(nn(g)),I1(g))for(let C=10;C<g.length;C++){const N=g[C],R=N[1].firstChild;null!==R&&$6(N[1],N,R,l)}const b=o.type;if(8&b)$6(n,t,o.child,l);else if(32&b){const C=Te(o,t);let N;for(;N=C();)l.push(N)}else if(16&b){const C=d8(t,o);if(Array.isArray(C))l.push(...C);else{const N=pn(t[16]);$6(N[1],N,C,l,!0)}}o=p?o.projectionNext:o.next}return l}class Sl{constructor(t,o){this._lView=t,this._cdRefInjectingView=o,this._appRef=null,this._attachedToViewContainer=!1}get rootNodes(){const t=this._lView,o=t[1];return $6(o,t,o.firstChild,[])}get context(){return this._lView[8]}set context(t){this._lView[8]=t}get destroyed(){return 256==(256&this._lView[2])}destroy(){if(this._appRef)this._appRef.detachView(this);else if(this._attachedToViewContainer){const t=this._lView[3];if(I1(t)){const o=t[8],l=o?o.indexOf(this):-1;l>-1&&(R2(t,l),qr(o,l))}this._attachedToViewContainer=!1}$r(this._lView[1],this._lView)}onDestroy(t){V8(this._lView[1],this._lView,null,t)}markForCheck(){X3(this._cdRefInjectingView||this._lView)}detach(){this._lView[2]&=-129}reattach(){this._lView[2]|=128}detectChanges(){p0(this._lView[1],this._lView,this.context)}checkNoChanges(){!function Gu(n,t,o){g2(!0);try{p0(n,t,o)}finally{g2(!1)}}(this._lView[1],this._lView,this.context)}attachToViewContainerRef(){if(this._appRef)throw new yn(902,"");this._attachedToViewContainer=!0}detachFromAppRef(){this._appRef=null,function Wi(n,t){jc(n,t,t[11],2,null,null)}(this._lView[1],this._lView)}attachToAppRef(t){if(this._attachedToViewContainer)throw new yn(902,"");this._appRef=t}}class Ip extends Sl{constructor(t){super(t),this._view=t}detectChanges(){Y8(this._view)}checkNoChanges(){!function Wu(n){g2(!0);try{Y8(n)}finally{g2(!1)}}(this._view)}get context(){return null}}class e9 extends Z6{constructor(t){super(),this.ngModule=t}resolveComponentFactory(t){const o=Sn(t);return new kd(o,this.ngModule)}}function n9(n){const t=[];for(let o in n)n.hasOwnProperty(o)&&t.push({propName:n[o],templateName:o});return t}class kd extends Y7{constructor(t,o){super(),this.componentDef=t,this.ngModule=o,this.componentType=t.type,this.selector=function xs(n){return n.map(T3).join(",")}(t.selectors),this.ngContentSelectors=t.ngContentSelectors?t.ngContentSelectors:[],this.isBoundToModule=!!o}get inputs(){return n9(this.componentDef.inputs)}get outputs(){return n9(this.componentDef.outputs)}create(t,o,l,p){const g=(p=p||this.ngModule)?function Vp(n,t){return{get:(o,l,p)=>{const g=n.get(o,jd,p);return g!==jd||l===jd?g:t.get(o,l,p)}}}(t,p.injector):t,b=g.get(J7,ke),C=g.get(kp,null),N=b.createRenderer(null,this.componentDef),R=this.componentDef.selectors[0][0]||"div",B=l?function O8(n,t,o){if(re(n))return n.selectRootElement(t,o===Nt.ShadowDom);let l="string"==typeof t?n.querySelector(t):t;return l.textContent="",l}(N,l,this.componentDef.encapsulation):la(b.createRenderer(null,this.componentDef),R,function Op(n){const t=n.toLowerCase();return"svg"===t?"svg":"math"===t?"math":null}(R)),K=this.componentDef.onPush?576:528,ue=function ac(n,t){return{components:[],scheduler:n||f,clean:Zu,playerHandler:t||null,flags:0}}(),Ce=k4(0,null,null,1,0,null,null,null,null,null),qe=T4(null,Ce,ue,K,null,null,b,N,C,g);let vn,zn;Y1(qe);try{const Fn=function Rc(n,t,o,l,p,g){const b=o[1];o[20]=n;const N=Pc(b,20,2,"#host",null),R=N.mergedAttrs=t.hostAttrs;null!==R&&(Y3(N,R,!0),null!==n&&(Or(p,n,R),null!==N.classes&&ql(p,n,N.classes),null!==N.styles&&Fl(p,n,N.styles)));const B=l.createRenderer(n,t),K=T4(o,P8(t),null,t.onPush?64:16,o[20],N,l,B,g||null,null);return b.firstCreatePass&&(es(_r(N,o),b,t.type),o0(b,N),s0(N,o.length,1)),$3(o,K),o[20]=K}(B,this.componentDef,qe,b,N);if(B)if(l)Or(N,B,["ng-version",Pp.full]);else{const{attrs:en,classes:at}=function x8(n){const t=[],o=[];let l=1,p=2;for(;l<n.length;){let g=n[l];if("string"==typeof g)2===p?""!==g&&t.push(g,n[++l]):8===p&&o.push(g);else{if(!M2(p))break;p=g}l++}return{attrs:t,classes:o}}(this.componentDef.selectors[0]);en&&Or(N,B,en),at&&at.length>0&&ql(N,B,at.join(" "))}if(zn=Jn(Ce,20),void 0!==o){const en=zn.projection=[];for(let at=0;at<this.ngContentSelectors.length;at++){const i1=o[at];en.push(null!=i1?Array.from(i1):null)}}vn=function il(n,t,o,l,p){const g=o[1],b=function Ru(n,t,o){const l=b1();n.firstCreatePass&&(o.providersResolver&&o.providersResolver(o),c0(n,l,t,Ic(n,t,1,null),o));const p=Ie(t,n,l.directiveStart,l);jt(p,t);const g=kn(l,t);return g&&jt(g,t),p}(g,o,t);if(l.components.push(b),n[8]=b,p&&p.forEach(N=>N(b,t)),t.contentQueries){const N=b1();t.contentQueries(1,b,N.directiveStart)}const C=b1();return!g.firstCreatePass||null===t.hostBindings&&null===t.hostAttrs||(bi(C.index),B3(o[1],C,0,C.directiveStart,C.directiveEnd,t),U3(t,b)),b}(Fn,this.componentDef,qe,ue,[r7]),j4(Ce,qe,null)}finally{aa()}return new Rp(this.componentType,vn,a3(zn,qe),qe,zn)}}class Rp extends class zp{}{constructor(t,o,l,p,g){super(),this.location=l,this._rootLView=p,this._tNode=g,this.instance=o,this.hostView=this.changeDetectorRef=new Ip(p),this.componentType=t}get injector(){return new Kn(this._tNode,this._rootLView)}destroy(){this.hostView.destroy()}onDestroy(t){this.hostView.onDestroy(t)}}class r3{}class t9{}const o3=new Map;class r9 extends r3{constructor(t,o){super(),this._parent=o,this._bootstrapComponents=[],this.injector=this,this.destroyCbs=[],this.componentFactoryResolver=new e9(this);const l=$t(t);this._bootstrapComponents=E(l.bootstrap),this._r3Injector=V4(t,o,[{provide:r3,useValue:this},{provide:Z6,useValue:this.componentFactoryResolver}],Ae(t)),this._r3Injector._resolveInjectorDefTypes(),this.instance=this.get(t)}get(t,o=Dr.THROW_IF_NOT_FOUND,l=$n.Default){return t===Dr||t===r3||t===h0?this:this._r3Injector.get(t,o,l)}destroy(){const t=this._r3Injector;!t.destroyed&&t.destroy(),this.destroyCbs.forEach(o=>o()),this.destroyCbs=null}onDestroy(t){this.destroyCbs.push(t)}}class Pd extends t9{constructor(t){super(),this.moduleType=t,null!==$t(t)&&function qp(n){const t=new Set;!function o(l){const p=$t(l,!0),g=p.id;null!==g&&(function i9(n,t,o){if(t&&t!==o)throw new Error(`Duplicate module registered for ${n} - ${Ae(t)} vs ${Ae(t.name)}`)}(g,o3.get(g),l),o3.set(g,l));const b=E(p.imports);for(const C of b)t.has(C)||(t.add(C),o(C))}(n)}(t)}create(t){return new r9(this.moduleType,t)}}function o9(n,t,o){const l=O()+n,p=Ye();return p[l]===At?p2(p,l,o?t.call(o):t()):function Ms(n,t){return n[t]}(p,l)}function s9(n,t,o,l){return function d9(n,t,o,l,p,g){const b=t+o;return Ra(n,b,p)?p2(n,b+1,g?l.call(g,p):l(p)):Ml(n,b+1)}(Ye(),O(),n,t,o,l)}function c9(n,t,o,l,p){return function u9(n,t,o,l,p,g,b){const C=t+o;return ws(n,C,p,g)?p2(n,C+2,b?l.call(b,p,g):l(p,g)):Ml(n,C+2)}(Ye(),O(),n,t,o,l,p)}function l9(n,t,o,l,p,g){return function f9(n,t,o,l,p,g,b,C){const N=t+o;return function B4(n,t,o,l,p){const g=ws(n,t,o,l);return Ra(n,t+2,p)||g}(n,N,p,g,b)?p2(n,N+3,C?l.call(C,p,g,b):l(p,g,b)):Ml(n,N+3)}(Ye(),O(),n,t,o,l,p,g)}function Ml(n,t){const o=n[t];return o===At?void 0:o}function Id(n){return t=>{setTimeout(n,void 0,t)}}const $o=class tm extends M.xQ{constructor(t=!1){super(),this.__isAsync=t}emit(t){super.next(t)}subscribe(t,o,l){var p,g,b;let C=t,N=o||(()=>null),R=l;if(t&&"object"==typeof t){const K=t;C=null===(p=K.next)||void 0===p?void 0:p.bind(K),N=null===(g=K.error)||void 0===g?void 0:g.bind(K),R=null===(b=K.complete)||void 0===b?void 0:b.bind(K)}this.__isAsync&&(N=Id(N),C&&(C=Id(C)),R&&(R=Id(R)));const B=super.subscribe({next:C,error:N,complete:R});return t instanceof d.w&&t.add(B),B}};function im(){return this._results[vo()]()}class Od{constructor(t=!1){this._emitDistinctChangesOnly=t,this.dirty=!0,this._results=[],this._changesDetected=!1,this._changes=null,this.length=0,this.first=void 0,this.last=void 0;const o=vo(),l=Od.prototype;l[o]||(l[o]=im)}get changes(){return this._changes||(this._changes=new $o)}get(t){return this._results[t]}map(t){return this._results.map(t)}filter(t){return this._results.filter(t)}find(t){return this._results.find(t)}reduce(t,o){return this._results.reduce(t,o)}forEach(t){this._results.forEach(t)}some(t){return this._results.some(t)}toArray(){return this._results.slice()}toString(){return this._results.toString()}reset(t,o){const l=this;l.dirty=!1;const p=St(t);(this._changesDetected=!function xa(n,t,o){if(n.length!==t.length)return!1;for(let l=0;l<n.length;l++){let p=n[l],g=t[l];if(o&&(p=o(p),g=o(g)),g!==p)return!1}return!0}(l._results,p,o))&&(l._results=p,l.length=p.length,l.last=p[this.length-1],l.first=p[0])}notifyOnChanges(){this._changes&&(this._changesDetected||!this._emitDistinctChangesOnly)&&this._changes.emit(this)}setDirty(){this.dirty=!0}destroy(){this.changes.complete(),this.changes.unsubscribe()}}Symbol;let zl=(()=>{class n{}return n.__NG_ELEMENT_ID__=om,n})();const am=zl,rm=class extends am{constructor(t,o,l){super(),this._declarationLView=t,this._declarationTContainer=o,this.elementRef=l}createEmbeddedView(t){const o=this._declarationTContainer.tViews,l=T4(this._declarationLView,o,t,16,null,o.declTNode,null,null,null,null);l[17]=this._declarationLView[this._declarationTContainer.index];const g=this._declarationLView[19];return null!==g&&(l[19]=g.createEmbeddedView(o)),j4(o,l,t),new Sl(l)}};function om(){return X6(b1(),Ye())}function X6(n,t){return 4&n.type?new rm(t,n,a3(n,t)):null}let Y6=(()=>{class n{}return n.__NG_ELEMENT_ID__=sm,n})();function sm(){return v9(b1(),Ye())}const cm=Y6,h9=class extends cm{constructor(t,o,l){super(),this._lContainer=t,this._hostTNode=o,this._hostLView=l}get element(){return a3(this._hostTNode,this._hostLView)}get injector(){return new Kn(this._hostTNode,this._hostLView)}get parentInjector(){const t=Rr(this._hostTNode,this._hostLView);if(dc(t)){const o=yr(t,this._hostLView),l=v2(t);return new Kn(o[1].data[l+8],o)}return new Kn(null,this._hostLView)}clear(){for(;this.length>0;)this.remove(this.length-1)}get(t){const o=g9(this._lContainer);return null!==o&&o[t]||null}get length(){return this._lContainer.length-10}createEmbeddedView(t,o,l){const p=t.createEmbeddedView(o||{});return this.insert(p,l),p}createComponent(t,o,l,p,g){const b=t&&!function I2(n){return"function"==typeof n}(t);let C;if(b)C=o;else{const K=o||{};C=K.index,l=K.injector,p=K.projectableNodes,g=K.ngModuleRef}const N=b?t:new kd(Sn(t)),R=l||this.parentInjector;if(!g&&null==N.ngModule){const ue=(b?R:this.parentInjector).get(r3,null);ue&&(g=ue)}const B=N.create(R,p,void 0,g);return this.insert(B.hostView,C),B}insert(t,o){const l=t._lView,p=l[1];if(function L(n){return I1(n[3])}(l)){const B=this.indexOf(t);if(-1!==B)this.detach(B);else{const K=l[3],ue=new h9(K,K[6],K[3]);ue.detach(ue.indexOf(t))}}const g=this._adjustIndex(o),b=this._lContainer;!function di(n,t,o,l){const p=10+l,g=o.length;l>0&&(o[p-1][4]=t),l<g-10?(t[4]=o[p],x2(o,10+l,t)):(o.push(t),t[4]=null),t[3]=o;const b=t[17];null!==b&&o!==b&&function Q1(n,t){const o=n[9];t[16]!==t[3][3][16]&&(n[2]=!0),null===o?n[9]=[t]:o.push(t)}(b,t);const C=t[19];null!==C&&C.insertView(n),t[2]|=128}(p,l,b,g);const C=Hl(g,b),N=l[11],R=Fo(N,b[7]);return null!==R&&function Ha(n,t,o,l,p,g){l[0]=p,l[6]=t,jc(n,l,o,1,p,g)}(p,b[6],N,l,R,C),t.attachToViewContainerRef(),x2(Vd(b),g,t),t}move(t,o){return this.insert(t,o)}indexOf(t){const o=g9(this._lContainer);return null!==o?o.indexOf(t):-1}remove(t){const o=this._adjustIndex(t,-1),l=R2(this._lContainer,o);l&&(qr(Vd(this._lContainer),o),$r(l[1],l))}detach(t){const o=this._adjustIndex(t,-1),l=R2(this._lContainer,o);return l&&null!=qr(Vd(this._lContainer),o)?new Sl(l):null}_adjustIndex(t,o=0){return null==t?this.length+o:t}};function g9(n){return n[8]}function Vd(n){return n[8]||(n[8]=[])}function v9(n,t){let o;const l=t[n.index];if(I1(l))o=l;else{let p;if(8&n.type)p=nn(l);else{const g=t[11];p=g.createComment("");const b=kn(n,t);ur(g,Fo(g,b),p,function s8(n,t){return re(n)?n.nextSibling(t):t.nextSibling}(g,b),!1)}t[n.index]=o=d0(l,t,p,n),$3(t,o)}return new h9(o,n,t)}class Hd{constructor(t){this.queryList=t,this.matches=null}clone(){return new Hd(this.queryList)}setDirty(){this.queryList.setDirty()}}class Rd{constructor(t=[]){this.queries=t}createEmbeddedView(t){const o=t.queries;if(null!==o){const l=null!==t.contentQueries?t.contentQueries[0]:o.length,p=[];for(let g=0;g<l;g++){const b=o.getByIndex(g);p.push(this.queries[b.indexInDeclarationView].clone())}return new Rd(p)}return null}insertView(t){this.dirtyQueriesWithMatches(t)}detachView(t){this.dirtyQueriesWithMatches(t)}dirtyQueriesWithMatches(t){for(let o=0;o<this.queries.length;o++)null!==N9(t,o).matches&&this.queries[o].setDirty()}}class b9{constructor(t,o,l=null){this.predicate=t,this.flags=o,this.read=l}}class Fd{constructor(t=[]){this.queries=t}elementStart(t,o){for(let l=0;l<this.queries.length;l++)this.queries[l].elementStart(t,o)}elementEnd(t){for(let o=0;o<this.queries.length;o++)this.queries[o].elementEnd(t)}embeddedTView(t){let o=null;for(let l=0;l<this.length;l++){const p=null!==o?o.length:0,g=this.getByIndex(l).embeddedTView(t,p);g&&(g.indexInDeclarationView=l,null!==o?o.push(g):o=[g])}return null!==o?new Fd(o):null}template(t,o){for(let l=0;l<this.queries.length;l++)this.queries[l].template(t,o)}getByIndex(t){return this.queries[t]}get length(){return this.queries.length}track(t){this.queries.push(t)}}class qd{constructor(t,o=-1){this.metadata=t,this.matches=null,this.indexInDeclarationView=-1,this.crossesNgTemplate=!1,this._appliesToNextNode=!0,this._declarationNodeIndex=o}elementStart(t,o){this.isApplyingToNode(o)&&this.matchTNode(t,o)}elementEnd(t){this._declarationNodeIndex===t.index&&(this._appliesToNextNode=!1)}template(t,o){this.elementStart(t,o)}embeddedTView(t,o){return this.isApplyingToNode(t)?(this.crossesNgTemplate=!0,this.addMatch(-t.index,o),new qd(this.metadata)):null}isApplyingToNode(t){if(this._appliesToNextNode&&1!=(1&this.metadata.flags)){const o=this._declarationNodeIndex;let l=t.parent;for(;null!==l&&8&l.type&&l.index!==o;)l=l.parent;return o===(null!==l?l.index:-1)}return this._appliesToNextNode}matchTNode(t,o){const l=this.metadata.predicate;if(Array.isArray(l))for(let p=0;p<l.length;p++){const g=l[p];this.matchTNodeWithReadOption(t,o,um(o,g)),this.matchTNodeWithReadOption(t,o,se(o,t,g,!1,!1))}else l===zl?4&o.type&&this.matchTNodeWithReadOption(t,o,-1):this.matchTNodeWithReadOption(t,o,se(o,t,l,!1,!1))}matchTNodeWithReadOption(t,o,l){if(null!==l){const p=this.metadata.read;if(null!==p)if(p===Cl||p===Y6||p===zl&&4&o.type)this.addMatch(o.index,-2);else{const g=se(o,t,p,!1,!1);null!==g&&this.addMatch(o.index,g)}else this.addMatch(o.index,l)}}addMatch(t,o){null===this.matches?this.matches=[t,o]:this.matches.push(t,o)}}function um(n,t){const o=n.localNames;if(null!==o)for(let l=0;l<o.length;l+=2)if(o[l]===t)return o[l+1];return null}function y9(n,t,o,l){return-1===o?function fm(n,t){return 11&n.type?a3(n,t):4&n.type?X6(n,t):null}(t,n):-2===o?function pm(n,t,o){return o===Cl?a3(t,n):o===zl?X6(t,n):o===Y6?v9(t,n):void 0}(n,t,l):Ie(n,n[1],o,t)}function _9(n,t,o,l){const p=t[19].queries[l];if(null===p.matches){const g=n.data,b=o.matches,C=[];for(let N=0;N<b.length;N+=2){const R=b[N];C.push(R<0?null:y9(t,g[R],b[N+1],o.metadata.read))}p.matches=C}return p.matches}function Bd(n,t,o,l){const p=n.queries.getByIndex(o),g=p.matches;if(null!==g){const b=_9(n,t,p,o);for(let C=0;C<g.length;C+=2){const N=g[C];if(N>0)l.push(b[C/2]);else{const R=g[C+1],B=t[-N];for(let K=10;K<B.length;K++){const ue=B[K];ue[17]===ue[3]&&Bd(ue[1],ue,R,l)}if(null!==B[9]){const K=B[9];for(let ue=0;ue<K.length;ue++){const Ce=K[ue];Bd(Ce[1],Ce,R,l)}}}}}return l}function x9(n){const t=Ye(),o=Ct(),l=Tt();Yt(l+1);const p=N9(o,l);if(n.dirty&&H1(t)===(2==(2&p.metadata.flags))){if(null===p.matches)n.reset([]);else{const g=p.crossesNgTemplate?Bd(o,t,l,[]):_9(o,t,p,l);n.reset(g,Ap),n.notifyOnChanges()}return!0}return!1}function C9(n,t,o){const l=Ct();l.firstCreatePass&&(z9(l,new b9(n,t,o),-1),2==(2&t)&&(l.staticViewQueries=!0)),w9(l,Ye(),t)}function S9(n,t,o,l){const p=Ct();if(p.firstCreatePass){const g=b1();z9(p,new b9(t,o,l),g.index),function hm(n,t){const o=n.contentQueries||(n.contentQueries=[]);t!==(o.length?o[o.length-1]:-1)&&o.push(n.queries.length-1,t)}(p,n),2==(2&o)&&(p.staticContentQueries=!0)}w9(p,Ye(),o)}function M9(){return function mm(n,t){return n[19].queries[t].queryList}(Ye(),Tt())}function w9(n,t,o){const l=new Od(4==(4&o));V8(n,t,l,l.destroy),null===t[19]&&(t[19]=new Rd),t[19].queries.push(new Hd(l))}function z9(n,t,o){null===n.queries&&(n.queries=new Fd),n.queries.track(new qd(t,o))}function N9(n,t){return n.queries.getByIndex(t)}function D9(n,t){return X6(n,t)}const jm=eo("Input",n=>({bindingPropertyName:n})),km=eo("Output",n=>({bindingPropertyName:n})),Pm=eo("HostBinding",n=>({hostPropertyName:n}));function K6(...n){}const G9=new ti("Application Initializer");let Xd=(()=>{class n{constructor(o){this.appInits=o,this.resolve=K6,this.reject=K6,this.initialized=!1,this.done=!1,this.donePromise=new Promise((l,p)=>{this.resolve=l,this.reject=p})}runInitializers(){if(this.initialized)return;const o=[],l=()=>{this.done=!0,this.resolve()};if(this.appInits)for(let p=0;p<this.appInits.length;p++){const g=this.appInits[p]();if($4(g))o.push(g);else if(F0(g)){const b=new Promise((C,N)=>{g.subscribe({complete:C,error:N})});o.push(b)}}Promise.all(o).then(()=>{l()}).catch(p=>{this.reject(p)}),0===o.length&&l(),this.initialized=!0}}return n.\u0275fac=function(o){return new(o||n)(vt(G9,8))},n.\u0275prov=Ut({token:n,factory:n.\u0275fac,providedIn:"root"}),n})();const Yd=new ti("AppId",{providedIn:"root",factory:function W9(){return`${Qd()}${Qd()}${Qd()}`}});function Qd(){return String.fromCharCode(97+Math.floor(25*Math.random()))}const Z9=new ti("Platform Initializer"),$9=new ti("Platform ID"),X9=new ti("appBootstrapListener");let Y9=(()=>{class n{log(o){console.log(o)}warn(o){console.warn(o)}}return n.\u0275fac=function(o){return new(o||n)},n.\u0275prov=Ut({token:n,factory:n.\u0275fac}),n})();const Jd=new ti("LocaleId",{providedIn:"root",factory:()=>Br(Jd,$n.Optional|$n.SkipSelf)||function Im(){return"undefined"!=typeof $localize&&$localize.locale||K4}()}),Om=new ti("DefaultCurrencyCode",{providedIn:"root",factory:()=>"USD"});class Vm{constructor(t,o){this.ngModuleFactory=t,this.componentFactories=o}}let Hm=(()=>{class n{compileModuleSync(o){return new Pd(o)}compileModuleAsync(o){return Promise.resolve(this.compileModuleSync(o))}compileModuleAndAllComponentsSync(o){const l=this.compileModuleSync(o),g=E($t(o).declarations).reduce((b,C)=>{const N=Sn(C);return N&&b.push(new kd(N)),b},[]);return new Vm(l,g)}compileModuleAndAllComponentsAsync(o){return Promise.resolve(this.compileModuleAndAllComponentsSync(o))}clearCache(){}clearCacheFor(o){}getModuleId(o){}}return n.\u0275fac=function(o){return new(o||n)},n.\u0275prov=Ut({token:n,factory:n.\u0275fac,providedIn:"root"}),n})();const Fm=(()=>Promise.resolve(0))();function Kd(n){"undefined"==typeof Zone?Fm.then(()=>{n&&n.apply(null,null)}):Zone.current.scheduleMicroTask("scheduleMicrotask",n)}class bo{constructor({enableLongStackTrace:t=!1,shouldCoalesceEventChangeDetection:o=!1,shouldCoalesceRunChangeDetection:l=!1}){if(this.hasPendingMacrotasks=!1,this.hasPendingMicrotasks=!1,this.isStable=!0,this.onUnstable=new $o(!1),this.onMicrotaskEmpty=new $o(!1),this.onStable=new $o(!1),this.onError=new $o(!1),"undefined"==typeof Zone)throw new Error("In this configuration Angular requires Zone.js");Zone.assertZonePatched();const p=this;p._nesting=0,p._outer=p._inner=Zone.current,Zone.TaskTrackingZoneSpec&&(p._inner=p._inner.fork(new Zone.TaskTrackingZoneSpec)),t&&Zone.longStackTraceZoneSpec&&(p._inner=p._inner.fork(Zone.longStackTraceZoneSpec)),p.shouldCoalesceEventChangeDetection=!l&&o,p.shouldCoalesceRunChangeDetection=l,p.lastRequestAnimationFrameId=-1,p.nativeRequestAnimationFrame=function qm(){let n=gt.requestAnimationFrame,t=gt.cancelAnimationFrame;if("undefined"!=typeof Zone&&n&&t){const o=n[Zone.__symbol__("OriginalDelegate")];o&&(n=o);const l=t[Zone.__symbol__("OriginalDelegate")];l&&(t=l)}return{nativeRequestAnimationFrame:n,nativeCancelAnimationFrame:t}}().nativeRequestAnimationFrame,function Gm(n){const t=()=>{!function Um(n){n.isCheckStableRunning||-1!==n.lastRequestAnimationFrameId||(n.lastRequestAnimationFrameId=n.nativeRequestAnimationFrame.call(gt,()=>{n.fakeTopEventTask||(n.fakeTopEventTask=Zone.root.scheduleEventTask("fakeTopEventTask",()=>{n.lastRequestAnimationFrameId=-1,nu(n),n.isCheckStableRunning=!0,eu(n),n.isCheckStableRunning=!1},void 0,()=>{},()=>{})),n.fakeTopEventTask.invoke()}),nu(n))}(n)};n._inner=n._inner.fork({name:"angular",properties:{isAngularZone:!0},onInvokeTask:(o,l,p,g,b,C)=>{try{return Q9(n),o.invokeTask(p,g,b,C)}finally{(n.shouldCoalesceEventChangeDetection&&"eventTask"===g.type||n.shouldCoalesceRunChangeDetection)&&t(),J9(n)}},onInvoke:(o,l,p,g,b,C,N)=>{try{return Q9(n),o.invoke(p,g,b,C,N)}finally{n.shouldCoalesceRunChangeDetection&&t(),J9(n)}},onHasTask:(o,l,p,g)=>{o.hasTask(p,g),l===p&&("microTask"==g.change?(n._hasPendingMicrotasks=g.microTask,nu(n),eu(n)):"macroTask"==g.change&&(n.hasPendingMacrotasks=g.macroTask))},onHandleError:(o,l,p,g)=>(o.handleError(p,g),n.runOutsideAngular(()=>n.onError.emit(g)),!1)})}(p)}static isInAngularZone(){return"undefined"!=typeof Zone&&!0===Zone.current.get("isAngularZone")}static assertInAngularZone(){if(!bo.isInAngularZone())throw new Error("Expected to be in Angular Zone, but it is not!")}static assertNotInAngularZone(){if(bo.isInAngularZone())throw new Error("Expected to not be in Angular Zone, but it is!")}run(t,o,l){return this._inner.run(t,o,l)}runTask(t,o,l,p){const g=this._inner,b=g.scheduleEventTask("NgZoneEvent: "+p,t,Bm,K6,K6);try{return g.runTask(b,o,l)}finally{g.cancelTask(b)}}runGuarded(t,o,l){return this._inner.runGuarded(t,o,l)}runOutsideAngular(t){return this._outer.run(t)}}const Bm={};function eu(n){if(0==n._nesting&&!n.hasPendingMicrotasks&&!n.isStable)try{n._nesting++,n.onMicrotaskEmpty.emit(null)}finally{if(n._nesting--,!n.hasPendingMicrotasks)try{n.runOutsideAngular(()=>n.onStable.emit(null))}finally{n.isStable=!0}}}function nu(n){n.hasPendingMicrotasks=!!(n._hasPendingMicrotasks||(n.shouldCoalesceEventChangeDetection||n.shouldCoalesceRunChangeDetection)&&-1!==n.lastRequestAnimationFrameId)}function Q9(n){n._nesting++,n.isStable&&(n.isStable=!1,n.onUnstable.emit(null))}function J9(n){n._nesting--,eu(n)}class Wm{constructor(){this.hasPendingMicrotasks=!1,this.hasPendingMacrotasks=!1,this.isStable=!0,this.onUnstable=new $o,this.onMicrotaskEmpty=new $o,this.onStable=new $o,this.onError=new $o}run(t,o,l){return t.apply(o,l)}runGuarded(t,o,l){return t.apply(o,l)}runOutsideAngular(t){return t()}runTask(t,o,l,p){return t.apply(o,l)}}let K9=(()=>{class n{constructor(o){this._ngZone=o,this._pendingCount=0,this._isZoneStable=!0,this._didWork=!1,this._callbacks=[],this.taskTrackingZone=null,this._watchAngularEvents(),o.run(()=>{this.taskTrackingZone="undefined"==typeof Zone?null:Zone.current.get("TaskTrackingZone")})}_watchAngularEvents(){this._ngZone.onUnstable.subscribe({next:()=>{this._didWork=!0,this._isZoneStable=!1}}),this._ngZone.runOutsideAngular(()=>{this._ngZone.onStable.subscribe({next:()=>{bo.assertNotInAngularZone(),Kd(()=>{this._isZoneStable=!0,this._runCallbacksIfReady()})}})})}increasePendingRequestCount(){return this._pendingCount+=1,this._didWork=!0,this._pendingCount}decreasePendingRequestCount(){if(this._pendingCount-=1,this._pendingCount<0)throw new Error("pending async requests below zero");return this._runCallbacksIfReady(),this._pendingCount}isStable(){return this._isZoneStable&&0===this._pendingCount&&!this._ngZone.hasPendingMacrotasks}_runCallbacksIfReady(){if(this.isStable())Kd(()=>{for(;0!==this._callbacks.length;){let o=this._callbacks.pop();clearTimeout(o.timeoutId),o.doneCb(this._didWork)}this._didWork=!1});else{let o=this.getPendingTasks();this._callbacks=this._callbacks.filter(l=>!l.updateCb||!l.updateCb(o)||(clearTimeout(l.timeoutId),!1)),this._didWork=!0}}getPendingTasks(){return this.taskTrackingZone?this.taskTrackingZone.macroTasks.map(o=>({source:o.source,creationLocation:o.creationLocation,data:o.data})):[]}addCallback(o,l,p){let g=-1;l&&l>0&&(g=setTimeout(()=>{this._callbacks=this._callbacks.filter(b=>b.timeoutId!==g),o(this._didWork,this.getPendingTasks())},l)),this._callbacks.push({doneCb:o,timeoutId:g,updateCb:p})}whenStable(o,l,p){if(p&&!this.taskTrackingZone)throw new Error('Task tracking zone is required when passing an update callback to whenStable(). Is "zone.js/plugins/task-tracking" loaded?');this.addCallback(o,l,p),this._runCallbacksIfReady()}getPendingRequestCount(){return this._pendingCount}findProviders(o,l,p){return[]}}return n.\u0275fac=function(o){return new(o||n)(vt(bo))},n.\u0275prov=Ut({token:n,factory:n.\u0275fac}),n})(),ef=(()=>{class n{constructor(){this._applications=new Map,tu.addToWindow(this)}registerApplication(o,l){this._applications.set(o,l)}unregisterApplication(o){this._applications.delete(o)}unregisterAllApplications(){this._applications.clear()}getTestability(o){return this._applications.get(o)||null}getAllTestabilities(){return Array.from(this._applications.values())}getAllRootElements(){return Array.from(this._applications.keys())}findTestabilityInTree(o,l=!0){return tu.findTestabilityInTree(this,o,l)}}return n.\u0275fac=function(o){return new(o||n)},n.\u0275prov=Ut({token:n,factory:n.\u0275fac}),n})();class Zm{addToWindow(t){}findTestabilityInTree(t,o,l){return null}}function $m(n){tu=n}let yo,tu=new Zm;const nf=new ti("AllowMultipleToken");class Qm{constructor(t,o){this.name=t,this.token=o}}function tf(n,t,o=[]){const l=`Platform: ${t}`,p=new ti(l);return(g=[])=>{let b=af();if(!b||b.injector.get(nf,!1))if(n)n(o.concat(g).concat({provide:p,useValue:!0}));else{const C=o.concat(g).concat({provide:p,useValue:!0},{provide:P4,useValue:"platform"});!function Jm(n){if(yo&&!yo.destroyed&&!yo.injector.get(nf,!1))throw new yn(400,"");yo=n.get(rf);const t=n.get(Z9,null);t&&t.forEach(o=>o())}(Dr.create({providers:C,name:l}))}return function Km(n){const t=af();if(!t)throw new yn(401,"");return t}()}}function af(){return yo&&!yo.destroyed?yo:null}let rf=(()=>{class n{constructor(o){this._injector=o,this._modules=[],this._destroyListeners=[],this._destroyed=!1}bootstrapModuleFactory(o,l){const C=function eh(n,t){let o;return o="noop"===n?new Wm:("zone.js"===n?void 0:n)||new bo({enableLongStackTrace:!1,shouldCoalesceEventChangeDetection:!!(null==t?void 0:t.ngZoneEventCoalescing),shouldCoalesceRunChangeDetection:!!(null==t?void 0:t.ngZoneRunCoalescing)}),o}(l?l.ngZone:void 0,{ngZoneEventCoalescing:l&&l.ngZoneEventCoalescing||!1,ngZoneRunCoalescing:l&&l.ngZoneRunCoalescing||!1}),N=[{provide:bo,useValue:C}];return C.run(()=>{const R=Dr.create({providers:N,parent:this.injector,name:o.moduleType.name}),B=o.create(R),K=B.injector.get(H2,null);if(!K)throw new yn(402,"");return C.runOutsideAngular(()=>{const ue=C.onError.subscribe({next:Ce=>{K.handleError(Ce)}});B.onDestroy(()=>{au(this._modules,B),ue.unsubscribe()})}),function nh(n,t,o){try{const l=o();return $4(l)?l.catch(p=>{throw t.runOutsideAngular(()=>n.handleError(p)),p}):l}catch(l){throw t.runOutsideAngular(()=>n.handleError(l)),l}}(K,C,()=>{const ue=B.injector.get(Xd);return ue.runInitializers(),ue.donePromise.then(()=>(function _d(n){(function Bt(n,t){null==n&&st(t,n,null,"!=")})(n,"Expected localeId to be defined"),"string"==typeof n&&(H6=n.toLowerCase().replace(/_/g,"-"))}(B.injector.get(Jd,K4)||K4),this._moduleDoBootstrap(B),B))})})}bootstrapModule(o,l=[]){const p=sf({},l);return function Xm(n,t,o){const l=new Pd(o);return Promise.resolve(l)}(0,0,o).then(g=>this.bootstrapModuleFactory(g,p))}_moduleDoBootstrap(o){const l=o.injector.get(iu);if(o._bootstrapComponents.length>0)o._bootstrapComponents.forEach(p=>l.bootstrap(p));else{if(!o.instance.ngDoBootstrap)throw new yn(403,"");o.instance.ngDoBootstrap(l)}this._modules.push(o)}onDestroy(o){this._destroyListeners.push(o)}get injector(){return this._injector}destroy(){if(this._destroyed)throw new yn(404,"");this._modules.slice().forEach(o=>o.destroy()),this._destroyListeners.forEach(o=>o()),this._destroyed=!0}get destroyed(){return this._destroyed}}return n.\u0275fac=function(o){return new(o||n)(vt(Dr))},n.\u0275prov=Ut({token:n,factory:n.\u0275fac}),n})();function sf(n,t){return Array.isArray(t)?t.reduce(sf,n):Object.assign(Object.assign({},n),t)}let iu=(()=>{class n{constructor(o,l,p,g,b){this._zone=o,this._injector=l,this._exceptionHandler=p,this._componentFactoryResolver=g,this._initStatus=b,this._bootstrapListeners=[],this._views=[],this._runningTick=!1,this._stable=!0,this.componentTypes=[],this.components=[],this._onMicrotaskEmptySubscription=this._zone.onMicrotaskEmpty.subscribe({next:()=>{this._zone.run(()=>{this.tick()})}});const C=new Ue.y(R=>{this._stable=this._zone.isStable&&!this._zone.hasPendingMacrotasks&&!this._zone.hasPendingMicrotasks,this._zone.runOutsideAngular(()=>{R.next(this._stable),R.complete()})}),N=new Ue.y(R=>{let B;this._zone.runOutsideAngular(()=>{B=this._zone.onStable.subscribe(()=>{bo.assertNotInAngularZone(),Kd(()=>{!this._stable&&!this._zone.hasPendingMacrotasks&&!this._zone.hasPendingMicrotasks&&(this._stable=!0,R.next(!0))})})});const K=this._zone.onUnstable.subscribe(()=>{bo.assertInAngularZone(),this._stable&&(this._stable=!1,this._zone.runOutsideAngular(()=>{R.next(!1)}))});return()=>{B.unsubscribe(),K.unsubscribe()}});this.isStable=(0,Oe.T)(C,N.pipe(function le(){return n=>(0,ce.x)()(function he(n,t){return function(l){let p;if(p="function"==typeof n?n:function(){return n},"function"==typeof t)return l.lift(new oe(p,t));const g=Object.create(l,ye.N);return g.source=l,g.subjectFactory=p,g}}(fe)(n))}()))}bootstrap(o,l){if(!this._initStatus.done)throw new yn(405,"");let p;p=o instanceof Y7?o:this._componentFactoryResolver.resolveComponentFactory(o),this.componentTypes.push(p.componentType);const g=function Ym(n){return n.isBoundToModule}(p)?void 0:this._injector.get(r3),C=p.create(Dr.NULL,[],l||p.selector,g),N=C.location.nativeElement,R=C.injector.get(K9,null),B=R&&C.injector.get(ef);return R&&B&&B.registerApplication(N,R),C.onDestroy(()=>{this.detachView(C.hostView),au(this.components,C),B&&B.unregisterApplication(N)}),this._loadComponent(C),C}tick(){if(this._runningTick)throw new yn(101,"");try{this._runningTick=!0;for(let o of this._views)o.detectChanges()}catch(o){this._zone.runOutsideAngular(()=>this._exceptionHandler.handleError(o))}finally{this._runningTick=!1}}attachView(o){const l=o;this._views.push(l),l.attachToAppRef(this)}detachView(o){const l=o;au(this._views,l),l.detachFromAppRef()}_loadComponent(o){this.attachView(o.hostView),this.tick(),this.components.push(o),this._injector.get(X9,[]).concat(this._bootstrapListeners).forEach(p=>p(o))}ngOnDestroy(){this._views.slice().forEach(o=>o.destroy()),this._onMicrotaskEmptySubscription.unsubscribe()}get viewCount(){return this._views.length}}return n.\u0275fac=function(o){return new(o||n)(vt(bo),vt(Dr),vt(H2),vt(Z6),vt(Xd))},n.\u0275prov=Ut({token:n,factory:n.\u0275fac,providedIn:"root"}),n})();function au(n,t){const o=n.indexOf(t);o>-1&&n.splice(o,1)}let lf=!0;function ih(){lf=!1}let ah=(()=>{class n{}return n.__NG_ELEMENT_ID__=rh,n})();function rh(n){return function oh(n,t,o){if(Ki(n)&&!o){const l=V1(n.index,t);return new Sl(l,l)}return 47&n.type?new Sl(t[16],t):null}(b1(),Ye(),16==(16&n))}class mf{constructor(){}supports(t){return Fc(t)}create(t){return new fh(t)}}const uh=(n,t)=>t;class fh{constructor(t){this.length=0,this._linkedRecords=null,this._unlinkedRecords=null,this._previousItHead=null,this._itHead=null,this._itTail=null,this._additionsHead=null,this._additionsTail=null,this._movesHead=null,this._movesTail=null,this._removalsHead=null,this._removalsTail=null,this._identityChangesHead=null,this._identityChangesTail=null,this._trackByFn=t||uh}forEachItem(t){let o;for(o=this._itHead;null!==o;o=o._next)t(o)}forEachOperation(t){let o=this._itHead,l=this._removalsHead,p=0,g=null;for(;o||l;){const b=!l||o&&o.currentIndex<gf(l,p,g)?o:l,C=gf(b,p,g),N=b.currentIndex;if(b===l)p--,l=l._nextRemoved;else if(o=o._next,null==b.previousIndex)p++;else{g||(g=[]);const R=C-p,B=N-p;if(R!=B){for(let ue=0;ue<R;ue++){const Ce=ue<g.length?g[ue]:g[ue]=0,qe=Ce+ue;B<=qe&&qe<R&&(g[ue]=Ce+1)}g[b.previousIndex]=B-R}}C!==N&&t(b,C,N)}}forEachPreviousItem(t){let o;for(o=this._previousItHead;null!==o;o=o._nextPrevious)t(o)}forEachAddedItem(t){let o;for(o=this._additionsHead;null!==o;o=o._nextAdded)t(o)}forEachMovedItem(t){let o;for(o=this._movesHead;null!==o;o=o._nextMoved)t(o)}forEachRemovedItem(t){let o;for(o=this._removalsHead;null!==o;o=o._nextRemoved)t(o)}forEachIdentityChange(t){let o;for(o=this._identityChangesHead;null!==o;o=o._nextIdentityChange)t(o)}diff(t){if(null==t&&(t=[]),!Fc(t))throw new yn(900,"");return this.check(t)?this:null}onDestroy(){}check(t){this._reset();let p,g,b,o=this._itHead,l=!1;if(Array.isArray(t)){this.length=t.length;for(let C=0;C<this.length;C++)g=t[C],b=this._trackByFn(C,g),null!==o&&Object.is(o.trackById,b)?(l&&(o=this._verifyReinsertion(o,g,b,C)),Object.is(o.item,g)||this._addIdentityChange(o,g)):(o=this._mismatch(o,g,b,C),l=!0),o=o._next}else p=0,function v5(n,t){if(Array.isArray(n))for(let o=0;o<n.length;o++)t(n[o]);else{const o=n[vo()]();let l;for(;!(l=o.next()).done;)t(l.value)}}(t,C=>{b=this._trackByFn(p,C),null!==o&&Object.is(o.trackById,b)?(l&&(o=this._verifyReinsertion(o,C,b,p)),Object.is(o.item,C)||this._addIdentityChange(o,C)):(o=this._mismatch(o,C,b,p),l=!0),o=o._next,p++}),this.length=p;return this._truncate(o),this.collection=t,this.isDirty}get isDirty(){return null!==this._additionsHead||null!==this._movesHead||null!==this._removalsHead||null!==this._identityChangesHead}_reset(){if(this.isDirty){let t;for(t=this._previousItHead=this._itHead;null!==t;t=t._next)t._nextPrevious=t._next;for(t=this._additionsHead;null!==t;t=t._nextAdded)t.previousIndex=t.currentIndex;for(this._additionsHead=this._additionsTail=null,t=this._movesHead;null!==t;t=t._nextMoved)t.previousIndex=t.currentIndex;this._movesHead=this._movesTail=null,this._removalsHead=this._removalsTail=null,this._identityChangesHead=this._identityChangesTail=null}}_mismatch(t,o,l,p){let g;return null===t?g=this._itTail:(g=t._prev,this._remove(t)),null!==(t=null===this._unlinkedRecords?null:this._unlinkedRecords.get(l,null))?(Object.is(t.item,o)||this._addIdentityChange(t,o),this._reinsertAfter(t,g,p)):null!==(t=null===this._linkedRecords?null:this._linkedRecords.get(l,p))?(Object.is(t.item,o)||this._addIdentityChange(t,o),this._moveAfter(t,g,p)):t=this._addAfter(new ph(o,l),g,p),t}_verifyReinsertion(t,o,l,p){let g=null===this._unlinkedRecords?null:this._unlinkedRecords.get(l,null);return null!==g?t=this._reinsertAfter(g,t._prev,p):t.currentIndex!=p&&(t.currentIndex=p,this._addToMoves(t,p)),t}_truncate(t){for(;null!==t;){const o=t._next;this._addToRemovals(this._unlink(t)),t=o}null!==this._unlinkedRecords&&this._unlinkedRecords.clear(),null!==this._additionsTail&&(this._additionsTail._nextAdded=null),null!==this._movesTail&&(this._movesTail._nextMoved=null),null!==this._itTail&&(this._itTail._next=null),null!==this._removalsTail&&(this._removalsTail._nextRemoved=null),null!==this._identityChangesTail&&(this._identityChangesTail._nextIdentityChange=null)}_reinsertAfter(t,o,l){null!==this._unlinkedRecords&&this._unlinkedRecords.remove(t);const p=t._prevRemoved,g=t._nextRemoved;return null===p?this._removalsHead=g:p._nextRemoved=g,null===g?this._removalsTail=p:g._prevRemoved=p,this._insertAfter(t,o,l),this._addToMoves(t,l),t}_moveAfter(t,o,l){return this._unlink(t),this._insertAfter(t,o,l),this._addToMoves(t,l),t}_addAfter(t,o,l){return this._insertAfter(t,o,l),this._additionsTail=null===this._additionsTail?this._additionsHead=t:this._additionsTail._nextAdded=t,t}_insertAfter(t,o,l){const p=null===o?this._itHead:o._next;return t._next=p,t._prev=o,null===p?this._itTail=t:p._prev=t,null===o?this._itHead=t:o._next=t,null===this._linkedRecords&&(this._linkedRecords=new hf),this._linkedRecords.put(t),t.currentIndex=l,t}_remove(t){return this._addToRemovals(this._unlink(t))}_unlink(t){null!==this._linkedRecords&&this._linkedRecords.remove(t);const o=t._prev,l=t._next;return null===o?this._itHead=l:o._next=l,null===l?this._itTail=o:l._prev=o,t}_addToMoves(t,o){return t.previousIndex===o||(this._movesTail=null===this._movesTail?this._movesHead=t:this._movesTail._nextMoved=t),t}_addToRemovals(t){return null===this._unlinkedRecords&&(this._unlinkedRecords=new hf),this._unlinkedRecords.put(t),t.currentIndex=null,t._nextRemoved=null,null===this._removalsTail?(this._removalsTail=this._removalsHead=t,t._prevRemoved=null):(t._prevRemoved=this._removalsTail,this._removalsTail=this._removalsTail._nextRemoved=t),t}_addIdentityChange(t,o){return t.item=o,this._identityChangesTail=null===this._identityChangesTail?this._identityChangesHead=t:this._identityChangesTail._nextIdentityChange=t,t}}class ph{constructor(t,o){this.item=t,this.trackById=o,this.currentIndex=null,this.previousIndex=null,this._nextPrevious=null,this._prev=null,this._next=null,this._prevDup=null,this._nextDup=null,this._prevRemoved=null,this._nextRemoved=null,this._nextAdded=null,this._nextMoved=null,this._nextIdentityChange=null}}class mh{constructor(){this._head=null,this._tail=null}add(t){null===this._head?(this._head=this._tail=t,t._nextDup=null,t._prevDup=null):(this._tail._nextDup=t,t._prevDup=this._tail,t._nextDup=null,this._tail=t)}get(t,o){let l;for(l=this._head;null!==l;l=l._nextDup)if((null===o||o<=l.currentIndex)&&Object.is(l.trackById,t))return l;return null}remove(t){const o=t._prevDup,l=t._nextDup;return null===o?this._head=l:o._nextDup=l,null===l?this._tail=o:l._prevDup=o,null===this._head}}class hf{constructor(){this.map=new Map}put(t){const o=t.trackById;let l=this.map.get(o);l||(l=new mh,this.map.set(o,l)),l.add(t)}get(t,o){const p=this.map.get(t);return p?p.get(t,o):null}remove(t){const o=t.trackById;return this.map.get(o).remove(t)&&this.map.delete(o),t}get isEmpty(){return 0===this.map.size}clear(){this.map.clear()}}function gf(n,t,o){const l=n.previousIndex;if(null===l)return l;let p=0;return o&&l<o.length&&(p=o[l]),l+t+p}class vf{constructor(){}supports(t){return t instanceof Map||q4(t)}create(){return new hh}}class hh{constructor(){this._records=new Map,this._mapHead=null,this._appendAfter=null,this._previousMapHead=null,this._changesHead=null,this._changesTail=null,this._additionsHead=null,this._additionsTail=null,this._removalsHead=null,this._removalsTail=null}get isDirty(){return null!==this._additionsHead||null!==this._changesHead||null!==this._removalsHead}forEachItem(t){let o;for(o=this._mapHead;null!==o;o=o._next)t(o)}forEachPreviousItem(t){let o;for(o=this._previousMapHead;null!==o;o=o._nextPrevious)t(o)}forEachChangedItem(t){let o;for(o=this._changesHead;null!==o;o=o._nextChanged)t(o)}forEachAddedItem(t){let o;for(o=this._additionsHead;null!==o;o=o._nextAdded)t(o)}forEachRemovedItem(t){let o;for(o=this._removalsHead;null!==o;o=o._nextRemoved)t(o)}diff(t){if(t){if(!(t instanceof Map||q4(t)))throw new yn(900,"")}else t=new Map;return this.check(t)?this:null}onDestroy(){}check(t){this._reset();let o=this._mapHead;if(this._appendAfter=null,this._forEach(t,(l,p)=>{if(o&&o.key===p)this._maybeAddToChanges(o,l),this._appendAfter=o,o=o._next;else{const g=this._getOrCreateRecordForKey(p,l);o=this._insertBeforeOrAppend(o,g)}}),o){o._prev&&(o._prev._next=null),this._removalsHead=o;for(let l=o;null!==l;l=l._nextRemoved)l===this._mapHead&&(this._mapHead=null),this._records.delete(l.key),l._nextRemoved=l._next,l.previousValue=l.currentValue,l.currentValue=null,l._prev=null,l._next=null}return this._changesTail&&(this._changesTail._nextChanged=null),this._additionsTail&&(this._additionsTail._nextAdded=null),this.isDirty}_insertBeforeOrAppend(t,o){if(t){const l=t._prev;return o._next=t,o._prev=l,t._prev=o,l&&(l._next=o),t===this._mapHead&&(this._mapHead=o),this._appendAfter=t,t}return this._appendAfter?(this._appendAfter._next=o,o._prev=this._appendAfter):this._mapHead=o,this._appendAfter=o,null}_getOrCreateRecordForKey(t,o){if(this._records.has(t)){const p=this._records.get(t);this._maybeAddToChanges(p,o);const g=p._prev,b=p._next;return g&&(g._next=b),b&&(b._prev=g),p._next=null,p._prev=null,p}const l=new gh(t);return this._records.set(t,l),l.currentValue=o,this._addToAdditions(l),l}_reset(){if(this.isDirty){let t;for(this._previousMapHead=this._mapHead,t=this._previousMapHead;null!==t;t=t._next)t._nextPrevious=t._next;for(t=this._changesHead;null!==t;t=t._nextChanged)t.previousValue=t.currentValue;for(t=this._additionsHead;null!=t;t=t._nextAdded)t.previousValue=t.currentValue;this._changesHead=this._changesTail=null,this._additionsHead=this._additionsTail=null,this._removalsHead=null}}_maybeAddToChanges(t,o){Object.is(o,t.currentValue)||(t.previousValue=t.currentValue,t.currentValue=o,this._addToChanges(t))}_addToAdditions(t){null===this._additionsHead?this._additionsHead=this._additionsTail=t:(this._additionsTail._nextAdded=t,this._additionsTail=t)}_addToChanges(t){null===this._changesHead?this._changesHead=this._changesTail=t:(this._changesTail._nextChanged=t,this._changesTail=t)}_forEach(t,o){t instanceof Map?t.forEach(o):Object.keys(t).forEach(l=>o(t[l],l))}}class gh{constructor(t){this.key=t,this.previousValue=null,this.currentValue=null,this._nextPrevious=null,this._next=null,this._prev=null,this._nextAdded=null,this._nextRemoved=null,this._nextChanged=null}}function bf(){return new lu([new mf])}let lu=(()=>{class n{constructor(o){this.factories=o}static create(o,l){if(null!=l){const p=l.factories.slice();o=o.concat(p)}return new n(o)}static extend(o){return{provide:n,useFactory:l=>n.create(o,l||bf()),deps:[[n,new Lo,new io]]}}find(o){const l=this.factories.find(p=>p.supports(o));if(null!=l)return l;throw new yn(901,"")}}return n.\u0275prov=Ut({token:n,providedIn:"root",factory:bf}),n})();function yf(){return new du([new vf])}let du=(()=>{class n{constructor(o){this.factories=o}static create(o,l){if(l){const p=l.factories.slice();o=o.concat(p)}return new n(o)}static extend(o){return{provide:n,useFactory:l=>n.create(o,l||yf()),deps:[[n,new Lo,new io]]}}find(o){const l=this.factories.find(g=>g.supports(o));if(l)return l;throw new yn(901,"")}}return n.\u0275prov=Ut({token:n,providedIn:"root",factory:yf}),n})();const yh=tf(null,"core",[{provide:$9,useValue:"unknown"},{provide:rf,deps:[Dr]},{provide:ef,deps:[]},{provide:Y9,deps:[]}]);let _h=(()=>{class n{constructor(o){}}return n.\u0275fac=function(o){return new(o||n)(vt(iu))},n.\u0275mod=xe({type:n}),n.\u0275inj=qn({}),n})()},4182:(Xn,He,Q)=>{"use strict";Q.d(He,{u5:()=>c1,JU:()=>Me,JJ:()=>wa,On:()=>u1,UX:()=>Jn});var M=Q(6435),d=Q(9808),Ue=Q(2916),Oe=Q(6688),ye=Q(4850),he=Q(7830),oe=Q(5254);function fe(P,L){return new Ue.y(D=>{const W=P.length;if(0===W)return void D.complete();const je=new Array(W);let $e=0,A1=0;for(let ri=0;ri<W;ri++){const U1=(0,oe.D)(P[ri]);let Ri=!1;D.add(U1.subscribe({next:ta=>{Ri||(Ri=!0,A1++),je[ri]=ta},error:ta=>D.error(ta),complete:()=>{$e++,($e===W||!Ri)&&(A1===W&&D.next(L?L.reduce((ta,ia,kr)=>(ta[ia]=je[kr],ta),{}):je),D.complete())}}))}})}let le=(()=>{class P{constructor(D,W){this._renderer=D,this._elementRef=W,this.onChange=je=>{},this.onTouched=()=>{}}setProperty(D,W){this._renderer.setProperty(this._elementRef.nativeElement,D,W)}registerOnTouched(D){this.onTouched=D}registerOnChange(D){this.onChange=D}setDisabledState(D){this.setProperty("disabled",D)}}return P.\u0275fac=function(D){return new(D||P)(M.Y36(M.Qsj),M.Y36(M.SBq))},P.\u0275dir=M.lG2({type:P}),P})(),pe=(()=>{class P extends le{}return P.\u0275fac=function(){let L;return function(W){return(L||(L=M.n5z(P)))(W||P)}}(),P.\u0275dir=M.lG2({type:P,features:[M.qOj]}),P})();const Me=new M.OlP("NgValueAccessor"),rn={provide:Me,useExisting:(0,M.Gpc)(()=>ot),multi:!0},Qe=new M.OlP("CompositionEventMode");let ot=(()=>{class P extends le{constructor(D,W,je){super(D,W),this._compositionMode=je,this._composing=!1,null==this._compositionMode&&(this._compositionMode=!function Ke(){const P=(0,d.q)()?(0,d.q)().getUserAgent():"";return/android (\d+)/.test(P.toLowerCase())}())}writeValue(D){this.setProperty("value",null==D?"":D)}_handleInput(D){(!this._compositionMode||this._compositionMode&&!this._composing)&&this.onChange(D)}_compositionStart(){this._composing=!0}_compositionEnd(D){this._composing=!1,this._compositionMode&&this.onChange(D)}}return P.\u0275fac=function(D){return new(D||P)(M.Y36(M.Qsj),M.Y36(M.SBq),M.Y36(Qe,8))},P.\u0275dir=M.lG2({type:P,selectors:[["input","formControlName","",3,"type","checkbox"],["textarea","formControlName",""],["input","formControl","",3,"type","checkbox"],["textarea","formControl",""],["input","ngModel","",3,"type","checkbox"],["textarea","ngModel",""],["","ngDefaultControl",""]],hostBindings:function(D,W){1&D&&M.NdJ("input",function($e){return W._handleInput($e.target.value)})("blur",function(){return W.onTouched()})("compositionstart",function(){return W._compositionStart()})("compositionend",function($e){return W._compositionEnd($e.target.value)})},features:[M._Bn([rn]),M.qOj]}),P})();const ut=new M.OlP("NgValidators"),cn=new M.OlP("NgAsyncValidators");function me(P){return null!=P}function Xe(P){const L=(0,M.QGY)(P)?(0,oe.D)(P):P;return(0,M.CqO)(L),L}function En(P){let L={};return P.forEach(D=>{L=null!=D?Object.assign(Object.assign({},L),D):L}),0===Object.keys(L).length?null:L}function Ln(P,L){return L.map(D=>D(P))}function Rt(P){return P.map(L=>function lt(P){return!P.validate}(L)?L:D=>L.validate(D))}function Bt(P){return null!=P?function Zi(P){if(!P)return null;const L=P.filter(me);return 0==L.length?null:function(D){return En(Ln(D,L))}}(Rt(P)):null}function zt(P){return null!=P?function st(P){if(!P)return null;const L=P.filter(me);return 0==L.length?null:function(D){return function ce(...P){if(1===P.length){const L=P[0];if((0,Oe.k)(L))return fe(L,null);if((0,he.K)(L)&&Object.getPrototypeOf(L)===Object.prototype){const D=Object.keys(L);return fe(D.map(W=>L[W]),D)}}if("function"==typeof P[P.length-1]){const L=P.pop();return fe(P=1===P.length&&(0,Oe.k)(P[0])?P[0]:P,null).pipe((0,ye.U)(D=>L(...D)))}return fe(P,null)}(Ln(D,L).map(Xe)).pipe((0,ye.U)(En))}}(Rt(P)):null}function Lt(P,L){return null===P?[L]:Array.isArray(P)?[...P,L]:[P,L]}function y1(P){return P?Array.isArray(P)?P:[P]:[]}function qn(P,L){return Array.isArray(P)?P.includes(L):P===L}function pi(P,L){const D=y1(L);return y1(P).forEach(je=>{qn(D,je)||D.push(je)}),D}function Xi(P,L){return y1(L).filter(D=>!qn(P,D))}class j1{constructor(){this._rawValidators=[],this._rawAsyncValidators=[],this._onDestroyCallbacks=[]}get value(){return this.control?this.control.value:null}get valid(){return this.control?this.control.valid:null}get invalid(){return this.control?this.control.invalid:null}get pending(){return this.control?this.control.pending:null}get disabled(){return this.control?this.control.disabled:null}get enabled(){return this.control?this.control.enabled:null}get errors(){return this.control?this.control.errors:null}get pristine(){return this.control?this.control.pristine:null}get dirty(){return this.control?this.control.dirty:null}get touched(){return this.control?this.control.touched:null}get status(){return this.control?this.control.status:null}get untouched(){return this.control?this.control.untouched:null}get statusChanges(){return this.control?this.control.statusChanges:null}get valueChanges(){return this.control?this.control.valueChanges:null}get path(){return null}_setValidators(L){this._rawValidators=L||[],this._composedValidatorFn=Bt(this._rawValidators)}_setAsyncValidators(L){this._rawAsyncValidators=L||[],this._composedAsyncValidatorFn=zt(this._rawAsyncValidators)}get validator(){return this._composedValidatorFn||null}get asyncValidator(){return this._composedAsyncValidatorFn||null}_registerOnDestroy(L){this._onDestroyCallbacks.push(L)}_invokeOnDestroyCallbacks(){this._onDestroyCallbacks.forEach(L=>L()),this._onDestroyCallbacks=[]}reset(L){this.control&&this.control.reset(L)}hasError(L,D){return!!this.control&&this.control.hasError(L,D)}getError(L,D){return this.control?this.control.getError(L,D):null}}class Gt extends j1{constructor(){super(...arguments),this._parent=null,this.name=null,this.valueAccessor=null}}class a1 extends j1{get formDirective(){return null}get path(){return null}}let wa=(()=>{class P extends class q1{constructor(L){this._cd=L}is(L){var D,W,je;return"submitted"===L?!!(null===(D=this._cd)||void 0===D?void 0:D.submitted):!!(null===(je=null===(W=this._cd)||void 0===W?void 0:W.control)||void 0===je?void 0:je[L])}}{constructor(D){super(D)}}return P.\u0275fac=function(D){return new(D||P)(M.Y36(Gt,2))},P.\u0275dir=M.lG2({type:P,selectors:[["","formControlName",""],["","ngModel",""],["","formControl",""]],hostVars:14,hostBindings:function(D,W){2&D&&M.ekj("ng-untouched",W.is("untouched"))("ng-touched",W.is("touched"))("ng-pristine",W.is("pristine"))("ng-dirty",W.is("dirty"))("ng-valid",W.is("valid"))("ng-invalid",W.is("invalid"))("ng-pending",W.is("pending"))},features:[M.qOj]}),P})();function m1(P,L){(function Ni(P,L){const D=function $i(P){return P._rawValidators}(P);null!==L.validator?P.setValidators(Lt(D,L.validator)):"function"==typeof D&&P.setValidators([D]);const W=function Ut(P){return P._rawAsyncValidators}(P);null!==L.asyncValidator?P.setAsyncValidators(Lt(W,L.asyncValidator)):"function"==typeof W&&P.setAsyncValidators([W]);const je=()=>P.updateValueAndValidity();k1(L._rawValidators,je),k1(L._rawAsyncValidators,je)})(P,L),L.valueAccessor.writeValue(P.value),function kt(P,L){L.valueAccessor.registerOnChange(D=>{P._pendingValue=D,P._pendingChange=!0,P._pendingDirty=!0,"change"===P.updateOn&&Yi(P,L)})}(P,L),function za(P,L){const D=(W,je)=>{L.valueAccessor.writeValue(W),je&&L.viewToModelUpdate(W)};P.registerOnChange(D),L._registerOnDestroy(()=>{P._unregisterOnChange(D)})}(P,L),function r1(P,L){L.valueAccessor.registerOnTouched(()=>{P._pendingTouched=!0,"blur"===P.updateOn&&P._pendingChange&&Yi(P,L),"submit"!==P.updateOn&&P.markAsTouched()})}(P,L),function ma(P,L){if(L.valueAccessor.setDisabledState){const D=W=>{L.valueAccessor.setDisabledState(W)};P.registerOnDisabledChange(D),L._registerOnDestroy(()=>{P._unregisterOnDisabledChange(D)})}}(P,L)}function k1(P,L){P.forEach(D=>{D.registerOnValidatorChange&&D.registerOnValidatorChange(L)})}function Yi(P,L){P._pendingDirty&&P.markAsDirty(),P.setValue(P._pendingValue,{emitModelToViewChange:!1}),L.viewToModelUpdate(P._pendingValue),P._pendingChange=!1}function wt(P,L){const D=P.indexOf(L);D>-1&&P.splice(D,1)}const x1="VALID",$t="INVALID",P1="PENDING",M1="DISABLED";function Ft(P){return(qt(P)?P.validators:P)||null}function mn(P){return Array.isArray(P)?Bt(P):P||null}function bt(P,L){return(qt(L)?L.asyncValidators:P)||null}function Ai(P){return Array.isArray(P)?zt(P):P||null}function qt(P){return null!=P&&!Array.isArray(P)&&"object"==typeof P}const Gn=P=>P instanceof J1;function v1(P){return(P=>P instanceof n1)(P)?P.value:P.getRawValue()}function We(P,L){const D=Gn(P),W=P.controls;if(!(D?Object.keys(W):W).length)throw new M.vHH(1e3,"");if(!W[L])throw new M.vHH(1001,"")}function wn(P,L){Gn(P),P._forEachChild((W,je)=>{if(void 0===L[je])throw new M.vHH(1002,"")})}class mi{constructor(L,D){this._pendingDirty=!1,this._hasOwnPendingAsyncValidator=!1,this._pendingTouched=!1,this._onCollectionChange=()=>{},this._parent=null,this.pristine=!0,this.touched=!1,this._onDisabledChange=[],this._rawValidators=L,this._rawAsyncValidators=D,this._composedValidatorFn=mn(this._rawValidators),this._composedAsyncValidatorFn=Ai(this._rawAsyncValidators)}get validator(){return this._composedValidatorFn}set validator(L){this._rawValidators=this._composedValidatorFn=L}get asyncValidator(){return this._composedAsyncValidatorFn}set asyncValidator(L){this._rawAsyncValidators=this._composedAsyncValidatorFn=L}get parent(){return this._parent}get valid(){return this.status===x1}get invalid(){return this.status===$t}get pending(){return this.status==P1}get disabled(){return this.status===M1}get enabled(){return this.status!==M1}get dirty(){return!this.pristine}get untouched(){return!this.touched}get updateOn(){return this._updateOn?this._updateOn:this.parent?this.parent.updateOn:"change"}setValidators(L){this._rawValidators=L,this._composedValidatorFn=mn(L)}setAsyncValidators(L){this._rawAsyncValidators=L,this._composedAsyncValidatorFn=Ai(L)}addValidators(L){this.setValidators(pi(L,this._rawValidators))}addAsyncValidators(L){this.setAsyncValidators(pi(L,this._rawAsyncValidators))}removeValidators(L){this.setValidators(Xi(L,this._rawValidators))}removeAsyncValidators(L){this.setAsyncValidators(Xi(L,this._rawAsyncValidators))}hasValidator(L){return qn(this._rawValidators,L)}hasAsyncValidator(L){return qn(this._rawAsyncValidators,L)}clearValidators(){this.validator=null}clearAsyncValidators(){this.asyncValidator=null}markAsTouched(L={}){this.touched=!0,this._parent&&!L.onlySelf&&this._parent.markAsTouched(L)}markAllAsTouched(){this.markAsTouched({onlySelf:!0}),this._forEachChild(L=>L.markAllAsTouched())}markAsUntouched(L={}){this.touched=!1,this._pendingTouched=!1,this._forEachChild(D=>{D.markAsUntouched({onlySelf:!0})}),this._parent&&!L.onlySelf&&this._parent._updateTouched(L)}markAsDirty(L={}){this.pristine=!1,this._parent&&!L.onlySelf&&this._parent.markAsDirty(L)}markAsPristine(L={}){this.pristine=!0,this._pendingDirty=!1,this._forEachChild(D=>{D.markAsPristine({onlySelf:!0})}),this._parent&&!L.onlySelf&&this._parent._updatePristine(L)}markAsPending(L={}){this.status=P1,!1!==L.emitEvent&&this.statusChanges.emit(this.status),this._parent&&!L.onlySelf&&this._parent.markAsPending(L)}disable(L={}){const D=this._parentMarkedDirty(L.onlySelf);this.status=M1,this.errors=null,this._forEachChild(W=>{W.disable(Object.assign(Object.assign({},L),{onlySelf:!0}))}),this._updateValue(),!1!==L.emitEvent&&(this.valueChanges.emit(this.value),this.statusChanges.emit(this.status)),this._updateAncestors(Object.assign(Object.assign({},L),{skipPristineCheck:D})),this._onDisabledChange.forEach(W=>W(!0))}enable(L={}){const D=this._parentMarkedDirty(L.onlySelf);this.status=x1,this._forEachChild(W=>{W.enable(Object.assign(Object.assign({},L),{onlySelf:!0}))}),this.updateValueAndValidity({onlySelf:!0,emitEvent:L.emitEvent}),this._updateAncestors(Object.assign(Object.assign({},L),{skipPristineCheck:D})),this._onDisabledChange.forEach(W=>W(!1))}_updateAncestors(L){this._parent&&!L.onlySelf&&(this._parent.updateValueAndValidity(L),L.skipPristineCheck||this._parent._updatePristine(),this._parent._updateTouched())}setParent(L){this._parent=L}updateValueAndValidity(L={}){this._setInitialStatus(),this._updateValue(),this.enabled&&(this._cancelExistingSubscription(),this.errors=this._runValidator(),this.status=this._calculateStatus(),(this.status===x1||this.status===P1)&&this._runAsyncValidator(L.emitEvent)),!1!==L.emitEvent&&(this.valueChanges.emit(this.value),this.statusChanges.emit(this.status)),this._parent&&!L.onlySelf&&this._parent.updateValueAndValidity(L)}_updateTreeValidity(L={emitEvent:!0}){this._forEachChild(D=>D._updateTreeValidity(L)),this.updateValueAndValidity({onlySelf:!0,emitEvent:L.emitEvent})}_setInitialStatus(){this.status=this._allControlsDisabled()?M1:x1}_runValidator(){return this.validator?this.validator(this):null}_runAsyncValidator(L){if(this.asyncValidator){this.status=P1,this._hasOwnPendingAsyncValidator=!0;const D=Xe(this.asyncValidator(this));this._asyncValidationSubscription=D.subscribe(W=>{this._hasOwnPendingAsyncValidator=!1,this.setErrors(W,{emitEvent:L})})}}_cancelExistingSubscription(){this._asyncValidationSubscription&&(this._asyncValidationSubscription.unsubscribe(),this._hasOwnPendingAsyncValidator=!1)}setErrors(L,D={}){this.errors=L,this._updateControlsErrors(!1!==D.emitEvent)}get(L){return function Ei(P,L,D){if(null==L||(Array.isArray(L)||(L=L.split(D)),Array.isArray(L)&&0===L.length))return null;let W=P;return L.forEach(je=>{W=Gn(W)?W.controls.hasOwnProperty(je)?W.controls[je]:null:(P=>P instanceof d1)(W)&&W.at(je)||null}),W}(this,L,".")}getError(L,D){const W=D?this.get(D):this;return W&&W.errors?W.errors[L]:null}hasError(L,D){return!!this.getError(L,D)}get root(){let L=this;for(;L._parent;)L=L._parent;return L}_updateControlsErrors(L){this.status=this._calculateStatus(),L&&this.statusChanges.emit(this.status),this._parent&&this._parent._updateControlsErrors(L)}_initObservables(){this.valueChanges=new M.vpe,this.statusChanges=new M.vpe}_calculateStatus(){return this._allControlsDisabled()?M1:this.errors?$t:this._hasOwnPendingAsyncValidator||this._anyControlsHaveStatus(P1)?P1:this._anyControlsHaveStatus($t)?$t:x1}_anyControlsHaveStatus(L){return this._anyControls(D=>D.status===L)}_anyControlsDirty(){return this._anyControls(L=>L.dirty)}_anyControlsTouched(){return this._anyControls(L=>L.touched)}_updatePristine(L={}){this.pristine=!this._anyControlsDirty(),this._parent&&!L.onlySelf&&this._parent._updatePristine(L)}_updateTouched(L={}){this.touched=this._anyControlsTouched(),this._parent&&!L.onlySelf&&this._parent._updateTouched(L)}_isBoxedValue(L){return"object"==typeof L&&null!==L&&2===Object.keys(L).length&&"value"in L&&"disabled"in L}_registerOnCollectionChange(L){this._onCollectionChange=L}_setUpdateStrategy(L){qt(L)&&null!=L.updateOn&&(this._updateOn=L.updateOn)}_parentMarkedDirty(L){return!L&&!(!this._parent||!this._parent.dirty)&&!this._parent._anyControlsDirty()}}class n1 extends mi{constructor(L=null,D,W){super(Ft(D),bt(W,D)),this.defaultValue=null,this._onChange=[],this._pendingChange=!1,this._applyFormState(L),this._setUpdateStrategy(D),this._initObservables(),this.updateValueAndValidity({onlySelf:!0,emitEvent:!!this.asyncValidator}),qt(D)&&D.initialValueIsDefault&&(this.defaultValue=this._isBoxedValue(L)?L.value:L)}setValue(L,D={}){this.value=this._pendingValue=L,this._onChange.length&&!1!==D.emitModelToViewChange&&this._onChange.forEach(W=>W(this.value,!1!==D.emitViewToModelChange)),this.updateValueAndValidity(D)}patchValue(L,D={}){this.setValue(L,D)}reset(L=this.defaultValue,D={}){this._applyFormState(L),this.markAsPristine(D),this.markAsUntouched(D),this.setValue(this.value,D),this._pendingChange=!1}_updateValue(){}_anyControls(L){return!1}_allControlsDisabled(){return this.disabled}registerOnChange(L){this._onChange.push(L)}_unregisterOnChange(L){wt(this._onChange,L)}registerOnDisabledChange(L){this._onDisabledChange.push(L)}_unregisterOnDisabledChange(L){wt(this._onDisabledChange,L)}_forEachChild(L){}_syncPendingControls(){return!("submit"!==this.updateOn||(this._pendingDirty&&this.markAsDirty(),this._pendingTouched&&this.markAsTouched(),!this._pendingChange)||(this.setValue(this._pendingValue,{onlySelf:!0,emitModelToViewChange:!1}),0))}_applyFormState(L){this._isBoxedValue(L)?(this.value=this._pendingValue=L.value,L.disabled?this.disable({onlySelf:!0,emitEvent:!1}):this.enable({onlySelf:!0,emitEvent:!1})):this.value=this._pendingValue=L}}class J1 extends mi{constructor(L,D,W){super(Ft(D),bt(W,D)),this.controls=L,this._initObservables(),this._setUpdateStrategy(D),this._setUpControls(),this.updateValueAndValidity({onlySelf:!0,emitEvent:!!this.asyncValidator})}registerControl(L,D){return this.controls[L]?this.controls[L]:(this.controls[L]=D,D.setParent(this),D._registerOnCollectionChange(this._onCollectionChange),D)}addControl(L,D,W={}){this.registerControl(L,D),this.updateValueAndValidity({emitEvent:W.emitEvent}),this._onCollectionChange()}removeControl(L,D={}){this.controls[L]&&this.controls[L]._registerOnCollectionChange(()=>{}),delete this.controls[L],this.updateValueAndValidity({emitEvent:D.emitEvent}),this._onCollectionChange()}setControl(L,D,W={}){this.controls[L]&&this.controls[L]._registerOnCollectionChange(()=>{}),delete this.controls[L],D&&this.registerControl(L,D),this.updateValueAndValidity({emitEvent:W.emitEvent}),this._onCollectionChange()}contains(L){return this.controls.hasOwnProperty(L)&&this.controls[L].enabled}setValue(L,D={}){wn(this,L),Object.keys(L).forEach(W=>{We(this,W),this.controls[W].setValue(L[W],{onlySelf:!0,emitEvent:D.emitEvent})}),this.updateValueAndValidity(D)}patchValue(L,D={}){null!=L&&(Object.keys(L).forEach(W=>{this.controls[W]&&this.controls[W].patchValue(L[W],{onlySelf:!0,emitEvent:D.emitEvent})}),this.updateValueAndValidity(D))}reset(L={},D={}){this._forEachChild((W,je)=>{W.reset(L[je],{onlySelf:!0,emitEvent:D.emitEvent})}),this._updatePristine(D),this._updateTouched(D),this.updateValueAndValidity(D)}getRawValue(){return this._reduceChildren({},(L,D,W)=>(L[W]=v1(D),L))}_syncPendingControls(){let L=this._reduceChildren(!1,(D,W)=>!!W._syncPendingControls()||D);return L&&this.updateValueAndValidity({onlySelf:!0}),L}_forEachChild(L){Object.keys(this.controls).forEach(D=>{const W=this.controls[D];W&&L(W,D)})}_setUpControls(){this._forEachChild(L=>{L.setParent(this),L._registerOnCollectionChange(this._onCollectionChange)})}_updateValue(){this.value=this._reduceValue()}_anyControls(L){for(const D of Object.keys(this.controls)){const W=this.controls[D];if(this.contains(D)&&L(W))return!0}return!1}_reduceValue(){return this._reduceChildren({},(L,D,W)=>((D.enabled||this.disabled)&&(L[W]=D.value),L))}_reduceChildren(L,D){let W=L;return this._forEachChild((je,$e)=>{W=D(W,je,$e)}),W}_allControlsDisabled(){for(const L of Object.keys(this.controls))if(this.controls[L].enabled)return!1;return Object.keys(this.controls).length>0||this.disabled}}class d1 extends mi{constructor(L,D,W){super(Ft(D),bt(W,D)),this.controls=L,this._initObservables(),this._setUpdateStrategy(D),this._setUpControls(),this.updateValueAndValidity({onlySelf:!0,emitEvent:!!this.asyncValidator})}at(L){return this.controls[L]}push(L,D={}){this.controls.push(L),this._registerControl(L),this.updateValueAndValidity({emitEvent:D.emitEvent}),this._onCollectionChange()}insert(L,D,W={}){this.controls.splice(L,0,D),this._registerControl(D),this.updateValueAndValidity({emitEvent:W.emitEvent})}removeAt(L,D={}){this.controls[L]&&this.controls[L]._registerOnCollectionChange(()=>{}),this.controls.splice(L,1),this.updateValueAndValidity({emitEvent:D.emitEvent})}setControl(L,D,W={}){this.controls[L]&&this.controls[L]._registerOnCollectionChange(()=>{}),this.controls.splice(L,1),D&&(this.controls.splice(L,0,D),this._registerControl(D)),this.updateValueAndValidity({emitEvent:W.emitEvent}),this._onCollectionChange()}get length(){return this.controls.length}setValue(L,D={}){wn(this,L),L.forEach((W,je)=>{We(this,je),this.at(je).setValue(W,{onlySelf:!0,emitEvent:D.emitEvent})}),this.updateValueAndValidity(D)}patchValue(L,D={}){null!=L&&(L.forEach((W,je)=>{this.at(je)&&this.at(je).patchValue(W,{onlySelf:!0,emitEvent:D.emitEvent})}),this.updateValueAndValidity(D))}reset(L=[],D={}){this._forEachChild((W,je)=>{W.reset(L[je],{onlySelf:!0,emitEvent:D.emitEvent})}),this._updatePristine(D),this._updateTouched(D),this.updateValueAndValidity(D)}getRawValue(){return this.controls.map(L=>v1(L))}clear(L={}){this.controls.length<1||(this._forEachChild(D=>D._registerOnCollectionChange(()=>{})),this.controls.splice(0),this.updateValueAndValidity({emitEvent:L.emitEvent}))}_syncPendingControls(){let L=this.controls.reduce((D,W)=>!!W._syncPendingControls()||D,!1);return L&&this.updateValueAndValidity({onlySelf:!0}),L}_forEachChild(L){this.controls.forEach((D,W)=>{L(D,W)})}_updateValue(){this.value=this.controls.filter(L=>L.enabled||this.disabled).map(L=>L.value)}_anyControls(L){return this.controls.some(D=>D.enabled&&L(D))}_setUpControls(){this._forEachChild(L=>this._registerControl(L))}_allControlsDisabled(){for(const L of this.controls)if(L.enabled)return!1;return this.controls.length>0||this.disabled}_registerControl(L){L.setParent(this),L._registerOnCollectionChange(this._onCollectionChange)}}const Ar={provide:Gt,useExisting:(0,M.Gpc)(()=>u1)},qa=(()=>Promise.resolve(null))();let u1=(()=>{class P extends Gt{constructor(D,W,je,$e,A1){super(),this._changeDetectorRef=A1,this.control=new n1,this._registered=!1,this.update=new M.vpe,this._parent=D,this._setValidators(W),this._setAsyncValidators(je),this.valueAccessor=function it(P,L){if(!L)return null;let D,W,je;return Array.isArray(L),L.forEach($e=>{$e.constructor===ot?D=$e:function Re(P){return Object.getPrototypeOf(P.constructor)===pe}($e)?W=$e:je=$e}),je||W||D||null}(0,$e)}ngOnChanges(D){if(this._checkForErrors(),!this._registered||"name"in D){if(this._registered&&(this._checkName(),this.formDirective)){const W=D.name.previousValue;this.formDirective.removeControl({name:W,path:this._getPath(W)})}this._setUpControl()}"isDisabled"in D&&this._updateDisabled(D),function xe(P,L){if(!P.hasOwnProperty("model"))return!1;const D=P.model;return!!D.isFirstChange()||!Object.is(L,D.currentValue)}(D,this.viewModel)&&(this._updateValue(this.model),this.viewModel=this.model)}ngOnDestroy(){this.formDirective&&this.formDirective.removeControl(this)}get path(){return this._getPath(this.name)}get formDirective(){return this._parent?this._parent.formDirective:null}viewToModelUpdate(D){this.viewModel=D,this.update.emit(D)}_setUpControl(){this._setUpdateStrategy(),this._isStandalone()?this._setUpStandalone():this.formDirective.addControl(this),this._registered=!0}_setUpdateStrategy(){this.options&&null!=this.options.updateOn&&(this.control._updateOn=this.options.updateOn)}_isStandalone(){return!this._parent||!(!this.options||!this.options.standalone)}_setUpStandalone(){m1(this.control,this),this.control.updateValueAndValidity({emitEvent:!1})}_checkForErrors(){this._isStandalone()||this._checkParentType(),this._checkName()}_checkParentType(){}_checkName(){this.options&&this.options.name&&(this.name=this.options.name),this._isStandalone()}_updateValue(D){qa.then(()=>{var W;this.control.setValue(D,{emitViewToModelChange:!1}),null===(W=this._changeDetectorRef)||void 0===W||W.markForCheck()})}_updateDisabled(D){const W=D.isDisabled.currentValue,je=""===W||W&&"false"!==W;qa.then(()=>{var $e;je&&!this.control.disabled?this.control.disable():!je&&this.control.disabled&&this.control.enable(),null===($e=this._changeDetectorRef)||void 0===$e||$e.markForCheck()})}_getPath(D){return this._parent?function _1(P,L){return[...L.path,P]}(D,this._parent):[D]}}return P.\u0275fac=function(D){return new(D||P)(M.Y36(a1,9),M.Y36(ut,10),M.Y36(cn,10),M.Y36(Me,10),M.Y36(M.sBO,8))},P.\u0275dir=M.lG2({type:P,selectors:[["","ngModel","",3,"formControlName","",3,"formControl",""]],inputs:{name:"name",isDisabled:["disabled","isDisabled"],model:["ngModel","model"],options:["ngModelOptions","options"]},outputs:{update:"ngModelChange"},exportAs:["ngModel"],features:[M._Bn([Ar]),M.qOj,M.TTD]}),P})(),Ea=(()=>{class P{}return P.\u0275fac=function(D){return new(D||P)},P.\u0275mod=M.oAB({type:P}),P.\u0275inj=M.cJS({}),P})();const Aa=new M.OlP("NgModelWithFormControlWarning");let kn=(()=>{class P{}return P.\u0275fac=function(D){return new(D||P)},P.\u0275mod=M.oAB({type:P}),P.\u0275inj=M.cJS({imports:[[Ea]]}),P})(),c1=(()=>{class P{}return P.\u0275fac=function(D){return new(D||P)},P.\u0275mod=M.oAB({type:P}),P.\u0275inj=M.cJS({imports:[kn]}),P})(),Jn=(()=>{class P{static withConfig(D){return{ngModule:P,providers:[{provide:Aa,useValue:D.warnOnNgModelWithFormControl}]}}}return P.\u0275fac=function(D){return new(D||P)},P.\u0275mod=M.oAB({type:P}),P.\u0275inj=M.cJS({imports:[kn]}),P})()},2313:(Xn,He,Q)=>{"use strict";Q.d(He,{b2:()=>j1,H7:()=>r1,q6:()=>pi,se:()=>Le});var M=Q(9808),d=Q(6435);class Ue extends M.w_{constructor(){super(...arguments),this.supportsDOMEvents=!0}}class Oe extends Ue{static makeCurrent(){(0,M.HT)(new Oe)}onAndCancel(de,ee,xe){return de.addEventListener(ee,xe,!1),()=>{de.removeEventListener(ee,xe,!1)}}dispatchEvent(de,ee){de.dispatchEvent(ee)}remove(de){de.parentNode&&de.parentNode.removeChild(de)}createElement(de,ee){return(ee=ee||this.getDefaultDocument()).createElement(de)}createHtmlDocument(){return document.implementation.createHTMLDocument("fakeTitle")}getDefaultDocument(){return document}isElementNode(de){return de.nodeType===Node.ELEMENT_NODE}isShadowRoot(de){return de instanceof DocumentFragment}getGlobalEventTarget(de,ee){return"window"===ee?window:"document"===ee?de:"body"===ee?de.body:null}getBaseHref(de){const ee=function he(){return ye=ye||document.querySelector("base"),ye?ye.getAttribute("href"):null}();return null==ee?null:function ce(we){oe=oe||document.createElement("a"),oe.setAttribute("href",we);const de=oe.pathname;return"/"===de.charAt(0)?de:`/${de}`}(ee)}resetBaseElement(){ye=null}getUserAgent(){return window.navigator.userAgent}getCookie(de){return(0,M.Mx)(document.cookie,de)}}let oe,ye=null;const fe=new d.OlP("TRANSITION_ID"),pe=[{provide:d.ip1,useFactory:function le(we,de,ee){return()=>{ee.get(d.CZH).donePromise.then(()=>{const xe=(0,M.q)(),Re=de.querySelectorAll(`style[ng-transition="${we}"]`);for(let Vn=0;Vn<Re.length;Vn++)xe.remove(Re[Vn])})}},deps:[fe,M.K0,d.zs3],multi:!0}];class Me{static init(){(0,d.VLi)(new Me)}addToWindow(de){d.dqk.getAngularTestability=(xe,Re=!0)=>{const Vn=de.findTestabilityInTree(xe,Re);if(null==Vn)throw new Error("Could not find testability for element.");return Vn},d.dqk.getAllAngularTestabilities=()=>de.getAllTestabilities(),d.dqk.getAllAngularRootElements=()=>de.getAllRootElements(),d.dqk.frameworkStabilizers||(d.dqk.frameworkStabilizers=[]),d.dqk.frameworkStabilizers.push(xe=>{const Re=d.dqk.getAllAngularTestabilities();let Vn=Re.length,it=!1;const wt=function(Sn){it=it||Sn,Vn--,0==Vn&&xe(it)};Re.forEach(function(Sn){Sn.whenStable(wt)})})}findTestabilityInTree(de,ee,xe){if(null==ee)return null;const Re=de.getTestability(ee);return null!=Re?Re:xe?(0,M.q)().isShadowRoot(ee)?this.findTestabilityInTree(de,ee.host,!0):this.findTestabilityInTree(de,ee.parentElement,!0):null}}let Ae=(()=>{class we{build(){return new XMLHttpRequest}}return we.\u0275fac=function(ee){return new(ee||we)},we.\u0275prov=d.Yz7({token:we,factory:we.\u0275fac}),we})();const dn=new d.OlP("EventManagerPlugins");let rn=(()=>{class we{constructor(ee,xe){this._zone=xe,this._eventNameToPlugin=new Map,ee.forEach(Re=>Re.manager=this),this._plugins=ee.slice().reverse()}addEventListener(ee,xe,Re){return this._findPluginFor(xe).addEventListener(ee,xe,Re)}addGlobalEventListener(ee,xe,Re){return this._findPluginFor(xe).addGlobalEventListener(ee,xe,Re)}getZone(){return this._zone}_findPluginFor(ee){const xe=this._eventNameToPlugin.get(ee);if(xe)return xe;const Re=this._plugins;for(let Vn=0;Vn<Re.length;Vn++){const it=Re[Vn];if(it.supports(ee))return this._eventNameToPlugin.set(ee,it),it}throw new Error(`No event manager plugin found for event ${ee}`)}}return we.\u0275fac=function(ee){return new(ee||we)(d.LFG(dn),d.LFG(d.R0b))},we.\u0275prov=d.Yz7({token:we,factory:we.\u0275fac}),we})();class Ke{constructor(de){this._doc=de}addGlobalEventListener(de,ee,xe){const Re=(0,M.q)().getGlobalEventTarget(this._doc,de);if(!Re)throw new Error(`Unsupported event target ${Re} for event ${ee}`);return this.addEventListener(Re,ee,xe)}}let Qe=(()=>{class we{constructor(){this._stylesSet=new Set}addStyles(ee){const xe=new Set;ee.forEach(Re=>{this._stylesSet.has(Re)||(this._stylesSet.add(Re),xe.add(Re))}),this.onStylesAdded(xe)}onStylesAdded(ee){}getAllStyles(){return Array.from(this._stylesSet)}}return we.\u0275fac=function(ee){return new(ee||we)},we.\u0275prov=d.Yz7({token:we,factory:we.\u0275fac}),we})(),ot=(()=>{class we extends Qe{constructor(ee){super(),this._doc=ee,this._hostNodes=new Map,this._hostNodes.set(ee.head,[])}_addStylesToHost(ee,xe,Re){ee.forEach(Vn=>{const it=this._doc.createElement("style");it.textContent=Vn,Re.push(xe.appendChild(it))})}addHost(ee){const xe=[];this._addStylesToHost(this._stylesSet,ee,xe),this._hostNodes.set(ee,xe)}removeHost(ee){const xe=this._hostNodes.get(ee);xe&&xe.forEach(Dn),this._hostNodes.delete(ee)}onStylesAdded(ee){this._hostNodes.forEach((xe,Re)=>{this._addStylesToHost(ee,Re,xe)})}ngOnDestroy(){this._hostNodes.forEach(ee=>ee.forEach(Dn))}}return we.\u0275fac=function(ee){return new(ee||we)(d.LFG(M.K0))},we.\u0275prov=d.Yz7({token:we,factory:we.\u0275fac}),we})();function Dn(we){(0,M.q)().remove(we)}const yn={svg:"http://www.w3.org/2000/svg",xhtml:"http://www.w3.org/1999/xhtml",xlink:"http://www.w3.org/1999/xlink",xml:"http://www.w3.org/XML/1998/namespace",xmlns:"http://www.w3.org/2000/xmlns/",math:"http://www.w3.org/1998/MathML/"},ut=/%COMP%/g;function Yn(we,de,ee){for(let xe=0;xe<de.length;xe++){let Re=de[xe];Array.isArray(Re)?Yn(we,Re,ee):(Re=Re.replace(ut,we),ee.push(Re))}return ee}function tt(we){return de=>{if("__ngUnwrap__"===de)return we;!1===we(de)&&(de.preventDefault(),de.returnValue=!1)}}let Le=(()=>{class we{constructor(ee,xe,Re){this.eventManager=ee,this.sharedStylesHost=xe,this.appId=Re,this.rendererByCompId=new Map,this.defaultRenderer=new De(ee)}createRenderer(ee,xe){if(!ee||!xe)return this.defaultRenderer;switch(xe.encapsulation){case d.ifc.Emulated:{let Re=this.rendererByCompId.get(xe.id);return Re||(Re=new Xe(this.eventManager,this.sharedStylesHost,xe,this.appId),this.rendererByCompId.set(xe.id,Re)),Re.applyToHost(ee),Re}case 1:case d.ifc.ShadowDom:return new En(this.eventManager,this.sharedStylesHost,ee,xe);default:if(!this.rendererByCompId.has(xe.id)){const Re=Yn(xe.id,xe.styles,[]);this.sharedStylesHost.addStyles(Re),this.rendererByCompId.set(xe.id,this.defaultRenderer)}return this.defaultRenderer}}begin(){}end(){}}return we.\u0275fac=function(ee){return new(ee||we)(d.LFG(rn),d.LFG(ot),d.LFG(d.AFp))},we.\u0275prov=d.Yz7({token:we,factory:we.\u0275fac}),we})();class De{constructor(de){this.eventManager=de,this.data=Object.create(null),this.destroyNode=null}destroy(){}createElement(de,ee){return ee?document.createElementNS(yn[ee]||ee,de):document.createElement(de)}createComment(de){return document.createComment(de)}createText(de){return document.createTextNode(de)}appendChild(de,ee){de.appendChild(ee)}insertBefore(de,ee,xe){de&&de.insertBefore(ee,xe)}removeChild(de,ee){de&&de.removeChild(ee)}selectRootElement(de,ee){let xe="string"==typeof de?document.querySelector(de):de;if(!xe)throw new Error(`The selector "${de}" did not match any elements`);return ee||(xe.textContent=""),xe}parentNode(de){return de.parentNode}nextSibling(de){return de.nextSibling}setAttribute(de,ee,xe,Re){if(Re){ee=Re+":"+ee;const Vn=yn[Re];Vn?de.setAttributeNS(Vn,ee,xe):de.setAttribute(ee,xe)}else de.setAttribute(ee,xe)}removeAttribute(de,ee,xe){if(xe){const Re=yn[xe];Re?de.removeAttributeNS(Re,ee):de.removeAttribute(`${xe}:${ee}`)}else de.removeAttribute(ee)}addClass(de,ee){de.classList.add(ee)}removeClass(de,ee){de.classList.remove(ee)}setStyle(de,ee,xe,Re){Re&(d.JOm.DashCase|d.JOm.Important)?de.style.setProperty(ee,xe,Re&d.JOm.Important?"important":""):de.style[ee]=xe}removeStyle(de,ee,xe){xe&d.JOm.DashCase?de.style.removeProperty(ee):de.style[ee]=""}setProperty(de,ee,xe){de[ee]=xe}setValue(de,ee){de.nodeValue=ee}listen(de,ee,xe){return"string"==typeof de?this.eventManager.addGlobalEventListener(de,ee,tt(xe)):this.eventManager.addEventListener(de,ee,tt(xe))}}class Xe extends De{constructor(de,ee,xe,Re){super(de),this.component=xe;const Vn=Yn(Re+"-"+xe.id,xe.styles,[]);ee.addStyles(Vn),this.contentAttr=function l1(we){return"_ngcontent-%COMP%".replace(ut,we)}(Re+"-"+xe.id),this.hostAttr=function tn(we){return"_nghost-%COMP%".replace(ut,we)}(Re+"-"+xe.id)}applyToHost(de){super.setAttribute(de,this.hostAttr,"")}createElement(de,ee){const xe=super.createElement(de,ee);return super.setAttribute(xe,this.contentAttr,""),xe}}class En extends De{constructor(de,ee,xe,Re){super(de),this.sharedStylesHost=ee,this.hostEl=xe,this.shadowRoot=xe.attachShadow({mode:"open"}),this.sharedStylesHost.addHost(this.shadowRoot);const Vn=Yn(Re.id,Re.styles,[]);for(let it=0;it<Vn.length;it++){const wt=document.createElement("style");wt.textContent=Vn[it],this.shadowRoot.appendChild(wt)}}nodeOrShadowRoot(de){return de===this.hostEl?this.shadowRoot:de}destroy(){this.sharedStylesHost.removeHost(this.shadowRoot)}appendChild(de,ee){return super.appendChild(this.nodeOrShadowRoot(de),ee)}insertBefore(de,ee,xe){return super.insertBefore(this.nodeOrShadowRoot(de),ee,xe)}removeChild(de,ee){return super.removeChild(this.nodeOrShadowRoot(de),ee)}parentNode(de){return this.nodeOrShadowRoot(super.parentNode(this.nodeOrShadowRoot(de)))}}let Ln=(()=>{class we extends Ke{constructor(ee){super(ee)}supports(ee){return!0}addEventListener(ee,xe,Re){return ee.addEventListener(xe,Re,!1),()=>this.removeEventListener(ee,xe,Re)}removeEventListener(ee,xe,Re){return ee.removeEventListener(xe,Re)}}return we.\u0275fac=function(ee){return new(ee||we)(d.LFG(M.K0))},we.\u0275prov=d.Yz7({token:we,factory:we.\u0275fac}),we})();const lt=["alt","control","meta","shift"],Zi={"\b":"Backspace","\t":"Tab","\x7f":"Delete","\x1b":"Escape",Del:"Delete",Esc:"Escape",Left:"ArrowLeft",Right:"ArrowRight",Up:"ArrowUp",Down:"ArrowDown",Menu:"ContextMenu",Scroll:"ScrollLock",Win:"OS"},Bt={A:"1",B:"2",C:"3",D:"4",E:"5",F:"6",G:"7",H:"8",I:"9",J:"*",K:"+",M:"-",N:".",O:"/","`":"0","\x90":"NumLock"},st={alt:we=>we.altKey,control:we=>we.ctrlKey,meta:we=>we.metaKey,shift:we=>we.shiftKey};let zt=(()=>{class we extends Ke{constructor(ee){super(ee)}supports(ee){return null!=we.parseEventName(ee)}addEventListener(ee,xe,Re){const Vn=we.parseEventName(xe),it=we.eventCallback(Vn.fullKey,Re,this.manager.getZone());return this.manager.getZone().runOutsideAngular(()=>(0,M.q)().onAndCancel(ee,Vn.domEventName,it))}static parseEventName(ee){const xe=ee.toLowerCase().split("."),Re=xe.shift();if(0===xe.length||"keydown"!==Re&&"keyup"!==Re)return null;const Vn=we._normalizeKey(xe.pop());let it="";if(lt.forEach(Sn=>{const Zt=xe.indexOf(Sn);Zt>-1&&(xe.splice(Zt,1),it+=Sn+".")}),it+=Vn,0!=xe.length||0===Vn.length)return null;const wt={};return wt.domEventName=Re,wt.fullKey=it,wt}static getEventFullKey(ee){let xe="",Re=function Lt(we){let de=we.key;if(null==de){if(de=we.keyIdentifier,null==de)return"Unidentified";de.startsWith("U+")&&(de=String.fromCharCode(parseInt(de.substring(2),16)),3===we.location&&Bt.hasOwnProperty(de)&&(de=Bt[de]))}return Zi[de]||de}(ee);return Re=Re.toLowerCase()," "===Re?Re="space":"."===Re&&(Re="dot"),lt.forEach(Vn=>{Vn!=Re&&st[Vn](ee)&&(xe+=Vn+".")}),xe+=Re,xe}static eventCallback(ee,xe,Re){return Vn=>{we.getEventFullKey(Vn)===ee&&Re.runGuarded(()=>xe(Vn))}}static _normalizeKey(ee){return"esc"===ee?"escape":ee}}return we.\u0275fac=function(ee){return new(ee||we)(d.LFG(M.K0))},we.\u0275prov=d.Yz7({token:we,factory:we.\u0275fac}),we})();const pi=(0,d.eFA)(d._c5,"browser",[{provide:d.Lbi,useValue:M.bD},{provide:d.g9A,useValue:function $i(){Oe.makeCurrent(),Me.init()},multi:!0},{provide:M.K0,useFactory:function y1(){return(0,d.RDi)(document),document},deps:[]}]),Xi=[{provide:d.zSh,useValue:"root"},{provide:d.qLn,useFactory:function Ut(){return new d.qLn},deps:[]},{provide:dn,useClass:Ln,multi:!0,deps:[M.K0,d.R0b,d.Lbi]},{provide:dn,useClass:zt,multi:!0,deps:[M.K0]},{provide:Le,useClass:Le,deps:[rn,ot,d.AFp]},{provide:d.FYo,useExisting:Le},{provide:Qe,useExisting:ot},{provide:ot,useClass:ot,deps:[M.K0]},{provide:d.dDg,useClass:d.dDg,deps:[d.R0b]},{provide:rn,useClass:rn,deps:[dn,d.R0b]},{provide:M.JF,useClass:Ae,deps:[]}];let j1=(()=>{class we{constructor(ee){if(ee)throw new Error("BrowserModule has already been loaded. If you need access to common directives such as NgIf and NgFor from a lazy loaded module, import CommonModule instead.")}static withServerTransition(ee){return{ngModule:we,providers:[{provide:d.AFp,useValue:ee.appId},{provide:fe,useExisting:d.AFp},pe]}}}return we.\u0275fac=function(ee){return new(ee||we)(d.LFG(we,12))},we.\u0275mod=d.oAB({type:we}),we.\u0275inj=d.cJS({providers:Xi,imports:[M.ez,d.hGG]}),we})();"undefined"!=typeof window&&window;let r1=(()=>{class we{}return we.\u0275fac=function(ee){return new(ee||we)},we.\u0275prov=d.Yz7({token:we,factory:function(ee){let xe=null;return xe=ee?new(ee||we):d.LFG(za),xe},providedIn:"root"}),we})(),za=(()=>{class we extends r1{constructor(ee){super(),this._doc=ee}sanitize(ee,xe){if(null==xe)return null;switch(ee){case d.q3G.NONE:return xe;case d.q3G.HTML:return(0,d.qzn)(xe,"HTML")?(0,d.z3N)(xe):(0,d.EiD)(this._doc,String(xe)).toString();case d.q3G.STYLE:return(0,d.qzn)(xe,"Style")?(0,d.z3N)(xe):xe;case d.q3G.SCRIPT:if((0,d.qzn)(xe,"Script"))return(0,d.z3N)(xe);throw new Error("unsafe value used in a script context");case d.q3G.URL:return(0,d.yhl)(xe),(0,d.qzn)(xe,"URL")?(0,d.z3N)(xe):(0,d.mCW)(String(xe));case d.q3G.RESOURCE_URL:if((0,d.qzn)(xe,"ResourceURL"))return(0,d.z3N)(xe);throw new Error("unsafe value used in a resource URL context (see https://g.co/ng/security#xss)");default:throw new Error(`Unexpected SecurityContext ${ee} (see https://g.co/ng/security#xss)`)}}bypassSecurityTrustHtml(ee){return(0,d.JVY)(ee)}bypassSecurityTrustStyle(ee){return(0,d.L6k)(ee)}bypassSecurityTrustScript(ee){return(0,d.eBb)(ee)}bypassSecurityTrustUrl(ee){return(0,d.LAX)(ee)}bypassSecurityTrustResourceUrl(ee){return(0,d.pB0)(ee)}}return we.\u0275fac=function(ee){return new(ee||we)(d.LFG(M.K0))},we.\u0275prov=d.Yz7({token:we,factory:function(ee){let xe=null;return xe=ee?new ee:function Yi(we){return new za(we.get(M.K0))}(d.LFG(d.zs3)),xe},providedIn:"root"}),we})()},4366:(Xn,He,Q)=>{"use strict";Q.d(He,{gz:()=>u1,gk:()=>xt,m2:()=>q1,Q3:()=>Mi,OD:()=>a1,F0:()=>Bi,Od:()=>a2,yS:()=>C1,Bz:()=>Os,lC:()=>j});var M=Q(6435);const Ue=(()=>{function z(){return Error.call(this),this.message="no elements in sequence",this.name="EmptyError",this}return z.prototype=Object.create(Error.prototype),z})();var Oe=Q(2916),ye=Q(5254),he=Q(8896);function oe(z){return new Oe.y(x=>{let _;try{_=z()}catch(V){return void x.error(V)}return(_?(0,ye.D)(_):(0,he.c)()).subscribe(x)})}var ce=Q(1086),fe=Q(591),le=Q(6053),pe=Q(1737),Me=Q(1221),Ae=Q(1762),dn=Q(5529),rn=Q(3489);function Ke(z,x){let _=!1;return arguments.length>=2&&(_=!0),function(V){return V.lift(new Qe(z,x,_))}}class Qe{constructor(x,_,T=!1){this.accumulator=x,this.seed=_,this.hasSeed=T}call(x,_){return _.subscribe(new ot(x,this.accumulator,this.seed,this.hasSeed))}}class ot extends rn.L{constructor(x,_,T,V){super(x),this.accumulator=_,this._seed=T,this.hasSeed=V,this.index=0}get seed(){return this._seed}set seed(x){this.hasSeed=!0,this._seed=x}_next(x){if(this.hasSeed)return this._tryNext(x);this.seed=x,this.destination.next(x)}_tryNext(x){const _=this.index++;let T;try{T=this.accumulator(this.seed,x,_)}catch(V){this.destination.error(V)}this.seed=T,this.destination.next(T)}}var Dn=Q(1177);function yn(z){return function(_){const T=new ut(z),V=_.lift(T);return T.caught=V}}class ut{constructor(x){this.selector=x}call(x,_){return _.subscribe(new cn(x,this.selector,this.caught))}}class cn extends Dn.Ds{constructor(x,_,T){super(x),this.selector=_,this.caught=T}error(x){if(!this.isStopped){let _;try{_=this.selector(x,this.caught)}catch(G){return void super.error(G)}this._unsubscribeAndRecycle();const T=new Dn.IY(this);this.add(T);const V=(0,Dn.ft)(_,T);V!==T&&this.add(V)}}}var fn=Q(2198),g1=Q(4231);function mt(z){return function(_){return 0===z?(0,he.c)():_.lift(new l1(z))}}class l1{constructor(x){if(this.total=x,this.total<0)throw new g1.W}call(x,_){return _.subscribe(new tn(x,this.total))}}class tn extends rn.L{constructor(x,_){super(x),this.total=_,this.ring=new Array,this.count=0}_next(x){const _=this.ring,T=this.total,V=this.count++;_.length<T?_.push(x):_[V%T]=x}_complete(){const x=this.destination;let _=this.count;if(_>0){const T=this.count>=this.total?this.total:this.count,V=this.ring;for(let G=0;G<T;G++){const te=_++%T;x.next(V[te])}}x.complete()}}function Yn(z=Le){return x=>x.lift(new tt(z))}class tt{constructor(x){this.errorFactory=x}call(x,_){return _.subscribe(new Un(x,this.errorFactory))}}class Un extends rn.L{constructor(x,_){super(x),this.errorFactory=_,this.hasValue=!1}_next(x){this.hasValue=!0,this.destination.next(x)}_complete(){if(this.hasValue)return this.destination.complete();{let x;try{x=this.errorFactory()}catch(_){x=_}this.destination.error(x)}}}function Le(){return new Ue}function De(z=null){return x=>x.lift(new ge(z))}class ge{constructor(x){this.defaultValue=x}call(x,_){return _.subscribe(new me(x,this.defaultValue))}}class me extends rn.L{constructor(x,_){super(x),this.defaultValue=_,this.isEmpty=!0}_next(x){this.isEmpty=!1,this.destination.next(x)}_complete(){this.isEmpty&&this.destination.next(this.defaultValue),this.destination.complete()}}var Xe=Q(5379),Ln=Q(2986);function lt(z,x){const _=arguments.length>=2;return T=>T.pipe(z?(0,fn.h)((V,G)=>z(V,G,T)):Xe.y,(0,Ln.q)(1),_?De(x):Yn(()=>new Ue))}var Rt=Q(2654);class Bt{constructor(x){this.callback=x}call(x,_){return _.subscribe(new st(x,this.callback))}}class st extends rn.L{constructor(x,_){super(x),this.add(new Rt.w(_))}}var zt=Q(4850),Lt=Q(7545),$i=Q(1059),Ut=Q(1406),y1=Q(1709),qn=Q(2994),pi=Q(4327),Xi=Q(9146),j1=Q(9808);class Gt{constructor(x,_){this.id=x,this.url=_}}class a1 extends Gt{constructor(x,_,T="imperative",V=null){super(x,_),this.navigationTrigger=T,this.restoredState=V}toString(){return`NavigationStart(id: ${this.id}, url: '${this.url}')`}}class q1 extends Gt{constructor(x,_,T){super(x,_),this.urlAfterRedirects=T}toString(){return`NavigationEnd(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}')`}}class xt extends Gt{constructor(x,_,T){super(x,_),this.reason=T}toString(){return`NavigationCancel(id: ${this.id}, url: '${this.url}')`}}class Mi extends Gt{constructor(x,_,T){super(x,_),this.error=T}toString(){return`NavigationError(id: ${this.id}, url: '${this.url}', error: ${this.error})`}}class wa extends Gt{constructor(x,_,T,V){super(x,_),this.urlAfterRedirects=T,this.state=V}toString(){return`RoutesRecognized(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})`}}class $n extends Gt{constructor(x,_,T,V){super(x,_),this.urlAfterRedirects=T,this.state=V}toString(){return`GuardsCheckStart(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})`}}class wi extends Gt{constructor(x,_,T,V,G){super(x,_),this.urlAfterRedirects=T,this.state=V,this.shouldActivate=G}toString(){return`GuardsCheckEnd(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state}, shouldActivate: ${this.shouldActivate})`}}class Rn extends Gt{constructor(x,_,T,V){super(x,_),this.urlAfterRedirects=T,this.state=V}toString(){return`ResolveStart(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})`}}class xn extends Gt{constructor(x,_,T,V){super(x,_),this.urlAfterRedirects=T,this.state=V}toString(){return`ResolveEnd(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})`}}class _n{constructor(x){this.route=x}toString(){return`RouteConfigLoadStart(path: ${this.route.path})`}}class on{constructor(x){this.route=x}toString(){return`RouteConfigLoadEnd(path: ${this.route.path})`}}class ln{constructor(x){this.snapshot=x}toString(){return`ChildActivationStart(path: '${this.snapshot.routeConfig&&this.snapshot.routeConfig.path||""}')`}}class sn{constructor(x){this.snapshot=x}toString(){return`ChildActivationEnd(path: '${this.snapshot.routeConfig&&this.snapshot.routeConfig.path||""}')`}}class zi{constructor(x){this.snapshot=x}toString(){return`ActivationStart(path: '${this.snapshot.routeConfig&&this.snapshot.routeConfig.path||""}')`}}class jn{constructor(x){this.snapshot=x}toString(){return`ActivationEnd(path: '${this.snapshot.routeConfig&&this.snapshot.routeConfig.path||""}')`}}class Nt{constructor(x,_,T){this.routerEvent=x,this.position=_,this.anchor=T}toString(){return`Scroll(anchor: '${this.anchor}', position: '${this.position?`${this.position[0]}, ${this.position[1]}`:null}')`}}const On="primary";class ht{constructor(x){this.params=x||{}}has(x){return Object.prototype.hasOwnProperty.call(this.params,x)}get(x){if(this.has(x)){const _=this.params[x];return Array.isArray(_)?_[0]:_}return null}getAll(x){if(this.has(x)){const _=this.params[x];return Array.isArray(_)?_:[_]}return[]}get keys(){return Object.keys(this.params)}}function Wt(z){return new ht(z)}const e1="ngNavigationCancelingError";function gt(z){const x=Error("NavigationCancelingError: "+z);return x[e1]=!0,x}function _1(z,x,_){const T=_.path.split("/");if(T.length>z.length||"full"===_.pathMatch&&(x.hasChildren()||T.length<z.length))return null;const V={};for(let G=0;G<T.length;G++){const te=T[G],se=z[G];if(te.startsWith(":"))V[te.substring(1)]=se;else if(te!==se.path)return null}return{consumed:z.slice(0,T.length),posParams:V}}function et(z,x){const _=z?Object.keys(z):void 0,T=x?Object.keys(x):void 0;if(!_||!T||_.length!=T.length)return!1;let V;for(let G=0;G<_.length;G++)if(V=_[G],!k1(z[V],x[V]))return!1;return!0}function k1(z,x){if(Array.isArray(z)&&Array.isArray(x)){if(z.length!==x.length)return!1;const _=[...z].sort(),T=[...x].sort();return _.every((V,G)=>T[G]===V)}return z===x}function ma(z){return Array.prototype.concat.apply([],z)}function Ni(z){return z.length>0?z[z.length-1]:null}function kt(z,x){for(const _ in z)z.hasOwnProperty(_)&&x(z[_],_)}function r1(z){return(0,M.CqO)(z)?z:(0,M.QGY)(z)?(0,ye.D)(Promise.resolve(z)):(0,ce.of)(z)}const za={exact:function ee(z,x,_){if(!$t(z.segments,x.segments)||!it(z.segments,x.segments,_)||z.numberOfChildren!==x.numberOfChildren)return!1;for(const T in x.children)if(!z.children[T]||!ee(z.children[T],x.children[T],_))return!1;return!0},subset:Re},Na={exact:function de(z,x){return et(z,x)},subset:function xe(z,x){return Object.keys(x).length<=Object.keys(z).length&&Object.keys(x).every(_=>k1(z[_],x[_]))},ignored:()=>!0};function we(z,x,_){return za[_.paths](z.root,x.root,_.matrixParams)&&Na[_.queryParams](z.queryParams,x.queryParams)&&!("exact"===_.fragment&&z.fragment!==x.fragment)}function Re(z,x,_){return Vn(z,x,x.segments,_)}function Vn(z,x,_,T){if(z.segments.length>_.length){const V=z.segments.slice(0,_.length);return!(!$t(V,_)||x.hasChildren()||!it(V,_,T))}if(z.segments.length===_.length){if(!$t(z.segments,_)||!it(z.segments,_,T))return!1;for(const V in x.children)if(!z.children[V]||!Re(z.children[V],x.children[V],T))return!1;return!0}{const V=_.slice(0,z.segments.length),G=_.slice(z.segments.length);return!!($t(z.segments,V)&&it(z.segments,V,T)&&z.children[On])&&Vn(z.children[On],x,G,T)}}function it(z,x,_){return x.every((T,V)=>Na[_](z[V].parameters,T.parameters))}class wt{constructor(x,_,T){this.root=x,this.queryParams=_,this.fragment=T}get queryParamMap(){return this._queryParamMap||(this._queryParamMap=Wt(this.queryParams)),this._queryParamMap}toString(){return Ft.serialize(this)}}class Sn{constructor(x,_){this.segments=x,this.children=_,this.parent=null,kt(_,(T,V)=>T.parent=this)}hasChildren(){return this.numberOfChildren>0}get numberOfChildren(){return Object.keys(this.children).length}toString(){return mn(this)}}class Zt{constructor(x,_){this.path=x,this.parameters=_}get parameterMap(){return this._parameterMap||(this._parameterMap=Wt(this.parameters)),this._parameterMap}toString(){return We(this)}}function $t(z,x){return z.length===x.length&&z.every((_,T)=>_.path===x[T].path)}class M1{}class Ei{parse(x){const _=new ha(x);return new wt(_.parseRootSegment(),_.parseQueryParams(),_.parseFragment())}serialize(x){const _=`/${bt(x.root,!0)}`,T=function mi(z){const x=Object.keys(z).map(_=>{const T=z[_];return Array.isArray(T)?T.map(V=>`${qt(_)}=${qt(V)}`).join("&"):`${qt(_)}=${qt(T)}`}).filter(_=>!!_);return x.length?`?${x.join("&")}`:""}(x.queryParams);return`${_}${T}${"string"==typeof x.fragment?`#${function Ze(z){return encodeURI(z)}(x.fragment)}`:""}`}}const Ft=new Ei;function mn(z){return z.segments.map(x=>We(x)).join("/")}function bt(z,x){if(!z.hasChildren())return mn(z);if(x){const _=z.children[On]?bt(z.children[On],!1):"",T=[];return kt(z.children,(V,G)=>{G!==On&&T.push(`${G}:${bt(V,!1)}`)}),T.length>0?`${_}(${T.join("//")})`:_}{const _=function P1(z,x){let _=[];return kt(z.children,(T,V)=>{V===On&&(_=_.concat(x(T,V)))}),kt(z.children,(T,V)=>{V!==On&&(_=_.concat(x(T,V)))}),_}(z,(T,V)=>V===On?[bt(z.children[On],!1)]:[`${V}:${bt(T,!1)}`]);return 1===Object.keys(z.children).length&&null!=z.children[On]?`${mn(z)}/${_[0]}`:`${mn(z)}/(${_.join("//")})`}}function Ai(z){return encodeURIComponent(z).replace(/%40/g,"@").replace(/%3A/gi,":").replace(/%24/g,"$").replace(/%2C/gi,",")}function qt(z){return Ai(z).replace(/%3B/gi,";")}function Gn(z){return Ai(z).replace(/\(/g,"%28").replace(/\)/g,"%29").replace(/%26/gi,"&")}function yt(z){return decodeURIComponent(z)}function v1(z){return yt(z.replace(/\+/g,"%20"))}function We(z){return`${Gn(z.path)}${function wn(z){return Object.keys(z).map(x=>`;${Gn(x)}=${Gn(z[x])}`).join("")}(z.parameters)}`}const n1=/^[^\/()?;=#]+/;function J1(z){const x=z.match(n1);return x?x[0]:""}const d1=/^[^=?&#]+/,Pn=/^[^&#]+/;class ha{constructor(x){this.url=x,this.remaining=x}parseRootSegment(){return this.consumeOptional("/"),""===this.remaining||this.peekStartsWith("?")||this.peekStartsWith("#")?new Sn([],{}):new Sn([],this.parseChildren())}parseQueryParams(){const x={};if(this.consumeOptional("?"))do{this.parseQueryParam(x)}while(this.consumeOptional("&"));return x}parseFragment(){return this.consumeOptional("#")?decodeURIComponent(this.remaining):null}parseChildren(){if(""===this.remaining)return{};this.consumeOptional("/");const x=[];for(this.peekStartsWith("(")||x.push(this.parseSegment());this.peekStartsWith("/")&&!this.peekStartsWith("//")&&!this.peekStartsWith("/(");)this.capture("/"),x.push(this.parseSegment());let _={};this.peekStartsWith("/(")&&(this.capture("/"),_=this.parseParens(!0));let T={};return this.peekStartsWith("(")&&(T=this.parseParens(!1)),(x.length>0||Object.keys(_).length>0)&&(T[On]=new Sn(x,_)),T}parseSegment(){const x=J1(this.remaining);if(""===x&&this.peekStartsWith(";"))throw new Error(`Empty path url segment cannot have parameters: '${this.remaining}'.`);return this.capture(x),new Zt(yt(x),this.parseMatrixParams())}parseMatrixParams(){const x={};for(;this.consumeOptional(";");)this.parseParam(x);return x}parseParam(x){const _=J1(this.remaining);if(!_)return;this.capture(_);let T="";if(this.consumeOptional("=")){const V=J1(this.remaining);V&&(T=V,this.capture(T))}x[yt(_)]=yt(T)}parseQueryParam(x){const _=function Qn(z){const x=z.match(d1);return x?x[0]:""}(this.remaining);if(!_)return;this.capture(_);let T="";if(this.consumeOptional("=")){const te=function Li(z){const x=z.match(Pn);return x?x[0]:""}(this.remaining);te&&(T=te,this.capture(T))}const V=v1(_),G=v1(T);if(x.hasOwnProperty(V)){let te=x[V];Array.isArray(te)||(te=[te],x[V]=te),te.push(G)}else x[V]=G}parseParens(x){const _={};for(this.capture("(");!this.consumeOptional(")")&&this.remaining.length>0;){const T=J1(this.remaining),V=this.remaining[T.length];if("/"!==V&&")"!==V&&";"!==V)throw new Error(`Cannot parse url '${this.url}'`);let G;T.indexOf(":")>-1?(G=T.substr(0,T.indexOf(":")),this.capture(G),this.capture(":")):x&&(G=On);const te=this.parseChildren();_[G]=1===Object.keys(te).length?te[On]:new Sn([],te),this.consumeOptional("//")}return _}peekStartsWith(x){return this.remaining.startsWith(x)}consumeOptional(x){return!!this.peekStartsWith(x)&&(this.remaining=this.remaining.substring(x.length),!0)}capture(x){if(!this.consumeOptional(x))throw new Error(`Expected "${x}".`)}}class Qi{constructor(x){this._root=x}get root(){return this._root.value}parent(x){const _=this.pathFromRoot(x);return _.length>1?_[_.length-2]:null}children(x){const _=Xt(x,this._root);return _?_.children.map(T=>T.value):[]}firstChild(x){const _=Xt(x,this._root);return _&&_.children.length>0?_.children[0].value:null}siblings(x){const _=Ji(x,this._root);return _.length<2?[]:_[_.length-2].children.map(V=>V.value).filter(V=>V!==x)}pathFromRoot(x){return Ji(x,this._root).map(_=>_.value)}}function Xt(z,x){if(z===x.value)return x;for(const _ of x.children){const T=Xt(z,_);if(T)return T}return null}function Ji(z,x){if(z===x.value)return[x];for(const _ of x.children){const T=Ji(z,_);if(T.length)return T.unshift(x),T}return[]}class B1{constructor(x,_){this.value=x,this.children=_}toString(){return`TreeNode(${this.value})`}}function o1(z){const x={};return z&&z.children.forEach(_=>x[_.value.outlet]=_),x}class Ht extends Qi{constructor(x,_){super(x),this.snapshot=_,K1(this,x)}toString(){return this.snapshot.toString()}}function Ar(z,x){const _=function qa(z,x){const te=new Ki([],{},{},"",{},On,x,null,z.root,-1,{});return new X1("",new B1(te,[]))}(z,x),T=new fe.X([new Zt("",{})]),V=new fe.X({}),G=new fe.X({}),te=new fe.X({}),se=new fe.X(""),Ie=new u1(T,V,te,se,G,On,x,_.root);return Ie.snapshot=_.root,new Ht(new B1(Ie,[]),_)}class u1{constructor(x,_,T,V,G,te,se,Ie){this.url=x,this.params=_,this.queryParams=T,this.fragment=V,this.data=G,this.outlet=te,this.component=se,this._futureSnapshot=Ie}get routeConfig(){return this._futureSnapshot.routeConfig}get root(){return this._routerState.root}get parent(){return this._routerState.parent(this)}get firstChild(){return this._routerState.firstChild(this)}get children(){return this._routerState.children(this)}get pathFromRoot(){return this._routerState.pathFromRoot(this)}get paramMap(){return this._paramMap||(this._paramMap=this.params.pipe((0,zt.U)(x=>Wt(x)))),this._paramMap}get queryParamMap(){return this._queryParamMap||(this._queryParamMap=this.queryParams.pipe((0,zt.U)(x=>Wt(x)))),this._queryParamMap}toString(){return this.snapshot?this.snapshot.toString():`Future(${this._futureSnapshot})`}}function I1(z,x="emptyOnly"){const _=z.pathFromRoot;let T=0;if("always"!==x)for(T=_.length-1;T>=1;){const V=_[T],G=_[T-1];if(V.routeConfig&&""===V.routeConfig.path)T--;else{if(G.component)break;T--}}return function Da(z){return z.reduce((x,_)=>({params:Object.assign(Object.assign({},x.params),_.params),data:Object.assign(Object.assign({},x.data),_.data),resolve:Object.assign(Object.assign({},x.resolve),_._resolvedData)}),{params:{},data:{},resolve:{}})}(_.slice(T))}class Ki{constructor(x,_,T,V,G,te,se,Ie,In,Ot,un){this.url=x,this.params=_,this.queryParams=T,this.fragment=V,this.data=G,this.outlet=te,this.component=se,this.routeConfig=Ie,this._urlSegment=In,this._lastPathIndex=Ot,this._resolve=un}get root(){return this._routerState.root}get parent(){return this._routerState.parent(this)}get firstChild(){return this._routerState.firstChild(this)}get children(){return this._routerState.children(this)}get pathFromRoot(){return this._routerState.pathFromRoot(this)}get paramMap(){return this._paramMap||(this._paramMap=Wt(this.params)),this._paramMap}get queryParamMap(){return this._queryParamMap||(this._queryParamMap=Wt(this.queryParams)),this._queryParamMap}toString(){return`Route(url:'${this.url.map(T=>T.toString()).join("/")}', path:'${this.routeConfig?this.routeConfig.path:""}')`}}class X1 extends Qi{constructor(x,_){super(_),this.url=x,K1(this,_)}toString(){return Ea(this._root)}}function K1(z,x){x.value._routerState=z,x.children.forEach(_=>K1(z,_))}function Ea(z){const x=z.children.length>0?` { ${z.children.map(Ea).join(", ")} } `:"";return`${z.value}${x}`}function hi(z){if(z.snapshot){const x=z.snapshot,_=z._futureSnapshot;z.snapshot=_,et(x.queryParams,_.queryParams)||z.queryParams.next(_.queryParams),x.fragment!==_.fragment&&z.fragment.next(_.fragment),et(x.params,_.params)||z.params.next(_.params),function m1(z,x){if(z.length!==x.length)return!1;for(let _=0;_<z.length;++_)if(!et(z[_],x[_]))return!1;return!0}(x.url,_.url)||z.url.next(_.url),et(x.data,_.data)||z.data.next(_.data)}else z.snapshot=z._futureSnapshot,z.data.next(z._futureSnapshot.data)}function ar(z,x){const _=et(z.params,x.params)&&function x1(z,x){return $t(z,x)&&z.every((_,T)=>et(_.parameters,x[T].parameters))}(z.url,x.url);return _&&!(!z.parent!=!x.parent)&&(!z.parent||ar(z.parent,x.parent))}function ga(z,x,_){if(_&&z.shouldReuseRoute(x.value,_.value.snapshot)){const T=_.value;T._futureSnapshot=x.value;const V=function Aa(z,x,_){return x.children.map(T=>{for(const V of _.children)if(z.shouldReuseRoute(T.value,V.value.snapshot))return ga(z,T,V);return ga(z,T)})}(z,x,_);return new B1(T,V)}{if(z.shouldAttach(x.value)){const G=z.retrieve(x.value);if(null!==G){const te=G.route;return te.value._futureSnapshot=x.value,te.children=x.children.map(se=>ga(z,se)),te}}const T=function Lr(z){return new u1(new fe.X(z.url),new fe.X(z.params),new fe.X(z.queryParams),new fe.X(z.fragment),new fe.X(z.data),z.outlet,z.component,z)}(x.value),V=x.children.map(G=>ga(z,G));return new B1(T,V)}}function Oi(z){return"object"==typeof z&&null!=z&&!z.outlets&&!z.segmentPath}function ea(z){return"object"==typeof z&&null!=z&&z.outlets}function va(z,x,_,T,V){let G={};return T&&kt(T,(te,se)=>{G[se]=Array.isArray(te)?te.map(Ie=>`${Ie}`):`${te}`}),new wt(_.root===z?x:La(_.root,z,x),G,V)}function La(z,x,_){const T={};return kt(z.children,(V,G)=>{T[G]=V===x?_:La(V,x,_)}),new Sn(z.segments,T)}class Qr{constructor(x,_,T){if(this.isAbsolute=x,this.numberOfDoubleDots=_,this.commands=T,x&&T.length>0&&Oi(T[0]))throw new Error("Root segment cannot have matrix parameters");const V=T.find(ea);if(V&&V!==Ni(T))throw new Error("{outlets:{}} has to be the last command")}toRoot(){return this.isAbsolute&&1===this.commands.length&&"/"==this.commands[0]}}class mr{constructor(x,_,T){this.segmentGroup=x,this.processChildren=_,this.index=T}}function Ga(z,x,_){if(z||(z=new Sn([],{})),0===z.segments.length&&z.hasChildren())return Vi(z,x,_);const T=function na(z,x,_){let T=0,V=x;const G={match:!1,pathIndex:0,commandIndex:0};for(;V<z.segments.length;){if(T>=_.length)return G;const te=z.segments[V],se=_[T];if(ea(se))break;const Ie=`${se}`,In=T<_.length-1?_[T+1]:null;if(V>0&&void 0===Ie)break;if(Ie&&In&&"object"==typeof In&&void 0===In.outlets){if(!Jr(Ie,In,te))return G;T+=2}else{if(!Jr(Ie,{},te))return G;T++}V++}return{match:!0,pathIndex:V,commandIndex:T}}(z,x,_),V=_.slice(T.commandIndex);if(T.match&&T.pathIndex<z.segments.length){const G=new Sn(z.segments.slice(0,T.pathIndex),{});return G.children[On]=new Sn(z.segments.slice(T.pathIndex),z.children),Vi(G,0,V)}return T.match&&0===V.length?new Sn(z.segments,{}):T.match&&!z.hasChildren()?Ta(z,x,_):T.match?Vi(z,0,V):Ta(z,x,_)}function Vi(z,x,_){if(0===_.length)return new Sn(z.segments,{});{const T=function hr(z){return ea(z[0])?z[0].outlets:{[On]:z}}(_),V={};return kt(T,(G,te)=>{"string"==typeof G&&(G=[G]),null!==G&&(V[te]=Ga(z.children[te],x,G))}),kt(z.children,(G,te)=>{void 0===T[te]&&(V[te]=G)}),new Sn(z.segments,V)}}function Ta(z,x,_){const T=z.segments.slice(0,x);let V=0;for(;V<_.length;){const G=_[V];if(ea(G)){const Ie=m2(G.outlets);return new Sn(T,Ie)}if(0===V&&Oi(_[0])){T.push(new Zt(z.segments[x].path,w1(_[0]))),V++;continue}const te=ea(G)?G.outlets[On]:`${G}`,se=V<_.length-1?_[V+1]:null;te&&se&&Oi(se)?(T.push(new Zt(te,w1(se))),V+=2):(T.push(new Zt(te,{})),V++)}return new Sn(T,{})}function m2(z){const x={};return kt(z,(_,T)=>{"string"==typeof _&&(_=[_]),null!==_&&(x[T]=Ta(new Sn([],{}),0,_))}),x}function w1(z){const x={};return kt(z,(_,T)=>x[T]=`${_}`),x}function Jr(z,x,_){return z==_.path&&et(x,_.parameters)}class Ti{constructor(x,_,T,V){this.routeReuseStrategy=x,this.futureState=_,this.currState=T,this.forwardEvent=V}activate(x){const _=this.futureState._root,T=this.currState?this.currState._root:null;this.deactivateChildRoutes(_,T,x),hi(this.futureState.root),this.activateChildRoutes(_,T,x)}deactivateChildRoutes(x,_,T){const V=o1(_);x.children.forEach(G=>{const te=G.value.outlet;this.deactivateRoutes(G,V[te],T),delete V[te]}),kt(V,(G,te)=>{this.deactivateRouteAndItsChildren(G,T)})}deactivateRoutes(x,_,T){const V=x.value,G=_?_.value:null;if(V===G)if(V.component){const te=T.getContext(V.outlet);te&&this.deactivateChildRoutes(x,_,te.children)}else this.deactivateChildRoutes(x,_,T);else G&&this.deactivateRouteAndItsChildren(_,T)}deactivateRouteAndItsChildren(x,_){x.value.component&&this.routeReuseStrategy.shouldDetach(x.value.snapshot)?this.detachAndStoreRouteSubtree(x,_):this.deactivateRouteAndOutlet(x,_)}detachAndStoreRouteSubtree(x,_){const T=_.getContext(x.value.outlet),V=T&&x.value.component?T.children:_,G=o1(x);for(const te of Object.keys(G))this.deactivateRouteAndItsChildren(G[te],V);if(T&&T.outlet){const te=T.outlet.detach(),se=T.children.onOutletDeactivated();this.routeReuseStrategy.store(x.value.snapshot,{componentRef:te,route:x,contexts:se})}}deactivateRouteAndOutlet(x,_){const T=_.getContext(x.value.outlet),V=T&&x.value.component?T.children:_,G=o1(x);for(const te of Object.keys(G))this.deactivateRouteAndItsChildren(G[te],V);T&&T.outlet&&(T.outlet.deactivate(),T.children.onOutletDeactivated(),T.attachRef=null,T.resolver=null,T.route=null)}activateChildRoutes(x,_,T){const V=o1(_);x.children.forEach(G=>{this.activateRoutes(G,V[G.value.outlet],T),this.forwardEvent(new jn(G.value.snapshot))}),x.children.length&&this.forwardEvent(new sn(x.value.snapshot))}activateRoutes(x,_,T){const V=x.value,G=_?_.value:null;if(hi(V),V===G)if(V.component){const te=T.getOrCreateContext(V.outlet);this.activateChildRoutes(x,_,te.children)}else this.activateChildRoutes(x,_,T);else if(V.component){const te=T.getOrCreateContext(V.outlet);if(this.routeReuseStrategy.shouldAttach(V.snapshot)){const se=this.routeReuseStrategy.retrieve(V.snapshot);this.routeReuseStrategy.store(V.snapshot,null),te.children.onOutletReAttached(se.contexts),te.attachRef=se.componentRef,te.route=se.route.value,te.outlet&&te.outlet.attach(se.componentRef,se.route.value),hi(se.route.value),this.activateChildRoutes(x,null,te.children)}else{const se=function Kr(z){for(let x=z.parent;x;x=x.parent){const _=x.routeConfig;if(_&&_._loadedConfig)return _._loadedConfig;if(_&&_.component)return null}return null}(V.snapshot),Ie=se?se.module.componentFactoryResolver:null;te.attachRef=null,te.route=V,te.resolver=Ie,te.outlet&&te.outlet.activateWith(V,Ie),this.activateChildRoutes(x,null,te.children)}}else this.activateChildRoutes(x,null,T)}}class ji{constructor(x,_){this.routes=x,this.module=_}}function ai(z){return"function"==typeof z}function O1(z){return z instanceof wt}const ba=Symbol("INITIAL_VALUE");function Pa(){return(0,Lt.w)(z=>(0,le.aj)(z.map(x=>x.pipe((0,Ln.q)(1),(0,$i.O)(ba)))).pipe(Ke((x,_)=>{let T=!1;return _.reduce((V,G,te)=>V!==ba?V:(G===ba&&(T=!0),T||!1!==G&&te!==_.length-1&&!O1(G)?V:G),x)},ba),(0,fn.h)(x=>x!==ba),(0,zt.U)(x=>O1(x)?x:!0===x),(0,Ln.q)(1)))}class jr{constructor(){this.outlet=null,this.route=null,this.resolver=null,this.children=new ya,this.attachRef=null}}class ya{constructor(){this.contexts=new Map}onChildOutletCreated(x,_){const T=this.getOrCreateContext(x);T.outlet=_,this.contexts.set(x,T)}onChildOutletDestroyed(x){const _=this.getContext(x);_&&(_.outlet=null,_.attachRef=null)}onOutletDeactivated(){const x=this.contexts;return this.contexts=new Map,x}onOutletReAttached(x){this.contexts=x}getOrCreateContext(x){let _=this.getContext(x);return _||(_=new jr,this.contexts.set(x,_)),_}getContext(x){return this.contexts.get(x)||null}}let j=(()=>{class z{constructor(_,T,V,G,te){this.parentContexts=_,this.location=T,this.resolver=V,this.changeDetector=te,this.activated=null,this._activatedRoute=null,this.activateEvents=new M.vpe,this.deactivateEvents=new M.vpe,this.attachEvents=new M.vpe,this.detachEvents=new M.vpe,this.name=G||On,_.onChildOutletCreated(this.name,this)}ngOnDestroy(){this.parentContexts.onChildOutletDestroyed(this.name)}ngOnInit(){if(!this.activated){const _=this.parentContexts.getContext(this.name);_&&_.route&&(_.attachRef?this.attach(_.attachRef,_.route):this.activateWith(_.route,_.resolver||null))}}get isActivated(){return!!this.activated}get component(){if(!this.activated)throw new Error("Outlet is not activated");return this.activated.instance}get activatedRoute(){if(!this.activated)throw new Error("Outlet is not activated");return this._activatedRoute}get activatedRouteData(){return this._activatedRoute?this._activatedRoute.snapshot.data:{}}detach(){if(!this.activated)throw new Error("Outlet is not activated");this.location.detach();const _=this.activated;return this.activated=null,this._activatedRoute=null,this.detachEvents.emit(_.instance),_}attach(_,T){this.activated=_,this._activatedRoute=T,this.location.insert(_.hostView),this.attachEvents.emit(_.instance)}deactivate(){if(this.activated){const _=this.component;this.activated.destroy(),this.activated=null,this._activatedRoute=null,this.deactivateEvents.emit(_)}}activateWith(_,T){if(this.isActivated)throw new Error("Cannot activate an already activated outlet");this._activatedRoute=_;const te=(T=T||this.resolver).resolveComponentFactory(_._futureSnapshot.routeConfig.component),se=this.parentContexts.getOrCreateContext(this.name).children,Ie=new U(_,se,this.location.injector);this.activated=this.location.createComponent(te,this.location.length,Ie),this.changeDetector.markForCheck(),this.activateEvents.emit(this.activated.instance)}}return z.\u0275fac=function(_){return new(_||z)(M.Y36(ya),M.Y36(M.s_b),M.Y36(M._Vd),M.$8M("name"),M.Y36(M.sBO))},z.\u0275dir=M.lG2({type:z,selectors:[["router-outlet"]],outputs:{activateEvents:"activate",deactivateEvents:"deactivate",attachEvents:"attach",detachEvents:"detach"},exportAs:["outlet"]}),z})();class U{constructor(x,_,T){this.route=x,this.childContexts=_,this.parent=T}get(x,_){return x===u1?this.route:x===ya?this.childContexts:this.parent.get(x,_)}}let k=(()=>{class z{}return z.\u0275fac=function(_){return new(_||z)},z.\u0275cmp=M.Xpm({type:z,selectors:[["ng-component"]],decls:1,vars:0,template:function(_,T){1&_&&M._UZ(0,"router-outlet")},directives:[j],encapsulation:2}),z})();function X(z,x=""){for(let _=0;_<z.length;_++){const T=z[_];re(T,ke(x,T))}}function re(z,x){z.children&&X(z.children,x)}function ke(z,x){return x?z||x.path?z&&!x.path?`${z}/`:!z&&x.path?x.path:`${z}/${x.path}`:"":z}function Je(z){const x=z.children&&z.children.map(Je),_=x?Object.assign(Object.assign({},z),{children:x}):Object.assign({},z);return!_.component&&(x||_.loadChildren)&&_.outlet&&_.outlet!==On&&(_.component=k),_}function nn(z){return z.outlet||On}function Pt(z,x){const _=z.filter(T=>nn(T)===x);return _.push(...z.filter(T=>nn(T)!==x)),_}const s1={matched:!1,consumedSegments:[],remainingSegments:[],parameters:{},positionalParamSegments:{}};function Dt(z,x,_){var T;if(""===x.path)return"full"===x.pathMatch&&(z.hasChildren()||_.length>0)?Object.assign({},s1):{matched:!0,consumedSegments:[],remainingSegments:_,parameters:{},positionalParamSegments:{}};const G=(x.matcher||_1)(_,z,x);if(!G)return Object.assign({},s1);const te={};kt(G.posParams,(Ie,In)=>{te[In]=Ie.path});const se=G.consumed.length>0?Object.assign(Object.assign({},te),G.consumed[G.consumed.length-1].parameters):te;return{matched:!0,consumedSegments:G.consumed,remainingSegments:_.slice(G.consumed.length),parameters:se,positionalParamSegments:null!==(T=G.posParams)&&void 0!==T?T:{}}}function kn(z,x,_,T,V="corrected"){if(_.length>0&&function h1(z,x,_){return _.some(T=>H1(z,x,T)&&nn(T)!==On)}(z,_,T)){const te=new Sn(x,function Jn(z,x,_,T){const V={};V[On]=T,T._sourceSegment=z,T._segmentIndexShift=x.length;for(const G of _)if(""===G.path&&nn(G)!==On){const te=new Sn([],{});te._sourceSegment=z,te._segmentIndexShift=x.length,V[nn(G)]=te}return V}(z,x,T,new Sn(_,z.children)));return te._sourceSegment=z,te._segmentIndexShift=x.length,{segmentGroup:te,slicedSegments:[]}}if(0===_.length&&function V1(z,x,_){return _.some(T=>H1(z,x,T))}(z,_,T)){const te=new Sn(z.segments,function c1(z,x,_,T,V,G){const te={};for(const se of T)if(H1(z,_,se)&&!V[nn(se)]){const Ie=new Sn([],{});Ie._sourceSegment=z,Ie._segmentIndexShift="legacy"===G?z.segments.length:x.length,te[nn(se)]=Ie}return Object.assign(Object.assign({},V),te)}(z,x,_,T,z.children,V));return te._sourceSegment=z,te._segmentIndexShift=x.length,{segmentGroup:te,slicedSegments:_}}const G=new Sn(z.segments,z.children);return G._sourceSegment=z,G._segmentIndexShift=x.length,{segmentGroup:G,slicedSegments:_}}function H1(z,x,_){return(!(z.hasChildren()||x.length>0)||"full"!==_.pathMatch)&&""===_.path}function P(z,x,_,T){return!!(nn(z)===T||T!==On&&H1(x,_,z))&&("**"===z.path||Dt(x,z,_).matched)}function L(z,x,_){return 0===x.length&&!z.children[_]}class D{constructor(x){this.segmentGroup=x||null}}class W{constructor(x){this.urlTree=x}}function je(z){return(0,pe._)(new D(z))}function $e(z){return(0,pe._)(new W(z))}class Ri{constructor(x,_,T,V,G){this.configLoader=_,this.urlSerializer=T,this.urlTree=V,this.config=G,this.allowRedirects=!0,this.ngModule=x.get(M.h0i)}apply(){const x=kn(this.urlTree.root,[],[],this.config).segmentGroup,_=new Sn(x.segments,x.children);return this.expandSegmentGroup(this.ngModule,this.config,_,On).pipe((0,zt.U)(G=>this.createUrlTree(ia(G),this.urlTree.queryParams,this.urlTree.fragment))).pipe(yn(G=>{if(G instanceof W)return this.allowRedirects=!1,this.match(G.urlTree);throw G instanceof D?this.noMatchError(G):G}))}match(x){return this.expandSegmentGroup(this.ngModule,this.config,x.root,On).pipe((0,zt.U)(V=>this.createUrlTree(ia(V),x.queryParams,x.fragment))).pipe(yn(V=>{throw V instanceof D?this.noMatchError(V):V}))}noMatchError(x){return new Error(`Cannot match any routes. URL Segment: '${x.segmentGroup}'`)}createUrlTree(x,_,T){const V=x.segments.length>0?new Sn([],{[On]:x}):x;return new wt(V,_,T)}expandSegmentGroup(x,_,T,V){return 0===T.segments.length&&T.hasChildren()?this.expandChildren(x,_,T).pipe((0,zt.U)(G=>new Sn([],G))):this.expandSegment(x,T,_,T.segments,V,!0)}expandChildren(x,_,T){const V=[];for(const G of Object.keys(T.children))"primary"===G?V.unshift(G):V.push(G);return(0,ye.D)(V).pipe((0,Ut.b)(G=>{const te=T.children[G],se=Pt(_,G);return this.expandSegmentGroup(x,se,te,G).pipe((0,zt.U)(Ie=>({segment:Ie,outlet:G})))}),Ke((G,te)=>(G[te.outlet]=te.segment,G),{}),function En(z,x){const _=arguments.length>=2;return T=>T.pipe(z?(0,fn.h)((V,G)=>z(V,G,T)):Xe.y,mt(1),_?De(x):Yn(()=>new Ue))}())}expandSegment(x,_,T,V,G,te){return(0,ye.D)(T).pipe((0,Ut.b)(se=>this.expandSegmentAgainstRoute(x,_,T,se,V,G,te).pipe(yn(In=>{if(In instanceof D)return(0,ce.of)(null);throw In}))),lt(se=>!!se),yn((se,Ie)=>{if(se instanceof Ue||"EmptyError"===se.name){if(L(_,V,G))return(0,ce.of)(new Sn([],{}));throw new D(_)}throw se}))}expandSegmentAgainstRoute(x,_,T,V,G,te,se){return P(V,_,G,te)?void 0===V.redirectTo?this.matchSegmentAgainstRoute(x,_,V,G,te):se&&this.allowRedirects?this.expandSegmentAgainstRouteUsingRedirect(x,_,T,V,G,te):je(_):je(_)}expandSegmentAgainstRouteUsingRedirect(x,_,T,V,G,te){return"**"===V.path?this.expandWildCardWithParamsAgainstRouteUsingRedirect(x,T,V,te):this.expandRegularSegmentAgainstRouteUsingRedirect(x,_,T,V,G,te)}expandWildCardWithParamsAgainstRouteUsingRedirect(x,_,T,V){const G=this.applyRedirectCommands([],T.redirectTo,{});return T.redirectTo.startsWith("/")?$e(G):this.lineralizeSegments(T,G).pipe((0,y1.zg)(te=>{const se=new Sn(te,{});return this.expandSegment(x,se,_,te,V,!1)}))}expandRegularSegmentAgainstRouteUsingRedirect(x,_,T,V,G,te){const{matched:se,consumedSegments:Ie,remainingSegments:In,positionalParamSegments:Ot}=Dt(_,V,G);if(!se)return je(_);const un=this.applyRedirectCommands(Ie,V.redirectTo,Ot);return V.redirectTo.startsWith("/")?$e(un):this.lineralizeSegments(V,un).pipe((0,y1.zg)(Kn=>this.expandSegment(x,_,T,Kn.concat(In),te,!1)))}matchSegmentAgainstRoute(x,_,T,V,G){if("**"===T.path)return T.loadChildren?(T._loadedConfig?(0,ce.of)(T._loadedConfig):this.configLoader.load(x.injector,T)).pipe((0,zt.U)(un=>(T._loadedConfig=un,new Sn(V,{})))):(0,ce.of)(new Sn(V,{}));const{matched:te,consumedSegments:se,remainingSegments:Ie}=Dt(_,T,V);return te?this.getChildConfig(x,T,V).pipe((0,y1.zg)(Ot=>{const un=Ot.module,Kn=Ot.routes,{segmentGroup:_t,slicedSegments:S1}=kn(_,se,Ie,Kn),ra=new Sn(_t.segments,_t.children);if(0===S1.length&&ra.hasChildren())return this.expandChildren(un,Kn,ra).pipe((0,zt.U)(Cr=>new Sn(se,Cr)));if(0===Kn.length&&0===S1.length)return(0,ce.of)(new Sn(se,{}));const Ya=nn(T)===G;return this.expandSegment(un,ra,Kn,S1,Ya?On:G,!0).pipe((0,zt.U)(sr=>new Sn(se.concat(sr.segments),sr.children)))})):je(_)}getChildConfig(x,_,T){return _.children?(0,ce.of)(new ji(_.children,x)):_.loadChildren?void 0!==_._loadedConfig?(0,ce.of)(_._loadedConfig):this.runCanLoadGuards(x.injector,_,T).pipe((0,y1.zg)(V=>V?this.configLoader.load(x.injector,_).pipe((0,zt.U)(G=>(_._loadedConfig=G,G))):function ri(z){return(0,pe._)(gt(`Cannot load children because the guard of the route "path: '${z.path}'" returned false`))}(_))):(0,ce.of)(new ji([],x))}runCanLoadGuards(x,_,T){const V=_.canLoad;if(!V||0===V.length)return(0,ce.of)(!0);const G=V.map(te=>{const se=x.get(te);let Ie;if(function Wa(z){return z&&ai(z.canLoad)}(se))Ie=se.canLoad(_,T);else{if(!ai(se))throw new Error("Invalid CanLoad guard");Ie=se(_,T)}return r1(Ie)});return(0,ce.of)(G).pipe(Pa(),(0,qn.b)(te=>{if(!O1(te))return;const se=gt(`Redirecting to "${this.urlSerializer.serialize(te)}"`);throw se.url=te,se}),(0,zt.U)(te=>!0===te))}lineralizeSegments(x,_){let T=[],V=_.root;for(;;){if(T=T.concat(V.segments),0===V.numberOfChildren)return(0,ce.of)(T);if(V.numberOfChildren>1||!V.children[On])return(0,pe._)(new Error(`Only absolute redirects can have named outlets. redirectTo: '${x.redirectTo}'`));V=V.children[On]}}applyRedirectCommands(x,_,T){return this.applyRedirectCreatreUrlTree(_,this.urlSerializer.parse(_),x,T)}applyRedirectCreatreUrlTree(x,_,T,V){const G=this.createSegmentGroup(x,_.root,T,V);return new wt(G,this.createQueryParams(_.queryParams,this.urlTree.queryParams),_.fragment)}createQueryParams(x,_){const T={};return kt(x,(V,G)=>{if("string"==typeof V&&V.startsWith(":")){const se=V.substring(1);T[G]=_[se]}else T[G]=V}),T}createSegmentGroup(x,_,T,V){const G=this.createSegments(x,_.segments,T,V);let te={};return kt(_.children,(se,Ie)=>{te[Ie]=this.createSegmentGroup(x,se,T,V)}),new Sn(G,te)}createSegments(x,_,T,V){return _.map(G=>G.path.startsWith(":")?this.findPosParam(x,G,V):this.findOrReturn(G,T))}findPosParam(x,_,T){const V=T[_.path.substring(1)];if(!V)throw new Error(`Cannot redirect to '${x}'. Cannot find '${_.path}'.`);return V}findOrReturn(x,_){let T=0;for(const V of _){if(V.path===x.path)return _.splice(T),V;T++}return x}}function ia(z){const x={};for(const T of Object.keys(z.children)){const G=ia(z.children[T]);(G.segments.length>0||G.hasChildren())&&(x[T]=G)}return function ta(z){if(1===z.numberOfChildren&&z.children[On]){const x=z.children[On];return new Sn(z.segments.concat(x.segments),x.children)}return z}(new Sn(z.segments,x))}class Ye{constructor(x){this.path=x,this.route=this.path[this.path.length-1]}}class Ct{constructor(x,_){this.component=x,this.route=_}}function Fi(z,x,_){const T=z._root;return gi(T,x?x._root:null,_,[T.value])}function Pr(z,x,_){const T=function gr(z){if(!z)return null;for(let x=z.parent;x;x=x.parent){const _=x.routeConfig;if(_&&_._loadedConfig)return _._loadedConfig}return null}(x);return(T?T.module.injector:_).get(z)}function gi(z,x,_,T,V={canDeactivateChecks:[],canActivateChecks:[]}){const G=o1(x);return z.children.forEach(te=>{(function X2(z,x,_,T,V={canDeactivateChecks:[],canActivateChecks:[]}){const G=z.value,te=x?x.value:null,se=_?_.getContext(z.value.outlet):null;if(te&&G.routeConfig===te.routeConfig){const Ie=function Y2(z,x,_){if("function"==typeof _)return _(z,x);switch(_){case"pathParamsChange":return!$t(z.url,x.url);case"pathParamsOrQueryParamsChange":return!$t(z.url,x.url)||!et(z.queryParams,x.queryParams);case"always":return!0;case"paramsOrQueryParamsChange":return!ar(z,x)||!et(z.queryParams,x.queryParams);default:return!ar(z,x)}}(te,G,G.routeConfig.runGuardsAndResolvers);Ie?V.canActivateChecks.push(new Ye(T)):(G.data=te.data,G._resolvedData=te._resolvedData),gi(z,x,G.component?se?se.children:null:_,T,V),Ie&&se&&se.outlet&&se.outlet.isActivated&&V.canDeactivateChecks.push(new Ct(se.outlet.component,te))}else te&&Hn(x,se,V),V.canActivateChecks.push(new Ye(T)),gi(z,null,G.component?se?se.children:null:_,T,V)})(te,G[te.value.outlet],_,T.concat([te.value]),V),delete G[te.value.outlet]}),kt(G,(te,se)=>Hn(te,_.getContext(se),V)),V}function Hn(z,x,_){const T=o1(z),V=z.value;kt(T,(G,te)=>{Hn(G,V.component?x?x.children.getContext(te):null:x,_)}),_.canDeactivateChecks.push(new Ct(V.component&&x&&x.outlet&&x.outlet.isActivated?x.outlet.component:null,V))}class Pe{}function Fe(z){return new Oe.y(x=>x.error(z))}class An{constructor(x,_,T,V,G,te){this.rootComponentType=x,this.config=_,this.urlTree=T,this.url=V,this.paramsInheritanceStrategy=G,this.relativeLinkResolution=te}recognize(){const x=kn(this.urlTree.root,[],[],this.config.filter(te=>void 0===te.redirectTo),this.relativeLinkResolution).segmentGroup,_=this.processSegmentGroup(this.config,x,On);if(null===_)return null;const T=new Ki([],Object.freeze({}),Object.freeze(Object.assign({},this.urlTree.queryParams)),this.urlTree.fragment,{},On,this.rootComponentType,null,this.urlTree.root,-1,{}),V=new B1(T,_),G=new X1(this.url,V);return this.inheritParamsAndData(G._root),G}inheritParamsAndData(x){const _=x.value,T=I1(_,this.paramsInheritanceStrategy);_.params=Object.freeze(T.params),_.data=Object.freeze(T.data),x.children.forEach(V=>this.inheritParamsAndData(V))}processSegmentGroup(x,_,T){return 0===_.segments.length&&_.hasChildren()?this.processChildren(x,_):this.processSegment(x,_,_.segments,T)}processChildren(x,_){const T=[];for(const G of Object.keys(_.children)){const te=_.children[G],se=Pt(x,G),Ie=this.processSegmentGroup(se,te,G);if(null===Ie)return null;T.push(...Ie)}const V=Yt(T);return function dt(z){z.sort((x,_)=>x.value.outlet===On?-1:_.value.outlet===On?1:x.value.outlet.localeCompare(_.value.outlet))}(V),V}processSegment(x,_,T,V){for(const G of x){const te=this.processSegmentAgainstRoute(G,_,T,V);if(null!==te)return te}return L(_,T,V)?[]:null}processSegmentAgainstRoute(x,_,T,V){if(x.redirectTo||!P(x,_,T,V))return null;let G,te=[],se=[];if("**"===x.path){const _t=T.length>0?Ni(T).parameters:{};G=new Ki(T,_t,Object.freeze(Object.assign({},this.urlTree.queryParams)),this.urlTree.fragment,ni(x),nn(x),x.component,x,oi(_),Y1(_)+T.length,N1(x))}else{const _t=Dt(_,x,T);if(!_t.matched)return null;te=_t.consumedSegments,se=_t.remainingSegments,G=new Ki(te,_t.parameters,Object.freeze(Object.assign({},this.urlTree.queryParams)),this.urlTree.fragment,ni(x),nn(x),x.component,x,oi(_),Y1(_)+te.length,N1(x))}const Ie=function ft(z){return z.children?z.children:z.loadChildren?z._loadedConfig.routes:[]}(x),{segmentGroup:In,slicedSegments:Ot}=kn(_,te,se,Ie.filter(_t=>void 0===_t.redirectTo),this.relativeLinkResolution);if(0===Ot.length&&In.hasChildren()){const _t=this.processChildren(Ie,In);return null===_t?null:[new B1(G,_t)]}if(0===Ie.length&&0===Ot.length)return[new B1(G,[])];const un=nn(x)===V,Kn=this.processSegment(Ie,In,Ot,un?On:V);return null===Kn?null:[new B1(G,Kn)]}}function Tt(z){const x=z.value.routeConfig;return x&&""===x.path&&void 0===x.redirectTo}function Yt(z){const x=[],_=new Set;for(const T of z){if(!Tt(T)){x.push(T);continue}const V=x.find(G=>T.value.routeConfig===G.value.routeConfig);void 0!==V?(V.children.push(...T.children),_.add(V)):x.push(T)}for(const T of _){const V=Yt(T.children);x.push(new B1(T.value,V))}return x.filter(T=>!_.has(T))}function oi(z){let x=z;for(;x._sourceSegment;)x=x._sourceSegment;return x}function Y1(z){let x=z,_=x._segmentIndexShift?x._segmentIndexShift:0;for(;x._sourceSegment;)x=x._sourceSegment,_+=x._segmentIndexShift?x._segmentIndexShift:0;return _-1}function ni(z){return z.data||{}}function N1(z){return z.resolve||{}}function R1(z){return[...Object.keys(z),...Object.getOwnPropertySymbols(z)]}function bi(z){return(0,Lt.w)(x=>{const _=z(x);return _?(0,ye.D)(_).pipe((0,zt.U)(()=>x)):(0,ce.of)(x)})}class Yo extends class e2{shouldDetach(x){return!1}store(x,_){}shouldAttach(x){return!1}retrieve(x){return null}shouldReuseRoute(x,_){return x.routeConfig===_.routeConfig}}{}const xo=new M.OlP("ROUTES");class Co{constructor(x,_,T,V){this.injector=x,this.compiler=_,this.onLoadStartListener=T,this.onLoadEndListener=V}load(x,_){if(_._loader$)return _._loader$;this.onLoadStartListener&&this.onLoadStartListener(_);const V=this.loadModuleFactory(_.loadChildren).pipe((0,zt.U)(G=>{this.onLoadEndListener&&this.onLoadEndListener(_);const te=G.create(x);return new ji(ma(te.injector.get(xo,void 0,M.XFs.Self|M.XFs.Optional)).map(Je),te)}),yn(G=>{throw _._loader$=void 0,G}));return _._loader$=new Ae.c(V,()=>new dn.xQ).pipe((0,pi.x)()),_._loader$}loadModuleFactory(x){return r1(x()).pipe((0,y1.zg)(_=>_ instanceof M.YKP?(0,ce.of)(_):(0,ye.D)(this.compiler.compileModuleAsync(_))))}}class t2{shouldProcessUrl(x){return!0}extract(x){return x}merge(x,_){return x}}function E1(z){throw z}function vr(z,x,_){return x.parse("/")}function $a(z,x){return(0,ce.of)(null)}const L2={paths:"exact",fragment:"ignored",matrixParams:"ignored",queryParams:"exact"},Qo={paths:"subset",fragment:"ignored",matrixParams:"ignored",queryParams:"subset"};let Bi=(()=>{class z{constructor(_,T,V,G,te,se,Ie){this.rootComponentType=_,this.urlSerializer=T,this.rootContexts=V,this.location=G,this.config=Ie,this.lastSuccessfulNavigation=null,this.currentNavigation=null,this.disposed=!1,this.navigationId=0,this.currentPageId=0,this.isNgZoneEnabled=!1,this.events=new dn.xQ,this.errorHandler=E1,this.malformedUriErrorHandler=vr,this.navigated=!1,this.lastSuccessfulId=-1,this.hooks={beforePreactivation:$a,afterPreactivation:$a},this.urlHandlingStrategy=new t2,this.routeReuseStrategy=new Yo,this.onSameUrlNavigation="ignore",this.paramsInheritanceStrategy="emptyOnly",this.urlUpdateStrategy="deferred",this.relativeLinkResolution="corrected",this.canceledNavigationResolution="replace",this.ngModule=te.get(M.h0i),this.console=te.get(M.c2e);const un=te.get(M.R0b);this.isNgZoneEnabled=un instanceof M.R0b&&M.R0b.isInAngularZone(),this.resetConfig(Ie),this.currentUrlTree=function Yi(){return new wt(new Sn([],{}),{},null)}(),this.rawUrlTree=this.currentUrlTree,this.browserUrlTree=this.currentUrlTree,this.configLoader=new Co(te,se,Kn=>this.triggerEvent(new _n(Kn)),Kn=>this.triggerEvent(new on(Kn))),this.routerState=Ar(this.currentUrlTree,this.rootComponentType),this.transitions=new fe.X({id:0,targetPageId:0,currentUrlTree:this.currentUrlTree,currentRawUrl:this.currentUrlTree,extractedUrl:this.urlHandlingStrategy.extract(this.currentUrlTree),urlAfterRedirects:this.urlHandlingStrategy.extract(this.currentUrlTree),rawUrl:this.currentUrlTree,extras:{},resolve:null,reject:null,promise:Promise.resolve(!0),source:"imperative",restoredState:null,currentSnapshot:this.routerState.snapshot,targetSnapshot:null,currentRouterState:this.routerState,targetRouterState:null,guards:{canActivateChecks:[],canDeactivateChecks:[]},guardsResult:null}),this.navigations=this.setupNavigations(this.transitions),this.processNavigations()}get browserPageId(){var _;return null===(_=this.location.getState())||void 0===_?void 0:_.\u0275routerPageId}setupNavigations(_){const T=this.events;return _.pipe((0,fn.h)(V=>0!==V.id),(0,zt.U)(V=>Object.assign(Object.assign({},V),{extractedUrl:this.urlHandlingStrategy.extract(V.rawUrl)})),(0,Lt.w)(V=>{let G=!1,te=!1;return(0,ce.of)(V).pipe((0,qn.b)(se=>{this.currentNavigation={id:se.id,initialUrl:se.currentRawUrl,extractedUrl:se.extractedUrl,trigger:se.source,extras:se.extras,previousNavigation:this.lastSuccessfulNavigation?Object.assign(Object.assign({},this.lastSuccessfulNavigation),{previousNavigation:null}):null}}),(0,Lt.w)(se=>{const Ie=this.browserUrlTree.toString(),In=!this.navigated||se.extractedUrl.toString()!==Ie||Ie!==this.currentUrlTree.toString();if(("reload"===this.onSameUrlNavigation||In)&&this.urlHandlingStrategy.shouldProcessUrl(se.rawUrl))return Ir(se.source)&&(this.browserUrlTree=se.extractedUrl),(0,ce.of)(se).pipe((0,Lt.w)(un=>{const Kn=this.transitions.getValue();return T.next(new a1(un.id,this.serializeUrl(un.extractedUrl),un.source,un.restoredState)),Kn!==this.transitions.getValue()?he.E:Promise.resolve(un)}),function kr(z,x,_,T){return(0,Lt.w)(V=>function U1(z,x,_,T,V){return new Ri(z,x,_,T,V).apply()}(z,x,_,V.extractedUrl,T).pipe((0,zt.U)(G=>Object.assign(Object.assign({},V),{urlAfterRedirects:G}))))}(this.ngModule.injector,this.configLoader,this.urlSerializer,this.config),(0,qn.b)(un=>{this.currentNavigation=Object.assign(Object.assign({},this.currentNavigation),{finalUrl:un.urlAfterRedirects})}),function vi(z,x,_,T,V){return(0,y1.zg)(G=>function Be(z,x,_,T,V="emptyOnly",G="legacy"){try{const te=new An(z,x,_,T,V,G).recognize();return null===te?Fe(new Pe):(0,ce.of)(te)}catch(te){return Fe(te)}}(z,x,G.urlAfterRedirects,_(G.urlAfterRedirects),T,V).pipe((0,zt.U)(te=>Object.assign(Object.assign({},G),{targetSnapshot:te}))))}(this.rootComponentType,this.config,un=>this.serializeUrl(un),this.paramsInheritanceStrategy,this.relativeLinkResolution),(0,qn.b)(un=>{if("eager"===this.urlUpdateStrategy){if(!un.extras.skipLocationChange){const _t=this.urlHandlingStrategy.merge(un.urlAfterRedirects,un.rawUrl);this.setBrowserUrl(_t,un)}this.browserUrlTree=un.urlAfterRedirects}const Kn=new wa(un.id,this.serializeUrl(un.extractedUrl),this.serializeUrl(un.urlAfterRedirects),un.targetSnapshot);T.next(Kn)}));if(In&&this.rawUrlTree&&this.urlHandlingStrategy.shouldProcessUrl(this.rawUrlTree)){const{id:Kn,extractedUrl:_t,source:S1,restoredState:ra,extras:Ya}=se,oa=new a1(Kn,this.serializeUrl(_t),S1,ra);T.next(oa);const sr=Ar(_t,this.rootComponentType).snapshot;return(0,ce.of)(Object.assign(Object.assign({},se),{targetSnapshot:sr,urlAfterRedirects:_t,extras:Object.assign(Object.assign({},Ya),{skipLocationChange:!1,replaceUrl:!1})}))}return this.rawUrlTree=se.rawUrl,se.resolve(null),he.E}),bi(se=>{const{targetSnapshot:Ie,id:In,extractedUrl:Ot,rawUrl:un,extras:{skipLocationChange:Kn,replaceUrl:_t}}=se;return this.hooks.beforePreactivation(Ie,{navigationId:In,appliedUrlTree:Ot,rawUrlTree:un,skipLocationChange:!!Kn,replaceUrl:!!_t})}),(0,qn.b)(se=>{const Ie=new $n(se.id,this.serializeUrl(se.extractedUrl),this.serializeUrl(se.urlAfterRedirects),se.targetSnapshot);this.triggerEvent(Ie)}),(0,zt.U)(se=>Object.assign(Object.assign({},se),{guards:Fi(se.targetSnapshot,se.currentSnapshot,this.rootContexts)})),function h2(z,x){return(0,y1.zg)(_=>{const{targetSnapshot:T,currentSnapshot:V,guards:{canActivateChecks:G,canDeactivateChecks:te}}=_;return 0===te.length&&0===G.length?(0,ce.of)(Object.assign(Object.assign({},_),{guardsResult:!0})):function _a(z,x,_,T){return(0,ye.D)(z).pipe((0,y1.zg)(V=>function ve(z,x,_,T,V){const G=x&&x.routeConfig?x.routeConfig.canDeactivate:null;if(!G||0===G.length)return(0,ce.of)(!0);const te=G.map(se=>{const Ie=Pr(se,x,V);let In;if(function Za(z){return z&&ai(z.canDeactivate)}(Ie))In=r1(Ie.canDeactivate(z,x,_,T));else{if(!ai(Ie))throw new Error("Invalid CanDeactivate guard");In=r1(Ie(z,x,_,T))}return In.pipe(lt())});return(0,ce.of)(te).pipe(Pa())}(V.component,V.route,_,x,T)),lt(V=>!0!==V,!0))}(te,T,V,z).pipe((0,y1.zg)(se=>se&&function Hi(z){return"boolean"==typeof z}(se)?function g2(z,x,_,T){return(0,ye.D)(x).pipe((0,Ut.b)(V=>(0,Me.z)(function Z(z,x){return null!==z&&x&&x(new ln(z)),(0,ce.of)(!0)}(V.route.parent,T),function O(z,x){return null!==z&&x&&x(new zi(z)),(0,ce.of)(!0)}(V.route,T),function ne(z,x,_){const T=x[x.length-1],G=x.slice(0,x.length-1).reverse().map(te=>function b1(z){const x=z.routeConfig?z.routeConfig.canActivateChild:null;return x&&0!==x.length?{node:z,guards:x}:null}(te)).filter(te=>null!==te).map(te=>oe(()=>{const se=te.guards.map(Ie=>{const In=Pr(Ie,te.node,_);let Ot;if(function ei(z){return z&&ai(z.canActivateChild)}(In))Ot=r1(In.canActivateChild(T,z));else{if(!ai(In))throw new Error("Invalid CanActivateChild guard");Ot=r1(In(T,z))}return Ot.pipe(lt())});return(0,ce.of)(se).pipe(Pa())}));return(0,ce.of)(G).pipe(Pa())}(z,V.path,_),function Y(z,x,_){const T=x.routeConfig?x.routeConfig.canActivate:null;if(!T||0===T.length)return(0,ce.of)(!0);const V=T.map(G=>oe(()=>{const te=Pr(G,x,_);let se;if(function ka(z){return z&&ai(z.canActivate)}(te))se=r1(te.canActivate(x,z));else{if(!ai(te))throw new Error("Invalid CanActivate guard");se=r1(te(x,z))}return se.pipe(lt())}));return(0,ce.of)(V).pipe(Pa())}(z,V.route,_))),lt(V=>!0!==V,!0))}(T,G,z,x):(0,ce.of)(se)),(0,zt.U)(se=>Object.assign(Object.assign({},_),{guardsResult:se})))})}(this.ngModule.injector,se=>this.triggerEvent(se)),(0,qn.b)(se=>{if(O1(se.guardsResult)){const In=gt(`Redirecting to "${this.serializeUrl(se.guardsResult)}"`);throw In.url=se.guardsResult,In}const Ie=new wi(se.id,this.serializeUrl(se.extractedUrl),this.serializeUrl(se.urlAfterRedirects),se.targetSnapshot,!!se.guardsResult);this.triggerEvent(Ie)}),(0,fn.h)(se=>!!se.guardsResult||(this.restoreHistory(se),this.cancelNavigationTransition(se,""),!1)),bi(se=>{if(se.guards.canActivateChecks.length)return(0,ce.of)(se).pipe((0,qn.b)(Ie=>{const In=new Rn(Ie.id,this.serializeUrl(Ie.extractedUrl),this.serializeUrl(Ie.urlAfterRedirects),Ie.targetSnapshot);this.triggerEvent(In)}),(0,Lt.w)(Ie=>{let In=!1;return(0,ce.of)(Ie).pipe(function qi(z,x){return(0,y1.zg)(_=>{const{targetSnapshot:T,guards:{canActivateChecks:V}}=_;if(!V.length)return(0,ce.of)(_);let G=0;return(0,ye.D)(V).pipe((0,Ut.b)(te=>function aa(z,x,_,T){return function Ia(z,x,_,T){const V=R1(z);if(0===V.length)return(0,ce.of)({});const G={};return(0,ye.D)(V).pipe((0,y1.zg)(te=>function D1(z,x,_,T){const V=Pr(z,x,T);return r1(V.resolve?V.resolve(x,_):V(x,_))}(z[te],x,_,T).pipe((0,qn.b)(se=>{G[te]=se}))),mt(1),(0,y1.zg)(()=>R1(G).length===V.length?(0,ce.of)(G):he.E))}(z._resolve,z,x,T).pipe((0,zt.U)(G=>(z._resolvedData=G,z.data=Object.assign(Object.assign({},z.data),I1(z,_).resolve),null)))}(te.route,T,z,x)),(0,qn.b)(()=>G++),mt(1),(0,y1.zg)(te=>G===V.length?(0,ce.of)(_):he.E))})}(this.paramsInheritanceStrategy,this.ngModule.injector),(0,qn.b)({next:()=>In=!0,complete:()=>{In||(this.restoreHistory(Ie),this.cancelNavigationTransition(Ie,"At least one route resolver didn't emit any value."))}}))}),(0,qn.b)(Ie=>{const In=new xn(Ie.id,this.serializeUrl(Ie.extractedUrl),this.serializeUrl(Ie.urlAfterRedirects),Ie.targetSnapshot);this.triggerEvent(In)}))}),bi(se=>{const{targetSnapshot:Ie,id:In,extractedUrl:Ot,rawUrl:un,extras:{skipLocationChange:Kn,replaceUrl:_t}}=se;return this.hooks.afterPreactivation(Ie,{navigationId:In,appliedUrlTree:Ot,rawUrlTree:un,skipLocationChange:!!Kn,replaceUrl:!!_t})}),(0,zt.U)(se=>{const Ie=function Ba(z,x,_){const T=ga(z,x._root,_?_._root:void 0);return new Ht(T,x)}(this.routeReuseStrategy,se.targetSnapshot,se.currentRouterState);return Object.assign(Object.assign({},se),{targetRouterState:Ie})}),(0,qn.b)(se=>{this.currentUrlTree=se.urlAfterRedirects,this.rawUrlTree=this.urlHandlingStrategy.merge(se.urlAfterRedirects,se.rawUrl),this.routerState=se.targetRouterState,"deferred"===this.urlUpdateStrategy&&(se.extras.skipLocationChange||this.setBrowserUrl(this.rawUrlTree,se),this.browserUrlTree=se.urlAfterRedirects)}),((z,x,_)=>(0,zt.U)(T=>(new Ti(x,T.targetRouterState,T.currentRouterState,_).activate(z),T)))(this.rootContexts,this.routeReuseStrategy,se=>this.triggerEvent(se)),(0,qn.b)({next(){G=!0},complete(){G=!0}}),function Zi(z){return x=>x.lift(new Bt(z))}(()=>{var se;G||te||this.cancelNavigationTransition(V,`Navigation ID ${V.id} is not equal to the current navigation id ${this.navigationId}`),(null===(se=this.currentNavigation)||void 0===se?void 0:se.id)===V.id&&(this.currentNavigation=null)}),yn(se=>{if(te=!0,function Mt(z){return z&&z[e1]}(se)){const Ie=O1(se.url);Ie||(this.navigated=!0,this.restoreHistory(V,!0));const In=new xt(V.id,this.serializeUrl(V.extractedUrl),se.message);T.next(In),Ie?setTimeout(()=>{const Ot=this.urlHandlingStrategy.merge(se.url,this.rawUrlTree),un={skipLocationChange:V.extras.skipLocationChange,replaceUrl:"eager"===this.urlUpdateStrategy||Ir(V.source)};this.scheduleNavigation(Ot,"imperative",null,un,{resolve:V.resolve,reject:V.reject,promise:V.promise})},0):V.resolve(!1)}else{this.restoreHistory(V,!0);const Ie=new Mi(V.id,this.serializeUrl(V.extractedUrl),se);T.next(Ie);try{V.resolve(this.errorHandler(se))}catch(In){V.reject(In)}}return he.E}))}))}resetRootComponentType(_){this.rootComponentType=_,this.routerState.root.component=this.rootComponentType}setTransition(_){this.transitions.next(Object.assign(Object.assign({},this.transitions.value),_))}initialNavigation(){this.setUpLocationChangeListener(),0===this.navigationId&&this.navigateByUrl(this.location.path(!0),{replaceUrl:!0})}setUpLocationChangeListener(){this.locationSubscription||(this.locationSubscription=this.location.subscribe(_=>{const T="popstate"===_.type?"popstate":"hashchange";"popstate"===T&&setTimeout(()=>{var V;const G={replaceUrl:!0},te=(null===(V=_.state)||void 0===V?void 0:V.navigationId)?_.state:null;if(te){const Ie=Object.assign({},te);delete Ie.navigationId,delete Ie.\u0275routerPageId,0!==Object.keys(Ie).length&&(G.state=Ie)}const se=this.parseUrl(_.url);this.scheduleNavigation(se,T,te,G)},0)}))}get url(){return this.serializeUrl(this.currentUrlTree)}getCurrentNavigation(){return this.currentNavigation}triggerEvent(_){this.events.next(_)}resetConfig(_){X(_),this.config=_.map(Je),this.navigated=!1,this.lastSuccessfulId=-1}ngOnDestroy(){this.dispose()}dispose(){this.transitions.complete(),this.locationSubscription&&(this.locationSubscription.unsubscribe(),this.locationSubscription=void 0),this.disposed=!0}createUrlTree(_,T={}){const{relativeTo:V,queryParams:G,fragment:te,queryParamsHandling:se,preserveFragment:Ie}=T,In=V||this.routerState.root,Ot=Ie?this.currentUrlTree.fragment:te;let un=null;switch(se){case"merge":un=Object.assign(Object.assign({},this.currentUrlTree.queryParams),G);break;case"preserve":un=this.currentUrlTree.queryParams;break;default:un=G||null}return null!==un&&(un=this.removeEmptyProps(un)),function pr(z,x,_,T,V){if(0===_.length)return va(x.root,x.root,x,T,V);const G=function Ua(z){if("string"==typeof z[0]&&1===z.length&&"/"===z[0])return new Qr(!0,0,z);let x=0,_=!1;const T=z.reduce((V,G,te)=>{if("object"==typeof G&&null!=G){if(G.outlets){const se={};return kt(G.outlets,(Ie,In)=>{se[In]="string"==typeof Ie?Ie.split("/"):Ie}),[...V,{outlets:se}]}if(G.segmentPath)return[...V,G.segmentPath]}return"string"!=typeof G?[...V,G]:0===te?(G.split("/").forEach((se,Ie)=>{0==Ie&&"."===se||(0==Ie&&""===se?_=!0:".."===se?x++:""!=se&&V.push(se))}),V):[...V,G]},[]);return new Qr(_,x,T)}(_);if(G.toRoot())return va(x.root,new Sn([],{}),x,T,V);const te=function Tr(z,x,_){if(z.isAbsolute)return new mr(x.root,!0,0);if(-1===_.snapshot._lastPathIndex){const G=_.snapshot._urlSegment;return new mr(G,G===x.root,0)}const T=Oi(z.commands[0])?0:1;return function rr(z,x,_){let T=z,V=x,G=_;for(;G>V;){if(G-=V,T=T.parent,!T)throw new Error("Invalid number of '../'");V=T.segments.length}return new mr(T,!1,V-G)}(_.snapshot._urlSegment,_.snapshot._lastPathIndex+T,z.numberOfDoubleDots)}(G,x,z),se=te.processChildren?Vi(te.segmentGroup,te.index,G.commands):Ga(te.segmentGroup,te.index,G.commands);return va(te.segmentGroup,se,x,T,V)}(In,this.currentUrlTree,_,un,null!=Ot?Ot:null)}navigateByUrl(_,T={skipLocationChange:!1}){const V=O1(_)?_:this.parseUrl(_),G=this.urlHandlingStrategy.merge(V,this.rawUrlTree);return this.scheduleNavigation(G,"imperative",null,T)}navigate(_,T={skipLocationChange:!1}){return function Oa(z){for(let x=0;x<z.length;x++){const _=z[x];if(null==_)throw new Error(`The requested path contains ${_} segment at index ${x}`)}}(_),this.navigateByUrl(this.createUrlTree(_,T),T)}serializeUrl(_){return this.urlSerializer.serialize(_)}parseUrl(_){let T;try{T=this.urlSerializer.parse(_)}catch(V){T=this.malformedUriErrorHandler(V,this.urlSerializer,_)}return T}isActive(_,T){let V;if(V=!0===T?Object.assign({},L2):!1===T?Object.assign({},Qo):T,O1(_))return we(this.currentUrlTree,_,V);const G=this.parseUrl(_);return we(this.currentUrlTree,G,V)}removeEmptyProps(_){return Object.keys(_).reduce((T,V)=>{const G=_[V];return null!=G&&(T[V]=G),T},{})}processNavigations(){this.navigations.subscribe(_=>{this.navigated=!0,this.lastSuccessfulId=_.id,this.currentPageId=_.targetPageId,this.events.next(new q1(_.id,this.serializeUrl(_.extractedUrl),this.serializeUrl(this.currentUrlTree))),this.lastSuccessfulNavigation=this.currentNavigation,_.resolve(!0)},_=>{this.console.warn(`Unhandled Navigation Error: ${_}`)})}scheduleNavigation(_,T,V,G,te){var se,Ie,In;if(this.disposed)return Promise.resolve(!1);const Ot=this.transitions.value,un=Ir(T)&&Ot&&!Ir(Ot.source),Kn=Ot.rawUrl.toString()===_.toString(),_t=Ot.id===(null===(se=this.currentNavigation)||void 0===se?void 0:se.id);if(un&&Kn&&_t)return Promise.resolve(!0);let ra,Ya,oa;te?(ra=te.resolve,Ya=te.reject,oa=te.promise):oa=new Promise((y2,Fr)=>{ra=y2,Ya=Fr});const sr=++this.navigationId;let Cr;return"computed"===this.canceledNavigationResolution?(0===this.currentPageId&&(V=this.location.getState()),Cr=V&&V.\u0275routerPageId?V.\u0275routerPageId:G.replaceUrl||G.skipLocationChange?null!==(Ie=this.browserPageId)&&void 0!==Ie?Ie:0:(null!==(In=this.browserPageId)&&void 0!==In?In:0)+1):Cr=0,this.setTransition({id:sr,targetPageId:Cr,source:T,restoredState:V,currentUrlTree:this.currentUrlTree,currentRawUrl:this.rawUrlTree,rawUrl:_,extras:G,resolve:ra,reject:Ya,promise:oa,currentSnapshot:this.routerState.snapshot,currentRouterState:this.routerState}),oa.catch(y2=>Promise.reject(y2))}setBrowserUrl(_,T){const V=this.urlSerializer.serialize(_),G=Object.assign(Object.assign({},T.extras.state),this.generateNgRouterState(T.id,T.targetPageId));this.location.isCurrentPathEqualTo(V)||T.extras.replaceUrl?this.location.replaceState(V,"",G):this.location.go(V,"",G)}restoreHistory(_,T=!1){var V,G;if("computed"===this.canceledNavigationResolution){const te=this.currentPageId-_.targetPageId;"popstate"!==_.source&&"eager"!==this.urlUpdateStrategy&&this.currentUrlTree!==(null===(V=this.currentNavigation)||void 0===V?void 0:V.finalUrl)||0===te?this.currentUrlTree===(null===(G=this.currentNavigation)||void 0===G?void 0:G.finalUrl)&&0===te&&(this.resetState(_),this.browserUrlTree=_.currentUrlTree,this.resetUrlToCurrentUrlTree()):this.location.historyGo(te)}else"replace"===this.canceledNavigationResolution&&(T&&this.resetState(_),this.resetUrlToCurrentUrlTree())}resetState(_){this.routerState=_.currentRouterState,this.currentUrlTree=_.currentUrlTree,this.rawUrlTree=this.urlHandlingStrategy.merge(this.currentUrlTree,_.rawUrl)}resetUrlToCurrentUrlTree(){this.location.replaceState(this.urlSerializer.serialize(this.rawUrlTree),"",this.generateNgRouterState(this.lastSuccessfulId,this.currentPageId))}cancelNavigationTransition(_,T){const V=new xt(_.id,this.serializeUrl(_.extractedUrl),T);this.triggerEvent(V),_.resolve(!1)}generateNgRouterState(_,T){return"computed"===this.canceledNavigationResolution?{navigationId:_,\u0275routerPageId:T}:{navigationId:_}}}return z.\u0275fac=function(_){M.$Z()},z.\u0275prov=M.Yz7({token:z,factory:z.\u0275fac}),z})();function Ir(z){return"imperative"!==z}let br=(()=>{class z{constructor(_,T,V,G,te){this.router=_,this.route=T,this.tabIndexAttribute=V,this.renderer=G,this.el=te,this.commands=null,this.onChanges=new dn.xQ,this.setTabIndexIfNotOnNativeEl("0")}setTabIndexIfNotOnNativeEl(_){if(null!=this.tabIndexAttribute)return;const T=this.renderer,V=this.el.nativeElement;null!==_?T.setAttribute(V,"tabindex",_):T.removeAttribute(V,"tabindex")}ngOnChanges(_){this.onChanges.next(this)}set routerLink(_){null!=_?(this.commands=Array.isArray(_)?_:[_],this.setTabIndexIfNotOnNativeEl("0")):(this.commands=null,this.setTabIndexIfNotOnNativeEl(null))}onClick(){if(null===this.urlTree)return!0;const _={skipLocationChange:Xa(this.skipLocationChange),replaceUrl:Xa(this.replaceUrl),state:this.state};return this.router.navigateByUrl(this.urlTree,_),!0}get urlTree(){return null===this.commands?null:this.router.createUrlTree(this.commands,{relativeTo:void 0!==this.relativeTo?this.relativeTo:this.route,queryParams:this.queryParams,fragment:this.fragment,queryParamsHandling:this.queryParamsHandling,preserveFragment:Xa(this.preserveFragment)})}}return z.\u0275fac=function(_){return new(_||z)(M.Y36(Bi),M.Y36(u1),M.$8M("tabindex"),M.Y36(M.Qsj),M.Y36(M.SBq))},z.\u0275dir=M.lG2({type:z,selectors:[["","routerLink","",5,"a",5,"area"]],hostBindings:function(_,T){1&_&&M.NdJ("click",function(){return T.onClick()})},inputs:{queryParams:"queryParams",fragment:"fragment",queryParamsHandling:"queryParamsHandling",preserveFragment:"preserveFragment",skipLocationChange:"skipLocationChange",replaceUrl:"replaceUrl",state:"state",relativeTo:"relativeTo",routerLink:"routerLink"},features:[M.TTD]}),z})(),C1=(()=>{class z{constructor(_,T,V){this.router=_,this.route=T,this.locationStrategy=V,this.commands=null,this.href=null,this.onChanges=new dn.xQ,this.subscription=_.events.subscribe(G=>{G instanceof q1&&this.updateTargetUrlAndHref()})}set routerLink(_){this.commands=null!=_?Array.isArray(_)?_:[_]:null}ngOnChanges(_){this.updateTargetUrlAndHref(),this.onChanges.next(this)}ngOnDestroy(){this.subscription.unsubscribe()}onClick(_,T,V,G,te){if(0!==_||T||V||G||te||"string"==typeof this.target&&"_self"!=this.target||null===this.urlTree)return!0;const se={skipLocationChange:Xa(this.skipLocationChange),replaceUrl:Xa(this.replaceUrl),state:this.state};return this.router.navigateByUrl(this.urlTree,se),!1}updateTargetUrlAndHref(){this.href=null!==this.urlTree?this.locationStrategy.prepareExternalUrl(this.router.serializeUrl(this.urlTree)):null}get urlTree(){return null===this.commands?null:this.router.createUrlTree(this.commands,{relativeTo:void 0!==this.relativeTo?this.relativeTo:this.route,queryParams:this.queryParams,fragment:this.fragment,queryParamsHandling:this.queryParamsHandling,preserveFragment:Xa(this.preserveFragment)})}}return z.\u0275fac=function(_){return new(_||z)(M.Y36(Bi),M.Y36(u1),M.Y36(j1.S$))},z.\u0275dir=M.lG2({type:z,selectors:[["a","routerLink",""],["area","routerLink",""]],hostVars:2,hostBindings:function(_,T){1&_&&M.NdJ("click",function(G){return T.onClick(G.button,G.ctrlKey,G.shiftKey,G.altKey,G.metaKey)}),2&_&&M.uIk("target",T.target)("href",T.href,M.LSH)},inputs:{target:"target",queryParams:"queryParams",fragment:"fragment",queryParamsHandling:"queryParamsHandling",preserveFragment:"preserveFragment",skipLocationChange:"skipLocationChange",replaceUrl:"replaceUrl",state:"state",relativeTo:"relativeTo",routerLink:"routerLink"},features:[M.TTD]}),z})();function Xa(z){return""===z||!!z}let a2=(()=>{class z{constructor(_,T,V,G,te,se){this.router=_,this.element=T,this.renderer=V,this.cdr=G,this.link=te,this.linkWithHref=se,this.classes=[],this.isActive=!1,this.routerLinkActiveOptions={exact:!1},this.isActiveChange=new M.vpe,this.routerEventsSubscription=_.events.subscribe(Ie=>{Ie instanceof q1&&this.update()})}ngAfterContentInit(){(0,ce.of)(this.links.changes,this.linksWithHrefs.changes,(0,ce.of)(null)).pipe((0,Xi.J)()).subscribe(_=>{this.update(),this.subscribeToEachLinkOnChanges()})}subscribeToEachLinkOnChanges(){var _;null===(_=this.linkInputChangesSubscription)||void 0===_||_.unsubscribe();const T=[...this.links.toArray(),...this.linksWithHrefs.toArray(),this.link,this.linkWithHref].filter(V=>!!V).map(V=>V.onChanges);this.linkInputChangesSubscription=(0,ye.D)(T).pipe((0,Xi.J)()).subscribe(V=>{this.isActive!==this.isLinkActive(this.router)(V)&&this.update()})}set routerLinkActive(_){const T=Array.isArray(_)?_:_.split(" ");this.classes=T.filter(V=>!!V)}ngOnChanges(_){this.update()}ngOnDestroy(){var _;this.routerEventsSubscription.unsubscribe(),null===(_=this.linkInputChangesSubscription)||void 0===_||_.unsubscribe()}update(){!this.links||!this.linksWithHrefs||!this.router.navigated||Promise.resolve().then(()=>{const _=this.hasActiveLinks();this.isActive!==_&&(this.isActive=_,this.cdr.markForCheck(),this.classes.forEach(T=>{_?this.renderer.addClass(this.element.nativeElement,T):this.renderer.removeClass(this.element.nativeElement,T)}),this.isActiveChange.emit(_))})}isLinkActive(_){const T=function Q2(z){return!!z.paths}(this.routerLinkActiveOptions)?this.routerLinkActiveOptions:this.routerLinkActiveOptions.exact||!1;return V=>!!V.urlTree&&_.isActive(V.urlTree,T)}hasActiveLinks(){const _=this.isLinkActive(this.router);return this.link&&_(this.link)||this.linkWithHref&&_(this.linkWithHref)||this.links.some(_)||this.linksWithHrefs.some(_)}}return z.\u0275fac=function(_){return new(_||z)(M.Y36(Bi),M.Y36(M.SBq),M.Y36(M.Qsj),M.Y36(M.sBO),M.Y36(br,8),M.Y36(C1,8))},z.\u0275dir=M.lG2({type:z,selectors:[["","routerLinkActive",""]],contentQueries:function(_,T,V){if(1&_&&(M.Suo(V,br,5),M.Suo(V,C1,5)),2&_){let G;M.iGM(G=M.CRH())&&(T.links=G),M.iGM(G=M.CRH())&&(T.linksWithHrefs=G)}},inputs:{routerLinkActiveOptions:"routerLinkActiveOptions",routerLinkActive:"routerLinkActive"},outputs:{isActiveChange:"isActiveChange"},exportAs:["routerLinkActive"],features:[M.TTD]}),z})();class J2{}class T2{preload(x,_){return(0,ce.of)(null)}}let Or=(()=>{class z{constructor(_,T,V,G){this.router=_,this.injector=V,this.preloadingStrategy=G,this.loader=new Co(V,T,Ie=>_.triggerEvent(new _n(Ie)),Ie=>_.triggerEvent(new on(Ie)))}setUpPreloading(){this.subscription=this.router.events.pipe((0,fn.h)(_=>_ instanceof q1),(0,Ut.b)(()=>this.preload())).subscribe(()=>{})}preload(){const _=this.injector.get(M.h0i);return this.processRoutes(_,this.router.config)}ngOnDestroy(){this.subscription&&this.subscription.unsubscribe()}processRoutes(_,T){const V=[];for(const G of T)if(G.loadChildren&&!G.canLoad&&G._loadedConfig){const te=G._loadedConfig;V.push(this.processRoutes(te.module,te.routes))}else G.loadChildren&&!G.canLoad?V.push(this.preloadConfig(_,G)):G.children&&V.push(this.processRoutes(_,G.children));return(0,ye.D)(V).pipe((0,Xi.J)(),(0,zt.U)(G=>{}))}preloadConfig(_,T){return this.preloadingStrategy.preload(T,()=>(T._loadedConfig?(0,ce.of)(T._loadedConfig):this.loader.load(_.injector,T)).pipe((0,y1.zg)(G=>(T._loadedConfig=G,this.processRoutes(G.module,G.routes)))))}}return z.\u0275fac=function(_){return new(_||z)(M.LFG(Bi),M.LFG(M.Sil),M.LFG(M.zs3),M.LFG(J2))},z.\u0275prov=M.Yz7({token:z,factory:z.\u0275fac}),z})(),j2=(()=>{class z{constructor(_,T,V={}){this.router=_,this.viewportScroller=T,this.options=V,this.lastId=0,this.lastSource="imperative",this.restoredId=0,this.store={},V.scrollPositionRestoration=V.scrollPositionRestoration||"disabled",V.anchorScrolling=V.anchorScrolling||"disabled"}init(){"disabled"!==this.options.scrollPositionRestoration&&this.viewportScroller.setHistoryScrollRestoration("manual"),this.routerEventsSubscription=this.createScrollEvents(),this.scrollEventsSubscription=this.consumeScrollEvents()}createScrollEvents(){return this.router.events.subscribe(_=>{_ instanceof a1?(this.store[this.lastId]=this.viewportScroller.getScrollPosition(),this.lastSource=_.navigationTrigger,this.restoredId=_.restoredState?_.restoredState.navigationId:0):_ instanceof q1&&(this.lastId=_.id,this.scheduleScrollEvent(_,this.router.parseUrl(_.urlAfterRedirects).fragment))})}consumeScrollEvents(){return this.router.events.subscribe(_=>{_ instanceof Nt&&(_.position?"top"===this.options.scrollPositionRestoration?this.viewportScroller.scrollToPosition([0,0]):"enabled"===this.options.scrollPositionRestoration&&this.viewportScroller.scrollToPosition(_.position):_.anchor&&"enabled"===this.options.anchorScrolling?this.viewportScroller.scrollToAnchor(_.anchor):"disabled"!==this.options.scrollPositionRestoration&&this.viewportScroller.scrollToPosition([0,0]))})}scheduleScrollEvent(_,T){this.router.triggerEvent(new Nt(_,"popstate"===this.lastSource?this.store[this.restoredId]:null,T))}ngOnDestroy(){this.routerEventsSubscription&&this.routerEventsSubscription.unsubscribe(),this.scrollEventsSubscription&&this.scrollEventsSubscription.unsubscribe()}}return z.\u0275fac=function(_){M.$Z()},z.\u0275prov=M.Yz7({token:z,factory:z.\u0275fac}),z})();const Vr=new M.OlP("ROUTER_CONFIGURATION"),Is=new M.OlP("ROUTER_FORROOT_GUARD"),dc=[j1.Ye,{provide:M1,useClass:Ei},{provide:Bi,useFactory:function Ko(z,x,_,T,V,G,te={},se,Ie){const In=new Bi(null,z,x,_,T,V,ma(G));return se&&(In.urlHandlingStrategy=se),Ie&&(In.routeReuseStrategy=Ie),function b2(z,x){z.errorHandler&&(x.errorHandler=z.errorHandler),z.malformedUriErrorHandler&&(x.malformedUriErrorHandler=z.malformedUriErrorHandler),z.onSameUrlNavigation&&(x.onSameUrlNavigation=z.onSameUrlNavigation),z.paramsInheritanceStrategy&&(x.paramsInheritanceStrategy=z.paramsInheritanceStrategy),z.relativeLinkResolution&&(x.relativeLinkResolution=z.relativeLinkResolution),z.urlUpdateStrategy&&(x.urlUpdateStrategy=z.urlUpdateStrategy),z.canceledNavigationResolution&&(x.canceledNavigationResolution=z.canceledNavigationResolution)}(te,In),te.enableTracing&&In.events.subscribe(Ot=>{var un,Kn;null===(un=console.group)||void 0===un||un.call(console,`Router Event: ${Ot.constructor.name}`),console.log(Ot.toString()),console.log(Ot),null===(Kn=console.groupEnd)||void 0===Kn||Kn.call(console)}),In},deps:[M1,ya,j1.Ye,M.zs3,M.Sil,xo,Vr,[class n2{},new M.FiY],[class It{},new M.FiY]]},ya,{provide:u1,useFactory:function wo(z){return z.routerState.root},deps:[Bi]},Or,T2,class So{preload(x,_){return _().pipe(yn(()=>(0,ce.of)(null)))}},{provide:Vr,useValue:{enableTracing:!1}}];function v2(){return new M.PXZ("Router",Bi)}let Os=(()=>{class z{constructor(_,T){}static forRoot(_,T){return{ngModule:z,providers:[dc,Mo(_),{provide:Is,useFactory:Jo,deps:[[Bi,new M.FiY,new M.tp0]]},{provide:Vr,useValue:T||{}},{provide:j1.S$,useFactory:k2,deps:[j1.lw,[new M.tBr(j1.mr),new M.FiY],Vr]},{provide:j2,useFactory:yr,deps:[Bi,j1.EM,Vr]},{provide:J2,useExisting:T&&T.preloadingStrategy?T.preloadingStrategy:T2},{provide:M.PXZ,multi:!0,useFactory:v2},[or,{provide:M.ip1,multi:!0,useFactory:_r,deps:[or]},{provide:xr,useFactory:Hr,deps:[or]},{provide:M.tb,multi:!0,useExisting:xr}]]}}static forChild(_){return{ngModule:z,providers:[Mo(_)]}}}return z.\u0275fac=function(_){return new(_||z)(M.LFG(Is,8),M.LFG(Bi,8))},z.\u0275mod=M.oAB({type:z}),z.\u0275inj=M.cJS({}),z})();function yr(z,x,_){return _.scrollOffset&&x.setOffset(_.scrollOffset),new j2(z,x,_)}function k2(z,x,_={}){return _.useHash?new j1.Do(z,x):new j1.b0(z,x)}function Jo(z){return"guarded"}function Mo(z){return[{provide:M.deG,multi:!0,useValue:z},{provide:xo,multi:!0,useValue:z}]}let or=(()=>{class z{constructor(_){this.injector=_,this.initNavigation=!1,this.destroyed=!1,this.resultOfPreactivationDone=new dn.xQ}appInitializer(){return this.injector.get(j1.V_,Promise.resolve(null)).then(()=>{if(this.destroyed)return Promise.resolve(!0);let T=null;const V=new Promise(se=>T=se),G=this.injector.get(Bi),te=this.injector.get(Vr);return"disabled"===te.initialNavigation?(G.setUpLocationChangeListener(),T(!0)):"enabled"===te.initialNavigation||"enabledBlocking"===te.initialNavigation?(G.hooks.afterPreactivation=()=>this.initNavigation?(0,ce.of)(null):(this.initNavigation=!0,T(!0),this.resultOfPreactivationDone),G.initialNavigation()):T(!0),V})}bootstrapListener(_){const T=this.injector.get(Vr),V=this.injector.get(Or),G=this.injector.get(j2),te=this.injector.get(Bi),se=this.injector.get(M.z2F);_===se.components[0]&&(("enabledNonBlocking"===T.initialNavigation||void 0===T.initialNavigation)&&te.initialNavigation(),V.setUpPreloading(),G.init(),te.resetRootComponentType(se.componentTypes[0]),this.resultOfPreactivationDone.next(null),this.resultOfPreactivationDone.complete())}ngOnDestroy(){this.destroyed=!0}}return z.\u0275fac=function(_){return new(_||z)(M.LFG(M.zs3))},z.\u0275prov=M.Yz7({token:z,factory:z.\u0275fac}),z})();function _r(z){return z.appInitializer.bind(z)}function Hr(z){return z.bootstrapListener.bind(z)}const xr=new M.OlP("Router Initializer")},9444:(Xn,He,Q)=>{"use strict";Q.d(He,{BN:()=>gi,uH:()=>g2});var M=Q(6435);function d(O){return(d="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(Z){return typeof Z}:function(Z){return Z&&"function"==typeof Symbol&&Z.constructor===Symbol&&Z!==Symbol.prototype?"symbol":typeof Z})(O)}function Oe(O,Z){for(var Y=0;Y<Z.length;Y++){var ne=Z[Y];ne.enumerable=ne.enumerable||!1,ne.configurable=!0,"value"in ne&&(ne.writable=!0),Object.defineProperty(O,ne.key,ne)}}function he(O,Z,Y){return Z in O?Object.defineProperty(O,Z,{value:Y,enumerable:!0,configurable:!0,writable:!0}):O[Z]=Y,O}function oe(O){for(var Z=1;Z<arguments.length;Z++){var Y=null!=arguments[Z]?arguments[Z]:{},ne=Object.keys(Y);"function"==typeof Object.getOwnPropertySymbols&&(ne=ne.concat(Object.getOwnPropertySymbols(Y).filter(function(ve){return Object.getOwnPropertyDescriptor(Y,ve).enumerable}))),ne.forEach(function(ve){he(O,ve,Y[ve])})}return O}function ce(O,Z){return function pe(O){if(Array.isArray(O))return O}(O)||function Ae(O,Z){var Y=[],ne=!0,ve=!1,Pe=void 0;try{for(var Be,Fe=O[Symbol.iterator]();!(ne=(Be=Fe.next()).done)&&(Y.push(Be.value),!Z||Y.length!==Z);ne=!0);}catch(An){ve=!0,Pe=An}finally{try{!ne&&null!=Fe.return&&Fe.return()}finally{if(ve)throw Pe}}return Y}(O,Z)||function rn(){throw new TypeError("Invalid attempt to destructure non-iterable instance")}()}var Qe={},ot={};try{"undefined"!=typeof window&&(Qe=window),"undefined"!=typeof document&&(ot=document),"undefined"!=typeof MutationObserver&&MutationObserver,"undefined"!=typeof performance&&performance}catch(O){}var cn=(Qe.navigator||{}).userAgent,fn=void 0===cn?"":cn,g1=Qe,mt=ot,tt=!!mt.documentElement&&!!mt.head&&"function"==typeof mt.addEventListener&&"function"==typeof mt.createElement,Le=(~fn.indexOf("MSIE")||fn.indexOf("Trident/"),"___FONT_AWESOME___"),me="svg-inline--fa",pi=[1,2,3,4,5,6,7,8,9,10],Xi=pi.concat([11,12,13,14,15,16,17,18,19,20]),Gt={GROUP:"group",SWAP_OPACITY:"swap-opacity",PRIMARY:"primary",SECONDARY:"secondary"},q1=(["xs","sm","lg","fw","ul","li","border","pull-left","pull-right","spin","pulse","rotate-90","rotate-180","rotate-270","flip-horizontal","flip-vertical","flip-both","stack","stack-1x","stack-2x","inverse","layers","layers-text","layers-counter",Gt.GROUP,Gt.SWAP_OPACITY,Gt.PRIMARY,Gt.SECONDARY].concat(pi.map(function(O){return"".concat(O,"x")})).concat(Xi.map(function(O){return"w-".concat(O)})),g1.FontAwesomeConfig||{});mt&&"function"==typeof mt.querySelector&&[["data-family-prefix","familyPrefix"],["data-replacement-class","replacementClass"],["data-auto-replace-svg","autoReplaceSvg"],["data-auto-add-css","autoAddCss"],["data-auto-a11y","autoA11y"],["data-search-pseudo-elements","searchPseudoElements"],["data-observe-mutations","observeMutations"],["data-mutate-approach","mutateApproach"],["data-keep-original-source","keepOriginalSource"],["data-measure-performance","measurePerformance"],["data-show-missing-icons","showMissingIcons"]].forEach(function(O){var Z=ce(O,2),ne=Z[1],ve=function Mi(O){return""===O||"false"!==O&&("true"===O||O)}(function xt(O){var Z=mt.querySelector("script["+O+"]");if(Z)return Z.getAttribute(O)}(Z[0]));null!=ve&&(q1[ne]=ve)});var wi=oe({},{familyPrefix:"fa",replacementClass:me,autoReplaceSvg:!0,autoAddCss:!0,autoA11y:!0,searchPseudoElements:!1,observeMutations:!0,mutateApproach:"async",keepOriginalSource:!0,measurePerformance:!1,showMissingIcons:!0},q1);wi.autoReplaceSvg||(wi.observeMutations=!1);var Rn=oe({},wi);g1.FontAwesomeConfig=Rn;var xn=g1||{};xn[Le]||(xn[Le]={}),xn[Le].styles||(xn[Le].styles={}),xn[Le].hooks||(xn[Le].hooks={}),xn[Le].shims||(xn[Le].shims=[]);var _n=xn[Le],on=[];tt&&((mt.documentElement.doScroll?/^loaded|^c/:/^loaded|^i|^c/).test(mt.readyState)||mt.addEventListener("DOMContentLoaded",function O(){mt.removeEventListener("DOMContentLoaded",O),on.map(function(Z){return Z()})}));var _1,jn="pending",Nt="settled",On="fulfilled",ht="rejected",Wt=function(){},e1="undefined"!=typeof global&&void 0!==global.process&&"function"==typeof global.process.emit,gt="undefined"==typeof setImmediate?setTimeout:setImmediate,Mt=[];function m1(){for(var O=0;O<Mt.length;O++)Mt[O][0](Mt[O][1]);Mt=[],_1=!1}function et(O,Z){Mt.push([O,Z]),_1||(_1=!0,gt(m1,0))}function ma(O){var Z=O.owner,Y=Z._state,ne=Z._data,ve=O[Y],Pe=O.then;if("function"==typeof ve){Y=On;try{ne=ve(ne)}catch(Fe){r1(Pe,Fe)}}Ni(Pe,ne)||(Y===On&&Di(Pe,ne),Y===ht&&r1(Pe,ne))}function Ni(O,Z){var Y;try{if(O===Z)throw new TypeError("A promises callback cannot return that same promise.");if(Z&&("function"==typeof Z||"object"===d(Z))){var ne=Z.then;if("function"==typeof ne)return ne.call(Z,function(ve){Y||(Y=!0,Z===ve?kt(O,ve):Di(O,ve))},function(ve){Y||(Y=!0,r1(O,ve))}),!0}}catch(ve){return Y||r1(O,ve),!0}return!1}function Di(O,Z){(O===Z||!Ni(O,Z))&&kt(O,Z)}function kt(O,Z){O._state===jn&&(O._state=Nt,O._data=Z,et(za,O))}function r1(O,Z){O._state===jn&&(O._state=Nt,O._data=Z,et(Na,O))}function Yi(O){O._then=O._then.forEach(ma)}function za(O){O._state=On,Yi(O)}function Na(O){O._state=ht,Yi(O),!O._handled&&e1&&global.process.emit("unhandledRejection",O._data,O)}function we(O){global.process.emit("rejectionHandled",O)}function de(O){if("function"!=typeof O)throw new TypeError("Promise resolver "+O+" is not a function");if(!(this instanceof de))throw new TypeError("Failed to construct 'Promise': Please use the 'new' operator, this object constructor cannot be called as a function.");this._then=[],function k1(O,Z){function ne(ve){r1(Z,ve)}try{O(function Y(ve){Di(Z,ve)},ne)}catch(ve){ne(ve)}}(O,this)}de.prototype={constructor:de,_state:jn,_then:null,_data:void 0,_handled:!1,then:function(Z,Y){var ne={owner:this,then:new this.constructor(Wt),fulfilled:Z,rejected:Y};return(Y||Z)&&!this._handled&&(this._handled=!0,this._state===ht&&e1&&et(we,this)),this._state===On||this._state===ht?et(ma,ne):this._then.push(ne),ne.then},catch:function(Z){return this.then(null,Z)}},de.all=function(O){if(!Array.isArray(O))throw new TypeError("You must pass an array to Promise.all().");return new de(function(Z,Y){var ne=[],ve=0;function Pe(An){return ve++,function(dt){ne[An]=dt,--ve||Z(ne)}}for(var Be,Fe=0;Fe<O.length;Fe++)(Be=O[Fe])&&"function"==typeof Be.then?Be.then(Pe(Fe),Y):ne[Fe]=Be;ve||Z(ne)})},de.race=function(O){if(!Array.isArray(O))throw new TypeError("You must pass an array to Promise.race().");return new de(function(Z,Y){for(var ve,ne=0;ne<O.length;ne++)(ve=O[ne])&&"function"==typeof ve.then?ve.then(Z,Y):Z(ve)})},de.resolve=function(O){return O&&"object"===d(O)&&O.constructor===de?O:new de(function(Z){Z(O)})},de.reject=function(O){return new de(function(Z,Y){Y(O)})};var Re={size:16,x:0,y:0,rotate:0,flipX:!1,flipY:!1};function Sn(){for(var O=12,Z="";O-- >0;)Z+="0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ"[62*Math.random()|0];return Z}function P1(O){return"".concat(O).replace(/&/g,"&amp;").replace(/"/g,"&quot;").replace(/'/g,"&#39;").replace(/</g,"&lt;").replace(/>/g,"&gt;")}function Ei(O){return Object.keys(O||{}).reduce(function(Z,Y){return Z+"".concat(Y,": ").concat(O[Y],";")},"")}function Ft(O){return O.size!==Re.size||O.x!==Re.x||O.y!==Re.y||O.rotate!==Re.rotate||O.flipX||O.flipY}function mn(O){var Z=O.transform,ne=O.iconWidth,ve={transform:"translate(".concat(O.containerWidth/2," 256)")},Pe="translate(".concat(32*Z.x,", ").concat(32*Z.y,") "),Fe="scale(".concat(Z.size/16*(Z.flipX?-1:1),", ").concat(Z.size/16*(Z.flipY?-1:1),") "),Be="rotate(".concat(Z.rotate," 0 0)");return{outer:ve,inner:{transform:"".concat(Pe," ").concat(Fe," ").concat(Be)},path:{transform:"translate(".concat(ne/2*-1," -256)")}}}var Ai={x:0,y:0,width:"100%",height:"100%"};function qt(O){var Z=!(arguments.length>1&&void 0!==arguments[1])||arguments[1];return O.attributes&&(O.attributes.fill||Z)&&(O.attributes.fill="black"),O}function Ze(O){return"g"===O.tag?O.children:[O]}function wn(O){var Z=O.icons,Y=Z.main,ne=Z.mask,ve=O.prefix,Pe=O.iconName,Fe=O.transform,Be=O.symbol,An=O.title,dt=O.maskId,ft=O.titleId,Tt=O.extra,Yt=O.watchable,z1=void 0!==Yt&&Yt,oi=ne.found?ne:Y,Y1=oi.width,ni=oi.height,N1="fak"===ve,vi=N1?"":"fa-w-".concat(Math.ceil(Y1/ni*16)),qi=[Rn.replacementClass,Pe?"".concat(Rn.familyPrefix,"-").concat(Pe):"",vi].filter(function(e2){return-1===Tt.classes.indexOf(e2)}).filter(function(e2){return""!==e2||!!e2}).concat(Tt.classes).join(" "),aa={children:[],attributes:oe({},Tt.attributes,{"data-prefix":ve,"data-icon":Pe,class:qi,role:Tt.attributes.role||"img",xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 ".concat(Y1," ").concat(ni)})},Ia=N1&&!~Tt.classes.indexOf("fa-fw")?{width:"".concat(Y1/ni*16*.0625,"em")}:{};z1&&(aa.attributes["data-fa-i2svg"]=""),An&&aa.children.push({tag:"title",attributes:{id:aa.attributes["aria-labelledby"]||"title-".concat(ft||Sn())},children:[An]});var R1=oe({},aa,{prefix:ve,iconName:Pe,main:Y,mask:ne,maskId:dt,transform:Fe,symbol:Be,styles:oe({},Ia,Tt.styles)}),D1=ne.found&&Y.found?function Gn(O){var Z=O.children,Y=O.attributes,ne=O.main,ve=O.mask,Pe=O.maskId,An=ne.icon,ft=ve.icon,Tt=mn({transform:O.transform,containerWidth:ve.width,iconWidth:ne.width}),Yt={tag:"rect",attributes:oe({},Ai,{fill:"white"})},z1=An.children?{children:An.children.map(qt)}:{},oi={tag:"g",attributes:oe({},Tt.inner),children:[qt(oe({tag:An.tag,attributes:oe({},An.attributes,Tt.path)},z1))]},Y1={tag:"g",attributes:oe({},Tt.outer),children:[oi]},ni="mask-".concat(Pe||Sn()),N1="clip-".concat(Pe||Sn()),vi={tag:"mask",attributes:oe({},Ai,{id:ni,maskUnits:"userSpaceOnUse",maskContentUnits:"userSpaceOnUse"}),children:[Yt,Y1]},qi={tag:"defs",children:[{tag:"clipPath",attributes:{id:N1},children:Ze(ft)},vi]};return Z.push(qi,{tag:"rect",attributes:oe({fill:"currentColor","clip-path":"url(#".concat(N1,")"),mask:"url(#".concat(ni,")")},Ai)}),{children:Z,attributes:Y}}(R1):function yt(O){var Z=O.children,Y=O.attributes,ne=O.main,ve=O.transform,Fe=Ei(O.styles);if(Fe.length>0&&(Y.style=Fe),Ft(ve)){var Be=mn({transform:ve,containerWidth:ne.width,iconWidth:ne.width});Z.push({tag:"g",attributes:oe({},Be.outer),children:[{tag:"g",attributes:oe({},Be.inner),children:[{tag:ne.icon.tag,children:ne.icon.children,attributes:oe({},ne.icon.attributes,Be.path)}]}]})}else Z.push(ne.icon);return{children:Z,attributes:Y}}(R1),It=D1.attributes;return R1.children=D1.children,R1.attributes=It,Be?function We(O){var Y=O.iconName,ne=O.children,Pe=O.symbol;return[{tag:"svg",attributes:{style:"display: none;"},children:[{tag:"symbol",attributes:oe({},O.attributes,{id:!0===Pe?"".concat(O.prefix,"-").concat(Rn.familyPrefix,"-").concat(Y):Pe}),children:ne}]}]}(R1):function v1(O){var Z=O.children,Y=O.main,ne=O.mask,ve=O.attributes,Pe=O.styles,Fe=O.transform;if(Ft(Fe)&&Y.found&&!ne.found){var dt={x:Y.width/Y.height/2,y:.5};ve.style=Ei(oe({},Pe,{"transform-origin":"".concat(dt.x+Fe.x/16,"em ").concat(dt.y+Fe.y/16,"em")}))}return[{tag:"svg",attributes:ve,children:Z}]}(R1)}var Xt=function(Z,Y,ne,ve){var An,dt,ft,Pe=Object.keys(Z),Fe=Pe.length,Be=void 0!==ve?function(Z,Y){return function(ne,ve,Pe,Fe){return Z.call(Y,ne,ve,Pe,Fe)}}(Y,ve):Y;for(void 0===ne?(An=1,ft=Z[Pe[0]]):(An=0,ft=ne);An<Fe;An++)ft=Be(ft,Z[dt=Pe[An]],dt,Z);return ft};function B1(O,Z){var Y=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{},ne=Y.skipHooks,ve=void 0!==ne&&ne,Pe=Object.keys(Z).reduce(function(Fe,Be){var An=Z[Be];return An.icon?Fe[An.iconName]=An.icon:Fe[Be]=An,Fe},{});"function"!=typeof _n.hooks.addPack||ve?_n.styles[O]=oe({},_n.styles[O]||{},Pe):_n.hooks.addPack(O,Pe),"fas"===O&&B1("fa",Z)}var o1=_n.styles,Ht=_n.shims,I1=function(){var Z=function(ve){return Xt(o1,function(Pe,Fe,Be){return Pe[Be]=Xt(Fe,ve,{}),Pe},{})};Z(function(ne,ve,Pe){return ve[3]&&(ne[ve[3]]=Pe),ne}),Z(function(ne,ve,Pe){var Fe=ve[2];return ne[Pe]=Pe,Fe.forEach(function(Be){ne[Be]=Pe}),ne});var Y="far"in o1;Xt(Ht,function(ne,ve){var Fe=ve[1];return"far"===Fe&&!Y&&(Fe="fas"),ne[ve[0]]={prefix:Fe,iconName:ve[2]},ne},{})};function ar(O,Z,Y){if(O&&O[Z]&&O[Z][Y])return{prefix:Z,iconName:Y,icon:O[Z][Y]}}function Ba(O){var Z=O.tag,Y=O.attributes,ne=void 0===Y?{}:Y,ve=O.children,Pe=void 0===ve?[]:ve;return"string"==typeof O?P1(O):"<".concat(Z," ").concat(function M1(O){return Object.keys(O||{}).reduce(function(Z,Y){return Z+"".concat(Y,'="').concat(P1(O[Y]),'" ')},"").trim()}(ne),">").concat(Pe.map(Ba).join(""),"</").concat(Z,">")}I1();function ja(O){this.name="MissingIcon",this.message=O||"Icon unavailable",this.stack=(new Error).stack}(ja.prototype=Object.create(Error.prototype)).constructor=ja;var Ti={fill:"currentColor"},Kr={attributeType:"XML",repeatCount:"indefinite",dur:"2s"},ai=(oe({},Ti,{d:"M156.5,447.7l-12.6,29.5c-18.7-9.5-35.9-21.2-51.5-34.9l22.7-22.7C127.6,430.5,141.5,440,156.5,447.7z M40.6,272H8.5 c1.4,21.2,5.4,41.7,11.7,61.1L50,321.2C45.1,305.5,41.8,289,40.6,272z M40.6,240c1.4-18.8,5.2-37,11.1-54.1l-29.5-12.6 C14.7,194.3,10,216.7,8.5,240H40.6z M64.3,156.5c7.8-14.9,17.2-28.8,28.1-41.5L69.7,92.3c-13.7,15.6-25.5,32.8-34.9,51.5 L64.3,156.5z M397,419.6c-13.9,12-29.4,22.3-46.1,30.4l11.9,29.8c20.7-9.9,39.8-22.6,56.9-37.6L397,419.6z M115,92.4 c13.9-12,29.4-22.3,46.1-30.4l-11.9-29.8c-20.7,9.9-39.8,22.6-56.8,37.6L115,92.4z M447.7,355.5c-7.8,14.9-17.2,28.8-28.1,41.5 l22.7,22.7c13.7-15.6,25.5-32.9,34.9-51.5L447.7,355.5z M471.4,272c-1.4,18.8-5.2,37-11.1,54.1l29.5,12.6 c7.5-21.1,12.2-43.5,13.6-66.8H471.4z M321.2,462c-15.7,5-32.2,8.2-49.2,9.4v32.1c21.2-1.4,41.7-5.4,61.1-11.7L321.2,462z M240,471.4c-18.8-1.4-37-5.2-54.1-11.1l-12.6,29.5c21.1,7.5,43.5,12.2,66.8,13.6V471.4z M462,190.8c5,15.7,8.2,32.2,9.4,49.2h32.1 c-1.4-21.2-5.4-41.7-11.7-61.1L462,190.8z M92.4,397c-12-13.9-22.3-29.4-30.4-46.1l-29.8,11.9c9.9,20.7,22.6,39.8,37.6,56.9 L92.4,397z M272,40.6c18.8,1.4,36.9,5.2,54.1,11.1l12.6-29.5C317.7,14.7,295.3,10,272,8.5V40.6z M190.8,50 c15.7-5,32.2-8.2,49.2-9.4V8.5c-21.2,1.4-41.7,5.4-61.1,11.7L190.8,50z M442.3,92.3L419.6,115c12,13.9,22.3,29.4,30.5,46.1 l29.8-11.9C470,128.5,457.3,109.4,442.3,92.3z M397,92.4l22.7-22.7c-15.6-13.7-32.8-25.5-51.5-34.9l-12.6,29.5 C370.4,72.1,384.4,81.5,397,92.4z"}),oe({},Kr,{attributeName:"opacity"}));function Za(O){var Z=O[0],Y=O[1],Pe=ce(O.slice(4),1)[0];return{found:!0,width:Z,height:Y,icon:Array.isArray(Pe)?{tag:"g",attributes:{class:"".concat(Rn.familyPrefix,"-").concat(Gt.GROUP)},children:[{tag:"path",attributes:{class:"".concat(Rn.familyPrefix,"-").concat(Gt.SECONDARY),fill:"currentColor",d:Pe[0]}},{tag:"path",attributes:{class:"".concat(Rn.familyPrefix,"-").concat(Gt.PRIMARY),fill:"currentColor",d:Pe[1]}}]}:{tag:"path",attributes:{fill:"currentColor",d:Pe}}}}function Dt(){Rn.autoAddCss&&!H1&&(function it(O){if(O&&tt){var Z=mt.createElement("style");Z.setAttribute("type","text/css"),Z.innerHTML=O;for(var Y=mt.head.childNodes,ne=null,ve=Y.length-1;ve>-1;ve--){var Pe=Y[ve],Fe=(Pe.tagName||"").toUpperCase();["STYLE","LINK"].indexOf(Fe)>-1&&(ne=Pe)}return mt.head.insertBefore(Z,ne),O}}(function Pt(){var O="fa",Z=me,Y=Rn.familyPrefix,ne=Rn.replacementClass,ve='svg:not(:root).svg-inline--fa {\n  overflow: visible;\n}\n\n.svg-inline--fa {\n  display: inline-block;\n  font-size: inherit;\n  height: 1em;\n  overflow: visible;\n  vertical-align: -0.125em;\n}\n.svg-inline--fa.fa-lg {\n  vertical-align: -0.225em;\n}\n.svg-inline--fa.fa-w-1 {\n  width: 0.0625em;\n}\n.svg-inline--fa.fa-w-2 {\n  width: 0.125em;\n}\n.svg-inline--fa.fa-w-3 {\n  width: 0.1875em;\n}\n.svg-inline--fa.fa-w-4 {\n  width: 0.25em;\n}\n.svg-inline--fa.fa-w-5 {\n  width: 0.3125em;\n}\n.svg-inline--fa.fa-w-6 {\n  width: 0.375em;\n}\n.svg-inline--fa.fa-w-7 {\n  width: 0.4375em;\n}\n.svg-inline--fa.fa-w-8 {\n  width: 0.5em;\n}\n.svg-inline--fa.fa-w-9 {\n  width: 0.5625em;\n}\n.svg-inline--fa.fa-w-10 {\n  width: 0.625em;\n}\n.svg-inline--fa.fa-w-11 {\n  width: 0.6875em;\n}\n.svg-inline--fa.fa-w-12 {\n  width: 0.75em;\n}\n.svg-inline--fa.fa-w-13 {\n  width: 0.8125em;\n}\n.svg-inline--fa.fa-w-14 {\n  width: 0.875em;\n}\n.svg-inline--fa.fa-w-15 {\n  width: 0.9375em;\n}\n.svg-inline--fa.fa-w-16 {\n  width: 1em;\n}\n.svg-inline--fa.fa-w-17 {\n  width: 1.0625em;\n}\n.svg-inline--fa.fa-w-18 {\n  width: 1.125em;\n}\n.svg-inline--fa.fa-w-19 {\n  width: 1.1875em;\n}\n.svg-inline--fa.fa-w-20 {\n  width: 1.25em;\n}\n.svg-inline--fa.fa-pull-left {\n  margin-right: 0.3em;\n  width: auto;\n}\n.svg-inline--fa.fa-pull-right {\n  margin-left: 0.3em;\n  width: auto;\n}\n.svg-inline--fa.fa-border {\n  height: 1.5em;\n}\n.svg-inline--fa.fa-li {\n  width: 2em;\n}\n.svg-inline--fa.fa-fw {\n  width: 1.25em;\n}\n\n.fa-layers svg.svg-inline--fa {\n  bottom: 0;\n  left: 0;\n  margin: auto;\n  position: absolute;\n  right: 0;\n  top: 0;\n}\n\n.fa-layers {\n  display: inline-block;\n  height: 1em;\n  position: relative;\n  text-align: center;\n  vertical-align: -0.125em;\n  width: 1em;\n}\n.fa-layers svg.svg-inline--fa {\n  -webkit-transform-origin: center center;\n          transform-origin: center center;\n}\n\n.fa-layers-counter, .fa-layers-text {\n  display: inline-block;\n  position: absolute;\n  text-align: center;\n}\n\n.fa-layers-text {\n  left: 50%;\n  top: 50%;\n  -webkit-transform: translate(-50%, -50%);\n          transform: translate(-50%, -50%);\n  -webkit-transform-origin: center center;\n          transform-origin: center center;\n}\n\n.fa-layers-counter {\n  background-color: #ff253a;\n  border-radius: 1em;\n  -webkit-box-sizing: border-box;\n          box-sizing: border-box;\n  color: #fff;\n  height: 1.5em;\n  line-height: 1;\n  max-width: 5em;\n  min-width: 1.5em;\n  overflow: hidden;\n  padding: 0.25em;\n  right: 0;\n  text-overflow: ellipsis;\n  top: 0;\n  -webkit-transform: scale(0.25);\n          transform: scale(0.25);\n  -webkit-transform-origin: top right;\n          transform-origin: top right;\n}\n\n.fa-layers-bottom-right {\n  bottom: 0;\n  right: 0;\n  top: auto;\n  -webkit-transform: scale(0.25);\n          transform: scale(0.25);\n  -webkit-transform-origin: bottom right;\n          transform-origin: bottom right;\n}\n\n.fa-layers-bottom-left {\n  bottom: 0;\n  left: 0;\n  right: auto;\n  top: auto;\n  -webkit-transform: scale(0.25);\n          transform: scale(0.25);\n  -webkit-transform-origin: bottom left;\n          transform-origin: bottom left;\n}\n\n.fa-layers-top-right {\n  right: 0;\n  top: 0;\n  -webkit-transform: scale(0.25);\n          transform: scale(0.25);\n  -webkit-transform-origin: top right;\n          transform-origin: top right;\n}\n\n.fa-layers-top-left {\n  left: 0;\n  right: auto;\n  top: 0;\n  -webkit-transform: scale(0.25);\n          transform: scale(0.25);\n  -webkit-transform-origin: top left;\n          transform-origin: top left;\n}\n\n.fa-lg {\n  font-size: 1.3333333333em;\n  line-height: 0.75em;\n  vertical-align: -0.0667em;\n}\n\n.fa-xs {\n  font-size: 0.75em;\n}\n\n.fa-sm {\n  font-size: 0.875em;\n}\n\n.fa-1x {\n  font-size: 1em;\n}\n\n.fa-2x {\n  font-size: 2em;\n}\n\n.fa-3x {\n  font-size: 3em;\n}\n\n.fa-4x {\n  font-size: 4em;\n}\n\n.fa-5x {\n  font-size: 5em;\n}\n\n.fa-6x {\n  font-size: 6em;\n}\n\n.fa-7x {\n  font-size: 7em;\n}\n\n.fa-8x {\n  font-size: 8em;\n}\n\n.fa-9x {\n  font-size: 9em;\n}\n\n.fa-10x {\n  font-size: 10em;\n}\n\n.fa-fw {\n  text-align: center;\n  width: 1.25em;\n}\n\n.fa-ul {\n  list-style-type: none;\n  margin-left: 2.5em;\n  padding-left: 0;\n}\n.fa-ul > li {\n  position: relative;\n}\n\n.fa-li {\n  left: -2em;\n  position: absolute;\n  text-align: center;\n  width: 2em;\n  line-height: inherit;\n}\n\n.fa-border {\n  border: solid 0.08em #eee;\n  border-radius: 0.1em;\n  padding: 0.2em 0.25em 0.15em;\n}\n\n.fa-pull-left {\n  float: left;\n}\n\n.fa-pull-right {\n  float: right;\n}\n\n.fa.fa-pull-left,\n.fas.fa-pull-left,\n.far.fa-pull-left,\n.fal.fa-pull-left,\n.fab.fa-pull-left {\n  margin-right: 0.3em;\n}\n.fa.fa-pull-right,\n.fas.fa-pull-right,\n.far.fa-pull-right,\n.fal.fa-pull-right,\n.fab.fa-pull-right {\n  margin-left: 0.3em;\n}\n\n.fa-spin {\n  -webkit-animation: fa-spin 2s infinite linear;\n          animation: fa-spin 2s infinite linear;\n}\n\n.fa-pulse {\n  -webkit-animation: fa-spin 1s infinite steps(8);\n          animation: fa-spin 1s infinite steps(8);\n}\n\n@-webkit-keyframes fa-spin {\n  0% {\n    -webkit-transform: rotate(0deg);\n            transform: rotate(0deg);\n  }\n  100% {\n    -webkit-transform: rotate(360deg);\n            transform: rotate(360deg);\n  }\n}\n\n@keyframes fa-spin {\n  0% {\n    -webkit-transform: rotate(0deg);\n            transform: rotate(0deg);\n  }\n  100% {\n    -webkit-transform: rotate(360deg);\n            transform: rotate(360deg);\n  }\n}\n.fa-rotate-90 {\n  -ms-filter: "progid:DXImageTransform.Microsoft.BasicImage(rotation=1)";\n  -webkit-transform: rotate(90deg);\n          transform: rotate(90deg);\n}\n\n.fa-rotate-180 {\n  -ms-filter: "progid:DXImageTransform.Microsoft.BasicImage(rotation=2)";\n  -webkit-transform: rotate(180deg);\n          transform: rotate(180deg);\n}\n\n.fa-rotate-270 {\n  -ms-filter: "progid:DXImageTransform.Microsoft.BasicImage(rotation=3)";\n  -webkit-transform: rotate(270deg);\n          transform: rotate(270deg);\n}\n\n.fa-flip-horizontal {\n  -ms-filter: "progid:DXImageTransform.Microsoft.BasicImage(rotation=0, mirror=1)";\n  -webkit-transform: scale(-1, 1);\n          transform: scale(-1, 1);\n}\n\n.fa-flip-vertical {\n  -ms-filter: "progid:DXImageTransform.Microsoft.BasicImage(rotation=2, mirror=1)";\n  -webkit-transform: scale(1, -1);\n          transform: scale(1, -1);\n}\n\n.fa-flip-both, .fa-flip-horizontal.fa-flip-vertical {\n  -ms-filter: "progid:DXImageTransform.Microsoft.BasicImage(rotation=2, mirror=1)";\n  -webkit-transform: scale(-1, -1);\n          transform: scale(-1, -1);\n}\n\n:root .fa-rotate-90,\n:root .fa-rotate-180,\n:root .fa-rotate-270,\n:root .fa-flip-horizontal,\n:root .fa-flip-vertical,\n:root .fa-flip-both {\n  -webkit-filter: none;\n          filter: none;\n}\n\n.fa-stack {\n  display: inline-block;\n  height: 2em;\n  position: relative;\n  width: 2.5em;\n}\n\n.fa-stack-1x,\n.fa-stack-2x {\n  bottom: 0;\n  left: 0;\n  margin: auto;\n  position: absolute;\n  right: 0;\n  top: 0;\n}\n\n.svg-inline--fa.fa-stack-1x {\n  height: 1em;\n  width: 1.25em;\n}\n.svg-inline--fa.fa-stack-2x {\n  height: 2em;\n  width: 2.5em;\n}\n\n.fa-inverse {\n  color: #fff;\n}\n\n.sr-only {\n  border: 0;\n  clip: rect(0, 0, 0, 0);\n  height: 1px;\n  margin: -1px;\n  overflow: hidden;\n  padding: 0;\n  position: absolute;\n  width: 1px;\n}\n\n.sr-only-focusable:active, .sr-only-focusable:focus {\n  clip: auto;\n  height: auto;\n  margin: 0;\n  overflow: visible;\n  position: static;\n  width: auto;\n}\n\n.svg-inline--fa .fa-primary {\n  fill: var(--fa-primary-color, currentColor);\n  opacity: 1;\n  opacity: var(--fa-primary-opacity, 1);\n}\n\n.svg-inline--fa .fa-secondary {\n  fill: var(--fa-secondary-color, currentColor);\n  opacity: 0.4;\n  opacity: var(--fa-secondary-opacity, 0.4);\n}\n\n.svg-inline--fa.fa-swap-opacity .fa-primary {\n  opacity: 0.4;\n  opacity: var(--fa-secondary-opacity, 0.4);\n}\n\n.svg-inline--fa.fa-swap-opacity .fa-secondary {\n  opacity: 1;\n  opacity: var(--fa-primary-opacity, 1);\n}\n\n.svg-inline--fa mask .fa-primary,\n.svg-inline--fa mask .fa-secondary {\n  fill: black;\n}\n\n.fad.fa-inverse {\n  color: #fff;\n}';if(Y!==O||ne!==Z){var Pe=new RegExp("\\.".concat(O,"\\-"),"g"),Fe=new RegExp("\\--".concat(O,"\\-"),"g"),Be=new RegExp("\\.".concat(Z),"g");ve=ve.replace(Pe,".".concat(Y,"-")).replace(Fe,"--".concat(Y,"-")).replace(Be,".".concat(ne))}return ve}()),H1=!0)}function kn(O,Z){return Object.defineProperty(O,"abstract",{get:Z}),Object.defineProperty(O,"html",{get:function(){return O.abstract.map(function(ne){return Ba(ne)})}}),Object.defineProperty(O,"node",{get:function(){if(tt){var ne=mt.createElement("div");return ne.innerHTML=O.html,ne.children}}}),O}function c1(O){var Z=O.prefix,Y=void 0===Z?"fa":Z,ne=O.iconName;if(ne)return ar(h1.definitions,Y,ne)||ar(_n.styles,Y,ne)}oe({},Ti,{cx:"256",cy:"364",r:"28"}),oe({},Kr,{attributeName:"r",values:"28;14;28;28;14;28;"}),oe({},ai,{values:"1;0;1;1;0;1;"}),oe({},Ti,{opacity:"1",d:"M263.7,312h-16c-6.6,0-12-5.4-12-12c0-71,77.4-63.9,77.4-107.8c0-20-17.8-40.2-57.4-40.2c-29.1,0-44.3,9.6-59.2,28.7 c-3.9,5-11.1,6-16.2,2.4l-13.1-9.2c-5.6-3.9-6.9-11.8-2.6-17.2c21.2-27.2,46.4-44.7,91.2-44.7c52.3,0,97.4,29.8,97.4,80.2 c0,67.6-77.4,63.5-77.4,107.8C275.7,306.6,270.3,312,263.7,312z"}),oe({},ai,{values:"1;0;0;0;0;1;"}),oe({},Ti,{opacity:"0",d:"M232.5,134.5l7,168c0.3,6.4,5.6,11.5,12,11.5h9c6.4,0,11.7-5.1,12-11.5l7-168c0.3-6.8-5.2-12.5-12-12.5h-23 C237.7,122,232.2,127.7,232.5,134.5z"}),oe({},ai,{values:"0;0;1;1;0;0;"});var h1=new(function(){function O(){(function Ue(O,Z){if(!(O instanceof Z))throw new TypeError("Cannot call a class as a function")})(this,O),this.definitions={}}return function ye(O,Z,Y){Z&&Oe(O.prototype,Z),Y&&Oe(O,Y)}(O,[{key:"add",value:function(){for(var Y=this,ne=arguments.length,ve=new Array(ne),Pe=0;Pe<ne;Pe++)ve[Pe]=arguments[Pe];var Fe=ve.reduce(this._pullDefinitions,{});Object.keys(Fe).forEach(function(Be){Y.definitions[Be]=oe({},Y.definitions[Be]||{},Fe[Be]),B1(Be,Fe[Be]),I1()})}},{key:"reset",value:function(){this.definitions={}}},{key:"_pullDefinitions",value:function(Y,ne){var ve=ne.prefix&&ne.iconName&&ne.icon?{0:ne}:ne;return Object.keys(ve).map(function(Pe){var Fe=ve[Pe],Be=Fe.prefix,An=Fe.iconName,dt=Fe.icon;Y[Be]||(Y[Be]={}),Y[Be][An]=dt}),Y}}]),O}()),H1=!1,L_transform=function(Z){return function(Z){var Y={size:16,x:0,y:0,flipX:!1,flipY:!1,rotate:0};return Z?Z.toLowerCase().split(" ").reduce(function(ne,ve){var Pe=ve.toLowerCase().split("-"),Fe=Pe[0],Be=Pe.slice(1).join("-");if(Fe&&"h"===Be)return ne.flipX=!0,ne;if(Fe&&"v"===Be)return ne.flipY=!0,ne;if(Be=parseFloat(Be),isNaN(Be))return ne;switch(Fe){case"grow":ne.size=ne.size+Be;break;case"shrink":ne.size=ne.size-Be;break;case"left":ne.x=ne.x-Be;break;case"right":ne.x=ne.x+Be;break;case"up":ne.y=ne.y-Be;break;case"down":ne.y=ne.y+Be;break;case"rotate":ne.rotate=ne.rotate+Be}return ne},Y):Y}(Z)},D=function Jn(O){return function(Z){var Y=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},ne=(Z||{}).icon?Z:c1(Z||{}),ve=Y.mask;return ve&&(ve=(ve||{}).icon?ve:c1(ve||{})),O(ne,oe({},Y,{mask:ve}))}}(function(O){var Z=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},Y=Z.transform,ne=void 0===Y?Re:Y,ve=Z.symbol,Pe=void 0!==ve&&ve,Fe=Z.mask,Be=void 0===Fe?null:Fe,An=Z.maskId,dt=void 0===An?null:An,ft=Z.title,Tt=void 0===ft?null:ft,Yt=Z.titleId,z1=void 0===Yt?null:Yt,oi=Z.classes,Y1=void 0===oi?[]:oi,ni=Z.attributes,N1=void 0===ni?{}:ni,vi=Z.styles,qi=void 0===vi?{}:vi;if(O){var aa=O.prefix,Ia=O.iconName,R1=O.icon;return kn(oe({type:"icon"},O),function(){return Dt(),Rn.autoA11y&&(Tt?N1["aria-labelledby"]="".concat(Rn.replacementClass,"-title-").concat(z1||Sn()):(N1["aria-hidden"]="true",N1.focusable="false")),wn({icons:{main:Za(R1),mask:Be?Za(Be.icon):{found:!1,width:null,height:null,icon:{}}},prefix:aa,iconName:Ia,transform:oe({},Re,ne),symbol:Pe,title:Tt,maskId:dt,titleId:z1,extra:{attributes:N1,styles:qi,classes:Y1}})})}}),U1=Q(2313);const Ri=["*"],kr=O=>{const Z={"fa-spin":O.spin,"fa-pulse":O.pulse,"fa-fw":O.fixedWidth,"fa-border":O.border,"fa-inverse":O.inverse,"fa-layers-counter":O.counter,"fa-flip-horizontal":"horizontal"===O.flip||"both"===O.flip,"fa-flip-vertical":"vertical"===O.flip||"both"===O.flip,[`fa-${O.size}`]:null!==O.size,[`fa-rotate-${O.rotate}`]:null!==O.rotate,[`fa-pull-${O.pull}`]:null!==O.pull,[`fa-stack-${O.stackItemSize}`]:null!=O.stackItemSize};return Object.keys(Z).map(Y=>Z[Y]?Y:null).filter(Y=>Y)};let Fi=(()=>{class O{constructor(){this.defaultPrefix="fas",this.fallbackIcon=null}}return O.\u0275fac=function(Y){return new(Y||O)},O.\u0275prov=M.Yz7({token:O,factory:O.\u0275fac,providedIn:"root"}),O})(),b1=(()=>{class O{constructor(){this.definitions={}}addIcons(...Y){for(const ne of Y){ne.prefix in this.definitions||(this.definitions[ne.prefix]={}),this.definitions[ne.prefix][ne.iconName]=ne;for(const ve of ne.icon[2])"string"==typeof ve&&(this.definitions[ne.prefix][ve]=ne)}}addIconPacks(...Y){for(const ne of Y){const ve=Object.keys(ne).map(Pe=>ne[Pe]);this.addIcons(...ve)}}getIconDefinition(Y,ne){return Y in this.definitions&&ne in this.definitions[Y]?this.definitions[Y][ne]:null}}return O.\u0275fac=function(Y){return new(Y||O)},O.\u0275prov=M.Yz7({token:O,factory:O.\u0275fac,providedIn:"root"}),O})(),Pr=(()=>{class O{constructor(){this.stackItemSize="1x"}ngOnChanges(Y){if("size"in Y)throw new Error('fa-icon is not allowed to customize size when used inside fa-stack. Set size on the enclosing fa-stack instead: <fa-stack size="4x">...</fa-stack>.')}}return O.\u0275fac=function(Y){return new(Y||O)},O.\u0275dir=M.lG2({type:O,selectors:[["fa-icon","stackItemSize",""],["fa-duotone-icon","stackItemSize",""]],inputs:{stackItemSize:"stackItemSize",size:"size"},features:[M.TTD]}),O})(),gr=(()=>{class O{constructor(Y,ne){this.renderer=Y,this.elementRef=ne}ngOnInit(){this.renderer.addClass(this.elementRef.nativeElement,"fa-stack")}ngOnChanges(Y){"size"in Y&&(null!=Y.size.currentValue&&this.renderer.addClass(this.elementRef.nativeElement,`fa-${Y.size.currentValue}`),null!=Y.size.previousValue&&this.renderer.removeClass(this.elementRef.nativeElement,`fa-${Y.size.previousValue}`))}}return O.\u0275fac=function(Y){return new(Y||O)(M.Y36(M.Qsj),M.Y36(M.SBq))},O.\u0275cmp=M.Xpm({type:O,selectors:[["fa-stack"]],inputs:{size:"size"},features:[M.TTD],ngContentSelectors:Ri,decls:1,vars:0,template:function(Y,ne){1&Y&&(M.F$t(),M.Hsn(0))},encapsulation:2}),O})(),gi=(()=>{class O{constructor(Y,ne,ve,Pe,Fe){this.sanitizer=Y,this.config=ne,this.iconLibrary=ve,this.stackItem=Pe,this.classes=[],null!=Fe&&null==Pe&&console.error('FontAwesome: fa-icon and fa-duotone-icon elements must specify stackItemSize attribute when wrapped into fa-stack. Example: <fa-icon stackItemSize="2x"></fa-icon>.')}ngOnChanges(Y){if(null==this.icon&&null==this.config.fallbackIcon)return(()=>{throw new Error("Property `icon` is required for `fa-icon`/`fa-duotone-icon` components.")})();let ne=null;if(ne=null==this.icon?this.config.fallbackIcon:this.icon,Y){const ve=this.findIconDefinition(ne);if(null!=ve){const Pe=this.buildParams();this.renderIcon(ve,Pe)}}}render(){this.ngOnChanges({})}findIconDefinition(Y){const ne=((O,Z)=>(O=>void 0!==O.prefix&&void 0!==O.iconName)(O)?O:Array.isArray(O)&&2===O.length?{prefix:O[0],iconName:O[1]}:"string"==typeof O?{prefix:Z,iconName:O}:void 0)(Y,this.config.defaultPrefix);if("icon"in ne)return ne;const ve=this.iconLibrary.getIconDefinition(ne.prefix,ne.iconName);return null!=ve?ve:((O=>{throw new Error(`Could not find icon with iconName=${O.iconName} and prefix=${O.prefix} in the icon library.`)})(ne),null)}buildParams(){const Y={flip:this.flip,spin:this.spin,pulse:this.pulse,border:this.border,inverse:this.inverse,size:this.size||null,pull:this.pull||null,rotate:this.rotate||null,fixedWidth:"boolean"==typeof this.fixedWidth?this.fixedWidth:this.config.fixedWidth,stackItemSize:null!=this.stackItem?this.stackItem.stackItemSize:null},ne="string"==typeof this.transform?L_transform(this.transform):this.transform;return{title:this.title,transform:ne,classes:[...kr(Y),...this.classes],mask:null!=this.mask?this.findIconDefinition(this.mask):null,styles:null!=this.styles?this.styles:{},symbol:this.symbol,attributes:{role:this.a11yRole}}}renderIcon(Y,ne){const ve=D(Y,ne);this.renderedIconHTML=this.sanitizer.bypassSecurityTrustHtml(ve.html.join("\n"))}}return O.\u0275fac=function(Y){return new(Y||O)(M.Y36(U1.H7),M.Y36(Fi),M.Y36(b1),M.Y36(Pr,8),M.Y36(gr,8))},O.\u0275cmp=M.Xpm({type:O,selectors:[["fa-icon"]],hostAttrs:[1,"ng-fa-icon"],hostVars:2,hostBindings:function(Y,ne){2&Y&&(M.Ikx("innerHTML",ne.renderedIconHTML,M.oJD),M.uIk("title",ne.title))},inputs:{icon:"icon",title:"title",spin:"spin",pulse:"pulse",mask:"mask",styles:"styles",flip:"flip",size:"size",pull:"pull",border:"border",inverse:"inverse",symbol:"symbol",rotate:"rotate",fixedWidth:"fixedWidth",classes:"classes",transform:"transform",a11yRole:"a11yRole"},features:[M.TTD],decls:0,vars:0,template:function(Y,ne){},encapsulation:2}),O})(),g2=(()=>{class O{}return O.\u0275fac=function(Y){return new(Y||O)},O.\u0275mod=M.oAB({type:O}),O.\u0275inj=M.cJS({}),O})()}},Xn=>{Xn(Xn.s=8862)}]);