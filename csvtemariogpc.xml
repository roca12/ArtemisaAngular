<?xml version="1.0" encoding="UTF-8"?>
<data>
<row>
  <ID>1</ID>
  <supergrupo>Busquedas</supergrupo>
  <tema>Binary Search</tema>
  <texto><div style="text-align: justify;"><span style="font-size: 10pt;">La búsqueda binaria, también conocida como búsqueda de intervalo medio o búsqueda logarítmica, es un algoritmo de búsqueda que encuentra la posición de un valor en un arreglo ordenado. Compara el valor con el elemento en el medio del arreglo, si no son iguales, la mitad en la cual el valor no puede estar es eliminada y la búsqueda sigue en la mitad restante hasta que el valor se encuentre.&nbsp;</span></div><div style="text-align: justify;"><span style="font-size: 10pt;"><br></span></div><div style="text-align: justify;"><span style="font-size: 10pt;">La búsqueda binaria es computada en el peor de los casos en un tiempo logarítmico, realizando  O (log n)  comparaciones, donde n es el número de elementos del arreglo y log es el logaritmo.</span></div></texto>
  <complejidad_tiempo>Mejor caso :    O(1)            Peor caso :      O(log n)             Promedio: O(log n)</complejidad_tiempo>
  <java>// Implementación Java de una búsqueda binaria recursiva 

public class BinarySearch {
    /*Retorna el indice de x si se encuentra presente
    en arr[1,2,....r]*, si no retorna -1*/
    static int binarySearch(int arr[], int l, int r, int x) {
        if (r &gt;= l) {
            int mid = l + (r - l) / 2;
            /*Si el elemento esta presente en el medio*/
            if (arr[mid] == x) {
                return mid;
            }
            /*Si el elemento es más pequeño que la mitad
            entonces solo puede estar presente en el 
            subarreglo izquierdo*/
            if (arr[mid] &gt; x) {
                return binarySearch(arr, l, mid - 1, x);
            }
            //Si no el elemento solo pued estar presente 
            //en el subarreglo derecho 
            return binarySearch(arr, mid + 1, r, x);
        }
        //Si llegamos aqui, el elemento no esta presente
        //en el arreglo
        return -1;
    }

    public static void main(String args[]) {
        int arr[] = {2, 3, 4, 10, 40};
        int n = arr.length;
        int x = 10;
        int result = binarySearch(arr, 0, n - 1, x);
        if (result == -1) {
            System.out.println(&quot;Elemento no presente&quot;);
        } else {
            System.out.println(&quot;Element encontrado en la posición &quot; + result);
        }
    }
}
</java>
  <cpp>#include &lt;bits/stdc++.h&gt;
#include &lt;cstdlib&gt;

int binarysearch(int arr[], int l, int r, int x) {
    if (r &gt;= l) {
        int mid = l + (r - 1) / 2;
        if (arr[mid] == x) {
            return mid;
        }
        if (arr[mid] &gt; x) {
            return binarysearch(arr, l, mid - 1, x);
        } else {
            return binarysearch(arr, mid + 1, r, x);
        }
    }
    return -1;
}

int main() {
    int arr[] = {2, 3, 4, 5, 6};
    int n = sizeof (arr) / sizeof (arr[0]);
    int x = 5;
    int resultado = binarysearch(arr, 0, n - 1, x);
    if (resultado == -1) {
        printf(&quot;elemento no presente&quot;);
    } else {
        printf(&quot;elemento encontrado en el indice: %d&quot;, resultado);
    }
    return 0;
}
</cpp>
  <py>def BinarySearch(arr, inicio, fin, numerobuscado):
    if(fin &gt;= inicio):
        medio = int(inicio + (fin-1) / 2)
        if(arr[medio] == numerobuscado):
            return medio
        if(arr[medio] &gt; numerobuscado):
            return BinarySearch(arr, inicio, medio-1, numerobuscado)
        else:
            return BinarySearch(arr, medio + 1, fin, numerobuscado)
    return -1

arr = [1, 2, 3, 4, 5, 6]
tam = len(arr)
numerobuscado = 5
resultado = int (BinarySearch(arr, 0, tam-1, numerobuscado))
if(resultado == -1):
    print(&quot;Elemento no encontrado&quot;)
else:
    print(&quot;Elemento encontrado en la posicion&quot;, resultado)
</py>
  <orden>2</orden>
  <suborden>0</suborden>
  <fecha_creacion>2020-12-02 17:30:29</fecha_creacion>
  <fecha_modificacion>2020-12-06 22:47:01</fecha_modificacion>
</row>
<row>
  <ID>2</ID>
  <supergrupo>Busquedas</supergrupo>
  <tema>Exponential Search</tema>
  <texto><div style="text-align: justify;"><span style="font-size: 10pt;">El nombre de este algoritmo de búsqueda puede ser engañoso, ya que funciona en tiempo O (Log n).&nbsp;</span></div><div style="text-align: justify; font-weight: normal;">El nombre proviene de la forma en que busca un elemento. La búsqueda binaria exponencial es particularmente útil para búsquedas ilimitadas, donde el tamaño del vector es infinito.&nbsp;</div><div style="text-align: justify; "><span style="font-weight: bold;"><br></span></div><div style="text-align: justify; "><span style="font-weight: bold;">La búsqueda exponencial implica dos pasos:&nbsp;</span></div><div style="text-align: justify; font-weight: normal;"><br></div><div style="text-align: justify; font-weight: normal;"><span style="white-space:pre">	</span>1)  Encuentra el rango donde el elemento está presente&nbsp;</div><div style="text-align: justify; font-weight: normal;"><span style="white-space:pre">	</span>2)  Hacer una búsqueda binaria en el rango encontrado arriba.&nbsp;</div><div style="text-align: justify; font-weight: normal;"><br></div><div style="text-align: justify; font-weight: normal;">La idea es comenzar con el tamaño del subarreglo 1, comparar su último elemento con x, luego probar el tamaño 2, luego el 4 y así sucesivamente hasta que el último elemento de un subconjunto no sea mayor que el tamaño del vector.
Una vez que encontramos un índice i (después de duplicar repetidamente i), sabemos que el elemento debe estar presente entre i / 2 - i, i / 2 porque se encontró un valor mayor en la iteración anterior.&nbsp;</div><div style="text-align: justify; font-weight: normal;"><br></div><div style="text-align: justify; "><span style="font-weight: bold;">Podemos tener en cuenta que:&nbsp;</span></div><div style="text-align: justify; font-weight: normal;"><br></div><div style="text-align: justify; font-weight: normal;"><span style="white-space:pre">	</span>- La búsqueda binaria exponencial es particularmente útil para búsquedas ilimitadas, donde el tamaño del vector es infinito.&nbsp;</div><div style="text-align: justify; font-weight: normal;"><span style="white-space:pre">	</span>- Funciona mejor que la Búsqueda binaria para vectores limitados, y también cuando el elemento a buscar está más cerca del primer elemento.
</div></texto>
  <complejidad_tiempo>Mejor caso :    O(1)            Peor caso :      O(log n)             Promedio: O(log n)             </complejidad_tiempo>
  <java>//Programa Java para encontrar un elemento
//x en un array ordenado usando Exponential Search

import java.util.Arrays;

public class ExponentialSearch {

    /* Retorna posición de la primerra ocurrencia 
    de x en un arreglo*/
    static int exponentialSearch(int arr[],int n, int x) {
        // Si z esta presente en la primera localización en si misma
        if (arr[0] == x) {
            return 0;
        }
        /*Encuentra ranfo para la busqueda binaria
        por repetidos dobles*/
        int i = 1;
        while (i &lt; n &amp;&amp; arr[i] &lt;= x) {
            i = i * 2;
        }
        //llama la busqueda binaria para el rango encontrado 
        return Arrays.binarySearch(arr, i / 2,
                Math.min(i, n), x);
    }

    public static void main(String args[]) {
        int arr[] = {2, 3, 4, 10, 40};
        int x = 10;
        int result = exponentialSearch(arr, arr.length, x);
        System.out.println((result &lt; 0)
                ? &quot;El elemento no esta presente en el array&quot;
                : &quot;Elemento encontrado en : &quot;
                + result);
    }
}
</java>
  <cpp>#include &lt;bits/stdc++.h&gt;
#include &lt;cstdlib&gt;
using namespace std;

int binarySearch(int arr[], int l, int r, int x) {
    if (r &gt;= l) {
        int mid = l + (r - l) / 2;
        if (arr[mid] == x) {
            return mid;
        }
        if (arr[mid] &gt; x) {
            return binarySearch(arr, l, mid - 1, x);
        } else {
            return binarySearch(arr, mid + 1, r, x);
        }
    }

    return -1;
}

int exponentialSearch(int arr[], int n, int x) {
    if (arr[0] == x) {
        return 0;
    }
    int i = 1;
    while (i &lt; n &amp;&amp; arr[i] &lt;= x) {
        i = i * 2;
    }
    return binarySearch(arr, i / 2, min(i, n), x);
}

int main(int argc, char const *argv[]) {
    int arr[] = {1, 2, 3, 4, 5};
    int n = sizeof (arr) / sizeof (arr[0]);
    int x = 5;
    int result = exponentialSearch(arr, n, x);
    if (result &lt; 0) {
        cout &lt;&lt; &quot;El resultado no esta presente en el Array&quot; &lt;&lt; endl;
    } else {
        cout &lt;&lt; &quot;Elemento encontrado en el indice &quot; &lt;&lt; result &lt;&lt; endl;
    }

    return 0;
}
</cpp>
  <py>def BinarySearch(arr, inicio, fin, numerobuscado):
    if(fin&gt;inicio):
        medio = int((inicio+(fin-1))/2)
        if(arr[medio] == numerobuscado):
            return medio
        if(arr[medio] &gt; numerobuscado):
            return BinarySearch(arr,inicio,medio-1,numerobuscado)
        else:
            return BinarySearch(arr,medio+1,fin,numerobuscado)
    return -1

def exponentialSearch(arr,tam,buscado):
    if(arr[0] == buscado):
        return 0
    i = int(1)
    while (i&lt;tam and arr[i]&lt;=buscado):
        i = i*2
    return BinarySearch(arr,i//2,min(i,tam),buscado)

lista = [1,2,3,4,5,6]
buscado = int(9)
resultado = int(exponentialSearch(lista, len(lista), buscado))
if(resultado &lt; 0):
    print (&quot;El elemento no se encuentra dentro del arreglo&quot;)
else:
    print(&quot;El elemento esta en la posicion:&quot;,resultado)</py>
  <orden>2</orden>
  <suborden>1</suborden>
  <fecha_creacion>2020-12-02 17:30:29</fecha_creacion>
  <fecha_modificacion>2020-12-07 02:20:34</fecha_modificacion>
</row>
<row>
  <ID>3</ID>
  <supergrupo>Busquedas</supergrupo>
  <tema>Array Max/Min Search</tema>
  <texto>Tenemos un Array en donde queremos buscar el valor más pequeño y el valor más grande del mismo de forma eficiente haciendo la menor cantidad de comparaciones, para resolver este problema podemos emplear la siguiente aproximación.</texto>
  <complejidad_tiempo>Mejor caso :    O(n)            Peor caso :      O(n)             Promedio: O(n)             </complejidad_tiempo>
  <java>/* Programa Java que busca el máximo y el mínimo
en un array*/
public class ArrayMaxMinSearch {
    /*Clase Pair es usada para retornar
    dos valores de getMinMax()*/
    static class Pair {
        int min;
        int max;
    }

    static Pair getMinMax(int arr[], int n) {
        Pair minmax = new Pair();
        int i;
        /*Si es el unico elemento, lo retorna como min y max*/
        if (n == 1) {
            minmax.max = arr[0];
            minmax.min = arr[0];
            return minmax;
        }
        /*Si hay más de un elemento, 
        entones inicializa min y más*/
        if (arr[0] &gt; arr[1]) {
            minmax.max = arr[0];
            minmax.min = arr[1];
        } else {
            minmax.max = arr[1];
            minmax.min = arr[0];
        }
        for (i = 2; i &lt; n; i++) {
            if (arr[i] &gt; minmax.max) {
                minmax.max = arr[i];
            } else if (arr[i] &lt; minmax.min) {
                minmax.min = arr[i];
            }
        }
        return minmax;
    }

    public static void main(String args[]) {
        int arr[] = {1000, 11, 445, 1, 330, 3000};
        int arr_size = 6;
        Pair minmax = getMinMax(arr, arr_size);
        System.out.printf(&quot;\nEl minimo elemento es %d&quot;, minmax.min);
        System.out.printf(&quot;\nEl maximo elemento es %d&quot;, minmax.max);
    }

}
</java>
  <cpp>#include &lt;bits/stdc++.h&gt;
#include &lt;cstdlib&gt;
using namespace std;

struct pairMaxMin {
    int min;
    int max;
};

static pairMaxMin getMinMax(int arr[], int n) {
    pairMaxMin minmax;
    int i;

    if (n == 1) {
        minmax.max = arr[0];
        minmax.min = arr[0];
        return minmax;
    }
    if (arr[0] &gt; arr[1]) {
        minmax.max = arr[0];
        minmax.min = arr[1];
    } else {
        minmax.max = arr[1];
        minmax.min = arr[0];
    }
    for (i = 2; i &lt; n; i++) {
        if (arr[i] &gt; minmax.max) {
            minmax.max = arr[i];
        } else if (arr[i] &lt; minmax.min) {
            minmax.min = arr[i];
        }
    }

    return minmax;
}

int main(int argc, char** argv) {
    int arr[] = {12, 3, 4, 345, 65, 43};
    int len = sizeof (arr) / sizeof (arr[0]);
    pairMaxMin minmax = getMinMax(arr, len);
    printf(&quot;el minimo elemento es %d\n&quot;, minmax.min);
    printf(&quot;el maximo elemento es %d\n&quot;, minmax.max);
    return 0;
}
</cpp>
  <py>class Pair:
    max,min = int(),int()

def  getmaxmin(lista,n):
    maxmin = Pair()
    i = int()
    if n==1:
        maxmin.max = lista[0]
        maxmin.max = lista[0]
        return maxmin
    if lista[0]&gt;lista[1]:
        maxmin.max = lista[0]
        maxmin.min = lista[1]
    else:
        maxmin.max = lista[1]
        maxmin.min = lista[0]
    for i in range(2,n):
        if lista[i]&gt;maxmin.max:
            maxmin.max = lista[i]
        elif lista[i]&lt;maxmin.min:
            maxmin.min = lista[i]
    return maxmin

lista = [1, 422, 789, 2333, 2444]
n = len(lista)
resultado = getmaxmin(lista,n)
print(&quot;El minimo es &quot;,resultado.min)
print(&quot;El maximo es &quot;,resultado.max)
</py>
  <orden>2</orden>
  <suborden>2</suborden>
  <fecha_creacion>2020-12-02 17:30:29</fecha_creacion>
  <fecha_modificacion>2020-12-06 20:04:14</fecha_modificacion>
</row>
<row>
  <ID>4</ID>
  <supergrupo>Busquedas</supergrupo>
  <tema>Fibonacci Search</tema>
  <texto><div style="text-align: justify;"><span style="font-size: 10pt;">La búsqueda de Fibonacci es una técnica basada en la comparación que utiliza los números de Fibonacci para buscar un elemento en un array ordenado.&nbsp;</span></div><div style="text-align: justify; "><span style="font-weight: bold;">Similitudes con la búsqueda binaria:&nbsp;</span></div><div style="text-align: justify; font-weight: normal;"><span style="white-space:pre">	</span>- Trabaja con arrays ordenados.</div><div style="text-align: justify; font-weight: normal;"><span style="white-space:pre">	</span>- Es un algoritmo de dividir y conquistar.</div><div style="text-align: justify; font-weight: normal;"><span style="white-space:pre">	</span>- Tiene una complejidad de registro y tiempo.&nbsp;</div><div style="text-align: justify; "><span style="font-weight: bold;"><br></span></div><div style="text-align: justify; "><span style="font-weight: bold;">Diferencias con la búsqueda binaria:&nbsp;</span></div><div style="text-align: justify; font-weight: normal;"><span style="white-space:pre">	</span>- La búsqueda de Fibonacci divide un array dado en partes desiguales&nbsp;</div><div style="text-align: justify; font-weight: normal;"><span style="white-space:pre">	</span>- La búsqueda binaria usa el operador de división para dividir el rango.&nbsp;</div><div style="text-align: justify; font-weight: normal;"><br></div><div style="text-align: justify; "><span style="font-weight: bold;">Puntos importantes:</span></div><div style="text-align: justify; font-weight: normal;"><span style="white-space:pre">	</span>- La búsqueda de Fibonacci no usa /, pero usa + y -. El operador de la división puede ser costoso en algunas CPU.&nbsp;</div><div style="text-align: justify; font-weight: normal;"><span style="white-space:pre">	</span>- La búsqueda de Fibonacci examina elementos relativamente más cercanos en pasos subsiguientes. Por lo tanto, cuando el vector de entrada es grande y no cabe en la memoria caché de la <span style="white-space:pre">	</span>&nbsp; CPU o incluso en la RAM, la búsqueda de Fibonacci puede ser útil.&nbsp;</div><div style="text-align: justify; font-weight: normal;"><span style="white-space:pre">	</span>- La idea es encontrar primero el número de Fibonacci más pequeño que sea mayor o igual a la longitud del vector dado.
</div></texto>
  <complejidad_tiempo>null</complejidad_tiempo>
  <java>// Programa Java para Fibonacci Search  
public class FibonacciSearch {

    //Función de utilidad para biscar el minimo
    //de dos elementos
    public static int min(int x, int y) {
        return (x &lt;= y) ? x : y;
    }

    /* Regresa el indice de x si esta presente, si no retorna -1*/
    public static int fibonacciSearch(int arr[],
            int x, int n) {
        /* Inicializa los números fibonacci*/
        int fibMMm2 = 0; // (m-2)esimo número fibonacci. 
        int fibMMm1 = 1; // (m-1)esimo número fibonacci. 
        int fibM = fibMMm2 + fibMMm1; // mesimo fibonacci.
        /* FibM va a ser almacenado como el más pequeño
        fibonacci más grande o igual a n*/
        while (fibM &lt; n) {
            fibMMm2 = fibMMm1;
            fibMMm1 = fibM;
            fibM = fibMMm2 + fibMMm1;
        }
        // Marca el rango eliminado del frente
        int offset = -1;
        /* Si bien hay elementos a inspeccionar.
        Tenga en cuenta que comparamos arr [fibMm2] con x.
        Cuando fibM se convierte en 1, fibMm2 se convierte en 0 */
        while (fibM &gt; 1) {
            //Revisa si fibMm2 es una ubicación valida
            int i = min(offset + fibMMm2, n - 1);
            /*Si x es más grande que el valor
            en el indice fibMm2, fuera del subarray
            desde offset a i*/
            if (arr[i] &lt; x) {
                fibM = fibMMm1;
                fibMMm1 = fibMMm2;
                fibMMm2 = fibM - fibMMm1;
                offset = i;
            } 
            /*Si x es más grande que el valor en indice 
            fibMm2, corta el subarreglo despues de i+1*/ 
           else if (arr[i] &gt; x) {
                fibM = fibMMm2;
                fibMMm1 = fibMMm1 - fibMMm2;
                fibMMm2 = fibM - fibMMm1;
            } /* Elemento encontrado, retorna indice*/ 
     else {
                return i;
            }
        }
        /* Comparando el ultimo elemento con x*/
        if (fibMMm1 == 1 &amp;&amp; arr[offset + 1] == x) {
            return offset + 1;
        }
        /*Elemento no encontrado, retorna -1*/
        return -1;
    }

    public static void main(String[] args) {
        int arr[] = {10, 22, 35, 40, 45, 50,
            80, 82, 85, 90, 100};
        int n = 11;
        int x = 85;
        System.out.println(&quot;Found at index: &quot;
                + fibonacciSearch(arr, x, n));
    }
}
</java>
  <cpp>#include &lt;bits/stdc++.h&gt;
#include &lt;cstdlib&gt;
using namespace std;

static int fibonacciSearch(int arr[], int x, int n) {
    int fibMMm2 = 0;
    int fibMMm1 = 1;
    int fibM = fibMMm2 + fibMMm1;
    while (fibM &lt; n) {
        fibMMm2 = fibMMm1;
        fibMMm1 = fibM;
        fibM = fibMMm2 + fibMMm1;
    }
    int offset = -1;
    while (fibM &gt; 1) {
        int i = std::min(offset + fibMMm2, n - 1);
        if (arr[i] &lt; x) {
            fibM = fibMMm1;
            fibMMm1 = fibMMm2;
            fibMMm2 = fibM - fibMMm1;
            offset = i;
        } else if (arr[i] &gt; x) {
            fibM = fibMMm2;
            fibMMm1 -= fibMMm2;
            fibMMm2 = fibM - fibMMm1;
        } else {
            return i;
        }
    }
    if (fibM == 1 &amp;&amp; arr[offset + 1] == x) {
        return offset + 1;
    }
    return -1;
}

int main(int argc, char** argv) {
    //
    int arr[] = {10, 22, 35, 40, 45, 50, 80, 82, 85, 90, 100};
    int n = sizeof (arr) / sizeof (arr[0]);
    int x = 85;
    printf(&quot;Encontrado en la posicion %d&quot;, fibonacciSearch(arr, x, n));
    return 0;
}
</cpp>
  <py>def menor(x, y):
    return min(x, y)

def FibonacciSearch(lista, x, n):
    if x &gt; lista[n-1]:
        return -1
    Fm2 = int(0)
    Fm1 = int(1)
    Fms = int(Fm2 + Fm1)
    while Fms &lt; n:
        Fm2 = Fm1
        Fm1 = Fms
        Fms = int(Fm2 + Fm1)
    offset = int(-1)
    while Fms &gt; 1:
        i = int(menor(offset + Fm2, n - 1))
        if lista[i] &lt; x:
            Fms = Fm1
            Fm1 = Fm2
            Fm2 = Fms - Fm1
            offset = i
        elif lista[i] &gt; x:
            Fms = Fm2
            Fm1 = Fm1 - Fm2
            Fm2 = Fms - Fm1
        else:
            return i

    if Fm1 == 1 and lista[offset + 1] == x:
        return offset + 1
    else:
        return -1


lista = [10, 22, 33, 45, 89, 99, 100]
n = int(len(lista))
x = int(input())
if FibonacciSearch(lista, x, n) != -1:
    print(&quot;Encontrado en la poscion &quot;, FibonacciSearch(lista, x, n))
else:
    print(&quot;No encontrado&quot;)
</py>
  <orden>2</orden>
  <suborden>3</suborden>
  <fecha_creacion>2020-12-02 17:30:29</fecha_creacion>
  <fecha_modificacion>2020-12-07 02:20:50</fecha_modificacion>
</row>
<row>
  <ID>5</ID>
  <supergrupo>Busquedas</supergrupo>
  <tema>Jump Search</tema>
  <texto><div style="text-align: justify;"><span style="font-size: 10pt;">Al igual que Binary Search, Jump Search es un algoritmo de búsqueda para vectores ordenados.&nbsp;</span></div><div style="text-align: justify; font-weight: normal;">La idea básica es verificar menos elementos (que la búsqueda lineal) saltando hacia delante con pasos fijos u salteando algunos elementos en lugar de buscar todos los elementos.
En el peor de los casos, tenemos que realizar saltos de n / m y, si el último valor verificado es mayor que el elemento a buscar, realizamos comparaciones de m-1 más para la búsqueda lineal.&nbsp;</div><div style="text-align: justify; font-weight: normal;"><br></div><div style="text-align: justify; font-weight: normal;">Por lo tanto, el número total de comparaciones en el peor de los casos será ((n / m) + m-1). El valor de la función ((n / m) + m-1) será mínimo cuando m = ?n. Por lo tanto, el mejor tamaño de paso es m = ?n.</div><div style="text-align: justify; font-weight: normal;"><br></div><div style="text-align: justify; "><span style="font-weight: bold;">Puntos importantes:&nbsp;
</span></div><div style="text-align: justify; font-weight: normal;"><br></div><div style="text-align: justify; font-weight: normal;"><span style="white-space:pre">	</span>- Trabaja solo arreglos ordenados.&nbsp;</div><div style="text-align: justify; font-weight: normal;"><span style="white-space:pre">	</span>- El tamaño óptimo de un bloque a saltar es (? n).&nbsp;</div><div style="text-align: justify; font-weight: normal;"><br></div><div style="text-align: justify; font-weight: normal;">Esto hace que la complejidad del tiempo de Jump Search O (? n).&nbsp;</div><div style="text-align: justify; font-weight: normal;"><br></div><div style="text-align: justify; font-weight: normal;">- La complejidad temporal de la búsqueda por salto es entre la búsqueda lineal ((O (n)) y la búsqueda binaria (O (Log n)).&nbsp;</div><div style="text-align: justify; font-weight: normal;">- La búsqueda binaria es mejor que la búsqueda por salto, pero la búsqueda por salto tiene la ventaja de que retrocedemos solo una vez (la búsqueda binaria puede requerir saltos O (Log n), considere una situación en la que el elemento a buscar es el elemento más pequeño o más pequeño que el más pequeño). Entonces, en un sistema donde el salto hacia atrás es costoso, usamos Jump Search.
</div></texto>
  <complejidad_tiempo>Mejor caso :    O(? n)            Peor caso :      O(? n)             Promedio: O(? n)             </complejidad_tiempo>
  <java>public class JumpSearch {

    public static int jumpSearch(int[] arr, int x) {
        int n = arr.length;
        //Buscando el tamaño del bloque que sera
        //saltado
        int step = (int) Math.floor(Math.sqrt(n));
        /* Buscando el bloque donde el elemento
        esta presente (Si esta presente)*/
        int prev = 0;
        while (arr[Math.min(step, n) - 1] &lt; x) {
            prev = step;
            step += (int) Math.floor(Math.sqrt(n));
            if (prev &gt;= n) {
                return -1;
            }
        }
        /*Realizando una busqueda linear para x en 
        el bloque empezando con prev*/
        while (arr[prev] &lt; x) {
            prev++;
            /*Si nosotros alcanzamos el siguiente bloque
            o el fin del array el elemento no esta presente*/
            if (prev == Math.min(step, n)) {
                return -1;
            }
        }
        // Si el elemento fue encontrado
        if (arr[prev] == x) {
            return prev;
        }
        return -1;
    }

    public static void main(String[] args) {
        int arr[] = {0, 1, 1, 2, 3, 5, 8, 13, 21,
            34, 55, 89, 144, 233, 377, 610};
        int x = 55;
        //Encontrar el indice de &#39;x&#39; usando Jump Search
        int index = jumpSearch(arr, x);
        // Imprime el indice donde x fue encontrado
        System.out.println(&quot;\nNúmero &quot; + x
                + &quot; esta en el indice &quot; + index);
    }
}
</java>
  <cpp>#include &lt;bits/stdc++.h&gt;
#include &lt;cstdlib&gt;
using namespace std;

static int jumpSearch(int arr[], int x, int n) {
    int step = int(std::floor(std::sqrt(n)));
    int prev = 0;
    while (arr[std::min(step, n) - 1] &lt; x) {
        prev = step;
        step += int(std::floor(std::sqrt(n)));
        if (prev &gt;= n) {
            return -1;
        }
    }
    while (arr[prev] &lt; x) {
        prev++;
        if (prev == std::min(step, n)) {
            return -1;
        }
    }
    if (arr[prev] == x) {
        return prev;
    }
    return -1;

}

int main(int argc, char const *argv[]) {
    int arr[] = {1, 2, 3, 4, 5};
    int n = sizeof (arr) / sizeof (arr[0]);
    int x = 5;
    int result = jumpSearch(arr, x, n);
    if (result &lt; 0) {
        cout &lt;&lt; &quot;El elemento no esta presente en el Array&quot; &lt;&lt; endl;
    } else {
        cout &lt;&lt; &quot;Elemento encontrado en el indice &quot; &lt;&lt; result &lt;&lt; endl;
    }

    return 0;
}
</cpp>
  <py>import math

def jumpSearch(lista, x):
    tamanio = len(lista)
    salto = int(math.floor(math.sqrt(tamanio)))
    previo = int(0)
    while(lista[min(salto, tamanio)-1] &lt; x):
        previo = salto
        salto = salto + int(math.floor(math.sqrt(tamanio)))
        if(previo &gt;= tamanio):
            return -1
    while(lista[previo] &lt; x):
        previo = previo + 1
        if(previo == min(salto, tamanio)):
            return -1
    if(lista[previo] == x):
        return previo
    return -1

lista = [0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144]
numeroabuscar = int(input())
resultado = jumpSearch(lista, numeroabuscar)
if(resultado == -1):
    print(&#39;No encontrado&#39;)
else:
    print(&#39;Encontrado en el indice &#39;, resultado)
</py>
  <orden>2</orden>
  <suborden>4</suborden>
  <fecha_creacion>2020-12-02 17:30:29</fecha_creacion>
  <fecha_modificacion>2020-12-07 02:20:57</fecha_modificacion>
</row>
<row>
  <ID>6</ID>
  <supergrupo>Busquedas</supergrupo>
  <tema>Minimum Absolute Sum Pair</tema>
  <texto><div style="text-align: justify;"><span style="font-size: 10pt;">Teniendo un vector de números, se buscan dos elementos cuya suma es la más cercana a cero.&nbsp;</span></div><div style="text-align: justify;">Para cada elemento de dicho vector encuentre la suma con cada otro elemento del mismo vector y compare las sumas.&nbsp;</div><div style="text-align: justify;"><br></div><div style="text-align: justify;">Por último, devolver la suma mínima encontrada.</div></texto>
  <complejidad_tiempo>Mejor caso :    O(n2)            Peor caso :      O(n2)             Promedio: O(n2</complejidad_tiempo>
  <java>//Programa JAVA que busque el par de números
//que sumados de la minima suma absoluta

public class MinAbsSumPair {
//función que busca el par 

    static void minAbsSumPair(int arr[], int arr_size) {
        int l, r, min_sum, sum, min_l, min_r;
        /*El array debe tener al menos 2 elementos*/
        if (arr_size &lt; 2) {
            System.out.println(&quot;Invalid Input&quot;);
            return;
        }
        /* Inicialización de los valores*/
        min_l = 0;
        min_r = 1;
        min_sum = arr[0] + arr[1];
        for (l = 0; l &lt; arr_size - 1; l++) {
            for (r = l + 1; r &lt; arr_size; r++) {
                sum = arr[l] + arr[r];
                if (Math.abs(min_sum) &gt; Math.abs(sum)) {
                    min_sum = sum;
                    min_l = l;
                    min_r = r;
                }
            }
        }
        System.out.println(&quot; Los dos elementos los cuales &quot;
                + &quot;tienen la suma minima son &quot;
                + arr[min_l] + &quot; y &quot; + arr[min_r]);
    }

    public static void main(String[] args) {
        int arr[] = {1, 60, -10, 70, -80, 85};
        minAbsSumPair(arr, 6);
    }
}
</java>
  <cpp>#include &lt;bits/stdc++.h&gt;
#include &lt;cstdlib&gt;
using namespace std;

void minAbsSumPair(int arr[], int n) {
    int l, r, min_sum, sum, min_l, min_r;
    if (n &lt; 2) {
        printf(&quot;Entrada no valida&quot;);
    }
    min_l = 0;
    min_r = 1;
    min_sum = arr[0] + arr[1];
    for (l = 0; l &lt; n - 1; ++l) {
        for (r = l + 1; r &lt; n; ++r) {
            sum = arr[l] + arr[r];
            if (std::abs(min_sum) &gt; std::abs(sum)) {
                min_sum = sum;
                min_l = l;
                min_r = r;
            }
        }
    }
    printf(&quot;Los numero que tienen la minima suma son %d %d&quot;, arr[min_l], arr[min_r]);
}

int main(int argc, char const *argv[]) {
    int arr[] = {1, -2, -10, 70, -80, 85};
    int n = sizeof (arr) / sizeof (arr[0]);
    minAbsSumPair(arr, n);
    return 0;
}
</cpp>
  <py>def minAbsSumPair(arr,n):
    l,r,min_sum,sum,min_l,min_r = int(),int(),int(),int(),int(),int()
    if n&lt;2:
        print(&quot;Array no tiene suficientes valores&quot;)
        return
    min_l = int(0)
    min_r = int (1)
    min_sum = arr[0]+arr[1]
    for l in range(n-1):
        for r in range(l+1,n):
            sum = arr[l]+arr[r]
            if abs(min_sum)&gt;abs(sum):
                min_sum=sum
                min_l=l
                min_r=r
    print(f&quot;la minima suma es: {arr[min_l]} y {arr[min_r]}&quot;)

arr = [1,60,-10,70,-80,85]
minAbsSumPair(arr,len(arr))
</py>
  <orden>2</orden>
  <suborden>5</suborden>
  <fecha_creacion>2020-12-02 17:30:29</fecha_creacion>
  <fecha_modificacion>2020-12-06 20:04:16</fecha_modificacion>
</row>
<row>
  <ID>7</ID>
  <supergrupo>Busquedas</supergrupo>
  <tema>Missing Number Search</tema>
  <texto><div style="text-align: justify;"><span style="font-size: 10pt;">Se le da una lista de n-1 enteros y estos enteros están en el rango de 1 a n. No hay duplicados en la lista pero nos falta uno de los enteros en la lista.
Los pasos para resolver este problema son los siguientes:
1) XOR todos los elementos del array, que el resultado de XOR sea X1.
2) XOR todos los números del 1 al n, sea XOR sea X2.
3) XOR de X1 y X2 da el número que falta, es decir el resultado.</span></div></texto>
  <complejidad_tiempo>Mejor caso :    O(n)            Peor caso :      O(n)             Promedio: O(n)             </complejidad_tiempo>
  <java>public class MissingNo {

    public static void main(String[] args) {
        int[] arr = {1,2,3,5,6,7,8};
        int missed = getMissingNo(arr, arr.length);
        System.out.println(&quot;el numero que falta es: &quot;+ missed);
    }

    static int getMissingNo(int a[], int n) {
        int x1 = a[0];
        int x2 = 1;
        for (int i = 1; i &lt; n; i++) {
            x1 ^= a[i];
        }
        for (int i = 2; i &lt;= n + 1; i++) {
            x2 ^= i;
        }
        return x1 ^ x2;
    }

}
</java>
  <cpp>#include &lt;bits/stdc++.h&gt;
#include &lt;cstdlib&gt;
using namespace std;

static int MissingNoSearch(int arr[], int n) {
    int x1 = arr[0];
    int x2 = 1;
    for (int i = 1; i &lt; n; ++i) {
        x1 = x1^arr[i];
    }
    for (int i = 2; i &lt;= n + 1; ++i) {
        x2 = x2^i;
    }
    return (x1^x2);
}

int main(int argc, char const *argv[]) {
    int arr[] = {1, 3, 4, 5, 6, 7};
    int n = sizeof (arr) / sizeof (arr[0]);
    printf(&quot;El numero faltante es : %d&quot;, MissingNoSearch(arr, n));
    return 0;
}
</cpp>
  <py>def getMissingNo(a,n):
    x1 = a[0]
    x2 = int(1)
    for i in range(1,n):
        x1^=a[i]
    for i in range(2,n+2):
        x2^=i
    return x1^x2

lista = [1,2,3,4,5,7,8]
missed = getMissingNo(lista,len(lista))
print(&quot;Numero perdido: &quot;+ str(missed))
</py>
  <orden>2</orden>
  <suborden>6</suborden>
  <fecha_creacion>2020-12-02 17:30:29</fecha_creacion>
  <fecha_modificacion>2020-12-07 02:21:15</fecha_modificacion>
</row>
<row>
  <ID>8</ID>
  <supergrupo>Busquedas</supergrupo>
  <tema>Difference Pair Search</tema>
  <texto><div style="text-align: justify;"><span style="font-size: 10pt;">Dado un vector sin orden y un número n, busque si existe un par de elementos en el vector cuya diferencia es n.&nbsp;</span></div><div style="text-align: justify;">El método más simple es ejecutar dos bucles, el bucle externo selecciona el primer elemento (elemento más pequeño) y el bucle interno busca el elemento seleccionado por el bucle externo más n.&nbsp;<span style="font-size: 10pt;">La complejidad del tiempo de este método es O (n ^ 2).&nbsp;
</span></div><div style="text-align: justify;"><span style="font-size: 10pt;"><br></span></div><div style="text-align: justify;"><span style="font-size: 10pt;">Podemos usar el ordenamiento y la búsqueda binaria para mejorar la complejidad del tiempo a O (nLogn). El primer paso es ordenar el array en orden ascendente. Una vez que el array esté ordenado, recorra el array de izquierda a derecha y, para cada elemento arr [i], la búsqueda binaria de arr [i] + n en arr [i + 1...n-1].&nbsp;</span></div><div style="text-align: justify;"><span style="font-size: 10pt;"><br></span></div><div style="text-align: justify;"><span style="font-size: 10pt;">Si se encuentra el elemento, devuelva el par.
Tanto el primer como el segundo paso toman O (nLogn). Así que la complejidad global es O (nLogn).

El segundo paso del algoritmo anterior se puede mejorar a O (n). El primer paso sigue siendo el mismo.&nbsp;</span></div><div style="text-align: justify;"><span style="font-size: 10pt;"><br></span></div><div style="text-align: justify;"><span style="font-size: 10pt;">La idea para el segundo paso es tomar dos variables de índice i y j, inicializarlas como 0 y 1 respectivamente. Ahora ejecuta un bucle lineal. Si arr [j] - arr [i] es más pequeño que n, debemos buscar un arr mayor [j], así que aumente j. Si arr [j] - arr [i] es mayor que n, debemos buscar un arr mayor [i], entonces incremente i.</span></div></texto>
  <complejidad_tiempo>Mejor caso :    O(nLog(n))            Peor caso :      O(nLog(n))             Promedio: O(nLog(n))  </complejidad_tiempo>
  <java>// Programa Java para buscar un par
// Dada una diferencia

public class PairDifferenceSearch {
    //La función asume que el array esta ordenado
    static boolean findPair(int arr[], int n) {
        int size = arr.length;
        // Inicializa la posición de dos elementos
        int i = 0, j = 1;
        // Busca por el par
        while (i &lt; size &amp;&amp; j &lt; size) {
            if (i != j &amp;&amp; arr[j] - arr[i] == n) {
                System.out.print(&quot;Par Encontrado: &quot;
                        + &quot;( &quot; + arr[i] + &quot;, &quot; + arr[j] + &quot; )&quot;);
                return true;
            } else if (arr[j] - arr[i] &lt; n) {
                j++;
            } else {
                i++;
            }
        }
        //No encuentra el par
        System.out.print(&quot;No hay tal par&quot;);
        return false;
    }

    public static void main(String[] args) {
        int arr[] = {1, 8, 30, 40, 100};
        int n = 60;
        findPair(arr, n);
    }
}
</java>
  <cpp>#include &lt;bits/stdc++.h&gt;
#include &lt;cstdlib&gt;
using namespace std;

static bool findPair(int arr[], int n, int size) {
    int i = 0, j = 1;
    while (i &lt; size &amp;&amp; j &lt; size) {
        if (i != j &amp;&amp; arr[j] - arr[i] == n) {
            printf(&quot;par encontrado (%d %d)&quot;, arr[i], arr[j]);
            return true;
        } else if (arr[j] - arr[i] &lt; n) {
            j++;
        } else {
            i++;
        }
    }
    printf(&quot;no hay par que de el numero&quot;);
    return false;
}

int main(int argc, char const *argv[]) {
    int arr[] = {1, 8, 30, 40, 100};
    int n = 7;
    int size = sizeof (arr) / sizeof (arr[0]);
    findPair(arr, n, size);
    return 0;
}
</cpp>
  <py>def FindPair(arr,x):
    size = len(arr)
    i,j = 0,1
    while i&lt;size and j&lt;size:
        if i != j and arr[j] - arr[i] == x:
            print(f&quot;par encontrado en: ({arr[i]} - {arr[j]})&quot;)
            return True
        elif arr[j]-arr[i]&lt;x:
            j+=1
        else:
            i+=1
    print(&quot;No existe el par que cumpla la suma de n&quot;)
    return False

arr = [1,8,30,40,100]
x = int(60)
FindPair(arr,x)
</py>
  <orden>2</orden>
  <suborden>7</suborden>
  <fecha_creacion>2020-12-02 17:30:29</fecha_creacion>
  <fecha_modificacion>2020-12-06 20:04:17</fecha_modificacion>
</row>
<row>
  <ID>9</ID>
  <supergrupo>Busquedas</supergrupo>
  <tema>Ternary Search</tema>
  <texto><div style="text-align: justify;"><span style="font-size: 10pt;">La búsqueda ternaria es un algoritmo de dividir y conquistar que se puede usar para encontrar un elemento en un array. Es similar a la búsqueda binaria donde dividimos el array en dos partes pero en este algoritmo dividimos el array dado en tres partes y determinamos cuál tiene la clave (elemento buscado).&nbsp;</span></div><div style="text-align: justify;">Podemos dividir el array en tres partes tomando mid1 y mid2, que se pueden calcular como se muestra a continuación.
mid1 = l + (r-l) / 3
mid2 = r - (r-l) / 3
Inicialmente, l y r serán iguales a 0 y n-1 respectivamente, donde n es la longitud de la matriz.&nbsp;</div><div style="text-align: justify;"><br></div><div style="text-align: justify;">El array debe ordenarse para realizar una búsqueda ternaria en ella.
</div></texto>
  <complejidad_tiempo>Mejor caso :    O(nLog(n))            Peor caso :      O(nLog(n))             Promedio: O(nLog(n))             </complejidad_tiempo>
  <java>//Programa Java para ilustrar 
//recursivamente la aproximación
//de una búsqueda ternaria

public class TernarySearch {
    //Función que realiza la busqueda ternaria
    static int ternarySearch(int l, int r, int key, int ar[]) {
        if (r &gt;= l) {
            //encontrar el mid1 y mid 2
            int mid1 = l + (r - l) / 3;
            int mid2 = r - (r - l) / 3;
            //Verificar si la key esta presente en algun medio
            if (ar[mid1] == key) {
                return mid1;
            }
            if (ar[mid2] == key) {
                return mid2;
            }
            /*Desde que la key no este presente en el mid
            verifica en cada region si esta presente
            luego repite la operación de busqueda
            en esa región*/
            if (key &lt; ar[mid1]) {
                //La key yace entre 1 y mid1
                return ternarySearch(l, mid1 - 1, key, ar);
            } else if (key &gt; ar[mid2]) {
                //La key yace entre mid2 y r
                return ternarySearch(mid2 + 1, r, key, ar);
            } else {
                //La key  yace entre mid 1 y mid 2
                return ternarySearch(mid1 + 1, mid2 - 1, key, ar);
            }
        }
        // key no encontrada
        return -1;
    }

    public static void main(String args[]) {
        int l, r, p, key;
        //Cree el array y ordenelo si no lo está
        int ar[] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
        // Indice inicial
        l = 0;
        // Tamaño del arreglo 
        r = 9;
        // Buscando por el 5
        // key que va a ser buscada en el array
        key = 5;
        // Busca usando Ternary Search
        p = ternarySearch(l, r, key, ar);
        // Imprime el resultado
        System.out.println(&quot;Indice de &quot; + key + &quot; es &quot; + p);
        // Buscando por el 50
        // Key a ser buscada en el array
        key = 50;
        // Buscar usando Ternary Search
        p = ternarySearch(l, r, key, ar);
        // Imprime el resultado 
        System.out.println(&quot;Index of &quot; + key + &quot; is &quot; + p);
    }
}
</java>
  <cpp>#include &lt;bits/stdc++.h&gt;
#include &lt;cstdlib&gt;
using namespace std;

static int ternarySearch(int left, int r, int key, int arr[]) {
    if (r &gt;= left) {
        int mid1 = left + (r - left) / 3;
        int mid2 = r - (r - left) / 3;
        if (arr[mid1] == key) {
            return mid1;
        }
        if (arr[mid2] == key) {
            return mid2;
        }
        if (key &lt; arr[mid1]) {
            return ternarySearch(left, mid1 - 1, key, arr);
        } else if (key &gt; arr[mid2]) {
            return ternarySearch(mid2 + 1, r, key, arr);
        } else {
            return ternarySearch(mid1 + 1, mid2 - 1, key, arr);
        }

    }
    return -1;
}

int main() {
    int arr[] = {1, 2, 3, 4, 5, 6, 7, 8, 9};
    int n = sizeof (arr) / sizeof (arr[0]);
    int l = 0;
    int r = 9;
    int x = 5;
    int result = ternarySearch(l, r, x, arr);
    if (result &lt; 0) {
        printf(&quot;el numero %d no se encuentra en el array\n&quot;, x);
    } else {
        printf(&quot;indice encontrado en la posicion %d\n&quot;, result);
    }
    return 0;
}
</cpp>
  <py>def TernarySearch(l,r,key,arr):
    if r &gt;= l:
        mid1 = l+(r-l)//3
        mid2 = r-(r-l)//3
        if arr[mid1]==key:
            return mid1
        if arr[mid2] == key:
            return mid2
        if key&lt;arr[mid1]:
            return TernarySearch(l,mid1-1,key,arr)
        elif key&gt;arr[mid2]:
            return TernarySearch(mid2+1,r,key,arr)
        else:
            return TernarySearch(mid1+1,mid2-1,key,arr)

    return -1

l,r,resultado,key = int(),int(),int(),int()
arr = [1,2,3,4,5,6,7,8,9,10]
l = int(0)
r = len(arr)-1
key = 7
resultado=TernarySearch(l,r,key,arr)
if resultado==-1:
    print(&quot;No existe el dato en el arreglo&quot;)
else:
    print(&quot;Encontrado en el indice: &quot;+str(resultado))
</py>
  <orden>2</orden>
  <suborden>8</suborden>
  <fecha_creacion>2020-12-02 17:30:29</fecha_creacion>
  <fecha_modificacion>2020-12-07 02:21:35</fecha_modificacion>
</row>
<row>
  <ID>10</ID>
  <supergrupo>Ordenamientos</supergrupo>
  <tema>Bubble Sort</tema>
  <texto><div style="text-align: justify;"><span style="font-size: 10pt;">Ordenamiento burbuja es el algoritmo de ordenamiento más simple que existe, funciona intercambiando repetidamente los elementos adyacentes si están en orden incorrecto.
Si existen demasiadas recursiones puede llegar a ser demasiado demorado o resultar en un error en tiempo de ejecución.</span></div></texto>
  <complejidad_tiempo>Mejor caso :    O(n)            Peor caso :      O(n2)             Promedio: O(n2)</complejidad_tiempo>
  <java>
//Programa java que realiza Bubble Sort Recursivo

import java.util.Arrays;

public class RecursiveBubbleSort {

    static void bubbleSort(int arr[], int n) {
        // Caso base
        if (n == 1) {
            return;
        }
        //Un paso de Bubble Sort, luego de este
        //paso, el elemento más largo es movido
        //  hasta el final
        for (int i = 0; i &lt; n - 1; i++) {
            if (arr[i] &gt; arr[i + 1]) {   //intercambia arr[i], arr[i+1] 
                int temp = arr[i];
                arr[i] = arr[i + 1];
                arr[i + 1] = temp;
            }
        }
        bubbleSort(arr, n - 1);
    }

    public static void main(String[] args) {
        int arr[] = {64, 34, 25, 12, 22, 11, 90};
        bubbleSort(arr, arr.length);
        System.out.println(&quot;Array ordenado : &quot;);
        System.out.println(Arrays.toString(arr));
    }
}
</java>
  <cpp>#include &lt;bits/stdc++.h&gt;
#include &lt;cstdlib&gt;
using namespace std;
typedef long long int ll;

void bubble_sort(int arr[], int len) {
    if (len == 1) {
        return;
    }
    for (int j = 0; j &lt; len; j++) {
        for (int i = 0; i &lt; len - 1; i++) {
            if (arr[i] &gt; arr[i + 1]) {
                int temp = arr[i];
                arr[i] = arr[i + 1];
                arr[i + 1] = temp;
            }
        }
    }
}

int main() {
    int arr[] = {9, 7, 6, 4, 3, 2, 1, 7, 8, 43, 43, 4, 54, 54, 3, 234, 1, 23};
    int len = sizeof (arr) / sizeof (arr[0]);
    bubble_sort(arr, len);
    for (int i = 0; i &lt; len; ++i) {
        printf(&quot;%d &quot;, arr[i]);
    }
    return 0;
}
</cpp>
  <py>def BubbleSort(arr, n):
    if n == 1:
        return
    for i in range(n-1):
        if arr[i] &gt; arr[i + 1]:
            temp = arr[i]
            arr[i] = arr[i + 1]
            arr[i + 1] = temp
    BubbleSort(arr, n-1)
arr = [4,5,8,9,10,2]
BubbleSort(arr, len(arr))
print(arr)
</py>
  <orden>3</orden>
  <suborden>0</suborden>
  <fecha_creacion>2020-12-02 17:30:29</fecha_creacion>
  <fecha_modificacion>2020-12-07 02:21:44</fecha_modificacion>
</row>
<row>
  <ID>11</ID>
  <supergrupo>Ordenamientos</supergrupo>
  <tema>Merge Sort</tema>
  <texto><div style="text-align: justify;"><span style="font-size: 10pt;">Al igual que Quick Sort, Merge Sort es un algoritmo de Dividir y Conquistar.&nbsp;</span></div><div style="text-align: justify;">Divide el arreglo de entrada en dos mitades, se llama a sí misma para las dos mitades y luego combina las dos mitades clasificadas. La función merge () se usa para fusionar dos mitades.

El merge (arr, l, m, r) es un proceso clave que asume que arr [l...m] y arr [m + 1...r] están ordenados y combina los dos subarreglos ordenados en uno solo.&nbsp;
</div><div style="text-align: justify;"><br></div><div style="text-align: justify;">Merge Sort es útil para ordenar listas enlazadas en tiempo O (nLogn). En el caso de listas enlazadas, el caso es diferente principalmente debido a la diferencia en la asignación de memoria de los arrays y las listas enlazadas. A diferencia de los arrays, los nodos de listas enlazadas pueden no estar adyacentes en la memoria. A diferencia del array, en la lista enlazada, podemos insertar elementos en el medio en O (1) espacio adicional y O (1) tiempo.&nbsp;<span style="font-size: 10pt;">Por lo tanto, la operación de fusión de merge sort se puede implementar sin espacio adicional para las listas vinculadas.

En arrays, podemos hacer acceso aleatorio ya que los elementos son continuos en la memoria.</span></div></texto>
  <complejidad_tiempo>Mejor caso :    O(nlog(n))            Peor caso :      O(nlog(n))             Promedio: O(nlog(n))</complejidad_tiempo>
  <java>/*Programa java para Merge Sort*/
public class MergeSort {

    /*Une dos subarrays de arr[]
    Primer subarray es arr[1...m]
    Segundo subarray es arr[m+1..r]*/
    static void merge(int arr[], int l, int m, int r) {
        //Encuentra tamaños de dos subarrays a ser unidos
        int n1 = m - l + 1;
        int n2 = r - m;
        /* Crear arrays temporales */
        int L[] = new int[n1];
        int R[] = new int[n2];
        /*Copia datos en los arrays temporales*/
        for (int i = 0; i &lt; n1; ++i) {
            L[i] = arr[l + i];
        }
        for (int j = 0; j &lt; n2; ++j) {
            R[j] = arr[m + 1 + j];
        }
        /*Une los arreglos temporales*/
        // Indices iniciales del los dos subarrays
        int i = 0, j = 0;
        //indice inicial de array unido
        int k = l;
        while (i &lt; n1 &amp;&amp; j &lt; n2) {
            if (L[i] &lt;= R[j]) {
                arr[k] = L[i];
                i++;
            } else {
                arr[k] = R[j];
                j++;
            }
            k++;
        }
        /*Copia los elementos restanes de L[] si hay*/
        while (i &lt; n1) {
            arr[k] = L[i];
            i++;
            k++;
        }
        //Copia los elementos restanes de R[] si hay
        while (j &lt; n2) {
            arr[k] = R[j];
            j++;
            k++;
        }
    }

    static void sort(int arr[], int l, int r) {
        if (l &lt; r) {
            //Encuentra el punto medio
            int m = (l + r) / 2;
            // Ordena los dos subarrays
            sort(arr, l, m);
            sort(arr, m + 1, r);
            // Une los subarrays
            merge(arr, l, m, r);
        }
    }

    //Imprimir array
    static void printArray(int arr[]) {
        int n = arr.length;
        for (int i = 0; i &lt; n; ++i) {
            System.out.print(arr[i] + &quot; &quot;);
        }
        System.out.println();
    }

    public static void main(String args[]) {
        int arr[] = {12, 11, 13, 5, 6, 7};
        System.out.println(&quot;Array dado&quot;);
        printArray(arr);
        sort(arr, 0, arr.length - 1);
        System.out.println(&quot;\nArray ordenado&quot;);
        printArray(arr);
    }
}
</java>
  <cpp>#include &lt;bits/stdc++.h&gt;
#include &lt;cstdlib&gt;
using namespace std;

void merge(int arr[], int l, int m, int r) {
    int n1 = m - l + 1;
    int n2 = r - m;
    int L[n1];
    int R[n2];
    for (int i = 0; i &lt; n1; ++i) {
        L[i] = arr[l + i];
        for (int j = 0; j &lt; n2; j++) {
            R[j] = arr[m + 1 + j];
        }
    }
    int i = 0, j = 0;
    int k = l;
    while (i &lt; n1 &amp;&amp; j &lt; n2) {
        if (L[i] &lt;= R[j]) {
            arr[k] = L[i];
            i++;
        } else {
            arr[k] = R[j];
            j++;
        }
        k++;
    }
    while (i &lt; n1) {
        arr[k] = L[i];
        i++;
        k++;
    }
    while (j &lt; n2) {
        arr[k] = R[j];
        j++;
        k++;
    }
}

void printArray(int arr[], int n) {
    for (int i = 0; i &lt; n; i++) {
        printf(&quot;%d &quot;, arr[i]);
    }
    cout &lt;&lt; &quot;\n&quot;;
}

void sort(int arr[], int l, int r) {
    if (l &lt; r) {
        int m = (l + r) / 2;
        sort(arr, l, m);
        sort(arr, m + 1, r);
        merge(arr, l, m, r);
    }
}

int main() {
 
    /*
    int arr[]={3,41,1,34,41,2,4,0};
    int n=sizeof(arr)/sizeof(arr[0]);
    sort(arr,0,n-1);
    printArray(arr,n);
     */
    //Mediante lectura
    string str;
    getline(cin, str);
    string intermediate;
    vector&lt;int&gt; vec;
    stringstream check1(str);
    while (getline(check1, intermediate, &#39; &#39;)) {
        vec.push_back(atoi(intermediate.c_str()));
    }
    int arr[vec.size()];
    for (int i = 0; i &lt; vec.size(); ++i) {
        arr[i] = vec[i];
    }
    sort(arr, 0, vec.size() - 1);
    printArray(arr, vec.size());
    return 0;
}
</cpp>
  <py>def merge(arr, left, mid, right):
    n1 = mid - left + 1
    n2 = right - mid
    L, R = [], []
    for i in range(n1):
        L.append(arr[left + i])
    for i in range(n2):
        R.append(arr[mid + 1 + i])
    i, j = int(0), int(0)
    k = left
    while i &lt; n1 and j &lt; n2:
        if L[i] &lt;= R[j]:
            arr[k] = L[i]
            i += 1
        else:
            arr[k] = R[j]
            j += 1
        k += 1
    while i &lt; n1:
        arr[k] = L[i]
        i += 1
        k += 1
    while j &lt; n2:
        arr[k] = R[j]
        j += 1
        k += 1
        
def mergeSort(arr, left, right):
    if left &lt; right:
        m = (left + right) // 2
        mergeSort(arr, left, m)
        mergeSort(arr, m + 1, right)
        merge(arr, left, m, right)
        
arr = [int(x) for x in input().split()]
mergeSort(arr, 0, len(arr)-1)
print(arr)
</py>
  <orden>3</orden>
  <suborden>1</suborden>
  <fecha_creacion>2020-12-02 17:30:29</fecha_creacion>
  <fecha_modificacion>2020-12-06 20:05:43</fecha_modificacion>
</row>
<row>
  <ID>12</ID>
  <supergrupo>Ordenamientos</supergrupo>
  <tema>Binary Insertion Sort</tema>
  <texto><div style="text-align: justify;"><span style="font-size: 10pt;">Podemos usar la búsqueda binaria para reducir el número de comparaciones en el ordenamiento de inserción normal. El ordenamiento de inserción binaria utiliza la búsqueda binaria para encontrar la ubicación adecuada para insertar el elemento seleccionado en cada iteración.&nbsp;</span></div><div style="text-align: justify;">En el ordenamiento de inserción normal, se necesitan comparaciones O(n) (en la iteración n) en el peor de los casos. Podemos reducirlo a O (log n) mediante la búsqueda binaria.
El algoritmo en su conjunto aún tiene un tiempo de ejecución en el peor de los casos de O (n^2) debido a la serie de intercambios necesarios para cada inserción.
</div></texto>
  <complejidad_tiempo>Mejor caso :    O(n)            Peor caso :      O(n2)             Promedio: O(n2)</complejidad_tiempo>
  <java>// Programa java implementando
// Binary Insertion Sort

import java.util.Arrays;

public class BinaryInsertionSort {

    public static void main(String[] args) {
        int[] arr = {37, 23, 0, 17, 12, 72, 31,
            46, 100, 88, 54};
        sort(arr);
        for (int i = 0; i &lt; arr.length; i++) {
            System.out.print(arr[i] + &quot; &quot;);
        }
    }

    static void sort(int array[]) {
        for (int i = 1; i &lt; array.length; i++) {
            int x = array[i];
            // Encontrar ubicación para insertar usando
            // Binary Search
            int j = Math.abs(Arrays.binarySearch(array, 0, i, x) + 1);
            System.arraycopy(array, j, array, j + 1, i - j);
            // Colocar elemento en su correcta localización
            array[j] = x;
        }
    }
}
</java>
  <cpp>#include &lt;iostream&gt;

using namespace std;

int binarySearch(int arr[], int i, int low, int high) {
    if (high &lt;= low) {
        return (i &gt; arr[low]) ? (low + 1) : low;
    }
    int mid = (low + high) / 2;
    if (i == arr[mid]) {
        return mid + 1;
    }
    if (i &gt; arr[mid]) {
        return binarySearch(arr, i, mid + 1, high);
    }
    return binarySearch(arr, i, low, mid - 1);
}

void insertionSort(int arr[], int n) {
    int i, loc, j, selected;
    for (i = 1; i &lt; n; ++i) {
        j = i - 1;
        selected = arr[i];
        loc = binarySearch(arr, selected, 0, j);
        while (j &gt;= loc) {
            arr[j + 1] = arr[j];
            j--;
        }
        arr[j + 1] = selected;
    }
}

int main() {
    int arr[] = {-63, 8, -7, -15, -19, 17, 19, 110};
    int n = sizeof (arr) / sizeof (arr[0]);
    insertionSort(arr, n);
    cout &lt;&lt; &quot;Arreglo ordenado:&quot; &lt;&lt; endl;
    for (int i = 0; i &lt; n; i++) {
        if (i == n - 1) {
            cout &lt;&lt; arr[i] &lt;&lt; endl;
            break;
        }
        cout &lt;&lt; arr[i] &lt;&lt; &quot; &quot;;
    }
    return 0;
}
</cpp>
  <py>def partition(arr, low, high):
    pivot = arr[high]
    i = low - 1
    for j in range(low, high):
        if(arr[j] &lt; pivot):
            i = i + 1
            temp = arr[i]
            arr[i] = arr[j]
            arr[j] = temp
    temp = arr[i + 1]
    arr[i + 1] = arr[high]
    arr[high] = temp
    return i + 1


def quickSort(arr, low, high):
    if(low &lt; high):
        pivot = partition(arr, low, high)
        quickSort(arr, low, pivot-1)
        quickSort(arr, pivot + 1, high)


lista = [int(x) for x in input().split()]
quickSort(lista, 0, len(lista)-1)
print(*lista)</py>
  <orden>3</orden>
  <suborden>2</suborden>
  <fecha_creacion>2020-12-02 17:30:29</fecha_creacion>
  <fecha_modificacion>2020-12-06 20:05:44</fecha_modificacion>
</row>
<row>
  <ID>13</ID>
  <supergrupo>Ordenamientos</supergrupo>
  <tema>Quick Sort</tema>
  <texto>Quick Sort es un algoritmo de Dividir y Conquistar. Selecciona un elemento como pivote y divide el array dado alrededor del pivote seleccionado.&amp;nbsp;&lt;div style=&quot;font-weight: normal;&quot;&gt;&lt;br&gt;&lt;/div&gt;&lt;div style=&quot;&quot;&gt;&lt;span style=&quot;font-weight: bold;&quot;&gt;Hay muchas versiones diferentes de quick Sort que seleccionan pivote de diferentes maneras.
&amp;nbsp;&lt;/span&gt;&lt;/div&gt;&lt;div style=&quot;font-weight: normal;&quot;&gt;&lt;span style=&quot;white-space:pre&quot;&gt;	&lt;/span&gt;- Elije siempre el primer elemento como pivote.&amp;nbsp;&lt;/div&gt;&lt;div style=&quot;font-weight: normal;&quot;&gt;&lt;span style=&quot;white-space:pre&quot;&gt;	&lt;/span&gt;- Siempre elije el último elemento como pivote.&amp;nbsp;&lt;/div&gt;&lt;div style=&quot;font-weight: normal;&quot;&gt;&lt;span style=&quot;white-space:pre&quot;&gt;	&lt;/span&gt;- Elige un elemento aleatorio como pivote.&amp;nbsp;&lt;/div&gt;&lt;div style=&quot;font-weight: normal;&quot;&gt;&lt;span style=&quot;white-space:pre&quot;&gt;	&lt;/span&gt;- Elije la mediana como pivote.&amp;nbsp;&lt;/div&gt;&lt;div style=&quot;font-weight: normal;&quot;&gt;&lt;br&gt;&lt;/div&gt;&lt;div style=&quot;font-weight: normal;&quot;&gt;El proceso clave en quick Sort es partition (). El destino de las particiones es, dada un array y un elemento x del array como pivote, coloca x en su posición correcta en el array ordenado y coloca todos los elementos más pequeños (más pequeños que x) antes de x, y coloca todos los elementos mayores (mayores que x) después de X. Todo esto debe hacerse en tiempo lineal.
&lt;/div&gt;</texto>
  <complejidad_tiempo>Mejor caso :    O(nlog(n))            Peor caso :      O(n2)             Promedio: O(nlog(n))</complejidad_tiempo>
  <java>// Programa java para la implementación de QuickSort

public class QuickSort {

    /* Esta función toma el ultimo elemento como
    pivote, coloca el pivote en la posición correcta
    en el array ordenado, y coloca todos los más 
    pequeñps (Más pequeños que el pivote) a la izquierda
    del pivote, y todos los más grandes a la derecha del
    pivote*/
    static int partition(int arr[], int low, int high) {
        int pivot = arr[high];
        int i = (low - 1); // Indice del elemento más pequeño
        for (int j = low; j &lt; high; j++) {
            /*Si el actual elemento es más pequeño
            p igual que el pivote*/
            if (arr[j] &lt;= pivot) {
                i++;
                //intercambia arr[i] y arr[j] 
                int temp = arr[i];
                arr[i] = arr[j];
                arr[j] = temp;
            }
        }
        // Intercambia arr[i+1] y arr[high] (o pivote) 
        int temp = arr[i + 1];
        arr[i + 1] = arr[high];
        arr[high] = temp;

        return i + 1;
    }

    /*arr[] --&gt; Array que sera ordenado, 
      low  --&gt; indice inicial, 
      high  --&gt; indice final */
    static void sort(int arr[], int low, int high) {
        if (low &lt; high) {
            /* pi esta particionando indices, arr[pi] is  
              now at right place */
            int pi = partition(arr, low, high);
            // Recursivamente ordena elementos antes de 
            // la partición y despues de la partición
            sort(arr, low, pi - 1);
            sort(arr, pi + 1, high);
        }
    }
    /* Imprimir array */
    static void printArray(int arr[]) {
        int n = arr.length;
        for (int i = 0; i &lt; n; ++i) {
            System.out.print(arr[i] + &quot; &quot;);
        }
        System.out.println();
    }

    public static void main(String args[]) {
        int arr[] = {10, 7, 8, 9, 1, 5};
        int n = arr.length;
        sort(arr, 0, n - 1);
        System.out.println(&quot;Array ordenado&quot;);
        printArray(arr);
    }
}
</java>
  <cpp>#include &lt;bits/stdc++.h&gt;
#include &lt;cstdlib&gt;
using namespace std;

int partition(int arr[], int low, int high) {
    int pivot = arr[high];
    int i = (low - 1);

    for (int j = low; j &lt;= high - 1; j++) {
        if (arr[j] &lt;= pivot) {
            i++;
            int temp = arr[i];
            arr[i] = arr[j];
            arr[j] = temp;
        }
    }
    int temp = arr[i + 1];
    arr[i + 1] = arr[high];
    arr[high] = temp;
    return (i + 1);
}

void quickSort(int arr[], int low, int high) {
    if (low &lt; high) {

        int pi = partition(arr, low, high);

        quickSort(arr, low, pi - 1);
        quickSort(arr, pi + 1, high);
    }
}

void print(int arr[], int n) {
    for (int i = 0; i &lt; n; ++i) {
        printf(&quot;%d &quot;, arr[i]);
    }
    cout &lt;&lt; &quot;\n&quot;;
}

int main(int argc, char const *argv[]) {
    int arr[] = {9, 8, 7, 6, 5, 4, 3, 2, 1, 0};
    int n = sizeof (arr) / sizeof (arr[0]);
    quickSort(arr, 0, n - 1);
    print(arr, n);
    return 0;
}
</cpp>
  <py>def Partition(arr, low, high):
    pivot = arr[high]
    i = low-1
    for j in range(low, high):
        if arr[j] &lt;= pivot:
            i += 1
            temp = arr[i]
            arr[i] = arr[j]
            arr[j] = temp
    temp = arr[i + 1]
    arr[i + 1] = arr[high]
    arr[high] = temp
    return i + 1

def QuickSort(arr, low, high):
    if low &lt; high:
        pivot = Partition(arr, low, high)
        QuickSort(arr, low, pivot-1)
        QuickSort(arr, pivot + 1, high)
arr = [int(x) for x in input().split()]
QuickSort(arr, 0, len(arr)-1)
print(arr)
</py>
  <orden>3</orden>
  <suborden>3</suborden>
  <fecha_creacion>2020-12-02 17:30:29</fecha_creacion>
  <fecha_modificacion>2020-12-07 01:55:14</fecha_modificacion>
</row>
<row>
  <ID>14</ID>
  <supergrupo>Ordenamientos</supergrupo>
  <tema>Radix Sort</tema>
  <texto>Radix sort es un algoritmo de ordenamiento que clasifica los números según las posiciones de sus dígitos.&amp;nbsp;&lt;span style=&quot;font-size: 10pt;&quot;&gt;Básicamente, utiliza el valor posicional de los dígitos en un número.&amp;nbsp;&lt;/span&gt;&lt;div&gt;&lt;span style=&quot;font-size: 10pt;&quot;&gt;&lt;br&gt;&lt;/span&gt;&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;font-size: 10pt;&quot;&gt;A diferencia de la mayoría de los otros algoritmos de ordenamiento, como Merge Sort, Insertion Sort y burbuja, no compara los números.

Radix sort utiliza un algoritmo de ordenamiento estable como subrutina para ordenar los dígitos. Aquí hemos usado una variación de conteo como una subrutina que usa la raíz para ordenar los dígitos en cada posición.&amp;nbsp;&lt;/span&gt;&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;font-size: 10pt;&quot;&gt;&lt;br&gt;&lt;/span&gt;&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;font-size: 10pt;&quot;&gt;El ordenamiento radix es un algoritmo de ordenamiento estable y funciona bien en la práctica.

La clasificación por radix funciona clasificando los dígitos del dígito menos significativo al dígito más significativo. 

Si tenemos bits log2n para cada dígito, el tiempo de ejecución de Radix parece ser mejor que Quick Sort para una amplia gama de números de entrada. Los factores constantes ocultos en la notación asintótica son mayores para Radix Sort y Quick-Sort usa cachés de hardware de manera más efectiva.&lt;/span&gt;&lt;/div&gt;</texto>
  <complejidad_tiempo>Mejor caso :    O(dígitos*n)            Peor caso :     O(dígitos*n)             Promedio: O(dígitos*n)</complejidad_tiempo>
  <java>//Implementación java de Radix Sort

import java.util.*;

public class RadixSort {

    // Una función de utilidad que obtiene
    //El maximo valor en arr[] 
    static int getMax(int arr[], int n) {
        int mx = arr[0];
        for (int i = 1; i &lt; n; i++) {
            if (arr[i] &gt; mx) {
                mx = arr[i];
            }
        }
        return mx;
    }

    /*Una función que realiza conteo de ordenamiento en 
    arr[] de acuerdo al digito
    representado como exp*/
    static void countSort(int arr[], int n, int exp) {
        int output[] = new int[n]; // Array de salida
        int i;
        int count[] = new int[10];
        Arrays.fill(count, 0);
        // Almacena el conteo de las ocurrencias en count[]
        for (i = 0; i &lt; n; i++) {
            count[(arr[i] / exp) % 10]++;
        }
        // cambia count[i] de tal manera que ahora
        //contenga la actual posicion de este digito en
        //output[]
        for (i = 1; i &lt; 10; i++) {
            count[i] += count[i - 1];
        }
        //Contruye el array de salida
        for (i = n - 1; i &gt;= 0; i--) {
            output[count[(arr[i] / exp) % 10] - 1] = arr[i];
            count[(arr[i] / exp) % 10]--;
        }
        // copia el array de salida a arr[], ahora arr[] 
        // contiene los números ordenados de acuerdo al digito
        //actual 
        for (i = 0; i &lt; n; i++) {
            arr[i] = output[i];
        }
    }

    static void radixsort(int arr[], int n) {
        // Encuentra el maximo número para conocer el número 
        // de digitos
        int m = getMax(arr, n);
        for (int exp = 1; m / exp &gt; 0; exp *= 10) {
            countSort(arr, n, exp);
        }
    }

    //Imprimir el array
    static void print(int arr[], int n) {
        for (int i = 0; i &lt; n; i++) {
            System.out.print(arr[i] + &quot; &quot;);
        }
    }

    public static void main(String[] args) {
        int arr[] = {170, 45, 75, 90, 802, 24, 2, 66};
        int n = arr.length;
        radixsort(arr, n);
        print(arr, n);
    }
}
</java>
  <cpp>#include &lt;bits/stdc++.h&gt;
#include &lt;cstdlib&gt;
using namespace std;

int getMax(int arr[], int n) {
    int mx = arr[0];
    for (int i = 1; i &lt; n; ++i) {
        if (arr[i] &gt; mx) {
            mx = arr[i];
        }
    }
    return mx;
}

void countSort(int arr[], int n, int exp) {
    int output[n];
    int count[10];
    memset(count, 0, sizeof (count));
    for (int i = 0; i &lt; n; ++i) {
        count[(arr[i] / exp) % 10]++;
    }
    for (int i = 0; i &lt; 10; ++i) {
        count[i] += count[i - 1];
    }
    for (int i = n - 1; i &gt;= 0; --i) {
        output[count[(arr[i] / exp) % 10] - 1] = arr[i];
        count[(arr[i] / exp) % 10]--;
    }
    for (int i = 0; i &lt; n; ++i) {
        arr[i] = output[i];
    }
}

void radixSort(int arr[], int n) {
    int m = getMax(arr, n);
    for (int exp = 1; m / exp &gt; 0; exp *= 10) {
        countSort(arr, n, exp);
    }
}

void printArray(int arr[], int n) {
    for (int i = 0; i &lt; n; ++i) {
        printf(&quot;%d &quot;, arr[i]);
    }
    cout &lt;&lt; &quot;\n&quot;;
}

int main(int argc, char const *argv[]) {
    int arr[] = {9, 78, 6, 5, 32, 1, 1, 4, 5, 45};
    int n = sizeof (arr) / sizeof (arr[0]);
    radixSort(arr, n);
    printArray(arr, n);
    return 0;
}
</cpp>
  <py># Solo con Numeros Positivos

def getMax(arr, n):
    maxim = arr[0]
    for i in range(1, n):
        if(arr[i] &gt; maxim):
            maxim = arr[i]
    return maxim


def countSort(arr, n, exp):
    output = [0 for x in range(n)]
    count = [0 for x in range(10)]
    i = 0
    for i in range(0, n):
        count[(arr[i] // exp) % 10] += 1
    for i in range(1, 10):
        count[i] += count[i-1]
    for i in range(n-1, -1, -1):
        output[count[(arr[i] // exp) % 10]-1] = arr[i]
        count[(arr[i] // exp) % 10] -= 1
    for i in range(0, n):
        arr[i] = output[i]


def radixSort(arr, n):
    m = getMax(arr, n)
    exp = 1
    while m // exp &gt; 0:
        countSort(arr, n, exp)
        exp *= 10


lista = [int(x) for x in input().split()]
radixSort(lista, len(lista))
print(*lista)
</py>
  <orden>3</orden>
  <suborden>4</suborden>
  <fecha_creacion>2020-12-02 17:30:29</fecha_creacion>
  <fecha_modificacion>2020-12-07 01:56:47</fecha_modificacion>
</row>
<row>
  <ID>15</ID>
  <supergrupo>Ordenamientos</supergrupo>
  <tema>Shell Sort</tema>
  <texto>Shell Sort es principalmente una variación de Insertion Sort.&amp;nbsp;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;En el ordenamiento por inserción, movemos los elementos solo una posición adelante. Cuando un elemento tiene que moverse mucho más adelante, hay muchos movimientos involucrados. La idea de shell Sort es permitir el intercambio de elementos lejanos. En shell Sort, hacemos el array para un gran valor de h. Continuamos reduciendo el valor de h hasta que se convierte en 1. Se dice que un array está ordenado por h si todas las sublistas de cada elemento h están ordenadas.&amp;nbsp;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&amp;nbsp;La complejidad de tiempo de la implementación de shell Sort es O (n^2). En la implementación la brecha se reduce a la mitad en cada iteración.
&lt;/div&gt;</texto>
  <complejidad_tiempo>Mejor caso :    O(nlog(n))            Peor caso :     O(n2)             Promedio: O(nlog(n))</complejidad_tiempo>
  <java>// Implementación java de ShellSort

public class ShellSort {

    /*Imprimir el array */
    static void printArray(int arr[]) {
        int n = arr.length;
        for (int i = 0; i &lt; n; ++i) {
            System.out.print(arr[i] + &quot; &quot;);
        }
        System.out.println();
    }
    //Función ordenadora Shell Sort
    static void sort(int arr[]) {
        int n = arr.length;
        //Inicia con un gran salto, luego reduce el salto
        for (int gap = n / 2; gap &gt; 0; gap /= 2) {   
     //Realiza un insertion sort con salto
            // Los primeros elementros del sato a[0..gap-1]
            // estan ya en un orden de salto que sigue agregando
            //un elemento más hasta que el array entero este ordenado
            for (int i = gap; i &lt; n; i += 1) {
                //Agrega a[i] a los elementos que estan en el ordenamiento
                // con salto
                int temp = arr[i];
                int j;
                for (j = i; j &gt;= gap &amp;&amp; arr[j - gap] &gt; temp; j -= gap) {
                    arr[j] = arr[j - gap];
                }
                arr[j] = temp;
            }
        }
        
    }

    public static void main(String args[]) {
        int arr[] = {12, 34, 54, 2, 3};
        System.out.println(&quot;Array antes de ordenar&quot;);
        printArray(arr);
        sort(arr);
        System.out.println(&quot;Array despues de ordenar&quot;);
        printArray(arr);
    }
}
</java>
  <cpp>#include &lt;bits/stdc++.h&gt;
#include &lt;cstdlib&gt;
typedef long long int ll;
using namespace std;

void printArray(vector &lt;int&gt; myvec, int n) {
    for (int i = 0; i &lt; n; ++i) {
        printf(&quot;%d &quot;, myvec[i]);
    }
}

int sort(vector &lt;int&gt; myvec, int n) {
    for (int gap = n / 2; gap &gt; 0; gap /= 2) {
        for (int i = gap; i &lt; n; i += 1) {
            int temp = myvec[i];
            int j;
            for (j = i; j &gt;= gap &amp;&amp; myvec[j - gap] &gt; temp; j -= gap) {
                myvec[j] = myvec[j - gap];
            }
            myvec[j] = temp;
        }
    }
    printArray(myvec, n);
    return 0;
}

int main(int argc, char** argv) {
    int arr[] = {3, 4, 1, 3, 54, 6, 6, 4, 3, 2, 3, 1, 21};
    int n = sizeof (arr) / sizeof (arr[0]);
    vector&lt;int&gt; myvec;
    myvec.insert(myvec.begin(), arr, arr + n);
    sort(myvec, n);
    return 0;
}
</cpp>
  <py>def ShellSort(arr):
    n = len(arr)
    grap = n // 2
    while grap &gt; 0:
        i = grap
        while i &lt; n:
            temp = arr[i]
            j = i
            while j &gt;= grap and arr[j-grap] &gt; temp:
                arr[j] = arr[j-grap]
                j -= grap
            arr[j] = temp
            i += 1
        grap //= 2
        
arr = [12, 56, 89, 47, 89, 23]
ShellSort(arr)
print(*arr)
</py>
  <orden>3</orden>
  <suborden>5</suborden>
  <fecha_creacion>2020-12-02 17:30:29</fecha_creacion>
  <fecha_modificacion>2020-12-07 01:57:07</fecha_modificacion>
</row>
<row>
  <ID>16</ID>
  <supergrupo>Ordenamientos</supergrupo>
  <tema>Tim Sort</tema>
  <texto><p class="MsoNormalCxSpFirst" style="margin:0cm;margin-bottom:.0001pt;mso-add-space:
auto">TimSort es un algoritmo de ordenamiento basado en Insertion Sort y Merge
Sort.<o:p></o:p></p>

<p class="MsoNormalCxSpLast" style="margin:0cm;margin-bottom:.0001pt;mso-add-space:
auto"><o:p>&nbsp;</o:p></p>

<p class="MsoListParagraphCxSpFirst" style="margin-top:0cm;margin-right:0cm;
margin-bottom:0cm;margin-left:36.0pt;margin-bottom:.0001pt;mso-add-space:auto;
text-indent:-18.0pt;mso-list:l0 level1 lfo1"><!--[if !supportLists]--><span style="mso-ascii-font-family:Calibri;mso-fareast-font-family:Calibri;
mso-hansi-font-family:Calibri;mso-bidi-font-family:Calibri"><span style="mso-list:Ignore">-<span style="font:7.0pt &quot;Times New Roman&quot;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span></span>Es un algoritmo de ordenamiento estable
funciona en tiempo O (n Log n)<o:p></o:p></p>

<p class="MsoListParagraphCxSpMiddle" style="margin-top:0cm;margin-right:0cm;
margin-bottom:0cm;margin-left:36.0pt;margin-bottom:.0001pt;mso-add-space:auto;
text-indent:-18.0pt;mso-list:l0 level1 lfo1"><!--[if !supportLists]--><span style="mso-ascii-font-family:Calibri;mso-fareast-font-family:Calibri;
mso-hansi-font-family:Calibri;mso-bidi-font-family:Calibri"><span style="mso-list:Ignore">-<span style="font:7.0pt &quot;Times New Roman&quot;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span></span><!--[endif]-->Se utiliza en Arrays.sort () de Java, así como
en Python sorted() y C++ sort()<o:p></o:p></p>

<p class="MsoListParagraphCxSpLast" style="margin-top:0cm;margin-right:0cm;
margin-bottom:0cm;margin-left:36.0pt;margin-bottom:.0001pt;mso-add-space:auto;
text-indent:-18.0pt;mso-list:l0 level1 lfo1"><!--[if !supportLists]--><span style="mso-ascii-font-family:Calibri;mso-fareast-font-family:Calibri;
mso-hansi-font-family:Calibri;mso-bidi-font-family:Calibri"><span style="mso-list:Ignore">-<span style="font:7.0pt &quot;Times New Roman&quot;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span></span><!--[endif]-->Primero clasifica las piezas pequeñas utilizando
el ordenamiento de Inserción, luego fusiona las piezas utilizando ordenamiento
por fusión (Merge Sort).<o:p></o:p></p>

<p class="MsoNormal" style="margin:0cm;margin-bottom:.0001pt"><o:p>&nbsp;</o:p></p>

<p class="MsoNormalCxSpMiddle" style="margin:0cm;margin-bottom:.0001pt;
mso-add-space:auto">Dividimos el array en bloques conocidos como Run. Ordenamos
esas ejecuciones utilizando el ordenamiento por inserción una por una y luego
las combinamos utilizando la función de combinación utilizada en Merge Sort. Si
el tamaño del array es menor que run, entonces el array se clasifica
simplemente utilizando el ordenamiento de inserción.<o:p></o:p></p>

<p class="MsoNormalCxSpMiddle" style="margin:0cm;margin-bottom:.0001pt;
mso-add-space:auto"><o:p>&nbsp;</o:p></p>

<p class="MsoNormalCxSpMiddle" style="margin:0cm;margin-bottom:.0001pt;
mso-add-space:auto">El tamaño de run puede variar de 32 a 64, dependiendo del
tamaño del array. Tenga en cuenta que la función de combinación funciona bien
cuando los arreglos secundarios de tamaño son potencias de 2. La idea se basa
en el hecho de que el ordenamiento por inserción funciona bien para arreglos
pequeños.<o:p></o:p></p></texto>
  <complejidad_tiempo>Mejor caso :    O(n)            Peor caso :     O(nlog(n))             Promedio: O(nlog(n))</complejidad_tiempo>
  <java>// Programa Java que realiza TimSort

public class TimSort {

    static int RUN = 32;
    // esta función ordena el arreglo 
    //desde el índice izquierdo hasta
    //a la derecha el índice que es de tamaño más alto RUN 
    public static void insertionSort(int[] arr, int left, int right) {
        for (int i = left + 1; i &lt;= right; i++) {
            int temp = arr[i];
            int j = i - 1;
            while (arr[j] &gt; temp &amp;&amp; j &gt;= left) {
                arr[j + 1] = arr[j];
                j--;
  if (j &lt; 0) {
                    break;
                }

            }
            arr[j + 1] = temp;
        }
    }

    public static void merge(int[] arr, int l, int m, int r) {
        //Array original esta separado en dos partes
        // array derecho e izquierdo 
        int len1 = m - l + 1, len2 = r - m;
        int[] left = new int[len1];
        int[] right = new int[len2];
        for (int x = 0; x &lt; len1; x++) {
            left[x] = arr[l + x];
        }
        for (int x = 0; x &lt; len2; x++) {
            right[x] = arr[m + 1 + x];
        }
        int i = 0;
        int j = 0;
        int k = l;
        // despues de comparar, 
        // after comparing,unimos los dos array  
        // en un subarray más largo
        while (i &lt; len1 &amp;&amp; j &lt; len2) {
            if (left[i] &lt;= right[j]) {
                arr[k] = left[i];
                i++;
            } else {
                arr[k] = right[j];
                j++;
            }
            k++;
        }
        //Copia los elementos restates de la izquiera, si hay
        while (i &lt; len1) {
            arr[k] = left[i];
            k++;
            i++;
        }
        // Copia los elementos restates de la derecha, si hay
        while (j &lt; len2) {
            arr[k] = right[j];
            k++;
            j++;
        }
    }

    public static void timSort(int[] arr, int n) {
        //Ordena individualmente los subarrays de 
        //tamaño RUN
        for (int i = 0; i &lt; n; i += RUN) {
            insertionSort(arr, i, Math.min((i + 31), (n - 1)));
        }
        //Comienza a unir de tamaño run, luego
        //podra unir de tamaño 64, 128, 256 y asi...
        for (int size = RUN; size &lt; n; size = 2 * size) {
            // Toma un punto inicial del subarray izquierdo
            // nosotros vamos a unir arr[left..left+size-1] y
            //arr[left+size, left+2*size-1], luego de cada union
            // nosotros incrementamos izquiera en  2*size  
            for (int left = 0; left &lt; n; left += 2 * size) {
                //Encontramos punto de finalizacion de
                // el subarray izquierdo, mid+1
                // mid+1 es el punto inicial del 
                //subarray derecho  
                int mid = Math.min((left + size - 1), (n - 1));
                int right = Math.min((left + 2 * size - 1), (n - 1));
                // une sub array arr[left.....mid] y  
                // arr[mid+1....right]  
                merge(arr, left, mid, right);
            }
        }
    }

    // Imprimir el array
    public static void printArray(int[] arr, int n) {
        for (int i = 0; i &lt; n; i++) {
            System.out.print(arr[i] + &quot; &quot;);
        }
        System.out.print(&quot;\n&quot;);
    }

    public static void main(String[] args) {
        int[] arr = {5, 21, 7, 23, 19};
        int n = arr.length;
        System.out.print(&quot;El array dado es\n&quot;);
        printArray(arr, n);
        timSort(arr, n);
        System.out.print(&quot;Array ordenado\n&quot;);
        printArray(arr, n);
    }
}
</java>
  <cpp>#include &lt;bits/stdc++.h&gt;
#include &lt;cstdlib&gt;
#define MAX 256
typedef long long int ll;
using namespace std;
int RUN = 32;

void printArray(int arr[], int n) {
    for (int i = 0; i &lt; n; i++) {
        printf(&quot;%d &quot;, arr[i]);
    }
}

void insertionSort(int arr[], int left, int rigth) {
    for (int i = left + 1; i &lt;= rigth; ++i) {
        int temp = arr[i];
        int j = i - 1;
        while (arr[j] &gt; temp &amp;&amp; j &gt;= left) {
            arr[j + 1] = arr[j];
            j--;
        }
        arr[j + 1] = temp;
    }
}

void merge(int arr[], int l, int m, int r) {
    int len1 = m - l + 1, len2 = r - m;
    int left[len1];
    int rigth[len2];
    for (int x = 0; x &lt; len1; ++x) {
        left[x] = arr[l + x];
    }
    for (int x = 0; x &lt; len2; ++x) {
        rigth[x] = arr[m + 1 + x];
    }
    int i = 0, j = 0, k = l;
    while (i &lt; len1 &amp;&amp; j &lt; len2) {
        if (left[i] &lt;= rigth[j]) {
            arr[k] = left[i];
            i++;
        } else {
            arr[k] = rigth[j];
            j++;
        }
        k++;
    }
    while (i &lt; len1) {
        arr[k] = left[i];
        k++;
        i++;
    }
    while (j &lt; len2) {
        arr[k] = rigth[j];
        k++;
        j++;
    }
}

void timSort(int arr[], int n) {
    for (int i = 0; i &lt; n; i += RUN) {
        insertionSort(arr, i, std::min((i + 31), (n - 1)));
    }
    for (int size = RUN; size &lt; n; size = 2 * size) {
        for (int left = 0; left &lt; n; left += 2 * size) {
            int mid = std::min((left + size - 1), (n - 1));
            int rigth = std::min((left + 2 * size - 1), (n - 1));
            merge(arr, left, mid, rigth);
        }
    }
    printArray(arr, n);
}

int main(int argc, char** argv) {
    int arr[] = {3, 4, 5, 6, 3, 1, 1, 23, 5, 546, 34, 3, 2, 2};
    int len = sizeof (arr) / sizeof (arr[0]);
    timSort(arr, len);
    return 0;
}
</cpp>
  <py>from sys import stdout
wr = stdout.write

RUN = 32
def insertionSort(arr, left, right):
    for i in range(left + 1, right + 1):
        temp = arr[i]
        j = i - 1
        while j &gt;= left and arr[j] &gt; temp:
            arr[j + 1] = arr[j]
            j -= 1
        arr[j + 1] = temp


def merge(arr, l, m, r):
    len1 = m - l + 1
    len2 = r - m
    left = [0 for x in range(len1)]
    right = [0 for x in range(len2)]
    for i in range(len1):
        left[x] = arr[l + x]
    for i in range(len2):
        right[x] = arr[m + 1 + x]
    i = 0
    j = 0
    k = l
    while i &lt; len1 and j &lt; len2:
        if left[i] &lt;= right[i]:
            arr[k] = left[i]
            i += 1
        else:
            arr[k] = right[j]
            j += 1
        k += 1
    while i &lt; len1:
        arr[k] = left[i]
        k += 1
        i += 1
    while j &lt; len2:
        arr[k] = right[j]
        k += 1
        j += 1


def timSort(arr, n):
    i = 0
    while i &lt; n:
        insertionSort(arr, i, min((i + 31), (n - 1)))
        i += RUN
    size = RUN
    while size &lt; n:
        left = 0
        while left &lt; 2:
                        mid = min ((left + size - 1), (n - 1))
            right = min((left + 2 * size - 1), (n - 1))
            merge(arr, left, mid, right)
            left += 2 * size
        size = 2 * size


def printArray(arr, n):
    for i in range(n):
        wr(f&#39;{arr[i]} &#39;)
    wr(&#39;\n&#39;)

arr = [int(x) for x in input().split()]
n = len(arr)
timSort(arr, n)
printArray(arr, n)
</py>
  <orden>3</orden>
  <suborden>6</suborden>
  <fecha_creacion>2020-12-04 20:09:36</fecha_creacion>
  <fecha_modificacion>2020-12-07 01:58:30</fecha_modificacion>
</row>
<row>
  <ID>17</ID>
  <supergrupo>Ordenamientos</supergrupo>
  <tema>Tree Sort</tema>
  <texto><div style="text-align: justify;"><span style="font-size: 10pt;">Ordenamiento árbol es un algoritmo de clasificación que se basa en la estructura de datos del Binary Search Tree (Árbol de búsqueda binaria).&nbsp;</span></div><div style="text-align: justify;"><span style="font-size: 10pt;"><br></span></div><div style="text-align: justify; font-weight: normal;">Primero crea un árbol de búsqueda binario a partir de los elementos de la lista de entrada o un array luego realiza un recorrido inorden en el árbol de búsqueda binario creado para obtener los elementos ordenados.&nbsp;</div><div style="text-align: justify; font-weight: normal;"><br></div><div style="text-align: justify; "><span style="font-weight: bold;">Para recorrer un árbol binario no vacío en inorden, hay que realizar las siguientes operaciones recursivamente en cada nodo:&nbsp;</span></div><div style="text-align: justify; font-weight: normal;"><span style="white-space:pre">	</span>1. Atraviese el sub-árbol o nodo izquierdo&nbsp;</div><div style="text-align: justify; font-weight: normal;"><span style="white-space:pre">	</span>2. Visite la raiz&nbsp;</div><div style="text-align: justify; font-weight: normal;"><span style="white-space:pre">	</span>3. Atraviese el sub-árbol o nodo derecho
</div></texto>
  <complejidad_tiempo>Mejor caso :    O(nlog(n))            Peor caso :     O(n2)             Promedio: O(nlog(n))</complejidad_tiempo>
  <java>//Código java que implementa Tree Sort 

public class TreeSort {
    
    //Clase conteniendo hijo izquierdo
    //y derecho del nodo actual, y 
    // el valor del nodo (Key)
    static class Node {
        int key;
        Node left, right;
        public Node(int item) {
            key = item;
            left = right = null;
        }
    }
    // Raiz del arbol de busqueda
    //binaria
    static Node root;
    static void init() {
        root = null;
    }
    static void insert(int key) {
        root = insertRec(root, key);
    }

    /*Una función recursiva que inserta 
    nuevos valores al arbol de busqueda binaria*/
    static Node insertRec(Node root, int key) {
        /*Si el arbol esta vacio
        Retorne un nuevo nodo*/
        if (root == null) {
            root = new Node(key);
            return root;
        }
        /*De otra forma, baja por el arbol*/
        if (key &lt; root.key) {
            root.left = insertRec(root.left, key);
        } else if (key &gt; root.key) {
            root.right = insertRec(root.right, key);
        }
        /*Retorna la raiz*/
        return root;
    }

    /*Una función que realiza recorrido
    inorden atraves del arbol*/
    static void inorderRec(Node root) {
        if (root != null) {
            inorderRec(root.left);
            System.out.print(root.key + &quot; &quot;);
            inorderRec(root.right);
        }
    }

    static void treeins(int arr[]) {
        for (int i = 0; i &lt; arr.length; i++) {
            insert(arr[i]);
        }
    }

    public static void main(String[] args) {
        int arr[] = {5, 4, 7, 2, 11};
        treeins(arr);
        inorderRec(root);
    }
}
</java>
  <cpp>#include &lt;bits/stdc++.h&gt;
#include &lt;cstdlib&gt;
using namespace std;

struct Node {
    int key;
    struct Node *left, *right;
};

struct Node *newNode(int item) {
    struct Node *temp = new Node;
    temp-&gt;key = item;
    temp-&gt;left = temp-&gt;right = NULL;
    return temp;
}

void storeSorted(Node *root, int arr[], int &amp;i) {
    if (root != NULL) {
        storeSorted(root-&gt;left, arr, i);
        arr[i++] = root-&gt;key;
        storeSorted(root-&gt;right, arr, i);
    }
}

Node* insert(Node* node, int key) {
    if (node == NULL) {
        return newNode(key);
    }
    if (key &lt; node-&gt;key) {
        node-&gt;left = insert(node-&gt;left, key);
    } else if (key &gt; node-&gt;key) {
        node-&gt;right = insert(node-&gt;right, key);
    }
    return node;
}

void printArray(int arr[], int n) {
    for (int i = 0; i &lt; n; ++i) {
        printf(&quot;%d &quot;, arr[i]);
    }
}

void treeSort(int arr[], int n) {
    struct Node *root = NULL;

    root = insert(root, arr[0]);
    for (int i = 1; i &lt; n; i++)
        root = insert(root, arr[i]);

    int i = 0;
    storeSorted(root, arr, i);
    printArray(arr, n);
}
 
int main() {
    /*
    int arr[]={2,3,5,1,32,4,50};
    int n = sizeof(arr)/sizeof(arr[0]);
    treeSort(arr,n);
     */
    string str;
    getline(cin, str);
    string intermediate;
    vector&lt;int&gt; vec;
    stringstream check1(str);
    while (getline(check1, intermediate, &#39; &#39;)) {
        vec.push_back(atoi(intermediate.c_str()));
    }
    int arr[vec.size()];
    for (int i = 0; i &lt; vec.size(); ++i) {
        arr[i] = vec[i];
    }
    treeSort(arr, vec.size());
    return 0;
}
</cpp>
  <py>from sys import stdin
from sys import stdout
rl = stdin.readline
wr = stdout.write


class Hoja:

    def __init__(self, item=None):
        self.key = item
        self.right = None
        self.left = None
        
root = Hoja()

def init():
    global root
    root = None

def insert(key):
    global root
    root = insertRec(root, key)

def insertRec(raiz, key):
   
    if raiz == None:
        raiz = Hoja(key)
        return raiz

    if key &lt; raiz.key:
        raiz.left = insertRec(raiz.left, key)
    elif key &gt;= raiz.key:
        raiz.right = insertRec(raiz.right, key)

    return raiz

def inOrder(actual):
    if actual != None:
        inOrder(actual.left)
        wr(f&#39;{actual.key} &#39;)
        inOrder(actual.right)

       
def insertInTree(arr):
    for i in range(len(arr)):
        insert(arr[i])

arr = list(map(int, rl().split()))
init()
insertInTree(arr)
inOrder(root)
wr(&#39;\n&#39;)
</py>
  <orden>3</orden>
  <suborden>7</suborden>
  <fecha_creacion>2020-12-04 20:09:36</fecha_creacion>
  <fecha_modificacion>2020-12-06 20:05:47</fecha_modificacion>
</row>
<row>
  <ID>18</ID>
  <supergrupo>Ordenamientos</supergrupo>
  <tema>Bitonic Sort</tema>
  <texto>Bitonic Sort es un algoritmo clásico para ordenamiento.
El ordenamiento bitónico hace comparaciones O (n Log 2n).
El número de comparaciones realizadas por Bitonic Sort son más que los algoritmos de clasificación populares como Merge Sort [hace O (nLogn) comparaciones], pero Bitonic es mejor para la implementación en paralelo porque siempre comparamos elementos en una secuencia predefinida y la secuencia de comparación no. Depende de los datos. Por lo tanto, es adecuado para la implementación en hardware y array de procesado paralelo&amp;nbsp;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;Para entender el ordenamiento bitónico, primero debemos entender qué es la secuencia bitónica y cómo hacer una secuencia dada bitónica.
Una secuencia es bitónica si primero aumenta, luego disminuye. En otras palabras, una matriz arr [0...n-i] es bitonica si existe un índice i donde&amp;nbsp;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div style=&quot;text-align: center;&quot;&gt;0 &amp;lt;= i &amp;lt;= n-1 tal que
x0 &amp;lt;= x1 ... .. &amp;lt;= xi y xi&amp;gt; = xi + 1 ... ..&amp;gt; = xn-1&amp;nbsp;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;Para formar una secuencia ordenada de longitud n a partir de dos secuencias ordenadas de longitud n / 2, se requieren comparaciones de log (n) (por ejemplo: log (8) = 3 cuando el tamaño de la secuencia. Por lo tanto, el número de comparaciones T (n) de la clasificación completa está dada por:
T (n) = log (n) + T (n / 2) la solución de esta ecuación de recurrencia es&amp;nbsp;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div style=&quot;text-align: center;&quot;&gt;T (n) = log (n) + log (n) -1 + log (n) -2 +… + 1 = log (n) · (log (n) +1) / 2&amp;nbsp;&lt;/div&gt;&lt;div&gt;&amp;nbsp;&lt;/div&gt;&lt;div&gt;Cada etapa de la red de ordenamiento consiste en n / 2 comparaciones. Por lo tanto un total de O (n log2n) comparaciones.
&lt;/div&gt;</texto>
  <complejidad_tiempo>Mejor caso :    O(log2(n))            Peor caso :     O(log2(n))             Promedio: O(log2(n))</complejidad_tiempo>
  <java>/* Programa java para Bitonic Sort*/
/* Nota: Este programa solo funciona si el tamaño
de la entrada es una potencia de 2*/
public class BitonicSort {

    /* El parámetro dir indica la dirección de ordenamiento,
       ASCENDIENDO o DESCENDIENDO; si (a [i]&gt; a [j]) está de acuerdo
       con la dirección, entonces a[i] y a[j] son
        intercambiados*/
    static void compAndSwap(int a[], int i, int j, int dir) {
        if ((a[i] &gt; a[j] &amp;&amp; dir == 1)
                || (a[i] &lt; a[j] &amp;&amp; dir == 0)) {
            // intercambiando elementos
            int temp = a[i];
            a[i] = a[j];
            a[j] = temp;
        }
    }

    static void bitonicMerge(int a[], int low, int cnt, int dir) {
        if (cnt &gt; 1) {
            int k = cnt / 2;
            for (int i = low; i &lt; low + k; i++) {
                compAndSwap(a, i, i + k, dir);
            }
            bitonicMerge(a, low, k, dir);
            bitonicMerge(a, low + k, k, dir);
        }
    }

    static void bitonicSort(int a[], int low, int cnt, int dir) {
        if (cnt &gt; 1) {
            int k = cnt / 2;
            // Ordena en orden ascendente, dir es 1 
            bitonicSort(a, low, k, 1);
            // ordena en orden descendente, dir es 0
            bitonicSort(a, low + k, k, 0);
            // une toda la secuencia en orden ascendente
            bitonicMerge(a, low, cnt, dir);
        }
    }

    static void sort(int a[], int N, int up) {
        bitonicSort(a, 0, N, up);
    }

    /*Imprimir array */
    static void printArray(int arr[]) {
        int n = arr.length;
        for (int i = 0; i &lt; n; ++i) {
            System.out.print(arr[i] + &quot; &quot;);
        }
        System.out.println();
    }

    public static void main(String args[]) {
        int a[] = {3, 7, 4, 8, 6, 2, 1, 5};
        int up = 1;
        sort(a, a.length, up);
        System.out.println(&quot;\nArray ordenado&quot;);
        printArray(a);
    }
} 
</java>
  <cpp>#include &lt;iostream&gt;

using namespace std;

void compAndSwap(int arr[], int i, int j, int dir) {
    if ((arr[i] &gt; arr[j] &amp;&amp; dir == 1) || (arr[i] &lt; arr[j] &amp;&amp; dir == 0)) {
        swap(arr[i], arr[j]);
    }
}

void bitonicMerge(int arr[], int low, int cnt, int dir) {
    if (cnt &gt; 1) {
        int k = cnt / 2;
        for (int i = low; i &lt; low + k; i++) {
            compAndSwap(arr, i, i + k, dir);
        }
        bitonicMerge(arr, low, k, dir);
        bitonicMerge(arr, low + k, k, dir);
    }
}

void bitonicSort(int arr[], int low, int cnt, int dir) {
    if (cnt &gt; 1) {
        int k = cnt / 2;
        bitonicSort(arr, low, k, 1);
        bitonicSort(arr, low + k, k, 0);
        bitonicMerge(arr, low, cnt, dir);
    }
}

void sorted(int arr[], int N, int up) {
    bitonicSort(arr, 0, N, up);
}

void printArray(int arr[], int n) {
    for (int i = 0; i &lt; n; ++i) {
        if (i == n - 1) {
            cout &lt;&lt; arr[i] &lt;&lt; endl;
            break;
        }
        cout &lt;&lt; arr[i] &lt;&lt; &quot; &quot;;
    }
}

int main() {
    int arr[] = {-5, -6, -1, -4, 8, 100, -90, -15, 35};
    int up = 1;
    int tam = sizeof (arr) / sizeof (arr[0]);
    sorted(arr, tam, up);
    cout &lt;&lt; &quot;Array ordenado&quot; &lt;&lt; endl;
    printArray(arr, tam);
    return 0;
}
</cpp>
  <py>from sys import stdin, stdout
rl = stdin.readline
wr = stdout.write

def compAndSwap(arr, i, j, direc):
    if (arr[i] &gt; arr[j] and direc == 1) or (arr[i] &lt; arr[j] and direc == 0):
        arr[i], arr[j] = arr[j], arr[i]

def bitonicMerge(arr, low, cnt, direc):
    if cnt &gt; 1:
        k = cnt // 2
        for i in range(low, low+k):
            compAndSwap(arr, i, i+k, direc)

        bitonicMerge(arr, low, k, direc)
        bitonicMerge(arr, low+k, k, direc)


def bitonicSort(arr, low, cnt, direc):

    if cnt &gt; 1:
        k = cnt // 2
        bitonicSort(arr, low, k, 1)
        bitonicSort(arr, low+k, k, 0)
        bitonicMerge(arr, low, cnt, direc)


def sortB(arr, n, up):
    bitonicSort(arr, 0, n, up)


def printArray(arr):
    for i in arr:
        wr(f&#39;{i} &#39;)
    wr(&#39;\n&#39;)


arr = list(map(int, rl().split()))
up = 1  # 0 = Mayor a Menor
printArray(arr)
sortB(arr, len(arr), up)
printArray(arr)
</py>
  <orden>3</orden>
  <suborden>8</suborden>
  <fecha_creacion>2020-12-04 20:09:36</fecha_creacion>
  <fecha_modificacion>2020-12-07 02:01:08</fecha_modificacion>
</row>
<row>
  <ID>19</ID>
  <supergrupo>Ordenamientos</supergrupo>
  <tema>Cocktail Sort</tema>
  <texto>Cocktail Sort es una variación de Bubble Sort.&amp;nbsp;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;El algoritmo de ordenamiento de burbuja siempre atraviesa elementos de la izquierda y mueve el elemento más grande a su posición correcta en la primera iteración y el segundo más grande en la segunda iteración, y así sucesivamente. El ordenamiento de cóctel atraviesa un vector dado en ambas direcciones alternativamente.&amp;nbsp;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;Las complejidades de tiempo son iguales, pero Cocktail se desempeña mejor que Bubble Sort. Por lo general, el cóctel es menos de dos veces más rápido que el tipo burbuja. Considere el ejemplo (2, 3, 4, 5, 1). La clasificación de burbuja requiere cuatro recorridos de matriz para este ejemplo, mientras que la clasificación de cóctel requiere solo dos recorridos.
&lt;/div&gt;</texto>
  <complejidad_tiempo>Mejor caso :    O(n)            Peor caso :     O(n2)             Promedio: O(n2)</complejidad_tiempo>
  <java>// Programa java implementando Cocktail sort

public class CocktailSort {

    static void cocktailSort(int a[]) {
        boolean swapped = true;
        int start = 0;
        int end = a.length;
        while (swapped == true) {
            // Resetea la bandera intercambiada al entrar
            // en el ciclo, porque puede ser true de la
            // anterior iteración
            swapped = false;
            // Ciclo del fondo a encima igual
            // que bubble sort
            for (int i = start; i &lt; end - 1; ++i) {
                if (a[i] &gt; a[i + 1]) {
                    int temp = a[i];
                    a[i] = a[i + 1];
                    a[i + 1] = temp;
                    swapped = true;
                }
            }
            // Si nada fue movido, array esta ordenado
            if (swapped == false) {
                break;
            }
            // de otra forma, resetea la bandera intercambiada
            // de tal forma que pueda ser usada en el 
            //siguiente proceso
            swapped = false;
            // Mueve el punto final atras en uno, porque
            // el item al final esta en la derecha completa
            end = end - 1;
            // from top to bottom, doing the 
            // same comparison as in the previous stage 
            for (int i = end - 1; i &gt;= start; i--) {
                if (a[i] &gt; a[i + 1]) {
                    int temp = a[i];
                    a[i] = a[i + 1];
                    a[i + 1] = temp;
                    swapped = true;
                }
            }
            // Incrementa el punto inicial, por que
            // la ultima fase pudo haber movido el siguiente
            // más pequeño número en la derecha completa
            start = start + 1;
        }
    }
    /* Imprime el array*/
    static void printArray(int a[]) {
        int n = a.length;
        for (int i = 0; i &lt; n; i++) {
            System.out.print(a[i] + &quot; &quot;);
        }
        System.out.println();
    }
    public static void main(String[] args) {
        int a[] = {5, 1, 4, 2, 8, 0, 2};
        cocktailSort(a);
        System.out.println(&quot;Arreglo ordenado&quot;);
        printArray(a);
    }
}
</java>
  <cpp>#include &lt;iostream&gt;

using namespace std;

void cocktailSort(int arr[], int n) {
    bool swapped = true;
    int start = 0;
    int ended = n;
    while (swapped == true) {
        swapped = false;
        for (int i = start; i &lt; ended - 1; ++i) {
            if (arr[i] &gt; arr[i + 1]) {
                int temp = arr[i];
                arr[i] = arr[i + 1];
                arr[i + 1] = temp;
                swapped = true;
            }
        }
        if (swapped == false) {
            break;
        }
        swapped = false;
        ended = ended - 1;
        for (int i = ended - 1; i &gt;= start; i--) {
            if (arr[i] &gt; arr[i + 1]) {
                int temp = arr[i];
                arr[i] = arr[i + 1];
                arr[i + 1] = temp;
                swapped = true;
            }
        }
        start += 1;
    }
}

void printArray(int arr[], int n) {
    for (int i = 0; i &lt; n; i++) {
        if (i == n - 1) {
            cout &lt;&lt; arr[i] &lt;&lt; endl;
            break;
        }
        cout &lt;&lt; arr[i] &lt;&lt; &quot; &quot;;
    }
}

int main() {
    int arr[] = {-5, -90, 5, 9, 7, -15, 8, 2, -8, 0, 1, 32, -35};
    int tam = sizeof (arr) / sizeof (arr[0]);
    cocktailSort(arr, tam);
    cout &lt;&lt; &quot;Arreglo ordenado&quot; &lt;&lt; endl;
    printArray(arr, tam);
    return 0;
}
</cpp>
  <py>from sys import stdin, stdout
rl = stdin.readline
wr = stdout.write

def cocktailSort(arr):
    swapped = True
    start = 0
    end = len(arr)
    while swapped:  # Sort Izq a Der
        swapped = False
        for i in range(start, end-1):
            if arr[i] &gt; arr[i+1]:  # Cambiar &lt; o &gt;
                arr[i], arr[i+1] = arr[i+1], arr[i]
                swapped = True
        if not swapped:
            break

    swapped = False
    end -= 1
    for i in range(end-1, start-1, -1):  # Sort Der a Izq
        if arr[i] &gt; arr[i+1]:  # Cambiar &lt; o &gt;
            arr[i], arr[i+1] = arr[i+1], arr[i]
            swapped = True

    start += 1


def printArray(arr):
    for i in arr:
        wr(f&#39;{i} &#39;)
    wr(&#39;\n&#39;)


arr = list(map(int, rl().split()))
printArray(arr)
cocktailSort(arr)
printArray(arr)
</py>
  <orden>3</orden>
  <suborden>9</suborden>
  <fecha_creacion>2020-12-04 20:09:36</fecha_creacion>
  <fecha_modificacion>2020-12-07 02:04:41</fecha_modificacion>
</row>
<row>
  <ID>20</ID>
  <supergrupo>Ordenamientos</supergrupo>
  <tema>Comb Sort</tema>
  <texto>Comb Sort es principalmente una mejora sobre Bubble Sort. El ordenamiento de burbuja siempre compara valores adyacentes. Así que todas las inversiones se eliminan una por una. Comb Sort mejora en Bubble Sort usando un espacio de tamaño mayor que 1. El espacio comienza con un gran valor y se reduce en un factor de 1.3 en cada iteración hasta que alcanza el valor 1.&amp;nbsp;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;Por lo tanto, Comb Sort funciona mejor que Bubble Sort.
Aunque funciona mejor que Bubble Sort en promedio, el peor de los casos sigue siendo O (n^2).
&lt;/div&gt;</texto>
  <complejidad_tiempo>Mejor caso :    O(nlog(n))            Peor caso :     O(n2)             Promedio: O(n2/2incrementos)</complejidad_tiempo>
  <java>// Programa java implementando Comb Sort

public class CombSort {

    // Para buscar espacio entre elementos
    static int getNextGap(int gap) {
        gap = (gap * 10) / 13;
        if (gap &lt; 1) {
            return 1;
        }
        return gap;
    }

    static void sort(int arr[]) {
        int n = arr.length;
        // Inicializa espacio
        int gap = n;
        boolean swapped = true;
        /*Mantiene ejecutando mientras gap es más que 1 y la 
        ultima iteración causa un intercambio*/
        while (gap != 1 || swapped == true) {
            gap = getNextGap(gap);
            /*Inicializa swapped como falso, aso 
            podemos verificar si el intercambio paso
            o no*/
            swapped = false;
            //Compara todos los elementos con el espacio actual 
            for (int i = 0; i &lt; n - gap; i++) {
                if (arr[i] &gt; arr[i + gap]) {
                    //Intercambia arr[i] y arr[i+gap]
                    int temp = arr[i];
                    arr[i] = arr[i + gap];
                    arr[i + gap] = temp;
                    // Se intercambió
                    swapped = true;
                }
            }
        }
    }

    public static void main(String args[]) {
        int arr[] = {8, 4, 1, 56, 3, -44, 23, -6, 28, 0};
        sort(arr);
        System.out.println(&quot;Array ordenado&quot;);
        for (int i = 0; i &lt; arr.length; ++i) {
            System.out.print(arr[i] + &quot; &quot;);
        }
    }
}
</java>
  <cpp>#include &lt;iostream&gt;

using namespace std;

int getNextGap(int gap) {
    gap = (gap * 10) / 13;
    if (gap &lt; 1) {
        return 1;
    }
    return gap;
}

void sorted(int arr[], int n) {
    int gap = n;
    bool swapped = true;
    while (gap != 1 || swapped == true) {
        gap = getNextGap(gap);
        swapped = false;
        for (int i = 0; i &lt; n - gap; i++) {
            if (arr[i] &gt; arr[i + gap]) {
                int temp = arr[i];
                arr[i] = arr[i + gap];
                arr[i + gap] = temp;
                swapped = true;
            }
        }
    }
}

int main() {
    int arr[] = {8, 4, 1, 56, 3, -44, 23, -6, 28, 0, -10};
    int tam = sizeof (arr) / sizeof (arr[0]);
    sorted(arr, tam);
    cout &lt;&lt; &quot;Array ordenado&quot; &lt;&lt; endl;
    for (int i = 0; i &lt; tam; i++) {
        if (i == tam - 1) {
            cout &lt;&lt; arr[i] &lt;&lt; endl;
            break;
        }
        cout &lt;&lt; arr[i] &lt;&lt; &quot; &quot;;
    }
    return 0;
}

</cpp>
  <py>from sys import stdin,stdout
rl = stdin.readline
wr = stdout.write

def getNextGap(gap):
    gap = (gap * 10) // 13
    if gap &lt; 1:
        return 1
    return gap

def combSort(arr, n):

    gap = n
    swapped = True
    
    while gap != 1 or swapped:
        gap = getNextGap(gap)
        swapped = False
        for i in range(n-gap):
            if arr[i] &gt; arr[i+gap]:
                arr[i], arr[i+gap] = arr[i+gap], arr[i]
                swapped = True

arr = list(map(int, rl().split()))
combSort(arr, len(arr))
print(*arr)
</py>
  <orden>3</orden>
  <suborden>10</suborden>
  <fecha_creacion>2020-12-04 20:09:36</fecha_creacion>
  <fecha_modificacion>2020-12-07 02:07:11</fecha_modificacion>
</row>
<row>
  <ID>21</ID>
  <supergrupo>Ordenamientos</supergrupo>
  <tema>Counting Sort</tema>
  <texto>El ordenamiento por conteo es una técnica de ordenamiento basada en claves entre un rango específico. Funciona contando el número de objetos que tienen valores clave distintos (un tipo de hashing). Luego, hacer algo de aritmética para calcular la posición de cada objeto en la secuencia de salida.
&amp;nbsp;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;1. El ordenamiento de conteo es eficiente si el rango de datos de entrada no es significativamente mayor que el número de objetos a clasificar. &amp;nbsp;&lt;/div&gt;&lt;div&gt;2. No es una comparación basada en la clasificación. La complejidad del tiempo de ejecución es O (n) con espacio proporcional al rango de datos.&amp;nbsp;&lt;/div&gt;&lt;div&gt;3. A menudo se usa como una sub-rutina para otro algoritmo de clasificación como la clasificación por radix.&amp;nbsp;&lt;/div&gt;&lt;div&gt;4. EL ordenamiento de conteo usa un hashing parcial para contar la ocurrencia del objeto de datos en O (1).&amp;nbsp;&lt;/div&gt;&lt;div style=&quot;text-align: justify;&quot;&gt;5. El ordenamiento de conteo también se puede extender para que funcione con entradas negativas.
&lt;/div&gt;</texto>
  <complejidad_tiempo>Mejor caso :    O(n+k)            Peor caso :     O(n+k)             Promedio: O(n+k)</complejidad_tiempo>
  <java>// Implementación java de Counting Sort

public class CountingSort {

    static void sort(char arr[]) {
        int n = arr.length;
        // El array de caracteres que sera el array 
        // ordenado de salida
        char output[] = new char[n];
        // Crea un array de conteo para almacenar 
        // conteo individual de caracteres e inicializar
        // array de conteo en 0
        int count[] = new int[256];
        for (int i = 0; i &lt; 256; ++i) {
            count[i] = 0;
        }
        // Almacena el conteo de cada caracter
        for (int i = 0; i &lt; n; ++i) {
            ++count[arr[i]];
        }
        // Cambian count[i] de forma que ahora contenga la 
        //posición actual de este caracter en el array de saliday 
        for (int i = 1; i &lt;= 255; ++i) {
            count[i] += count[i - 1];
        }
        // Construye el array de caracteres de salida
        // Para hacerlo estable lo hacemos en orden inverso
        for (int i = n - 1; i &gt;= 0; i--) {
            output[count[arr[i]] - 1] = arr[i];
            --count[arr[i]];
        }
        //Copia el array de salida a arr, asi arr ahora
        // contiene los caracteres ordenados 
        for (int i = 0; i &lt; n; ++i) {
            arr[i] = output[i];
        }
    }

    public static void main(String args[]) {
        char arr[] = {&#39;g&#39;, &#39;e&#39;, &#39;e&#39;, &#39;k&#39;, &#39;s&#39;, &#39;f&#39;, &#39;o&#39;,
            &#39;r&#39;, &#39;g&#39;, &#39;e&#39;, &#39;e&#39;, &#39;k&#39;, &#39;s&#39;};
        sort(arr);
        System.out.print(&quot;array de caracteres ordenado: &quot;);
        for (int i = 0; i &lt; arr.length; ++i) {
            System.out.print(arr[i]);
        }
    }
}
</java>
  <cpp>#include &lt;iostream&gt;
#include &lt;string.h&gt;

using namespace std;

void sorted(char arr[], int n) {
    char output[n];
    int counting[256];
    memset(counting, 0, sizeof (counting));
    for (int i = 0; i &lt; n; i++) {
        ++counting[arr[i]];
    }
    for (int i = 1; i &lt;= 255; ++i) {
        counting[i] += counting[i - 1];
    }
    for (int i = n - 1; i &gt;= 0; i--) {
        output[counting[arr[i]] - 1] = arr[i];
        --counting[arr[i]];
    }
    for (int i = 0; i &lt; n; ++i) {
        arr[i] = output[i];
    }
}

int main() {
    string entrada = &quot;alkjslkjkdjaskjdkasjddf&quot;;
    char arr[entrada.size()];
    strcpy(arr, entrada.c_str());
    int tam = sizeof (arr) / sizeof (arr[0]);
    sorted(arr, tam);
    cout &lt;&lt; &quot;Array de caracteres ordenado: &quot; &lt;&lt; endl;
    for (int i = 0; i &lt; tam; i++) {
        if (i == tam - 1) {
            cout &lt;&lt; arr[i] &lt;&lt; endl;
            break;
        }
        cout &lt;&lt; arr[i] &lt;&lt; &quot; &quot;;
    }
    return 0;
}
</cpp>
  <py>from sys import stdin, stdout
rl = stdin.readline
wl = stdout.write


def countSort(arr, n):

    output = [&#39;&#39;] * n
    count = [0] * 256

    for i in arr:
        count[ord(i)] += 1

    for i in range(1, 256):
        count[i] += count[i-1]

    for i in range(n-1, -1, -1):
        output[count[ord(arr[i])]-1] = arr[i]
        count[ord(arr[i])] -= 1

    for i in range(n):
        arr[i] = output[i]


arr = list(map(str, rl().split()))
countSort(arr, len(arr))
print(*arr)
</py>
  <orden>3</orden>
  <suborden>11</suborden>
  <fecha_creacion>2020-12-04 20:09:36</fecha_creacion>
  <fecha_modificacion>2020-12-07 02:09:54</fecha_modificacion>
</row>
<row>
  <ID>22</ID>
  <supergrupo>Ordenamientos</supergrupo>
  <tema>Cycle Sort</tema>
  <texto><div style="text-align: justify;"><span style="font-size: 10pt;">El ordenamiento por ciclos es un algoritmo de ordenamiento en el lugar, un ordenamiento de comparación que es teóricamente óptima en términos del número total de escrituras en el array original.&nbsp;
</span></div><div style="text-align: justify;"><span style="font-size: 10pt;"><br></span></div><div style="text-align: justify;"><span style="font-size: 10pt;">Es óptimo en términos de cantidad de escrituras de memoria. Minimiza el número de escrituras de memoria para ordenar (cada valor se escribe cero veces, si ya está en su posición correcta, o se escribe una vez en su posición correcta).</span></div></texto>
  <complejidad_tiempo>Mejor caso :    O(n2)            Peor caso :     O(n2)             Promedio: O(n2)</complejidad_tiempo>
  <java>//Programa java implementando Cycle sort

public class CycleSort {

    public static void cycleSort(int arr[], int n) {   
  //Contador de escrituras en memoria
        int writes = 0;
        //Pasar poe los elementros del array
        //y ponerlos en el lugar correcto 
        for (int cycle_start = 0; cycle_start &lt;= n - 2; cycle_start++) {
            // Inicializa item como punto inicial
            int item = arr[cycle_start];
            // Encuentra posicion donde nosotros pondremos el item
            // Basicamente contamos todos los elementos más pequeños
            //a la derecha del item
            int pos = cycle_start;
            for (int i = cycle_start + 1; i &lt; n; i++) {
                if (arr[i] &lt; item) {
                    pos++;
                }
            }
            //Si item esta ya en la posicion correcta
            if (pos == cycle_start) {
                continue;
            }
            //Ignorar todos los elementos duplicados
            while (item == arr[pos]) {
                pos += 1;
            }
            //Ponemos el item en su posición correcta
            if (pos != cycle_start) {
                int temp = item;
                item = arr[pos];
                arr[pos] = temp;
                writes++;
            }
            //Rota el resto del ciclo
            while (pos != cycle_start) {
                pos = cycle_start;
                // Encuentra posicion donde poner el elemento 
                for (int i = cycle_start + 1; i &lt; n; i++) {
                    if (arr[i] &lt; item) {
                        pos += 1;
                    }
                }
                //Ignora todos los duplicados
                while (item == arr[pos]) {
                    pos += 1;
                }
                // Ponemos el item en su posición correcta
                if (item != arr[pos]) {
                    int temp = item;
                    item = arr[pos];
                    arr[pos] = temp;
                    writes++;
                }
            }
        }
    }

    public static void main(String[] args) {
        int arr[] = {1, 8, 3, 9, 10, 10, 2, 4};
        int n = arr.length;
        cycleSort(arr, n);
        System.out.println(&quot;Luego de ordenar : &quot;);
        for (int i = 0; i &lt; n; i++) {
            System.out.print(arr[i] + &quot; &quot;);
        }
    }
}
</java>
  <cpp>#include &lt;iostream&gt;

using namespace std;

void cycleSort(int arr[], int n) {
    int writes = 0;
    for (int cycle_start = 0; cycle_start &lt;= n - 2; cycle_start++) {
        int item = arr[cycle_start];
        int pos = cycle_start;
        for (int i = cycle_start + 1; i &lt; n; i++) {
            if (arr[i] &lt; item) {
                pos++;
            }
        }
        if (pos == cycle_start) {
            continue;
        }
        while (item == arr[pos]) {
            pos += 1;
        }
        if (pos != cycle_start) {
            int temp = item;
            item = arr[pos];
            arr[pos] = temp;
            writes++;
        }
        while (pos != cycle_start) {
            pos = cycle_start;
            for (int i = cycle_start + 1; i &lt; n; i++) {
                if (arr[i] &lt; item) {
                    pos += 1;
                }
            }
            while (item == arr[pos]) {
                pos += 1;
            }
            if (item != arr[pos]) {
                int temp = item;
                item = arr[pos];
                arr[pos] = temp;
                writes++;
            }
        }
    }
}

int main() {
    ios_base::sync_with_stdio(false);
    cout.tie(NULL);
    int arr[] = {1, 8, 3, 9, 10, -10, -5, -4, -8, -90, 90, 80};
    int n = sizeof (arr) / sizeof (arr[0]);
    cycleSort(arr, n);
    cout &lt;&lt; &quot;Luego de ordenar:&quot; &lt;&lt; endl;
    for (int i = 0; i &lt; n; i++) {
        if (i == n - 1) {
            cout &lt;&lt; arr[i] &lt;&lt; endl;
            break;
        }
        cout &lt;&lt; arr[i] &lt;&lt; &quot; &quot;;
    }
    return 0;
}
</cpp>
  <py>from sys import stdin, stdout
rl = stdin.readline
wr = stdout.write


def cycleSort(arr, n):

    writes = 0
    for cyclestart in range(n-2):
        item = arr[cyclestart]
        pos = cyclestart

        for i in range(cyclestart+1, n):
            if arr[i] &lt; item:
                pos += 1

        if pos == cyclestart:
            continue

        while item == arr[pos]:
            pos += 1

        if pos != cyclestart:
            item, arr[pos] = arr[pos], item
            writes += 1

        while pos != cyclestart:
            pos = cyclestart
            for i in range(cyclestart+1, n):
                if arr[i] &lt; item:
                    pos += 1
            while item == arr[pos]:
                pos += 1
            if item != arr[pos]:
                item, arr[pos] = arr[pos], item
                writes += 1


arr = list(map(int, rl().split()))
cycleSort(arr, len(arr))
print(*arr)
</py>
  <orden>3</orden>
  <suborden>12</suborden>
  <fecha_creacion>2020-12-04 20:09:36</fecha_creacion>
  <fecha_modificacion>2020-12-07 02:10:17</fecha_modificacion>
</row>
<row>
  <ID>23</ID>
  <supergrupo>Ordenamientos</supergrupo>
  <tema>3 Way Merge Sort</tema>
  <texto>Merge sort envuelve separación recursiva del array en dos partes, ordenamiento y finalmente unión de las mismas. Una variante de merge sort es llamado merge sort de tres vías donde en vez de separar el array en dos partes se separa en tres. Merge sort recursivamente rompe los arrays en arrays de tamaño medio, Merge de tres vías hace lo mismo en arrays de tamaño de un tercio.
Complejidad de tiempo: En caso de Merge Sort se tiene la ecuación T(n) = 2T(n/2) + O(n). Igualmente en caso de Merge de tres vías se tiene la ecuación(n) = 3T(n/3) + O(n) por lo que la aproximación más cercana de su complejidad es: O(n log 3n).
</texto>
  <complejidad_tiempo>Mejor caso :    O(nlog3n)            Peor caso :     O(nlog3n)             Promedio: O(nlog3n)</complejidad_tiempo>
  <java>//Programa java que realiza Merge Sort de tres vias

public class MergeSort3Way {

    public static void mergeSort3Way(Integer[] gArray) {   
        //Si el arrat tiene tamaño 0, retorna null
        if (gArray == null) {
            return;
        }
        //Creando duplicado del array dado
        Integer[] fArray = new Integer[gArray.length];
        //Copiando elementos del array dado al
        //array duplicado
        System.arraycopy(gArray, 0, fArray, 0, fArray.length);
        mergeSort3WayRec(fArray, 0, gArray.length, gArray);
        //Copiando elementos del array duplicado al
        //array dado
        System.arraycopy(fArray, 0, gArray, 0, fArray.length);
    }

    /*Realizando el algoritmo Merge Sort en el array
    dado para los valores en el rando de los indices 
    [low,high], low es el menor y high es el mayor
    Exclusivo*/
    public static void mergeSort3WayRec(Integer[] gArray,
            int low, int high, Integer[] destArray) {
        //Si el array tiene tamaño 1 no haga nada
        if (high - low &lt; 2) {
            return;
        }
        // Separando el array en tres partes
        int mid1 = low + ((high - low) / 3);
        int mid2 = low + 2 * ((high - low) / 3) + 1;
        // Ordenando las tres partes recursivamente
        mergeSort3WayRec(destArray, low, mid1, gArray);
        mergeSort3WayRec(destArray, mid1, mid2, gArray);
        mergeSort3WayRec(destArray, mid2, high, gArray);
        // Uniendo las tres partes
        merge(destArray, low, mid1, mid2, high, gArray);
    }

    /*Une los rangos ordenados (low, mid1),(mid1,mid2)
    y (mid2, high), mid 1 es el primer indice punto 
    medio en todo el rando para unir mid2 es segundo*/
    public static void merge(Integer[] gArray, int low,
            int mid1, int mid2, int high,
            Integer[] destArray) {
        int i = low, j = mid1, k = mid2, l = low;
        // escoje el más pequeño de los más pequeños en los
        //tres rangos
        while ((i &lt; mid1) &amp;&amp; (j &lt; mid2) &amp;&amp; (k &lt; high)) {
            if (gArray[i].compareTo(gArray[j]) &lt; 0) {
                if (gArray[i].compareTo(gArray[k]) &lt; 0) {
                    destArray[l++] = gArray[i++];
                } else {
                    destArray[l++] = gArray[k++];
                }
            } else {
                if (gArray[j].compareTo(gArray[k]) &lt; 0) {
                    destArray[l++] = gArray[j++];
                } else {
                    destArray[l++] = gArray[k++];
                }
            }
        }
        while ((i &lt; mid1) &amp;&amp; (j &lt; mid2)) {
            if (gArray[i].compareTo(gArray[j]) &lt; 0) {
                destArray[l++] = gArray[i++];
            } else {
                destArray[l++] = gArray[j++];
            }
        }
        while ((j &lt; mid2) &amp;&amp; (k &lt; high)) {
            if (gArray[j].compareTo(gArray[k]) &lt; 0) {
                destArray[l++] = gArray[j++];
            } else {
                destArray[l++] = gArray[k++];
            }
        }
        while ((i &lt; mid1) &amp;&amp; (k &lt; high)) {
            if (gArray[i].compareTo(gArray[k]) &lt; 0) {
                destArray[l++] = gArray[i++];
            } else {
                destArray[l++] = gArray[k++];
            }
        }
        while (i &lt; mid1) {
            destArray[l++] = gArray[i++];
        }
        while (j &lt; mid2) {
            destArray[l++] = gArray[j++];
        }
        while (k &lt; high) {
            destArray[l++] = gArray[k++];
        }
    }

    public static void main(String args[]) {
        Integer[] data = new Integer[]{45, -2, -45, 78,
            30, -42, 10, 19, 73, 93};
        mergeSort3Way(data);
        System.out.println(&quot;Despues de merge sort de 3 vias: &quot;);
        for (int i = 0; i &lt; data.length; i++) {
            System.out.print(data[i] + &quot; &quot;);
        }
    }
}
</java>
  <cpp>#include&lt;bits/stdc++.h&gt;
#include&lt;cstdlib&gt;
using namespace std;

void mergeArr(int gArray[], int low, int mid1, int mid2, int high, int arrdest[]) {
    int i = low, j = mid1, k = mid2, l = low;
    while ((i &lt; mid1) &amp;&amp; (j &lt; mid2) &amp;&amp; (k &lt; high)) {
        if (gArray[i] &lt; gArray[j]) {
            if (gArray[i] &lt; gArray[k]) {
                arrdest[l++] = gArray[i++];
            } else {
                arrdest[l++] = gArray[k++];
            }
        } else {
            if (gArray[j] &lt; gArray[k]) {
                arrdest[l++] = gArray[j++];
            } else {
                arrdest[l++] = gArray[k++];
            }
        }
    }
    while ((i &lt; mid1) &amp;&amp; (j &lt; mid2)) {
        if (gArray[i] &lt; gArray[j]) {
            arrdest[l++] = gArray[i++];
        } else {
            arrdest[l++] = gArray[j++];
        }
    }
    while ((j &lt; mid2) &amp;&amp; (k &lt; high)) {
        if (gArray[j] &lt; gArray[k]) {
            arrdest[l++] = gArray[j++];
        } else {
            arrdest[l++] = gArray[k++];
        }
    }
    while ((i &lt; mid1) &amp;&amp; (k &lt; high)) {
        if (gArray[i] &lt; gArray[k]) {
            arrdest[l++] = gArray[i++];
        } else {
            arrdest[l++] = gArray[k++];
        }
    }
    while (i &lt; mid1) {
        arrdest[l++] = gArray[i++];
    }
    while (j &lt; mid2) {
        arrdest[l++] = gArray[j++];
    }
    while (k &lt; high) {
        arrdest[l++] = gArray[k++];
    }
}

void mergeSort3wayRec(int arr[], int low, int high, int arrdest[]) {
    if (high - low &lt; 2) {
        return;
    }
    int mid1 = low + ((high - low) / 3);
    int mid2 = low + 2 * ((high - low) / 3) + 1;
    mergeSort3wayRec(arrdest, low, mid1, arr);
    mergeSort3wayRec(arrdest, mid1, mid2, arr);
    mergeSort3wayRec(arrdest, mid2, high, arr);

    mergeArr(arrdest, low, mid1, mid2, high, arr);
}

void mergeSort3way(int arr[], int n) {
    if (n == 0) {
        return;
    }
    int farr[n];
    for (int i = 0; i &lt; n; i++) {
        farr[i] = arr[i];
    }
    mergeSort3wayRec(farr, 0, n, arr);
    for (int i = 0; i &lt; n; i++) {
        arr[i] = farr[i];
    }
}

void printArr(int arr[], int n) {
    for (int i = 0; i &lt; n; i++) {
        cout &lt;&lt; arr[i] &lt;&lt; &quot; &quot;;
    }
    cout &lt;&lt; endl;
}

int main() {
    int arr[] = {1, 3, 54, 255, 2, 5, 3, 1, 5, 7, 4, 299, 3, 54, 64, 73};
    int N = sizeof (arr) / sizeof (arr[0]);
    mergeSort3way(arr, N);
    cout &lt;&lt; &quot;arreglo ordenados&quot; &lt;&lt; endl;
    printArr(arr, N);
} 
</cpp>
  <py>null</py>
  <orden>3</orden>
  <suborden>13</suborden>
  <fecha_creacion>2020-12-04 20:09:36</fecha_creacion>
  <fecha_modificacion>2020-12-06 20:05:51</fecha_modificacion>
</row>
<row>
  <ID>24</ID>
  <supergrupo>Ordenamientos</supergrupo>
  <tema>Pigeon Hole Sort</tema>
  <texto>Ordenamiento nido de Paloma es un algoritmo de ordenamiento que es adecuado para ordenar listas de elementos donde el número de elementos y el número de valores de los mismos son aproximadamente lo mismo.
Este requiere un tiempo de  O(n + Rango) donde n es el número de elementos en el array de entrada y Rango es el número de posibles valores en el array. Este algoritmo es similar a Counting sort, pero difiere en la forma en que mueve los datos, dos veces.
</texto>
  <complejidad_tiempo>Mejor caso :    O(N+n)            Peor caso :     O(N+n)             Promedio: O(N+n)
N=rango 
</complejidad_tiempo>
  <java>/*Programa java que implementa Pigeonhole Sort*/
import java.util.*;

public class PigeonholeSort {

    static void pigeonhole_sort(int arr[],int n) {
        int min = arr[0];
        int max = arr[0];
        int range, i, j, index;
        for (int a = 0; a &lt; n; a++) {
            if (arr[a] &gt; max) {
                max = arr[a];
            }
            if (arr[a] &lt; min) {
                min = arr[a];
            }
        }
        range = max - min + 1;
        int[] phole = new int[range];
        Arrays.fill(phole, 0);
        for (i = 0; i &lt; n; i++) {
            phole[arr[i] - min]++;
        }
        index = 0;
        for (j = 0; j &lt; range; j++) {
            while (phole[j]-- &gt; 0) {
                arr[index++] = j + min;
            }
        }
    }

    public static void main(String[] args) {
        int[] arr = {8, 3, 2, 7, 4, 6, 8};
        System.out.print(&quot;Array ordenado : &quot;);
        pigeonhole_sort(arr, arr.length);
        for (int i = 0; i &lt; arr.length; i++) {
            System.out.print(arr[i] + &quot; &quot;);
        }
    }
}
</java>
  <cpp>#include &lt;iostream&gt;
#include &lt;string.h&gt;
#include &lt;vector&gt;

using namespace std;

void pigeonHoleSort(int arr[], int n) {
    int minim = arr[0];
    int maxim = arr[0];
    int range, i;
    for (int a = 0; a &lt; n; a++) {
        if (arr[a] &gt; maxim) {
            maxim = arr[a];
        }
        if (arr[a] &lt; minim) {
            minim = arr[a];
        }
    }
    range = maxim - minim + 1;

    //Crear un arreglo de vectores de tamamio range.
    //Cada vector representa un agujero que estara
    //para contener los elementos que coincidentes
    vector&lt;int&gt; pHole[range];
    memset(pHole, 0, range);

    //Atravesar el arreglo de entrada y colocar cada elemento
    //en su respectivo agujero
    for (i = 0; i &lt; n; i++) {
        pHole[arr[i] - minim].push_back(arr[i]);
    }

    //Recorrer todos los agujeros uno a uno.
    //Para cada agujero, se toma sus elementos y se
    //colocan en el arreglo dado.
    int index = 0;
    for (i = 0; i &lt; range; i++) {
        for (int k : pHole[i]) {
            arr[index++] = k;
        }
    }
}

int main() {
    ios_base::sync_with_stdio(false);
    cout.tie(NULL);
    int arr[] = {-8, 4, -5, 8, -6, 90, 70, -95, -100, 105, 97, -1000};
    cout &lt;&lt; &quot;Arreglo ordenado:&quot; &lt;&lt; endl;
    int n = sizeof (arr) / sizeof (arr[0]);
    pigeonHoleSort(arr, n);
    for (int i = 0; i &lt; n; i++) {
        if (i == n - 1) {
            cout &lt;&lt; arr[i] &lt;&lt; endl;
            break;
        }
        cout &lt;&lt; arr[i] &lt;&lt; &quot; &quot;;
    }
    return 0;
}
</cpp>
  <py>from sys import stdin
from sys import stdout

in_, out = stdin.readline, stdout.write

def gen(arr): yield from arr

datos_int = lambda: list(map(int, in_().strip().split()))


def pigeonSort(arr, n):
    mn = arr[0]
    mx = arr[0]
    for k in range(n):
        if arr[k] &gt; mx:
            mx = arr[k]
        if arr[k] &lt; mn:
            mn = arr[k]
    range_ = mx - mn + 1
    phole = [0] * range_
    for i in range(n):
        phole[arr[i] - mn] += 1
    index = 0
    for j in range(range_):
        while phole[j]:
            arr[index] = j + mn
            index += 1
            phole[j] -= 1

lista = datos_int()
n = len(lista)
pigeonSort(lista, n)
for i in gen(lista):
    out(f&quot;{i} &quot;)
print()
</py>
  <orden>3</orden>
  <suborden>14</suborden>
  <fecha_creacion>2020-12-04 20:09:36</fecha_creacion>
  <fecha_modificacion>2020-12-07 02:10:52</fecha_modificacion>
</row>
<row>
  <ID>25</ID>
  <supergrupo>Strings</supergrupo>
  <tema>Algoritmo de Knuth-Morris-Pratt </tema>
  <texto><div style="font-weight: normal; text-align: justify;"><span style="font-size: 10pt;">Dado un texto txt[0…n-1] y un patrón pat[0...m-1] busque todas las ocurrencias de pat en txt e imprímalas, asuma que n es mayor que m.&nbsp;</span></div><div style="font-weight: normal; text-align: justify;"><span style="font-size: 10pt;"><br></span></div><div style="font-weight: normal; text-align: justify;">El algoritmo KMP usa la propiedad de degeneración (Usar los subpatrones que se puedan crear a partir del patrón) del patrón y mejora el peor caso de complejidad de O(n). La idea básica detrás de KMP es: Cuando detectemos una no coincidencia (luego de algunas coincidencias), ya sabemos algunos de los caracteres en el texto de la siguiente ventana. Tomamos ventaja de esta información para evadir coincidencias de caracteres que sabemos que de todas maneras coincidirán.&nbsp;</div><div style="font-weight: normal; text-align: justify;"><br></div><div style="text-align: justify;"><span style="font-weight: bold;">Revisión del preprocesado:</span>
KMP preprocesa pat[] y construye un lps[] auxiliar de tamaño m (El mismo tamaño que el patrón) el cual es usado para saltar caracteres mientras se coteja.
El nombre lps indica el prefijo propio más largo el cual es también sufijo. Un prefijo propio es un prefijo  con todo el string no permitido. Por ejemplo, prefijos de “ABC” son “”,”A”,”AB” Y “ABC”, prefijos propios son “”, “A” y “AB”. Sufijos del string son “”, “C”,”BC” y “ABC”.
Buscamos por lps en subpatrones. Más claramente nos enfocamos en los subsring de patrones que son prefijos y sufijos. Por cada subpatron pat[0...i] donde i=0 hasta m-1, lps[i] almacena la longitud del máximo prefijo propio coincidente el cual también es sufijo del subpatron pat[0...i].
Algoritmo de búsqueda:
A diferencia de los algoritmos ingenuos, donde deslizamos el patrón uno por uno y comparamos todos los caracteres en cada movimientos, usamos un valor de lps[] para decidir los nuevos caracteres que serán cotejados, la idea es no cotejar un carácter que sabemos que va a aparecer.&nbsp;</div><div style="text-align: justify;"><span style="font-weight: bold;"><br></span></div><div style="text-align: justify;"><span style="font-weight: bold;">¿Cómo usamos lps [] para decidir las siguientes posiciones o número de caracteres que serán saltadas?&nbsp;</span></div><div style="text-align: justify;"><span style="font-size: 10pt;"><br></span></div><div style="text-align: justify;"><span style="font-size: 10pt;">Comenzamos la comparación de pat [j] con j=0 con los caracteres de la actual ventana de texto. Seguimos cotejando caracteres de txt[i] y pat [j] y seguimos incrementando i y j mientras pat[j] y txt [i] sigan coincidiendo.
Cuando vemos una no coincidencia, sabemos que los caracteres pat[0…j-1] coinciden con txt[i-j…..i-1] (Nótese que j inicia en 0 e incrementa solo cuando hay una coincidencia). También sabemos que lps[j-1] está contando los caracteres de pat[o…j-1] que son prefijo propio y sufijo.
De estos puntos podemos concluir que nosotros no necesitaremos cotejar estos lps[j-1] caracteres con txt porque sabemos que de todas formas esos caracteres coincidirán.</span></div></texto>
  <complejidad_tiempo>Mejor caso :    On)            Peor caso :     O(n+m)             Promedio: O(m+n)</complejidad_tiempo>
  <java>/* Programa java implementando el algoritmo 
de busqueda KMP*/
public class KMPStringMatching {

    static void KMPSearch(String pat, String txt) {
        int M = pat.length();
        int N = txt.length();
        // Crea lps[] el cual podra mantener el
        // más largo prefijo sufijo para patrón
        int lps[] = new int[M];
        int j = 0; // indice de pat[] 
        // Preprocesa el patrón (Calcula lps[]) 
        computeLPSArray(pat, M, lps);
        int i = 0; // indice para txt[] 
        while (i &lt; N) {
            if (pat.charAt(j) == txt.charAt(i)) {
                j++;
                i++;
            }
            if (j == M) {
                System.out.println(&quot;Encontrado patrón &quot;
                        + &quot;en indice &quot; + (i - j));
                j = lps[j - 1];
            } // no coincide luego de j veces
            else if (i &lt; N &amp;&amp; pat.charAt(j) != txt.charAt(i)) {
                /*No coincide lps[0..lps[j-1]] caracteres
                ellos coincidiran de todos modos*/
                if (j != 0) {
                    j = lps[j - 1];
                } else {
                    i = i + 1;
                }
            }
        }
    }

    static void computeLPSArray(String pat, int M, int lps[]) {
        // Longitus del anterior prefijo sufijo más largo
        int len = 0;
        int i = 1;
        lps[0] = 0; // lps[0] es siempre 0
        // el ciclo calcula lps[i] para i = 1 hasta M-1 
        while (i &lt; M) {
            if (pat.charAt(i) == pat.charAt(len)) {
                len++;
                lps[i] = len;
                i++;
            } else // (pat[i] != pat[len])  
            {
                // Esto es dificl, considere el ejemplo
                // AAACAAAA y i = 7. la idea es similar
                // el paso de busqueda
                if (len != 0) {
                    len = lps[len - 1];
                    // Tambien, note que no incrementamos 
                    //i aqui
                } else {
                    // if (len == 0) 
                    lps[i] = len;
                    i++;
                }
            }
        }
    }

    public static void main(String args[]) {
        String txt = &quot;ABABDABACDABABCABAB&quot;;
        String pat = &quot;ABABCABAB&quot;;
        KMPSearch(pat, txt);
    }
}
</java>
  <cpp>#include&lt;bits/stdc++.h&gt;
#include&lt;cstdlib&gt;
using namespace std;

void computeLPSArray(string pat, int M, int lps[]) {
    int len = 0;
    int i = 1;
    lps[0] = 0;
    while (i &lt; M) {
        if (pat[i] == pat[len]) {
            len++;
            lps[i] = len;
            i++;
        } else {
            if (len != 0) {
                len = lps[len - 1];
            } else {
                lps[i] = len;
                i++;
            }
        }
    }
}

void KMPsearch(string pat, string txt) {
    int M = pat.size();
    int N = txt.size();
    int lps[M];
    int j = 0;
    computeLPSArray(pat, M, lps);
    int i = 0;
    while (i &lt; N) {
        if (pat[j] == txt[i]) {
            j++;
            i++;
        }
        if (j == M) {
            cout &lt;&lt; &quot;Patron encontrado en el indice &quot; &lt;&lt; (i - j) &lt;&lt; endl;
            j = lps[j - 1];
        } else if (i &lt; N &amp;&amp; pat[j] != txt[i]) {
            if (j != 0) {
                j = lps[j - 1];
            } else {
                i++;
            }
        }
    }
}

int main() {
    string txt = &quot;lalalalalala&quot;;
    string pat = &quot;lal;
    KMPsearch(pat, txt);
}
</cpp>
  <py>def KMPsearch(pat, txt):
    M = len(pat)
    N = len(txt)
    lps = [None for x in range(M)]
    j = 0
    computeLPSArray(pat, M, lps)
    i = 0
    while i &lt; N:
        if pat[j] == txt[i]:
            i += 1
            j += 1
        if j == M:
            print(&quot;Encontrado patrÃ³n (&quot;, pat, &quot;) en el indice &quot;, (i - j), &quot;-&quot;, ((i - j) + M - 1))
            j = lps[j - 1]
        elif i &lt; N and pat[j] != txt[i]:
            if j != 0:
                j = lps[j-1]
            else:
                i += 1

def computeLPSArray(pat, M, lps):
    leng = 0
    i = 1
    lps[0] = 0
    while i &lt; M:
        if pat[i] == pat[leng]:
            leng += 1
            lps[i] = leng
            i += 1
        else:
            if leng != 0:
                leng = lps[leng-1]
            else:
                lps[i] = leng
                i += 1

def variasBusquedas(arr, txt):
    for i in range(len(arr)):
        KMPsearch(arr[i], txt)

txt = &quot;lalalalalalalalalalala&quot;
arr = [&quot;la&quot;, &quot;lal&quot;, &quot;lala&quot;]
variasBusquedas(arr, txt)
</py>
  <orden>5</orden>
  <suborden>99</suborden>
  <fecha_creacion>2020-12-04 20:09:36</fecha_creacion>
  <fecha_modificacion>2020-12-07 02:13:00</fecha_modificacion>
</row>
<row>
  <ID>26</ID>
  <supergrupo>Strings</supergrupo>
  <tema>Algoritmo de Rabin-Karp </tema>
  <texto><div style="font-weight: normal; text-align: justify;"><span style="font-size: 10pt;">Dado un texto txt[0...n-1] y un patrón pat[0...m-1] busque todas las ocurrencias de pat en txt e imprímalas, asuma que n es mayor que m.&nbsp;</span></div><div style="font-weight: normal; text-align: justify;"><span style="font-size: 10pt;"><br></span></div><div style="font-weight: normal; text-align: justify;"><span style="font-size: 10pt;">Como los algoritmos ingenuos, Rabin-Karp también desliza el patrón uno por uno, pero a diferencia de este, RK coteja el valor hash del patrón con el valor hash del actual substring de texto y su los valores hash coinciden entonces solo empieza a cotejar caracteres individuales, entonces RK necesita calcular los valores hash de los siguientes strings.&nbsp;</span></div><div style="font-weight: normal; text-align: justify;"><span style="font-size: 10pt;"><br></span></div><div style="font-weight: normal; text-align: justify;"><span style="font-size: 10pt;">1) El string patrón&nbsp;</span></div><div style="font-weight: normal; text-align: justify;"><span style="font-size: 10pt;">2) Todos los substrings del texto de tamaño m.&nbsp;</span></div><div style="font-weight: normal; text-align: justify;"><span style="font-size: 10pt;"><br></span></div><div style="font-weight: normal; text-align: justify;"><span style="font-size: 10pt;">Desde que necesitamos calcular eficientemente los valores hash de todos los substrings de tamaño m del texto, debemos tener una función hash la cual tenga la siguiente propiedad.
El hash del siguiente cambio debe ser eficientemente calculable desde el hash actual y el siguiente carácter en el texto o podemos decir hashtxt[s+1….. s+m])= rehash (txt[s+m], hash(txt[s….s+m-1]) y rehash debe ser una operación O(1).&nbsp;</span></div><div style="font-weight: normal; text-align: justify;"><span style="font-size: 10pt;"><br></span></div><div style="font-weight: normal; text-align: justify;"><span style="font-size: 10pt;">La función hash sugerida por Rabin y Karp calcula un valor entero, el valor entero para  un string es un valor número de un string, por ejemplo el número si todos los posibles caracteres son de 1 a 10, el valor número de “122” seria 122. El número de posibles caracteres es mayor que 10 (256 en general) y la longitud el patrón puede ser larga. Entonces los valores numéricos no pueden ser prácticamente almacenados como un entero. Sin embargo el valor número es calculado usando matemática modular para asegurar que los valores hash pueden ser almacenados en una variable entra (puede caber en palabras de memoria).&nbsp;</span></div><div style="font-weight: normal; text-align: justify;"><span style="font-size: 10pt;"><br></span></div><div style="font-weight: normal; text-align: justify;"><span style="font-size: 10pt;">Para hacer rehashing, necesitamos tomar el más significante digito y añadirlo nuestro nuevo digito significante para el valor hash, el rehashing se realiza con la siguiente formula
- hash( txt[s+1 .. s+m] ) = ( d ( hash( txt[s .. s+m-1]) – txt[s]*h ) + txt[s + m] ) mod q
- hash( txt[s .. s+m-1] ) :  Valor hash en cambio s.
- hash( txt[s+1 .. s+m] ) : Valor has en nuevo cambio ( cambio s+1)
- d:Número de caracteres en el alfabeto
- q: Un número primo
- h: d^(m-1)
Esto es matemática simple, calculamos el valor decimal de la actual ventana desde la ventana anterior.
Por ejemplo el tamaño del patrón es 3 y el string es “23456”
Se calcula el valor de la primera ventana el cual es 234 (String ventana es “234”).&nbsp;</span></div><div style="font-weight: normal; text-align: justify;"><span style="font-size: 10pt;"><br></span></div><div style="text-align: justify;"><span style="font-size: 10pt; font-weight: bold;">¿Cómo puedes calcular el valor de la siguiente ventana “345”?&nbsp;</span></div><div style="font-weight: normal; text-align: justify;"><span style="font-size: 10pt;"><br></span></div><div style="font-weight: normal; text-align: justify;"><span style="font-size: 10pt;">se puede hacer (234 – 2*100)*10 + 5 y obtener 345.
El promedio y mejor tiempo de ejecución en un caso de RK es de O(n+m) pero su peor caso es O(nm). El peor caso de Rabin-Karp ocurre cuando todos los caracteres del patrón y el texto tienen los mismos valores hash de todos los substrings de txt, por ejemplo pat[]=”AAA”  y txt[]=”AAAAAAA”.</span></div></texto>
  <complejidad_tiempo>Mejor caso :    O(m+n)            Peor caso :     O(n*m)             Promedio: O(n*m)</complejidad_tiempo>
  <java>/*Implementación java del algoritmo de 
Rabin Karp*/
public class RabinKarp {   
// d es elnúmero de caracteres en el alfabeto de entrada

    public final static int d = 256;

    /* pat -&gt; patrón 
        txt -&gt; texto
        q -&gt; Un número primo
     */
    static void search(String pat, String txt, int q) {
        int M = pat.length();
        int N = txt.length();
        int i, j;
        int p = 0; // valor hash  del patrón
        int t = 0; // valor hash  del txt 
        int h = 1;
        // el valor de h debe ser &quot;pow(d, M-1)%q&quot;
        for (i = 0; i &lt; M - 1; i++) {
            h = (h * d) % q;
        }
        /*Calcula el valor hash del patron y primera 
        ventana de texto*/
        for (i = 0; i &lt; M; i++) {
            p = (d * p + pat.charAt(i)) % q;
            t = (d * t + txt.charAt(i)) % q;
        }
        //Desliza el patrón por encima del texto uno por uno
        for (i = 0; i &lt;= N - M; i++) {
            /*Verifica los valores hash de la actual ventana de text
            y patrón. Si el valor hash coincide entonces solo revisa 
            los caratceres uno por uno*/
            if (p == t) {
                /*Revisa por caracteres uno por uno*/
                for (j = 0; j &lt; M; j++) {
                    if (txt.charAt(i + j) != pat.charAt(j)) {
                        break;
                    }
                }
                // Si p==t y pat[0...M-1] = txt[i, i+1, ...i+M-1] 
                if (j == M) {
                    System.out.println(&quot;Patron encontrado en el indice &quot; + i);
                }
            }
            // Calcula el valor hash de la siguiente ventana de texto
            // Remueve el digito lider, y final
            if (i &lt; N - M) {
                t = (d * (t - txt.charAt(i) * h) + txt.charAt(i + M)) % q;
                /*Nosotros obtendremos un valor negativo de t
                convirtiendolo a positivo*/
                if (t &lt; 0) {
                    t = (t + q);
                }
            }
        }
    }

    public static void main(String[] args) {
        String txt = &quot;EQUIPO ARTEMIS&quot;;
        String pat = &quot;ARTE&quot;;
        int q = 101; // un número primo
        search(pat, txt, q);
    }
}
</java>
  <cpp>using namespace std;
#include&lt;bits/stdc++.h&gt;
#include&lt;cstdlib&gt;
#define FAST ios_base::sync_with_stdio(false);cin.tie(NULL);cout.tie(0);cout&lt;&lt;setprecision(25);
int d = 256;

void rabinKarp(string pat, string txt, int q) {
    int M = pat.size();
    int N = txt.size();
    int i, j; //indices
    int p = 0;
    int t = 0;
    int h = 1; //tamanio del hash
    for (i = 0; i &lt; M - 1; i++) {
        h = (h * d) % q;
    }
    for (i = 0; i &lt; M; i++) {
        p = (d * p + pat[i]) % q;
        t = (d * i + txt[i]) % q;
    }
    for (i = 0; i &lt;= N - M; i++) {
        if (p == t) {
            for (j = 0; j &lt; M; j++) {
                if (txt[i + j] != pat[j]) {
                    break;
                }
            }
            if (j == M) {
                cout &lt;&lt; &quot;Patron encontrado en el indice &quot; &lt;&lt; i &lt;&lt; &quot; &quot; &lt;&lt; (i + M - 1) &lt;&lt; endl;
            }
        }
        if (i &lt; N - M) {
            t = (d * (t - txt[i] * h) + txt[i + M]) % q;
            if (t &lt; 0) {
                t = (t + q);
            }
        }
    }
}

int main() {
    FAST
    string txt = &quot;anita lava la tina&quot;;
    string pat = &quot;la&quot;;
    rabinKarp(pat, txt, d);
}
</cpp>
  <py>from sys import stdin
from sys import stdout
d = 256


def rabinKarp(pat, txt, q):
    M = len(pat)
    N = len(txt)
    i, j, p, t, h = int(0), int(0), int(0), int(0), int(1)
    for i in range(M-1):
        h = (h * d) % q
    for i in range(M):
        p = (d * p + ord(pat[i])) % q
        t = (d * t + ord(txt[i])) % q
    for i in range(N-M + 1):
        if p == t:
            for j in range(M):
                if txt[i + j] != pat[j]:
                    break
            j += 1
            if j == M:
                stdout.write(f&#39;Patron en {str(i)} - {str(i+M-1)}\n&#39;)
        if i &lt; N-M:
            t = (d * (t-ord(txt[i]) * h) + ord(txt[i + M])) % q
            if t &lt; 0:
                t = t + q


txt = &#39;Anita lava la tina&#39;
pat = &#39;la&#39;
rabinKarp(pat, txt, d)

</py>
  <orden>5</orden>
  <suborden>99</suborden>
  <fecha_creacion>2020-12-04 20:09:36</fecha_creacion>
  <fecha_modificacion>2020-12-07 02:14:48</fecha_modificacion>
</row>
<row>
  <ID>27</ID>
  <supergrupo>Strings</supergrupo>
  <tema>Algoritmo de Boyer-Moore </tema>
  <texto><div style="font-weight: normal; text-align: justify;"><span style="font-size: 10pt;">Cuando realizamos una búsqueda de un string en Notepad, Word, buscador o una base de datos, los algoritmos de búsquedas de patrones son usados para buscar los resultados.&nbsp;</span></div><div style="font-weight: normal; text-align: justify;"><span style="font-size: 10pt;"><br></span></div><div style="font-weight: normal; text-align: justify;"><span style="font-size: 10pt;">Un enunciado de este problema podría ser:
Dado un texto txt[0…n-1] y un patrón pat[0...m-1] busque una función que imprima todas las ocurrencias de pat en txt, se asume que n es mayor que m.&nbsp;</span></div><div style="font-weight: normal; text-align: justify;"><span style="font-size: 10pt;"><br></span></div><div style="font-weight: normal; text-align: justify;"><span style="font-size: 10pt;">Como KMP y Boyer Moore también preprocesa el patrón, Boyer Moore es la combinación de las siguientes dos aproximaciones:
1) Heurística de caracteres malos
2) Heurística de buenos sufijos
Ambas de las dos heurísticas de arriba pueden también ser usadas independientemente para buscar un patrón en un texto. Primero entendamos como estas dos aproximaciones trabajan juntos en Boyer Moore. Si tomamos un vistazo a cualquier algoritmo ingenuo, desliza el patrón sobre el texto carácter por carácter. KMP hace preprocesado sobre el patrón de tal forma que el patrón puede ser cambiado más de una vez.&nbsp;</span></div><div style="font-weight: normal; text-align: justify;"><span style="font-size: 10pt;"><br></span></div><div style="font-weight: normal; text-align: justify;"><span style="font-size: 10pt;">El algoritmo de Boyer Moore hace preprocesado por la misma razón. Este procesa el patrón y crea arrays diferentes para cada heurística. En cada paso desliza el patrón por el máximo de deslices sugeridos por las dos heurísticas, entonces usa la mejor de las dos heurísticas en cada paso.
A diferencia de los anteriores algoritmos de búsqueda de patrones, Boyer Moore comienza el cotejamiento desde el último carácter del patrón.&nbsp;</span></div><div style="font-weight: normal; text-align: justify;"><span style="font-size: 10pt;"><br></span></div><div style="text-align: justify;"><span style="font-size: 10pt; font-weight: bold;">Heurística de caracteres malos&nbsp;</span></div><div style="font-weight: normal; text-align: justify;"><span style="font-size: 10pt;">La idea de esta heurística es simple. El carácter del texto que no coincida con el carácter actual del patrón es llamado un carácter malo. Con esta no coincidencia nosotros movemos el patrón hasta:&nbsp;</span></div><div style="font-weight: normal; text-align: justify;"><span style="font-size: 10pt;"><br></span></div><div style="font-weight: normal; text-align: justify;"><span style="font-size: 10pt;"><span style="white-space:pre">	</span>1) La no coincidencia se convierta en un cotejamiento positivo.&nbsp;</span></div><div style="font-weight: normal; text-align: justify;"><span style="font-size: 10pt;"><span style="white-space:pre">	</span>2) Patrón P se mueve después del carácter no coincidente.&nbsp;</span></div><div style="font-weight: normal; text-align: justify;"><span style="font-size: 10pt;"><br></span></div><div style="font-weight: normal; text-align: justify;"><span style="font-size: 10pt;">Caso 1: No coincidencia se convierte en una coincidencia
Buscamos la posición de la última ocurrencia del carácter no coincidente en el patrón y si el carácter no coincidente existe en el patrón, entones movemos el patrón de tal manera que quede alineado con el carácter no coincidente en el texto T.&nbsp;</span></div><div style="font-weight: normal; text-align: justify;"><span style="font-size: 10pt;"><br></span></div><div style="font-weight: normal; text-align: justify;"><span style="font-size: 10pt;">Caso 2: El patrón se mueve pasado el carácter no coincidente
Nosotros buscamos la posición de la última ocurrencia del carácter no coincidente en el patrón y si el carácter no existe deberíamos mover el patrón pasado ese carácter.</span></div></texto>
  <complejidad_tiempo>Mejor caso :    O(n)            Peor caso :     O(3n)             Promedio: O(n)</complejidad_tiempo>
  <java>/*Programa java para heuristica de malos caracteres
usando el algoritmo de Boyer Moore*/

public class BoyerMoore {

    static int NO_OF_CHARS = 256;
    //Una función de utilidad para obtener el maximo de
    //dos enteros
    static int max(int a, int b) {
        return (a &gt; b) ? a : b;
    }
    //El preprocesado del algoritmo
    static void badCharHeuristic(char[] str, int size, int badchar[]) {
        int i;
        // Inicializa todas las ocurrencias en  -1 
        for (i = 0; i &lt; NO_OF_CHARS; i++) {
            badchar[i] = -1;
        }
        /*Llena el actual valor de la ultima ocurrencia
        de un caracter*/
        for (i = 0; i &lt; size; i++) {
            badchar[(int) str[i]] = i;
        }
    }

    /* Una función de busqueda de patrón que usa 
     la heuristica de mal caracter*/
    static void search(char txt[], char pat[]) {
        int m = pat.length;
        int n = txt.length;
        int badchar[] = new int[NO_OF_CHARS];
        /* Llena el arreglo de malos caracteres llamando
        la función de preprocesado para el patrón dado*/
        badCharHeuristic(pat, m, badchar);
        int s = 0;  // s  es cambiado del patron con respecto al texto  
        while (s &lt;= (n - m)) {
            int j = m - 1;
            /* Mantiene reduciento el indice j para el patrón
            mientras los caracteres del patrón y el texto 
            estan coincidiendo en s*/
            while (j &gt;= 0 &amp;&amp; pat[j] == txt[s + j]) {
                j--;
            }
            /*Si el patrón esta presente en el actual
            cambio, entonces el indice j se convertira en -1
            luego del ciclo de arriba*/
            if (j &lt; 0) {
                System.out.println(&quot;Patrón encontrado en cambio = &quot; + s);
                s += (s + m &lt; n) ? m - badchar[txt[s + m]] : 1;
            } else {
                s += max(1, j - badchar[txt[s + j]]);
            }
        }
    }
    public static void main(String[] args) {
        char txt[] = &quot;ABAAABCDABCABC&quot;.toCharArray();
        char pat[] = &quot;ABC&quot;.toCharArray();
        search(txt, pat);
    }
}
</java>
  <cpp>#include&lt;bits/stdc++.h&gt;
#include&lt;cstdlib&gt;
using namespace std;
const int NO_OF_CHARS = 256;

int MAX(int a, int b) {
    return a &gt; b ? a : b;
}

void badCharHeuristic(char str[], int siz, int badchar[]) {
    int i;
    memset(badchar, -1, sizeof badchar);
    for (i = 0; i &lt; siz; i++) {
        badchar[(int) str[i]] = i;
    }
}

void boyerMoore(char txt[], char pat[]) {
    int m = strlen(pat);
    int n = strlen(txt);
    int badchar[NO_OF_CHARS];
    badCharHeuristic(pat, m, badchar);
    int s = 0;
    while (s &lt;= (n - m)) {
        int j = m - 1;
        while (j &lt;= 0 &amp;&amp; pat[j] == txt[s + j]) {
            j--;
        }
        if (j &gt; 0) {
            cout &lt;&lt; &quot;Patron encontrado encontrado en salto &quot; &lt;&lt; s &lt;&lt; endl;
            s += (s + m &lt; m) ? badchar[txt[s + m]] : 1;
        } else {
            s += MAX(1, j - badchar[txt[s + j]]);
        }
    }
}

int main() {
    char txt[] = &quot;lalalalalalalala&quot;;
    char pat[] = &quot;lala&quot;;
    boyerMoore(txt, pat);
}
</cpp>
  <py>
from sys import stdout
wr = stdout.write

NO_OF_CHARS = 256

def badChar(string, size, badchar):
    for i in range(size):
        badchar[ord(string[i])] = i


def BMsearch(txt, pat):

    M = len(pat)
    N = len(txt)
    badchar = [0] * NO_OF_CHARS
    badChar(pat, M, badchar)
    s = 0

    while s &lt;= N-M:
        j = M-1
        while j &gt;= 0 and pat[j] == txt[s+j]:
            j -= 1
        if j &lt; 0:
            wr(f&#39;&quot;{&quot;&quot;.join(txt[s:s+M])}&quot; encontrado en el indice ({s} - {s+M-1})\n&#39;)
            s += M - badchar[ord(txt[s+M])] if s + M &lt; N else 1
        else:
            s += max(1, j - badchar[ord(txt[s+j])])


txt = &#39;anitalavalatina&#39;
pat = &#39;al&#39;
BMsearch(txt, pat)
</py>
  <orden>5</orden>
  <suborden>0</suborden>
  <fecha_creacion>2020-12-04 20:09:36</fecha_creacion>
  <fecha_modificacion>2020-12-07 02:17:36</fecha_modificacion>
</row>
<row>
  <ID>28</ID>
  <supergrupo>Strings</supergrupo>
  <tema>Patrón en anagramas</tema>
  <texto>Dado un texto txt [0...n-1] y un patrón pat [0...m-11], use una función que imprima todas las ocurrencias de pat [] y sus permutaciones (o anagramas) en txt [], se asume que n es menor que m.&amp;nbsp;&lt;div style=&quot;font-weight: normal;&quot;&gt;&lt;br&gt;&lt;/div&gt;&lt;div style=&quot;font-weight: normal;&quot;&gt;La complejidad de tiempo esperada es de O(n).
Este problema es ligeramente diferente a la búsqueda de patrones estándar, aquí necesitamos buscar por anagramas también. Por lo tanto no podemos aplicar directamente la búsqueda de patrones estándar de algoritmos como KMP, Rabin Karp o Boyer Moore.
Podemos conseguir una complejidad de tiempo de O(n) asumiendo que el tamaño del alfabeto está arreglado en los 256 caracteres ASCII.&amp;nbsp;&lt;/div&gt;&lt;div style=&quot;font-weight: normal;&quot;&gt;&lt;br&gt;&lt;/div&gt;&lt;div style=&quot;&quot;&gt;&lt;span style=&quot;font-weight: bold;&quot;&gt;La idea es usar dos arrays de conteo:&amp;nbsp;&lt;/span&gt;&lt;/div&gt;&lt;div style=&quot;font-weight: normal;&quot;&gt;&lt;span style=&quot;white-space:pre&quot;&gt;	&lt;/span&gt;1) El primer array de conteo almacena la frecuencia de los caracteres en el patrón.&amp;nbsp;&lt;/div&gt;&lt;div style=&quot;font-weight: normal;&quot;&gt;&lt;span style=&quot;white-space:pre&quot;&gt;	&lt;/span&gt;2) El Segundo array de conteo almacena la frecuencia en la actual ventana de texto.&amp;nbsp;&lt;/div&gt;&lt;div style=&quot;font-weight: normal;&quot;&gt;&lt;br&gt;&lt;/div&gt;&lt;div style=&quot;font-weight: normal;&quot;&gt;Una cosa importante a tener en cuenta es, la complejidad de tiempo de comparar dos arrays de conteo es O(1) como el número de elementos en ellos.&amp;nbsp;&lt;/div&gt;&lt;div style=&quot;font-weight: normal;&quot;&gt;&lt;br&gt;&lt;/div&gt;&lt;div style=&quot;&quot;&gt;&lt;span style=&quot;font-weight: bold;&quot;&gt;Estos son los pasos de este algoritmo:&amp;nbsp;&lt;/span&gt;&lt;/div&gt;&lt;div style=&quot;font-weight: normal;&quot;&gt;&lt;span style=&quot;white-space:pre&quot;&gt;	&lt;/span&gt;1) Almacena conteos de frecuencia del patrón en el primer array de conteo countP []. También almacena conteo de frecuencias de la primera ventana de texto en el array countTW[].&amp;nbsp;&lt;/div&gt;&lt;div style=&quot;font-weight: normal;&quot;&gt;&lt;span style=&quot;font-size: 10pt;&quot;&gt;&lt;span style=&quot;white-space:pre&quot;&gt;	&lt;/span&gt;2) Ahora ejecuta un ciclo de i=M hasta N-1 haciendo lo siguiente en cada ciclo:&amp;nbsp;&lt;/span&gt;&lt;/div&gt;&lt;div style=&quot;font-weight: normal;&quot;&gt;&lt;span style=&quot;font-size: 10pt;&quot;&gt;&lt;span style=&quot;white-space:pre&quot;&gt;		&lt;/span&gt;a) Si los dos arrays de conteo son idénticos, hemos encontrado una ocurrencia.&amp;nbsp;&lt;/span&gt;&lt;/div&gt;&lt;div style=&quot;font-weight: normal;&quot;&gt;&lt;span style=&quot;font-size: 10pt;&quot;&gt;&lt;span style=&quot;white-space:pre&quot;&gt;		&lt;/span&gt;b) Incrementa el conteo del actual carácter del texto en countTW[]
c) Decrementa conteo del primer carácter en la ventana anterior en countWT[]
3) La última ventana no es revisada por&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; este ciclo, se revisa explícitamente&lt;/span&gt;&lt;/div&gt;</texto>
  <complejidad_tiempo>Mejor caso :    O(n)            Peor caso :     O(n)             Promedio: O(n)</complejidad_tiempo>
  <java>// Programa java que busca todos los anagramás
// de un patrón en un texto 

public class AnagramsPattern {

    static final int MAX = 256;
    // Esta función retorna true si los contenidos
    // de arr1[] y arr2[] son iguales, de otra forma es falso

    static boolean compare(char arr1[], char arr2[]) {
        for (int i = 0; i &lt; MAX; i++) {
            if (arr1[i] != arr2[i]) {
                return false;
            }
        }
        return true;
    }
    // Esta función busca todas las permutaciones de 
    // pat[] en txt[]

    static void search(String pat, String txt) {
        int M = pat.length();
        int N = txt.length();
        // countP[]:  Almacena el conteo de todos
        // los caracteres del patrón
        // countTW[]: Almacena el conteo de los caracteres
        // la ventana de texto
        char[] countP = new char[MAX];
        char[] countTW = new char[MAX];
        for (int i = 0; i &lt; M; i++) {
            (countP[pat.charAt(i)])++;
            (countTW[txt.charAt(i)])++;
        }
        //Atravesar atravez de los caracteres restantes de patrón
        for (int i = M; i &lt; N; i++) {   //Compara conteos de la ventana actual
            // de texto con los conteos de pattern[]
            if (compare(countP, countTW)) {
                System.out.println(&quot;Encontrado en indice &quot;
                        + (i - M));
            }
            // Agreca el actual caracter a la ventana actual
            (countTW[txt.charAt(i)])++;
            // Remueve el primer caracter de la anterior ventana
            countTW[txt.charAt(i - M)]--;
        }
        // Revisa por la ultima ventana en el texto
        if (compare(countP, countTW)) {
            System.out.println(&quot;Encontrado en indice &quot;
                    + (N - M));
        }
    }

    public static void main(String args[]) {
        String txt = &quot;BACDGABCDA&quot;;
        String pat = &quot;ABCD&quot;;
        search(pat, txt);
    }
}
</java>
  <cpp>#include &lt;iostream&gt;
#include &lt;string.h&gt;

using namespace std;

const int MAX = 256;

bool compare(char arr1[], char arr2[]){
    for(int i = 0; i &lt; MAX; i++){
        if(arr1[i] != arr2[i]){
            return false;
        }
    }
    return true;
}

void anagramsSearch(string pat, string txt){
    int M = pat.size();
    int N = txt.size();
    char countP[MAX];
    char countTX[MAX];
    memset(countP,0 , MAX);
    memset(countTX, 0, MAX);
    for(int i = 0; i &lt; M; i++){
        countP[pat[i]]++;
        countTX[txt[i]]++;
    }
    for(int i = M; i &lt; N; i++){
        if(compare(countP, countTX)){
            cout &lt;&lt; &quot;Encontrado en el indice &quot;&lt;&lt;(i - M)&lt;&lt;&quot; Anagrama: &quot;&lt;&lt;txt.substr(i - M, M)&lt;&lt;endl;
        }
        countTX[txt[i]]++;
        countTX[txt[i - M]]--;
    }
    if(compare(countP, countTX)){
        cout&lt;&lt;&quot;Encontrado en el indice &quot;&lt;&lt;(N - M) &lt;&lt;&quot; Anagrama: &quot;&lt;&lt; txt.substr(N - M, N) &lt;&lt; endl;
    }
}

int main()
{
    string txt = &quot;anitalavalatinaanilegustviajarnitatani&quot;;
    string pat = &quot;anita&quot;;
    anagramsSearch(pat, txt);
    return 0;
}
</cpp>
  <py>from sys import stdout
wr = stdout.write

MAX = 256

def anagramsSearch(pat, txt):

    M = len(pat)
    N = len(txt)
    countP = [0] * MAX
    countTW = [0] * MAX

    for i in range(M):
        countP[ord(pat[i])] += 1
        countTW[ord(txt[i])] += 1
    for i in range(M, N):
        if countP == countTW:
            wr(f&#39;&quot;{txt[i-M:i]}&quot; encontrado en el indice ({i-M} - {i-1})\n&#39;)
        countTW[ord(txt[i])] += 1
        countTW[ord(txt[i-M])] -= 1
    if countP == countTW:
        wr(f&#39;&quot;{txt[N-M:N]}&quot; encontrado en el indice ({N-M} - {N-1})\n&#39;)


txt = &#39;BACDGABCDAABDCDBA&#39;
pat = &#39;ABDC&#39;
anagramsSearch(pat, txt)
</py>
  <orden>5</orden>
  <suborden>1</suborden>
  <fecha_creacion>2020-12-04 20:09:36</fecha_creacion>
  <fecha_modificacion>2020-12-07 02:18:52</fecha_modificacion>
</row>
<row>
  <ID>29</ID>
  <supergrupo>Strings</supergrupo>
  <tema>Wildcard</tema>
  <texto>Dado un texto y un patrón de wildcards, se debe implementar un algoritmo que encuentre si el patrón wildcard concuerda con el texto, el cotejamiento debe cubrir todo el texto.&amp;nbsp;&lt;div style=&quot;font-weight: normal;&quot;&gt;&lt;br&gt;&lt;/div&gt;&lt;div style=&quot;font-weight: normal;&quot;&gt;El patrón wildcard puede incluir los caracteres ‘?’ y ‘*’:
‘?’ – Coteja cualquier carácter solitario.
‘*’ – Coteja cualquier secuencia de caracteres (Incluyendo una secuencia vacía).
Cada ocurrencia de ‘?’ en el patrón wildcard puede ser reemplazado con cualquier otro carácter y cada ocurrencia de ‘*’ con una secuencia de caracteres tales que el patrón de wildcard se convierta en idéntico al string de entrada luego del reemplazo.&amp;nbsp;&lt;/div&gt;&lt;div style=&quot;font-weight: normal;&quot;&gt;&lt;br&gt;&lt;/div&gt;&lt;div style=&quot;font-weight: normal;&quot;&gt;Consideremos cualquier carácter en el patrón.&amp;nbsp;&lt;/div&gt;&lt;div style=&quot;font-weight: normal;&quot;&gt;&lt;br&gt;&lt;/div&gt;&lt;div style=&quot;&quot;&gt;&lt;span style=&quot;font-weight: bold;&quot;&gt;Caso 1: El carácter es ‘*’&amp;nbsp;&lt;/span&gt;&lt;/div&gt;&lt;div style=&quot;font-weight: normal;&quot;&gt;&lt;br&gt;&lt;/div&gt;&lt;div style=&quot;font-weight: normal;&quot;&gt;Aquí dos cosas pueden pasar:
- Podemos ignorar el carácter ‘*’ y movernos al siguiente carácter del patrón.
- El carácter ‘*’ coincide con uno o más caracteres en el texto, aquí podemos movernos al carácter siguiente en el string.&amp;nbsp;&lt;/div&gt;&lt;div style=&quot;font-weight: normal;&quot;&gt;&lt;br&gt;&lt;/div&gt;&lt;div style=&quot;&quot;&gt;&lt;span style=&quot;font-weight: bold;&quot;&gt;Caso 2: El carácter es ‘?’:&amp;nbsp;&lt;/span&gt;&lt;/div&gt;&lt;div style=&quot;font-weight: normal;&quot;&gt;&lt;br&gt;&lt;/div&gt;&lt;div style=&quot;font-weight: normal;&quot;&gt;Podemos ignorar el actual carácter en el texto y movernos al siguiente carácter en el patrón y texto.&amp;nbsp;&lt;/div&gt;&lt;div style=&quot;font-weight: normal;&quot;&gt;&lt;br&gt;&lt;/div&gt;&lt;div style=&quot;&quot;&gt;&lt;span style=&quot;font-weight: bold;&quot;&gt;Caso 3: El carácter no es un carácter wildcard&amp;nbsp;&lt;/span&gt;&lt;/div&gt;&lt;div style=&quot;font-weight: normal;&quot;&gt;&lt;br&gt;&lt;/div&gt;&lt;div style=&quot;font-weight: normal;&quot;&gt;Si el carácter actual en el texto coincide con el actual carácter en el patrón, podemos movernos al siguiente carácter en el patrón y el texto, si no concuerdan, el patrón wildcard y el texto.&lt;/div&gt;</texto>
  <complejidad_tiempo>Mejor caso :    O(n*m)            Peor caso :     O(n*m)             Promedio: O(n*m)</complejidad_tiempo>
  <java>//Programa java que implementa el cotejamiento
// de patrones con Wildcard

import java.util.Arrays;

public class WildcardPattern {
    //Función que coteja str con el patron wildcard

    static boolean strmatch(String str, String pattern,
            int n, int m) {
        // Patron vacio colo puede coincidir 
        // con string vacio
        if (m == 0) {
            return (n == 0);
        }
        // Tabla de busqueda para almacenar resultados
        // de subproblemás
        boolean[][] lookup = new boolean[n + 1][m + 1];
        //Inicializa la tabla en falso
        for (int i = 0; i &lt; n + 1; i++) {
            Arrays.fill(lookup[i], false);
        }
        lookup[0][0] = true;
        //Solo &#39;*&#39; puede coincidri con string vacio
        for (int j = 1; j &lt;= m; j++) {
            if (pattern.charAt(j - 1) == &#39;*&#39;) {
                lookup[0][j] = lookup[0][j - 1];
            }
        }
        // Llena la tabla 
        for (int i = 1; i &lt;= n; i++) {
            for (int j = 1; j &lt;= m; j++) {
                /*Dos casos que podemos ver de &#39;*&#39;
                a) Ignoramos &#39;*&#39; y pasamos al siguiente
                caracter en el patrón
                b) &#39;*&#39; coincide con un iesimo
                caracter en una entrada*/

                if (pattern.charAt(j - 1) == &#39;*&#39;) {
                    lookup[i][j] = lookup[i][j - 1]
                            || lookup[i - 1][j];
                } /*Actuales caracteres son considerados 
                como coincidentes en dos casos
                a) actual caracter de patron es &#39;?&#39;
                b) caracteres actuales coinciden*/ 
                else if (pattern.charAt(j - 1) == &#39;?&#39;
                        || str.charAt(i - 1) == pattern.charAt(j - 1)) {
                    lookup[i][j] = lookup[i - 1][j - 1];
                } // Si el caracter no coincide
                else {
                    lookup[i][j] = false;
                }
            }
        }
        return lookup[n][m];
    }

    public static void main(String args[]) {
        String str = &quot;baaabab&quot;;
        String pattern = &quot;*****ba*****ab&quot;;
        //Casos de prueba 
        // String pattern = &quot;ba*****ab&quot;;
        // String pattern = &quot;ba*ab&quot;;
        // String pattern = &quot;a*ab&quot;;
        // String pattern = &quot;a*****ab&quot;;
        // String pattern = &quot;*a*****ab&quot;;
        // String pattern = &quot;ba*ab****&quot;;
        // String pattern = &quot;****&quot;;
        // String pattern = &quot;*&quot;;
        // String pattern = &quot;aa?ab&quot;;
        // String pattern = &quot;b*b&quot;;
        // String pattern = &quot;a*a&quot;;
        // String pattern = &quot;baaabab&quot;;
        // String pattern = &quot;?baaabab&quot;;
        // String pattern = &quot;*baaaba*&quot;; 

        if (strmatch(str, pattern, str.length(),
                pattern.length())) {
            System.out.println(&quot;Si&quot;);
        } else {
            System.out.println(&quot;No&quot;);
        }
    }
}
</java>
  <cpp>using namespace std;
#include&lt;bits/stdc++.h&gt;
#include&lt;cstdlib&gt;
#define FAST ios_base::sync_with_stdio(false);cin.tie(NULL);cout.tie(0);
#define Afill(x,y) memset(x,y,sizeof x)
bool strMatch(string str,string pat,int n,int m){
    if(m==0){
        return n==0;
    }
    bool lookup[n+1][m+1];
    for(int i=0;i&lt;n+1;i++){
        Afill(lookup[i],false);
    }
    lookup[0][0]=true;
    for(int j=1;j&lt;=m;j++){
        if(pat[j-1]==&#39;*&#39;){
            lookup[0][j]=lookup[0][j-1];
        }
    }
    for(int i=1;i&lt;=n;i++){
        for(int j=1;j&lt;=m;j++){
            if(pat[j-1]==&#39;*&#39;){
                lookup[i][j]=lookup[i][j-1]||lookup[i-1][j];
            }else if(pat[j-1]==&#39;?&#39; || str[i-1]==pat[j-1]){
                lookup[i][j]=lookup[i-1][j-1];
            }else{
                lookup[i][j]=false;
            }
        }
    }
    return lookup[n][m];
}
int main() {
    FAST
    string str=&quot;baaaaababa&quot;;
    string pat=&quot;ba*******?&quot;;
    if(strMatch(str,pat,str.size(),pat.size())){
        cout&lt;&lt;&quot;Si&quot;&lt;&lt;endl;
    }else{
        cout&lt;&lt;&quot;No&quot;&lt;&lt;endl;
    }
}
</cpp>
  <py>from sys import stdin, stdout
rl = stdin.readline
wr = stdout.write


def wildCardStrMatch(strn, pat, n, m):

    if m == 0:
        return n == 0

    lookup = [[False for x in range(m+1)] for x in range(n+1)]
    lookup[0][0] = True

    for i in range(1, m+1):
        if pat[i-1] == &#39;*&#39;:
            lookup[0][i] = lookup[0][i-1]

    for i in range(1, n+1):
        for j in range(1, m+1):
            if pat[j-1] == &#39;*&#39;:
                lookup[i][j] = lookup[i][j-1] or lookup[i-1][j]
            elif pat[j-1] == &#39;?&#39; or strn[i-1] == pat[j-1]:
                lookup[i][j] = lookup[i-1][j-1]
            else:
                lookup[i][j] = False

    return lookup[n][m]


txt = &#39;anitalavalatina&#39;
pat = &#39;?nit?lava*&#39;

if wildCardStrMatch(txt, pat, len(txt), len(pat)):
    wr(&#39;Iguales\n&#39;)
else:
    wr(&#39;Diferentes\n&#39;)
</py>
  <orden>5</orden>
  <suborden>2</suborden>
  <fecha_creacion>2020-12-04 20:09:36</fecha_creacion>
  <fecha_modificacion>2020-12-07 02:19:43</fecha_modificacion>
</row>
<row>
  <ID>30</ID>
  <supergrupo>Strings</supergrupo>
  <tema>Algoritmo de Manacher</tema>
  <texto><div style="text-align: justify;"><span style="font-size: 10pt;">Dado un string, encuentre el substring más largo que sea palíndromo.&nbsp;</span></div><div style="text-align: justify;">Si el string dado es “abaaba” la salida deberá ser “abaaba”&nbsp;</div><div style="text-align: justify;"><br></div><div style="text-align: justify;">Vamos a considerar el string “abababa”.
Aquí el centro del string es el 4to carácter con índice 3, si cotejamos más caracteres en la izquierda y derecha del centro todos los caracteres coinciden y el string es palíndromo.
Considere el string “abaaba” de tamaño par. Este string es palíndromo alrededor de la posición entre el 3er y 4to carácter.&nbsp;</div><div style="text-align: justify;"><br></div><div style="text-align: justify;">Para encontrar el substring más largo palíndromo de un string de tamaño N, una vía es tomar cada posible 2*N+1 centros (las N posiciones de caracteres, N-1 entre dos caracteres y dos posiciones en los fines de derecha e izquierda), haga que el carácter coincida en ambas direcciones en cada 2*N+1 centros y siga rastreando por LPS (Longest palindromic string).&nbsp;</div><div style="text-align: justify;"><br></div><div style="text-align: justify;">Si el string dado es “abababa” la salida debe ser “abababa”&nbsp;</div><div style="text-align: justify;"><span style="font-size: 10pt;"><br></span></div><div style="text-align: justify;"><span style="font-size: 10pt;">Si el string dado es “abcbabcbabcba” la salida debe ser “abcbabcba”</span></div></texto>
  <complejidad_tiempo>Mejor caso :    O(n)            Peor caso :     O(n)             Promedio: O(n)</complejidad_tiempo>
  <java>// Programa java implementando el algoritmo de Manacher
// LPS: longest palindrome string

public class ManacherAlgorithm {

    static char text[];

    public static void main(String[] args) {
        text = &quot;babcbabcbaccba&quot;.toCharArray();
        findLongestPalindromicString();
        text = &quot;abaaba&quot;.toCharArray();
        findLongestPalindromicString();
        text = &quot;abababa&quot;.toCharArray();
        findLongestPalindromicString();
        text = &quot;abcbabcbabcba&quot;.toCharArray();
        findLongestPalindromicString();
        text = &quot;caba&quot;.toCharArray();
        findLongestPalindromicString();
        text = &quot;abacdfgdcaba&quot;.toCharArray();
        findLongestPalindromicString();
        text = &quot;abacdfgdcabba&quot;.toCharArray();
        findLongestPalindromicString();
        text = &quot;abacdedcaba&quot;.toCharArray();
        findLongestPalindromicString();
    }

    static int min(int a, int b) {
        int res = a;
        if (b &lt; a) {
            res = b;
        }
        return res;
    }

    static void findLongestPalindromicString() {
        int N = text.length;
        if (N == 0) {
            return;
        }
        N = 2 * N + 1; //Conteo de posición
        int L[] = new int[N]; //LPS tamaño de array
        L[0] = 0;
        L[1] = 1;
        int C = 1; //Posición central
        int R = 2; //posición Centro derecho
        int i = 0; //Posición actual derecho
        int iMirror; //Posición actual izquierda
        int maxLPSLength = 0;
        int maxLPSCenterPosition = 0;
        int start = -1;
        int end = -1;
        int diff = -1;
        //Descomentar para imprimir tamaño del arreglo LPS
        //printf(&quot;%d %d &quot;, L[0], L[1]); 
        for (i = 2; i &lt; N; i++) {
            iMirror = 2 * C - i;
            L[i] = 0;
            diff = R - i;
            if (diff &gt; 0) {
                L[i] = min(L[iMirror], diff);
            }
            /*Intente expandir palíndromo centrado en currentRightPosition i
            Aquí para posiciones impares, comparamos caracteres y
            si coinciden, aumente la longitud de LPS en UNO
            Si la posición es igual, solo incrementamos LPS en UNO sin*/
            try {
                while (((i + L[i]) &lt; N &amp;&amp; (i - L[i]) &gt; 0)
                        &amp;&amp; (((i + L[i] + 1) % 2 == 0)
                        || (text[(i + L[i] + 1) / 2] == text[(i - L[i] - 1) / 2]))) {
                    L[i]++;
                }
            } catch (Exception e) {
            }
            //Comparación de cualquier caracter
            if (L[i] &gt; maxLPSLength) {
                maxLPSLength = L[i];
                maxLPSCenterPosition = i;
            }
            if (i + L[i] &gt; R) {
                C = i;
                R = i + L[i];
            }
            //Descomentar para imprimir tamaño del arreglo LPS
            //printf(&quot;%d &quot;, L[i]); 
        }
        start = (maxLPSCenterPosition - maxLPSLength) / 2;
        end = start + maxLPSLength - 1;
        System.out.println(&quot;LPS del string es &quot; + String.copyValueOf(text) + &quot;: &quot;);
        for (i = start; i &lt;= end; i++) {
            System.out.printf(&quot;%c&quot;, text[i]);
        }
        System.out.println(&quot;&quot;);
    }
}
</java>
  <cpp>using namespace std;
#include&lt;bits/stdc++.h&gt;
#include&lt;cstdlib&gt;
#define FAST ios_base::sync_with_stdio(false);cin.tie(NULL);
#define string_valueof(x) puts(x);

void findLPS(char text[], int N) {
    if (N == 0) {
        return;
    } 
    N = 2 * N + 1;
    int L[N];
    L[0] = 0;
    L[1] = 1;
    int C = 1;
    int R = 2;
    int i_mirror;
    int max_LPS_len = 0;
    int max_LPS_centerPos = 0;
    int start = -1, endLPS = -1, diff = -1;
    for (int i = 2; i &lt; N; i++) {
        i_mirror = 2 * C - i;
        L[i] = 0;
        diff = R - i;
        if (diff &gt; 0) {
            L[i] = std::min(L[i_mirror], diff);
        }
        try {
            while (((i + L[i]) &lt; N and (i - L[i]) &gt; 0) and (((i + L[i] + 1) % 2 == 0) || text[(i + L[i] + 1) / 2] == text[(i - L[i] - 1) / 2])) {
                L[i]++;
            }
        } catch (exception&amp; e) {
        }
        if (L[i] &gt; max_LPS_len) {
            max_LPS_len = L[i];
            max_LPS_centerPos = i;
        }
        if (i + L[i] &gt; R) {
            C = i;
            R = i + L[i];
        }
    }
    start = (max_LPS_centerPos - max_LPS_len) / 2;
    endLPS = start + max_LPS_len - 1;
    cout &lt;&lt; &quot;LPS del string es &quot;;
    string_valueof(text);
    cout &lt;&lt; &quot; : &quot;;
    for (int j = start; j &lt;= endLPS; j++) {
        cout &lt;&lt; text[j];
    }
    cout &lt;&lt; endl;
    /*
    cout&lt;&lt;&quot;inicio : &quot;&lt;&lt;start&lt;&lt;&quot;    -    final : &quot;&lt;&lt;endLPS&lt;&lt;endl;
    for(int j=0;j&lt;N;j++){
        cout&lt;&lt;L[j]&lt;&lt;&quot; &quot;;
    }
     */
}

int main() {
    FAST;
    char text[1000];
    gets(text);
    int N = strlen(text);
    findLPS(text, N);
}
</cpp>
  <py>from sys import stdin, stdout
rl = stdin.readline
wr = stdout.write


def findLPS():

    N = len(text)
    if N == 0:
        return

    N = 2 * N + 1
    L = [0] * N
    L[0] = 0
    L[1] = 1
    C, R = 1, 2
    iMirror = maxLPSlen = maxLPScenterPos = 0
    start = end = diff = -1

    for i in range(2, N):
        iMirror = 2 * C - i
        L[i] = 0
        diff = R - i
        if diff &gt; 0:
            L[i] = min(L[iMirror], diff)
        try:
            while ((i + L[i]) &lt; N and (i - L[i]) &gt; 0) and (((i + L[i] + 1) % 2 == 0) or (text[(i + L[i] + 1) // 2] == text[(i - L[i] - 1) // 2])):
                L[i] += 1
        except:
            pass

        if L[i] &gt; maxLPSlen:
            maxLPSlen = L[i]
            maxLPScenterPos = i

        if i + L[i] &gt; R:
            C = i
            R = i + L[i]

    start = (maxLPScenterPos - maxLPSlen) // 2
    end = start + maxLPSlen - 1

    wr(f&#39;LPS del string {&quot;&quot;.join(text)}:\n&#39;)
    for i in range(start, end+1):
        wr(f&#39;{text[i]}&#39;)
    wr(&#39;\n&#39;)


text = [x for x in &#39;OABAABAOBO&#39;]
findLPS()
</py>
  <orden>5</orden>
  <suborden>3</suborden>
  <fecha_creacion>2020-12-04 20:09:36</fecha_creacion>
  <fecha_modificacion>2020-12-07 02:20:21</fecha_modificacion>
</row>
<row>
  <ID>31</ID>
  <supergrupo>Strings</supergrupo>
  <tema>Algoritmo de Aho-Corasick </tema>
  <texto><div style="font-size: 13.3333px; text-align: justify;"><span style="font-size: 10pt;">Dada una entrada de texto y un array de k palabras, arr[], encontrar todas las ocurrencias de todas las palabras en el texto de entrada.&nbsp;</span></div><div style="font-size: 13.3333px; text-align: justify;"><span style="font-size: 10pt;"><br></span></div><div style="font-size: 13.3333px; text-align: justify;"><span style="font-size: 10pt;">Sea n la longitud del texto y m sea el número total de caracteres en todas las palabras, por ejemplo: m = length (arr [0]) + length (arr [1]) +… + length (arr [k-1]).&nbsp;</span></div><div style="font-size: 13.3333px; text-align: justify;"><span style="font-size: 10pt;"><br></span></div><div style="font-size: 13.3333px; text-align: justify;"><span style="font-size: 10pt;">Si usamos un algoritmo de tiempo linear como KMP, entonces necesitaremos una búsqueda uno por uno de todas las palabras en text[]. Esto nos da un total de complejidad de tiempo de O(n + length(word[0]) + O(n + length(word[1]) + O(n + length(word[2]) + … O(n + length(word[k-1]). Esta complejidad de tiempo puede ser escrita como O(n*k + m). Aho-corasick encuentra todas las palabras en tiempo O(n+m+z) donde z es el número total de ocurrencias de las palabras en el texto, este algoritmo forma las bases del comando original de Unix fgrep.&nbsp;</span></div><div style="font-size: 13.3333px; text-align: justify;"><span style="font-size: 10pt;"><br></span></div><div style="font-size: 13.3333px; text-align: justify;"><span style="font-size: 10pt; font-weight: bold;">Este algoritmo tiene dos pasos principales:&nbsp;</span></div><div style="font-size: 13.3333px; text-align: justify;"><span style="font-size: 10pt;"><span style="white-space: pre;">	</span>- Preprocesado: Construye un automaton de todas las palabras en arr[].&nbsp;</span></div><div style="font-size: 13.3333px; text-align: justify;"><span style="font-size: 10pt;"><span style="white-space: pre;">	</span>- Cotejamiento: Atraviesa el texto dado sobre el automaton formado para encontrar las palabras a cotejar.&nbsp;</span></div><div style="font-size: 13.3333px; text-align: justify;"><span style="font-size: 10pt;"><br></span></div><div style="font-size: 13.3333px; text-align: justify;"><span style="font-size: 10pt;">Por un estado s, los índices de todas las palabras terminados en s son almacenadas. Estos índices son almacenados en un map de BitWise (Haciendo OR a lo valores. Esto también computa usando búsqueda primera en anchura con fallo. Construimos un autómata para este conjunto de cadenas. Ahora procesaremos el texto letra por letra, haciendo la transición durante los diferentes estados. Inicialmente estamos en la raíz del trie. Si estamos en cualquier momento en el estado v, y la siguiente letra es c, entonces hacemos la transición al siguiente estado con go (v, c), aumentando así la longitud de la subcadena de coincidencia actual en 1, o disminuyéndola siguiendo Un enlace de sufijo.</span></div><div style="font-size: 13.3333px; text-align: justify;"><span style="font-size: 10pt; font-weight: bold;"><br></span></div><div style="font-size: 13.3333px; text-align: justify;"><span style="font-size: 10pt; font-weight: bold;">¿Cómo podemos encontrar un estado v, si hay coincidencias con cadenas para el conjunto?&nbsp;</span></div><div style="font-size: 13.3333px; text-align: justify;"><span style="font-size: 10pt;"><br></span></div><div style="font-size: 13.3333px; text-align: justify;"><span style="font-size: 10pt;">Primero, está claro que si nos paramos en un vértice de la hoja, entonces la cadena correspondiente al vértice termina en esta posición en el texto. Sin embargo, este no es el único caso posible de lograr una coincidencia: si podemos alcanzar uno o más vértices de hojas moviéndonos a lo largo de los enlaces de sufijo, entonces también habrá una coincidencia correspondiente a cada vértice de hoja encontrado.&nbsp;</span></div><div style="font-size: 13.3333px; text-align: justify;"><span style="font-size: 10pt;"><br></span></div><div style="font-size: 13.3333px; text-align: justify;"><span style="font-size: 10pt;">Un ejemplo simple que demuestra esta situación puede ser crear usando el conjunto de cadenas {dabce, abc, bc} y el texto dabc. Por lo tanto, si almacenamos en cada vértice de la hoja el índice de la cadena correspondiente (o la lista de índices si aparecen cadenas duplicadas en el conjunto), entonces podemos encontrar en O (n) tiempo los índices de todas las cadenas que coinciden con la actual estado, simplemente siguiendo los enlaces de sufijo desde el vértice actual hasta la raíz. Sin embargo, esta no es la solución más eficiente, ya que nos da una complejidad O (n len) en total. Sin embargo, esto se puede optimizar calculando y almacenando el vértice de la hoja más cercano al que se puede acceder mediante enlaces de sufijo (esto a veces se denomina enlace de salida). Este valor lo podemos calcular perezosamente en tiempo lineal. Por lo tanto, para cada vértice podemos avanzar en tiempo O (1) al siguiente vértice marcado en la ruta de enlace del sufijo, es decir, a la siguiente coincidencia. Por lo tanto, para cada partido pasamos O (1) tiempo, y por lo tanto alcanzamos la complejidad O (len + ans). Si solo desea contar las ocurrencias y no encontrar los índices, puede calcular el número de vértices marcados en la ruta de enlace del sufijo para cada vértice v.&nbsp;</span></div><div style="font-size: 13.3333px; text-align: justify;"><span style="font-size: 10pt;"><br></span></div><div style="font-size: 13.3333px; text-align: justify;"><span style="font-size: 10pt;"><br></span></div><div style="font-size: 13.3333px; text-align: justify;"><span style="font-size: 10pt;">Esto se puede calcular en O (n) en total. Por lo tanto, podemos resumir todas las coincidencias en O (len).&nbsp;</span></div><div style="font-size: 13.3333px; text-align: justify;"><span style="font-size: 10pt;"><br></span></div><div style="font-size: 13.3333px; text-align: justify;"><span style="font-size: 10pt; font-weight: bold;">Utilidades de este algoritmo:&nbsp;</span></div><div style="font-size: 13.3333px; text-align: justify;"><span style="font-size: 10pt;">1) Encontrar la cadena lexicográfica más pequeña de una longitud dada que no coincide con ninguna cadena dada Se da un conjunto de cuerdas y una longitud L. Tenemos que encontrar una cadena de longitud L, que no contiene ninguna de las cadenas, y derivar la cadena lexicográfica más pequeña de tales cadenas. Podemos construir el autómata para el conjunto de cadenas. Recordemos que los vértices desde los cuales podemos alcanzar el vértice de una hoja son los estados, en los cuales tenemos una coincidencia con una cadena del conjunto. Como en esta tarea debemos evitar las coincidencias, no se nos permite ingresar a dichos estados. Por otro lado, podemos ingresar todos los demás vértices. Por lo tanto, eliminamos todos los vértices "malos" de la máquina, y en el gráfico restante del autómata encontramos la ruta lexicográfica más pequeña de longitud L. Esta tarea se puede resolver en O (L), por ejemplo, mediante la búsqueda en profundidad. &nbsp;</span></div><div style="font-size: 13.3333px; text-align: justify;"><span style="font-size: 10pt;"><br></span></div><div style="font-size: 13.3333px; text-align: justify;"><span style="font-size: 10pt;">2) Encontrar la cadena más corta que contiene todas las cadenas dadas Aquí usamos las mismas ideas. Para cada vértice almacenamos una máscara que denota las cadenas que coinciden en este estado. Entonces el problema puede reformularse de la siguiente manera: inicialmente estando en el estado (v = raíz, máscara = 0), queremos llegar al estado (v, máscara = 2n - 1), donde n es el número de cadenas en el conjunto . Cuando hacemos la transición de un estado a otro usando una letra, actualizamos la máscara en consecuencia. Al ejecutar una búsqueda de respiración primero podemos encontrar una ruta al estado (v, máscara = 2n - 1) con la longitud más pequeña. 3) Encontrar la cadena lexicográfica más pequeña de longitud L que contiene k cadenas Como en el problema anterior, calculamos para cada vértice el número de coincidencias que le corresponden (es decir, el número de vértices marcados a los que se puede acceder mediante enlaces de sufijo). Reformulamos el problema: el estado actual está determinado por un triple de números (v, len, cnt), y queremos llegar desde el estado (raíz, 0, 0) al estado (v, L, k), donde v puede ser cualquier vértice Por lo tanto, podemos encontrar dicha ruta utilizando la búsqueda en profundidad primero (y si la búsqueda mira los bordes en su orden natural, entonces la ruta encontrada será automáticamente la más pequeña lexicográfica).</span></div></texto>
  <complejidad_tiempo>Mejor caso :    O(n + m + ocurrencias) Peor caso : O(n + m + ocurrencias)   
 Promedio: O(n + m + ocurrencias)         
</complejidad_tiempo>
  <java>import java.util.Arrays;
import java.util.LinkedList;
import java.util.Queue;

//Programa JAVA implementando Aho Corasick
//para matching de strings
public class Main {

    //Maximo numero de estados en la maquina de cotejamiento
    //debe ser igual a la suma del tamaño de todas las palablas clave
    static final int MAXS = 500;
    //numero maximo de caracteres en el alfabeto de entrada
    static final int MAXC = 26;
    //La funcion Output esta implementada usando out[]
    // bit i de esta mascara es uno si la palabra en el 
    // indice i aparece cuando la maquina entra en este estado
    static int out[] = new int[MAXS];
    //función de fallo 
    static int f[] = new int[MAXS];
    //implementación de las tries
    static int g[][] = new int[MAXS][MAXC];

    // Construye la maquina de cotejado
    /* &quot;out[state] &amp; (1 &lt;&lt; i)&quot; es &gt; 0 si encontramos la
    palabra de word[i] en el texto
    arr-&gt; vector de palabras, el incide de cada palabla clave
    es importante */
    // retorna el numero de estados que la maquina tiene construidos
    // los estados estan numerados desde 0 hasta el valor de retorno - 1
    static int buildMatchingMachine(String arr[], int k) {
        //Inicializar todos los valores de out en 0. 
        Arrays.fill(out, 0);
        // Inicializar todos los valores de g en -1.
        for (int i = 0; i &lt; MAXS; i++) {
            Arrays.fill(g[i], -1);
        }
        // Inicialmente tenemos 0 estados 
        int states = 1;
        //Esto es lo mismo que construir un Trie para arr[] 
        for (int i = 0; i &lt; k; ++i) {
            String word = arr[i];
            int currentState = 0;
            // Insertar todos los caracteres de la palabra actual
            // en arr[]
            for (int j = 0; j &lt; word.length(); ++j) {
                int ch = word.charAt(j) - &#39;a&#39;;
                // crea un nuevo nodo (estado) si un nodo
                // para ch no existe
                if (g[currentState][ch] == -1) {
                    g[currentState][ch] = states++;
                }
                currentState = g[currentState][ch];
            }
            // agrega la palabra actual a la función de salida
            out[currentState] |= (1 &lt;&lt; i);
        }
        // para todos los caracteres que no tengan un camino desde
        // la raiz (El estado 0) en el trie, agregar un camino
        // hacia el estado 0 mismo
        for (int ch = 0; ch &lt; MAXC; ++ch) {
            if (g[0][ch] == -1) {
                g[0][ch] = 0;
            }
        }
        //Inicializamos los valores en la funcion de fallo
        Arrays.fill(f, -1);
        // Se usa BFS y una cola para calcular los fallos
        Queue&lt;Integer&gt; q = new LinkedList&lt;&gt;();
        // Se itera por lo que se encuentre
        for (int ch = 0; ch &lt; MAXC; ++ch) {
            // Todos los nodos de profundidad 1 tienen una funcion de fallo
            // como 0.
            if (g[0][ch] != 0) {
                f[g[0][ch]] = 0;
                q.offer((g[0][ch]));
            }
        }
        while (!q.isEmpty()) {
            // Tomamos el nodo o estado del frente de la cola
            int state = q.poll();
            // Se busca la funcion de fallo de todos los caracteres del estado
            // removido para cuales funcion g no esta definido
            for (int ch = 0; ch &lt; MAXC; ++ch) {
                if (g[state][ch] != -1) {
                    //Encontrar el valor de la funcion de fallo
                    int failure = f[state];
                    // encuentra el nodo mas profundo con el sufijo
                    // apropiado del string desde el nodo raiz al estado actual
                    while (g[failure][ch] == -1) {
                        failure = f[failure];
                    }
                    failure = g[failure][ch];
                    f[g[state][ch]] = failure;
                    //Junta los valores de salida
                    out[g[state][ch]] |= out[failure];
                    //Inserta el nodo del siguiente nivel del trie
                    q.offer(g[state][ch]);
                }
            }
        }

        return states;
    }
    // currentState - El estado actual de la maquina 
    //                 entre 0 y el total de estados -1  
    // nextInput - El siguiente caracter que entra en la maquina. 

    static int findNextState(int currentState, char nextInput) {
        int answer = currentState;
        int ch = nextInput - &#39;a&#39;;
        // Si g no esta definido, use la funcion de fallo 
        while (g[answer][ch] == -1) {
            answer = f[answer];
        }
        return g[answer][ch];
    }

    //Función que busca las ocurrencias en el texto
    static void searchWords(String arr[], int k, String text) {
        // Preprocesar patrones
        // Construir los tries como una maquina de estado finito
        buildMatchingMachine(arr, k);
        // Inicializar los estados
        int currentState = 0;
        //Atravesamos el texto buscando las ocurrencias
        for (int i = 0; i &lt; text.length(); ++i) {
            currentState = findNextState(currentState, text.charAt(i));
            // Si no se encuentra cotejado, pasa al siguiente estado
            if (out[currentState] == 0) {
                continue;
            }
            // cotejado encontrado, imprimir todas las palabras de 
            // arr[] que se encontraron 
            for (int j = 0; j &lt; k; ++j) {
                int aux = (out[currentState] &amp; (1 &lt;&lt; j));
                if (aux &gt; 0) {
                    System.out.println(&quot;La palabra &quot; + arr[j] + &quot; aparece de &quot;
                            + (i - arr[j].length() + 1) + &quot; a &quot; + i);
                }
            }
        }
    }

    public static void main(String[] args) {
        String arr[] = {&quot;he&quot;, &quot;she&quot;, &quot;hers&quot;, &quot;his&quot;};
        String text = &quot;ahishers&quot;;
        int k = arr.length;
        searchWords(arr, k, text);
    }
}
</java>
  <cpp>using namespace std;
#include &lt;bits/stdc++.h&gt; 

const int MAXS = 500;
const int MAXC = 26;
int out[MAXS];
int f[MAXS];
int g[MAXS][MAXC];

int buildMatchingMachine(string arr[], int k) {
    memset(out, 0, sizeof out);
    memset(g, -1, sizeof g);
    int states = 1;
    for (int i = 0; i &lt; k; ++i) {
        const string &amp;word = arr[i];
        int currentState = 0;
        for (int j = 0; j &lt; word.size(); ++j) {
            int ch = word[j] - &#39;a&#39;;
            if (g[currentState][ch] == -1)
                g[currentState][ch] = states++;
            currentState = g[currentState][ch];
        }
        out[currentState] |= (1 &lt;&lt; i);
    }
    for (int ch = 0; ch &lt; MAXC; ++ch)
        if (g[0][ch] == -1)
            g[0][ch] = 0;
    memset(f, -1, sizeof f);
    queue&lt;int&gt; q;
    for (int ch = 0; ch &lt; MAXC; ++ch) {
        if (g[0][ch] != 0) {
            f[g[0][ch]] = 0;
            q.push(g[0][ch]);
        }
    }

    while (q.size()) {
        int state = q.front();
        q.pop();
        for (int ch = 0; ch &lt;= MAXC; ++ch) {
            if (g[state][ch] != -1) {
                int failure = f[state];
                while (g[failure][ch] == -1)
                    failure = f[failure];
                failure = g[failure][ch];
                f[g[state][ch]] = failure;
                out[g[state][ch]] |= out[failure];
                q.push(g[state][ch]);
            }
        }
    }
    return states;
}

int findNextState(int currentState, char nextInput) {
    int answer = currentState;
    int ch = nextInput - &#39;a&#39;;
    while (g[answer][ch] == -1)
        answer = f[answer];
    return g[answer][ch];
}

void searchWords(string arr[], int k, string text) {
    buildMatchingMachine(arr, k);
    int currentState = 0;
    for (int i = 0; i &lt; text.size(); ++i) {
        currentState = findNextState(currentState, text[i]);
        if (out[currentState] == 0)
            continue;
        for (int j = 0; j &lt; k; ++j) {
            int aux = out[currentState] &amp; (1 &lt;&lt; j);
            if (aux) {
                cout &lt;&lt; &quot;Word &quot; &lt;&lt; arr[j] &lt;&lt; &quot; appears from &quot;
                        &lt;&lt; i - arr[j].size() + 1 &lt;&lt; &quot; to &quot; &lt;&lt; i &lt;&lt; endl;
            }
        }
    }
}

int main() {
    string arr[] = {&quot;he&quot;, &quot;she&quot;, &quot;hers&quot;, &quot;his&quot;};
    string text = &quot;ahishers&quot;;
    int k = sizeof (arr) / sizeof (arr[0]);

    searchWords(arr, k, text);

    return 0;
} 
</cpp>
  <py>from collections import deque
MAXS = 500
MAXC = 26
out = []
f = []
g = []

def buildMatchingMachine(arr, k):
    global MAXS
    global MAXC
    global out
    global g
    global f
    out = [0 for x in range(MAXS)]
    g = [[-1 for y in range(MAXC)] for x in range(MAXS)]
    states = 1
    for i in range(k):
        word = arr[i]
        currentState = 0
        for j in range(len(word)):
            ch = ord(word[j]) - ord(&#39;a&#39;)
            if g[currentState][ch] == -1:
                states = states + 1
                g[currentState][ch] = states
            currentState = g[currentState][ch]
        out[currentState] |= (1 &lt;&lt; i)
    for ch in range(MAXC):
        if g[0][ch] == -1:
            g[0][ch] = 0
    f = [-1 for x in range(MAXS)]
    q = deque()
    for ch in range(MAXC):
        if g[0][ch] != 0:
            f[g[0][ch]] = 0
            q.append((g[0][ch]))
    while not len(q) == 0:
        state = q.pop()
        for ch in range(MAXC):
            if g[state][ch] != -1:
                failure = f[state]
                while g[failure][ch] == -1:
                    failure = f[failure]
                failure = g[failure][ch]
                f[g[state][ch]] = failure
                out[g[state][ch]] |= out[failure]
                q.append(g[state][ch])
    return states

def findNextState(currentState, nextInput):
    global MAXS
    global MAXC
    global out
    global g
    global f
    answer = currentState
    ch = int(ord(nextInput) - ord(&#39;a&#39;))
    while g[answer][ch] == -1:
        answer = f[answer]
    return g[answer][ch]

def searchWords(arr, k, text):
    global MAXS
    global MAXC
    global out
    global g
    global f
    buildMatchingMachine(arr, k)
    currentState = 0
    for i in range(len(text)):
        currentState = findNextState(currentState, text[i])
        if out[currentState] == 0:
            continue
        for j in range(k):
            aux = (out[currentState] &amp; (1 &lt;&lt; j))
            if aux &gt; 0:
                print(&quot;la palabra &quot;, arr[j], &quot; aparece de &quot;, ((i - len(arr[j])) + 1), &quot; a &quot;, i)


arr = [&quot;he&quot;, &quot;she&quot;, &quot;hers&quot;, &quot;his&quot;]
text = &quot;ahishers&quot;
k = len(arr)
searchWords(arr, k, text)
</py>
  <orden>5</orden>
  <suborden>4</suborden>
  <fecha_creacion>2020-12-04 20:09:36</fecha_creacion>
  <fecha_modificacion>2020-12-07 02:36:10</fecha_modificacion>
</row>
<row>
  <ID>32</ID>
  <supergrupo>Strings</supergrupo>
  <tema>Finite Automata</tema>
  <texto><div style="text-align: justify;"><span style="font-size: 10pt;">Dado un texto txt[0...n-1] y un patrón pat[0...m-1], busque todas las ocurrencias de pat en txt e imprímalas, asuma que n es mayor que m.&nbsp;</span></div><div style="text-align: justify;"><span style="font-size: 10pt;"><br></span></div><div style="text-align: justify;"><span style="font-size: 10pt;">En el algoritmo basado en Finite autómata, nosotros preprocesamos el patrón y construimos un array de dos dimensiones que represente un autómata finito. Construcción del FA es la parte complicada de este algoritmo. Una vez el FA este construido, la búsqueda es simple, En la búsqueda nosotros simplemente necesitamos iniciar desde el primer estado del autómata y el primer carácter del texto. En cada paso, consideramos el siguiente carácter del texto, miramos por el siguiente estado en el FA construido y nos movemos a un nuevo estado. Si alcanzamos el estado final, entonces el patrón fue encontrado en el texto.</span></div></texto>
  <complejidad_tiempo>Mejor caso :    O(n)        Peor caso : O(n)       Promedio: O(n)         </complejidad_tiempo>
  <java>// Programa java para el algoritmo
// Finite Automata de busqueda de patrones

public class FiniteAutomata {

    static int NO_OF_CHARS = 256;

    static int getNextState(char[] pat, int M,
            int state, int x) {
        // Si el caracter c es el mismo como el 
        // siguiente en patrón, simplemente incrementa
        // state
        if (state &lt; M &amp;&amp; x == pat[state]) {
            return state + 1;
        }
        // ns almacena el resultado el cual es 
        // el siguiente state
        int ns, i;
        /* ns finalmente contiene el prefijo más largo
        el cual tambien es sufijo en &quot;pat[0..state-1]c&quot;
        Empieza desde el valor más largo posible 
        y se detiene cuando se encuentra un prefijo el cual
        es tambien sufijo*/
        for (ns = state; ns &gt; 0; ns--) {
            if (pat[ns - 1] == x) {
                for (i = 0; i &lt; ns - 1; i++) {
                    if (pat[i] != pat[state - ns + 1 + i]) {
                        break;
                    }
                }
                if (i == ns - 1) {
                    return ns;
                }
            }
        }
        return 0;
    }

    /*Esta función construye la tabla TF la cual
    representa Finite Automata del patrón dado*/
    static void computeTF(char[] pat, int M, int TF[][]) {
        int state, x;
        for (state = 0; state &lt;= M; ++state) {
            for (x = 0; x &lt; NO_OF_CHARS; ++x) {
                TF[state][x] = getNextState(pat, M, state, x);
            }
        }
    }

    /* Imprime todas las ocurrencuas de pat en txt*/
    static void search(char[] pat, char[] txt) {
        int M = pat.length;
        int N = txt.length;
        int[][] TF = new int[M + 1][NO_OF_CHARS];
        computeTF(pat, M, TF);
        // Procesa txt sobre FA.
        int i, state = 0;
        for (i = 0; i &lt; N; i++) {
            state = TF[state][txt[i]];
            if (state == M) {
                System.out.println(&quot;Patrón encontrado &quot;
                        + &quot;en indice &quot; + (i - M + 1));
            }
        }
    }

    public static void main(String[] args) {
        char[] txt = &quot;AABAACAADAABAAABAA&quot;.toCharArray();
        char[] pat = &quot;AABA&quot;.toCharArray();
        search(pat, txt);
    }
}
</java>
  <cpp>#include &lt;cstdlib&gt;
#include &lt;bits/stdc++.h&gt;
using namespace std;
#define NO_OF_CHARS 256

int getNextState(char pat[], int M, int state, int x) {
    if (state &lt; M &amp;&amp; x == pat[state]) {
        return state + 1;
    }
    int ns, i;
    for (ns = state; ns &gt; 0; ns--) {
        if (pat[ns - 1] == x) {
            for (i = 0; i &lt; ns - 1; i++) {
                if (pat[i] != pat[state - ns + 1 + i]) {
                    break;
                }
            }
            if (i == ns - 1) {
                return ns;
            }
        }
    }
    return 0;
}

void computeTF(char pat[], int M, int TF[NO_OF_CHARS][NO_OF_CHARS]) {
    int state, x;
    for (state = 0; state &lt;= M; state++) {
        for (x = 0; x &lt; NO_OF_CHARS; x++) {
            TF[state][x] = getNextState(pat, M, state, x);
        }
    }
}

void finiteAutomata(char pat[], char txt[]) {
    int M = strlen(pat);
    int N = strlen(txt);
    int TF[M + 1][NO_OF_CHARS];
    computeTF(pat, M, TF);
    int i, state = 0;
    for (i = 0; i &lt; N; i++) {
        state = TF[state][txt[i]];
        if (state == M) {
            cout &lt;&lt; &quot;Patron encontrado en indice &quot; &lt;&lt; i - M + 1 &lt;&lt; &quot; - &quot; &lt;&lt; i &lt;&lt; endl;
        }
    }
}

int main(int argc, char const *argv[]) {
    char pat[] = {&quot;looloolo&quot;};
    char txt[] = {&quot;olo&quot;};
    finiteAutomata(txt, pat);
    return 0;
}
</cpp>
  <py>from sys import stdin
from sys import stdout
rl = stdin.readline
wr = stdout.write

NO_OF_CHARS = 256


def getNextState(pat, M, state, x):

    if state &lt; M and x == ord(pat[state]):
        return state + 1

    i = 0
    for ns in range(state, 0, -1):
        if ord(pat[ns-1]) == x:
            for i in range(ns-1):
                if pat[i] != pat[state-ns + 1 + i]:
                    break
                i += 1
            if i == ns - 1:
                return ns

    return 0


def computeTF(pat, M, TF):
    for state in range(M + 1):
        for x in range(NO_OF_CHARS):
            TF[state][x] = getNextState(pat, M, state, x)


def finiteAutomataSearch(pat, txt):

    M = len(pat)
    N = len(txt)
    TF = [[0 for x in range(NO_OF_CHARS)] for x in range(M + 1)]
    computeTF(pat, M, TF)
    state = 0
    for i in range(N):
        state = TF[state][ord(txt[i])]
        if state == M:
            wr(f&#39;&quot;{&quot;&quot;.join(pat)}&quot; encontrado en indices ({i-M+1} - {i})\n&#39;)


txt = &#39;AABAACAADAABAABA&#39;
pat = &#39;AABA&#39;
finiteAutomataSearch(pat, txt)
</py>
  <orden>5</orden>
  <suborden>5</suborden>
  <fecha_creacion>2020-12-04 20:09:36</fecha_creacion>
  <fecha_modificacion>2020-12-07 02:37:59</fecha_modificacion>
</row>
<row>
  <ID>33</ID>
  <supergrupo>Matemática</supergrupo>
  <tema>GCD/LCM</tema>
  <texto><div style="text-align: justify;"><span style="font-size: 10pt;">El máximo común divisor (MCD o GCD) de dos o más números naturales o enteros (no números con decimales) es el número más grande que les divide.
El mínimo común múltiplo (MCM o LCM) de dos números a y b es el número más pequeño que es múltiplo de a y múltiplo de b.</span></div></texto>
  <complejidad_tiempo>Mejor caso :    O(log(n))        Peor caso : O(log(n))       Promedio: O(log(n))         </complejidad_tiempo>
  <java>//Programa java que realiza
//Maximo comun divisor y minimo comun multiplo

public class GCDLCM {

    public static void main(String[] args) {
        int a = 8, b = 12;
        System.out.println(&quot;GCD de a y b es :&quot; + gcd(a, b));
        System.out.println(&quot;LCM de a y b es :&quot; + lcm(a, b));
    }
    //Maximo Comun Divisor
    public static int gcd(int a, int b) {
        return b == 0 ? a : gcd(b, a % b);
    }
    //Minimo Comun Multiplo
    public static int lcm(int a, int b) {
        return a * (b / gcd(a, b));
    }
}
</java>
  <cpp>#include&lt;bits/stdc++.h&gt;
#include&lt;cstdlib&gt;
//---------------//
using namespace std;

int GCD(int a, int b) {
    return b == 0 ? a : GCD(b, a % b);
}

int LCM(int a, int b) {
    return a * (b / GCD(a, b));
}

int main() {
    int a = 8;
    int b = 12;
    cout &lt;&lt; &quot;GCD de a y b es: &quot; &lt;&lt; GCD(a, b) &lt;&lt; endl;
    cout &lt;&lt; &quot;LCM de a y b es: &quot; &lt;&lt; LCM(a, b) &lt;&lt; endl;
}
</cpp>
  <py>from sys import stdout

def GCD(a, b):
    return a if b == 0 else GCD(b, a % b)

def LCM(a, b):
    return a * (b // GCD(a, b))

def main():
    a = int(8)
    b = int(12)
    stdout.write(f&quot;GCD de a y b es : {GCD(a,b)}\n&quot;)
    stdout.write(f&quot;LCM de a y b es : {LCM(a,b)}\n&quot;)

main()
</py>
  <orden>6</orden>
  <suborden>0</suborden>
  <fecha_creacion>2020-12-04 22:01:06</fecha_creacion>
  <fecha_modificacion>2020-12-07 02:42:29</fecha_modificacion>
</row>
<row>
  <ID>34</ID>
  <supergrupo>Matemática</supergrupo>
  <tema>Multiple GCD</tema>
  <texto><div style="text-align: justify;"><span style="font-size: 10pt;">Dado un array de números, encontrar GCD del array de elementos.
El GCD de tres o más números es igual que el producto de los factores primos comunes de todos los números, pero puede también ser calculado tomando repetidamente el GCD de los pares de números.</span></div></texto>
  <complejidad_tiempo>Mejor caso :    O(nlog(n))        Peor caso : O(nlog(n))       Promedio: O(nlog(n))</complejidad_tiempo>
  <java>// Programa java que encuentra
// el maximo comun divisor de 2 o más 
//números

public class GCDMultiple {
    // Funcion que retorna gcd de a y b
    static int gcd(int a, int b) {
        if (a == 0) {
            return b;
        }
        return gcd(b % a, a);
    }
    // Función que encuentra gcd de un arreglo de números
    static int findGCD(int arr[], int n) {
        int result = arr[0];
        for (int i = 1; i &lt; n; i++) {
            result = gcd(arr[i], result);
        }

        return result;
    }
    public static void main(String[] args) {
        int arr[] = {2, 4, 6, 8, 16};
        int n = arr.length;
        System.out.println(findGCD(arr, n));
    }
} 
</java>
  <cpp>null</cpp>
  <py>null</py>
  <orden>6</orden>
  <suborden>1</suborden>
  <fecha_creacion>2020-12-04 22:01:06</fecha_creacion>
  <fecha_modificacion>2020-12-07 02:42:37</fecha_modificacion>
</row>
<row>
  <ID>35</ID>
  <supergrupo>Matemática</supergrupo>
  <tema>GCD de números flotantes</tema>
  <texto><div style="font-family: Arial, Verdana; font-size: 10pt; font-style: normal; font-variant-ligatures: normal; font-variant-caps: normal; font-weight: normal; text-align: justify;"><span style="font-size: 10pt;">Una aproximación simple para realizar GCD a números flotantes es:&nbsp;</span></div><div style="font-family: Arial, Verdana; font-size: 10pt; font-style: normal; font-variant-ligatures: normal; font-variant-caps: normal; font-weight: normal; text-align: justify;">- a=1.20&nbsp;</div><div style="font-family: Arial, Verdana; font-size: 10pt; font-style: normal; font-variant-ligatures: normal; font-variant-caps: normal; font-weight: normal; text-align: justify;">- b=22.5&nbsp;</div><div style=""><div style="text-align: justify;"><span style="font-family: Arial, Verdana; font-size: 13.3333px;"><br></span></div><div style="text-align: justify; font-family: Arial, Verdana; font-size: 10pt; font-style: normal; font-variant-ligatures: normal; font-variant-caps: normal; font-weight: normal;">Expresando cada uno de los números sin decimales como el producto de los primos obtenemos:
- 120=2^3*3*5
- 2250=2*3^2*5^3
GCD de 120 y 2250 = 2*3*5=30
Por lo tanto, el GCD de 1.20 y 22.5=0.30 (Tomando 2 dígitos decimales).
Podemos hacer esto usando el algoritmo de Euclides, Este algoritmo indica si el número más pequeño es restado del número más largo, el GCD de dos números no cambia.
</div></div></texto>
  <complejidad_tiempo>Mejor caso :    O(log(n))        Peor caso : O(log(n))       Promedio: O(log(n))         </complejidad_tiempo>
  <java>// Programa java que encuentra el GCD de dos
// números flotantes

public class FloatGCD {
    // Funcion recursiva que retorna gcd de a y b  
    static double gcd(double a, double b) {
        if (a &lt; b) {
            return gcd(b, a);
        }
        // Caso base
        if (Math.abs(b) &lt; 0.001) {
            return a;
        } else {
            return (gcd(b, a - Math.floor(a / b) * b));
        }
    }

    public static void main(String args[]) {
        double a = 1.20, b = 22.5;
        System.out.printf(&quot;%.1f&quot;, gcd(a, b));
    }
}
</java>
  <cpp>include&lt;bits/stdc++.h&gt;
#include&lt;cstdlib&gt;
//---------------//
using namespace std;

double GCD(double a, double b) {
    if (a &lt; b) {
        return GCD(b, a);
    }
    if (std::fabs(b) &lt; 0.001) {
        return a;
    } else {
        return (GCD(b, a - (std::floor(a / b) * b)));
    }
}

int main() {
    double a = 1.20, b = 22.5;
    printf(&quot;%.2f\n&quot;, (GCD(a, b)));
} 

</cpp>
  <py>null</py>
  <orden>6</orden>
  <suborden>2</suborden>
  <fecha_creacion>2020-12-04 22:01:06</fecha_creacion>
  <fecha_modificacion>2020-12-07 02:43:07</fecha_modificacion>
</row>
<row>
  <ID>36</ID>
  <supergrupo>Matemática</supergrupo>
  <tema>LCM en un vector</tema>
  <texto><div style="font-weight: normal; text-align: justify;"><span style="font-size: 10pt;">Dado un array de n números, encontrar el LCM de ellos.&nbsp;
</span></div><div style="font-weight: normal; text-align: justify;"><span style="font-size: 10pt;"><br></span></div><div style="font-weight: normal; text-align: justify;"><span style="font-size: 10pt;">La idea es extender nuestra relación de más de dos números, se tiene un array arr[] que contiene n elementos de los cuales se necesita calcular su LCM.&nbsp;</span></div><div style="font-weight: normal; text-align: justify;"><span style="font-size: 10pt;"><br></span></div><div style="text-align: justify;"><span style="font-size: 10pt; font-weight: bold;">Los pasos principales del algoritmo son:&nbsp;</span></div><div style="font-weight: normal; text-align: justify;"><span style="font-size: 10pt;">1) Inicializa ans = arr[0]&nbsp;</span></div><div style="font-weight: normal; text-align: justify;"><span style="font-size: 10pt;">2) Iterar sobre todos los elementos del array, por ejemplo desde i=1 a i= n-1, en la iesima iteración ans= LCM(arr[0],arr[1],……., arr[i-1]). Esto puede ser fácilmente hecho como LCM(arr[0], arr[1], …., arr[i]) = LCM(ans, arr[i]). Entonces en la iesima iteración tenemos que hacer ans = LCM(ans, arr[i]) = ans x arr[i] / gcd(ans, arr[i])</span></div></texto>
  <complejidad_tiempo>Mejor caso :    O(nlog(n))        Peor caso : O(nlog(n))       Promedio: O(nlog(n))         </complejidad_tiempo>
  <java>// Programa java que calcula el minimo común multiplo
// de n elementos

public class Lcmofarrayelements {

    public static long lcm_of_array_elements(int[] element_array) {
        long lcm_of_array_elements = 1;
        int divisor = 2;
        while (true) {
            int counter = 0;
            boolean divisible = false;
            for (int i = 0; i &lt; element_array.length; i++) {

                // lcm_of_array_elements (n1, n2, ... 0) = 0. 
                // Para cada número negativo lo convertimos
                // En positivo y calculamos lcm_of_array_elements. 
                if (element_array[i] == 0) {
                    return 0;
                } else if (element_array[i] &lt; 0) {
                    element_array[i] = element_array[i] * (-1);
                }
                if (element_array[i] == 1) {
                    counter++;
                }
                /* Divide element_array por diviser si completa
                división */
                if (element_array[i] % divisor == 0) {
                    divisible = true;
                    element_array[i] = element_array[i] / divisor;
                }
            }
            /*Si el divisor es capaz de dividir completamente cualquier número.
            de la matriz multiplicar con lcm_of_array_elements
            y almacenar en lcm_of_array_elements y continuar
            al mismo divisor para encontrar el siguiente factor.
            si no incrementar divisor*/

            if (divisible) {
                lcm_of_array_elements = lcm_of_array_elements * divisor;
            } else {
                divisor++;
            }
            //Verifica si todo element_Array es 1 indicando
            // encontramos todos los factores y terminamos el ciclo
            if (counter == element_array.length) {
                return lcm_of_array_elements;
            }
        }
    }

    public static void main(String[] args) {
        int[] element_array = {2, 7, 3, 9, 4};
        System.out.println(lcm_of_array_elements(element_array));
    }
}
</java>
  <cpp>#include&lt;bits/stdc++.h&gt;
#include&lt;cstdlib&gt;
//---------------//
using namespace std;

long lcm_array(int arr[], int len) {
    long lcm = 1;
    int divisor = 2;
    while (true) {
        int counter = 0;
        bool divisible = false;
        for (int i = 0; i &lt; len; i++) {
            if (arr[i] == 0) {
                return 0;
            } else if (arr[i] &lt; 0) {
                arr[i] = arr[i]*(-1);
            }
            if (arr[i] == 1) {
                counter++;
            }
            if (arr[i] % divisor == 0) {
                divisible = true;
                arr[i] = arr[i] / divisor;
            }
        }
        if (divisible) {
            lcm = lcm*divisor;
        } else {
            divisor++;
        }
        if (counter == len) {
            return lcm;
        }
    }
}

int main() {
    int arr[] = {2, 7, 3, 9, 4};
    int len = sizeof arr / sizeof arr[0];
    cout &lt;&lt; lcm_array(arr, len);
} 
</cpp>
  <py>null</py>
  <orden>6</orden>
  <suborden>3</suborden>
  <fecha_creacion>2020-12-04 22:01:06</fecha_creacion>
  <fecha_modificacion>2020-12-07 02:43:55</fecha_modificacion>
</row>
<row>
  <ID>37</ID>
  <supergrupo>Matemática</supergrupo>
  <tema>Test de primalidad</tema>
  <texto><div style="text-align: justify;"><span style="font-size: 10pt;">Un número primo es un número natural mayor que 1 que tiene únicamente dos divisores distintos: él mismo y el 1. Por el contrario, los números compuestos son los números naturales que tienen algún divisor natural aparte de sí mismos y del 1, y, por lo tanto, pueden factorizarse. El número 1, por convenio, no se considera ni primo ni compuesto.&nbsp;</span></div><div style="text-align: justify;"><span style="font-size: 10pt;"><br></span></div><div style="text-align: justify;"><span style="font-size: 10pt;">La propiedad de ser número primo se denomina primalidad. El estudio de los números primos es una parte importante de la teoría de números, rama de las matemáticas que trata las propiedades, básicamente aritméticas, de los números enteros.
El teorema fundamental de la aritmética establece que todo número natural tiene una representación única como producto de factores primos, salvo el orden. Un mismo factor primo puede aparecer varias veces. El 1 se representa entonces como un producto vacío.</span></div></texto>
  <complejidad_tiempo>Mejor caso :    O(vn)        Peor caso : O(vn)       Promedio: O(vn)</complejidad_tiempo>
  <java>//Programa java que verifica si un número
// es primo o no

public class PrimalityTest {

    public static void main(String[] args) {
        boolean isprime = false;
        int n = 5;
        if (isPrime(n)) {
            System.out.println(&quot;Es primo&quot;);
        } else {
            System.out.println(&quot;No es primo&quot;);
        }
    }

    //Prueba de primalidad
    public static boolean isPrime(int x) {
        if (x &lt; 2) {
            return false;
        }
        if (x == 2) {
            return true;
        }
        if (x % 2 == 0) {
            return false;
        }
        for (int i = 2; i * i &lt;= x; i++) {
            if (x % i == 0) {
                return false;
            }
        }
        return true;
    }
}
</java>
  <cpp>#include&lt;bits/stdc++.h&gt;
#include&lt;cstdlib&gt;
//---------------//
using namespace std;

bool isPrime(int x) {
    if (x &lt; 2) {
        return false;
    }
    if (x == 2) {
        return true;
    }
    for (int i = 2; i * i &lt;= x; i++) {
        if (x % i == 0) {
            return false;
        }
    }
    return true;
}

int main() {
    int n = 25;
    if (isPrime(n)) {
        cout &lt;&lt; n &lt;&lt; &quot; es primo&quot; &lt;&lt; endl;
    } else {
        cout &lt;&lt; n &lt;&lt; &quot; no es primo&quot; &lt;&lt; endl;
    }
}
</cpp>
  <py>from sys import stdout

def isPrime(x):
    if (x % 2 == 0 and x &gt; 2) or x &lt; 2:
        return False
    if x == 2:
        return True
    i = 3
    while i * i &lt;= x:
        if x % i == 0:
            return False
        i += 1
    return True

def main():
    n = int(13)
    if isPrime(n):
        stdout.write(&quot;es primo&quot;)
    else:
        stdout.write(&quot;no es primo&quot;)

main()
</py>
  <orden>6</orden>
  <suborden>4</suborden>
  <fecha_creacion>2020-12-04 22:01:06</fecha_creacion>
  <fecha_modificacion>2020-12-07 02:44:15</fecha_modificacion>
</row>
<row>
  <ID>38</ID>
  <supergrupo>Matemática</supergrupo>
  <tema>Factores primos</tema>
  <texto><div style="text-align: justify;"><span style="font-size: 10pt;">Los factores primos de un número entero son los números primos divisores exactos de ese número entero.&nbsp;</span></div><div style="text-align: justify;"><span style="font-size: 10pt;"><br></span></div><div style="text-align: justify;">El proceso de búsqueda de esos divisores se denomina factorización de enteros, o factorización en números primos.
Determinar el número de factores primos de un número es un ejemplo de problema matemático frecuentemente empleado para asegurar la seguridad de los sistemas criptográficos: se cree que este problema requiere un tiempo superior al tiempo polinómico en el número de dígitos implicados; de hecho, es relativamente sencillo construir un problema que precisaría más tiempo que la Edad del Universo si se intentase calcular con los ordenadores actuales utilizando algoritmos actuales.
</div></texto>
  <complejidad_tiempo>Mejor caso :    O(vn)        Peor caso : O(vn)       Promedio: O(vn)         </complejidad_tiempo>
  <java>//Programa que descompone un número n
// en sus factores primos

public class PrimeFactors {

    public static void main(String[] args) {
        primeFactors(12);
    }
    //Descomposicion en factores primos
    public static void primeFactors(int N) {
        for (long p = 2; p * p &lt;= N; ++p) {
            while (N % p == 0) {
                System.out.println(p);
                N /= p;
            }
        }
        if (N &gt; 1) {
            System.out.println(N);
        }
    }
}
</java>
  <cpp>#include&lt;bits/stdc++.h&gt;
#include&lt;cstdlib&gt;
//---------------//
using namespace std;
typedef long long int ll;

void primeFactors(ll n) {
    for (ll p = 2; p * p &lt;= n; p++) {
        while (n % p == 0) {
            cout &lt;&lt; p &lt;&lt; &quot; &quot;;
            n /= p;
        }
    }
    if (n &gt; 1) {
        cout &lt;&lt; n &lt;&lt; endl;
    }
}

int main() {
    ll n = 20;
    primeFactors(n);
}</cpp>
  <py>from sys import stdout

def PrimeFactors(n):
    i = int(2)
    while i**2 &lt;= n:
        while n % i == 0:
            stdout.write(str(i)+&quot;\n&quot;)
            n //= i
        i+=1
    if n&gt;1:
        stdout.write(str(n))

def main():
    PrimeFactors(20)

main()</py>
  <orden>6</orden>
  <suborden>5</suborden>
  <fecha_creacion>2020-12-04 22:01:06</fecha_creacion>
  <fecha_modificacion>2020-12-07 02:44:34</fecha_modificacion>
</row>
<row>
  <ID>39</ID>
  <supergrupo>Matemática</supergrupo>
  <tema>Divisibilidad de un número</tema>
  <texto><div style="text-align: justify;"><span style="font-size: 10pt;">Los criterios de divisibilidad son reglas que sirven para saber si un número es divisible por otro sin necesidad de realizar la división, a continuación se presentan los criterios de divisibilidad para los números mas conocidos.</span></div></texto>
  <complejidad_tiempo>Mejor caso :    O(n)        Peor caso : O(n)       Promedio: O(n)         </complejidad_tiempo>
  <java>//Programa que verifica la divisibilidad de un 
// número entre los números 1 a 12

public class DivisibilityBySmallNumbers {

    public static void main(String[] args) {
        boolean[] res = divisility(12);
        for (int i = 0; i &lt; res.length; i++) {
            System.out.println(i + &quot; : &quot; + res[i]);
        }
    }

    static public boolean[] divisility(int num) {
        String M = String.valueOf(num);
        int n = M.length();
        boolean[] isMultipleOf = new boolean[13];
        int sum = 0;
        for (char c : M.toCharArray()) {
            sum += c - &#39;0&#39;;
        }
        int lastDigit = M.charAt(n - 1) - &#39;0&#39;;
        //Divisibilidad entre 1
        isMultipleOf[1] = true;
        //Divisibilidad entre 2
        isMultipleOf[2] = lastDigit % 2 == 0;
        //Divisibilidad entre 3
        isMultipleOf[3] = sum % 3 == 0;
        //Divisibilidad entre 4
        if (n &gt; 1) {
            isMultipleOf[4] = Integer.parseInt(M.substring(n - 2, n)) % 4 == 0;
        } else {
            isMultipleOf[4] = lastDigit % 4 == 0;
        }
        //Divisibilidad entre 5
        isMultipleOf[5] = lastDigit == 0 || lastDigit == 5;
        //Divisibilidad entre 6
        isMultipleOf[6] = isMultipleOf[2] &amp;&amp; isMultipleOf[3];
        int altSum = 0;
        int[] pattern = {1, 3, 2, -1, -3, -2};
        int j = 0;
        for (int i = n - 1; i &gt;= 0; i--) {
            altSum += pattern[j] * (M.charAt(i) - &#39;0&#39;);
            j = (j + 1) % 6;
        }
        //Divisibilidad entre 7
        isMultipleOf[7] = Math.abs(altSum) % 7 == 0;
        //Divisibilidad entre 8
        if (n &gt; 2) {
            isMultipleOf[8] = Integer.parseInt(M.substring(n - 3, n)) % 8 == 0;
        } else {
            isMultipleOf[8] = Integer.parseInt(M) % 8 == 0;
        }
        //Divisibilidad entre 9
        isMultipleOf[9] = sum % 9 == 0;
        //Divisibilidad entre 10
        isMultipleOf[10] = lastDigit == 0;
        altSum = 0;
        int s = 1;
        for (int i = n - 1; i &gt;= 0; i--) {
            altSum += s * (M.charAt(i) - &#39;0&#39;);
            s = -s;
        }
        //Divisibilidad entre 11
        isMultipleOf[11] = Math.abs(altSum) % 11 == 0;
        //Divisibilidad entre 12
        isMultipleOf[12] = isMultipleOf[3] &amp;&amp; isMultipleOf[4];
        return isMultipleOf;
    }
}
</java>
  <cpp>#include&lt;bits/stdc++.h&gt;
#include&lt;cstdlib&gt;
//---------------//
using namespace std;

void print(bool arr[]) {
    for (int i = 0; i &lt; 13; i++) {
        cout &lt;&lt; i &lt;&lt; &quot;: &quot; &lt;&lt; arr[i] &lt;&lt; endl;
    }
}

void divisibility(int num) {
    stringstream ss;
    ss &lt;&lt; num;
    string M;
    ss&gt;&gt;M;
    int n = M.size();
    bool isMultipleof[13];
    memset(isMultipleof, false, sizeof isMultipleof);
    int sum = 0;
    for (int i = 0; i &lt; n; i++) {
        sum += (M[i] - &#39;0&#39;);
    }
    int lastDigit = M[n - 1] - &#39;0&#39;;
    isMultipleof[0] = false;
    isMultipleof[1] = true;
    isMultipleof[2] = lastDigit % 2 == 0;
    isMultipleof[3] = sum % 3 == 0;
    if (n &gt; 1) {
        isMultipleof[4] = stoi(M.substr(n - 2, n)) % 4 == 0;
    } else {
        isMultipleof[4] = lastDigit % 4 == 0;
    }
    isMultipleof[5] = lastDigit == 0 || lastDigit == 5;
    isMultipleof[6] = isMultipleof[2] &amp;&amp; isMultipleof[3];
    int altsum = 0;
    int pattern[] = {1, 3, 2, -1, -3, -2};
    int j = 0;
    for (int i = n - 1; i&gt;-0; i--) {
        altsum += pattern[j]*(M[i] - &#39;0&#39;);
        j = (j + 1) % 6;
    }
    isMultipleof[7] = std::abs(altsum) % 7 == 0;
    if (n &gt; 2) {
        isMultipleof[8] = stoi(M.substr(n - 3, n)) % 8 == 0;
    } else {
        isMultipleof[8] = stoi(M) % 8 == 0;
    }
    isMultipleof[9] = sum % 8 == 0;
    isMultipleof[10] - lastDigit == 0;
    altsum = 0;
    int s = 1;
    for (int i = n - 1; i &gt;= 0; i--) {
        altsum += s * (M[i] - &#39;0&#39;);
        s = -s;
    }
    isMultipleof[11] = std::abs(altsum) % 11 == 0;
    isMultipleof[12] = isMultipleof[2] &amp;&amp; isMultipleof[4];
    print(isMultipleof);
}

int main() {
    divisibility(33);
}
</cpp>
  <py>from sys import stdout


def divisibility(num):
    M = str(num)
    n = len(M)
    isMultipleOf = [False for x in range(13)]
    suma = 0
    for c in M:
        suma += ord(c) - ord(&quot;0&quot;)

    lastDigit = ord(M[n - 1]) - ord(&quot;0&quot;)
    isMultipleOf[1] = True
    isMultipleOf[2] = lastDigit % 2 == 0
    isMultipleOf[3] = suma % 3 == 0

    if n &gt; 1:
        isMultipleOf[4] = int(M[n - 2:n]) % 4 == 0
    else:
        isMultipleOf[4] = lastDigit % 4 == 0

    isMultipleOf[5] = lastDigit == 0 or lastDigit == 5
    isMultipleOf[6] = isMultipleOf[2] and isMultipleOf[3]

    altsum = 0
    pattern = [1, 3, 2, -1, -3, -2]
    j = 0
    for i in range(n - 1, -1, -1):
        altsum = pattern[j] * (ord(M[i]) - ord(&quot;0&quot;))
        j = (j + 1) % 6
    isMultipleOf[7] = abs(altsum) % 7 == 0
    if n &gt; 2:
        isMultipleOf[8] = int(M[n - 3:n]) % 8 == 0
    else:
        isMultipleOf[8] = int(M) % 8 == 0

    isMultipleOf[9] = suma % 8 == 0
    isMultipleOf[10] = lastDigit == 0
    altsum = 0
    s = 1
    for i in range(n-1, -1, -1):
        altsum += s * (ord(M[i]) - ord(&quot;0&quot;))
        s = -s

    isMultipleOf[11] = abs(altsum) % 11 == 0
    isMultipleOf[12] = isMultipleOf[4] and isMultipleOf[13]
    return isMultipleOf


res = divisibility(123)
for i in range(len(res)):
    stdout.write(f&quot;{i} : {res[i]}\n&quot;)
</py>
  <orden>6</orden>
  <suborden>6</suborden>
  <fecha_creacion>2020-12-04 22:01:06</fecha_creacion>
  <fecha_modificacion>2020-12-07 02:44:50</fecha_modificacion>
</row>
<row>
  <ID>40</ID>
  <supergrupo>Matemática</supergrupo>
  <tema>Numero de divisores</tema>
  <texto><div style="text-align: justify;"><span style="font-size: 10pt;">Los divisores de un número son aquellos valores que dividen al número en partes exactas. Así, dado un número a, si la división a/b es exacta (el resto es cero), entonces se dice que b es divisor de a. También se puede decir que a es divisible por b o que a es un múltiplo de b.&nbsp;</span></div><div style="text-align: justify;"><span style="font-size: 10pt;"><br></span></div><div style="text-align: justify;">Esto resulta útil, por ejemplo, a la hora de agrupar una cantidad de objetos en partes iguales sin que nos sobre ninguno.
Lógicamente, el 1 siempre es divisor de cualquier número, porque siempre podemos hacer paquetes individuales y no nos sobrará ninguno. De igual forma, todo número es divisible por sí mismo, lo que equivaldría a hacer un único paquete.
</div></texto>
  <complejidad_tiempo>Mejor caso :    O(vn)        Peor caso : O(vn)       Promedio: O(vn)         </complejidad_tiempo>
  <java>//Programa java que cuenta el número
// de divisores de x

public class NumberOfDivisors {

    public static void main(String[] args) {
        System.out.println(divisors(56));
    }

    //Todos los divisores de un número
    public static int divisors(int x) {
        int nDiv = 1;
        for (int p = 2; p * p &lt;= x; ++p) {
            int cnt = 0;
            while (x % p == 0) {
                ++cnt; 
                x /= p;
            }
            nDiv *= cnt + 1;
        }
        if (x &gt; 1) {
            nDiv *= 2;
        }
        return nDiv;
    }
}
</java>
  <cpp>#include&lt;bits/stdc++.h&gt;
#include&lt;cstdlib&gt;
//---------------//
using namespace std;

int divisors(int x) {
    int nDiv = 1;
    for (int i = 2; i * i &lt;= x; i++) {
        int cnt = 0;
        while (x % i == 0) {
            ++cnt;
            x /= i;
        }
        nDiv *= cnt + 1;
    }
    if (x &gt; 1) {
        nDiv *= 2;
    }
    return nDiv;
}

int main() {
    cout &lt;&lt; divisors(10);
}
</cpp>
  <py>from sys import stdout


def divisors(x):
    nDiv = 1
    i = 2
    while i ** 2 &lt;= x:
        cnt = 0
        while x % i == 0:
            cnt += 1
            x //= i
        nDiv *= cnt + 1
        i += 1
    if x &gt; 1:
        nDiv *= 2
    return nDiv

stdout.write(str(divisors(10)))
</py>
  <orden>6</orden>
  <suborden>7</suborden>
  <fecha_creacion>2020-12-04 22:01:06</fecha_creacion>
  <fecha_modificacion>2020-12-07 02:45:29</fecha_modificacion>
</row>
<row>
  <ID>41</ID>
  <supergrupo>Matemática</supergrupo>
  <tema>Criba de Eratóstenes</tema>
  <texto>Criba de Eratóstenes es un algoritmo que permite hallar todos los números primos menores que un número natural dado n. Se forma una tabla con todos los números naturales comprendidos entre 2 y n, y se van tachando los números que no son primos de la siguiente manera: 
Comenzando por el 2, se tachan todos sus múltiplos; comenzando de nuevo, cuando se encuentra un número entero que no ha sido tachado, ese número es declarado primo, y se procede a tachar todos sus múltiplos, así sucesivamente. El proceso termina cuando el cuadrado del siguiente número confirmado como primo es mayor que n.
</texto>
  <complejidad_tiempo>Mejor caso :    O(nlog(log(n)))     Peor caso : O(nlog(log(n)))       Promedio: O(nlog(log(n)))         </complejidad_tiempo>
  <java>//Programa java que encuentra todos los números 
//primos bajo N

import java.util.Arrays;

public class PrimeNumbers {

    public static void main(String[] args) {
        boolean[] res = sieveEratostenes(100);
        for (int i = 0; i &lt; res.length; i++) {
            System.out.println(i + &quot; : &quot; + res[i]);
        }
    }

    //Criba de Eratostenes (Todos los primos bajo un número)
    public static boolean[] sieveEratostenes(int N) {
        boolean[] prime = new boolean[N + 1];
        Arrays.fill(prime, true);
        prime[0] = prime[1] = false;
        for (int p = 2; p * p &lt;= N; p++) {
            if (prime[p]) {
                for (int i = p * p; i &lt;= N; i += p) {
                    prime[i] = false;
                }
            }
        }
        return prime;
    }
}
</java>
  <cpp>#include &lt;bits/stdc++.h&gt;
#define FAST ios_base::sync_with_stdio(false);cin.tie(NULL);
using namespace std;

void print(bool arr[], int n) {
    for (int i = 0; i &lt;= n; i++) {
        cout &lt;&lt; i &lt;&lt; &quot;: &quot; &lt;&lt; arr[i] &lt;&lt; endl;
    }
}

void sieveErathostenes(int N) {
    bool prime[N + 1];
    memset(prime, true, sizeof prime);
    prime[0] = prime[1] = false;
    for (int p = 2; p * p &lt;= N; p++) {
        if (prime[p]) {
            for (int i = p * p; i &lt;= N; i += p) {
                prime[i] = false;
            }
        }
    }
    print(prime, N);
}

int main() {
    FAST;
    sieveErathostenes(1000);
    return 0;
}
</cpp>
  <py>from sys import stdout


def sieveErathostenes(n):
    prime = [True for x in range(n + 1)]
    prime[0] = False
    prime[1] = False
    p = 2
    while p ** 2 &lt;= n:
        if prime[p]:
            i = p ** 2
            while i &lt;= n:
                prime[i] = False
                i += p
        p += 1
    return prime

res = sieveErathostenes(100)

for i in range(len(res)):
    stdout.write(str(i) + &quot; &quot; + str(res[i])+ &quot;\n&quot;)

</py>
  <orden>6</orden>
  <suborden>8</suborden>
  <fecha_creacion>2020-12-04 22:01:06</fecha_creacion>
  <fecha_modificacion>2020-12-06 20:23:02</fecha_modificacion>
</row>
<row>
  <ID>42</ID>
  <supergrupo>Matemática</supergrupo>
  <tema>Criba de Eratóstenes O(n)</tema>
  <texto>La clásica criba de Eratóstenes toma O(Nlog (logN))  para encontrar todos los números primos  menores a N, este código es una versión modificada de esta criba que tiene una complejidad de tiempo de O(N).</texto>
  <complejidad_tiempo>Mejor caso :    O(n)        Peor caso : O(n)       Promedio: O(n)         </complejidad_tiempo>
  <java>/*Programa java que genera todos los números primos
menores a N en O(N) Eratostenes Optimizado*/
import java.util.ArrayList;

public class SieveofEratosthenesOptimizated {

    static final int MAX_SIZE = 1000001;
    // isPrime[] : isPrime[i] es true si el número es primo  
    // prime[] : Almacena todos los números primos menores a N 
    // SPF[] Almacena los factores primos más pequeños de un número 
    // [Por ejemplo : factor primo más pequeño que &#39;8&#39; y &#39;16&#39; es  
    //  &#39;2&#39; entonces nosotros ponemos SPF[8]=2 , SPF[16]=2 ] 
    static ArrayList&lt;Boolean&gt; isprime = new ArrayList&lt;&gt;(MAX_SIZE);
    static ArrayList&lt;Integer&gt; prime = new ArrayList&lt;&gt;();
    static ArrayList&lt;Integer&gt; SPF = new ArrayList&lt;&gt;(MAX_SIZE);
    // Metodo que genera todos los factores primos menores de N

    static void manipulated_seive(int N) {   // 0 y 1 no son primos
        isprime.set(0, false);
        isprime.set(1, false);

        // llena el resto de las entradas
        for (int i = 2; i &lt; N; i++) {
            // si isPrime[i] == True entonces i es  
            // número primo
            if (isprime.get(i)) {
                // pone i dentro de prime[]  
                prime.add(i);
                // un número primo es su propio factor primo
                // más pequeño
                SPF.set(i, i);
            }
            /*Eliminar todos los múltiplos de i * prime [j] que son
            no primos haciendo isPrime [i * prime [j]] = false
            y ponga el factor primo más pequeño de i * Prime [j] como prime [j]
            [Por ejemplo: dejemos i = 5, j = 0, prime[j] = 2 [i * prime [j] =           10]
            por lo que el factor primo más pequeño de &#39;10&#39; es &#39;2&#39; que es prime          [j]]
            este bucle se ejecuta solo una vez para el número que no es primo*/

            for (int j = 0;
                    j &lt; prime.size()
                    &amp;&amp; i * prime.get(j) &lt; N &amp;&amp; prime.get(j) &lt;= SPF.get(i);
                    j++) {
                isprime.set(i * prime.get(j), false);
                // Pone el factor primo más pequeño de i*prime[j] 
                SPF.set(i * prime.get(j), prime.get(j));
            }
        }
    }

    public static void main(String args[]) {
        int N = 13; //Debe ser menor que  MAX_SIZE        
        // inicializando isprime y SPF
        for (int i = 0; i &lt; MAX_SIZE; i++) {
            isprime.add(true);
            SPF.add(2);
        }
        manipulated_seive(N);
        //Imprima todos los números primos menores que n 
        for (int i = 0; i &lt; prime.size() &amp;&amp; prime.get(i) &lt;= N; i++) {
            System.out.print(prime.get(i) + &quot; &quot;);
        }
    }
}
</java>
  <cpp>#include &lt;bits/stdc++.h&gt;
#define FAST ios_base::sync_with_stdio(false);cin.tie(NULL);
#define MAX_SIZE 1000001
using namespace std;
typedef long long int ll;
vector&lt;int&gt;prime;

void manipule(ll N) {
    bool arr[N + 1];
    ll SPF[N + 1];
    memset(arr, true, sizeof arr);
    memset(SPF, 2, sizeof SPF);
    arr[0] = false;
    arr[1] = false;
    for (ll i = 2; i &lt; N; i++) {
        if (arr[i]) {
            prime.push_back(i);
            SPF[i] = i;
        }
        for (ll j = 0; j &lt; prime.size() &amp;&amp; i * prime[j] &lt; N &amp;&amp; prime[j] &lt;= SPF[i]; j++) {
            arr[i * prime[j]] = false;
            SPF[i * prime[j]] = prime[j];
        }
    }
    for (ll i = 0; i &lt; prime.size(); i++) {
        cout &lt;&lt; prime[i] &lt;&lt; &quot; &quot;;
    }
}

int main() {
    manipule(1000);
}
</cpp>
  <py>from sys import stdin
from sys import stdout

wr = stdout.write

MAX_SIZE = 1000001

isprime = [True for x in range(MAX_SIZE)]

prime = []

SPF = [int for x in range(MAX_SIZE)]

def manipuledSieve(N):
    global isprime
    global prime
    global SPF
    isprime[0] = False
    isprime[1] = False
    for i in range(2, N):
        if isprime[i]:
            prime.append(i)
            SPF[i] = i
        j = 0
        while j &lt; len(prime) and i * prime[j] &lt; N and prime[j] &lt;= SPF[i]:
            isprime[i * prime[j]] = False
            SPF[i * prime[j]] = prime[j]
            j += 1

N = 100
for i in range(MAX_SIZE):
    # isprime.append(True)
    SPF.append(2)
manipuledSieve(N)
for i in range(len(prime)):
    wr(f&quot;{prime[i]}  &quot;)

wr(&quot;\n&quot;)

for i in range(2, N):
    wr(f&quot;{i} : {SPF[i]} \n&quot;)
</py>
  <orden>6</orden>
  <suborden>9</suborden>
  <fecha_creacion>2020-12-04 22:01:06</fecha_creacion>
  <fecha_modificacion>2020-12-06 20:23:03</fecha_modificacion>
</row>
<row>
  <ID>43</ID>
  <supergrupo>Matemática</supergrupo>
  <tema>Ultimo digito de un Fibonacci</tema>
  <texto>La sucesión o serie de Fibonacci es una sucesión infinita de números naturales: 0 1 1 2 3 58 21 34 55 89....
La sucesión comienza con los números 0 y 1, y a partir de estos, cada término es la suma de los dos anteriores.
Los números de esta sucesión pueden llegar a ser muy grandes y calcular su último digito se hace complicado en máquinas.
Usando fib, multiply y power se puede calcular de forma optimizada un numero de Fibonacci, pero hay que tener en cuenta de no desbordar la variable o el resultado podría no ser correcto.
</texto>
  <complejidad_tiempo>O(1)        Peor caso : O(1)       Promedio: O(1)         </complejidad_tiempo>
  <java>// Programa java que encuentra el ultimo digito 
// de un nesimo número fibonacci

public class FibonacciLastDigit {
    //Funcion que retona el nesimo
    // Número de fibonacci
    static long fib(long n) {
        long F[][] = new long[][]{{1, 1}, {1, 0}};
        if (n == 0) {
            return 0;
        }
        power(F, n - 1);
        return F[0][0];
    }
    //Función que multiplica dos
    // matrices y almacera el resultado en la primera
    static void multiply(long F[][], long M[][]) {
        long x = F[0][0] * M[0][0]
                + F[0][1] * M[1][0];
        long y = F[0][0] * M[0][1]
                + F[0][1] * M[1][1];
        long z = F[1][0] * M[0][0]
                + F[1][1] * M[1][0];
        long w = F[1][0] * M[0][1]
                + F[1][1] * M[1][1];
        F[0][0] = x;
        F[0][1] = y;
        F[1][0] = z;
        F[1][1] = w;
    }

    static void power(long F[][], long n) {
        if (n == 0 || n == 1) {
            return;
        }
        long M[][] = new long[][]{{1, 1}, {1, 0}};
        power(F, n / 2);
        multiply(F, F);
        if (n % 2 != 0) {
            multiply(F, M);
        }
    }
    // Retorna el ultimo digito 
    // nesimo número fibonacci
    public static long findLastDigit(long n) {
        return (fib(n) % 10);
    }
    public static void main(String[] args) {
        int n;
        n = 1;
        System.out.println(findLastDigit(n));
        n = 61;
        System.out.println(findLastDigit(n));
        n = 7;
        System.out.println(findLastDigit(n));
        n = 67;
        System.out.println(findLastDigit(n));
    }
}
</java>
  <cpp>#include &lt;bits/stdc++.h&gt;
using namespace std;
typedef long long int ll;

void multiply(ll F[][2], ll M[][2]) {
    ll x = F[0][0] * M[0][0] + F[0][1] * M[1][0];
    ll y = F[0][0] * M[0][1] + F[0][1] * M[1][1];
    ll z = F[1][0] * M[0][0] + F[1][1] * M[1][0];
    ll w = F[1][0] * M[0][1] + F[1][1] * M[1][1];
    F[0][0] = x;
    F[0][1] = y;
    F[1][0] = z;
    F[1][1] = w;
}

void power(ll F[][2], ll n) {
    if (n == 0 || n == 1) {
        return;
    }
    ll M[][2] = {
        {1, 1},
        {1, 0}};
    power(F, n / 2);
    multiply(F, F);
    if (n % 2 != 0) {
        multiply(F, M);
    }
}

ll fib(ll n) {
    ll F [][2] = {
        {1, 1},
        {1, 0}};
    if (n == 0) {
        return 0;
    }
    power(F, n - 1);
    return F[0][0];
}

ll findLastDigit(ll n) {
    return (fib(n) % 10);
}

int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(NULL);
    cout &lt;&lt; fib(83) &lt;&lt; &quot; : &quot; &lt;&lt; findLastDigit(83);
    return 0;
}
</cpp>
  <py>from sys import stdout
wr = stdout.write


def multiply(F, M):
    x = F[0][0] * M[0][0] + F[0][1] * M[1][0]
    y = F[0][0] * M[0][1] + F[0][1] * M[1][1]
    z = F[1][0] * M[0][0] + F[1][1] * M[1][0]
    w = F[1][0] * M[0][1] + F[1][1] * M[1][1]
    F[0][0] = x
    F[0][1] = y
    F[1][0] = z
    F[1][1] = w


def power(F, n):
    if n == 0 or n == 1:
        return
    M = [[1, 1], [1, 0]]
    power(F, n // 2)
    multiply(F, F)
    if n % 2 != 0:
        multiply(F, M)

def fib(n):
    F = [[1, 1], [1, 0]]
    if n == 0:
        return 0
    power(F, n - 1)
    return F[0][0]

def findLastDigit(n):
    return fib(n) % 10

wr(f&#39;{fib(20)} : {findLastDigit(20)}&#39;)
</py>
  <orden>6</orden>
  <suborden>10</suborden>
  <fecha_creacion>2020-12-04 22:01:06</fecha_creacion>
  <fecha_modificacion>2020-12-06 20:23:04</fecha_modificacion>
</row>
<row>
  <ID>44</ID>
  <supergrupo>Matemática</supergrupo>
  <tema>Fibonacci largos</tema>
  <texto>Ciertos ejercicios demandar realizar el cálculo de números de la secuencia de Fibonacci los cuales son demasiado grandes,  para ciertos lenguajes el tamaño de las variables es un impedimento para realizar esta acción por lo que se debe usar librerías que permitan realizar operaciones con números increíblemente grandes, pero hay que tener en cuenta que entre más grande el numero, el tiempo de ejecución va a ser mayor.</texto>
  <complejidad_tiempo>Mejor caso :    O(n)        Peor caso : O(n)       Promedio: O(n)         </complejidad_tiempo>
  <java>//Porgrama java que busca el nesimo número
// de fibonacci cuando n puede ser muy largo

import java.math.*;

public class LongFibonacci {

    static BigInteger fib(int n) {
        BigInteger a = BigInteger.valueOf(0);
        BigInteger b = BigInteger.valueOf(1);
        BigInteger c = BigInteger.valueOf(1);
        for (int j = 2; j &lt;= n; j++) {
            c = a.add(b);
            a = b;
            b = c;
        }
        return (a);
    }

    public static void main(String[] args) {
        int n = 1000;
        System.out.println(&quot;Fibonacci de  &quot; + n
                + &quot; termino&quot; + &quot; &quot; + &quot;es&quot; + &quot; &quot; + fib(n));
    }
} 
</java>
  <cpp>null</cpp>
  <py>null</py>
  <orden>6</orden>
  <suborden>11</suborden>
  <fecha_creacion>2020-12-04 22:01:06</fecha_creacion>
  <fecha_modificacion>2020-12-06 20:23:04</fecha_modificacion>
</row>
<row>
  <ID>45</ID>
  <supergrupo>Matemática</supergrupo>
  <tema>Test de numero de Fibonacci</tema>
  <texto>Teniendo cualquier número entero n, se necesita verificar si este hace parte de la secuencia de los números de Fibonacci de forma optimizada.</texto>
  <complejidad_tiempo>Mejor caso :    O(log(n))        Peor caso : O(log(n))       Promedio: O(log(n))         </complejidad_tiempo>
  <java>// Programa que verifica si x es número fibonacci

public class IsFiboNumber {   
    // Función que retorna si x es cuadrado perfecto
    static boolean isPerfectSquare(int x) {
        int s = (int) Math.sqrt(x);
        return (s * s == x);
    }
    //Función que verifica si es número fibonacci
    static boolean isFibonacci(int n) {   
        // N es fibinacci si uno de 5*n*n+4 o or 5*n*n - 4
        // o ambos son cuadrados perfectos
        return isPerfectSquare(5 * n * n + 4)
                || isPerfectSquare(5 * n * n - 4);
    }

    public static void main(String[] args) {
        for (int i = 1; i &lt;= 10; i++) {
            System.out.println(isFibonacci(i) ? i + &quot; Es un número de fibonacci&quot;
                    : i + &quot; No es un número de fibonacci&quot;);
        }
    }
}
</java>
  <cpp>#include&lt;bits/stdc++.h&gt;
#include&lt;cstdlib&gt;
using namespace std;

bool isPerfectSquare(int x) {
    int s = (int) sqrt(x);
    return (s * s == x);
}

bool isFibonacci(int n) {
    return isPerfectSquare(5 * n * n + 4) || isPerfectSquare(5 * n * n - 4);
}

int main() {
    for (int i = 0; i &lt; 10; i++) {
        isFibonacci(i) ? cout &lt;&lt; i &lt;&lt; &quot;Es Fibonacci&quot; &lt;&lt; endl : cout &lt;&lt; i &lt;&lt; &quot;No es fibonacci&quot; &lt;&lt; endl;
    }
} 
</cpp>
  <py>null</py>
  <orden>6</orden>
  <suborden>12</suborden>
  <fecha_creacion>2020-12-04 22:01:06</fecha_creacion>
  <fecha_modificacion>2020-12-06 20:23:05</fecha_modificacion>
</row>
<row>
  <ID>46</ID>
  <supergrupo>Matemática</supergrupo>
  <tema>Fibonacci Golden Ratio
</tema>
  <texto>Existen diferentes métodos para encontrar el enésimo número de Fibonacci, una simple manera de encontrarlo es usando el ratio dorado.
Golden ratio (Ratio dorado):
f=(1+v5)/2=1.6180339887….
Golden ratio nos puede dar una respuesta incorrecta.
Podemos obtener la respuesta correcta si redondeamos hacia arriba el resultado de cada punto.
Este método puede calcular los primeros 34 números de Fibonacci correctamente, luego de esto puede haber diferencia con el valor correcto.
</texto>
  <complejidad_tiempo>Mejor caso :    O(vn)        Peor caso : O(vn)       Promedio: O(vn)         </complejidad_tiempo>
  <java>// Programa java que encuentra el 
// nesimo número fibonacci

public class FiboGoldenRatio {   //Valor aproximado del golden ratio
    // Approximate value of golden ratio 
    static double PHI = 1.6180339;
    // Números fibonacci hasta 5
    static int f[] = {0, 1, 1, 2, 3, 5};
    // Función que encuentra nesimo
    // número fibonacci
    static int fib(int n) {   // Números fibonacci menores a 6
        if (n &lt; 6) {
            return f[n];
        }
        // Si no comience conteo desde el quinto
        int t = 5;
        int fn = 5;
        while (t &lt; n) {
            fn = (int) Math.round(fn * PHI);
            t++;
        }
        return fn;
    }

    public static void main(String[] args) {
        int n = 9;
        System.out.println(n + &quot; número fibonacci= &quot;
                + fib(n));
    }
}
</java>
  <cpp>#include&lt;bits/stdc++.h&gt;
#include&lt;cstdlib&gt;
using namespace std;
const double phi = 1.6180339;
int f[] = {0, 1, 1, 2, 3, 5};

int fib(int n) {
    if (n &lt; 6) {
        return f[n];
    }
    int t = 5;
    int fn = 5;
    while (t &lt; n) {
        fn = (int) round(fn * phi);
        t++;
    }
    return fn;
}

int main() {
    for (int i = 0; i &lt; 10; i++) {
        cout &lt;&lt; fib(i) &lt;&lt; endl;
    }
} 
</cpp>
  <py>null</py>
  <orden>6</orden>
  <suborden>13</suborden>
  <fecha_creacion>2020-12-04 22:01:06</fecha_creacion>
  <fecha_modificacion>2020-12-06 20:23:05</fecha_modificacion>
</row>
<row>
  <ID>47</ID>
  <supergrupo>Matemática</supergrupo>
  <tema>Permutaciones</tema>
  <texto>Una permutación es la variación del orden o posición de los elementos de un conjunto ordenado o una tupla, hay dos tipos de permutaciones:
Se permite repetir: una cerradura de combinación de tres numeros, podría ser &quot;333&quot;.
Sin repetición: Los tres primeros puestos en una carrera. No puedes quedar primero y segundo a la vez.

 Permutaciones con repetición
Son las más fáciles de calcular. Si tiene n cosas para elegir y elige r de ellas, las permutaciones posibles son:
 n × n × ... (r veces) = nr
(Porque hay n posibilidades para la primera elección, luego hay n posibilidades para la segunda elección, y así.)
Por ejemplo en un candado de combinacion de 3 numeros, hay 10 números para elegir (0,1,...,9) y se elige 3 de ellos:
 10 × 10 × ... (3 veces) = 10^3 = 1000 permutaciones

Así que la fórmula es simplemente:
 n*r
donde n es el número de cosas que puede elegir, y elige r de ellas, dentro de estas permutaciones se puede repetir y el orden importa.

2. Permutaciones sin repetición
En este caso, se reduce el número de opciones en cada paso.
¿cómo se puede ordenar 16 bolas de billar?
Después de elegir por ejemplo la &quot;14&quot; no puede elegirla otra vez, así que la primera elección tiene 16 posibilidades, y la siguiente elección tiene 15 posibilidades, después 14, 13, hasta 1 Y el total de permutaciones sería:
 16 × 15 × 14 × 13 ... = 20.922.789.888.000
Pero a lo mejor no quiere elegirlas todas, sólo 3 de ellas, así que sería solamente:
 16 × 15 × 14 = 3360
Es decir, hay 3.360 maneras diferentes de elegir 3 bolas de billar de entre 16.
La función factorial “!” significa que se multiplican números descendentes, varios ejemplos de factoriales son:
 4! = 4 × 3 × 2 × 1 = 24
 7! = 7 × 6 × 5 × 4 × 3 × 2 × 1 = 5040
 1! = 1
 16! = 20.922.789.888.000
Pero si sólo quiere elegir 3, tiene que dejar de multiplicar después de 14. 
¿Cómo se puede escribir esto? Se divide entre 13!...
 16x15x14x13….. /13x12x11…. 
 16! / 13! = 16 × 15 × 14
La fórmula se escribe:
 n!/(n-r)!
donde n es el número de cosas que puede elegir, y elige r de ellas, dentro de este tipo e permutaciones no se puede repetir y  el orden importa.
</texto>
  <complejidad_tiempo>Mejor caso :    O(ecuación aplicable)        Peor caso : O(ecuación aplicable)      
 Promedio: O(ecuación aplicable)         
</complejidad_tiempo>
  <java>//Programa java que imprime todas las permutaciones
// con o sin repetición, r modifica el tamaño de las permutaciones
import java.util.Arrays;
import java.util.HashSet;
import java.util.Iterator;
import java.util.Set;

public class Permutations {

    static Set&lt;String&gt; permutations;
    static Set&lt;String&gt; result = new HashSet&lt;&gt;();
    static int cont = 0;

    static void permWithRepUtil(String str, char[] data,
            int last, int index) {
        int length = str.length();
        for (int i = 0; i &lt; length; i++) {
            data[index] = str.charAt(i);
            if (index == last) {
                System.out.println(new String(data));
                cont++;
            } else {
                permWithRepUtil(str, data, last,
                        index + 1);
            }
        }
    }

    static void permWithRep(String str) {
        int length = str.length();
        char[] data = new char[length + 1];
        char[] temp = str.toCharArray();
        Arrays.sort(temp);
        str = new String(temp);
        permWithRepUtil(str, data, length - 1, 0);
    }

    static void shuffle(char c) {
        if (permutations.isEmpty()) {
            permutations.add(String.valueOf(c));
        } else {
            Iterator&lt;String&gt; it = permutations.iterator();
            for (int i = 0; i &lt; permutations.size(); i++) {
                String temp1;
                while (it.hasNext()) {
                    temp1 = it.next();
                    for (int k = 0; k &lt; temp1.length() + 1; k++) {
                        StringBuilder sb = new StringBuilder(temp1);
                        sb.insert(k, c);
                        result.add(sb.toString());
                    }
                }
            }
            permutations = result;
            result = new HashSet&lt;&gt;();
        }
    }

    static Set&lt;String&gt; permutation(String string) {
        permutations = new HashSet&lt;&gt;();
        int n = string.length();
        for (int i = n - 1; i &gt;= 0; i--) {
            shuffle(string.charAt(i));
        }
        Set&lt;String&gt; aux = new HashSet&lt;&gt;();
        Iterator&lt;String&gt; it = permutations.iterator();
        while (it.hasNext()) {
            String aux2 = it.next();
            //Entre mas aumente r, mas pequeñas seran las permutations
            int r = 0;
            aux.add(aux2.substring(0, aux2.length() - 0));
        }
        return aux;

    }

    public static void main(String[] args) {
        String entrada = &quot;1234&quot;;
        Set&lt;String&gt; res = permutation(entrada);
        System.out.println(&quot;Hay en total &quot; + res.size() + &quot; permutations sin repetición de &quot; + entrada);
        Iterator&lt;String&gt; it = res.iterator();
        while (it.hasNext()) {
            System.out.println(it.next());
        }
        String entrada2 = &quot;ABC&quot;;
 permWithRep(entrada2);
        System.out.println(&quot;Hay en total &quot; + cont + &quot; permutations con repetición de &quot; + entrada2);
        
    }
}
</java>
  <cpp>#include &lt;iostream&gt;
#include &lt;set&gt;
#include &lt;string.h&gt;
#include &lt;algorithm&gt;

using namespace std;

int cont1 = 0;
int cont2 = 0;

void permWithOutRepetition(string str) {
    char ayuda[str.size()];
    strcpy(ayuda, str.c_str());
    do {
        ++cont1;
        cout &lt;&lt; ayuda &lt;&lt; endl;
    } while (next_permutation(ayuda, ayuda + str.size()));
}

void permWithRepUtil(string str, char data [], int last, int index) {
    int length = str.size();
    for (int i = 0; i &lt; length; i++) {
        data[index] = str[i];
        if (index == last) {
            cont2++;
            string ayuda = data;
            cout &lt;&lt; ayuda &lt;&lt; endl;
        } else {
            permWithRepUtil(str, data, last, index + 1);
        }
    }
}

void permWithRep(string str) {
    int length = str.size();
    char data[length + 1];
    char temp[length];
    strcpy(temp, str.c_str());
    sort(temp, temp + length);
    str = temp;
    permWithRepUtil(str, data, length - 1, 0);
}

int main() {
    ios_base::sync_with_stdio(false);
    cout.tie(NULL);
    cin.tie(NULL);
    string entrada = &quot;Terry&quot;;
    permWithOutRepetition(entrada);
    cout &lt;&lt; &quot;Hay en total &quot; &lt;&lt; cont1 &lt;&lt; &quot; permutaciones sin repeticion de &quot; &lt;&lt; entrada &lt;&lt; endl;
    cout &lt;&lt; &quot;\n\n&quot; &lt;&lt; endl;
    permWithRep(entrada);
    cout &lt;&lt; &quot;Hay en total &quot; &lt;&lt; cont2 &lt;&lt; &quot; permutaciones con repeticion de &quot; &lt;&lt; entrada &lt;&lt; endl;
} 
</cpp>
  <py>null</py>
  <orden>6</orden>
  <suborden>14</suborden>
  <fecha_creacion>2020-12-04 22:01:06</fecha_creacion>
  <fecha_modificacion>2020-12-06 20:23:06</fecha_modificacion>
</row>
<row>
  <ID>48</ID>
  <supergrupo>Matemática</supergrupo>
  <tema>Combinatorias</tema>
  <texto>La Combinatoria es la parte de las Matemáticas que estudia las diversas formas de realizar agrupaciones con los elementos de un conjunto, formándolas y calculando su número.
Existen distintas formas de realizar estas agrupaciones, según se repitan los elementos o no, según se puedan tomar todos los elementos de que disponemos o no y si influye o no el orden de colocación de los elementos.
El orden NO es importante. La notación para las combinaciones es C(n,r) que es la cantidad de combinaciones de “n” elementos seleccionados, “r” a la vez. Es igual a la cantidad de permutaciones de “n” elementos tomados “r” a la vez dividido por “r” factorial. 
- P(n,r)/r!.

Ejemplo: Si se seleccionan cinco cartas de un grupo de nueve, ¿cuantas combinaciones de cinco cartas habría?
La cantidad de combinaciones posibles sería:
-  P(9,5)/5! = (9*8*7*6*5)/(5*4*3*2*1) = 126 combinaciones posibles.
</texto>
  <complejidad_tiempo>Mejor caso :    O(ecuación aplicable)        Peor caso : O(ecuación aplicable)      
 Promedio: O(ecuación aplicable)         
</complejidad_tiempo>
  <java>//Programa java que imprime todas las combinaciones con o sin repetición
// de tamaño r en un arreglo de tamaño n

public class Combinations {

    static void combinationUtil(int arr[], int data[], int start,
            int end, int index, int r) {
        if (index == r) {
            for (int j = 0; j &lt; r; j++) {
                System.out.print(data[j] + &quot; &quot;);
            }
            System.out.println(&quot;&quot;);
            return;
        }

        for (int i = start; i &lt;= end &amp;&amp; end - i + 1 &gt;= r - index; i++) {
            data[index] = arr[i];
            combinationUtil(arr, data, i + 1, end, index + 1, r);
        }
    }

    static void combination(int arr[], int n, int r) {
        int data[] = new int[r];
        combinationUtil(arr, data, 0, n - 1, 0, r);
    }

    static void CombinationRepetitionUtil(int chosen[], int arr[],
            int index, int r, int start, int end) {
        if (index == r) {
            for (int i = 0; i &lt; r; i++) {
                System.out.printf(&quot;%d &quot;, arr[chosen[i]]);
            }
            System.out.printf(&quot;\n&quot;);
            return;
        }
        for (int i = start; i &lt; end; i++) {
            chosen[index] = i;
            CombinationRepetitionUtil(chosen, arr, index + 1,
                    r, i, end);
        }
        
    }

    static void CombinationRepetition(int arr[], int n, int r) {
        int chosen[] = new int[r + 1];
        CombinationRepetitionUtil(chosen, arr, 0, r, 0, n - 1);
    }

    public static void main(String[] args) {
        //Sin repetición
        int arr[] = {1, 2, 3, 4, 5};
        int r = 3;
        int n = arr.length;
        combination(arr, n, r);
        //Con repetición
        int arr2[] = {1, 2, 3, 4};
        int n2 = arr.length;
        int r2 = 2;
        CombinationRepetition(arr2, n2, r2);

    }
}
</java>
  <cpp>#include &lt;cstdlib&gt;
#include &lt;bits/stdc++.h&gt;
using namespace std;

void combinationUtil(int arr[], int data[], int start, int end, int index, int r) {
    if (index == r) {
        for (int j = 0; j &lt; r; j++) {
            cout &lt;&lt; data[j] &lt;&lt; &quot; &quot;;
        }
        cout &lt;&lt; endl;
        return;
    }
    for (int i = start; i &lt;= end &amp;&amp; end - i + 1 &gt;= r - index; i++) {
        data[index] = arr[i];
        combinationUtil(arr, data, i + 1, end, index + 1, r);
    }
}

void combination(int arr[], int n, int r) {
    int data[r];
    combinationUtil(arr, data, 0, n - 1, 0, r);
}

void combinationRepetitionUtil(int chosen[], int arr[], int index, int r, int start, int end) {
    if (index == r) {
        for (int i = 0; i &lt; r; i++) {
            cout &lt;&lt; arr[chosen[i]] &lt;&lt; &quot; &quot;;
        }
        cout &lt;&lt; endl;
        return;
    }
    for (int i = start; i &lt; end; i++) {
        chosen[index] = i;
        combinationRepetitionUtil(chosen, arr, index + 1, r, i, end);
    }
    return;
}

void combinationRepetition(int arr[], int n, int r) {
    int chosen[r + 1];
    combinationRepetitionUtil(chosen, arr, 0, r, 0, n - 1);
}

int main(int argc, char const *argv[]) {
    cout &lt;&lt; &quot;Sin Repeticion&quot; &lt;&lt; endl;
    int arr[] = {1, 2, 3, 4, 5};
    int r = 3;
    int n = sizeof (arr) / sizeof (arr[0]);
    combination(arr, n, r);
    cout &lt;&lt; &quot;Con Repeticion&quot; &lt;&lt; endl;
    int arr2[] = {1, 2, 3, 4};
    int n2 = sizeof (arr2) / sizeof (arr2[0]);
    int r2 = 2;
    combinationRepetition(arr2, n2, r2);
    return 0;
}
</cpp>
  <py>from sys import stdout
wr = stdout.write

cont1 = 0
cont2 = 0

def combUtil(arr, data, start, end, index, r):
    global cont1
    if index == r:
        for j in range(r):
            wr(f&#39;{data[j]} &#39;)
        wr(&#39;\n&#39;)
        cont1 += 1
        return
    i = start
    while i &lt;= end and end - i + 1 &gt;= r - index:
        data[index] = arr[i]
        combUtil(arr, data, i+1, end, index+1, r)
        i += 1

def combinationRepetitionUtil(chosen, arr, index, r, start, end):
    global cont2
    if index == r:
        for i in range(r):
            wr(f&#39;{arr[chosen[i]]} &#39;)
        wr(&#39;\n&#39;)
        cont2 += 1
        return
    for i in range(start, end):
        chosen[index] = i
        combinationRepetitionUtil(chosen, arr, index+1, r, i, end)
    return

def printComb(arr, n, r):
    data = [0 for x in range(r)]
    combUtil(arr, data, 0, n-1, 0, r)

def combinationRepetition(arr, n, r):
    chosen = [0 for x in range(r+1)]
    combinationRepetitionUtil(chosen, arr, 0, r, 0, n-1)

arrint1 = [1, 2, 3, 4, 5]
r1 = 3
n1 = len(arrint1)
printComb(arrint1, n1, r1)
wr(f&#39;Hay {str(cont1)} Combinaciones Sin Repetición\n&#39;)

arrint2 = [1, 2, 3, 4, 5]
r2 = 2
n2 = len(arrint2)
combinationRepetition(arrint2, n2, r2)
wr(f&#39;Hay {str(cont2)} Combinaciones Con Repetición&#39;)
</py>
  <orden>6</orden>
  <suborden>15</suborden>
  <fecha_creacion>2020-12-04 22:01:06</fecha_creacion>
  <fecha_modificacion>2020-12-06 20:23:07</fecha_modificacion>
</row>
<row>
  <ID>49</ID>
  <supergrupo>Matemática</supergrupo>
  <tema>Combinatorias compuestas</tema>
  <texto>Teniendo la teoría anterior clara, se puede modificar el algoritmo de tal forma que calcule las composiciones compuestas tal y como deseemos.</texto>
  <complejidad_tiempo>Mejor caso :    O(ecuación aplicable)        Peor caso : O(ecuación aplicable)      
 Promedio: O(ecuación aplicable)         
</complejidad_tiempo>
  <java>//Programa java que imprime todas
//las combinaciones que pueden componer un número dado

public class CombinationsCompose {
    //Función imprime todas las combinaciones de números 1, 2, ...MAX_POINT
    // que su suma resulte  n
    // i es usado en recursion para mantener revisión del indice
    // en arr[] donde el siguiente elemento sera añadido
    // Valor inicial de i debe ser pasado como 0

    static void printCompositions(int arr[], int n, int i) {
        int MAX_POINT = 3;
        if (n == 0) {
            printArray(arr, i);
        } else if (n &gt; 0) {
            for (int k = 1; k &lt;= MAX_POINT; k++) {
                arr[i] = k;
                printCompositions(arr, n - k, i + 1);
            }
        }
    }

    // Imprime array
    static void printArray(int arr[], int m) {
        for (int i = 0; i &lt; m; i++) {
            System.out.print(arr[i] + &quot; &quot;);
        }
        System.out.println();
    }

    public static void main(String[] args) {
        int n = 5;
        int size = 100;
        int[] arr = new int[size];
        System.out.println(&quot;Diferentes composiciones formadas por &quot;
                + &quot;1, 2 y 3 de &quot; + n + &quot; son &quot;);
        printCompositions(arr, n, 0);
    }
}
</java>
  <cpp>#include&lt;bits/stdc++.h&gt;
#include&lt;cstdlib&gt;
using namespace std;

void printArr(int arr[], int n) {
    for (int i = 0; i &lt; n; i++) {
        cout &lt;&lt; arr[i] &lt;&lt; &quot; &quot;;
    }
    cout &lt;&lt; endl;
}

void printCompositions(int arr[], int n, int i) {
    int MAX_POINT = 3;
    if (n == 0) {
        printArr(arr, i);
    } else if (n &gt; 0) {
        for (int k = 1; k &lt;= MAX_POINT; k++) {
            arr[i] = k;
            printCompositions(arr, n - k, i + 1);
        }
    }
}

int main() {
    int n = 5;
    int len = 100;
    int arr[len];
    printCompositions(arr, n, 0);
    return 0;
} 
</cpp>
  <py>null</py>
  <orden>6</orden>
  <suborden>16</suborden>
  <fecha_creacion>2020-12-04 22:01:06</fecha_creacion>
  <fecha_modificacion>2020-12-06 20:23:07</fecha_modificacion>
</row>
<row>
  <ID>50</ID>
  <supergrupo>Matemática</supergrupo>
  <tema>Subsets de un Set (Conjuntos)</tema>
  <texto>Un conjunto (set) es una colección de elementos con características similares considerada en sí misma como un objeto. Los elementos de un conjunto, pueden ser las siguientes: personas, números, colores, letras, figuras, etc.
Se dice que un elemento (o miembro) pertenece al conjunto si está definido como incluido de algún modo dentro de él.
</texto>
  <complejidad_tiempo>Mejor caso :    O(n2n)        Peor caso : O(n2n)      Promedio: O(n2n)         </complejidad_tiempo>
  <java>//Programa java que imprime todos los subconjuntos de 
//un conjunto

public class Allsets {

    static void printSubsets(char set[]) {
        int n = set.length;
        // Ejecuta un ciclo imprimiendo todos
        //  los subconjuntos 2^n uno por uno
        for (int i = 0; i &lt; (1 &lt;&lt; n); i++) {
            System.out.print(&quot;{ &quot;);
            //Imprime el subconjunto actual
            for (int j = 0; j &lt; n; j++) // (1&lt;&lt;j) es un número con jesimo bit 1
            {
                if ((i &amp; (1 &lt;&lt; j)) &gt; 0) {
                    System.out.print(set[j] + &quot; &quot;);
                }
            }
            System.out.println(&quot;}&quot;);
        }
    }

    public static void main(String[] args) {
        char set[] = {&#39;a&#39;, &#39;b&#39;, &#39;c&#39;};
        printSubsets(set);
    }
}
</java>
  <cpp>#include&lt;bits/stdc++.h&gt;
#include&lt;cstdlib&gt;
using namespace std;

void printSubset(char sets[], int n) {
    for (int i = 0; i &lt; (1 &lt;&lt; n); i++) {
        cout &lt;&lt; &quot;{&quot;;
        for (int j = 0; j &lt; n; j++) {
            if ((i &amp; (1 &lt;&lt; j))) {
                cout &lt;&lt; sets[j] &lt;&lt; &quot; &quot;;
            }
        }
        cout &lt;&lt; &quot;}&quot; &lt;&lt; endl;
    }
}

int main() {
    char conjunto[] = {&#39;a&#39;, &#39;b&#39;, &#39;c&#39;};
    int n = sizeof conjunto / sizeof conjunto[0];
    printSubset(conjunto, n);
}
</cpp>
  <py>from sys import stdout
wr = stdout.write


def printSubsets(sset):
    n = len(sset)
    for i in range(1 &lt;&lt; n):
        wr(&#39;{ &#39;)
        for j in range(n):
            if (i &amp; (1 &lt;&lt; j)) &gt; 0:
                wr(f&#39;{sset[j]} &#39;)
        wr(&#39;}\n&#39;)
        
        
conjunto = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]
printSubsets(conjunto)
</py>
  <orden>6</orden>
  <suborden>17</suborden>
  <fecha_creacion>2020-12-04 22:01:06</fecha_creacion>
  <fecha_modificacion>2020-12-06 20:23:08</fecha_modificacion>
</row>
<row>
  <ID>51</ID>
  <supergrupo>Matemática</supergrupo>
  <tema>Coeficientes binomiales</tema>
  <texto>Los coeficientes binomiales, números combinatorios o combinaciones son números estudiados en combinatoria que corresponden al número de formas en que se puede extraer subconjuntos a partir de un conjunto dado.</texto>
  <complejidad_tiempo>Mejor caso :    O(n+k)        Peor caso : O(n+k)      Promedio: O(n+k)         </complejidad_tiempo>
  <java>// Programa java que  calcula el valor
// de coeficientes binomiales

public class BinomialCoefficients {
    // Retorna el valor del coeficiente binomial
    // C(n, k)  
    static int binomialCoeff(int n, int k) {
        // Casos base
        if (k == 0 || k == n) {
            return 1;
        }
        // Recursión
        return binomialCoeff(n - 1, k - 1)
                + binomialCoeff(n - 1, k);
    }

    public static void main(String[] args) {
        int n = 5, k = 2;
        System.out.printf(&quot;Valor de C(%d, %d) is %d &quot;,
                n, k, binomialCoeff(n, k));
    }
}
</java>
  <cpp>#include&lt;bits/stdc++.h&gt;
#include&lt;cstdlib&gt;
using namespace std;

int BinomialCoeff(int n, int k) {
    if (k == 0 || k == n) {
        return 1;
    }
    return BinomialCoeff(n - 1, k - 1) + BinomialCoeff(n - 1, k);
}

int main() {
    int n = 5, k = 2;
    printf(&quot;valor de C(%d, %d) is %d&quot;, n, k, BinomialCoeff(n, k));
} 
</cpp>
  <py>null</py>
  <orden>6</orden>
  <suborden>18</suborden>
  <fecha_creacion>2020-12-04 22:01:06</fecha_creacion>
  <fecha_modificacion>2020-12-06 20:23:09</fecha_modificacion>
</row>
<row>
  <ID>52</ID>
  <supergrupo>Matemática</supergrupo>
  <tema>Torres de Hanoi</tema>
  <texto>Las Torres de Hanói son un rompecabezas o juego matemático inventado en 1883 por el matemático francés Édouard Lucas. Este juego de mesa individual consiste en un número de discos perforados de radio creciente que se apilan insertándose en uno de los tres postes fijados a un tablero. El objetivo del juego es trasladar la pila a otro de los postes siguiendo ciertas reglas, como que no se puede colocar un disco más grande encima de un disco más pequeño. El problema es muy conocido en la ciencia de la computación y aparece en muchos libros de texto como introducción a la teoría de algoritmos.
La fórmula para encontrar el número de movimientos necesarios para transferir n discos desde un poste a otro es: 2n – 1.
</texto>
  <complejidad_tiempo>Mejor caso :    O(2n)        Peor caso : O(2n)      Promedio: O(2n)         </complejidad_tiempo>
  <java>//Programa java que calcula los movimientos
// necesarios para completar las torres de Hanoi
// Sin importar el número de discos n

public class HanoiTowels {

    public static void main(String[] args) {
        //Número de discos
        int n;
        n = 8;
        hanoi(n, &quot;Primera torre&quot;, &quot;Segunda torre&quot;, &quot;Tercera torre&quot;);
    }
    static int paso = 1;
    //Función recursiva de busqueda
    static void hanoi(int n, String from, String temp, String to) {
        if (n == 0) {
            return;
        }
        hanoi(n - 1, from, to, temp);
        System.out.println(paso + &quot;: Mover disco &quot; + n + 
                &quot; de &quot; + from + &quot; a &quot; + to);
        paso++;
        hanoi(n - 1, temp, from, to);
    }
}
</java>
  <cpp>#include&lt;bits/stdc++.h&gt;
#include&lt;cstdlib&gt;
using namespace std;
int paso = 1;

void hanoi(int n, string from, string temp, string to) {
    if (n == 0) {
        return;
    }
    hanoi(n - 1, from, to, temp);
    cout &lt;&lt; paso &lt;&lt; &quot; mover disco &quot; &lt;&lt; n &lt;&lt; &quot; de &quot; &lt;&lt; from &lt;&lt; &quot; a &quot; &lt;&lt; to &lt;&lt; endl;
    paso++;
    hanoi(n - 1, temp, from, to);
}

int main() {
    int n = 8;
    hanoi(n, &quot;Primer Torre&quot;, &quot;Segunda Torre&quot;, &quot;Tercer Torre&quot;);
    return 0;
} 
</cpp>
  <py>null</py>
  <orden>6</orden>
  <suborden>19</suborden>
  <fecha_creacion>2020-12-04 22:01:06</fecha_creacion>
  <fecha_modificacion>2020-12-06 20:23:09</fecha_modificacion>
</row>
<row>
  <ID>53</ID>
  <supergrupo>Matemática</supergrupo>
  <tema>AX+BY=N</tema>
  <texto>Dado a, b y n. Encuentre x y y  que satisfaga ax+by=n, imprima cualquiera de los x y y que cumplan la ecuación.
Podemos verificar si alguna solución existe o no usando ecuaciones lineales de Diofanes, pero ahí se necesita encontrar para esta ecuación, entonces se puede simplemente iterar por todos los posibles valores de 0 a n sin exceder n para esta ecuación. Entonces resolviendo esta ecuación con lápiz y papel obtenemos y=(n-ax)/b y similarmente obtenemos el otro número con x=(n-by)/a, si ninguno de los valores satisface la ecuación, al final imprime “Sin solución”.
</texto>
  <complejidad_tiempo>Mejor caso :    O(n)        Peor caso : O(n)      Promedio: O(n)         </complejidad_tiempo>
  <java>//Programa que calcula la solución de
// ax + by = n 

public class AXplusBYequalsN {

    static void solution(int a, int b, int n) {
        //A traves de todos los posibles valores
        for (int i = 0; i * a &lt;= n; i++) {
            //Verifica si se satisface la ecuación
            if ((n - (i * a)) % b == 0) {
                System.out.println(&quot;x = &quot; + i
                        + &quot;, y = &quot;
                        + (n - (i * a)) / b);
                return;
            }
        }
        System.out.println(&quot;Sin solución&quot;);
    }

    public static void main(String[] args) {
        int a = 2, b = 3, n = 7;
        solution(a, b, n);
    }
}
</java>
  <cpp>#include &lt;iostream&gt;

using namespace std;

void solution(int a, int b, int n) {
    for (int i = 0; i * a &lt;= n; i++) {
        if ((n - (i * a)) % b == 0) {
            cout &lt;&lt; &quot;x: &quot; &lt;&lt; i &lt;&lt; &quot;, y: &quot; &lt;&lt; ((n - (i * a)) / b) &lt;&lt; endl;
            return;
        }
    }
    cout &lt;&lt; &quot;No hay solucion&quot; &lt;&lt; endl;
}

int main() {
    int a = 2, b = 3, n = 16;
    solution(a, b, n);
    return 0;
}
</cpp>
  <py>from sys import stdout

def solution(a, b, n):
    i = 0
    while i * a &lt;= n:
        if (n - (i * a)) % b == 0:
            stdout.write(f&quot;x = {i} y = {(n-(i*a))/b}&quot;)
            return
        i += 1
    stdout.write(&quot;No tiene soluciÃ³n \n&quot;)

a, b, n = 2, 3, 7
solution(a, b, n)

</py>
  <orden>6</orden>
  <suborden>20</suborden>
  <fecha_creacion>2020-12-04 22:01:06</fecha_creacion>
  <fecha_modificacion>2020-12-06 20:23:10</fecha_modificacion>
</row>
<row>
  <ID>54</ID>
  <supergrupo>Matemática</supergrupo>
  <tema>A%X=B</tema>
  <texto>Dados dos números a y b, encontrar todos los x que permitan a%x=b.
Existen tres casos:
- Si  a es menor que b entonces no habrá respuesta.
- Si a es igual que b entonces todos los números más grandes que a, habrá infinitas soluciones.
- Si a es mayor que b, supone que x es una respuesta a nuestra ecuación. Entonces x divide (a-b) también desde a%x=b entonces b es menor que x
</texto>
  <complejidad_tiempo>Mejor caso :    O(n)        Peor caso : O(n)      Promedio: O(n)         </complejidad_tiempo>
  <java>/* Programa java que encuentra x tal que
a % x es igual  b.*/
public class AmodXequalB {

    static void modularEquation(int a, int b) {
        // Si a es menos que b, entonces no hay solución
        if (a &lt; b) {
            System.out.println(&quot;No solution possible &quot;);
            return;
        }
        /*Si a es igual a b, entonces cada número 
        más grande que a sera la solución, entonces
        es infinito*/
        if (a == b) {
            System.out.println(&quot;Infinite Solution possible &quot;);
            return;
        }
        /*todo el número resultante debe ser mayor
        que b y (a-b) deben ser divisibles
        por número resultante
        variable count almacena el número de
        valores posibles*/
        int count = 0;
        int n = a - b;
        int y = (int) Math.sqrt(a - b);
        for (int i = 1; i &lt;= y; ++i) {
            if (n % i == 0) {
                /*Revisando por ambos divisor y 
                cociente cual divide (a-b) completamente
                y mayor que b*/
                if (n / i &gt; b) {
                    count++;
                }
                if (i &gt; b) {
                    count++;
                }
            }
        }
        /* Aqui y es añadido dos veces en la
        ultima iteracón entonces y deberia ser decrementado
        para obtener la solución correcta*/
        if (y * y == n &amp;&amp; y &gt; b) {
            count--;
        }
        System.out.println(count);
    }

    public static void main(String[] args) {
        int a = 21, b = 5;
        modularEquation(a, b);
    }
}
</java>
  <cpp>#include&lt;bits/stdc++.h&gt;
#include&lt;cstdlib&gt;
using namespace std;

void modEquation(int a, int b) {
    if (a &lt; b) {
        cout &lt;&lt; &quot;no hay solucion&quot; &lt;&lt; endl;
        return;
    }
    if (a == b) {
        cout &lt;&lt; &quot;infinitas soluciones&quot; &lt;&lt; endl;
        return;
    }
    int cont = 0;
    int n = a - b;
    int y = std::sqrt(a - b);

    for (int i = 1; i &lt;= y; i++) {
        if (n % i == 0) {
            if (n / i &gt; b) {
                cont++;
                cout &lt;&lt; (n / i) &lt;&lt; &quot; &quot;;
            }
            if (i &gt; b) {
                cont++;
                cout &lt;&lt; i &lt;&lt; &quot; &quot;;
            }
        }
    }
    cout &lt;&lt; endl;
    if (y * y == n &amp;&amp; y &gt; b) {
        cont--;
    }
    cout &lt;&lt; cont &lt;&lt; endl;
}

int main() {
    //a%x=b;
    int a = 21, b = 5;
    modEquation(a, b);
}
</cpp>
  <py>import math
from sys import stdout
wr = stdout.write


def modEquation(a, b):
    if a &lt; b:
        wr(f&#39;No hay Solucion&#39;)
        return
    if a == b:
        wr(f&#39;Infinitas Soluciones&#39;)
    cont = 0
    n = a - b
    y = int(math.sqrt(a-b))
    for i in range(1, y + 1):
        if n % i == 0:
            if n // i &gt; b:
                cont += 1
                wr(f&#39;{n//i}\n&#39;)
            if i &gt; b:
                cont += 1
                wr(f&#39;{i}\n&#39;)
    if y * y == n and y &gt; b:
        cont -= 1
    wr(f&#39;{cont}&#39;)


a = 21
b = 5
modEquation(a, b)
</py>
  <orden>6</orden>
  <suborden>22</suborden>
  <fecha_creacion>2020-12-04 22:01:06</fecha_creacion>
  <fecha_modificacion>2020-12-06 20:23:10</fecha_modificacion>
</row>
<row>
  <ID>55</ID>
  <supergrupo>Matemática</supergrupo>
  <tema>E pow X</tema>
  <texto>El valor de la función exponencial e^x puede ser expresado usando la siguiente serie de Taylor:
- e^x = 1 + x/1! + x^2/2! + x^3/3! + ...... 
¿Cómo calcular eficientemente la suma de la serie de arriba? Puede ser escrita de la siguiente forma:
- e^x = 1 + (x/1) (1 + (x/2) (1 + (x/3) (........)))
</texto>
  <complejidad_tiempo>Mejor caso :    O(n)        Peor caso : O(n)      Promedio: O(n)         </complejidad_tiempo>
  <java>// Programa eficiente que calcula e elevado x

public class EpowX {
    // Función que retorna aproximado de e^x
    // Usando suma de los primeros n terminos
    // de la serie de Taylor 
    static float exponential(int n, float x) {
        float sum = 1;
        for (int i = n - 1; i &gt; 0; --i) {
            sum = 1 + x * sum / i;
        }
        return sum;
    }

    public static void main(String[] args) {
        int n = 10;
        float x = 1;
        System.out.println(&quot;e^x = &quot; + exponential(n, x));
    }
}
</java>
  <cpp>#include &lt;iostream&gt;
#include &lt;iomanip&gt;

using namespace std;

double exp(int n, double x) {
    double sum = 1;
    for (int i = n - 1; i &gt; 0; i--) {
        sum = 1 + x * sum / i;
    }
    return sum;
}

int main() {
    ios_base::sync_with_stdio(false);
    cout.tie(NULL);
    int n = 10;
    double x = 2;
    cout &lt;&lt; &quot;exp: &quot; &lt;&lt; setprecision(25) &lt;&lt; exp(n, x) &lt;&lt; endl;
    cout &lt;&lt; &quot;exp: &quot; &lt;&lt; setprecision(25) &lt;&lt; exp(n + 10, x) &lt;&lt; endl;
    return 0;
}
</cpp>
  <py>from sys import stdout
wr = stdout.write

def exp(n, x):
    suma = 1
    for i in range(n-1, 0, -1):
        suma = 1 + x * suma / i
    return suma

n = 10
x = 2
wr(f&#39;exp = {exp(n,x)}\n&#39;)
wr(f&#39;exp = {exp(n+10,x)}&#39;)
</py>
  <orden>6</orden>
  <suborden>23</suborden>
  <fecha_creacion>2020-12-04 22:01:06</fecha_creacion>
  <fecha_modificacion>2020-12-06 20:23:11</fecha_modificacion>
</row>
<row>
  <ID>56</ID>
  <supergrupo>Matemática</supergrupo>
  <tema>Factorial</tema>
  <texto>El factorial de un entero positivo n, el factorial de n o n factorial se define en principio como el producto de todos los números enteros positivos desde 1 (es decir, los números naturales) hasta n.
La operación de factorial aparece en muchas áreas de las matemáticas, particularmente en combinatoria y análisis matemático. De manera fundamental la factorial de n representa el número de formas distintas de ordenar n objetos distintos (elementos sin repetición).
</texto>
  <complejidad_tiempo>Mejor caso :    O(n)        Peor caso : O(n)      Promedio: O(n)         </complejidad_tiempo>
  <java>// Programa java que encuentra el 
// factorial de un número

public class Factorial {

    static int factorial(int n) {
        if (n == 0) {
            return 1;
        }
        return n * factorial(n - 1);
    }

    public static void main(String[] args) {
        int num = 5;
        System.out.println(&quot;Factorial de &quot; + num + &quot; es &quot; + factorial(5));
    }
}
</java>
  <cpp>#include&lt;bits/stdc++.h&gt;
#include&lt;cstdlib&gt;
using namespace std;
typedef long long int ll;
ll factorial(ll n){
    if(n==0){
        return 1;
    }
    return n*(factorial(n-1));
}
int main() {
    cout&lt;&lt;factorial(10)&lt;&lt;endl;
}
</cpp>
  <py>from sys import stdout
wr = stdout.write

def factorial(n):
    if n == 0:
        return 1
    return n * factorial(n-1)

res = 5
wr(f&#39;{factorial(res)}&#39;)
</py>
  <orden>6</orden>
  <suborden>24</suborden>
  <fecha_creacion>2020-12-04 22:01:06</fecha_creacion>
  <fecha_modificacion>2020-12-06 20:23:12</fecha_modificacion>
</row>
<row>
  <ID>57</ID>
  <supergrupo>Matemática</supergrupo>
  <tema>Factorial largo</tema>
  <texto>Al igual que con otras secuencias numéricas, el cálculo de números grandes puede ser un problema debido a que pueden no caber dentro de una variable en específico, o ser muy lentas al calcularlo, el siguiente código presenta una forma optimizada de calcular factoriales grandes sin sacrificar tanto tiempo de ejecución, aunque para números demasiado grandes puede seguir siendo demasiado lento.</texto>
  <complejidad_tiempo>Mejor caso :    O(n)        Peor caso : O(n)      Promedio: O(n)         </complejidad_tiempo>
  <java>// Programa java que calcula factoriales
// de números enormes

public class BigFactorial {

    static void factorial(int n) {
        int res[] = new int[500];
        res[0] = 1;
        int res_size = 1;
        // Aplicamos la formula normal de facotorial
        // n! = 1 * 2 * 3 * 4...*n 
        for (int x = 2; x &lt;= n; x++) {
            res_size = multiply(x, res, res_size);
        }

        System.out.println(&quot;Factorial del numero dado es &quot;);
        for (int i = res_size - 1; i &gt;= 0; i--) {
            System.out.print(res[i]);
        }
    }

    static int multiply(int x, int res[], int res_size) {
        int carry = 0; // inicializar carry
        // Uno por uno multiplicamos n con 
        //los digitos individuales de res[] 
        for (int i = 0; i &lt; res_size; i++) {
            int prod = res[i] * x + carry;
            res[i] = prod % 10; //Almacenar ultimo digito de  
            // &#39;prod&#39; en res[] 
            carry = prod / 10; // Poner el resto de carry 
        }
        //Pone el carry en res e incrementa el tamaño del resultadolt size 
        while (carry != 0) {
            res[res_size] = carry % 10;
            carry = carry / 10;
            res_size++;
        }
        return res_size;
    }

    public static void main(String args[]) {
        factorial(100);
    }
}
</java>
  <cpp>#include &lt;iostream&gt;

using namespace std;

int multiply(int x, int res[], int res_size) {
    int carry = 0;
    for (int i = 0; i &lt; res_size; i++) {
        int prod = res[i] * x + carry;
        res[i] = prod % 10;
        carry = prod / 10;
    }
    while (carry != 0) {
        res[res_size] = carry % 10;
        carry /= 10;
        res_size++;
    }
    return res_size;
}

void factorial(int n) {
    int res[10000];
    res[0] = 1;
    int res_size = 1;
    for (int i = 2; i &lt;= n; i++) {
        res_size = multiply(i, res, res_size);
    }
    cout &lt;&lt; &quot;Factorial del numero dado es:&quot; &lt;&lt; endl;
    for (int i = res_size - 1; i &gt;= 0; i--) {
        cout &lt;&lt; res[i];
    }
    cout &lt;&lt; endl;
}

int main() {
    factorial(100);
    return 0;
}
</cpp>
  <py>from sys import stdout
wr = stdout.write

def multilply(x, res, res_size):
    carry = 0
    for i in range(res_size):
        prod = res[i] * x + carry
        res[i] = prod % 10
        carry = prod // 10
    while carry != 0:
        res[res_size] = carry % 10
        carry //= 10
        res_size += 1
    return res_size

def factorial(n):
    res = [0 for x in range(500)]  # Maximo digitos de n
    res[0] = 1
    res_size = 1
    for i in range(2, n + 1):
        res_size = multilply(i, res, res_size)
    wr(f&#39;Factorial de {n} es: \n&#39;)
    for i in range(res_size-1, -1, -1):
        wr(f&#39;{res[i]}&#39;)

factorial(100)
</py>
  <orden>6</orden>
  <suborden>25</suborden>
  <fecha_creacion>2020-12-04 22:01:06</fecha_creacion>
  <fecha_modificacion>2020-12-06 20:23:12</fecha_modificacion>
</row>
<row>
  <ID>58</ID>
  <supergrupo>Matemática</supergrupo>
  <tema>Numero de dígitos de un factorial</tema>
  <texto>Dado un entero n, encuentre el número de dígitos que aparecen en este factorial, donde factorial es definido como, factorial(n) =1*2*3*4……..*n y factorial (0) = 1…………
Una solución ingenua puede ser calcular n! primero y luego calcular el número de dígitos presentes en el, sin embargo el valor de n! poder ser muy largo. Se vuelve algo complicado de almacenar esta variable (A menos que estés trabajando en Python).
Una mejor solución puede ser usar las útiles propiedades de los logaritmos para calcular la respuesta.
Sabemos que:
- log(a*b) = log(a) + log(b)
Por lo tanto:
- log ( n!) = log (1*2*3....... * n)     = log (1) + log (2) +........ +log(n)
Ahora, observamos que el valor piso del logaritmo base 10 incrementado 1 de cualquier número da el número de dígitos presentes en ese número.
Entonces la salida puede ser: floor (log(n!)) + 1.</texto>
  <complejidad_tiempo>Mejor caso :    O(n)        Peor caso : O(n)      Promedio: O(n)         </complejidad_tiempo>
  <java>// Programa java que encuentra número de 
// digitos en un factorial

public class FactorialNumDigits {   // Retorna el número de digtos
    // en n! 

    static int findDigits(int n) {   // Factorial existe solo para n&gt;=0 
        if (n &lt; 0) {
            return 0;
        }
        // Caso base
        if (n &lt;= 1) {
            return 1;
        }
        // si no itera atravez de n y calcula el valor
        double digits = 0;
        for (int i = 2; i &lt;= n; i++) {
            digits += Math.log10(i);
        }
        return (int) (Math.floor(digits)) + 1;
    }

    public static void main(String[] args) {
        System.out.println(findDigits(1));
        System.out.println(findDigits(5));
        System.out.println(findDigits(10));
        System.out.println(findDigits(120));
    }
}</java>
  <cpp>#include&lt;bits/stdc++.h&gt;
#include&lt;cstdlib&gt;
using namespace std;

int FindDigits(int n) {
    if (n &lt; 0) {
        return 0;
    }
    if (n == 1) {
        return 1;
    }
    double digits = 0;
    for (int i = 2; i &lt;= n; i++) {
        digits += (std::log10(i));
    }
    return (int) (std::floor(digits)) + 1;
}

int main() {
    cout &lt;&lt; FindDigits(1000) &lt;&lt; endl;
    cout &lt;&lt; FindDigits(5) &lt;&lt; endl;
    cout &lt;&lt; FindDigits(20) &lt;&lt; endl;
    cout &lt;&lt; FindDigits(100) &lt;&lt; endl;
}
</cpp>
  <py>import math
from sys import stdout
wr = stdout.write

def findDigits(n):
    if n &lt; 0:
        return 0
    if n &lt;= 1:
        return 1
    digits = 0
    for i in range(2, n+1):
        digits += math.log10(i)
    return int(math.floor(digits)+1)

wr(f&#39;{findDigits(1000000)}&#39;)
</py>
  <orden>6</orden>
  <suborden>26</suborden>
  <fecha_creacion>2020-12-04 22:01:06</fecha_creacion>
  <fecha_modificacion>2020-12-06 20:23:13</fecha_modificacion>
</row>
<row>
  <ID>59</ID>
  <supergrupo>Matemática</supergrupo>
  <tema>Numero de dígitos de un factorial optimizado</tema>
  <texto>Si la solución anterior no es lo suficientemente rápida, podemos usar la fórmula de Kamenetsky para obtener la respuesta.
Se aproxima al número de dígitos en una factorial con:
- f(x) =    log10( ((n/e)^n) * sqrt(2*pi*n))
Además podemos fácilmente usar las propiedades de los logaritmos para obtener:
- f(x) = n* log10(( n/ e)) + log10(2*pi*n)/2 
Esta solución puede manejar número muy grandes de entrada, que pueden caber en un entero de 32 bits, e incluso más que esto.
</texto>
  <complejidad_tiempo>Mejor caso :    O(1)        Peor caso : O(1)      Promedio: O(1)         </complejidad_tiempo>
  <java>// Programa java que encuentra el número de digitos
// en un factorial

public class FactorialNumDigitsOP {

    public static double M_E = 2.71828182845904523536;
    public static double M_PI = 3.141592654;

    /* Funcion que retorna el número de digitos presente en 
    n! desde que el resultado sea muy largo*/
    static long findDigits(int n) {

        if (n &lt; 0) {
            return 0;
        }

        // caso base
        if (n &lt;= 1) {
            return 1;
        }
        // Usamos la formula de Kamenestsky para
        // calcular el número de digitos
        double x = (n * Math.log10(n / M_E)
                + Math.log10(2 * M_PI * n)
                / 2.0);

        return (long) Math.floor(x) + 1;
    }

    public static void main(String[] args) {
        System.out.println(findDigits(1));
        System.out.println(findDigits(50000000));
        System.out.println(findDigits(1000000000));
        System.out.println(findDigits(120));
    }
}
</java>
  <cpp>#include&lt;bits/stdc++.h&gt;
#include&lt;cstdlib&gt;
using namespace std;
const double PI = 3.14159265358979323846;
const double E = 2.71828182845904523536;

long FindDigitsKame(int n) {
    if (n &lt; 0) {
        return 0;
    }
    if (n &lt;= 1) {
        return 1;
    }
    double x = (n * log10(n / E)) + std::log10(2 * PI * n) / 2.0;
    return (long) (std::floor(x)) + 1;
}

int main() {
    cout &lt;&lt; FindDigitsKame(1000000) &lt;&lt; endl;
}
</cpp>
  <py>import math
from sys import stdout
wr = stdout.write

def findDigits(n):
    if n &lt; 0:
        return 0
    if n &lt;= 1:
        return 1
    x = (n * math.log10(n / math.e) + math.log10(2 * math.pi * n) / 2)
    return int(math.floor(x) + 1)

wr(f&#39;{findDigits(10000)}&#39;)
</py>
  <orden>6</orden>
  <suborden>27</suborden>
  <fecha_creacion>2020-12-04 22:01:06</fecha_creacion>
  <fecha_modificacion>2020-12-06 20:23:13</fecha_modificacion>
</row>
<row>
  <ID>60</ID>
  <supergrupo>Matemática</supergrupo>
  <tema>Teorema de Euclides-Euler</tema>
  <texto>De acuerdo con el teorema de Euclides-Euler, un número perfecto el cual es par, puede ser representado de la forma (2^n - 1)*(2^n / 2))) donde n es un número primo y 2^n – 1 es un número primo de Mersenne. Este es un producto de la potencia de 2 con un primo Mersenne, este teorema establece una conexión entre un número primo de Mersenne y un número par primo perfecto. Un número perfecto es aquél que es igual a la suma de sus divisores, exceptuando él mismo.
Algunos ejemplos de números perfectos los cuales satisfacen este teorema son:
- 6, 28, 496, 8128, 33550336, 8589869056, 137438691328
Explicación:
-  6 es un número perfecto par.
Entonces puede ser escrito de la forma 
- (2^2 - 1) * (2^ (2 - 1)) = 6
Donde n =2 es un número primo y 2^n -1=3 es un número primo de Mersenne
Toma cada número primo y forma un primo de Mersenne con él. El primo de Mersenne = 2^n – 1 donde n es primo. Ahora se forma el número (2^n – 1)*(2^(n – 1)) y verificamos si es par y perfecto.
</texto>
  <complejidad_tiempo>Mejor caso :    O(n)        Peor caso : O(n)      Promedio: O(n)         </complejidad_tiempo>
  <java>//Programa que verifica el teorema de Euclides Euler

import java.util.ArrayList;

public class EuclidEulerTheorem {
    static ArrayList&lt;Long&gt; power2 = new ArrayList&lt;Long&gt;();
    
    public static void main(String[] args) {
        //Almacenando potencias de 2 para acceder 
        // en tiempo O(1) 
        for (int i = 0; i &lt; 62; i++) {
            power2.add(0L);
        }

        for (int i = 0; i &lt;= 60; i++) {
            power2.set(i, (1L &lt;&lt; i));
        }
        System.out.println(&quot;Generando los primeros números que satisfacen &quot;
                + &quot;el teorema de Euclid Euler\n&quot;);
        for (long i = 2; i &lt;= 25; i++) {
            long no = ((power2.get((int) i) - 1L) * (power2.get((int) (i - 1))));
            if (isperfect(no) &amp;&amp; (no % 2 == 0)) {
                System.out.println(&quot;(2^&quot; + i + &quot; - 1) * (2^(&quot; + i + &quot; - 1)) = &quot; 
                        + no + &quot;\n&quot;);
            }
        }
    }

    static boolean isperfect(long n) // Números perfectos
    {
        /* Verifica si n es suma perfecta de dividores
        excepto por el número en si mismo*/
        long s = -n;
        for (long i = 1; i * i &lt;= n; i++) {
            // es i un divisor de n
            if (n % i == 0) {
                long factor1 = i, factor2 = n / i;
                s += factor1 + factor2;
                // aqui i*i == n
                if (factor1 == factor2) {
                    s -= i;
                }
            }
        }
        return (n == s);
    }

    boolean isprime(long n) {
        // Verifica cual número es primo o no
        for (int i = 2; i * i &lt;= n; i++) {
            if (n % i == 0) {
                return false;
            }
        }
        return false;
    }
}
</java>
  <cpp>#include&lt;bits/stdc++.h&gt;
#include&lt;cstdlib&gt;
//---------------//
using namespace std;
typedef long long int ll;
ll power2[1000];

bool isPerfect(ll n) {
    ll s = -n;
    for (ll i = 1; i * i &lt;= n; i++) {
        if (n % i == 0) {
            ll factor1 = i, factor2 = n / i;
            s += factor1 + factor2;
            if (factor1 == factor2) {
                s -= i;
            }
        }
    }
    return (n == s);
}

bool isPrime(ll n) {
    for (ll i = 2; i * i &lt;= n; i++) {
        if (n % i == 0) {
            return false;
        }
    }
    return false;
}

int main() {
    memset(power2, 0L, sizeof power2);
    for (int i = 0; i &lt; 62; i++) {
        power2[i] = 0L;
    }
    for (int i = 0; i &lt;= 60; i++) {
        power2[i] = (1L &lt;&lt; i);
    }
    cout &lt;&lt; &quot;Generando los primeros numeros que satiscafacen el teorema&quot; &lt;&lt; endl;
    for (ll i = 2; i &lt;= 25; i++) {
        ll no = ((power2[(int) i] - 1L) * power2[(int) (i - 1)]);
        if (isPerfect(no) &amp;&amp; (no % 2 == 0)) {
            cout &lt;&lt; &quot;(2^&quot; &lt;&lt; i &lt;&lt; &quot; -1 * (2^(&quot; &lt;&lt; i &lt;&lt; &quot; -1)) = &quot; &lt;&lt; no &lt;&lt; endl;
        }
    }
} 
</cpp>
  <py>null</py>
  <orden>6</orden>
  <suborden>28</suborden>
  <fecha_creacion>2020-12-04 22:01:06</fecha_creacion>
  <fecha_modificacion>2020-12-06 20:23:14</fecha_modificacion>
</row>
<row>
  <ID>61</ID>
  <supergrupo>Matemática</supergrupo>
  <tema>Algoritmo Euclidiano</tema>
  <texto>El MCD de dos números es el número más grande que divide ambos. Una forma simple de encontrar este número es factorizar ambos números y multiplicar los factores comunes.
El algoritmo se basa en lo siguiente:

- Si resta el número más pequeño del más grande, MCD (GCD) no cambia, entonces si sigue restando repetidamente el más grande dos, termina con MCD.
- Ahora en vez de restar, si divide el número más pequeño, el algoritmo termina cuando se encuentra residuo 0.
</texto>
  <complejidad_tiempo>Mejor caso :    O(Log min(a, b))  Peor caso : O(Log min(a, b))      Promedio: O(Log min(a, b))         </complejidad_tiempo>
  <java>//Programa java que demuestra el algoritmo de Euclides  

public class EuclideanAlgorithm {
    // Algoritmo de euclides extendido
    public static int gcd(int a, int b) {
        if (a == 0) {
            return b;
        }
        return gcd(b % a, a);
    }

    public static void main(String[] args) {
        int a = 10, b = 15, g;
        g = gcd(a, b);
        System.out.println(&quot;GCD(&quot; + a + &quot; , &quot; + b + &quot;) = &quot; + g);
        a = 35;
        b = 10;
        g = gcd(a, b);
        System.out.println(&quot;GCD(&quot; + a + &quot; , &quot; + b + &quot;) = &quot; + g);
        a = 31;
        b = 2;
        g = gcd(a, b);
        System.out.println(&quot;GCD(&quot; + a + &quot; , &quot; + b + &quot;) = &quot; + g);
    }
}
</java>
  <cpp>#include&lt;bits/stdc++.h&gt;
#include&lt;cstdlib&gt;
//---------------//
using namespace std;

int GCD(int a, int b) {
    if (a == 0) {
        return b;
    }
    return GCD(b % a, a);
}

int main() {
    int a = 10;
    int b = 15;
    cout &lt;&lt; &quot;GCD&quot; &lt;&lt; &quot;(&quot; &lt;&lt; a &lt;&lt; &quot;,&quot; &lt;&lt; b &lt;&lt; &quot;)= &quot; &lt;&lt; GCD(a, b) &lt;&lt; endl;
} 
</cpp>
  <py>null</py>
  <orden>6</orden>
  <suborden>29</suborden>
  <fecha_creacion>2020-12-04 22:01:06</fecha_creacion>
  <fecha_modificacion>2020-12-06 20:23:15</fecha_modificacion>
</row>
<row>
  <ID>62</ID>
  <supergrupo>Matemática</supergrupo>
  <tema>Euler Totient</tema>
  <texto>La función totient de Euler para una entrada n es un conteo de números desde 1 hasta n que son primos relativos con n, por ejemplo, los números cuyo GCD (Máximo común divisor) con n es 1. Se llama primos relativos (coprimos) a cualquier par de números enteros que no tienen ningún divisor en común, excepto el 1.
El criptosistema RSA es basado en este teorema.
</texto>
  <complejidad_tiempo>Mejor caso :    O(n)  Peor caso : O(n)  Promedio: O(n) </complejidad_tiempo>
  <java>// Programa simple que calcula el valor 
// de la función  totient Euler

public class EulerTotient {
    // Función que retorna gcd de a y b
    static int gcd(int a, int b) {
        if (a == 0) {
            return b;
        }
        return gcd(b % a, a);
    }
        // Función que evalua función totient de euler
    static int phi(int n) {
        int result = 1;
        for (int i = 2; i &lt; n; i++) {
            if (gcd(i, n) == 1) {
                result++;
            }
        }
        return result;
    }

    public static void main(String[] args) {
        int n;
        for (n = 1; n &lt;= 10; n++) {
            System.out.println(&quot;phi(&quot; + n + &quot;) = &quot; + phi(n));
        }
    }
}
</java>
  <cpp>#include&lt;bits/stdc++.h&gt;
#include&lt;cstdlib&gt;
using namespace std;
int gcd(int a,int b){
    if(a==0){
        return b;
    }
    return gcd(b%a,a);
}
int phi(int n){
    int result=1;
    for(int i=2;i&lt;n;i++ ){
        if(gcd(i,n)==1){
            result++;
        }
    }
    return result;
}
int main() {
    for(int i=1;i&lt;=10;i++){
        printf(&quot;el phi (%d) = %d\n&quot;,i,phi(i));
    }
}
</cpp>
  <py>from sys import stdout
wr = stdout.write

def gcd(a, b):
    if a == 0:
        return b
    return gcd(b % a, a)

def phi(n):
    result = 1
    for i in range(2, n):
        if gcd(i, n) == 1:
            result += 1
    return result

for i in range(1, 11):
    wr(f&#39;Phi ({i}) = {phi(i)}\n&#39;)
</py>
  <orden>6</orden>
  <suborden>30</suborden>
  <fecha_creacion>2020-12-04 22:01:06</fecha_creacion>
  <fecha_modificacion>2020-12-06 20:23:15</fecha_modificacion>
</row>
<row>
  <ID>63</ID>
  <supergrupo>Matemática</supergrupo>
  <tema>El pequeño teorema de Fermat</tema>
  <texto>El pequeño teorema de Fermat dice que si p es un número primo, entonces para cualquier entero a, el número de p-a es un entero múltiplo de p.
Aquí p es un número primo:
- a^p = a (mod p).
Caso especial: si a no es divisible por p, el pequeño teorema de Fermat es equivalente a la sentencia que un p-1-1 es un entero múltiplo de p.
- a^p-1 = 1 (mod p)
O
- a^p-1 % p = 1  Aquí a no es divisible por p.
Usos del pequeño teorema de Fermat
Si sabemos que m es primo, entones se puede también usar el pequeño teorema de Fermat para buscar la inversa:
- a^m-1 = 1 (mod m)
Si nosotros multiplicamos ambos saldos con a-1, obtenemos:
- a^-1 = a m-2 (mod m)
</texto>
  <complejidad_tiempo>Mejor caso :    O(n)  Peor caso : O(n)  Promedio: O(n) </complejidad_tiempo>
  <java>/*Programa de Java para encontrar modular.
 inverso de un módulo bajo m
 utilizando el pequeño teorema de Fermat.
 Este programa funciona solo si m es primo.*/
public class FermatLittleTheorem {

    static int __gcd(int a, int b) {
        if (b == 0) {
            return a;
        } else {
            return __gcd(b, a % b);
        }
    }
    // Computa x^y bajo modulo m

    static int power(int x, int y, int m) {
        if (y == 0) {
            return 1;
        }
        int p = power(x, y / 2, m) % m;
        p = (p * p) % m;
        return (y % 2 == 0) ? p : (x * p) % m;
    }
    // Función para encontrar modular
    // inverso bajo un modulo m
    // Asumimos m es primo

    static void modInverse(int a, int m) {
        if (__gcd(a, m) != 1) {
            System.out.print(&quot;No existe inverso&quot;);
        } else {
            // Si a y m son primos relativos, entonces
            // modulo inverso es a^(m-2) mod m 
            System.out.print(&quot;Multiplicación modular inversa es &quot;
                    + power(a, m - 2, m));
        }
    }

    public static void main(String[] args) {
        int a = 3, m = 11;
        modInverse(a, m);
    }
} 
</java>
  <cpp>null</cpp>
  <py>null</py>
  <orden>6</orden>
  <suborden>31</suborden>
  <fecha_creacion>2020-12-04 22:01:06</fecha_creacion>
  <fecha_modificacion>2020-12-06 20:23:16</fecha_modificacion>
</row>
<row>
  <ID>64</ID>
  <supergrupo>Matemática</supergrupo>
  <tema>Producto de fracciones</tema>
  <texto>Dados el numerador y el denominador de N fracciones, la tarea es encontrar el producto de N fracciones e imprimir la respuesta en forma reducida.
La idea es encontrar el producto de numeradores en una variable, como new_num, ahora encontrar el producto de los denominadores en otra variable como new_den. 
Ahora para encontrar la respuesta en forma reducida, encuentre el GCD de new_num y new_den y dividir el new_num y new_den por el GCD calculado.
La solución causa desbordamiento para números grandes, podemos evadir esto si encontramos los factores primos de todos los numeradores y denominadores, una vez hayamos encontrado los factores, podemos cancelar los factores primos comunes.
Cuando se solicita representar la respuesta de la forma {P \veces {Q} ^ {-1}}. Primero convierta el numerador  y el denominador en forma reducible de P/Q. luego busque el multiplicativo inverso de Q con respecto a un número primo m (Generalmente 10^9 + 7) el cual es dado como pregunta, luego de encontrar el multiplicativo inverso de Q, multiplicarlo con P y tomar el modulo con el número primo m,  el cual nos da nuestra salida requerida.
</texto>
  <complejidad_tiempo>Mejor caso :    O(n)  Peor caso : O(n)  Promedio: O(n) </complejidad_tiempo>
  <java>//Programa java que encuentra el producto
// de N fracciones en forma reducida

public class Fractionsproduct {
    // Función que retorna el gcd de a y b
    static int gcd(int a, int b) {
        if (a == 0) {
            return b;
        }
        return gcd(b % a, a);
    }

    static void productReduce(int n, int num[],
            int den[]) {
        int new_num = 1, new_den = 1;
        //Encontrando el producto de todos los N
        // numeradores y denominadores
        for (int i = 0; i &lt; n; i++) {
            new_num *= num[i];
            new_den *= den[i];
        }
        // Encontrando GCD de nuevo numerados y denominador 
        int GCD = gcd(new_num, new_den);
        // Convirtiendo en forma reducids
        new_num /= GCD;
        new_den /= GCD;
        System.out.println(new_num + &quot;/&quot; + new_den);
    }

    public static void main(String[] args) {
        int n = 3;
        int num[] = {1, 2, 5};
        int den[] = {2, 1, 6};
        productReduce(n, num, den);
    }
}
</java>
  <cpp>#include&lt;bits/stdc++.h&gt;
#include&lt;cstdlib&gt;
//---------------//
using namespace std;
int GCD(int a,int b){
    if(a==0){
        return b;
    }
    return GCD(b%a,a);
}
void productReduce(int n,int num[],int den[]){
    int new_num=1,new_den=1;
    for(int i=0;i&lt;n;i++){
        new_num*=num[i];
        new_den*=den[i];
    }
    int gcd = GCD(new_num,new_den);
    new_num/=gcd;
    new_den/=gcd;
    cout&lt;&lt;new_num&lt;&lt;&quot;/&quot;&lt;&lt;new_den&lt;&lt;endl;
}
int main() {
    int n=3;
    int num[]={1,2,5};
    int den[]={2,1,6};
    productReduce(n,num,den);
} 
</cpp>
  <py>null</py>
  <orden>6</orden>
  <suborden>32</suborden>
  <fecha_creacion>2020-12-04 22:01:06</fecha_creacion>
  <fecha_modificacion>2020-12-06 20:23:17</fecha_modificacion>
</row>
<row>
  <ID>65</ID>
  <supergrupo>Matemática</supergrupo>
  <tema>Josephus</tema>
  <texto>En las ciencias de la computación y las matemáticas, el problema Josephus (O permutación Josephus) es un problema teorético el cual su enunciado es el siguiente.
Hay n personas sentadas en círculo, esperando a ser ejecutadas. El conteo empieza en el mismo punto en el círculo y procede alrededor del círculo en dirección horaria, en cada paso un cierto número de personas son saltadas y la siguiente persona es ejecutada. La eliminación se realiza alrededor del circulo (el comienza a ser más pequeño y pequeño mientras la gente es ejecutada y removida), hasta que solo quede una persona, a quien se le dará la libertad. Dado el total de personas n y un número k que indica que k-1 personas serán saltadas y la kesima persona es asesinada en el círculo, la tarea es escoger el lugar en el círculo inicial de tal forma que sea la posición de la última persona que sobreviva.
Por ejemplo, si n =5 y k = 2, entonces la posición segura es 3.  (1,2,3,4,5 y la posición inicial es 5). Primeramente la persona en la posición 2 es asesinada, luego la persona en la posición 4 es asesinada, luego la persona en la posición 1 es asesinada, finalmente la persona en la posición 5 es asesinada dejando a la persona en la 4 posición viva y con capacidad de disfrutar su libertad.
Si n=7 y k=3, entonces la posición segura es 4, las personas en las posiciones 3,6,2,7,5,1 son asesinadas en ese orden y la 4 sobrevive. 
</texto>
  <complejidad_tiempo>Mejor caso :    O(n)  Peor caso : O(n)  Promedio: O(n) </complejidad_tiempo>
  <java>//Implementación java de dos Algoritmos que realizan la
// busqueda josephus sabiendo número personas y tamaño
// de salto

public class Josephus {

    public static void main(String[] args) {
        System.out.println(josephus(6, 2));
        System.out.println(josephusModular(6, 2));
    }
    //Busqueda por algoritmo voraz
    static int josephus(int n, int k) {
        int d[] = new int[n + 1];
        d[0] = -1;
        for (int i = 1; i &lt;= n; i++) {
            d[i] = i;
        }
        int i = n;
        int a = 0;
        while (i != 1) {
            i--;
            a = next(a, k, d);
            d[a] = -1;
            a++;
        }
        for (i = 0; d[i] == -1; i++);
        return d[i];
    }
    //Calcule la posición siguiente a caer 
    static int next(int a, int k, int[] d) {
        int j = a - 1;
        for (int i = 0; i &lt; k;) {
            j = (j + 1) % d.length;
            if (d[j] != -1) {
                i++;
            }
        }
        return j;
    }
    //busqueda por matematica modular
    static int josephusModular(int n, int k) {
        int f = 0;
        for (int i = 1; i &lt;= n; i++) {
            f = (f + k) % i;

        }
        return f + 1;
    }
}
</java>
  <cpp>#include&lt;bits/stdc++.h&gt;
#include&lt;cstdlib&gt;
//---------------//
using namespace std;
int next(int a, int k, int d[], int n){
    int j = a - 1;
    for(int i = 0; i &lt; k;){
        j = (j + 1) % n;
        if(d[j] != -1){
            i++;
        }
    }
    cout&lt;&lt;&quot;next: &quot;&lt;&lt;j&lt;&lt;endl;
    return j;
}
int josephus(int n, int k){
    int d[n + 1];
    d[0] = -1;
    for(int i = 1; i &lt;= n; i++){
        d[i] = i;
    }
    int indice = n;
    int a = 0;
    while(indice != 1){
        indice--;
        a = next(a, k, d, n + 1);
        d[a] = -1;
        a++;
    }
    for(indice = 0; d[indice] == -1; indice++);
        return d[indice];
}
int main(){
    cout&lt;&lt;josephus(10, 3)&lt;&lt;endl;
    return 0;
}

</cpp>
  <py>from sys import stdout
wr = stdout.write

def next_(a, k, d):
    j = a - 1
    i = 0
    while i &lt; k:
        j = (j+1) % len(d)
        if d[j] != -1:
            i += 1
    wr(f&#39;Next = {j}\n&#39;)
    return j

def josephus(n, k):
    d = [-1 for x in range(n+1)]
    d[0] = -1
    for i in range(1, n+1):
        d[i] = i
    i = n
    a = 0
    while i != 1:
        i -= 1
        a = next_(a, k, d)
        d[a] = -1
        a += 1
    i = 0
    while d[i] == -1:
        i += 1
    return d[i]

def josephusModular(n, k):
    f = 0
    for i in range(1, n+1):
        f = (f+k) % i
    return f + 1

wr(f&#39;{josephusModular(6,2)}\n&#39;)
wr(f&#39;{josephus(6,2)}&#39;)
</py>
  <orden>6</orden>
  <suborden>33</suborden>
  <fecha_creacion>2020-12-04 22:01:06</fecha_creacion>
  <fecha_modificacion>2020-12-06 20:23:17</fecha_modificacion>
</row>
<row>
  <ID>66</ID>
  <supergrupo>Matemática</supergrupo>
  <tema>Números de la forma Cardinal/Ordinal</tema>
  <texto>Cuando usamos los números naturales para contar los elementos de un determinado conjunto los llamamos números cardinales.  
En muchas ocasiones es necesario dar un orden a las cosas: las posiciones finales de una carrera o los pisos de un edificio son algunos ejemplos.  Cuando se usan los números naturales para este ordenar los llamamos ordinales.
Para representar los números ordinales se usan los números naturales acompañados por una pequeña letra así: 1°a, 2°o  etc.  Cuando acompañamos el número por la letra a es para femenino, y con la letra o es para masculino.  Así, si queremos decir que Anita es la número uno de la clase decimos que es la primera: 1°a; y si queremos decir que Pablo ocupó el lugar número uno en la carrera decimos que fue el primero: 1°o
</texto>
  <complejidad_tiempo>Mejor caso :    O(n)  Peor caso : O(n)  Promedio: O(n) </complejidad_tiempo>
  <java>//Programa java que convierte números ordinales
// en números cardinales en ingles

public class CardinalNumbers {

    public static void main(String[] args) {
        for (int i = 1; i &lt;= 10; i++) {
            System.out.println(i + cardinalNumber(i));
        }
    }

    static String cardinalNumber(int n) {
        if (n % 10 == 1 &amp;&amp; n % 100 != 11) {
            return &quot;st&quot;;
        }
        if (n % 10 == 2 &amp;&amp; n % 100 != 12) {
            return &quot;nd&quot;;
        }
        if (n % 10 == 3 &amp;&amp; n % 100 != 13) {
            return &quot;rd&quot;;
        }
        return &quot;th&quot;;
    }
}
</java>
  <cpp>#include&lt;bits/stdc++.h&gt;
#include&lt;cstdlib&gt;
//---------------//
using namespace std;
string cardinalNumber(int n){
    if(n%10==1 &amp;&amp; n%100!=11){
        return &quot;st&quot;;
    }if(n%10==2 &amp;&amp; n%100!=12){
        return &quot;nt&quot;;
    }if(n%10==3 &amp;&amp; n%100!=13){
        return &quot;st&quot;;
    }
    return &quot;th&quot;;
}
int main(){
    for(int i=1;i&lt;=10;i++){
        cout&lt;&lt;i&lt;&lt;&quot; : &quot;&lt;&lt;cardinalNumber(i)&lt;&lt;endl;
    }
} 
</cpp>
  <py>null</py>
  <orden>6</orden>
  <suborden>34</suborden>
  <fecha_creacion>2020-12-04 22:01:06</fecha_creacion>
  <fecha_modificacion>2020-12-06 20:23:18</fecha_modificacion>
</row>
<row>
  <ID>67</ID>
  <supergrupo>Matemática</supergrupo>
  <tema>12.35) Números Romanos</tema>
  <texto>La numeración romana es un sistema de numeración que se desarrolló en la Antigua Roma y se utilizó en todo el Imperio romano, manteniéndose con posterioridad a su desaparición y todavía utilizado en algunos ámbitos.

Este sistema emplea algunas letras mayúsculas como símbolos para representar ciertos valores. Los números se escriben como combinaciones de letras. Por ejemplo, el año 2019 se escribe como MMXIX, donde cada M representa 1000 unidades, la X representa 10 unidades más y IX representa 9 unidades más (al ser X, que representa el 10, precedido por I, que representa el 1).
</texto>
  <complejidad_tiempo>Mejor caso :    O(n)  Peor caso : O(n)  Promedio: O(n) </complejidad_tiempo>
  <java>//Implementación java que convierte números decimales
// a números romanos y viceversa usando matematica modular

public class RomanNumbers {
    // Arrays constantes de letras romanas
    static String unit[] = {&quot;&quot;, &quot;I&quot;, &quot;II&quot;, &quot;III&quot;, &quot;IV&quot;, &quot;V&quot;, &quot;VI&quot;, &quot;VII&quot;, &quot;VIII&quot;, &quot;IX&quot;};
    static String ten[] = {&quot;&quot;, &quot;X&quot;, &quot;XX&quot;, &quot;XXX&quot;, &quot;XL&quot;, &quot;L&quot;, &quot;LX&quot;, &quot;LXX&quot;, &quot;LXXX&quot;, &quot;XC&quot;};
    static String hnd[] = {&quot;&quot;, &quot;C&quot;, &quot;CC&quot;, &quot;CCC&quot;, &quot;CD&quot;, &quot;D&quot;, &quot;DC&quot;, &quot;DCC&quot;, &quot;DCCC&quot;, &quot;CM&quot;};

    public static void main(String[] args) {
        System.out.println(toRoman(122));
        System.out.println(toDecimal(&quot;CXXII&quot;));
    }
    //Función que convierte a romano

    static String toRoman(int n) {
        //Los números romanos no tienen letras
        //más alla de los miles
        int a;
        StringBuilder sb = new StringBuilder();
        if (n &gt;= 1000) {
            a = n / 1000;
            for (int i = 1; i &lt;= a; i++) {
                sb.append(&quot;M&quot;);
            }
            n %= 1000;
        }
        //Letras de las centenas
        sb.append(hnd[n / 100]);
        n = n % 100;
        //Letras de las decenas
        sb.append(ten[n / 10]);
        //Letras de las unidades
        sb.append(unit[n % 10]);
        return sb.toString();
    }
    //Devuelve el valor de cada letra

    static int valor(char ch) {
        switch (ch) {
            case &#39;I&#39;:
                return 1;
            case &#39;V&#39;:
                return 5;
            case &#39;X&#39;:
                return 10;
            case &#39;L&#39;:
                return 50;
            case &#39;C&#39;:
                return 100;
            case &#39;D&#39;:
                return 500;
            case &#39;M&#39;:
                return 1000;
        }
        return 0;
    }
    //Función que convierte a decimal

    static int toDecimal(String num) {
        int sum = 0;
        int last = 0;
        int next;
        //Toma cada letra y verifica si esta antes o despues 
        // suma si esta despues, resta si esta antes
        for (int i = num.length() - 1; i &gt;= 0; i--) {
            next = valor(num.charAt(i));
            if (last &lt;= next) {
                sum += next;
            } else {
                sum -= next;
            }
            last = next;
        }
        return sum;
    }
}
</java>
  <cpp>#include&lt;bits/stdc++.h&gt;
#include&lt;cstdlib&gt;
//---------------//
using namespace std;
string unit[]={&quot;&quot;,&quot;I&quot;,&quot;II&quot;,&quot;III&quot;,&quot;IV&quot;,&quot;V&quot;,&quot;VI&quot;,&quot;VII&quot;,&quot;VIII&quot;,&quot;IX&quot;};
string ten[]={&quot;&quot;,&quot;X&quot;,&quot;XX&quot;,&quot;XXX&quot;,&quot;XL&quot;,&quot;L&quot;,&quot;LX&quot;,&quot;LXX&quot;,&quot;LXXX&quot;,&quot;XC&quot;};
string hnd[]={&quot;&quot;,&quot;C&quot;,&quot;CC&quot;,&quot;CCC&quot;,&quot;CD&quot;,&quot;D&quot;,&quot;DC&quot;,&quot;DCC&quot;,&quot;DCCC&quot;,&quot;CM&quot;};
int valor(char ch){
    switch(ch){
    case &#39;I&#39;:
        return 1;
    case &#39;V&#39;:
        return 5;
    case &#39;X&#39;:
        return 10;
    case &#39;L&#39;:
        return 50;
    case &#39;C&#39;:
        return 100;
    case &#39;D&#39;:
        return 500;
    case &#39;M&#39;:
        return 1000;
    }
    return 0;
}
string toRoman(int n){
    int a;
    string sb=&quot;&quot;;
    if(n&gt;=1000){
        a = n/1000;
        for(int i=1;i&lt;=a;i++){
            sb+=&quot;M&quot;;
        }
        n%=1000;
    }
    sb+=(hnd[n/100]);
    n%=100;
    sb+=(ten[n/10]);
    sb+=(unit[n%10]);
    return sb;
}
int toDecimal(string num){
    int sum=0;
    int last=0;
    int next;
    for(int i=num.size()-1;i&gt;=0;i--){
        next=valor(num[i]);
        if(last&lt;=next){
            sum+=next;
        }else{
            sum-=next;
        }
        last=next;
    }
    return sum;
}
int main(){
    cout&lt;&lt;toRoman(122)&lt;&lt;endl;
    cout&lt;&lt;toRoman(1)&lt;&lt;endl;
    cout&lt;&lt;toRoman(2323)&lt;&lt;endl;
    cout&lt;&lt;toRoman(343)&lt;&lt;endl;

    cout&lt;&lt;toDecimal(&quot;CXXII&quot;)&lt;&lt;endl;
    cout&lt;&lt;toDecimal(&quot;I&quot;)&lt;&lt;endl;
    cout&lt;&lt;toDecimal(&quot;MMCCCXXIII&quot;)&lt;&lt;endl;
    cout&lt;&lt;toDecimal(&quot;CCCXLIII&quot;)&lt;&lt;endl;
} 
</cpp>
  <py>null</py>
  <orden>6</orden>
  <suborden>35</suborden>
  <fecha_creacion>2020-12-04 22:01:06</fecha_creacion>
  <fecha_modificacion>2020-12-06 20:23:18</fecha_modificacion>
</row>
<row>
  <ID>68</ID>
  <supergrupo>Matemática</supergrupo>
  <tema>Teorema de Hardy-Ramanujan </tema>
  <texto>El teorema de Hardy Ramanujan propone que el número de factores de n debe ser aproximadamente log(log(n)) para la mayoría de números naturales n.
- 5192 tiene 2 factores primos distintos y log(log(5192)) = 2.1615
- 51242183 tiene 3 factores primos distintos y log(log(51242183)) = 2.8765
Este teorema es principalmente usado en algoritmos de aproximación y es prueba líder para conceptos más grandes de teoría de la probabilidad 
</texto>
  <complejidad_tiempo>Mejor caso :    O(vn)  Peor caso : O(vn)  Promedio: O(vn) </complejidad_tiempo>
  <java>// Programa java que cuenta todos los 
// factores primos

public class HardyRamanujanTheorem {
    // Una función que cuenta factores primos de 
    //un número n
    static int exactPrimeFactorCount(int n) {
        int count = 0;
        if (n % 2 == 0) {
            count++;
            while (n % 2 == 0) {
                n = n / 2;
            }
        }
        // n debe ser impar en este punto, asi 
        //podemos saltar un elemento (i=i+2)
        for (int i = 3; i &lt;= Math.sqrt(n); i = i + 2) {
            if (n % i == 0) {
                count++;
                while (n % i == 0) {
                    n = n / i;
                }
            }
        }
        // Esta condición es para controlar el caso
        // cuando n es un factor primo más grande que 2
        if (n &gt; 2) {
            count++;
        }
        return count;
    }

    public static void main(String[] args) {
        int n = 51242183;
        System.out.println(&quot;El número de diferentes &quot;
                + &quot; factores primos es &quot;
                + exactPrimeFactorCount(n));
        System.out.println(&quot;El valor de (log(n))&quot;
                + &quot; es &quot; + Math.log(Math.log(n)));
    }
}
</java>
  <cpp>#include&lt;bits/stdc++.h&gt;
#include&lt;cstdlib&gt;
//---------------//
using namespace std;
int exactPrimeFactorCount(int n){
    int cont=0;
    if(n%2==0){
        cont++;
        while(n%2==0){
            n/=2;
        }
    }
    for(int i=3;i&lt;=(sqrt(n));i+=2){
        if(n%i==0){
            cont++;
            while(n%i==0){
                n/=i;
            }
        }
    }
    if(n&gt;2){
        cont++;
    }
    return cont;
}
int main(){
    int n=51242183;
    cout&lt;&lt;&quot;El numero de diferentes factores primos es &quot;&lt;&lt;exactPrimeFactorCount(n)&lt;&lt;endl;
    cout&lt;&lt;&quot;EL valor de (log(n)) es &quot;&lt;&lt;log(log(n))&lt;&lt;endl;
} 
</cpp>
  <py>null</py>
  <orden>6</orden>
  <suborden>36</suborden>
  <fecha_creacion>2020-12-04 22:01:06</fecha_creacion>
  <fecha_modificacion>2020-12-06 20:23:19</fecha_modificacion>
</row>
<row>
  <ID>69</ID>
  <supergrupo>Matemática</supergrupo>
  <tema>Hoax Number</tema>
  <texto>Dado un número n, verificar si es un número falso o no.
Un número falso es definido como un número compuesto, cuya suma de dígitos es igual a la suma de dígitos de sus distintos factores primos, 1 no es considerado un número primo, entonces no es incluido en la suma de dígitos de los distintos factores primos.
La definición de un número falso está cerca de la de la definición de un número de Smith, algunos de los números falsos son también números de Smith, es aparente que estos números falsos no tienen factores repetidos en su descomposición de primos.
Implementación
1) Primero se generan todos los distintos factores primos del número n.
2) Si el n no es un número primo, encuentre la suma de dígitos de los factores obtenidos en el paso 1
3) Encuentre la suma de dígitos de n
4) Verifique si la suma obtenida en  2 y 3 son iguales o no.
5) Si las sumas son iguales, entonces n es un número falso.
</texto>
  <complejidad_tiempo>Mejor caso :    O(vn)  Peor caso : O(vn)  Promedio: O(vn) </complejidad_tiempo>
  <java>// Programa java que verifica si un número es 
// falso o no

import java.util.*;

public class HoaxNumber {

    /*Función que encuentra distintos factores primos
    dado un número n*/
    static List&lt;Integer&gt; primeFactors(int n) {
        List&lt;Integer&gt; res = new ArrayList&lt;&gt;();
        if (n % 2 == 0) {
            while (n % 2 == 0) {
                n = n / 2;
            }
            res.add(2);
        }
        /*N es impar en este punto
        desde que ya no sea divisible por 2
        entonces podemos probar solamente
        por números impares, mientras sean 
        factores de n*/
        for (int i = 3; i &lt;= Math.sqrt(n);
                i = i + 2) {
            //Verifica si i es factor primo
            if (n % i == 0) {
                while (n % i == 0) {
                    n = n / i;
                }
                res.add(i);
            }
        }
        /*Esra condición es para controlar
        el caso cuando n es un número primo
        más grande que 2*/
        if (n &gt; 2) {
            res.add(n);
        }
        return res;
    }

    /*Función que calcula suma de digitos de distintos
    factores primos de dado n y la suma de digitos
    de número n. compara las sumás obtenidas*/
    static boolean isHoax(int n) {
        /*Distintos factores primos de n seran almacenados
        en vector pf*/
        List&lt;Integer&gt; pf = primeFactors(n);
        /* Si n es un número primo
        no puede ser un número falso*/
        if (pf.get(0) == n) {
            return false;
        }
        /*Encontrando suma de digitos de 
        distintos factores primos de n*/
        int all_pf_sum = 0;
        for (int i = 0; i &lt; pf.size(); i++) {
            // Encontramos la suma de digitos de 
            // el actual factor primo pf[i] 
            int pf_sum;
            for (pf_sum = 0; pf.get(i) &gt; 0;
                    pf_sum += pf.get(i) % 10, pf.set(i, pf.get(i) / 10));

            all_pf_sum += pf_sum;
        }
        // Encontrando suma de digitos de n
        int sum_n;
        for (sum_n = 0; n &gt; 0; sum_n += n % 10, n /= 10);
        // Comparando las dos sumás calculadas
        return sum_n == all_pf_sum;
    }

    public static void main(String args[]) {
        int n = 84;
        if (isHoax(n)) {
            System.out.print(&quot;Un número falso\n&quot;);
        } else {
            System.out.print(&quot;No es número falso\n&quot;);
        }
    }
} 

</java>
  <cpp>null</cpp>
  <py>null</py>
  <orden>6</orden>
  <suborden>37</suborden>
  <fecha_creacion>2020-12-04 22:01:06</fecha_creacion>
  <fecha_modificacion>2020-12-06 20:23:20</fecha_modificacion>
</row>
<row>
  <ID>70</ID>
  <supergrupo>Matemática</supergrupo>
  <tema>Potencia más grande que divide un factorial</tema>
  <texto>Dados dos números, fact y n, encuentre la potencia más grande de n que divide fact! (Factorial de fact).
La idea es basada en la fórmula de Legendre la cual encuentra la potencia más grande de un número primo que divide fact!. Encontramos todos los factores primos de n. para cada factor primo encontramos la potencia más grande que divide fact! y finalmente retornamos el mínimo de todas las potencias encontradas.
Si hay múltiples potencias de un factor primo presentes en n, entonces se divide el conteo para obtener el valor de la máxima potencia de este factor.
</texto>
  <complejidad_tiempo>Mejor caso :    O(vn)  Peor caso : O(vn)  Promedio: O(vn) </complejidad_tiempo>
  <java>/* Programa java que encuentra la potencia más larga de
un número (La cual puede ser compuesta) que divide 
factorial*/
public class LargestPowDividesFactorial {

    /* For que encuentra la maxima potencia de número primo
    p que puede dividir un número facorial*/
    static int findPowerPrime(int fact, int p) {
        int res = 0;
        while (fact &gt; 0) {
            res += fact / p;
            fact /= p;
        }

        return res;
    }

    // Retorna la suma de todos los factores de n
    static int findPowerComposite(int fact, int n) {
        // Para almacernar el resultado ( Potencia minima de un 
        // factor primo que divide fact)
        int res = Integer.MAX_VALUE;
        // Atravesar atraves de todos los factores
        // primos de n
        for (int i = 2; i &lt;= Math.sqrt(n); i++) {
            // contador para contar la potencia del número primo
            int count = 0;
            if (n % i == 0) {
                count++;
                n = n / i;
            }
            if (count &gt; 0) {
                // Maxima potencia de i que divide 
                // fact, dividimos por count para 
                // manejar multiples ocurrencias de 
                // un factor primo
                int curr_pow = findPowerPrime(fact, i) / count;
                res = Math.min(res, curr_pow);
            }
        }
        // Esta condición es para manejar 
        // el caso cuando n es un número primo mayor 
        // que 2
        if (n &gt;= 2) {
            int curr_pow = findPowerPrime(fact, n);
            res = Math.min(res, curr_pow);
        }
        return res;
    }

    public static void main(String[] args) {
        int fact = 146, n = 5;
        System.out.println(findPowerComposite(fact, n));
    }
} 
</java>
  <cpp>null</cpp>
  <py>null</py>
  <orden>6</orden>
  <suborden>38</suborden>
  <fecha_creacion>2020-12-04 22:01:06</fecha_creacion>
  <fecha_modificacion>2020-12-06 20:23:20</fecha_modificacion>
</row>
<row>
  <ID>71</ID>
  <supergrupo>Matemática</supergrupo>
  <tema>Exponenciación modular</tema>
  <texto>Dados tres números x, y y p, calcule (x^y) % p.
Bajo esta propiedad fundamental modular  que es usada para computación eficiente, calcular la potencia usando matemática modular.
-  (ab) mod p = ( (a mod p) (b mod p) ) mod p 
Por ejemplo  a = 50,  b = 100, p = 13
- 50  mod 13  = 11
- 100 mod 13  = 9
- (50 * 100) mod 13 = ( (50 mod 13) * (100 mod 13) ) mod 13 
- or (5000) mod 13 = ( 11 * 9 ) mod 13
- or 8 = 8
</texto>
  <complejidad_tiempo>Mejor caso :    O(log n)  Peor caso : O(log n)  Promedio: O(log n) </complejidad_tiempo>
  <java>// Programa iteratico que calcula 
// potencia modular 

public class ModularExponentiation {

    /* Función iterativa que calcula
       (x^y)%p in O(log y) */
    static int power(int x, int y, int p) {
        // Inicializar resultado
        int res = 1;
        // Actualiza x si es más que    
        // o igual a p 
        x = x % p;
        while (y &gt; 0) {   //Si y es impar, multiplica x con res
            if ((y &amp; 1) == 1) {
                res = (res * x) % p;
            }
            // y debe ser par ahora
            // y = y / 2 
            y = y &gt;&gt; 1;
            x = (x * x) % p;
        }
        return res;
    }

    public static void main(String args[]) {
        int x = 2;
        int y = 5;
        int p = 13;
        System.out.println(&quot;La potencia es &quot; + power(x, y, p));
    }
} 
</java>
  <cpp>null</cpp>
  <py>null</py>
  <orden>6</orden>
  <suborden>39</suborden>
  <fecha_creacion>2020-12-04 22:01:06</fecha_creacion>
  <fecha_modificacion>2020-12-06 20:23:21</fecha_modificacion>
</row>
<row>
  <ID>72</ID>
  <supergrupo>Matemática</supergrupo>
  <tema>Multiple Euler Totient</tema>
  <texto>Función Totient de Euler de una entrada n es el conteo de números  en {1,2,3,..., n} que sea primo relativo a n, por ejemplo, los números los cuales su GCD con n es 1. 
En problemas donde tenemos que llamar a la función totient muchas veces como 10^5 veces, una solución simple puede retornar un TLE (time limit exceded). La idea es usar la criba de Eratóstenes.
Encuentre todos los factores primos con limite en 10^5 usando la criba de Eratóstenes.
Para realizar este F(n), se hace lo siguiente.
1) Inicializa el resultado como n.
2) Itera a través de todos los primos más pequeños o iguales que la raíz cuadrada de n. Dejamos que el actual número primo sea p, revisamos si p divide n, si lo hace, removemos todas las ocurrencias de p de n dividiéndolo repetidamente por n, también reducimos nuestro resultado por n/p.
3) Finalmente retornamos nuestro resultado.
</texto>
  <complejidad_tiempo>Mejor caso :    O(n2)  Peor caso : O(n2)  Promedio: O(n2) </complejidad_tiempo>
  <java>// Programa java que eficientemente calcula valores de
// la formula totient de euler para multiples entradas

import java.util.*;

public class MultipleEulerTotient {

    static int MAX = 100001;
    // Almacena números primos arriba hasta MAX -1
    static ArrayList&lt;Integer&gt; p = new ArrayList&lt;Integer&gt;();
    // Encurntra los números primos hasta MAX-1 Y
    // los almacena en p

    static void sieve() {
        int[] isPrime = new int[MAX + 1];
        for (int i = 2; i &lt;= MAX; i++) {
            // Si prime[i] no es marcado antes
            if (isPrime[i] == 0) {
                // Llena el vector para cada nuevo
                // primo encontrado
                p.add(i);
                for (int j = 2; i * j &lt;= MAX; j++) {
                    isPrime[i * j] = 1;
                }
            }
        }
    }
    // Función que encuentra totient de n

    static int phi(int n) {
        int res = n;
        // Este ciclo corre sqrt(n / ln(n)) veces
        for (int i = 0; p.get(i) * p.get(i) &lt;= n; i++) {
            if (n % p.get(i) == 0) {
                // resta multiplos de p[i] de r
                res -= (res / p.get(i));
                // Remueve todas las ocurrencias de p[i] en n
                while (n % p.get(i) == 0) {
                    n /= p.get(i);
                }
            }
        }
        // cuando n es un factor primo mayor 
        // que sqrt(n) 
        if (n &gt; 1) {
            res -= (res / n);
        }
        return res;
    }

    public static void main(String[] args) {
        //Preprocesa todos los primos hasta 10 ^ 5  
        sieve();
        System.out.println(phi(11));
        System.out.println(phi(21));
        System.out.println(phi(31));
        System.out.println(phi(41));
        System.out.println(phi(51));
        System.out.println(phi(61));
        System.out.println(phi(91));
        System.out.println(phi(101));
    }
} 
</java>
  <cpp>null</cpp>
  <py>null</py>
  <orden>6</orden>
  <suborden>40</suborden>
  <fecha_creacion>2020-12-04 22:01:06</fecha_creacion>
  <fecha_modificacion>2020-12-06 20:23:22</fecha_modificacion>
</row>
<row>
  <ID>73</ID>
  <supergrupo>Matemática</supergrupo>
  <tema>12.41) Sumatoria de naturales coprimos</tema>
  <texto>Dado N y M, la tarea es encontrar cuales números de 1 a n pueden ser divididos en dos conjuntos los cuales su diferencia absoluta entre la suma de los dos sets es M y el GCD de la suma de los dos sets es 1.
Desde que tenemos 1 a N números, sabemos que la suma de todos los números es N*(N+1)/2. Dejamos S1 y S2 de esta manera:
1) sum(S1) + sum(S2) = N * (N + 1) / 2
2) sum(S1) – sum(S2) = M
Resolviendo estas dos ecuaciones podemos dar la suma de ambos conjuntos. Si sum(S1) y sum(S2)  son enteros  y ellos son coprimos (Su GCD es 1), entonces ahí existe una forma de separar el número en dos sets. De otra forma no hay forma de separar esos números N.
</texto>
  <complejidad_tiempo>Mejor caso :    O(log(n))  Peor caso : O(log(n))  Promedio: O(log(n)) </complejidad_tiempo>
  <java>/* Código de Java para determinar si los números
1 a N se puede dividir en dos conjuntos
tal que la diferencia absoluta entre
la suma de estos dos conjuntos es M y estos
dos sumás son co-primos*/
public class NaturalCoprimeSum {

    static int GCD(int a, int b) {
        return b == 0 ? a : GCD(b, a % b);
    }

    /*función que devuelve valor booleano
     sobre la base de si es posible
     dividir 1 a N números en dos conjuntos
     Que satisfacen las condiciones dadas.*/
    static boolean isSplittable(int n, int m) {
        // Inicializando suma total de 1
        //a n 
        int total_sum = (n * (n + 1)) / 2;
        /*desde (1) total_sum = sum_s1 + sum_s2 
        y (2) m = sum_s1 - sum_s2 asumiendo 
        sum_s1&gt; sum_s2. resolviendo estas 2 
        ecuaciones para obtener sum_s1 y sum_s2*/
        int sum_s1 = (total_sum + m) / 2;
        // total_sum = sum_s1 + sum_s2 
        // y asi 
        int sum_s2 = total_sum - sum_s1;
        /*Si la suma total es menor que la 
        diferencia absoluta, no hay forma 
        de que podamos dividir n números 
        en dos conjuntos, así que devuelva falso*/
        if (total_sum &lt; m) {
            return false;
        }
        /*Compruebe si estas dos sumás son
        enteros y se suman a
        suma total y también si su
        La diferencia absoluta es m.*/
        if (sum_s1 + sum_s2 == total_sum
                &amp;&amp; sum_s1 - sum_s2 == m) // Ahora si las dos sumás son coprimos
        // Entonces retorna true, si no false
        {
            return (GCD(sum_s1, sum_s2) == 1);
        }
        /*si dos sumás no suman la suma total
          o si su diferencia absoluta.
         no es m, entonces no hay manera de
         dividir n números, por lo tanto retorna false*/
        return false;
    }

    public static void main(String args[]) {
        int n = 5, m = 7;
        if (isSplittable(n, m)) {
            System.out.println(&quot;Si&quot;);
        } else {
            System.out.println(&quot;No&quot;);
        }

    }
} 

</java>
  <cpp>null</cpp>
  <py>null</py>
  <orden>6</orden>
  <suborden>41</suborden>
  <fecha_creacion>2020-12-04 22:01:06</fecha_creacion>
  <fecha_modificacion>2020-12-06 20:23:22</fecha_modificacion>
</row>
<row>
  <ID>74</ID>
  <supergrupo>Matemática</supergrupo>
  <tema>Números de Leonardo</tema>
  <texto>Los números de Leonardo son una secuencia de números con la recurrencia:
- L(0)=0
- L(1)=1
- L(n)=L(n-1)+l(n-2)+1 si n&gt;1
Los primeros números de Leonardo son 1, 1, 3, 5, 9, 15, 25, 41, 67, 109, 177, 287, 465, 753, 1219, 1973, 3193, 5167, 8361, ···
Complejidad de tiempo: Exponencial
</texto>
  <complejidad_tiempo>null</complejidad_tiempo>
  <java>//Pograma java qque busca el nesimo número
// de Leonardo

public class LeonardoNumber {

    static int leonardo(int n) {
        if (n == 0 || n == 1) {
            return 1;
        }
        return (leonardo(n - 1) + leonardo(n - 2) + 1);
    }
    public static void main(String args[]) {
        System.out.println(leonardo(3));
    }
} 
</java>
  <cpp>null</cpp>
  <py>null</py>
  <orden>6</orden>
  <suborden>42</suborden>
  <fecha_creacion>2020-12-04 22:01:06</fecha_creacion>
  <fecha_modificacion>2020-12-06 20:23:23</fecha_modificacion>
</row>
<row>
  <ID>75</ID>
  <supergrupo>Matemática</supergrupo>
  <tema>Teorema de Zeckendorf</tema>
  <texto>El teorema de Zeckendorf indica que cada posible entero puede ser escrito como la suma de distintos números de Fibonacci no vecinos. Dos números Fibonacci son vecinos si uno viene luego del otro en la secuencia (0, 1, 1, 2, 3, 5, ..). Por ejemplo 3 y 5 son vecinos pero 2 y 5 no lo son.
Dado un número, encontrar la representación del número como la suma de números de Fibonacci no consecutivos.
1) Sea n el número de entrada
2) Mientras n &gt;= 0
a) Encontrar el Fibonacci más grande que sea menor que n. Dejar que este número sea ‘f’, e imprimir f.
b) n = n – f
</texto>
  <complejidad_tiempo>null</complejidad_tiempo>
  <java>/*Programa java para el Teorema de Zeckendorf, 
encuentra la representación de n como suma de 
números de fibonacci no vecinos*/
public class ZeckendorfTheorem {

    public static int nearestSmallerEqFib(int n) {
        // Casos base
        if (n == 0 || n == 1) {
            return n;
        }
        //Encuentra el mayor número fibonacci menor que n 
        int f1 = 0, f2 = 1, f3 = 1;
        while (f3 &lt;= n) {
            f1 = f2;
            f2 = f3;
            f3 = f1 + f2;
        }
        return f2;
    }
    // Imprime representación de fibonacci  

    public static void printFibRepresntation(int n) {
        while (n &gt; 0) {
            // Encuentra el mayor número fibonacci menor 
            // o igual que n 
            int f = nearestSmallerEqFib(n);
            // Imprime el número fibonacci encontrado
            System.out.print(f + &quot; &quot;);
            // Reduce n 
            n = n - f;
        }
    }

    public static void main(String[] args) {
        int n = 30;
        System.out.println(&quot;Representación de fibonacci no vecinos &quot;
                + &quot; de  &quot; + n + &quot; es&quot;);
        printFibRepresntation(n);
    }
} 
</java>
  <cpp>null</cpp>
  <py>null</py>
  <orden>6</orden>
  <suborden>43</suborden>
  <fecha_creacion>2020-12-04 22:01:06</fecha_creacion>
  <fecha_modificacion>2020-12-06 20:23:23</fecha_modificacion>
</row>
<row>
  <ID>76</ID>
  <supergrupo>Matemática</supergrupo>
  <tema>Teorema de Rosser </tema>
  <texto>El teorema de Rosser dicta que el nesimo número es mayor que el producto de n y el logaritmo natural de n para todos los n mayores a 1.
Matemáticamente: 
Para n &gt;= 1, si pn es el nesimo número primo, entonces then:
- pn &gt; n * (ln n)
 Para n = 1, enésimo número primo = 2
-  2 &gt; 1 * ln(1)
 Para n = 2, enésimo número primo = 3
- 3 &gt; 2 * ln(2)
 Para n = 3, enésimo número primo = 5
- 5 &gt; 3 * ln(3)
   Para n = 4, enésimo número primo = 7
- 7 &gt; 4 * ln(4)
   Para n = 5, enésimo número primo = 11
- 11 &gt; 5 * ln(5)
   Para n = 6, enésimo número primo = 13
- 13 &gt; 6 * ln(6)
</texto>
  <complejidad_tiempo>null</complejidad_tiempo>
  <java>// Programa java que verifica el Teorema de Rosser

import java.util.*;

public class RosserTheorem {

    static ArrayList&lt;Integer&gt; prime = new ArrayList&lt;Integer&gt;();
    // Criba de Eratostenes
    static void sieve() {
        int n = 10000;
        boolean[] isprime = new boolean[n + 2];
        for (int i = 0; i &lt; n; i++) {
            isprime[i] = true;
        }
        isprime[0] = false;
        isprime[1] = false;
        for (int i = 2; i &lt;= n; i++) {
            if (isprime[i]) {
                for (int j = i * i; j &lt;= n; j += i) {
                    isprime[j] = false;
                }
            }
        }
        //Almacena primos en prime[] 
        for (int i = 0; i &lt;= n; i++) {
            if (isprime[i]) {
                prime.add(i);
            }
        }
    }

    // Verifica el TEOREMA DE  ROSSER para todos los números  
    // Menores a n
    static void verifyRosser(int n) {
        System.out.println(&quot;TEOREMA DE ROSSER: nesimo número primo &gt; n * (ln n)&quot;);
        for (int i = 0; i &lt; n; i++) {
            if (prime.get(i) &gt; (i + 1) * Math.log(i + 1)) {
                System.out.println(&quot;para n = &quot; + (i + 1)
                        + &quot;, nesimo número primo = &quot;
                        + prime.get(i) + &quot;\n\t&quot;
                        + prime.get(i) + &quot; &gt; &quot; + (i + 1)
                        + &quot; * ln(&quot; + (i + 1) + &quot;)&quot;);
            }
        }
    }

    public static void main(String[] args) {
        sieve();
        verifyRosser(20);
    }
} 
</java>
  <cpp>null</cpp>
  <py>null</py>
  <orden>6</orden>
  <suborden>44</suborden>
  <fecha_creacion>2020-12-04 22:01:06</fecha_creacion>
  <fecha_modificacion>2020-12-06 20:23:24</fecha_modificacion>
</row>
<row>
  <ID>77</ID>
  <supergrupo>Matemática</supergrupo>
  <tema>Números de Smith</tema>
  <texto>Dado un número n, la tarea encontrar si un número es número de Smith o no, un número de Smith es un número compuesto cuya suma de dígitos es igual a la suma de los dígitos en su factorización prima.
- n = 4
- Factorización prima = 2, 2  and 2 + 2 = 4
- Por lo tanto, 4 es un número de Smith
La idea es primero encontrar todos los factores primos por debajo de un límite usando la criba de Sundaram. (Esto es útil para buscar y verificar varios números de Smith). Ahora por cada entrada que será verificada como número de Smith, atravesamos por todos los factores primos en él, y encontramos la suma de los dígitos en cada factor primo. También buscamos la suma de los dígitos en el número dado. Finalmente comparamos las dos sumas, si son lo mismo, retornamos true.
</texto>
  <complejidad_tiempo>null</complejidad_tiempo>
  <java>// Programa java que verifica si un número es 
// número de Smith o no

import java.util.ArrayList;

public class SmithNumber {

    static int MAX = 10000;
    //Array que almacena todos los primos menores o iguales
    // a 10^6
    static ArrayList&lt;Integer&gt; primes = new ArrayList&lt;&gt;();
    //Función de la criba de Sundaram

    static void sieveSundaram() {
        /*En general criva de Sundaram, produce primos más pequeños.
        que (2 * x + 2) para un número dado el número x. Ya que
         Queremos primos más pequeños que MAX, reducimos MAX a la mitad
         Esta matriz se usa para separar números del forma
         i + j + 2ij de otros donde 1 &lt;= i &lt;= j*/
        boolean marked[] = new boolean[MAX / 2 + 100];
        //Lógica principal de Sundaram, marcar todos los números
        // loc cuales no generan número primo haciendo 2*i+1
        for (int i = 1; i &lt;= (Math.sqrt(MAX) - 1) / 2; i++) {
            for (int j = (i * (i + 1)) &lt;&lt; 1; j &lt;= MAX / 2; j = j + 2 * i + 1) {
                marked[j] = true;
            }
        }

        // 2s es número primo
        primes.add(2);
        // Imprime los otros primos, primos restantes son de la 
        //forma 2*i+1 de tal manera que marked[i] es falso
        for (int i = 1; i &lt;= MAX / 2; i++) {
            if (marked[i] == false) {
                primes.add(2 * i + 1);
            }
        }
    }
    // Retorna true si n es un número de Smith, si no falso 

    static boolean isSmith(int n) {
        int original_no = n;
        // Encuentra la suma de los digitos de los factores 
        //  primos de n
        int pDigitSum = 0;
        for (int i = 0; primes.get(i) &lt;= n / 2; i++) {
            while (n % primes.get(i) == 0) {   // Si primes[i] es un factor primo
                // agrega sus digitos a pDigitSum
                int p = primes.get(i);
                n = n / p;
                while (p &gt; 0) {
                    pDigitSum += (p % 10);
                    p = p / 10;
                }
            }
        }
        /*Si n!=! entonces un primo sigue para ser sumado*/
        if (n != 1 &amp;&amp; n != original_no) {
            while (n &gt; 0) {
                pDigitSum = pDigitSum + n % 10;
                n = n / 10;
            }
        }
        // Todos los factores primos sumados 
        // Ahora suma los digitos del número original 
        int sumDigits = 0;
        while (original_no &gt; 0) {
            sumDigits = sumDigits + original_no % 10;
            original_no = original_no / 10;
        }
        // Si la suma de los digistos en factores primos 
        // y la suma de digitos en el número original son los mismos
        // entonces true, si no false
        return (pDigitSum == sumDigits);
    }

    public static void main(String[] args) {   //Encuentra todos los números primos antes del limite
        // estos números son usados para encontrar factores primos
        sieveSundaram();
        System.out.println(&quot;Imprimiento primeros números de Smith&quot;
                + &quot; usando isSmith()&quot;);
        for (int i = 1; i &lt; 500; i++) {
            if (isSmith(i)) {
                System.out.print(i + &quot; &quot;);
            }
        }
    }
} 
</java>
  <cpp>null</cpp>
  <py>null</py>
  <orden>6</orden>
  <suborden>45</suborden>
  <fecha_creacion>2020-12-04 22:01:06</fecha_creacion>
  <fecha_modificacion>2020-12-06 20:23:25</fecha_modificacion>
</row>
<row>
  <ID>78</ID>
  <supergrupo>Matemática</supergrupo>
  <tema>Números esfénicos</tema>
  <texto>Un número escénico es un entero positivo el cual es el producto de exactamente tres primos distintos, los primeros números esfénicos son 30, 42, 66, 70, 78, 102, 105, 110, 114,…
Dado un número n, determine si es un número esfenico o no.
Un número esfenico puede ser verificado generando los últimos factores primos de los números hasta n.
Luego podemos simplemente dividir el número por sus factores primos y luego ese número por sus factores primos, y así en Adelante, y luego verificar si el número tiene exactamente 3 factores primos distintos.
Complejidad de tiempo: O (nlog(n))
</texto>
  <complejidad_tiempo>null</complejidad_tiempo>
  <java>// Programa JAVA que verifica si un número
// es esfenico o no

import java.util.ArrayList;
import java.util.Collections;
import java.util.HashSet;
import java.util.Set;

public class SphenicNumber {

    static final int MAX = 1000;
    //Crea un vector donde almacenar primos
    // inicializa todas las entradas en 0
    static ArrayList&lt;Integer&gt; least_pf = new ArrayList&lt;&gt;(MAX);

    /* Esta función llena valores en least_pf[]
    de tal modod que el valor de least_pf[] almacene
    el factor primo más pequeño de i
    Se encuentra basado en la criba
    de Eratostenes*/
    public static void main(String[] args) {
        for (int i = 0; i &lt; 1001; i++) {
            least_pf.add(0);
        }
        Collections.fill(least_pf, 0);
        leastPrimeFactor(MAX);
        for (int i = 1; i &lt; 100; i++) {
            if (isSphenic(i)) {
                System.out.println(i + &quot; &quot;);
            }
        }

    }
    /*Función que verifica si un número es esfenico*/
    static boolean isSphenic(int n) {
        /*Almacena tres factores primos de n
        tenemos al menos 3 elementos en s*/
        Set&lt;Integer&gt; s = new HashSet&lt;&gt;();
        // Siga encontrando factores primos hasta que n sea 1
        while (n &gt; 1) {
            // Encuenta al menos un factor del actual valor de n
            int lpf = least_pf.get(n);
            // Almacenamos actual tamaño de s para verificar si
            //algun factor primo se repite
            int init_size = s.size();
            // Inserta un valor primo al actual valor de n
            s.add(lpf);
            // si lpf repite un número o se pasa de 3, retorna falso. 
            if (s.size() == init_size || s.size() &gt; 3) // El mismo primo divide
            // un número más de una vez
            {
                return false;
            }
            // dividir n en lpf
            n /= lpf;
        }
        // True si el tamaño es 3
        return (s.size() == 3);
    }

    static void leastPrimeFactor(int n) {
        // un factor primo de 1 es 1
        least_pf.set(1, 1);
        // Almacena números primos para todos 
        // los otros números
        for (int i = 2; i &lt;= n; i++) {
            // least_pf[i] == 0 significa que i es primo
            if (least_pf.get(i) == 0) {
                least_pf.set(i, i);
                for (int j = 2 * i; j &lt;= n; j += i) {
                    if (least_pf.get(j) == 0) {
                        least_pf.set(j, i);
                    }
                }

            }
        }
    }
} 
</java>
  <cpp>null</cpp>
  <py>null</py>
  <orden>6</orden>
  <suborden>46</suborden>
  <fecha_creacion>2020-12-04 22:01:06</fecha_creacion>
  <fecha_modificacion>2020-12-06 20:23:25</fecha_modificacion>
</row>
<row>
  <ID>79</ID>
  <supergrupo>Matemática</supergrupo>
  <tema>Identidad de Cassini</tema>
  <texto>La identidad de Cassini y la identidad de Catalan son relaciones matemáticas ligadas con los números de la sucesión de Fibonacci, afirma que para cada número n-ésimo de la sucesión de Fibonacci, se cumple que:
- Fn-1 x Fn+1-F^2n=(-1)^n
</texto>
  <complejidad_tiempo>null</complejidad_tiempo>
  <java>//Programa java que demuestra 
// la identidad de Cassini

public class CassiniIdentity {
    // Retorna (-1)^n 
    static int cassini(int n) {
        return (n &amp; 1) != 0 ? -1 : 1;
    }

    public static void main(String args[]) {
        int n = 5;
        System.out.println(cassini(n));
    }
}
</java>
  <cpp>#include&lt;bits/stdc++.h&gt;
#include&lt;cstdlib&gt;
using namespace std;
int cassini(int n){
    return (n&amp;1)!=0? -1 : 1;
}
int main(){
    int n=5;
    printf(&quot;%d\n&quot;,cassini(n));
} 
</cpp>
  <py>null</py>
  <orden>6</orden>
  <suborden>47</suborden>
  <fecha_creacion>2020-12-04 22:01:06</fecha_creacion>
  <fecha_modificacion>2020-12-06 20:23:26</fecha_modificacion>
</row>
<row>
  <ID>80</ID>
  <supergrupo>Matemática</supergrupo>
  <tema>Números de Catalan </tema>
  <texto>En combinatoria, los números de Catalan forman una secuencia de números naturales que aparece en varios problemas de conteo que habitualmente son recursivos. Obtienen su nombre del matemático belga Eugène Charles Catalan (1814–1894).
El n-ésimo número de Catalan se obtiene, aplicando coeficientes binomiales, a partir de la siguiente fórmula:
Cn=  (2n)!/(n+1)!n!
</texto>
  <complejidad_tiempo>null</complejidad_tiempo>
  <java>//Programa Java que recursivamente encuentra el
// nesimo número Catalan 

public class CatalanNumber {

    public static int catalan(int n) {
        int res = 0;
        // Caso base
        if (n &lt;= 1) {
            return 1;
        }
        for (int i = 0; i &lt; n; i++) {
            res += catalan(i) * catalan(n - i - 1);
        }
        return res;
    }

    public static void main(String[] args) {
        for (int i = 0; i &lt; 10; i++) {
            System.out.print(catalan(i) + &quot; &quot;);
        }
    }
} 
</java>
  <cpp>null</cpp>
  <py>null</py>
  <orden>6</orden>
  <suborden>48</suborden>
  <fecha_creacion>2020-12-04 22:01:06</fecha_creacion>
  <fecha_modificacion>2020-12-06 20:23:27</fecha_modificacion>
</row>
<row>
  <ID>81</ID>
  <supergrupo>Matemática</supergrupo>
  <tema>Números de Charmichael</tema>
  <texto>Un número n es un número de Carmichael si satisface la siguiente condición aritmética modular:
- pow(b, n-1) MOD n = 1, 
Para todos los b en rango de 1 a n tal que b y n son relativos primos gcd(b, n) = 1 .
Dado un entero positivo n, encontrar si es un número de Carmichael, estos números tienen importancia en el método de Fermat para el test de primalidad.
</texto>
  <complejidad_tiempo>null</complejidad_tiempo>
  <java>//Programa java que verifica si un número
// es un número de carmichael

public class CarmichaelNumbers {

//función que busca el GCD de dos números
    static int gcd(int a, int b) {
        if (a &lt; b) {
            return gcd(b, a);
        }
        if (a % b == 0) {
            return b;
        }
        return gcd(b, a % b);
    }
    //Función que busca el pow(x,y)
    // bajo un modulo mod
    static int power(int x, int y, int mod) {
        if (y == 0) {
            return 1;
        }
        int temp = power(x, y / 2, mod) % mod;
        temp = (temp * temp) % mod;
        if (y % 2 == 1) {
            temp = (temp * x) % mod;
        }
        return temp;
    }

//Función que verifica si un número es número de charmichael
    static int isCarmichaelNumber(int n) {
        for (int b = 2; b &lt; n; b++) {
            // Si &#39;b&#39; es primo relativo de n
            if (gcd(b, n) == 1) // y pow(b, n-1)%n no es 1,
            // retorne falso
            {
                if (power(b, n - 1, n) != 1) {
                    return 0;
                }
            }
        }
        return 1;
    }

    public static void main(String args[]) {
        System.out.println(isCarmichaelNumber(500));
        System.out.println(isCarmichaelNumber(561));
        System.out.println(isCarmichaelNumber(1105));
    }
} 
</java>
  <cpp>null</cpp>
  <py>null</py>
  <orden>6</orden>
  <suborden>49</suborden>
  <fecha_creacion>2020-12-04 22:01:06</fecha_creacion>
  <fecha_modificacion>2020-12-06 20:23:27</fecha_modificacion>
</row>
<row>
  <ID>82</ID>
  <supergrupo>Matemática</supergrupo>
  <tema>Secuencia Stern-Brocot</tema>
  <texto>La secuencia de Stern Brocot es similar la secuencia de Fibonacci, pero es diferente en la forma en que la secuencia es generada.
1) Primero y segundo elemento de la secuencia es 1 y 1.
2) Considere el segundo miembro de la secuencia, luego sume el miembro considerado de la secuencia y su predecesor, por ejemplo (1+1=2) ahora 2 es el siguiente elemento de nuestra serie, la secuencia será [1,1,2].
3) Después de este elemento, nuestro siguiente elemento en la secuencia será considerado el elemento en nuestro segundo paso, ahora la secuencia seria [1,1,2,1].
4) De nuevo realizamos el paso 2, pero ahora consideramos el elemento 2 (Tercer elemento), entonces nuestro siguiente número de la secuencia será la suma de los números considerados, y su predecesor(2+1=3), la secuencia ahora será [1,1,2,1,3]
5) Como en el paso 3, el siguiente elemento será considerado, por ejemplo 2, la secuencia será [1,1,2,1,3,2]
6) El proceso continua, nuestro elemento considerado será 1(Cuarto elemento).
</texto>
  <complejidad_tiempo>null</complejidad_tiempo>
  <java>// Programa java que imprime   
// La secuencia de Stern Brocot

import java.util.*;

public class SternBrocotSequence {

    static void SternSequenceFunc(ArrayList&lt;Integer&gt; BrocotSequence, int n) {
        // Ciclo que crea la secuencia
        for (int i = 1; BrocotSequence.size() &lt; n; i++) {
            int considered_element = BrocotSequence.get(i);
            int precedent = BrocotSequence.get(i - 1);
            //Agregando la suma de los elementos considerados
            // y son precedentes
            BrocotSequence.add(considered_element + precedent);
            //  Agregando siguiente elemento considerado 
            BrocotSequence.add(considered_element);
        }
        // Imprimiendo secuencia
        for (int i = 0; i &lt; 15; ++i) {
            System.out.print(BrocotSequence.get(i) + &quot; &quot;);
        }
    }

    public static void main(String[] args) {
        int n = 15;
        ArrayList&lt;Integer&gt; BrocotSequence = new ArrayList&lt;Integer&gt;();
        // Agregando primer y segundo valor 
        // A la secuencia
        BrocotSequence.add(1);
        BrocotSequence.add(1);
        SternSequenceFunc(BrocotSequence, n);
    }
} 
</java>
  <cpp>null</cpp>
  <py>null</py>
  <orden>6</orden>
  <suborden>50</suborden>
  <fecha_creacion>2020-12-04 22:01:06</fecha_creacion>
  <fecha_modificacion>2020-12-06 20:23:28</fecha_modificacion>
</row>
<row>
  <ID>83</ID>
  <supergrupo>Matemática</supergrupo>
  <tema>Secuencia Sylvester</tema>
  <texto>El en sistema numérico, La secuencia de Sylvester es una secuencia de enteros la cual cada miembro es un producto de los números previos, más uno, dado un entero positivo N, imprima los primeros N miembros de la secuencia.
Los números pueden ser muy largos, se usa %10^9 + 7.
La idea es correr un ciclo y tomar dos variables, inicializarlos como 1 y 2, uno para almacenar el producto hasta ahora, y el otro para almacenar el número actual el cual es el primer número +1 y por cada paso, multiplicar ambos usando aritmética modular, por ejemplo (a + b)%N = (a%N + b%N)%N  donde N es un número modular.
</texto>
  <complejidad_tiempo>null</complejidad_tiempo>
  <java>//Implementación java de la secuencia Sylvester  

public class SylvesterSequence {

    public static void printSequence(int n) {
        int a = 1; // Para almacenar el producto
        int ans = 2; // Para almacenar el número actual
        int N = 1000000007;
        //Ciclo hasta n
        for (int i = 1; i &lt;= n; i++) {
            System.out.print(ans + &quot; &quot;);
            ans = ((a % N) * (ans % N)) % N;
            a = ans;
            ans = (ans + 1) % N;
        }
    }

    public static void main(String[] args) {
        int n = 6;
        printSequence(n);

    }
} 
</java>
  <cpp>null</cpp>
  <py>null</py>
  <orden>6</orden>
  <suborden>51</suborden>
  <fecha_creacion>2020-12-04 22:01:06</fecha_creacion>
  <fecha_modificacion>2020-12-06 20:23:28</fecha_modificacion>
</row>
<row>
  <ID>84</ID>
  <supergrupo>Matemática</supergrupo>
  <tema>Secuencia Aliquot </tema>
  <texto>Dado un número n, la tarea es imprimir su secuencia de Aliquot. La secuencia de Aliquot de un número empieza con el mismo, términos restantes de la secuencia son la suma de los divisores propios del término inmediatamente anterior.

Por ejemplo, la secuencia de Aliquot de 10, es 10,8,7,1,0. La secuencia puede repetir. Por ejemplo para 6, tenemos una secuencia infinita de todos los 6, En esos casos              imprimimos el número repetido y paramos.
- Números los cuales tienen una secuencia de Aliquot repetitiva de longitud 1 son llamados números perfectos. Por ejemplo 6, suma de sus divisores propios es 6.
- Números  que tienen una secuencia de Aliquot repetitiva de tamaño 2 son llamados números de Amicable. Por ejemplo 220 es un número de Amicable.
- Números que tienen secuencia de Aliquot repetitiva de tamaño 3 son llamados números sociales
Podemos generar la secuencia primero imprimiendo el número n y luego calculando los siguientes términos usando la suma de los divisores propios. Cuando computemos el siguiente termino, verificamos si nosotros ya habíamos visto ese término o no, si el término aparece de nuevo tenemos una secuencia repetida, imprimimos el mismo y rompemos el ciclo. 
</texto>
  <complejidad_tiempo>null</complejidad_tiempo>
  <java>//Implementación java de una apoximación
// de la secuencia Aliquot 

import java.util.*;

public class AliquotSequence {
    // Función que calcula suma de 
    // los divisores adecuados
    static int getSum(int n) {
        int sum = 0; // 1 es un divisor adecuado
        for (int i = 1; i &lt;= Math.sqrt(n); i++) {
            if (n % i == 0) {   // Si divisores son iguales, solo toma uno 
                if (n / i == i) {
                    sum = sum + i;
                } else // Si no tome ambos
                {
                    sum = sum + i;
                    sum = sum + (n / i);
                }
            }
        }
        // Calcula la suma de los divisores adecuados
        return sum - n;
    }

    static void printAliquot(int n) {
        // Imprime el primer termino
        System.out.printf(&quot;%d &quot;, n);
        TreeSet&lt;Integer&gt; s = new TreeSet&lt;&gt;();
        s.add(n);

        int next = 0;
        while (n &gt; 0) {   // Calcula siguiente termino desde el anterior
            n = getSum(n);
            if (s.contains(n) &amp;&amp; n != s.last()) {
                System.out.print(&quot;\nRepeats with &quot; + n);
                break;
            }
            //Imprimir siguiente termino
            System.out.print(n + &quot; &quot;);
            s.add(n);
        }
    }

    public static void main(String[] args) {
        printAliquot(12);
    }
} 
</java>
  <cpp>null</cpp>
  <py>null</py>
  <orden>6</orden>
  <suborden>52</suborden>
  <fecha_creacion>2020-12-04 22:01:06</fecha_creacion>
  <fecha_modificacion>2020-12-06 20:23:29</fecha_modificacion>
</row>
<row>
  <ID>85</ID>
  <supergrupo>Matemática</supergrupo>
  <tema>Secuencia Juggler</tema>
  <texto>La secuencia de Juggles es una serie de números enteros la cual su primer término comienza con un entero positivo y los términos restantes son generados de los anteriores inmediatos números.
La secuencia Juggler comenzando con el número 3: 5, 11, 36, 6, 2, 1
La secuencia Juggler comenzando desde el número 9:  9, 27, 140, 11, 36, 6, 2, 1
Dado un número n tenemos que imprimir la secuencia Juggler de este número como el primer número de la secuencia
- Los términos en la secuencia de Juggler primero crecen hasta un valor pico, y luego empiezan a decrecer.
- El último término de la secuencia de Juggler es siempre 1.
</texto>
  <complejidad_tiempo>null</complejidad_tiempo>
  <java>// Implementación java de la secuenca de Juggler

public class JugglerSequence {

    static void printJuggler(int n) {
        int a = n;
        // Imprime el primer termino
        System.out.print(a + &quot; &quot;);
        // Calcula terminos hasta que el ultimo no sea 1
        while (a != 1) {
            int b = 0;
            // Verifica si los previos terminos son pares o impares
            if (a % 2 == 0) // calcular siguiente termino
            {
                b = (int) Math.floor(Math.sqrt(a));
            } else // para impar anterior, calcular 
            // Siguiente termino
            {
                b = (int) Math.floor(Math.sqrt(a)
                        * Math.sqrt(a) * Math.sqrt(a));
            }
            System.out.print(b + &quot; &quot;);
            a = b;
        }
    }

    public static void main(String[] args) {
        printJuggler(3);
        System.out.println();
        printJuggler(9);
    }
} 
</java>
  <cpp>null</cpp>
  <py>null</py>
  <orden>6</orden>
  <suborden>53</suborden>
  <fecha_creacion>2020-12-04 22:01:06</fecha_creacion>
  <fecha_modificacion>2020-12-06 20:23:30</fecha_modificacion>
</row>
<row>
  <ID>86</ID>
  <supergrupo>Matemática</supergrupo>
  <tema>Secuencia Moser de Brujin</tema>
  <texto>Dado un entero n, imprima los primeros n términos de la secuencia de Moser de Brujin.
La secuencia de Moser de Brujin es una secuencia obtenida adicionando las distintas potencias del número 4, por ejemplo 1,4,16,6..
Debe notarse aquí que cualquier número el cual es la suma de potencias de 4 no distintas no son parte de la secuencia, por ejemplo 8 no es parte de la secuencia debido a que es formado de la suma de no distintas potencias de 4, que son 4 y 4.
Por lo tanto cualquier número el cual no sea una potencia de 4 y está presente en la secuencia debe ser la suma de distintas potencias de 4.
Por ejemplo, 21 es parte de la secuencia, incluso a través de que no es una potencia de 4 porque es la suma de distintas potencias de 4, que son 1,4 y 16.
</texto>
  <complejidad_tiempo>null</complejidad_tiempo>
  <java>// Codigo java que genera los primeros n terminos
// de la secuencia de  Moser-de Bruijn 

public class MoserdeBruijnSequence {

    public static int gen(int n) {
        // S(0) = 0 
        if (n == 0) {
            return 0;
        } // S(1) = 1 
        else if (n == 1) {
            return 1;
        } // S(2 * n) = 4 * S(n) 
        else if (n % 2 == 0) {
            return 4 * gen(n / 2);
        } // S(2 * n + 1) = 4 * S(n) + 1 
        else if (n % 2 == 1) {
            return 4 * gen(n / 2) + 1;
        }
        return 0;
    }

    public static void moserDeBruijn(int n) {
        for (int i = 0; i &lt; n; i++) {
            System.out.print(gen(i) + &quot; &quot;);
        }
        System.out.println();
    }

    public static void main(String args[]) {
        int n = 15;
        System.out.println(&quot;Primeros &quot; + n
                + &quot; terminos de la secuencia de  &quot;
                + &quot;Moser-de Bruijn  : &quot;);
        moserDeBruijn(n);
    }
} 
</java>
  <cpp>null</cpp>
  <py>null</py>
  <orden>6</orden>
  <suborden>54</suborden>
  <fecha_creacion>2020-12-04 22:01:06</fecha_creacion>
  <fecha_modificacion>2020-12-06 20:23:30</fecha_modificacion>
</row>
<row>
  <ID>87</ID>
  <supergrupo>Matemática</supergrupo>
  <tema>Secuencia Newman-Conway</tema>
  <texto>La secuencia de  Newman-Conway es aquella que genera la siguiente secuencia de enteros:
1 1 2 2 3 4 4 4 5 6 7 7…
En términos matemáticos, la secuencia P(n) de Newman-Conway es definida por la siguiente relación de recurrencia:
- P(n) = P(P(n - 1)) + P(n - P(n - 1)) with seed values P(1) = 1 and P(2) = 1
Dado un número n, imprima el enésimo número de la secuencia Newman-Conway
Complejidad de tiempo: O(n)
</texto>
  <complejidad_tiempo>null</complejidad_tiempo>
  <java>// Programa java que encuentra el nesimo  
// elemento de la secuencia de  Newman-Conway

public class NewmanConwaySequence {

    static int sequence(int n) {
        if (n == 1 || n == 2) {
            return 1;
        } else {
            return sequence(sequence(n - 1))
                    + sequence(n - sequence(n - 1));
        }
    }

    static int sequenceDP(int n) {
        int f[] = new int[n + 1];
        int i;
        f[0] = 0;
        f[1] = 1;
        f[2] = 1;

        for (i = 3; i &lt;= n; i++) {
            f[i] = f[f[i - 1]] + f[i - f[i - 1]];
        }
        return f[n];
    }

    public static void main(String args[]) {
        int n = 10;
        System.out.println(sequence(n));
    }
} 
</java>
  <cpp>null</cpp>
  <py>null</py>
  <orden>6</orden>
  <suborden>55</suborden>
  <fecha_creacion>2020-12-04 22:01:06</fecha_creacion>
  <fecha_modificacion>2020-12-06 20:23:31</fecha_modificacion>
</row>
<row>
  <ID>88</ID>
  <supergrupo>Matemática</supergrupo>
  <tema>Secuencia Padovan</tema>
  <texto>La secuencia de Padovan es similar a la secuencia de Fibonacci, con una secuencia recursiva similar cuya fórmula es: 
- P(n) = P(n-2) + P(n-3)
-  P(0) = P(1) = P(2) = 1 
</texto>
  <complejidad_tiempo>null</complejidad_tiempo>
  <java>// Programa JAVA que encuentra el enesimo termino
// de la secuencia de Padovan
// usando programación dinamica  

public class PadovanSequence {

    /* Función que calcula el número de Padovan*/
    static int pad(int n) {   //0,1 y 2 número de la serie es 1
        int pPrevPrev = 1, pPrev = 1,
                pCurr = 1, pNext = 1;
        for (int i = 3; i &lt;= n; i++) {
            pNext = pPrevPrev + pPrev;
            pPrevPrev = pPrev;
            pPrev = pCurr;
            pCurr = pNext;
        }
        return pNext;
    }

    public static void main(String args[]) {
        int n = 12;
        System.out.println(pad(n));
    }
} 

</java>
  <cpp>null</cpp>
  <py>null</py>
  <orden>6</orden>
  <suborden>56</suborden>
  <fecha_creacion>2020-12-04 22:01:06</fecha_creacion>
  <fecha_modificacion>2020-12-06 20:23:32</fecha_modificacion>
</row>
<row>
  <ID>89</ID>
  <supergrupo>Matemática</supergrupo>
  <tema>Secuencia Recaman</tema>
  <texto>Dado un entero n, imprima los primeros n elementos de la secuencia de Recaman
Es básicamente una función con dominio y co dominio como números naturales y 0, su recursividad se define de la siguiente manera.
Específicamente, dejamos a(n) denotar el (n+1)simo termino (0 ya está ahí).
La regla dice:
- a(0) = 0,
- Si n &gt; 0 y el número no está incluido en la secuencia 
- a(n) = a(n - 1) - n 
- si no
- a(n) = a(n-1) + n. 
Complejidad de tiempo: O(n^2)
</texto>
  <complejidad_tiempo>null</complejidad_tiempo>
  <java>// Programa java que imprime el nesimo número
// de la secuencia de Recaman

public class RecamanSequence {

    static void recaman(int n) {   
        //Crea un array que almacenara los terminos
        int arr[] = new int[n];
        // Primer termino de la secuencia es siempre 0
        arr[0] = 0;
        System.out.print(arr[0] + &quot; ,&quot;);
        // Llena terminos restantes usando formula recursiva
        for (int i = 1; i &lt; n; i++) {
            int curr = arr[i - 1] - i;
            int j;
            for (j = 0; j &lt; i; j++) {   
   // si arr[i-1] - i es negativo or ya existe 
                if ((arr[j] == curr) || curr &lt; 0) {
                    curr = arr[i - 1] + i;
                    break;
                }
            }
            arr[i] = curr;
            System.out.print(arr[i] + &quot;, &quot;);
        }
    }

    public static void main(String[] args) {
        int n = 17;
        recaman(n);
    }
} 
</java>
  <cpp>null</cpp>
  <py>null</py>
  <orden>6</orden>
  <suborden>57</suborden>
  <fecha_creacion>2020-12-04 22:01:06</fecha_creacion>
  <fecha_modificacion>2020-12-06 20:23:32</fecha_modificacion>
</row>
<row>
  <ID>90</ID>
  <supergrupo>Geometría</supergrupo>
  <tema>Longitud de arco</tema>
  <texto>Un ángulo se forma cuando dos rayos se encuentran en un punto en un plano, esos rayos forman  los lados del ángulo, y el punto de encuentro es referido como el vértice del ángulo. Hay que tener en cuenta que el plano que forma un ángulo no tiene que ser un plano Euclidiano, ahora en un círculo el largo de un arco es una porción de la circunferencia.
Dado un ángulo y el diámetro de un círculo, podemos calcular el largo de un arco usando la fórmula:
- ArcLength = ( 2 * pi * radio ) * ( ángulo / 360 )
- Donde  pi = 22/7,
- Diámetro = 2 * radio,
- El ángulo está en grados.
Si el ángulo es mayor o igual a 360 grados, entonces el largo del arco no puede ser calculado desde que ningún ángulo es posible.
</texto>
  <complejidad_tiempo>Mejor caso :    O(1)  Peor caso : O(1)  Promedio: O(1) </complejidad_tiempo>
  <java>//Programa java que calcula 
//la longitud de un arco 

public class ArcLength {

    static double arcLength(double diameter,
            double angle) {
        double pi = 22.0 / 7.0;
        double arc;
        if (angle &gt;= 360) {
            System.out.println(&quot;Angulo no puede ser fromado&quot;);
            return 0;
        } else {
            arc = (pi * diameter) * (angle / 360.0);
            return arc;
        }
    }

    public static void main(String args[]) {
        double diameter = 25.0;
        double angle = 45.0;
        double arc_len = arcLength(diameter, angle);
        System.out.println(arc_len);
    }
}
</java>
  <cpp>#include&lt;bits/stdc++.h&gt;
#include&lt;cstdlib&gt;
#define PI 22/7
//---------------//
using namespace std;
typedef long double ld;
ld arcLen(ld diametro,ld angulo){
    ld arc;
    if(angulo&gt;=360){
        cout&lt;&lt;&quot;el angulo no puede ser formado&quot;&lt;&lt;endl;
        return 0;
    }
    else{
        arc=(PI*diametro)*(angulo/360);
        return arc;
    }
}
ld DegToRad(ld d){
    return ((d * PI )/ 180);
}
ld RagToDeg(ld r){
    return ((r * 180 )/ PI);
}
int main() {
    ld d=5000;
    ld angle=140.5;
    printf(&quot;%.5llf&quot;,arcLen(d,angle));
}
</cpp>
  <py>from sys import stdin, stdout
rl = stdin.readline
wr = stdout.write

def arclen(diametro, angulo):
    pi = 22 / 7
    arc = 0
    if angulo &gt;= 360:
        wr(f&#39;Angulo no puede ser formado&#39;)
        return 0
    else:
        arc = (pi * diametro) * (angulo / 360)
        return arc

d = 5000
angle = 140.5
wr(f&#39;{arclen(d,angle)}&#39;)

</py>
  <orden>7</orden>
  <suborden>0</suborden>
  <fecha_creacion>2020-12-04 23:04:25</fecha_creacion>
  <fecha_modificacion>2020-12-06 20:25:37</fecha_modificacion>
</row>
<row>
  <ID>91</ID>
  <supergrupo>Geometría</supergrupo>
  <tema>Area de un sector circular</tema>
  <texto>Un sector circular o un sector círculo, es la porción de un disco encerrado por dos radios y un arco, donde el área más pequeña es conocida como el sector menor y el grande como el sector mayor.
- Sector =(pi*r^2)*(Angulo/360)
El área de un sector es similar al cálculo del área de un círculo, solo se le multiplica el área de un círculo con el ángulo del sector.
</texto>
  <complejidad_tiempo>Mejor caso :    O(1)  Peor caso : O(1)  Promedio: O(1) </complejidad_tiempo>
  <java>// Programa java que encuentra el area de un sector circular

public class AreaCircularSector {

    static void SectorArea(double radius, double angle) {
        if (angle &gt;= 360) {
            System.out.println(&quot;Angle not possible&quot;);
        } // Calculando el area
        else {
            double sector = ((22 * radius * radius) / 7)
                    * (angle / 360);
            System.out.println(sector);
        }
    }

    public static void main(String[] args) {
        double radius = 9;
        double angle = 60;
        SectorArea(radius, angle);
    }
}
</java>
  <cpp>#include&lt;bits/stdc++.h&gt;
#include&lt;cstdlib&gt;
#define PI 22/7
//---------------//
using namespace std;
typedef long double ld;
void setCir(ld radio,ld angle){
    if(angle&gt;=360){
        cout&lt;&lt;&quot;el angulo no es posible&quot;&lt;&lt;endl;
    }else{
        ld sector=((22*radio*radio)/7)*(angle/360);
        printf(&quot;%.8llf\n&quot;,sector);
    }
}
int main() {
    ld radio=6;
    ld angle=22.7;
    setCir(radio,angle);
} 
</cpp>
  <py>null</py>
  <orden>7</orden>
  <suborden>1</suborden>
  <fecha_creacion>2020-12-04 23:04:26</fecha_creacion>
  <fecha_modificacion>2020-12-06 20:25:38</fecha_modificacion>
</row>
<row>
  <ID>92</ID>
  <supergrupo>Geometría</supergrupo>
  <tema>Circulo circunscrito en un triángulo equilátero</tema>
  <texto>Dado el largo de los lados de un triángulo equilátero, necesitamos encontrar el área de un circuncirculo del triángulo dado. Todos los lados del triángulo equilátero son de igual largo, y todos los ángulos interiores son de 60 grados.
Las propiedades de un circuncirculo son las siguientes:
- El centro del circuncirculo es el punto donde las medianas del triángulo equilátero se intersectan.
- El circulo circuncirculo de un triángulo equilátero es hecho a través de los tres vértices de un triángulo equilátero.
- El radio de un circuncirculo de un triángulo equilátero es igual a (a/v3), donde ‘a’ es el largo de los lados del triángulo equilátero
La fórmula usada para calcular el área de un círculo circuncirculo es:
-  (p*a^2)/3
Donde a es el largo del lado del triángulo dado.
Sabemos que el área de un circulo es p*r^2, donde r es el radio del circulo dado. 
También sabemos que el radio de un circuncirculo de un triángulo equilátero = (Lado del triángulo/v3. 
Por lo tanto, área = p*r^2 = p*a^2/3.
</texto>
  <complejidad_tiempo>Mejor caso :    O(1)  Peor caso : O(1)  Promedio: O(1) </complejidad_tiempo>
  <java>// código Java para encontrar el área de
// un círculo curcunscripto a un triángulo equilátero

public class CircumscribedCircleOfEquilateral {

    static double PI = 3.14159265;
    //Función que encuentra el area
    // del circulo circumscrito
    public static double area_cicumscribed(double a) {
        return (a * a * (PI / 3));
    }

    public static void main(String[] args) {
        double a = 6.0;
        System.out.println(&quot;Area of circumscribed circle is :&quot;
                + area_cicumscribed(a));
    }
}
</java>
  <cpp>#include&lt;bits/stdc++.h&gt;
#include&lt;cstdlib&gt;
#define PI 22/7
//---------------//
using namespace std;
typedef long double ld;
ld areaEquilatero(ld lado){
    return (lado*lado*(PI/3));
}
int main() {
    ld a=6;
    printf(&quot;%.8llf&quot;,areaEquilatero(a));
}
</cpp>
  <py>from sys import stdin, stdout
import math
rl = stdin.readline
wr = stdout.write

def area_circumscribed(a):
    return (a * a * (math.pi / 3))

a = int(rl())
wr(f&#39;Area de circulo circunscrito: {area_circumscribed(a)}&#39;)
</py>
  <orden>7</orden>
  <suborden>2</suborden>
  <fecha_creacion>2020-12-04 23:04:26</fecha_creacion>
  <fecha_modificacion>2020-12-06 20:25:39</fecha_modificacion>
</row>
<row>
  <ID>93</ID>
  <supergrupo>Geometría</supergrupo>
  <tema>Convex Hull (Envoltorio convexo)</tema>
  <texto>Se define como la envolvente convexa, envoltura convexa o cápsula convexa de un conjunto de puntos X de dimensión n como la intersección de todos los conjuntos convexos que contienen a X.
En el caso particular de puntos en un plano, si no todos los puntos están alineados, entonces su envolvente convexa corresponde a un polígono convexo cuyos vértices son algunos de los puntos del conjunto inicial de puntos.
Una forma intuitiva de ver la envolvente convexa de un conjunto de puntos en el plano, es imaginar una banda elástica estirada que los encierra a todos. Cuando se libere la banda elástica tomará la forma de la envolvente convexa.
</texto>
  <complejidad_tiempo>Mejor caso :    O(nlog(n))  Peor caso : O(n2)  Promedio: O(n*puntostomados) </complejidad_tiempo>
  <java>// Programa java que halla el casco convexo de un set de puntos

import java.util.*;

public class ConvexHull {

    static class Point {
        int x, y;
        Point(int x, int y) {
            this.x = x;
            this.y = y;
        }
    }
    // Para encontrar la orientación de la tripleta
    //la función retorna lo siguiente 
    // 0 --&gt; p, q y r son colineares 
    // 1 --&gt; Manecillas de reloj
    // 2 --&gt; en contra de las manecillas
    static int orientation(Point p, Point q, Point r) {
        int val = (q.y - p.y) * (r.x - q.x)
                - (q.x - p.x) * (r.y - q.y);
        if (val == 0) {
            return 0;  // colinear
        }
        return (val &gt; 0) ? 1 : 2; // Manecillas
    }
    //Imprime el casco convexo del set de puntos

    static void convexHull(Point points[], int n) {
        //Debe haber al menos 3 puntos
        if (n &lt; 3) {
            return;
        }
        // Inicializar resultado
        ArrayList&lt;Point&gt; hull = new ArrayList&lt;&gt;();
        // Encuentra el punto de más a la izquierda 
        int l = 0;
        for (int i = 1; i &lt; n; i++) {
            if (points[i].x &lt; points[l].x) {
                l = i;
            }
        }
        // Comienza desde el punto más a la izquierda, sigue moviéndose.
        // en sentido antihorario hasta llegar al punto de inicio
        // otra vez. Este ciclo corre O (h) veces donde h es
        // número de puntos en resultado o salida
        int p = l, q;
        do {
            // Agrega el punto actual al resultado
            hull.add(points[p]);
            // Buscar un punto &#39;q&#39; tal que
            // la orientación (p, x, q) es antihorario
            // para todos los puntos &#39;x&#39;. La idea es mantener
            // pista de los últimos visitados más contra reloj
            // punto en q. Si algún punto &#39;i&#39; es más
            // en sentido contrario a las agujas del reloj que q, luego                         //actualiza q.
            q = (p + 1) % n;
            for (int i = 0; i &lt; n; i++) {
                //Si i es más antihorario que el actual q, actualice q
                if (orientation(points[p], points[i], points[q])
                        == 2) {
                    q = i;
                }
            }
            //Ahora q es el más antihoriario con respecto
            // a p, ubica p como q para la siguiente iteración
            // asi q es agregado al casco resultado
            p = q;
        } while (p != l);
        // Mientras no vengamos del primer punto
        // Imprima resultado
        for (Point temp : hull) {
            System.out.println(&quot;(&quot; + temp.x + &quot;, &quot;
                    + temp.y + &quot;)&quot;);
        }
    }

    public static void main(String[] args) {
        Point points[] = new Point[7];
        points[0] = new Point(0, 3);
        points[1] = new Point(2, 3);
        points[2] = new Point(1, 1);
        points[3] = new Point(2, 1);
        points[4] = new Point(3, 0);
        points[5] = new Point(0, 0);
        points[6] = new Point(3, 3);
        int n = points.length;
        convexHull(points, n);
    }
}
</java>
  <cpp>#include&lt;bits/stdc++.h&gt;
#include&lt;cstdlib&gt;
#define x first
#define y second
//---------------//
using namespace std;
typedef pair&lt;int, int&gt; point;

int orientation(point p, point q, point r) {
    int val = (q.y - p.y)*(r.x - q.x)-(q.x - p.x)*(r.y - q.y);
    if (val == 0) {
        return 0;
    }
    return (val &gt; 0 ? 1 : 2);
}

void convexHull(point po[], int n) {
    if (n &lt; 3) {
        return;
    }
    vector&lt;point&gt;hull;
    int l = 0;
    for (int i = 1; i &lt; n; i++) {
        if (po[i].x &lt; po[l].x) {
            l = i;
        }
    }
    int p = l, q;
    do {
        hull.push_back(po[p]);
        q = (p + 1) % n;
        for (int i = 0; i &lt; n; i++) {
            if (orientation(po[p], po[i], po[q]) == 2) {
                q = i;
            }
        }
        p = q;
    } while (p != l);
    for (point punto : hull) {
        printf(&quot;{%d,%d}\n&quot;, punto.x, punto.y);
    }
}

int main() {
    point po[7];
    po[0] = make_pair(0, 3);
    po[1] = make_pair(2, 3);
    po[2] = make_pair(1, 1);
    po[3] = make_pair(2, 1);
    po[4] = make_pair(3, 0);
    po[5] = make_pair(0, 0);
    po[6] = make_pair(3, 3);
    convexHull(po, 7);
} 
</cpp>
  <py>null</py>
  <orden>7</orden>
  <suborden>3</suborden>
  <fecha_creacion>2020-12-04 23:04:26</fecha_creacion>
  <fecha_modificacion>2020-12-06 20:25:39</fecha_modificacion>
</row>
<row>
  <ID>94</ID>
  <supergrupo>Geometría</supergrupo>
  <tema>Sumatoria de cortes</tema>
  <texto>Dado el número de cortes, encuentre el máximo número de posibles piezas.
Este problema no es más que el problema del cartero flojo, y tiene la siguiente formula.
Máximo número de piezas  = 1 + n*(n+1)/2
</texto>
  <complejidad_tiempo>Mejor caso :    O(1)  Peor caso : O(1)  Promedio: O(1) </complejidad_tiempo>
  <java>//Programa que calcula el maximo número
// de piezas de pizza dados el número de cortes

public class CutsSumatory {

    static int findMaximumPieces(int n) {
        return 1 + n * (n + 1) / 2;
    }

    public static void main(String arg[]) {

System.out.print(findMaximumPieces(3));
    }
} 
</java>
  <cpp>#include&lt;bits/stdc++.h&gt;
#include&lt;cstdlib&gt;
//---------------//
using namespace std;
int findMaxSum(int n){
    return 1 + n* (n+1) / 2;
}
int main() {
    int a=5;
    cout&lt;&lt;findMaxSum(a)&lt;&lt;endl;
} 
</cpp>
  <py>null</py>
  <orden>7</orden>
  <suborden>4</suborden>
  <fecha_creacion>2020-12-04 23:04:26</fecha_creacion>
  <fecha_modificacion>2020-12-06 20:25:40</fecha_modificacion>
</row>
<row>
  <ID>95</ID>
  <supergrupo>Geometría</supergrupo>
  <tema>Formula de Heron</tema>
  <texto>En geometría plana elemental la fórmula de Herón, cuya invención se atribuye al matemático griego Herón de Alejandría, da el área de un triángulo conociendo las longitudes de sus tres lados a, b y c:
Area=v(s(s-a)(s-b)(s-c))
</texto>
  <complejidad_tiempo>Mejor caso :    O(1)  Peor caso : O(1)  Promedio: O(1) </complejidad_tiempo>
  <java>//Programa Java que calcula el area
// De un triángulo usando la formula de Herón

public class HeronFormula {

    public static void main(String[] args) {
        //Enviar las coordenadas de los vertices
        System.out.println(heron(1, 0, -1, 0, 0, 2));
    }
    //función que usa la formula de Herón
    static double heron(double x1, double y1, double x2,
            double y2, double x3, double y3) {
        double a = Math.sqrt((x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2));
        double b = Math.sqrt((x1 - x3) * (x1 - x3) + (y1 - y3) * (y1 - y3));
        double c = Math.sqrt((x3 - x2) * (x3 - x2) + (y3 - y2) * (y3 - y2));
        double s = (a + b + c) / 2.0;
        double A = Math.sqrt(s * (s - a) * (s - b) * (s - c));
        return A;
    }

}
</java>
  <cpp>#include&lt;bits/stdc++.h&gt;
#include&lt;cstdlib&gt;
#define point pair&lt;double,double&gt;
#define x first
#define y second
//---------------//
using namespace std;

double heron(double x1,double y1,double x2,double y2,double x3,double y3){
    double a =std::sqrt((x1-x2)*(x1-x2)+(y1-y2)*(y1-y2));
    double b =std::sqrt((x2-x3)*(x2-x3)+(y2-y3)*(y2-y3));
    double c =std::sqrt((x3-x1)*(x3-x1)+(y3-y1)*(y3-y1));
    double s=(a+b+c)/2;
    return (std::sqrt(s*(s-a)*(s-b)*(s-c)));

}
int main() {
    cout&lt;&lt;heron(1,0,-1,0,0,2)&lt;&lt;endl;
} 
</cpp>
  <py>null</py>
  <orden>7</orden>
  <suborden>5</suborden>
  <fecha_creacion>2020-12-04 23:04:27</fecha_creacion>
  <fecha_modificacion>2020-12-06 20:25:41</fecha_modificacion>
</row>
<row>
  <ID>96</ID>
  <supergrupo>Geometría</supergrupo>
  <tema>Area de un hexágono</tema>
  <texto>Un hexágono es una figura geométrica de 6 lados, en dos dimensiones, el total de la suma de los ángulos internos de cualquier hexágono es 720°. Un hexágono regular tiene 6 simetrías rotacionales, y 6 simetrías reflectivas, todos los ángulos internos son de 120 grados.
Ahí hay principalmente 6 triángulos equiláteros de lado n y el área de un triángulo equilátero es sqrt (3)/4*n*n. Desde el hexágono, hay en total 6 triángulos equiláteros con lado n, el área del hexágono se convierte en (3*sqrt (3)/2) * n * n)
</texto>
  <complejidad_tiempo>Mejor caso :    O(1)  Peor caso : O(1)  Promedio: O(1) </complejidad_tiempo>
  <java>//Programa Java que calcula el area de un Hexagono

public class HexagonArea {

    public static double hexagonArea(double s) {
        return ((3 * Math.sqrt(3)
                * (s * s)) / 2);
    }

    public static void main(String[] args) {
        // Largo de un lado
        double s = 4;
        System.out.print(&quot;Area: &quot;
                + hexagonArea(s));
        System.out.println(&quot;&quot;);
    }
}
</java>
  <cpp>#include&lt;bits/stdc++.h&gt;
#include&lt;cstdlib&gt;
//---------------//
using namespace std;
double hexArea(double s){
    return (3*sqrt(3)*(s*s))/2;
}
int main() {
    double s=6;
    printf(&quot;%.8f\n&quot;,hexArea(6));
} 
</cpp>
  <py>null</py>
  <orden>7</orden>
  <suborden>6</suborden>
  <fecha_creacion>2020-12-04 23:04:27</fecha_creacion>
  <fecha_modificacion>2020-12-06 20:25:41</fecha_modificacion>
</row>
<row>
  <ID>97</ID>
  <supergrupo>Geometría</supergrupo>
  <tema>Area de un polígono</tema>
  <texto>Dadas ordenadamente las coordenadas de un polígono, con n vértices, encontrar el área del polígono. Aquí ordenado significa que las coordenadas son dadas en sentido horario o anti horario, desde el primer vértice hasta el último.

Podemos dividir un polígono en triángulos, la fórmula del área es derivada de tomar cada camino AB, y calcular el área del triángulo ABO, con un vértice de origen O, tomando el producto cruz (El cual da el área de un paralelogramo) y dividiendo por 2. Mientras pasemos alrededor del polígono, estos triángulos con área positiva o negativa se sobreponen, y las ares en medio del origen y el polígono pueden ser canceladas y sumadas a 0, mientras solo haya área interna, el triángulo de referencia de mantiene.
</texto>
  <complejidad_tiempo>Mejor caso :    O(nlog(n))  Peor caso : O(nlog(n))  Promedio: O(nlog(n)) </complejidad_tiempo>
  <java>//Programa Java que calcula el area de un poligono

import java.awt.Point;
import java.awt.Polygon;
import java.util.Arrays;

public class AreaOfPolygon {

    public static void main(String[] args) {
        //Crea el poligono con los puntos dados
        Polygon p = new Polygon();
        p.addPoint(0, 2);
        p.addPoint(2, 2);
        p.addPoint(2, 0);
        p.addPoint(0, 0);
        System.out.println(area(p));
    }
    //Por medio de triángulos va calculando el area completa
    static int signedTriangleArea(Point a, Point b, Point c) {
        return a.x * b.y - a.y * b.x + a.y * c.x - a.x * c.y + b.x * c.y - c.x * b.y;
    }
    static boolean ccw(Point a, Point b, Point c) {
        return signedTriangleArea(a, b, c) &gt; 0;
    }
    // Verifica si los puntos son colineares
    static boolean collinear(Point a, Point b, Point c) {
        return signedTriangleArea(a, b, c) == 0;
    }
    //Calcula la distancia entre dos puntos
    static double distance(Point p1, Point p2) {
        double dx = p1.x - p2.x;
        double dy = p1.y - p2.y;
        return Math.sqrt(dx * dx + dy * dy);
    }
    //Función que calcula el area de cualquier poligono
    static double area(Polygon poly) {
        int N = poly.npoints;
        int[] x = poly.xpoints;
        int[] y = poly.ypoints;
        Point[] p = new Point[N];
        for (int i = 0; i &lt; N; ++i) {
            p[i] = new Point(x[i], y[i]);
        }
        final Point first;
        int min = 0;
        for (int i = 1; i &lt; N; i++) {
            if (p[i].y &lt; p[min].y) {
                min = i;
            } else if (p[i].y == p[min].y) {
                if (p[i].x &lt; p[min].x) {
                    min = i;
                }
            }
        }
        first = p[min];
        p[min] = p[0];
        p[0] = first;
        //Usar expresion lambda en vez de comparator
        Arrays.sort(p, 1, N, (Point p1, Point p2) -&gt; {
            if (collinear(first, p1, p2)) {
                return Double.compare(distance(first, p1), distance(first, p2));
            }
            if (ccw(first, p1, p2)) {
                return -1;
            } else {
                return 1; 
            }
        });
        double A = 0.0;
        for (int i = 0; i &lt; N; i++) {
            int j = (i + 1) % N;
            A += p[i].x * p[j].y - p[j].x * p[i].y;
        }
        return A / 2.0;

    }
} 
</java>
  <cpp>null</cpp>
  <py>null</py>
  <orden>7</orden>
  <suborden>7</suborden>
  <fecha_creacion>2020-12-04 23:04:27</fecha_creacion>
  <fecha_modificacion>2020-12-06 20:25:42</fecha_modificacion>
</row>
<row>
  <ID>98</ID>
  <supergrupo>Geometría</supergrupo>
  <tema>Intersección de líneas</tema>
  <texto>Dados puntos A y B, correspondientes a la línea AB y los puntos P y Q, correspondientes a la línea PQ, encuentre el punto de intersección de estas líneas. Los puntos están dados en un plano 2D con sus coordenadas X y Y.
Primero que todo, asumimos que tenemos dos puntos (x1,y1,) y (x2,y2). Ahora encontramos la ecuación de la línea formada por esos puntos.
Dejaremos que las líneas dadas sean:
- a1x + b1y = c1
- a2x + b2y = c2
Tenemos que ahora resolver estas dos ecuaciones para encontrar el punto de intersección, para resolver esto, multiplicamos a1 por b2 y a2 por b1, esto nos da:
- a1b2x + b1b2y = c1b2
- a2b1x + b2b1y = c2b1
Restando esto obtenemos:
- (a1b2 – a2b1) x = c1b2 – c2b1
Esto nos da el valor de x. similarmente podemos encontrar el valor de y, (x,y) nos da el punto de intersección.
Esto nos da el punto de intersección de dos líneas, pero si nos dan segmentos de línea en vez de líneas, tenemos que revisar el punto que computado yace en ambos segmentos de líneas,
Si el segmento de línea es especificado por los puntos (x1,y2) y (x2,y2), entonces debemos verificar si (x,y) está en el segmento que tenemos de la siguiente manera:
- min (x1, x2) &lt;= x &lt;= max (x1, x2)
- min (y1, y2) &lt;= y &lt;= max (y1, y2)
</texto>
  <complejidad_tiempo>Mejor caso :    O(1)  Peor caso : O(1)  Promedio: O(1) </complejidad_tiempo>
  <java>//Implementación Java que encuentra el punto de
//interseccion de dos lineas

public class LineLineIntersection {
    //Clase usada para almacenar las coordenadas X y la Y    
    // de un punto respectivo
    static class Point {
        double x, y;
        public Point(double x, double y) {
            this.x = x;
            this.y = y;
        }
        // Metodo usado para imprimir las cordenadas
        // X y Y de un punto
        static void displayPoint(Point p) {
            System.out.println(&quot;(&quot; + p.x + &quot;, &quot; + p.y + &quot;)&quot;);
        }
    }

    static Point lineLineIntersection(Point A, Point B, Point C, Point D) {
        // Linea AB representada como a1x + b1y=c1
        double a1 = B.y - A.y;
        double b1 = A.x - B.x;
        double c1 = a1 * (A.x) + b1 * (A.y);
        // Linea CD representada como a2x + b2y=c2
        double a2 = D.y - C.y;
        double b2 = C.x - D.x;
        double c2 = a2 * (C.x) + b2 * (C.y);
        double determinant = a1 * b2 - a2 * b1;
        if (determinant == 0) {
            //Las lineas son pararelas, esto es simplificado
            //Retornando un par de FLT_MAX
            return new Point(Double.MAX_VALUE, Double.MAX_VALUE);
        } else {
            double x = (b2 * c1 - b1 * c2) / determinant;
            double y = (a1 * c2 - a2 * c1) / determinant;
            return new Point(x, y);
        }
    }

    public static void main(String args[]) {
        Point A = new Point(1, 1);
        Point B = new Point(4, 4);
        Point C = new Point(1, 8);
        Point D = new Point(2, 4);
        Point intersection = lineLineIntersection(A, B, C, D);
        if (intersection.x == Double.MAX_VALUE
                &amp;&amp; intersection.y == Double.MAX_VALUE) {
            System.out.println(&quot;la linea AB y CD son paralelas.&quot;);
        } else {
            System.out.print(&quot;La intersección de las lineas AB &quot;+ &quot;y CD es: &quot;);
            Point.displayPoint(intersection);
        }
    }
} 
</java>
  <cpp>null</cpp>
  <py>null</py>
  <orden>7</orden>
  <suborden>8</suborden>
  <fecha_creacion>2020-12-04 23:04:28</fecha_creacion>
  <fecha_modificacion>2020-12-06 20:25:42</fecha_modificacion>
</row>
<row>
  <ID>99</ID>
  <supergrupo>Geometría</supergrupo>
  <tema>Punto medio de una línea</tema>
  <texto>Dado dos coordenadas de una línea iniciando en (x1,y1) y terminando en (x2,y2) encontrar el punto medio de una línea.
El punto medio de dos puntos (x1,y1) y (x2,y2) es el punto M encontrado con la siguiente fórmula:
- M = ((x1+x2)/2 , (y1+y2)/2)
</texto>
  <complejidad_tiempo>Mejor caso :    O(1)  Peor caso : O(1)  Promedio: O(1) </complejidad_tiempo>
  <java>//Programa java para buscar
//el punto medio de una linea

public class LineMidPoint {

    static void midpoint(int x1, int x2,
            int y1, int y2) {
        System.out.print((x1 + x2) / 2
                + &quot; , &quot; + (y1 + y2) / 2);
    }

    public static void main(String[] args) {
        int x1 = -1, y1 = 2;
        int x2 = 3, y2 = -6;
        midpoint(x1, x2, y1, y2);

    }
}
</java>
  <cpp>#include &lt;iostream&gt;

using namespace std;

string midPoint(int x1, int x2, int y1, int y2){
    string res1 = std::to_string((x1+x2)&gt;&gt;1);
    string res2 = std::to_string((y1+y2)&gt;&gt;1);
    return (res1+&quot;, &quot;+res2);
}

int main()
{
    ios_base::sync_with_stdio(false);cin.tie(NULL);cout.tie(NULL);
    int x1, x2; cin&gt;&gt;x1&gt;&gt;x2;
    int y1, y2; cin&gt;&gt;y1&gt;&gt;y2;
    cout&lt;&lt;midPoint(x1, x2, y1, y2)&lt;&lt;endl;
    return 0;
}
</cpp>
  <py>from sys import stdin,stdout

# m = ((x1+x2)/2 , (y1+y2)/2)

def midpoint(x1,y1,x2,y2):
    res = str(((x1+x2)/2))+&quot; , &quot;+str(((y1+y2)/2))
    return res

x1,y1,x2,y2 = stdin.readline().strip().split()

x1,y1,x2,y2 = int(x1),int(y1),int(x2),int(y2)

medio = midpoint(x1, y1, x2, y2)

stdout.write(f&quot;el punto medio es: {medio}&quot;)
</py>
  <orden>7</orden>
  <suborden>9</suborden>
  <fecha_creacion>2020-12-04 23:04:28</fecha_creacion>
  <fecha_modificacion>2020-12-06 20:25:43</fecha_modificacion>
</row>
<row>
  <ID>100</ID>
  <supergrupo>Geometría</supergrupo>
  <tema>Línea dados dos puntos</tema>
  <texto>Dados dos puntos P(x1,y1) y Q(x2,y2), encuentre la ecuación de la línea formada por esos dos puntos.
Cualquier línea puede ser representada como:
- ax + by = c
Dejamos dos puntos que satisfagan la línea dada, entonces tenemos:
-  ax1 + by1 = c
- ax2 + by2 = c
Podemos cambiar los siguientes valores para que la ecuación de mantenga verdadera:
- a = y2 - y1
- b = x1 - x2
- c = ax1 + by1
</texto>
  <complejidad_tiempo>Mejor caso :    O(1)  Peor caso : O(1)  Promedio: O(1) </complejidad_tiempo>
  <java>//Implementación Java para encontrar la linea
//que pasa atraves de dos puntos

public class LineThroughTwoPoints {

    public static void main(String[] args) {
        Pair P = new Pair(3, 2);
        Pair Q = new Pair(2, 6);
        lineFromPoints(P, Q);
    }

    static void lineFromPoints(Pair P, Pair Q) {
        double a = Q.second - P.second;
        double b = P.first - Q.first;
        double c = a * (P.first) + b * (P.second);
        if (b &lt; 0) {
            System.out.println(&quot;La linea que pasa a traves de &quot;
                    + &quot;los puntos P y Q es: &quot;
                    + a + &quot;x &quot; + b + &quot;y = &quot; + c);
        } else {
            System.out.println(&quot;La linea que pasa a traves de l&quot;
            + &quot;os puntos P y Q es: &quot;
                    + a + &quot;x + &quot; + b + &quot;y = &quot; + c);
        }
    }
    /* Este par  es usado para almacenar la X y Y
    de un punto respectivamente*/
    static class Pair {
        int first;
        int second;
        public Pair(int first, int second) {
            this.first = first;
            this.second = second;
        }
    }
}
</java>
  <cpp>#include&lt;bits/stdc++.h&gt;
#include&lt;cstdlib&gt;
#define x first
#define y second
using namespace std;
typedef pair&lt;int,int&gt; point;
void lineFromPoints(point P,point Q){
    double a=Q.y-P.y;
    double b=P.x-Q.x;
    double c=a*(P.x)+b*(P.y);
    if(b &lt; 0){
        cout&lt;&lt;&quot;La linea que pasa a traves de los puntos P y Q es:&quot;&lt;&lt;&quot;(&quot;&lt;&lt;a&lt;&lt;&quot;x) * (&quot;&lt;&lt;b&lt;&lt;&quot;y) = &quot;&lt;&lt;c&lt;&lt;endl;
    }else{
        cout &lt;&lt; &quot;La linea que pasa a traves de los punto P y Q es:&quot;&lt;&lt;a&lt;&lt;&quot;x + &quot; &lt;&lt; b &lt;&lt; &quot;y = &quot; &lt;&lt; c &lt;&lt; endl;
    }
}
int main() {
    point p=make_pair(3,2);
    point q=make_pair(2,6);
    lineFromPoints(p,q);
} 
</cpp>
  <py>null</py>
  <orden>7</orden>
  <suborden>10</suborden>
  <fecha_creacion>2020-12-04 23:04:28</fecha_creacion>
  <fecha_modificacion>2020-12-06 20:25:44</fecha_modificacion>
</row>
<row>
  <ID>101</ID>
  <supergrupo>Geometría</supergrupo>
  <tema>Triángulo de monedas ordenadas</tema>
  <texto>Tenemos N monedas las cuales necesitamos ordenar en forma de triángulo, por ejemplo la primera fila podrá tener una moneda, la segunda fila dos monedas y así en adelante, necesitamos saber la máxima altura que podemos obtener usando esas N monedas.
Este problema puede ser resuelto encontrando la relación entre la altura del triángulo y el número de monedas, dejamos como la altura máxima como H, luego la suma total de monedas debe ser menos de N.
</texto>
  <complejidad_tiempo>Mejor caso :    O(1)  Peor caso : O(1)  Promedio: O(1) </complejidad_tiempo>
  <java>// Programa java que encuentra la maxima altura
// de un triángulo de monedas arregladas

public class ArrangedCoinTriangle {

    /*Retrorna el la raiz cuadrada de n
    Note como la función lo realiza*/
    static float squareRoot(float n) {
        /*Usamos n como aproximción inicial*/
        float x = n;
        float y = 1;
        // Se decide el nivel de precisión
        float e = 0.000001f;
        while (x - y &gt; e) {
            x = (x + y) / 2;
            y = n / x;
        }
        return x;
    }
    //Metodo que encuentra la maxima altura
    //del arreglo de monedas
    static int findMaximumHeight(int N) {
        //Calculando la porción interna
        //de la raiz cuadrada
        int n = 1 + 8 * N;
        int maxH = (int) (-1 + squareRoot(n)) / 2;
        return maxH;
    }

    public static void main(String[] args) {
        int N = 12;
        System.out.print(findMaximumHeight(N));
    }
}
</java>
  <cpp>#include &lt;iostream&gt;
using namespace std;

int findMaxH(int);
float squareRoot(float);

int main() {
    int N = 12;
    cout &lt;&lt; findMaxH(N) &lt;&lt; endl;
}

int findMaxH(int n) {
    int n1 = 1 + 8 * n;
    int maxh = (int) (-1 + squareRoot(n1) / 2);
    return maxh;
}

float squareRoot(float n) {
    float x = n;
    float y = 1;
    float e = 0.0000001f;
    while (x - y &gt; e) {
        x = (x + y) / 2;
        y = n / x;
    }
    return x;
}
</cpp>
  <py>from sys import stdin
from sys import stdout

def findMaxH(n):
    n1 = 1 + 8 * n
    maxh = int(-1 + squareRoot(n1) / 2)
    return maxh

def squareRoot(n):
    x = n
    y = 1
    e = 0.000001
    while x - y &gt; e:
        x = (x + y) / 2
        y = n / x
    return x

N = 12
stdout.write(f&quot;{findMaxH(N)}&quot;)
</py>
  <orden>7</orden>
  <suborden>11</suborden>
  <fecha_creacion>2020-12-04 23:04:29</fecha_creacion>
  <fecha_modificacion>2020-12-06 20:25:44</fecha_modificacion>
</row>
<row>
  <ID>102</ID>
  <supergrupo>Geometría</supergrupo>
  <tema>Perímetro usando bloques</tema>
  <texto>Tenemos n bloques de tamaño 1x1, necesitamos encontrar el mínimo perímetro de una matriz hecha de estos bloques.


Si hacemos algunos ejemplos usando lápiz y papel, podemos notar que el perímetro se vuelve mínimo cuando la figura formada es más cercana a un cuadrado. La razón de esto es, que queremos el máximo de lados de bloques que miren dentro de la figura, entonces el perímetro de la figura se vuelve mínimo.
Si el número de bloques es un cuadrado perfecto, entonces el perímetro puede ser simplemente 4*sqrt(n).
Pero si el número de bloques no es una raíz cuadrada perfecta, entonces nosotros calculamos el número de filas y columnas cercanas a la raíz cuadrada, luego de arreglar los bloques en un rectángulo, y tenemos bloques restantes, simplemente podemos agregar 2 al perímetro porque solo 2 lados extra faltarían.
</texto>
  <complejidad_tiempo>Mejor caso :    O(1)  Peor caso : O(1)  Promedio: O(1) </complejidad_tiempo>
  <java>/*Codigo JAVA que permire encontrar el minimo
perimetro usando n bloques*/
public class PerimeterUsingBlocks {

    public static long minPerimeter(int n) {
        int l = (int) Math.sqrt(n);
        int sq = l * l;
        //si n es un cudrado perfeto
        if (sq == n) {
            return l * 4;
        } else {
            //Número de filas
            long row = n / l;
            //Perimetro de la matriz rectangular
            long perimeter
                    = 2 * (l + row);
            // Si hay bloques restantes
            if (n % l != 0) {
                perimeter += 2;
            }
            return perimeter;
        }
    }

    public static void main(String[] args) {
        int n = 10;
        System.out.println(minPerimeter(n));
    }
}
</java>
  <cpp>#include &lt;iostream&gt;
#include &lt;cmath&gt;

using namespace std;

long minPerimeter(int n) {
    int x = (int) sqrt(n);
    int sq = x * x;
    if (sq == n) {
        return x &lt;&lt; 2;
    } else {
        long row = n / x;
        long perimeter = (x + row) &lt;&lt; 1;
        if (n % x != 0) {
            perimeter += 2;
        }
        return perimeter;
    }
}

int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(NULL);
    cout.tie(NULL);
    int n;
    cin&gt;&gt;n;
    cout &lt;&lt; minPerimeter(n) &lt;&lt; endl;
    return 0;
}
</cpp>
  <py>import math
from collections import namedtuple
from sys import stdin, stdout
rl = stdin.readline
wr = stdout.write


def minPerimeter(n):
    l = int(math.sqrt(n))
    sq = l * l
    if sq == n:
        return l * 4
    else:
        row = n // l
        perimeter = 2 * (l + row)
        if n % l != 0:
            perimeter += 2
        return perimeter


n = int(rl())
wr(f&#39;{minPerimeter(n)}&#39;)
</py>
  <orden>7</orden>
  <suborden>12</suborden>
  <fecha_creacion>2020-12-04 23:04:29</fecha_creacion>
  <fecha_modificacion>2020-12-06 20:25:45</fecha_modificacion>
</row>
<row>
  <ID>103</ID>
  <supergrupo>Geometría</supergrupo>
  <tema>Punto dentro de un triangulo</tema>
  <texto>Dados tres puntos esquina de un triángulo, y un punto más P, verifique si P yace dentro del triángulo o no.
Dejaremos las coordenadas de las tres esquinas ser (x1, y1), (x2, y2) y (x3, y3), y las coordenadas de P ser (x, y). 
1) Calcular área del triángulo dado, por ejemplo el área del triángulo ACB:  Area A = [ x1(y2 – y3) + x2(y3 – y1) + x3(y1-y2)]/2
2) Calcular el área del triángulo PAB. Podemos usar la misma fórmula para esto, dejamos esta área ser A1.
3) Calculamos el área del triángulo PBC, dejamos esta área ser A2.
4) Calcular el área del triángulo PAC, dejaremos esta área ser A3.
5) Si P yace dentro del triángulo, entonces A1+A2+A3 debe ser igual a A.
</texto>
  <complejidad_tiempo>Mejor caso :    O(1)  Peor caso : O(1)  Promedio: O(1) </complejidad_tiempo>
  <java>//Codigo Java que verifica cuando un punto
//yace dentro de un triángulo o no

public class PointInsideTriangle {

    /* Una función de utilidad que calcula el 
    area del triángulo formado por (x1, y1) (x2, y2) y (x3, y3)*/
    static double area(int x1, int y1, int x2, int y2,
            int x3, int y3) {
        return Math.abs((x1 * (y2 - y3) + x2 * (y3 - y1)
                + x3 * (y1 - y2)) / 2.0);
    }

    /* Una función que verifica cu cualquier punto P(x,y)
    yace dentro de un triángulo formado por (x1, y1), 
    B(x2, y2) and C(x3, y3) */
    static boolean isInside(int x1, int y1, int x2,
            int y2, int x3, int y3, int x, int y) {
        /* Calcula el area del triángulo ABC */
        double A = area(x1, y1, x2, y2, x3, y3);
        /* Calcula el area del triángulo PCB */
        double A1 = area(x, y, x2, y2, x3, y3);
        /* Calcula el area del triángulo PAC */
        double A2 = area(x1, y1, x, y, x3, y3);
        /* Calcula el area del triángulo PAB */
        double A3 = area(x1, y1, x2, y2, x, y);
        /* verifica si la suma de A1,A2 y A3 es igual a A*/
        return (A == A1 + A2 + A3);
    }

    public static void main(String[] args) {
        /* Verificamos si el punto P(10,15)
        yace dentro del triángulo formado por
        A(0, 0), B(20, 0) and C(10, 30)*/
        if (isInside(0, 0, 20, 0, 10, 30, 10, 15)) {
            System.out.println(&quot;Adentro&quot;);
        } else {
            System.out.println(&quot;Por fuera&quot;);
        }
    }
}
</java>
  <cpp>#include &lt;iostream&gt;
#include &lt;math.h&gt;
using namespace std;


double area(int x1, int y1, int x2, int y2, int x3, int y3) {
    return fabs((x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)) / 2.0);
}

bool isinside(int x1, int y1, int x2, int y2, int x3, int y3, int x, int y) {
    double A = area(x1, y1, x2, y2, x3, y3);
    double A1 = area(x1, y1, x2, y2, x, y);
    double A2 = area(x1, y1, x3, y3, x, y);
    double A3 = area(x2, y2, x3, y3, x, y);
    return (A == A1 + A2 + A3);
}

int main() {
    int x1 = 0, x2 = 5, x3 = 10, y1 = 0, y2 = 5, y3 = 3, puntox = 5, puntoy = 3;
    if (isinside(x1, y1, x2, y2, x3, y3, puntox, puntoy)) {
        cout &lt;&lt; &quot;Esta dentro&quot; &lt;&lt; endl;
    } else cout &lt;&lt; &quot;Esta fuera&quot; &lt;&lt; endl;
}
</cpp>
  <py>from sys import stdin
from sys import stdout

def Area(x1, y1, x2, y2, x3, y3):
    return abs((x1 * (y2-y3) + x2 * (y3-y1) + x3 * (y1-y2)) / 2)

def isInside(x1, y1, x2, y2, x3, y3, x, y):
    A = Area(x1, y1, x2, y2, x3, y3)
    A1 = Area(x1, y1, x2, y2, x, y)
    A2 = Area(x1, y1, x3, y3, x, y)
    A3 = Area(x2, y2, x3, y3, x, y)
    return (A == A1 + A2 + A3)

x1, y1, x2, y2, x3, y3, x, y = 0, 0, 5, 5, 10, 3, 5, 3
if isInside(x1, y1, x2, y2, x3, y3, x, y):
    stdout.write(f&quot;el punto ({x},{y}) esta dentro del triangulo&quot;)
else:
    stdout.write(f&quot;el punto ({x},{y}) no esta dentro del triangulo&quot;)
</py>
  <orden>7</orden>
  <suborden>13</suborden>
  <fecha_creacion>2020-12-04 23:04:29</fecha_creacion>
  <fecha_modificacion>2020-12-06 20:25:46</fecha_modificacion>
</row>
<row>
  <ID>104</ID>
  <supergrupo>Geometría</supergrupo>
  <tema>Línea dividida en ratios</tema>
  <texto>Dadas dos coordenadas (x1, y1) y (x2, y2), y m y n, encuentre las coordenadas que dividen la línea juntando (x1, y1) y (x2,y2) en el ratio m:n.
La fórmula de la sección nos dice las coordenadas del punto que divide una línea segmento dada en dos partes las cuales tendrán la longitud del ratio m:n.
-  ((mx2+nx1/m+n),(my2+ny1/m+n))
</texto>
  <complejidad_tiempo>Mejor caso :    O(1)  Peor caso : O(1)  Promedio: O(1) </complejidad_tiempo>
  <java>// Programa java que encuentra el punto que divide una 
//linea dada, dado un ratio

public class RatioDivideLine {
    static void section(double x1, double x2,
            double y1, double y2,
            double m, double n) {
        //Aplicando la formula de la sección
        double x = ((n * x1) + (m * x2))
                / (m + n);
        double y = ((n * y1) + (m * y2))
                / (m + n);
        // Imprimiendo resultado
        System.out.println(&quot;(&quot; + x + &quot;, &quot; + y + &quot;)&quot;);
    }

    public static void main(String[] args) {
        double x1 = 2, x2 = 4, y1 = 4,
                y2 = 6, m = 2, n = 3;
        section(x1, x2, y1, y2, m, n);
    }
}
</java>
  <cpp>#include&lt;bits/stdc++.h&gt;
#include&lt;cstdlib&gt;
#define x first
#define y second
using namespace std;
typedef pair&lt;double,double&gt; point;
void section(point a,point b,point n){
    double x1 = ((n.y*a.x)+(n.x*a.y))/(n.x+n.y);
    double y1 = ((n.y*b.x)+(n.x*b.y))/(n.x+n.y);
    cout&lt;&lt;&quot;(&quot;&lt;&lt;x1&lt;&lt;&quot; , &quot;&lt;&lt;y1&lt;&lt;&quot;)&quot;&lt;&lt;endl;
}
int main() {
    point a=make_pair(2,0);
    point b=make_pair(5,5);
    point n=make_pair(3,2);
    section(a,b,n);
}
</cpp>
  <py>from sys import stdin
from sys import stdout
rl = stdin.readline
wr = stdout.write


# Usando coordenadas independientes
def section(x1, y1, x2, y2, m, n):
    x = ((n * x1) + (m * x2)) / (m + n)
    y = ((n * y1) + (m * y2)) / (m + n)
    wr(f&#39;({x} , {y})&#39;)


x1, y1, x2, y2, m, n = rl().strip().split()
x1, y1, x2, y2, m, n = int(x1), int(y1), int(x2), int(y2), int(m), int(n)
section(x1, y1, x2, y2, m, n)


# Usando NamedTuple
Puntos = namedtuple(&#39;Puntos&#39;, [&#39;x&#39;, &#39;y&#39;])


def sectionNT(P1, P2, m, n):
    x = ((n * P1.x) + (m * P2.x)) / (m + n)
    y = ((n * P1.y) + (m * P2.y)) / (m + n)
    wr(f&#39;({x} , {y})&#39;)


P1 = Puntos(x1, y1)
P2 = Puntos(x2, y2)
sectionNT(P1, P2, m, n)
</py>
  <orden>7</orden>
  <suborden>14</suborden>
  <fecha_creacion>2020-12-04 23:04:30</fecha_creacion>
  <fecha_modificacion>2020-12-06 20:25:46</fecha_modificacion>
</row>
<row>
  <ID>105</ID>
  <supergrupo>Geometría</supergrupo>
  <tema>Rectángulos en NxM</tema>
  <texto>Tenemos una matriz N*M, imprima el número de rectángulos en él.
- Si la matriz es 1x1, entonces habrá 1 rectángulo.
- Si la matriz es 2x1, entonces habrá  2 +1 = 3 rectángulos
- Si la matriz es 3x1, entonces habrá 3+2+1=6 rectángulo.
Podemos decir que para N*1 ahí habrá N+(N+1)+(N-2)… +1=(N)(N+1)/2 rectángulos.
Si nosotros añadimos una columna más a Nx1, primero tendríamos tantos rectángulos en la segunda columna como en la primera, y luego tendríamos el mismo número de 2xM rectángulos, entonces Nx2=3 (N)(N+1)/2, luego de deducir esto podemos decir que:
- Para N*M nosotros tendríamos (M)(M+1)/2 (N)(N+1)/2 = M(M+1)(N)(N+1)/4
Entonces la fórmula para el total de rectángulos es:
- M(M+1)(N)(N+1)/4
</texto>
  <complejidad_tiempo>Mejor caso :    O(1)  Peor caso : O(1)  Promedio: O(1) </complejidad_tiempo>
  <java>// Codigo Java que cuenta el número
// de rectangulos en una matriz N*M

public class RectanglesInNxM {

    public static long rectCount(int n, int m) {
        return (m * n * (n + 1) * (m + 1)) / 4;
    }

    public static void main(String[] args) {
        int n = 5, m = 4;
        System.out.println(rectCount(n, m));
    }
} 
</java>
  <cpp>null</cpp>
  <py>null</py>
  <orden>7</orden>
  <suborden>15</suborden>
  <fecha_creacion>2020-12-04 23:04:30</fecha_creacion>
  <fecha_modificacion>2020-12-06 20:25:47</fecha_modificacion>
</row>
<row>
  <ID>106</ID>
  <supergrupo>Geometría</supergrupo>
  <tema>Cuadrados 2x2 en un triángulo</tema>
  <texto>Cuál es el máximo número de cuadrados de tamaño 2x2 unidades que pueden caber en un triángulo isósceles de ángulos correctos dada la base en unidades.
Un lado del cuadrado debe ser paralelo a la base del triángulo.
Desde que el triángulo es isósceles, la base dada será también igual a la altura. Ahora en la parte diagonal, podríamos siempre necesitar un largo extra de dos unidades en la altura y la base del triángulo para acomodar un triángulo. En la longitud restante de la base, podemos construir largo/2 cuadrados. Desde que cada cuadrado es de dos unidades, lo mismo puede hacerse en el caso de la altura, ahí no hay necesidad de calcular  eso de nuevo.
Entonces, para cada nivel de la longitud dada, podemos construir “(largo-2)/2” cuadrados. Esto nos da una base de “(largo-2)” encima de él. Continuando con el proceso de obtener el número de cuadrados para toda la disponible “largo/2” altura, podemos calcular los cuadrados.
Para una forma más eficiente, podemos usar la fórmula de la suma de AP n*(n+1)/2, donde n= largo-2.
</texto>
  <complejidad_tiempo>Mejor caso :    O(1)  Peor caso : O(1)  Promedio: O(1) </complejidad_tiempo>
  <java>// Programa Java que cuenta el número de cuadros2 
// 2x2 que cabe en un triángulo isoceles

public class SquaresInTriangle2x2 {

    public static int numberOfSquares(int base) {
        // Removiendo la parte extra  
        // que podamos necesitar
        base = (base - 2);
        // Desde cada cuadrado que tenga
        // base de tamaño 2 
        base = base / 2;
        return base * (base + 1) / 2;
    }

    public static void main(String args[]) {
        int base = 8;
        System.out.println(numberOfSquares(base));
    }
} 

</java>
  <cpp>null</cpp>
  <py>null</py>
  <orden>7</orden>
  <suborden>16</suborden>
  <fecha_creacion>2020-12-04 23:04:30</fecha_creacion>
  <fecha_modificacion>2020-12-06 20:25:47</fecha_modificacion>
</row>
<row>
  <ID>107</ID>
  <supergrupo>Geometría</supergrupo>
  <tema>Suma de Manhattan</tema>
  <texto>Dados n coordenadas enteras, encuentre la suma de la distancia de Manhattan entre todos los pares de coordenadas.
La distancia de Manhattan entre dos puntos (x1,y1) y (x2,y2) es:
- |x1 – x2| + |y1 – y2|
La idea es recorrer dos ciclos anidados, por ejemplo cada punto, encontrar la distancia de todos los otros puntos con este.
</texto>
  <complejidad_tiempo> O(nlog(n))  Peor caso : O(nlog(n))  Promedio: O(nlog(n)) </complejidad_tiempo>
  <java>/*Programa Java para encontrar la suma de
las distancias de Manhattan entre todos 
los pares de puntos dados */

public class SumOfManhattan {

    /*Retorna la suma de la distancia entre todos
    los pares de puntos*/
    static int distancesum(int x[], int y[], int n) {
        int sum = 0;
        /* Por cada punto, encuentra la distancia 
        al resto de puntos */
        for (int i = 0; i &lt; n; i++) {
            for (int j = i + 1; j &lt; n; j++) {
                sum += (Math.abs(x[i] - x[j])
                        + Math.abs(y[i] - y[j]));
            }
        }
        return sum;
    }

    public static void main(String[] args) {
        int x[] = {-1, 1, 3, 2};
        int y[] = {5, 6, 5, 3};
        int n = x.length;
        System.out.println(distancesum(x, y, n));
    }
} 
</java>
  <cpp>null</cpp>
  <py>null</py>
  <orden>7</orden>
  <suborden>17</suborden>
  <fecha_creacion>2020-12-04 23:04:31</fecha_creacion>
  <fecha_modificacion>2020-12-06 20:25:48</fecha_modificacion>
</row>
<row>
  <ID>108</ID>
  <supergrupo>Geometría</supergrupo>
  <tema>Tres puntos colineales</tema>
  <texto>Dados tres puntos, verificar si estos puntos yacen en recta (colineales) o no.
Ejemplo: (1, 1), (1, 4), (1, 5)
Los tres puntos yacen en una línea recta.
Tres puntos yacen en una línea recta si el área formada por un triángulo de estos tres puntos es cero.
</texto>
  <complejidad_tiempo>Mejor caso :    O(1)  Peor caso : O(1)  Promedio: O(1) </complejidad_tiempo>
  <java>/*Programa en java para verificar si
tres puntos son colineares
o no usando el area del triángulo*/
public class ThreePointsCollinear {
    //Función que verifica si un punto es colineal o no
    static void collinear(int x1, int y1, int x2,
            int y2, int x3, int y3) {
        /*Calcular el area del triángulo
        Debemos omitir multiplicaciones con 0.5
        para evitar calculos flotantes*/
        int a = x1 * (y2 - y3)
                + x2 * (y3 - y1)
                + x3 * (y1 - y2);
        if (a == 0) {
            System.out.println(&quot;Yes&quot;);
        } else {
            System.out.println(&quot;No&quot;);
        }
    }

    public static void main(String args[]) {
        int x1 = 1, x2 = 1, x3 = 1,
                y1 = 1, y2 = 4, y3 = 5;
        collinear(x1, y1, x2, y2, x3, y3);

    }
} 
</java>
  <cpp>null</cpp>
  <py>null</py>
  <orden>7</orden>
  <suborden>18</suborden>
  <fecha_creacion>2020-12-04 23:04:31</fecha_creacion>
  <fecha_modificacion>2020-12-06 20:25:49</fecha_modificacion>
</row>
<row>
  <ID>109</ID>
  <supergrupo>Geometría</supergrupo>
  <tema>Ángulos de un triángulo</tema>
  <texto>Dadas las coordenadas de tres vértices de un triángulo en un plano 2D, encuentre sus tres ángulos.
- c^2 = a^2 + b^2 - 2(a)(b)(cos beta)
Luego del despeje:
- beta = acos( ( a^2 + b^2 - c^2 ) / (2ab) )
En trigonometría la ley del coseno cuenta que los largos de los lados de un triángulo con el coseno de uno de sus ángulos luego de un despeje nos da el ángulo.
Primero calculamos el largo de todos los lados, luego aplicamos la fórmula de arriba para obtener  todos los ángulos en radianes, luego convertimos de radianes a grados.
</texto>
  <complejidad_tiempo>null</complejidad_tiempo>
  <java>/* Codigo JAVA para encontrar todos los angulos
de un triángulos dadas las coordenadas
de los tres vertices*/
import java.awt.Point;
import static java.lang.Math.PI;
import static java.lang.Math.sqrt;
import static java.lang.Math.acos;

public class TriangleAngles {   
    // Regresa el cuadrado de la distancia b/w de dos puntos
    static int lengthSquare(Point p1, Point p2) {
        int xDiff = p1.x - p2.x;
        int yDiff = p1.y - p2.y;
        return xDiff * xDiff + yDiff * yDiff;
    }

    static void printAngle(Point A, Point B,
            Point C) {
        //Cuadrado de los tamaños de a2, b2, c2
        int a2 = lengthSquare(B, C);
        int b2 = lengthSquare(A, C);
        int c2 = lengthSquare(A, B);
        // Longitus de los lados de a, b, c 
        float a = (float) sqrt(a2);
        float b = (float) sqrt(b2);
        float c = (float) sqrt(c2);
        // De la ley del coseno
        float alfa = (float) acos((b2 + c2 - a2) / (2 * b * c));
        float beta = (float) acos((a2 + c2 - b2) / (2 * a * c));
        float gamma = (float) acos((a2 + b2 - c2) / (2 * a * b));
        //Conversión a grados
        alfa = (float) (alfa * 180 / PI);
        beta = (float) (beta * 180 / PI);
        gamma = (float) (gamma * 180 / PI);
        //Imprimiendo los angulos
        // printing all the angles 
        System.out.println(&quot;alfa : &quot; + alfa);
        System.out.println(&quot;beta : &quot; + beta);
        System.out.println(&quot;gamma : &quot; + gamma);
    }

    public static void main(String[] args) {
        Point A = new Point(0, 0);
        Point B = new Point(0, 1);
        Point C = new Point(1, 0);
        printAngle(A, B, C);
    }
} 
</java>
  <cpp>null</cpp>
  <py>null</py>
  <orden>7</orden>
  <suborden>19</suborden>
  <fecha_creacion>2020-12-04 23:04:31</fecha_creacion>
  <fecha_modificacion>2020-12-06 20:25:49</fecha_modificacion>
</row>
<row>
  <ID>110</ID>
  <supergrupo>BitWise</supergrupo>
  <tema>BitWise básico </tema>
  <texto>Operaciones a nivel de bits.
n &amp; 1  -&gt; Verifica si n es impar o no
n &amp; (1&lt;&lt;k) -&gt; Verifica si el k-esimo bit esta encendido o no
n | (1&lt;&lt;k) -&gt; Enciende el k-esimo bit
n &amp; ~(1&lt;&lt;k) -&gt; Apaga el k-esimo bit
n ^ (1&lt;&lt;k) -&gt; Invierte el k-esimo bit
~n  -&gt; Invierte todos los bits
n &amp; -n  -&gt; Devuelve el bit encendido mas a la derecha
~n &amp; (n+1) -&gt; Devuelve el bit apagado mas a la derecha
n | (n+1) -&gt; Enciende el bit apagado mas a la derecha
n &amp; (n-1) -&gt; Apaga el bit encendido mas a la derecha
Otras operaciones a nivel de bits.
1) Borrar todos los bits desde el bit menos significativo (LSB) hasta el bit i
• mask = ~((1 &lt;&lt; i+1 ) - 1);
• x &amp;= mask;
Para borrar todos los bits de LSB a i-ésimo bit, tenemos que AND X con la máscara que tiene LSB a i-ésimo bit 0. Para obtener dicha máscara, primero se desplaza a la izquierda 1 veces. Ahora, si sumamos 1 a partir de eso, todos los bits de 0 a i-1 se convierten en 1 y los bits restantes se convierten en 0. Ahora simplemente podemos tomar el complemento de máscara para obtener todos los primeros bits de i en 0 y permanecer en 1.
Ejemplo:
• x = 29 (00011101) y queremos borrar LSB al 3er bit, total 4 bits
• mask -&gt; 1 &lt;&lt; 4 -&gt; 16(00010000)
• mask -&gt; 16 – 1 -&gt; 15(00001111)
• mask -&gt; ~mask -&gt; 11110000
• x &amp; mask -&gt; 16 (00010000)
2) Borrar todos los bits del bit más significativo (MSB) al bit i-ésimo 
• mask = (1 &lt;&lt; i) - 1;
• x &amp;= mask;
Para borrar todos los bits de MSB a i-ésimo bit, tenemos que AND x con la máscara que tiene MSB a i-ésimo bit 0. Para obtener dicha máscara, primero se desplaza a la izquierda 1 veces. Ahora, si menos 1 de eso, todos los bits de 0 a i-1 se convierten en 1 y los bits restantes se convierten en 0.
Ejemplo:
• x = 215 (11010111) y queremos borrar MSB al 4to bit, total 4 bits
• mask -&gt; 1 &lt;&lt; 4 -&gt; 16(00010000)
• mask -&gt; 16 – 1 -&gt; 15(00001111)
• x &amp; mask -&gt; 7(00000111)
3) Dividir por 2
• x &gt;&gt;= 1;
Cuando hacemos un desplazamiento aritmético a la derecha, cada bit se desplaza a la derecha y la posición en blanco se sustituye con un bit de signo de número, 0 en caso de número positivo y 1 en caso de número negativo. Como cada bit es una potencia de 2, con cada cambio estamos reduciendo el valor de cada bit por un factor de 2 que es equivalente a la división de x por 2.
Ejemplo:
• x = 18(00010010)
• x &gt;&gt; 1 = 9 (00001001)
4) Multiplicar por 2
• x &lt;&lt;= 1;
Cuando hacemos desplazamiento aritmético a la izquierda, cada bit se desplaza a la izquierda y la posición en blanco se sustituye por 0. Como cada bit es una potencia de 2, con cada cambio aumentamos el valor de cada bit por un factor de 2 que es equivalente a la multiplicación de x por 2.
Ejemplo:
• x = 18(00010010)
• x &lt;&lt; 1 = 36 (00100100)
5) Mayusculas a minusculas en el alfabeto ingles
• ch |= &#39; &#39;;
La representación en bits de las letras en inglés en mayúsculas y minúsculas es:
A -&gt; 01000001          a -&gt; 01100001
B -&gt; 01000010          b -&gt; 01100010
C -&gt; 01000011          c -&gt; 01100011
  .                               .
  .                               .
Z -&gt; 01011010          z -&gt; 01111010
Como podemos ver si establecemos el quinto bit de caracteres en mayúsculas, se convertirá en caracteres en minúsculas. Tenemos que preparar una máscara que tenga el quinto bit 1 y otro 0 (00100000). Esta máscara es una representación en bits del carácter de espacio (‘‘). El carácter &quot;ch&quot; luego OR con la máscara.
Ejemplo:
• ch = ‘A’ (01000001)
• mask = ‘ ‘ (00100000)
• ch | mask = ‘a’ (01100001)
6) Minusculas a mayusculas en el alfabeto ingles
• ch &amp;= &#39;_’ ;
La representación en bits de las letras en inglés en mayúsculas y minúsculas es:
A -&gt; 01000001                a -&gt; 01100001
B -&gt; 01000010                b -&gt; 01100010
C -&gt; 01000011                c -&gt; 01100011
.                               .
.                               .
Z -&gt; 01011010                z -&gt; 01111010
Como podemos ver si borramos el quinto bit de caracteres en minúsculas, se convertirá en caracteres en mayúsculas. Tenemos que preparar una máscara que tenga el quinto bit 0 y otro 1 (10111111). Esta máscara es una representación en bits del carácter de subrayado (‘_‘). El carácter &quot;ch&quot; luego AND con la máscara.
Ejemplo:
ch = ‘a’ (01100001)
mask = ‘_ ‘ (11011111)
ch &amp; mask = ‘A’ (01000001)
7) Cuenta los bits establecidos en un entero 
int countSetBits(int x) {
    int count = 0;
    while (x) {
        x &amp;= (x - 1);
        count++;
    }
    return count;
}
Se realiza esta operacion basado en el algoritmo de Brian Kernighan.
8) Encuentra la log base 2 de un entero de 32 bits
int log2(int x) {
    int res = 0;
    while (x &gt;&gt;= 1)
        res++;
    return res;
}
Desplazamos a la derecha x repetidamente hasta que se convierte en 0, mientras tanto, contamos con la operación de desplazamiento. Este valor de conteo es el log2 (x).
9) Comprobando si un entero de 32 bits es una potencia de 2
int isPowerof2(int x) {
    return (x &amp;&amp; !(x &amp; x - 1));
}
Toda la potencia de 2 tiene solo un bit establecido, p. 16 (00010000). Si menos 1 de esto, todos los bits de LSB para establecer el bit se alternan, es decir, 16-1 = 15 (00001111). Ahora si realizamos AND x con (x-1) y el resultado es 0, entonces podemos decir que x es una potencia de 2, de lo contrario no. Tenemos que tener mucho cuidado cuando x = 0.
Ejemplo:
• x = 16(000100000)
• x – 1 = 15(00001111)
• x &amp; (x-1) = 0
• Entonces 16 es potencia de 2


10) Cómo establecer un bit en el número &quot;num&quot;:
Si queremos establecer un bit en la enésima posición en el número &quot;num&quot;, se puede hacer usando el operador &quot;OR&quot; (|).
• Primero dejamos el desplazamiento &quot;1&quot; a la posición n a través de (1 &lt;&lt; n)
• Luego, use el operador &quot;OR&quot; para establecer el bit en esa posición. El operador &quot;OR&quot; se usa porque establecerá el bit incluso si el bit no se ha establecido previamente en la representación binaria del número &quot;num&quot;.
C++
#include&lt;iostream&gt; 
using namespace std;
//num es el numero y pos es la posición 
//del bit que queremos activar

void set(int &amp; num, int pos) {
    //Primer paso es correr &#39;1&#39;,
    //Segundo paso es realizar OR
    num |= (1 &lt;&lt; pos);
}

int main() {
    int num = 4, pos = 1;
    set(num, pos);
    cout &lt;&lt; (int) (num) &lt;&lt; endl;
    return 0;
}
Salida:
6
11)  Cómo desestablecer un bit en el número &quot;num&quot;:
Supongamos que queremos desarmar un poco en la enésima posición en el número &quot;num&quot;, entonces tenemos que hacer esto con la ayuda del operador &quot;AND&quot; (&amp;).
• Primero dejamos el desplazamiento ‘1’ a la posición n mediante (1 &lt;&lt; n) que usamos el operador NOT bit a bit ‘~’ para desactivar este desplazamiento sh 1 ’.
• Ahora, después de despejar esta izquierda desplazada ‘1’, es decir, llegar a ‘0’, ‘AND &#39;(&amp;) con el número‘ num ’que desarmará el bit en la enésima posición.
C++
#include &lt;iostream&gt; 
using namespace std;

void unset(int &amp;num, int pos) {
    num &amp;= (~(1 &lt;&lt; pos));
}

int main() {
    int num = 7;
    int pos = 1;
    unset(num, pos);
    cout &lt;&lt; num &lt;&lt; endl;
    return 0;
}
Salida:
5
12)  Alternar un bit en la enésima posición:
Alternar significa activar el bit &#39;on&#39; (1) si estaba &#39;off&#39; (0) y desactivar &#39;(0) si estaba&#39; on &#39;(1) anteriormente. Usaremos el operador&#39; XOR &#39;aquí que es esto &#39;^&#39; La razón detrás del operador &quot;XOR&quot; se debe a sus propiedades.
• Propiedades de operador XOR.
• 1^1 = 0
• 0^0 = 0
• 1^0 = 1
• 0^1 = 1
• Si dos bits son diferentes, el operador &quot;XOR&quot; devuelve un bit establecido (1) de lo contrario, devuelve un bit no establecido (0).

C++
#include &lt;iostream&gt; 
using namespace std;

void toggle(int &amp;num, int pos) {
    num ^= (1 &lt;&lt; pos);
}

int main() {
    int num = 4;
    int pos = 1;
    toggle(num, pos);
    cout &lt;&lt; num &lt;&lt; endl;
    return 0;
}
Salida:
6
13) Comprobando si el bit en la enésima posición está activado o desactivado:
Es bastante fácil de hacer con el operador &quot;AND&quot;.
• Desplazar a la izquierda &#39;1&#39; a la posición dada y luego &#39;Y&#39; (&#39;y&#39;).#include &lt;iostream&gt; 
• using namespace std; 
C++
bool at_position(int num, int pos) {
    bool bit = num &amp; (1 &lt;&lt; pos);
    return bit;
}

int main() {
    int num = 5;
    int pos = 0;
    bool bit = at_position(num, pos);
    cout &lt;&lt; bit &lt;&lt; endl;
    return 0;
}
Salida:
1
Observe que primero hemos dejado &quot;1&quot; desplazado y luego hemos usado el operador &quot;Y&quot; para obtener el bit en esa posición. Entonces, si hay &#39;1&#39; en la posición &#39;pos&#39; en &#39;num&#39;, luego de &#39;AND&#39; nuestra variable &#39;bit&#39; almacenará &#39;1&#39; más si hay &#39;0&#39; en la posición &#39;pos&#39; en el número &#39;num&#39; que después de &#39;Y&#39; nuestro bit variable almacenará &#39;0&#39;.
14) Invertir cada bit de un numero a un numero con complement a 1
Si queremos invertir cada bit de un número, es decir, cambiar el bit &quot;0&quot; a &quot;1&quot; y el bit &quot;1&quot; a &quot;0&quot;. Podemos hacerlo con la ayuda del operador &quot;~&quot;. Por ejemplo: si número es num = 00101100 (representación binaria), entonces ‘~ num’ será ‘11010011’.
Este es también el &quot;complemento de número 1&quot;.
C++
#include &lt;iostream&gt; 
using namespace std;

int main() {
    int num = 4;
    // Invertir cada bit del numero
    cout &lt;&lt; (~num);
    return 0;
}
Salida:
 -5
15) Complemento a dos del número
Entonces, formalmente podemos tener el complemento de 2 al encontrar el complemento de 1 y agregar 1 al resultado, es decir (~ num + 1) o qué más podemos hacer es usar el operador ‘-‘.

C++
#include &lt;iostream&gt; 
using namespace std;

int main() {
    int num = 4;
    int twos_complement = -num;
    cout &lt;&lt; &quot;complemento a 2 &quot; &lt;&lt; twos_complement &lt;&lt; endl;
    cout &lt;&lt; &quot;Tambien complemento a 2  &quot; &lt;&lt; (~num + 1) &lt;&lt; endl;
    return 0;
}
Salida:
Complemento a 2 -4
Tambien complemento a 2 -4
16) Eliminando el bit activo más bajo:
En muchas situaciones, queremos quitar el bit establecido más bajo, por ejemplo, en la estructura de datos de árbol indexado binario, contando el número de bit establecido en un número.
Hacemos algo como esto:
X = X &amp; (X-1)
Veamos esto tomando un ejemplo, sea X = 1100. 
(X-1) invierte todos los bits hasta que encuentre el conjunto más bajo &#39;1&#39; y también invierte ese conjunto más bajo &#39;1&#39;.
X-1 se convierte en 1011. Después de realizar &#39;AND&#39; X con X-1 obtenemos el bit de ajuste más bajo despojado.
C++
#include &lt;iostream&gt; 
using namespace std;

void strip_last_set_bit(int &amp;num) {
    num = num &amp; (num - 1);
}

int main() {
    int num = 7;
    strip_last_set_bit(num);
    cout &lt;&lt; num &lt;&lt; endl;
    return 0;
}
Salida:
6
17) Obtener el bit activo mas bajo de un numero:
Esto se hace usando la expresión &#39;X &amp; (- X)&#39;. Veamos esto tomando un ejemplo: Sea X = 00101100. Entonces ~ X (complemento de 1) será &#39;11010011&#39; y el complemento de 2 será (~ X + 1 o -X), es decir, &#39;11010100&#39;. Entonces, si &#39;AND&#39; el número original &#39;X&#39; con su complemento de dos que es &#39;-X&#39;, obtenemos el bit de ajuste más bajo.
00101100
&amp; 11010100
-----------
00000100

C++
#include &lt;iostream&gt; 
using namespace std;

int lowest_set_bit(int num) {
    int ret = num &amp; (-num);
    return ret;
}

int main() {
    int num = 10;
    int ans = lowest_set_bit(num);
    cout &lt;&lt; ans &lt;&lt; endl;
    return 0;
}
Salida:
2

</texto>
  <complejidad_tiempo>null</complejidad_tiempo>
  <java>null</java>
  <cpp>null</cpp>
  <py>null</py>
  <orden>4</orden>
  <suborden>0</suborden>
  <fecha_creacion>2020-12-04 23:04:32</fecha_creacion>
  <fecha_modificacion>2020-12-06 20:11:13</fecha_modificacion>
</row>
<row>
  <ID>111</ID>
  <supergrupo>BitWise</supergrupo>
  <tema>Suma uno</tema>
  <texto>Sume uno a un número dado, el uso de los operadores como ‘+’, ‘-‘,’*’,’/’,’++’,’—‘…. Entre otros no está permitido.
La respuesta se consigue con algo de magia de bits.
Para agregar 1 a un número x(como 0011000111), voltee todos los bits luego del cero de más a la derecha (bit 0) (obtenemos 0011000000) finalmente, voltee el cero de más a la derecha también (obtenemos 0011001000) para obtener la respuesta.
</texto>
  <complejidad_tiempo>Mejor caso :    O(1)  Peor caso : O(1)  Promedio: O(1) </complejidad_tiempo>
  <java>// Programa Java en donde se agrega uno a
// un número dado

public class AddOne {

    static int addOne(int x) {
        return -(~x);
    }

    public static void main(String[] args) {
        System.out.println(addOne(13));
    }
}
</java>
  <cpp>#include &lt;iostream&gt;
using namespace std;

string decToBin(int n) {
    if (n == 0)
        return &quot;0&quot;;
    string bin = &quot;&quot;;
    int ayuda = n;
    n = abs(n);
    while (n &gt; 0) {
        bin = ((n &amp; 1) == 0 ? &#39;0&#39; : &#39;1&#39;) + bin;
        n &gt;&gt;= 1;
    }

    return (ayuda &lt; 0 ? bin = &#39;-&#39; + bin : bin);
}

int addOne(int x) {
    return (-(~x));
}

int main() {
    int a = 13;
    cout &lt;&lt; a &lt;&lt; &quot; --&gt; &quot; &lt;&lt; decToBin(a) &lt;&lt; endl;
    a = addOne(a);
    cout &lt;&lt; a &lt;&lt; &quot; --&gt; &quot; &lt;&lt; decToBin(a) &lt;&lt; endl;
    return 0;
}
</cpp>
  <py>from sys import stdin, stdout
rl = stdin.readline
wr = stdout.write

def addOne(n):
    wr(f&#39;{n} -&gt; {bin(n)[2:]}\n&#39;)
    n = (-(~n))
    wr(f&#39;{n} -&gt; {bin(n)[2:]}\n&#39;)

n = int(rl())
addOne(n)
</py>
  <orden>4</orden>
  <suborden>1</suborden>
  <fecha_creacion>2020-12-04 23:04:32</fecha_creacion>
  <fecha_modificacion>2020-12-06 20:11:13</fecha_modificacion>
</row>
<row>
  <ID>112</ID>
  <supergrupo>BitWise</supergrupo>
  <tema>Comparación de signos</tema>
  <texto>Dado dos enteros con signo, retorne true si los signos de los enteros dados son diferentes, de otra forma retorne falso, por ejemplo la función debe retornar true en -1 y +100, y debe retornar falso para -200 y -100. La función no debe usar ningún operador aritmético.
Dejaremos los enteros dados ser x y y, el bit de signo es 1 en números negativos, y 0 en números positivos, El XOR de x y y puede tener el bit de signo en 1 si ellos tiene signos opuestos, en otras palabras, XOR de x y y será un número negativo si x y y tienen signos opuestos.
</texto>
  <complejidad_tiempo>Mejor caso :    O(1)  Peor caso : O(1)  Promedio: O(1) </complejidad_tiempo>
  <java>//Programa Java para detectar si dos enteros
//tienen signos opuestos

public class OppositeSigns {

    static boolean oppositeSigns(int x, int y) {
        return ((x ^ y) &lt; 0);
    }

    public static void main(String[] args) {
        int x = 100, y = -100;
        if (oppositeSigns(x, y) == true) {
            System.out.println(&quot;Signos opuestos&quot;);
        } else {
            System.out.println(&quot;Signos no opuestos&quot;);
        }
        x = 100;
        y = 100;
        if (oppositeSigns(x, y) == true) {
            System.out.println(&quot;Signos son opuestos&quot;);
        } else {
            System.out.println(&quot;Signos no son opuestos&quot;);
        }
    }
}
</java>
  <cpp>#include &lt;iostream&gt;

using namespace std;

bool opposite(int a, int b) {
    return (a ^ b) &lt; 0;
}

int main() {
    int a = 123;
    int b = -123;
    if (opposite(a, b)) {
        cout &lt;&lt; &quot;Distintos signos&quot; &lt;&lt; endl;
    } else {
        cout &lt;&lt; &quot;Iguales signos&quot; &lt;&lt; endl;
    }
    return 0;
}
</cpp>
  <py>from sys import stdin, stdout
rl = stdin.readline
wr = stdout.write

def opposite(n, m):
    res = (n ^ m) &lt; 0
    if res:
        wr(f&#39;Distintos\n&#39;)
    else:
        wr(f&#39;Iguales\n&#39;)

n = 30
m = -100
opposite(n, m)
</py>
  <orden>4</orden>
  <suborden>2</suborden>
  <fecha_creacion>2020-12-04 23:04:32</fecha_creacion>
  <fecha_modificacion>2020-12-06 20:11:14</fecha_modificacion>
</row>
<row>
  <ID>113</ID>
  <supergrupo>BitWise</supergrupo>
  <tema>Multiplicación básica</tema>
  <texto>Podemos multiplicar un número por 7 usando operadores BitWise, primero hacemos corrimiento izquierdo del número de 3 bits (Se obtendrá 8n) luego se resta la forma original del número corrido y se retorna la diferencia (8n-n).
Complejidad de tiempo: O(1).
Funciona solo para enteros positivos.
El mismo concepto puede ser usado para  multiplicación rápida por 9 u otros números cambiando la formula bitwise.
Por ejemplo:
• (n &lt;&lt; 1)  = x2
• ((n &lt;&lt; 1) + n) = x3
• (n &lt;&lt; 2) = x4
• ((n &lt;&lt; 2) + n) = x5
• ((n &lt;&lt; 3) - (n &lt;&lt; 1)) = x6
• ((n &lt;&lt; 3) - n) = x7
• (n &lt;&lt; 3) = x8
• ((n &lt;&lt; 3)+n) = x9
• (n &lt;&lt; 3)+(n&lt;&lt;1) = x10
</texto>
  <complejidad_tiempo>Mejor caso :    O(1)  Peor caso : O(1)  Promedio: O(1) </complejidad_tiempo>
  <java>public class Multiply_2_to_10 {

    public static void main(String[] args) {
        int a = 18;
        System.out.println(multiplyByTwo(a));
        System.out.println(multiplyByThree(a));
        System.out.println(multiplyByFour(a));
        System.out.println(multiplyByFive(a));
        System.out.println(multiplyBySix(a));
        System.out.println(multiplyBySeven(a));
        System.out.println(multiplyByEight(a));
        System.out.println(multiplyByNine(a));
        System.out.println(multiplyByTen(a));
    }

    static int multiplyByTwo(int n) {
        return (n &lt;&lt; 1);
    }

    static int multiplyByThree(int n) {
        return ((n &lt;&lt; 1) + n);
    }

    static int multiplyByFour(int n) {
        return (n &lt;&lt; 2);
    }

    static int multiplyByFive(int n) {
        return ((n &lt;&lt; 2) + n);
    }

    static int multiplyBySix(int n) {
        return ((n &lt;&lt; 3) - (n &lt;&lt; 1));
    }

    static int multiplyBySeven(int n) {
        return ((n &lt;&lt; 3) - n);
    }

    static int multiplyByEight(int n) {
        return (n &lt;&lt; 3);
    }

    static int multiplyByNine(int n) {
        return ((n &lt;&lt; 3) + n);
    }

    static int multiplyByTen(int n) {
        return (n &lt;&lt; 3) + (n &lt;&lt; 1);
    }
}
</java>
  <cpp>#include &lt;iostream&gt;
//-------------//
#define FAST ios_base::sync_with_stdio(false);cout.tie(NULL);

using namespace std;

int multiplyByTwo(int n) {
    return (n &lt;&lt; 1);
}

int multiplyByThree(int n) {
    return ((n &lt;&lt; 1) + n);
}

int multiplyByFour(int n) {
    return (n &lt;&lt; 2);
}

int multiplyByFive(int n) {
    return ((n &lt;&lt; 2) + n);
}

int multiplyBySix(int n) {
    return ((n &lt;&lt; 3) - (n &lt;&lt; 1));
}

int multiplyBySeven(int n) {
    return ((n &lt;&lt; 3) - n);
}

int multiplyByEight(int n) {
    return (n &lt;&lt; 3);
}

int multiplyByNine(int n) {
    return ((n &lt;&lt; 3) + n);
}

int multiplyByTen(int n) {
    return (n &lt;&lt; 3) + (n &lt;&lt; 1);
}

int main() {
    FAST;
    int a = 9;
    cout &lt;&lt; multiplyByTwo(a) &lt;&lt; endl;
    cout &lt;&lt; multiplyByThree(a) &lt;&lt; endl;
    cout &lt;&lt; multiplyByFour(a) &lt;&lt; endl;
    cout &lt;&lt; multiplyByFive(a) &lt;&lt; endl;
    cout &lt;&lt; multiplyBySix(a) &lt;&lt; endl;
    cout &lt;&lt; multiplyBySeven(a) &lt;&lt; endl;
    cout &lt;&lt; multiplyByEight(a) &lt;&lt; endl;
    cout &lt;&lt; multiplyByNine(a) &lt;&lt; endl;
    cout &lt;&lt; multiplyByTen(a) &lt;&lt; endl;
    return 0;
}
</cpp>
  <py>from sys import stdin, stdout
rl = stdin.readline
wr = stdout.write

def multiplyZero(n):
    res = (n &lt;&lt; 0) - n
    wr(f&#39;{n} x 0 = {res}\n&#39;)

def multiplyOne(n):
    res = (n &lt;&lt; 1) - n
    wr(f&#39;{n} x 1 = {res}\n&#39;)

def multiplyTwo(n):
    res = (n &lt;&lt; 1)
    wr(f&#39;{n} x 2 = {res}\n&#39;)

def multiplyThree(n):
    res = (n &lt;&lt; 1)+n
    wr(f&#39;{n} x 3 = {res}\n&#39;)

def multiplyFour(n):
    res = (n &lt;&lt; 2)
    wr(f&#39;{n} x 4 = {res}\n&#39;)

def multiplyFive(n):
    res = (n &lt;&lt; 2)+n
    wr(f&#39;{n} x 5 = {res}\n&#39;)

def multiplySix(n):
    res = (n &lt;&lt; 3)-(n &lt;&lt; 1)
    wr(f&#39;{n} x 6 = {res}\n&#39;)

def multiplySeven(n):
    res = (n &lt;&lt; 3)-n
    wr(f&#39;{n} x 7 = {res}\n&#39;)

def multiplyEight(n):
    res = (n &lt;&lt; 3)
    wr(f&#39;{n} x 8 = {res}\n&#39;)

def multiplyNine(n):
    res = (n &lt;&lt; 3)+n
    wr(f&#39;{n} x 9 = {res}\n&#39;)

def multiplyTen(n):
    res = (n &lt;&lt; 3)+(n &lt;&lt; 1)
    wr(f&#39;{n} x 10 = {res}\n&#39;)

n = int(rl())
multiplyZero(n)
multiplyOne(n)
multiplyTwo(n)
multiplyThree(n)
multiplyFour(n)
multiplyFive(n)
multiplySix(n)
multiplySeven(n)
multiplyEight(n)
multiplyNine(n)
multiplyTen(n)
</py>
  <orden>4</orden>
  <suborden>3</suborden>
  <fecha_creacion>2020-12-04 23:04:33</fecha_creacion>
  <fecha_modificacion>2020-12-06 20:11:15</fecha_modificacion>
</row>
<row>
  <ID>114</ID>
  <supergrupo>BitWise</supergrupo>
  <tema>Cuadrado de N sin usar pow</tema>
  <texto>Dado un entero n, calcular el cuadrado de un número sin usar *,/ y pow().
Podemos hacerlo en tiempo O(Logn) usando operadores de BitWise, la idea está basada en el siguiente hecho:
- square(n) = 0 if n == 0
  Si n es par 
-   square(n) = 4*square(n/2) 
  Si n es impar
-    square(n) = 4*square(floor(n/2)) + 4*floor(n/2) + 1 
Por ejemplo:
- square(6) = 4*square(3)
- square(3) = 4*(square(1)) + 4*1 + 1 = 9
- square(7) = 4*square(3) + 4*3 + 1 = 4*9 + 4*3 + 1 = 49
Si n es par, puede ser escrito como:
-   n = 2*x 
-   n^2 = (2*x)2 = 4*x2
Si n es impar, puede ser escrito como: 
- n = 2*x + 1
-  n^2 = (2*x + 1)2 = 4*x2 + 4*x + 1
floor(n/2)  puede ser calculado usando el operados de BitWise corrimiento derecho.
</texto>
  <complejidad_tiempo>Mejor caso :    O(1)  Peor caso : O(1)  Promedio: O(1) </complejidad_tiempo>
  <java>// Programa en java para calcular el cuadrado
// Sin usar * ni Pow()

public class NSquareNoPow {

    static int square(int n) {
        // Caso base
        if (n == 0) {
            return 0;
        }
        if (n &lt; 0) {
            n = -n;
        }
        // Obtener floor(n/2) usando
        // right shift 
        int x = n &gt;&gt; 1;
        // si n es par
        ;
        if (n % 2 != 0) {
            return ((square(x) &lt;&lt; 2)
                    + (x &lt;&lt; 2) + 1);
        } else// si n es impar
        {
            return (square(x) &lt;&lt; 2);
        }
    }

    public static void main(String args[]) {
        for (int n = 1; n &lt;= 5; n++) {
            System.out.println(&quot;n = &quot; + n
                    + &quot; n^2 = &quot;
                    + square(n));
        }
    }
}
</java>
  <cpp>#include&lt;bits/stdc++.h&gt;
#include&lt;cstdlib&gt;
#define c(x) cout&lt;&lt;x&lt;&lt;endl;
#define cn(x) cout&lt;&lt;x;
#define l(c) cin&gt;&gt;t;
using namespace std;
int square(int n){
    if(n==0){
        return 0;
    }
    if(n&lt;0){
        n=-n;
    }
    int x=n&gt;&gt;1;
    if((n&amp;1)&gt;0){
        return ((square(x)&lt;&lt;2)+(x&lt;&lt;2)+1);
    }else{
        return (square(x)&lt;&lt;2);
    }
}
int main() {
    for(int i=0;i&lt;10;i++){
        c(square(i));
    }
}

</cpp>
  <py>from sys import stdin
from sys import stdout
rl = stdin.readline
wr = stdout.write

def square(n):
    if n == 0:
        return 0
    if n &lt; 0:
        n = -n
    x = n &gt;&gt; 1
    if n &amp; 1:
        return (square(x) &lt;&lt; 2) + (x &lt;&lt; 2) + 1
    else:
        return (square(x) &lt;&lt; 2)

for i in range(11):
    wr(f&#39;{i} -&gt; {square(i)}\n&#39;)
</py>
  <orden>4</orden>
  <suborden>4</suborden>
  <fecha_creacion>2020-12-04 23:04:33</fecha_creacion>
  <fecha_modificacion>2020-12-06 20:11:15</fecha_modificacion>
</row>
<row>
  <ID>115</ID>
  <supergrupo>BitWise</supergrupo>
  <tema>Palíndromo binario</tema>
  <texto>Encuentre el número cuya representación binaria es un palíndromo. No se consideran los ceros iniciales, Mientras se considera la representación binaria, considere el primer número cuya representación binaria es palíndroma como 1, en vez de 0.
Una aproximación ingenua puede ser atravesar a través de todos los enteros desde 1 hasta 2^31-1 e incrementar el conteo palíndromo, si el número es palíndromo, cuando el conteo palíndromo alcanza el n requerido, rompe el ciclo y retorna el actual entero.
La complejidad de tiempo de esta solución es O(x) donde x es el número resultado. Note que el valor de x es generalmente más grande que n.
</texto>
  <complejidad_tiempo>Mejor caso :    O(x)  Peor caso : O(x)  Promedio: O(x) </complejidad_tiempo>
  <java>/* Programa Java para buscar el Nesimo número el cual
su binario es un palíndromo*/
public class BinaryPalindromeN {

    static int INT_MAX = 2147483647;
    /*Busca si el kesimo bit esta 
    puesto en la representación binaria*/
    static int isKthBitSet(int x, int k) {
        return ((x &amp; (1
                &lt;&lt; (k - 1))) &gt; 0) ? 1 : 0;
    }

    /*Retorna la posicion de más a la izquierda
    el set de bits en la representacion binaria*/
    static int leftmostSetBit(int x) {
        int count = 0;
        while (x &gt; 0) {
            count++;
            x = x &gt;&gt; 1;
        }
        return count;
    }

    /*Encuentra cuales sean los enteros en binario
    siendo plindromos o no*/
    static int isBinPalindrome(int x) {
        int l = leftmostSetBit(x);
        int r = 1;
        //Uno a uno se comparan los bits
        while (l &gt; r) {
        //Comprara bits de izquierda y derecha
        // y converge 
            if (isKthBitSet(x, l)
                    != isKthBitSet(x, r)) {
                return 0;
            }
            l--;
            r++;
        }
        return 1;
    }

    static int findNthPalindrome(int n) {
        int pal_count = 0;
        /*Comienza desde 1, atravieza por todos los
        enteros*/
        int i = 0;
        for (i = 1; i &lt;= INT_MAX; i++) {
            if (isBinPalindrome(i) &gt; 0) {
                pal_count++;
            }
            /*Si nosotros llegamos n 
            rompe el ciclo*/
            if (pal_count == n) {
                break;
            }
        }
        return i;
    }

    public static void main(String[] args) {
        int n = 9;
        System.out.println(findNthPalindrome(n));
    }
} 
</java>
  <cpp>null</cpp>
  <py>from sys import maxsize
from sys import stdin
from sys import stdout
rl = stdin.readline
wr = stdout.write

def iskthBitSet(x, k):
    return 1 if (x &amp; (1 &lt;&lt; (k-1))) &gt; 0 else 0

def leftMostSetBit(x):
    cont = 0
    while x &gt; 0:
        cont += 1
        x = x &gt;&gt; 1
    return cont

def isBinPal(x):
    l = leftMostSetBit(x)
    r = 1
    while l &gt; r:
        if iskthBitSet(x, 1) != iskthBitSet(x, r):
            return 0
        l -= 1
        r += 1
    return 1

def findNthPal(n):
    pal_cont = 0
    i = 0
    for i in range(maxsize):
        if isBinPal(i) &gt; 0:
            pal_cont += 1
        if pal_cont == n:
            break
    return i

string = rl()
n = int(string, 16)
res = findNthPal(n)
wr(f&#39;{res} -&gt; {bin(res)[2:]}&#39;)
</py>
  <orden>4</orden>
  <suborden>5</suborden>
  <fecha_creacion>2020-12-04 23:04:33</fecha_creacion>
  <fecha_modificacion>2020-12-06 20:11:16</fecha_modificacion>
</row>
<row>
  <ID>116</ID>
  <supergrupo>BitWise</supergrupo>
  <tema>Número más cercano con los mismos bits</tema>
  <texto>Dado un entero positivo n, imprimir el siguiente más pequeño y el previo más largo que tiene el mismo número de bits 1 en su representación binaria.
Aproximación por fuerza bruta:
Una simple aproximación es contar el número de 1 en n, y luego incrementar o decrementar hasta que encontremos un número con el mismo número de 1.
Aproximación optimizada:
Vamos a inicial con el código de getNext, y luego nos movemos a getPrev.
Aproximación de manipulación de bits para obtención del siguiente número:
Si pensamos acerca cual será el siguiente número, podemos observar lo siguiente, dado el número 13948, su representación binaria es:
1   1   0   1   1  0  0  1  1  1  1  1  0  0
13  12  11  10  9  8  7  6  5  4  3  2  1  0
Buscamos hacer este número más grande, pero no muy grande, también necesitamos mantener el mismo número de unos.
Nota: Dado un número N y dos localizaciones de bits i y j, suponga que volteamos bit i desde 1 a 0, y bit j desde 0 a 1, si i&gt;j, entonces n podrá decrementarse, si i&lt;j entonces n podrá incrementarse.
Sabemos lo siguiente:
- Si volteamos un cero a un uno, debemos voltear un uno a un cero.
- El número (Luego de dos volteretas) podría ser más grande si y solo si el bit cero a uno fue el izquierdo del bit uno a cero.
Nosotros queremos hacer el número más grande, pero no necesariamente más grande, por lo tanto necesitamos voltear el cero de más a la derecha el cual tiene unos en el derecho de él.
Para pone resto en una forma diferente, nosotros estamos volteando el cero no final de más a la derecho, esto es usando el ejemplo de abajo, los ceros finales son en la primera y cero posición. El cero no final de más a la derecha es un bit 7, vamos a llamar esta posición p.
- p -&gt; posición de más a la derecha que no sea cero final.
Paso 1: volteamos el cero más a la derecha no final.
- 1    1   0   1  1  0  1  1  1  1  1  1  0  0
- 13  12  11  10  9  8  7  6  5  4  3  2  1  0
Con este cambio, hemos incrementado el número de unos en n, podemos encojer el número reordenando todos los bits de la derecha del bit p tales que los ceros están en la izquierda y los unos están a la derecha, cuando se hace esto, se busca reemplazar uno  de los unos con cero.
Una forma relativamente fácil de hacer esto es contando cuantos unos están a la derecha de p, despejar todos los bits desde 0 hasta p, y luego agregar de nuevo en c1-1 unos. Dejar c1 ser el número de unos de la derecha de p y c0 el número de ceros de la derecha de p.
Vamos a verificar esto con un ejemplo:
- c1-&gt; Número de unos de la derecho de p
- c0-&gt; Número de ceros de la derecho de p
- p = c0 + c1
Paso 2: despejar los bits de la derecha de p, como antes c0 = 2. c1 = 5. p = 7.
- 1    1   0   1  1  0  1  0  0  0  0  0  0  0
- 13  12  11  10  9  8  7  6  5  4  3  2  1  0
Para despejar estos bits, necesitamos crear una máscara que sea una secuencia de unos, seguido por p ceros, podemos hacer esto de la siguiente forma:
Todos los ceros excepto por un 1 en la posición p.
- a = 1 &lt;&lt; p; 
Todos los ceros, seguidos por p unos. 
- b = a - 1;                       
Todos los unos, seguidos por p ceros.
- mask = ~b;                       
Despeja los p bits de más a la derecha.
- n = n &amp; mask;                
O más concisamente, hacemos: 
- n &amp;= ~ ((1 &lt;&lt; p) - 1).
Paso 3: Agrega un c1=1 unos.
- 1   1   0   1   1  0  1  0  0  0  1  1  1  1
- 13  12  11  10  9  8  7  6  5  4  3  2  1  0
Para insertar c1-1 unos a la derecha, se realiza:
Ceros con un uno en la posición c1– 1
- a = 1 &lt;&lt; (c1 - 1);    
Ceros con unos en posiciones cero a través de c1-1
- b = a - 1;                
Inserta unos en las posiciones 0 a través de c1-1
- n = n | b;                
O más concisamente:
- n | = (1 &lt;&lt; (c1 - 1)) - 1;  
</texto>
  <complejidad_tiempo>Mejor caso :    O(n)  Peor caso : O(n)  Promedio: O(n) </complejidad_tiempo>
  <java>/* Programa JAVA de busqueda del siguiente número con 
la misma cantidad de 1 que algun anterior*/
public class ClosestNumbersSamebits {

    static int getNext(int n) {
        // Computa c0 y c1
        int c = n;
        int c0 = 0;
        int c1 = 0;
        while (((c &amp; 1) == 0)
                &amp;&amp; (c != 0)) {
            c0++;
            c &gt;&gt;= 1;
        }
        while ((c &amp; 1) == 1) {
            c1++;
            c &gt;&gt;= 1;
        }
        /*Si no hay número más grande 
        con el número de 1 buscado*/
        if (c0 + c1 == 31
                || c0 + c1 == 0) {
            return -1;
        }
        //Posicion de el más derecho cero 
        int p = c0 + c1;
        //Voltea el zero más derecho
        n |= (1 &lt;&lt; p);
        // Despeja todos los bits de la derecha de p
        n &amp;= ~((1 &lt;&lt; p) - 1);
        //Inserta los (c1-1) a la derecha
        n |= (1 &lt;&lt; (c1 - 1)) - 1;
        return n;
    }

    static int getPrev(int n) {
        int temp = n;
        int c0 = 0;
        int c1 = 0;
        while ((temp &amp; 1) == 1) {
            c1++;
            temp = temp &gt;&gt; 1;
        }
        if (temp == 0) {
            return -1;
        }
        while (((temp &amp; 1) == 0)
                &amp;&amp; (temp != 0)) {
            c0++;
            temp = temp &gt;&gt; 1;
        }
        // posicion de el cero no final de 
        // mas a la derecha
        int p = c0 + c1;
        //limpia del bit c hacia adelante 
        n = n &amp; ((~0) &lt;&lt; (p + 1));
        // Secuencia de (c1+1) unos
        int mask = (1 &lt;&lt; (c1 + 1)) - 1;
        n = n | mask &lt;&lt; (c0 - 1);
        return n;
    }

    public static void main(String[] args) {
        int n = 5;
        System.out.println(n + &quot;-&gt;&quot; + Integer.toString(n, 2) + &quot; &quot; + getNext(n));

        System.out.println(n + &quot;-&gt;&quot; + Integer.toString(n, 2) + &quot; &quot; + getPrev(n));
    }
}
</java>
  <cpp>#include&lt;bits/stdc++.h&gt;
#include&lt;cstdlib&gt;
//---------------//
using namespace std;
int getNext(int n){
    int c=n;
    int c0=0;
    int c1=0;
    while((c&amp;1)==0 &amp;&amp; (c!=0)){
        c0++;
        c &gt;&gt;=1;
    }
    while((c&amp;1)==1){
        c1++;
        c &gt;&gt;=1;
    }
    if(c0+c1 ==31 || c0+c1==0){
        return -1;
    }
    int p=c0+c1;
    n|=(1&lt;&lt;p);
    n&amp;=~((1&lt;&lt;p)-1);
    n|=(1&lt;&lt;(c1-1))-1;
    return n;
}

int getPrev(int n){
    int temp=n;
    int c0=0;
    int c1=0;
    while((temp&amp;1)==1){
        c1++;
        temp &gt;&gt;=1;
    }
    if(temp==0){
        return -1;
    }
    while(((temp&amp;1)==0) &amp;&amp; (temp!=0)){
        c0++;
        temp &gt;&gt;=1;
    }
    int p=c0+c1;
    n&amp;=((~0)&lt;&lt;(p+1));
    int mask=(1&lt;&lt;(c1+1))-1;
    n|=mask&lt;&lt;(c0-1);
    return n;
}
int main() {
    int n=5;
    cout&lt;&lt;(getNext(n))&lt;&lt;endl;
    n=5;
    cout&lt;&lt;(getPrev(n))&lt;&lt;endl;
}
</cpp>
  <py>from sys import stdin, stdout
rl = stdin.readline
wr = stdout.write


def getNext(n):
    c = n
    c0 = 0
    c1 = 0
    while (c &amp; 1 == 0) and (c != 0):
        c0 += 1
        c &gt;&gt;= 1
    while (c &amp; 1) == 1:
        c1 += 1
        c &gt;&gt;= 1
    if (c0 + c1 == 31) or (c0 + c1 == 0):
        return -1
    p = c0 + c1
    # Mascaras de Bits
    n |= (1 &lt;&lt; p)
    n &amp;= ~((1 &lt;&lt; p)-1)
    n |= (1 &lt;&lt; (c1-1))-1
    return n


def getPrev(n):
    temp = n
    c0 = 0
    c1 = 0
    while (temp &amp; 1) == 1:
        c1 += 1
        temp = temp &gt;&gt; 1
    if temp == 0:
        return -1
    while (temp &amp; 1 == 0) and (temp != 0):
        c0 += 1
        temp = temp &gt;&gt; 1
    p = c0 + c1
    n &amp;= ((~0) &lt;&lt; (p + 1))
    mask = (1 &lt;&lt; (c1 + 1)) - 1
    n |= mask &lt;&lt; (c0 - 1)
    return n


n = int(rl())
wr(f&#39;{n} -&gt; {bin(n)[2:]}\n&#39;)
wr(f&#39;{getNext(n)} -&gt; {bin(getNext(n))[2:]}\n&#39;)
wr(f&#39;{getPrev(n)} -&gt; {bin(getPrev(n))[2:]}&#39;)
</py>
  <orden>4</orden>
  <suborden>6</suborden>
  <fecha_creacion>2020-12-04 23:04:34</fecha_creacion>
  <fecha_modificacion>2020-12-06 20:11:16</fecha_modificacion>
</row>
<row>
  <ID>117</ID>
  <supergrupo>BitWise</supergrupo>
  <tema>Códigos de Gray a Binario e inversos</tema>
  <texto>Números binarios es la forma por defecto para almacenar números, pero en muchas aplicaciones los números binarios son difíciles de usar y una variación de los números binarios es necesaria, aquí es cuando los códigos de Gray son muy útiles.
El código de gray tiene una propiedad, dos números sucesivos difieren en un solo bit porque esta propiedad permite tener ciclo a través de varios estados con un esfuerzo mínimo y son usados en mapas k, también permiten corrección de errores, comunicación entre  muchas cosas más.
¿Cómo generar códigos de Gray de n bits?
La siguiente es la secuencia de dos bits (n=2)
-   00 01 11 10
La siguiente es la secuencia de 3 bits (n = 3)
- 000 001 011 010 110 111 101 100
Y la siguiente es la secuencia de 4 bits (n = 4)
- 0000 0001 0011 0010 0110 0111 0101 0100 1100 1101 1111 1110 1010 1011 1001 1000
Los códigos de Gray de n bits pueden ser generados de la lista de (n-1) códigos de Gray con los siguientes pasos.
- Dejar la lista de (n-1)bits ser L1, crear otra lista L2 la cual es la reversa de L1
- Modificar la lista L1 usando prefijo ‘0’ en todos los códigos de L1
- Concatene L1 y L2. La lista concatenada es la lista requerida de los códigos de Gray de n bits
En ciencias de la computación muchas veces necesitamos convertir de código binario a código de Gray y viceversa, esta conversion puede ser realizada bajo las siguientes reglas:
Conversión de binario a Gray:
El bit más significante (MSB most significant bit) del código de gray es siempre igual a el MSB del código binario dado.
Otros bits de la salida del código de gray pueden ser obtenidos realizando XOR al bit del código binario en ese índice y en el índice anterior.
Conversión de Gray a binario: 
El MSB del código binario es siempre igual al MSB del código de Gray.
Los otros bits de la salida del código binario pueden ser obtenidos verificando el bit del código Gray en ese incide, si el bit actual es 0, entonces copia el anterior bit del código binario, si no copia el inverso del anterior bit del código binario.
</texto>
  <complejidad_tiempo>Mejor caso :    O(n2)  Peor caso : O(n2)  Promedio: O(n2) </complejidad_tiempo>
  <java>// Programa en java para coversion binario - Gray e inverso

import java.io.*;

public class CodeConversionGrayToBinary {

    public static void main(String args[]) throws IOException {

        String binary = &quot;01001&quot;;
        System.out.println(&quot;Codigo gray de &quot; + binary + &quot; is &quot; + binarytoGray(binary));

        String gray = &quot;01101&quot;;
        System.out.println(&quot;Codigo Binaruo de &quot; + gray + &quot; is &quot; + graytoBinary(gray));
    }

    static char xor_c(char a, char b) {
        return (a == b) ? &#39;0&#39; : &#39;1&#39;;
    }
    //Funcion para voltear el bit 

    static char flip(char c) {
        return (c == &#39;0&#39;) ? &#39;1&#39; : &#39;0&#39;;
    }
    //Funcion binario a gray

    static String binarytoGray(String binary) {
        String gray = &quot;&quot;;
        gray += binary.charAt(0);
        // Coomputa bits restantes, siguiente bit es conmutado haciendole
        // XOR del previo con el actual en binario
        for (int i = 1; i &lt; binary.length(); i++) {
            /*Comcatena XOR del bit anterior con el actual*/
            gray += xor_c(binary.charAt(i - 1),
                    binary.charAt(i));
        }
        return gray;
    }
    //Funcion gray a binario
    static String graytoBinary(String gray) {
        String binary = &quot;&quot;;
        binary += gray.charAt(0);
        // Computa bits restantes,
        for (int i = 1; i &lt; gray.length(); i++) {
            //Si el bit actual es 0, concatena el bit anterior
            if (gray.charAt(i) == &#39;0&#39;) {
                binary += binary.charAt(i - 1);
            } //Sino, concatena invertidamente el bit anterior
            else {
                binary += flip(binary.charAt(i - 1));
            }
        }
        return binary;
    }
}
</java>
  <cpp>#include&lt;bits/stdc++.h&gt;
#include&lt;cstdlib&gt;
//---------------//
using namespace std;
char xor_c(char a,char b){
    return (a==b)?&#39;0&#39;:&#39;1&#39;;
}
char flip(char c){
    return (c==0)?&#39;1&#39;:&#39;0&#39;;
}
string grayToBinary(string gray){
    string binary = &quot;&quot;;
    int tam = gray.size();
    binary += gray[0];
    for(int i = 1; i &lt; tam; i++){
        if(gray[i] == &#39;0&#39;){
            binary += binary[i - 1];
        }else{
            binary += flip(binary[i - 1]);
        }
    }
    return binary;
}
string binaryToGrey(string binary){
    string grey=&quot;&quot;;
    grey+=binary[0];
    for(int i=1;i&lt;binary.size();i++){
        grey+=xor_c((binary[i-1]),(binary[i]));
    }
    return grey;
}
int main() {
    string n=&quot;01001&quot;;
    cout&lt;&lt;(binaryToGrey(n))&lt;&lt;endl;
    n=&quot;01001&quot;;
    cout&lt;&lt;(grayToBinary(n))&lt;&lt;endl;
}
</cpp>
  <py>from sys import stdin, stdout
rl = stdin.readline
wr = stdout.write

def binarytoGray(binary):
    gray = &#39;&#39;
    gray += binary[0]
    for i in range(1, len(binary)):
        gray += xor_c(binary[i-1], binary[i])
    return gray

def xor_c(a, b):
    return &#39;0&#39; if a == b else &#39;1&#39;

def flip(c):
    return &#39;1&#39; if c == &#39;0&#39; else &#39;0&#39;

def graytoBinary(gray):
    binary = &#39;&#39;
    binary += gray[0]
    for i in range(1, len(gray)):
        if gray[i] == &#39;0&#39;:
            binary += binary[i-1]
        else:
            binary += flip(binary[i-1])
    return binary

b1 = &#39;01001&#39;
res = binarytoGray(b1)
wr(f&#39;{b1} -&gt; {res}\n&#39;)
res2 = graytoBinary(res)
wr(f&#39;{res} -&gt; {res2}&#39;)
</py>
  <orden>4</orden>
  <suborden>7</suborden>
  <fecha_creacion>2020-12-04 23:04:34</fecha_creacion>
  <fecha_modificacion>2020-12-06 20:11:17</fecha_modificacion>
</row>
<row>
  <ID>118</ID>
  <supergrupo>BitWise</supergrupo>
  <tema>Códigos de Gray de N bits</tema>
  <texto>Dado un número n, generar los patrones de bits de 0 a 2^n-1 de los cuales cada patrón sucesivo difiera en uno solo bit.
Los códigos de Gray de n bits pueden ser generados de la lista de (n-1) códigos de Gray con los siguientes pasos.
- Dejar la lista de (n-1)bits ser L1, crear otra lista L2 la cual es la reversa de L1
- Modificar la lista L1 usando prefijo ‘0’ en todos los códigos de L1
- Concatene L1 y L2. La lista concatenada es la lista requerida de los códigos de Gray de n bits
Por ejemplo, los siguientes son los pasos para generar el código de Gray de 3 bits desde la lista de códigos de Gray de 2 bits.
- L1 = {00, 01, 11, 10} (Lista de Gray de dos bits)
- L2 = {10, 11, 01, 00} (Reversa de  L1)
- Agrega prefijo a todas las entradas de L1 con ‘0’, L1 se convierte en {000, 001, 011, 010}
- Agrega prefijo a todas las entradas de L2 con ‘1’, L2 se convierte en {110, 111, 101, 100}
- Concatena L1 y L2, obtenemos {000, 001, 011, 010, 110, 111, 101, 100}
Para generar los códigos de Gray de n bits, empezamos desde la lista de Grays de un solo bit, la cual es {0,1}, repetimos los pasos de arriba para general la lista de 2 bits a partir de la de 1 solo bit, luego generamos la de 3 bits a partir de la de 2 bits, y así hasta que el número de bits sea igual a n.
</texto>
  <complejidad_tiempo>Mejor caso :    O(nlog(n))  Peor caso : O(nlog(n))  Promedio: O(nlog(n)) </complejidad_tiempo>
  <java>//Programa Java para generar codigos de Gray Nesimos  

import java.util.ArrayList;

public class GrayCodesOfN {

    static void generateGrayarr(int n) {
        // Caso base
        if (n &lt;= 0) {
            return;
        }
        // &#39;arr&#39; podria almacenar todos los codigos generados 
        ArrayList&lt;String&gt; arr = new ArrayList&lt;String&gt;();
        // Comienza con un patron de un bit 
        arr.add(&quot;0&quot;);
        arr.add(&quot;1&quot;);
        /* Cada iteracion de este ciclo genera 2*i codigos desde los 
        i codigos generados previamente*/
        int i, j;
        for (i = 2; i &lt; (1 &lt;&lt; n); i = i &lt;&lt; 1) {
            /*Entra los previamente generados codigos de nuevo a arr[]
                en orden reverso, arr[] tiene el doble de número de codigos*/
            for (j = i - 1; j &gt;= 0; j--) {
                arr.add(arr.get(j));
            }
            // Concatena 0 a la primera mitad
            for (j = 0; j &lt; i; j++) {
                arr.set(j, &quot;0&quot; + arr.get(j));
            }
            // Concatena 1 a la segunda mitad
            for (j = i; j &lt; 2 * i; j++) {
                arr.set(j, &quot;1&quot; + arr.get(j));
            }
        }
        // Imprime el contenido de arr
        for (i = 0; i &lt; arr.size(); i++) {
            System.out.println(arr.get(i));
        }
    }

    public static void main(String[] args) {
        generateGrayarr(3);
    }
}
</java>
  <cpp>#include&lt;bits/stdc++.h&gt;
#include&lt;cstdlib&gt;
//---------------//
using namespace std;
void generateGray(int n){
    if(n&lt;=0){
        return;
    }
    vector&lt;string&gt;arr;
    arr.push_back(&quot;0&quot;);
    arr.push_back(&quot;1&quot;);
    for(int i=2;i&lt;(1&lt;&lt;n);i &lt;&lt;=1){
        for(int j = i-1;j&gt;=0;j--){
            arr.push_back(arr[j]);
        }
        for(int j=0;j&lt;i;j++){
            arr[j]=&quot;0&quot;+arr[j];
        }
        for(int j=i;j&lt;2*i;j++){
            arr[j]=&quot;1&quot;+arr[j];
        }
    }
    for(int i=0;i&lt;arr.size();i++){
        cout&lt;&lt;arr[i]&lt;&lt;endl;
    }
}
int main(){
    generateGray(5);
}
</cpp>
  <py>from sys import stdin, stdout
rl = stdin.readline
wr = stdout.write

def generateGray(n):
    if n &lt;= 0:
        return
    arr = []
    arr.append(&#39;0&#39;)
    arr.append(&#39;1&#39;)
    i = 2
    j = 0
    while i &lt; (1 &lt;&lt; n):
        for j in range(i-1, -1, -1):
            arr.append(arr[j])
        for j in range(0, i):
            arr[j] = &#39;0&#39; + arr[j]
        for j in range(i, 2*i):
            arr[j] = &#39;1&#39; + arr[j]
        i = i &lt;&lt; 1
    for i in range(len(arr)):
        wr(f&#39;{arr[i]}\n&#39;)

generateGray(5)
</py>
  <orden>4</orden>
  <suborden>8</suborden>
  <fecha_creacion>2020-12-04 23:04:34</fecha_creacion>
  <fecha_modificacion>2020-12-06 20:11:18</fecha_modificacion>
</row>
<row>
  <ID>119</ID>
  <supergrupo>BitWise</supergrupo>
  <tema>Conteo de bits a activar para que  A sea B</tema>
  <texto>Dados dos números ‘a’ y ‘b’, contar el número de bits necesarios a voltear para convertir ‘a’ en ‘b’.
1) Calcular el XOR de A y B:  a_xor_b = A ^ B
2) Contar los bits encendidos de lo de arriba
Resultado:
        countSetBits(a_xor_b)
XOR de dos números tendrá bits encendidos solo en esos lugares donde A difiera de B
</texto>
  <complejidad_tiempo>Mejor caso :    O(bits)  Peor caso : O(bits)  Promedio: O(bits) </complejidad_tiempo>
  <java>//Contar el número de bits que van a ser volteados para convertir A en B  

public class CountAtoB {

    public static int countSetBits(int n) {
        int count = 0;
        while (n != 0) {
            count += n &amp; 1;
            n &gt;&gt;= 1;
        }
        return count;
    }

    public static int FlippedCount(int a, int b) {
        //Retorna el conteo del set de bits en a XOR b 
        return countSetBits(a ^ b);
    }

    public static void main(String[] args) {
        int a = 10;
        int b = 20;
        System.out.print(FlippedCount(a, b));
    }
}
</java>
  <cpp>#include&lt;bits/stdc++.h&gt;
#include&lt;cstdlib&gt;
//---------------//
using namespace std;
int countSetBits(int n){
    int cont=0;
    while(n!=0){
        cont+=n&amp;1;
        n&gt;&gt;=1;
    }
    return cont;
}
int flippedCount(int a,int b){
    return countSetBits(a^b);
}
string toBinary(int n){
    string r;
    while(n!=0) {r=(n%2==0 ?&quot;0&quot;:&quot;1&quot;)+r; n/=2;}
    return r;
}
int main(){
    int a=5;
    int b=100;
    cout&lt;&lt;a&lt;&lt;&quot;-&gt;&quot;&lt;&lt;toBinary(a)&lt;&lt;endl;
    cout&lt;&lt;b&lt;&lt;&quot;-&gt;&quot;&lt;&lt;toBinary(b)&lt;&lt;endl;
    cout&lt;&lt;flippedCount(a,b)&lt;&lt;endl;
}

</cpp>
  <py>from sys import stdin, stdout
rl = stdin.readline
wr = stdout.write

def countSetBits(n):
    count = 0
    while n != 0:
        count += n &amp; 1
        n &gt;&gt;= 1
    return count

def flipperCount(a, b):
    return countSetBits(a ^ b)

a = 50
b = 100
wr(f&#39;{a} -&gt; {bin(a)[2:]}\n&#39;)
wr(f&#39;{b} -&gt; {bin(b)[2:]}\n&#39;)
wr(f&#39;{flipperCount(a,b)}&#39;)
</py>
  <orden>4</orden>
  <suborden>9</suborden>
  <fecha_creacion>2020-12-04 23:04:35</fecha_creacion>
  <fecha_modificacion>2020-12-06 20:11:18</fecha_modificacion>
</row>
<row>
  <ID>120</ID>
  <supergrupo>BitWise</supergrupo>
  <tema>Conteo de bits activos </tema>
  <texto>Dado un entero positivo n, cuente el número total de bits encendidos en representación binaria de todos los números de 1 a n.
Una solución simple es correr un ciclo desde 1 hasta n y sumar el conteo de todos los números de 1 a n.
</texto>
  <complejidad_tiempo>Mejor caso :    O(n)  Peor caso : O(n)  Promedio: O(n) </complejidad_tiempo>
  <java>//Un programa simpre que cuenta los bits set (Encendidos)
//en todos los números de 1 a n.

public class CountSetBits {

    static int countSetBits(int n) {
        int bitCount = 0;
        for (int i = 1; i &lt;= n; i++) {
            bitCount += countSetBitsUtil(i);
        }
        return bitCount;
    }
   
    static int countSetBitsUtil(int x) {
        if (x &lt;= 0) {
            return 0;
        }
        return (x % 2 == 0 ? 0 : 1)
                + countSetBitsUtil(x / 2);
    }

    public static void main(String[] args) {
        int n = 4;
        System.out.print(&quot;Conteo total del set de bits es &quot;);
        System.out.print(countSetBits(n));
    }
}
</java>
  <cpp>#include&lt;bits/stdc++.h&gt;
#include&lt;cstdlib&gt;
//---------------//
using namespace std;
string toBinary(int n){
    string r;
    while(n!=0) {r=(n%2==0 ?&quot;0&quot;:&quot;1&quot;)+r; n/=2;}
    return r;
}
int countSetBitUtil(int x){
    if(x&lt;=0){
        return 0;
    }
    return (x%2==0?0:1)+countSetBitUtil(x/2);
}
int countBitSetBits(int n){
    int bitCount=0;
    for(int i=1;i&lt;=n;i++){
        cout&lt;&lt;i&lt;&lt;&quot;-&gt;&quot;&lt;&lt;toBinary(i)&lt;&lt;endl;
        bitCount+=countSetBitUtil(i);
    }
    return bitCount;
}
int main(){
    int n=4;
    cout&lt;&lt;countBitSetBits(n)&lt;&lt;endl;
}

</cpp>
  <py>from sys import stdin, stdout
rl = stdin.readline
wr = stdout.write

def countSetBit(n):
    bitcount = 0
    for i in range(1, n+1):
        wr(f&#39;{i} -&gt; {bin(i)[2:]}\n&#39;)
        bitcount += countSetBitsUtil(i)
    return bitcount

def countSetBitsUtil(x):
    if x &lt;= 0:
        return 0
    return (0 if (x &amp; 1 == 0) else 1) + countSetBitsUtil(x//2)

n = 5
wr(f&#39;{countSetBit(n)}&#39;)
</py>
  <orden>4</orden>
  <suborden>10</suborden>
  <fecha_creacion>2020-12-04 23:04:35</fecha_creacion>
  <fecha_modificacion>2020-12-06 20:11:19</fecha_modificacion>
</row>
<row>
  <ID>121</ID>
  <supergrupo>BitWise</supergrupo>
  <tema>Euclides sin modulo ni división</tema>
  <texto>El algoritmo de Euclides es usado para encontrar el GCD de dos números.
La idea es usar operaciones de BitWise, podemos encontrar x/2 usando x&gt;&gt;1. Podemos verificar si x es par o impar usando x&amp;1.
- gcd(a, b) = 2*gcd(a/2, b/2) si ambos a y b son pares.
- gcd(a, b) = gcd(a/2, b)  si a es par y b es impar.
- gcd(a, b) = gcd(a, b/2) si a es impar y b es par.
</texto>
  <complejidad_tiempo>Mejor caso :    O(log(n))  Peor caso : O(log(n))  Promedio: O(log(n)) </complejidad_tiempo>
  <java>//Programa Java eficiente para realizar maximo comun divisor sin % y /

public class EuclidNoModAndDivide {

    public static void main(String[] args) {
        System.out.println(gcd(8, 9));
    }

    static int gcd(int a, int b) {
        // Casos base
        if (b == 0 || a == b) {
            return a;
        }
        if (a == 0) {
            return b;
        }
        /*Si ambos a y b son pares, divide ambos por 2
        y multiplica el resultado con 2*/
        if ((a &amp; 1) == 0 &amp;&amp; (b &amp; 1) == 0) {
            return gcd(a &gt;&gt; 1, b &gt;&gt; 1) &lt;&lt; 1;
        }
        //Si a es par, y b es impar, divide a por 2
        if ((a &amp; 1) == 0 &amp;&amp; (b &amp; 1) != 0) {
            return gcd(a &gt;&gt; 1, b);
        }
        //Si a es impar y b es par, divide b por 2
        if ((a &amp; 1) != 0 &amp;&amp; (b &amp; 1) == 0) {
            return gcd(a, b &gt;&gt; 1);
        }
        /*Si ambos son impares, entonces aplica el algoritmode 
        resta normal, notese que el casp impar-impar siempre 
        convierte casos impar-par  luego de una recursion*/
        return (a &gt; b) ? gcd(a - b, b) : gcd(a, b - a);
    }
}
</java>
  <cpp>#include&lt;bits/stdc++.h&gt;
#include&lt;cstdlib&gt;
//---------------//
using namespace std;
int gcd(int a,int b){
    if (b == 0 || a == 0) {
        return a;
    }
    if (a == 0) {
        return b;
    }
    if ((a &amp; 1) == 0 &amp;&amp; (b &amp; 1) == 0) {
        return gcd(a &gt;&gt; 1, b &gt;&gt; 1) &lt;&lt; 1;
    }
    if ((a &amp; 1) == 0 &amp;&amp; (b &amp; 1) != 0) {
        return gcd(a &gt;&gt; 1, b);
    }
    if ((a &amp; 1) != 0 &amp;&amp; (b &amp; 1) == 0) {
        return gcd(a, b &gt;&gt; 1);
    }
    return (a &gt; b) ? gcd(a - b, b) : gcd(a, b - a);
}
int main(){
    cout&lt;&lt;gcd(50,30)&lt;&lt;endl;
}
</cpp>
  <py>from sys import stdin, stdout
rl = stdin.readline
wr = stdout.write

def gcd(a, b):
    if b == 0 or a == 0:
        return a
    if a == 0:
        return b
    if (a &amp; 1 == 0) and (b &amp; 1 == 0):
        return gcd(a &gt;&gt; 1, b &gt;&gt; 1) &lt;&lt; 1
    if (a &amp; 1 == 0) and (b &amp; 1 != 0):
        return gcd(a &gt;&gt; 1, b)
    if (a &amp; 1 != 0) and (b &amp; 1 == 0):
        return gcd(a, b &gt;&gt; 1)
    return gcd(a - b, b) if a &gt; b else gcd(a, b - a)

wr(f&#39;{gcd(50,10)}&#39;)
</py>
  <orden>4</orden>
  <suborden>11</suborden>
  <fecha_creacion>2020-12-04 23:04:35</fecha_creacion>
  <fecha_modificacion>2020-12-06 20:11:19</fecha_modificacion>
</row>
<row>
  <ID>122</ID>
  <supergrupo>BitWise</supergrupo>
  <tema>Buscar duplicados usando un arreglo de bits</tema>
  <texto>Se tiene un arreglo de N números, donde n es al menos 32000, el array puede tener entradas duplicadas y no se sabe que N es.
Con solo 4 kilobytes de memoria disponible, ¿cómo podría imprimir todos los elementos duplicados en el array?
Tenemos 4 kilobytes de memoria lo cual significa que podemos direccionar hasta 8*4*210 bits, note que 32*210 es más grande que 32000, podemos crear un array de bits con 32000 bits, donde cada bit representa un entero.
Si se necesita crear un array de bit con más de 32000 bits entonces se puede crear fácilmente más y más de 32000.
Usando este vector de bits, podemos entonces iterar a través del arreglo, marcando cada elemento v poniendo el bit v en 1, cuando pasemos por un elemento duplicado, los imprimimos.
</texto>
  <complejidad_tiempo>Mejor caso :    O(n)  Peor caso : O(n)  Promedio: O(n) </complejidad_tiempo>
  <java>//Programa Java para imprimir todos los duplicados en un arreglo

public class FindDuplicatesBitArray {

    static class BitArray {

        int[] arr;
        // Constructor 
        public BitArray(int n) {
            /*Divide por 32, para almacenar n bits, nosotros necesitamos
            n/32 +1 enteros (Asumiendo int esta almacenado usando 32 bits*/
            arr = new int[(n &gt;&gt; 5) + 1];
        }
        // Obtener el valor de un bit en una posicion dada
        boolean get(int pos) {
            //Divide por 32 para encontrar la posicion del entero
            int index = (pos &gt;&gt; 5);
            //Ahora encuentra el bumero de bits en arr[index]
            int bitNo = (pos &amp; 0x1F);
            //Encuentra el valor dado un número bit en arr[index]
            return (arr[index] &amp; (1 &lt;&lt; bitNo)) != 0;
        }
        // Acomoda un bit en una posicion dada
        void set(int pos) {
            // Encuentra indice de una posicion de un bit
            int index = (pos &gt;&gt; 5);
            //Acomoda un número bot es arr[index] 
            int bitNo = (pos &amp; 0x1F);
            arr[index] |= (1 &lt;&lt; bitNo);
        }
        // Funcion de impresion de los duplicados
        static void checkDuplicates(int[] arr) {
            // Crea un bit con 320000 bits
            BitArray ba = new BitArray(320000);
            // Arreglo transverso de los elementos
            for (int i = 0; i &lt; arr.length; i++) {
                // Indice de un arreglo de bits 
                int num = arr[i] - 1;
                //Si número ya se encuentra presente en el arreglo de bits
                if (ba.get(num)) {
                    System.out.print((num + 1) + &quot; &quot;);
                } // Si no inserte el número
                else {
                    ba.set(num);
                }
            }
        }
    }

    public static void main(String[] args) {
        int[] arr = {10, 10, 1, 1, 2, 2, 3, 3};
        BitArray.checkDuplicates(arr);
    }
}
</java>
  <cpp>#include &lt;iostream&gt;
#include &lt;vector&gt;

using namespace std;

struct BitArray {
    vector &lt;int&gt; arr;

    BitArray(int n) {
        arr.resize((n &gt;&gt; 5) + 1);
    }

    bool get(int pos) {
        int index = (pos &gt;&gt; 5);
        int bitNo = (pos &amp; 0x1F);
        return (arr[index] &amp; (1 &lt;&lt; bitNo)) != 0;
    }

    void setPos(int pos) {
        int index = (pos &gt;&gt; 5);
        int bitNo = (pos &amp; 0x1F);
        arr[index] |= (1 &lt;&lt; bitNo);
    }

    void checkDuplicates(vector &lt;int&gt;&amp; arr, BitArray ba) {
        for (int i = 0; i &lt; arr.size(); i++) {
            int num = arr[i] - 1;
            if (ba.get(num)) {
                cout &lt;&lt; (num + 1) &lt;&lt; &quot; &quot;;
            } else {
                ba.setPos(num);
            }
        }
    }
};

int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(NULL);
    cout.tie(NULL);
    vector &lt;int&gt; arr{10, -10, -10, 8, 8, 5, 3, 4, 4, 3, 7, 9, -9, -8, -9};
    BitArray ba(32000);
    ba.checkDuplicates(arr, ba);
    return 0;
}
</cpp>
  <py>from sys import stdin, stdout
rl = stdin.readline
wr = stdout.write

class BitArray:
    arr = []
    def __init__(self, n):
        self.arr = [0 for x in range((n &gt;&gt; 5)+1)]

    def get(self, pos):
        self.index = (pos &gt;&gt; 5)
        self.bitNo = (pos &amp; 0x1f)
        return (self.arr[self.index] &amp; (1 &lt;&lt; self.bitNo)) != 0

    def set(self, pos):
        self.index = (pos &gt;&gt; 5)
        self.bitNo = (pos &amp; 0x1f)
        self.arr[self.index] |= (1 &lt;&lt; self.bitNo)

    def checkDuplicates(self, arr):
        for i in range(len(arr)):
            num = arr[i]-1
            if ba.get(num):
                wr(f&#39;{num+1} &#39;)
            else:
                ba.set(num)

arr = [10, 10, 10, 5, 58, 8, 1, 5, 3, 2, 16, 4, 4]
ba = BitArray(32000)
ba.checkDuplicates(arr)
</py>
  <orden>4</orden>
  <suborden>12</suborden>
  <fecha_creacion>2020-12-04 23:04:35</fecha_creacion>
  <fecha_modificacion>2020-12-06 20:11:20</fecha_modificacion>
</row>
<row>
  <ID>123</ID>
  <supergrupo>BitWise</supergrupo>
  <tema>Máximo de unos consecutivos</tema>
  <texto>Dado un entero n, pudiendo voltear exactamente un bit, encuentre la longitud de la secuencia más larga de 1 que se pueda crear.
Una solución eficiente es andar a través de los bits en representación binaria del número dado, mantenemos rastreo de la longitud de la secuencia actual de unos, de la longitud de la secuencia de unos previa, cuando veamos un cero, actualizamos la longitud anterior:
- Si el siguiente bit es un 1, la longitud anterior deberá ser ahora la longitud actual.
- Si el siguiente bit es un 0, entonces no podemos unir esas secuencias juntas, entonces la longitud previa es 0.
Actualizamos la longitud máxima comparando las dos siguientes cosas:
- Valor actual de max_lenght
- Current-lenght+previos-length
Entonces
- result = return max-length+1 (// Agrega 1 para el Contador de bits volteados )
</texto>
  <complejidad_tiempo>Mejor caso :    O(n)  Peor caso : O(n)  Promedio: O(n) </complejidad_tiempo>
  <java>//Programa java para buscar el subset de 1 más largo

public class MaxConsecutiveOne {

    static int flipBit(int a) {
        /*Si todos los bits son 1, la representacion de &#39;a&#39;
        tiene todos los unos*/
        if (~a == 0) {
            return 8 * sizeof();
        }
        int currLen = 0, prevLen = 0, maxLen = 0;
        while (a != 0) {
            /*Si el bit actual es un 1
            entonces incrementa currLen++*/
            if ((a &amp; 1) == 1) {
                currLen++;
            } /*Si el bit actual es un 0
            revisa el siguiente bit de a*/ else if ((a &amp; 1) == 0) {
                /*Actualiza prevLan a 0 (Si el siguiente bit es 0)
                o currLen (Si el siguiente bit es 1)*/
                prevLen = (a &amp; 2) == 0 ? 0 : currLen;
                /*Si dos bits consecutivos son 0
                entonces currLen tambien sera 0*/
                currLen = 0;
            }
            // Actualiza maxLen si es requerido 
            maxLen = Math.max(prevLen + currLen, maxLen);
            //Remueve el ultimo digito (Right shift) 
            a &gt;&gt;= 1;
        }
        /*Nosotros siempre podremos tener un secuencia de 
        al menos un 1, este es un bit volteado*/
        return maxLen + 1;
    }

    static byte sizeof() {
        byte sizeOfInteger = 8;
        return sizeOfInteger;
    }

    public static void main(String[] args) {
        System.out.println(flipBit(13));
        System.out.println(flipBit(1775));
        System.out.println(flipBit(15));
    }
}
</java>
  <cpp>#include&lt;bits/stdc++.h&gt;
#include&lt;cstdlib&gt;
//---------------//
using namespace std;
int SIZE(){
    int sizeOfInteger=8;
    return sizeOfInteger;
}
int flipBit(int a){
    if(~a==0){
        return 8*SIZE();
    }
    int currentlen=0,prevlen=0,maxlen=0;
    while(a!=0){
        if((a&amp;1)==1){
            currentlen++;
        }
        else if((a&amp;1)==0){
            prevlen=(a&amp;2==0)?0:currentlen;
            currentlen=0;
        }
        maxlen=std::max(prevlen+currentlen,maxlen);
        a&gt;&gt;=1;
    }
    return maxlen+1;
}
string toBinary(int n){
    string r;
    while(n!=0) {r=(n%2==0 ?&quot;0&quot;:&quot;1&quot;)+r; n/=2;}
    return r;
}
int main(){
    int a=654321;
    cout&lt;&lt;a&lt;&lt;&quot;-&gt;&quot;&lt;&lt;toBinary(a)&lt;&lt;&quot; : &quot;&lt;&lt;flipBit(a)&lt;&lt;endl;

}
</cpp>
  <py>from sys import stdin, stdout
rl = stdin.readline
wr = stdout.write

def flipBit(a):
    if ~a == 0:
        return 8 * sizeof()
    currlen, prevlen, maxlen = 0, 0, 0
    while a != 0:
        if a &amp; 1 == 1:  # Cambiar a 0
            currlen += 1
        elif a &amp; 1 == 0:  # Cambiar a 1
            prevlen = 0 if ((a &amp; 2) == 0) else currlen
            currlen = 0
        maxlen = max(prevlen + currlen, maxlen)
        a &gt;&gt;= 1
    return maxlen + 1

def sizeof():
    sizeOfInteger = 8
    return sizeOfInteger

a = int(rl())
wr(f&#39;{a} -&gt; {bin(a)[2:]}\n&#39;)
wr(f&#39;{flipBit(a)}&#39;)
</py>
  <orden>4</orden>
  <suborden>13</suborden>
  <fecha_creacion>2020-12-04 23:04:36</fecha_creacion>
  <fecha_modificacion>2020-12-06 20:11:21</fecha_modificacion>
</row>
<row>
  <ID>124</ID>
  <supergrupo>BitWise</supergrupo>
  <tema>Máximo XOR Subarray</tema>
  <texto>Dado un array de enteros, encontrar el valor máximo del Subarray XOR en el array dado. Una solución simple es usar dos ciclos para encontrar el XOR de todos los subarrays y retornar el máximo.</texto>
  <complejidad_tiempo>Mejor caso :    O(n2)  Peor caso : O(n2)  Promedio: O(n2) </complejidad_tiempo>
  <java>// Programa en JAVA para buscar el maximo subarreglo XOR  

public class MaxSubarrayXOR {

    static int maxSubarrayXOR(int arr[], int n) {
        int ans = Integer.MIN_VALUE; // Inicializar resultado 
        // Escogiendo puntos de inicio para los subarreglos
        for (int i = 0; i &lt; n; i++) {
            // para guardar XOR del actual subarreglo
            int curr_xor = 0;
            // Escojiendo puntos finales de subarreglos empezando por i
            for (int j = i; j &lt; n; j++) {
                curr_xor = curr_xor ^ arr[j];
                ans = Math.max(ans, curr_xor);
            }
        }
        return ans;
    }

    public static void main(String args[]) {
        int arr[] = {8, 1, 2, 12};
        int n = arr.length;
        System.out.println(&quot;Maximo subarray XOR es &quot;
                + maxSubarrayXOR(arr, n));
    }
}
</java>
  <cpp>#include&lt;bits/stdc++.h&gt;
#include&lt;cstdlib&gt;
//---------------//
using namespace std;
int maxSubArrayXOR(int arr[],int n){
    int ans=INT_MIN;
    for(int i=0;i&lt;n;i++){
        int curr_xor=0;
        for(int j=i;j&lt;n;j++){
            curr_xor = curr_xor ^ arr[j];
            ans = std::max(ans, curr_xor);
        }
    }
    return ans;
}
int main(){
    int arr[] = {8, 1, 2, 12};
    int n = sizeof (arr)/sizeof (arr[0]);
    cout&lt;&lt;&quot;Maximo subarray XOR es &quot;&lt;&lt;maxSubArrayXOR(arr,n)&lt;&lt;endl;
} 
</cpp>
  <py>null</py>
  <orden>4</orden>
  <suborden>14</suborden>
  <fecha_creacion>2020-12-04 23:04:36</fecha_creacion>
  <fecha_modificacion>2020-12-06 20:11:21</fecha_modificacion>
</row>
<row>
  <ID>125</ID>
  <supergrupo>BitWise</supergrupo>
  <tema>N número mágico</tema>
  <texto>Un número mágico es definido como un número el cual puede ser expresado como una potencia de 5 o la suma de potencias únicas de 5, algunos números mágicos son 5, 25, 30(5 + 25), 125, 130(125 + 5), ….
Si revisamos cuidadosamente los números mágicos, pueden ser representados como 001, 010, 011, 100, 101, 110, entre otros, donde 001 es 0*pow(5,3)+0*pow(5,2)+1*pow(5,1), entonces básicamente necesitamos agregar potencias de 5 por cada bit dado en el entero dado n.
</texto>
  <complejidad_tiempo>Mejor caso :    O(log(n))  Peor caso : O(log(n))  Promedio: O(log(n)) </complejidad_tiempo>
  <java>// Programa en java para buscar el Nsimo
// número magico, un número magico esta definido como un número el cual puede ser expresado como
// una potencia de 5 o suma de potencias unicas de 5
// Algunos primeros número magicos son: 5, 25, 30(5 + 25), 125, 130(125 + 5), … en adelante

public class NMagicNumber {

    static int nthMagicNo(int n) {
        int pow = 1, answer = 0;
        // Ir a traves de cada bit de n
        while (n != 0) {
            pow = pow * 5;
            // Si el untimo bit de n esta puesto
            if ((n &amp; 1) == 1) {
                answer += pow;
            }
            //Proceder con el siguiente bit 
            // 0 n= n/2 
            n &gt;&gt;= 1;
        }
        return answer;
    }

    public static void main(String[] args) {
        int n = 5;
        System.out.println(&quot;Enesimo número&quot;
                + &quot; magico es &quot; + nthMagicNo(n));
    }
} 
</java>
  <cpp>null</cpp>
  <py>null</py>
  <orden>4</orden>
  <suborden>15</suborden>
  <fecha_creacion>2020-12-04 23:04:37</fecha_creacion>
  <fecha_modificacion>2020-12-06 20:11:22</fecha_modificacion>
</row>
<row>
  <ID>126</ID>
  <supergrupo>BitWise</supergrupo>
  <tema>Intercambio de pares e impares</tema>
  <texto>Dado un entero sin signo, intercambia todos los bits pares con impares, por ejemplo si el número dado es 23 (00010111), puede ser convertido en 43 (00101011). Cada posición de bit par es intercambiada con el bit adyacente del lado de derecho, y cada posición impar es cambiada con el adyacente del lado izquierdo. 
Si realizamos una revisión en el ejemplo, podemos observar que básicamente necesitamos el corrimiento derecho (&gt;&gt;) de todos los bits pares por 1, entonces se convierten en bits impares, y corrimiento izquierdo (&lt;&lt;)  todos los bits impares por 1 entonces se convierten en pares, la siguiente solución está basada en estas ideas, se asume que el número de entrada está almacenado usando 32 bits.
Dejemos la entrada ser x.
1) Obtener todos los bits pares de x realizando BitWise, y or de x con 0xAAAAAAAA, el número 0xAAAAAAAA es un entero de 32 bit con todos los bits pares ubicados en 1, y todos los impares en 0.
2) Obtener todos los bits impares usando BitWise, y or de x con 0x55555555, el número 0x55555555 es un número entero de 32 bits con todos los bits impares en 1 y los pares en 0.
3) Corrimiento derecho de todos los bits pares
4) Corrimiento izquierdo de todos los bits impares
5) Combina los nuevos pares e impares y retorna
</texto>
  <complejidad_tiempo>Mejor caso :    O(1)  Peor caso : O(1)  Promedio: O(1) </complejidad_tiempo>
  <java>// Programa java para invertir bits pares  
// e impares de un número dado

public class OddEvenSwap {

    static int swapBits(int x) {
        // Obtener todos los bits par de x 
        int even_bits = x &amp; 0xAAAAAAAA;
        //Obtener todos los bits impar de x 
        int odd_bits = x &amp; 0x55555555;
        //  Movimiento derecho de bits pares
        even_bits &gt;&gt;= 1;
        // Movimiento izquierdo de bits impares 
        odd_bits &lt;&lt;= 1;
        // combinar pares e impares
        return (even_bits | odd_bits);
    }

    public static void main(String[] args) {
        int x = 23; // 00010111 
        // La salida es 43 (00101011) 
        System.out.println(swapBits(x));
    }
}
</java>
  <cpp>#include&lt;bits/stdc++.h&gt;
#include&lt;cstdlib&gt;
//---------------//
using namespace std;
int swapBits(int x){
    int even_bits=x &amp; 0xAAAAAAAA;
    int oddbits=x &amp; 0x55555555;
    even_bits&gt;&gt;=1;
    oddbits&lt;&lt;=1;
    return (even_bits|oddbits);
}
string toBinary(int n){
    string r;
    while(n!=0) {r=(n%2==0 ?&quot;0&quot;:&quot;1&quot;)+r; n/=2;}
    return r;
}
int main(){
   int x=7;
   cout&lt;&lt;x&lt;&lt;&quot;-&gt;&quot;&lt;&lt;toBinary(x)&lt;&lt;endl;
   int y=swapBits(x);
   cout&lt;&lt;swapBits(x)&lt;&lt;&quot;-&gt;&quot;&lt;&lt;toBinary(y)&lt;&lt;endl;

} 

</cpp>
  <py>null</py>
  <orden>4</orden>
  <suborden>16</suborden>
  <fecha_creacion>2020-12-04 23:04:37</fecha_creacion>
  <fecha_modificacion>2020-12-06 20:11:23</fecha_modificacion>
</row>
<row>
  <ID>127</ID>
  <supergrupo>BitWise</supergrupo>
  <tema>Ocurrencia impar</tema>
  <texto>Dado un array de enteros positivos, todos los números  ocurren número par de veces excepto un número el cual ocurre impar veces, encuentre el número en O(n) tiempo y espacio constante.
Una solución simple es correr dos ciclos anidados, el ciclo externo toma todos los elementos uno por uno y el ciclo interno cuenta el número de las ocurrencias del elemento tomado en el ciclo externo, la complejidad de tiempo de esta solución es O(n^2).
La mejor solución es hacer XOR bit a bit de todos los elementos. Un XOR de todos los elementos nos muestra cuales elementos son impares. Tenga en cuenta que XOR de dos elementos es 0 si ambos elementos son iguales y XOR de un número x con 0 es x.
</texto>
  <complejidad_tiempo>Mejor caso :    O(n)  Peor caso : O(n)  Promedio: O(n) </complejidad_tiempo>
  <java>//Programa JAVA para buscar la ocurrencia de un elemento
// número impar de veces

public class OddOccurence {

    static int getOddOccurrence(int ar[], int ar_size) {
        int i;
        int res = 0;
        for (i = 0; i &lt; ar_size; i++) {
            res = res ^ ar[i];
        }
        return res;
    }

    public static void main(String[] args) {
        int ar[] = new int[]{2, 3, 5, 4, 5, 2, 4, 3, 5, 2, 4, 4, 2};
        int n = ar.length;
        System.out.println(getOddOccurrence(ar, n));
    }
} 
</java>
  <cpp>null</cpp>
  <py>null</py>
  <orden>4</orden>
  <suborden>17</suborden>
  <fecha_creacion>2020-12-04 23:04:37</fecha_creacion>
  <fecha_modificacion>2020-12-06 20:11:23</fecha_modificacion>
</row>
<row>
  <ID>128</ID>
  <supergrupo>BitWise</supergrupo>
  <tema>Multiplicación Russian Peasant</tema>
  <texto>Dados dos enteros, multiplicar sin usar el operador de multiplicación.
Una forma interesante es usar el algoritmo de la campesina rusa, la idea es duplicar el primer número y dividir en dos el segundo número repetidamente mientras el segundo número no se convierta en 1, en el proceso cuando el segundo número se vuelta impar, añadimos el primer número al resultado, el cual esta inicializado en 0.
El valor de a*b es el mismo que (a*2)*(b/2), si b es par, de otra forma el valor es el mismo de ((a*2)*(b/2) + a), en el ciclo while, seguimos multiplicando ‘a’ con dos y seguimos dividiendo ‘b’ por 2, si ‘b’ se convierte en impar en el ciclo, agregamos ‘a’ a ‘res’ cuando el valor de ‘b’ se convierta en 1, el valor de ‘res’ + ‘a’ nos da el resultado.
Note que cuando ‘b’ es una potencia de 2, el ‘res’ puede mantenerse en 0 y ‘a’ puede ser la multiplicación.
</texto>
  <complejidad_tiempo>Mejor caso :    O(n)  Peor caso : O(n)  Promedio: O(n) </complejidad_tiempo>
  <java>// Programa en java para multiplicar usando el algoritmo de  Russian Peasant  

public class RussianPeasantMultiply {
    // Funcion para multiplicar dos números 
    static int russianPeasant(int a, int b) {
        // Inicializar resultado
        int res = 0;
        //Mientras el segundo no se convierta en 1
        while (b &gt; 0) {
            // Si el segundo número es  impar, 
            // añade el primer número al resultado 
            if ((b &amp; 1) != 0) {
                res = res + a;
            }
            // El doble del primer número
            // y la mitad del segundo número 
            a = a &lt;&lt; 1;
            b = b &gt;&gt; 1;
        }
        return res;
    }

    public static void main(String[] args) {
        System.out.println(russianPeasant(18, 1));
        System.out.println(russianPeasant(20, 12));
    }
}
</java>
  <cpp>#include&lt;bits/stdc++.h&gt;
#include&lt;cstdlib&gt;
//---------------//
using namespace std;

int RP(int a, int b) {
    int res = 0;
    while (b &gt; 0) {
        if ((b &amp; 1) != 0) {
            res += a;
        }
        a &lt;&lt;= 1;
        b &gt;&gt;= 1;
    }
    return res;
}

int main() {
    cout &lt;&lt; (RP(2, 18)) &lt;&lt; endl;
}
</cpp>
  <py>from sys import stdin, stdout
rl = stdin.readline
wr = stdout.write

def RP(a, b):
    res = 0
    while b &gt; 0:
        if b &amp; 1 != 0:
            res += a
        a &lt;&lt;= 1
        b &gt;&gt;= 1
    return res

a, b = int(rl()), int(rl())
wr(f&#39;{RP(a, b)}&#39;)
</py>
  <orden>4</orden>
  <suborden>18</suborden>
  <fecha_creacion>2020-12-04 23:04:37</fecha_creacion>
  <fecha_modificacion>2020-12-06 20:11:24</fecha_modificacion>
</row>
<row>
  <ID>129</ID>
  <supergrupo>BitWise</supergrupo>
  <tema>Multiplicación de Karatsuba</tema>
  <texto>Dados dos strings binarios (bigIntegers) que representan el valor de dos enteros, encuentre el producto de los dos strings, por ejemplo, si el primer string de bits es “1100” y el segundo string de bits es “1010” la salida debe ser 120.
Por simplicidad, dejaremos la longitud de ambos strings ser igual y ser n.
- x=5678 y=1234 
- a=56,b=78
- c=12,d=34
Paso 0 = m = n/2 + n%2
Paso 1 = a*c
Paso 2 = b*d
Paso 3 = (a + b)*(c + d)
Paso 4 = 3) - 2) - 1)
Paso 5 = 1)*pow(10, m*2) + 2) + 4)*pow(10, m)
</texto>
  <complejidad_tiempo>Mejor caso :    O(1)  Peor caso : O(1)  Promedio: O(1) </complejidad_tiempo>
  <java>//Programa JAVA que realiza multiplicaciones
//Por medio del algoritmo de Karatsuba

import java.math.BigInteger;
import java.util.Scanner;

public class KaratsubaMultiply {

    public static void main(String[] args) {
        BigInteger x, y;
        Scanner sc = new Scanner(System.in);
        x = sc.nextBigInteger();
        y = sc.nextBigInteger();

        BigInteger result = karatsuba(x, y);
        long result2 = karatsuba(x.longValue(), y.longValue());
        System.out.println(result);
        System.out.println(result2);
    }

    private static long karatsuba(long x, long y) {
        if (x &lt; 10 &amp;&amp; y &lt; 10) {
            return x * y;
        }
        int n = Math.max(Long.valueOf(x).toString().length(), 
                (Long.valueOf(y).toString().length()));
        int m = n / 2 + n % 2;
        long a = x / (long) Math.pow(10, m);
        long b = x % (long) Math.pow(10, m);
        long c = y / (long) Math.pow(10, m);
        long d = y % (long) Math.pow(10, m);
        long step1 = karatsuba(a, c);
        long step2 = karatsuba(b, d);
        long step3 = karatsuba(a + b, c + d);
        long step4 = step3 - step2 - step1;
        long step5 = step1 * (long) Math.pow(10, m * 2) + step2 + step4 * 
                (long) Math.pow(10, m);
        return step5;
    }

    private static BigInteger karatsuba(BigInteger x, BigInteger y) {
        if (x.compareTo(BigInteger.valueOf(10)) &lt; 0 &amp;&amp; 
                y.compareTo(BigInteger.valueOf(10)) &lt; 0) {
            return x.multiply(y);
        }
        int n = Math.max(x.toString().length(), y.toString().length());
        int m = n / 2 + n % 2;
        BigInteger[] a_b = x.divideAndRemainder(BigInteger.valueOf(10).pow(m));
        BigInteger a = a_b[0];
        BigInteger b = a_b[1];
        BigInteger[] c_d = y.divideAndRemainder(BigInteger.valueOf(10).pow(m));
        BigInteger c = c_d[0];
        BigInteger d = c_d[1];
        BigInteger step1 = karatsuba(a, c);
        BigInteger step2 = karatsuba(b, d);
        BigInteger step3 = karatsuba(a.add(b), c.add(d));
        BigInteger step4 = step3.subtract(step2).subtract(step1);
        BigInteger step5 = 
                step1.multiply(BigInteger.valueOf(10).pow(m * 2)).add(step2)
                .add(step4.multiply(BigInteger.valueOf(10).pow(m)));
        return step5;
    }
}
</java>
  <cpp>#include&lt;bits/stdc++.h&gt;
#include&lt;cstdlib&gt;
//---------------//
using namespace std;
typedef long long int ll;
ll makeEqualLength(string &amp;str1, string &amp;str2) {
    ll len1 = str1.size();
    ll len2 = str2.size();
    if (len1 &lt; len2) {
        for (ll i = 0 ; i &lt; len2 - len1 ; i++)
            str1 = &#39;0&#39; + str1;
        return len2;
    }
    else if (len1 &gt; len2) {
        for (ll i = 0 ; i &lt; len1 - len2 ; i++)
            str2 = &#39;0&#39; + str2;
    }
    return len1;
}
string addBitStrings( string first, string second ) {
    string result;
    ll length = makeEqualLength(first, second);
    ll carry = 0;
    for (ll i = length-1 ; i &gt;= 0 ; i--) {
        ll firstBit = first.at(i) - &#39;0&#39;;
        ll secondBit = second.at(i) - &#39;0&#39;;
        ll sum = (firstBit ^ secondBit ^ carry)+&#39;0&#39;;
        result = (char)sum + result;
        carry = (firstBit&amp;secondBit) | (secondBit&amp;carry) | (firstBit&amp;carry);
    }
    if (carry){
        result = &#39;1&#39; + result;
    }
    return result;
}
ll multiplyiSingleBit(string a, string b) {
     return (a[0] - &#39;0&#39;)*(b[0] - &#39;0&#39;);
}
ll karatsuba(string X, string Y) {
    ll n = makeEqualLength(X, Y);
    if (n == 0) return 0;
    if (n == 1) return multiplyiSingleBit(X, Y);
    ll fh = n/2;
    ll sh = (n-fh);
    string Xl = X.substr(0, fh);
    string Xr = X.substr(fh, sh);
    string Yl = Y.substr(0, fh);
    string Yr = Y.substr(fh, sh);
    ll P1 = karatsuba(Xl, Yl);
    ll P2 = karatsuba(Xr, Yr);
    ll P3 = karatsuba(addBitStrings(Xl, Xr), addBitStrings(Yl, Yr));
    return P1*(1&lt;&lt;(2*sh)) + (P3 - P1 - P2)*(1&lt;&lt;sh) + P2;
}
string toBinary(ll n){
    string r;
    while(n!=0) {r=(n%2==0 ?&quot;0&quot;:&quot;1&quot;)+r; n/=2;}
    return r;
}
int main(){
    ll a;
    ll b;
    cin&gt;&gt;a;
    cin&gt;&gt;b;
    string x=toBinary(a);
    string y=toBinary(b);
    cout&lt;&lt;karatsuba(x,y)&lt;&lt;endl;
} 
</cpp>
  <py>null</py>
  <orden>4</orden>
  <suborden>19</suborden>
  <fecha_creacion>2020-12-04 23:04:38</fecha_creacion>
  <fecha_modificacion>2020-12-06 20:11:24</fecha_modificacion>
</row>
<row>
  <ID>130</ID>
  <supergrupo>Grafos </supergrupo>
  <tema>Matriz de adyacencia</tema>
  <texto>La matriz de adyacencia es una matriz cuadrada que se utiliza como una forma de representar relaciones binarias, Se crea una matriz cero, cuyas columnas y filas representan los nodos del grafo. 
1) Por cada arista que une a dos nodos, se suma 1 al valor que hay actualmente en la ubicación correspondiente de la matriz.
2) Si tal arista es un bucle y el grafo es no dirigido, entonces se suma 2 en vez de 1.
3) Finalmente, se obtiene una matriz que representa el número de aristas (relaciones) entre cada par de nodos (elementos).
Existe una matriz de adyacencia única para cada grafo (sin considerar las permutaciones de filas o columnas), y viceversa.
- Para un grafo no dirigido la matriz de adyacencia es simétrica.
- El número de caminos Ci,j(k), atravesando k aristas desde el nodo i al nodo j, viene dado por un elemento de la potencia k-ésima de la matriz de adyacencia: -
- Ci,j(k)=[A^K]ij
Existen otras formas de representar relaciones binarias, como por ejemplo los pares ordenados o los grafos.
</texto>
  <complejidad_tiempo>Mejor caso :    O(n)  Peor caso : O(n)  Promedio: O(n) </complejidad_tiempo>
  <java>//Notacion java de una matriz de adyacencia

import java.util.Scanner;

public class AdyacencyMatrix {
    //matriz del grafo
    static int[][] G;
    static Scanner sc = new Scanner(System.in);
    public static void main(String[] args) {
        //Vertices y caminos
        int V = 4, E = 8;
        G = new int[V][V];
        for (int i = 0; i &lt; V; i++) {
            //desde hasta peso
            int aux1, aux2, aux3;
            aux1 = sc.nextInt();
            aux2 = sc.nextInt();
            aux3 = sc.nextInt();
            // solo este si es dirigido
            G[aux1][aux2] = aux3;
            // inverso si es no dirigido
            G[aux2][aux1] = aux3;
        }
        print(V);
    }
    //Función que imprime la matriz de adyacencia
    static void print(int V) {
        for (int i = 0; i &lt; V; i++) {
            for (int j = 0; j &lt; V; j++) {
                System.out.print(G[i][j] + &quot; &quot;);
            }
            System.out.println(&quot;&quot;);
        }
    }
}
</java>
  <cpp>#include &lt;bits/stdc++.h&gt;
#define MAX_V 101
using namespace std;
static int G[MAX_V][MAX_V];

int main() {
    memset(G, 0, sizeof G);
    int V, E;
    cin &gt;&gt; V&gt;&gt;E;
    memset(G, NULL, MAX_V);
    for (int i = 0; i &lt; E; ++i) {
        int desde, hasta, peso;
        cin &gt;&gt; desde&gt;&gt;hasta;
        cin&gt;&gt;peso;
        G[desde][hasta] = peso;
        G[hasta][desde] = peso;
    }
    for (int i = 0; i &lt; V; ++i) {
        for (int j = 0; j &lt; V; ++j) {
            cout &lt;&lt; G[i][j] &lt;&lt; &quot;\t&quot;;
        }
        cout &lt;&lt; endl;
    }
    return 0;
}
</cpp>
  <py>from sys import stdin, stdout
rl = stdin.readline
wr = stdout.write

V, E = rl().strip().split()
V, E = int(V), int(E)

G = [[-1 for x in range(V)] for x in range(V)]
for i in range(V):
    G[i][i] = 0

for i in range(E):
    desde, hasta, peso = rl().strip().split()
    desde, hasta, peso = int(desde), int(hasta), int(peso)
    G[desde][hasta] = peso
    G[hasta][desde] = peso

for i in range(V):
    for j in range(V):
        if G[i][j] == -1:
            wr(f&#39;inf\t&#39;)
        else:
            wr(f&#39;{G[i][j]}\t&#39;)
    wr(&#39;\n&#39;)
</py>
  <orden>8</orden>
  <suborden>0</suborden>
  <fecha_creacion>2020-12-05 00:45:45</fecha_creacion>
  <fecha_modificacion>2020-12-06 20:30:43</fecha_modificacion>
</row>
<row>
  <ID>131</ID>
  <supergrupo>Grafos </supergrupo>
  <tema>Lista de adyacencia</tema>
  <texto>En teoría de grafos, una lista de adyacencia es una representación de todas las aristas o arcos de un grafo mediante una lista.
Si el grafo es no dirigido, cada entrada es un conjunto o multiconjunto de dos vértices conteniendo los dos extremos de la arista correspondiente. Si el grafo es dirigido, cada entrada es una tupla de dos nodos, uno denotando el nodo fuente y el otro denotando el nodo destino del arco correspondiente.
Típicamente, las listas de adyacentes no son ordenadas.
</texto>
  <complejidad_tiempo>Mejor caso :    O(n)  Peor caso : O(n)  Promedio: O(n) </complejidad_tiempo>
  <java>//Implementación java de una lista de adyacencia
import java.util.ArrayList;
import java.util.List;
import java.util.Scanner;


import java.util.ArrayList;
import java.util.List;
import java.util.Scanner;

public class Main {
    static Vertex[] G;
    static Scanner sc = new Scanner(System.in);

    public static void main(String[] args) {
        int V = sc.nextInt(), E = sc.nextInt();
        G = new Vertex[V];
        for (int i = 0; i &lt; V; i++) {
            G[i] = new Vertex();
            G[i].adj = new ArrayList&lt;&gt;();
        }
        for (int i = 0; i &lt; E; i++) {
            int aux1, aux2, aux3;
            aux1 = sc.nextInt();
            aux2 = sc.nextInt();
            aux3 = sc.nextInt();
            //Dirigido
            G[aux1].adj.add(new Edge(aux2, aux3));
            //Descomentar para no dirigido
            //G[aux2].adj.add(new Edge(aux1, aux3));
        }
        for (int i = 0; i &lt; G.length; i++) {
            System.out.print(i+&quot;-&gt;&quot; );
            for (Edge e : G[i].adj) {
                System.out.print(e.to + &quot; &quot; + e.w+&quot;|&quot;);
            }
            System.out.println(&quot;&quot;);
        }
    }

    static class Vertex {
        List&lt;Edge&gt; adj;
        public Vertex() {
            adj = new ArrayList&lt;&gt;();
        }
    }

    static class Edge {
        int to, w;
        public Edge(int to, int w) {
            this.to = to;
            this.w = w;
        }
    }
}
</java>
  <cpp>#include&lt;bits/stdc++.h&gt;
#include&lt;cstdlib&gt;
#define MAX_V 101

using namespace std;

struct Edge {
    int to = 0, w = 0;

    Edge(int _to, int _w) {
        to = _to;
        w = _w;
    }
};

struct Vertex {
    list &lt;Edge&gt; adj;
};

static Vertex G[MAX_V];

int main(int argc, char *argv[]) {
    memset(G, 0, sizeof G);
    int V, E;
    scanf(&quot;%i %i&quot;, &amp;V, &amp;E);
    Vertex G [V];
    for (int i = 0; i &lt; V; i++) {
        G[i] = Vertex();
        G[i].adj;
    }
    for (int i = 0; i &lt; E; i++) {
        int desde, hasta, peso;
        scanf(&quot;%i %i %i&quot;, &amp;desde, &amp;hasta, &amp;peso);
        G[desde].adj.push_back(Edge(hasta, peso));
        G[hasta].adj.push_back(Edge(desde, hasta));
    }
    int size = sizeof (G) / sizeof (G[0]);
    for (int i = 0; i &lt; size; i++) {
        cout &lt;&lt; i &lt;&lt; &quot;-&gt; &quot;;
        for (Edge e : G[i].adj) {
            cout &lt;&lt; e.to &lt;&lt; &quot; &quot; &lt;&lt; e.w &lt;&lt; &quot;|&quot;;
        }
        cout &lt;&lt; &quot;&quot; &lt;&lt; endl;
    }
    return 0;
}
</cpp>
  <py>null</py>
  <orden>8</orden>
  <suborden>1</suborden>
  <fecha_creacion>2020-12-05 00:45:45</fecha_creacion>
  <fecha_modificacion>2020-12-06 20:30:44</fecha_modificacion>
</row>
<row>
  <ID>132</ID>
  <supergrupo>Grafos </supergrupo>
  <tema>DFS (Depth First Search)</tema>
  <texto>Una Búsqueda en profundidad (en inglés DFS o Depth First Search) es un algoritmo de búsqueda no informada utilizado para recorrer todos los nodos de un grafo o árbol (teoría de grafos) de manera ordenada, pero no uniforme. Su funcionamiento consiste en ir expandiendo todos y cada uno de los nodos que va localizando, de forma recurrente, en un camino concreto. Cuando ya no quedan más nodos que visitar en dicho camino, regresa (Backtracking), de modo que repite el mismo proceso con cada uno de los hermanos del nodo ya procesado.
Completitud: DFS es completo si y solo si usamos búsqueda basada en grafos en espacios de estado finitos, pues todos los nodos serán expandidos.
Optimalidad: DFS en ningún caso asegura la optimalidad, pues puede encontrar una solución más profunda que otra en una rama que todavía no ha sido expandida.
Complejidad temporal: en el peor caso, O(b^m) siendo b el factor de ramificación (número promedio de ramificaciones por nodo) y m la máxima profundidad del espacio de estados.
Complejidad espacial: O(b^d) siendo b el factor de ramificación y d la profundidad de la solución menos costosa, pues cada nodo generado permanece en memoria, almacenándose la mayor cantidad de nodos en el nivel meta.
</texto>
  <complejidad_tiempo>Mejor caso :    O(|v|+|e|)  Peor caso : O(|v|+|e|)  Promedio: O(|v|+|e|) </complejidad_tiempo>
  <java>// Programa java que imprime DFS transverso en un grafo

import java.util.*;

public class DFS {

    public static void main(String args[]) {
        Graph g = new Graph(4);
        g.addEdge(0, 1);
        g.addEdge(0, 2);
        g.addEdge(1, 2);
        g.addEdge(2, 0);
        g.addEdge(2, 3);
        g.addEdge(3, 3);
        System.out.println(&quot;Siguiendo la primera busqueda en profundidad &quot;
                + &quot;(iniciando desde vertice  2)&quot;);
        g.DFS(2);
    }

    static class Graph {
        private int V;  // número de vertices 
        // Array de listas de adyacencia
        private LinkedList&lt;Integer&gt; adj[];
        Graph(int v) {
            V = v;
            adj = new LinkedList[v];
            for (int i = 0; i &lt; v; ++i) {
                adj[i] = new LinkedList();
            }
        }
        //Agregando caminos
        void addEdge(int v, int w) {
            adj[v].add(w);
        }
        void DFSUtil(int v, boolean visited[]) {
            // Marca el nodo actual como visitado y lo imprime
            visited[v] = true;
            System.out.print(v + &quot; &quot;);
            // Recorre todos los vertices adyacentes a este vertice
            Iterator&lt;Integer&gt; i = adj[v].listIterator();
            while (i.hasNext()) {
                int n = i.next();
                if (!visited[n]) {
                    DFSUtil(n, visited);
                }
            }
        }
        void DFS(int v) {
            //Marca todos los vertices como no visitados (Falso)
            boolean visited[] = new boolean[V];
            DFSUtil(v, visited);
        }

    }
}
</java>
  <cpp>null</cpp>
  <py>class Grafo:
    V = 0
    adj = [[], [], [], [], [], []]
    def addEdge(self, v, w):
        self.adj[v].append(w)
    def DFSUtil(self, v, visited=[]):
        visited[v] = True
        print(v, &quot; &quot;)
        for i in range(len(self.adj[v])):
            n = self.adj[v][i]
            if not visited[n]:
                self.DFSUtil(n, visited)
    def DFS(self, v):
        visited = [False, False, False, False, False, False]
        self.DFSUtil(v, visited)

g = Grafo()
g.V = 4
g.addEdge(0, 1)
g.addEdge(0, 2)
g.addEdge(1, 2)
g.addEdge(2, 0)
g.addEdge(2, 3)
g.addEdge(3, 3)
inicial = 0
print(&quot;Nodo inicial&quot; + str(inicial))
g.DFS(inicial)
</py>
  <orden>8</orden>
  <suborden>2</suborden>
  <fecha_creacion>2020-12-05 00:45:46</fecha_creacion>
  <fecha_modificacion>2020-12-06 20:30:44</fecha_modificacion>
</row>
<row>
  <ID>133</ID>
  <supergrupo>Grafos </supergrupo>
  <tema>BFS (Breath First Search)</tema>
  <texto>Búsqueda en anchura (en inglés BFS - Breadth First Search) es un algoritmo de búsqueda no informada utilizado para recorrer o buscar elementos en un grafo (usado frecuentemente sobre árboles). Intuitivamente, se comienza en la raíz (eligiendo algún nodo como elemento raíz en el caso de un grafo) y se exploran todos los vecinos de este nodo. A continuación para cada uno de los vecinos se exploran sus respectivos vecinos adyacentes, y así hasta que se recorra todo el árbol.
Formalmente, BFS es un algoritmo de búsqueda sin información, que expande y examina todos los nodos de un árbol sistemáticamente para buscar una solución. El algoritmo no usa ninguna estrategia heurística.
- Dado un vértice fuente s, Breadth-first search sistemáticamente explora los vértices de G para “descubrir” todos los vértices alcanzables desde s.
- Calcula la distancia (menor número de vértices) desde s a todos los vértices alcanzables.
- Después produce un árbol BF con raíz en s y que contiene a todos los vértices alcanzables.
- El camino desde dt a cada vértice en este recorrido contiene el mínimo número de vértices. Es el camino más corto medido en número de vértices.
- Su nombre se debe a que expande uniformemente la frontera entre lo descubierto y lo no descubierto. Llega a los nodos de distancia k, sólo tras haber llegado a todos los nodos a distancia k-1.
</texto>
  <complejidad_tiempo>Mejor caso :    O(|v|+|e|)  Peor caso : O(|v|+|e|)  Promedio: O(|v|+|e|) </complejidad_tiempo>
  <java>// Programa java que imprime BFS (Busqueda en anchura) transverso
// desde un vertice (nodo) dado como inicio
// BFS(int s) atraviesa vertices alcanzables desde s 

import java.util.*;
//Esta clase representa un grafo dirigido usando listas de adyacencia

public class BFS {

    public static void main(String args[]) {
        Graph g = new Graph(4);
        g.addEdge(0, 1);
        g.addEdge(0, 2);
        g.addEdge(1, 2);
        g.addEdge(2, 0);
        g.addEdge(2, 3);
        g.addEdge(3, 3);
        System.out.println(&quot;Siguiendo su primera busqueda en anchura transverso&quot;
                + &quot;(iniciando desde el vertice 2)&quot;);
        //Vertice de inicio
        g.BFS(2);
    }

    static class Graph {
        private final int V;   // número de vertices
        private LinkedList&lt;Integer&gt; adj[]; //lista de ayacencia
        // Constructor
        Graph(int v) {
            V = v;
            adj = new LinkedList[v];
            for (int i = 0; i &lt; v; ++i) {
                adj[i] = new LinkedList();
            }
        }
        // funcion que agrega un camino al grafo
        void addEdge(int v, int w) {
            adj[v].add(w);
        }
        void BFS(int s) {
            //Marka todos los verticoes como no visitados (Falso)
            boolean visited[] = new boolean[V];
            //Crea una cola para la BFS
            // Create a queue for BFS 
            LinkedList&lt;Integer&gt; queue = new LinkedList&lt;&gt;();
            //Marca el nodo actual como vistiado y lo encola
            visited[s] = true;
            queue.add(s);
            while (!queue.isEmpty()) {
                //Desencola un vertice de la cola y lo imprime
                s = queue.poll();
                System.out.print(s + &quot; &quot;);
                /* Obtiene todos los vertices adyacentes del 
                vertice desencolado, si un adyacente no ha 
                sido visitado, lo marca lo visita y lo encola*/
                Iterator&lt;Integer&gt; i = adj[s].listIterator();
                while (i.hasNext()) {
                    int n = i.next();
                    if (!visited[n]) {
                        visited[n] = true;
                        queue.add(n);
                    }
                }
            }
        }
    }
}
</java>
  <cpp>#include &lt;bits/stdc++.h&gt;
#define MAX_V 101
using namespace std;
vector&lt;int&gt; adj[MAX_V];
vector&lt;int&gt;que;

struct Graph {
    int V;

    void addEdge(int v, int w) {
        adj[v].push_back(w);
    }

    void BFS(int s) {
        bool visited[V];
        visited[s] = true;
        que.push_back(s);
        while (!que.empty()) {
            s = que.front();
            que.erase(que.begin());
            cout &lt;&lt; s &lt;&lt; &quot; &quot;;
            for (int i = 0; i &lt; adj[s].size(); ++i) {
                int n = adj[s][i];
                if (!visited[n]) {
                    visited[n] = true;
                    que.push_back(n);
                }
            }
        }
    }
};

int main() {
    Graph gra;
    gra.V = 4;
    gra.addEdge(0, 1);
    gra.addEdge(0, 2);
    gra.addEdge(1, 2);
    gra.addEdge(2, 0);
    gra.addEdge(2, 3);
    gra.addEdge(3, 3);
    int initial = 0;
    gra.BFS(initial);
    return 0;
}
</cpp>
  <py>def add_edge(v, w):
    ady[v].append(w)
def bfs(s):
    visited = [[] for i in range (V)]
    queue = []
    visited[s] = True;
    queue.append(s)
    while len(queue) &gt; 0:
        s = queue[0]
        queue = queue[1:]
        print(str(s) + &quot; &quot;)
        aux = ady[s]
        for j in range (len(aux)):
            n = aux[j]
            if(visited[n] != True):
                visited[n] = True
                queue.append(n)
V = 4
ady = [[] for i in range (V)]
add_edge(0, 1)
add_edge(0, 2)
add_edge(1, 2)
add_edge(2, 0)
add_edge(2, 3)
add_edge(3, 3)
print(ady)
bfs(0)

</py>
  <orden>8</orden>
  <suborden>3</suborden>
  <fecha_creacion>2020-12-05 00:45:46</fecha_creacion>
  <fecha_modificacion>2020-12-06 20:30:45</fecha_modificacion>
</row>
<row>
  <ID>134</ID>
  <supergrupo>Grafos </supergrupo>
  <tema>BFS todos los caminos</tema>
  <texto>Utilizando el algoritmo de búsqueda en anchura, y modificándolo se puede realizar la búsqueda de todos los caminos existentes desde un origen hasta un destino, permitiendo también que se impriman los recorridos de estos caminos.</texto>
  <complejidad_tiempo>Mejor caso :    O(|v|+|e|)  Peor caso : O(|v|+|e|)  Promedio: O(|v|+|e|) </complejidad_tiempo>
  <java>//Programa java que imprime todos los caminos
// desde un inicio hasta un destino usando BFS

import java.util.ArrayList;
import java.util.List;
//Un grafo dirigido usando lista de adyacencia

public class BFSAllPaths {
    // Número de vertices
    static int v;
    // lista de adyacencia
    static ArrayList&lt;Integer&gt;[] adjList;
    static void initGraph(int vertices) {
        //Inicializa número de vertices
        v = vertices;
        // inicializa lista de adyacencia
        initAdjList();
    }

    static void initAdjList() {
        adjList = new ArrayList[v];
        for (int i = 0; i &lt; v; i++) {
            adjList[i] = new ArrayList&lt;&gt;();
        }
    }
    //Agrega camino de u a v
    static void addEdge(int u, int v) {
        // Agrega v a la lista de u
        adjList[u].add(v);
    }
    //Imrpime todos los caminos de 
    // &#39;s&#39; a &#39;d&#39; 
    static void printAllPaths(int s, int d) {
        boolean[] isVisited = new boolean[v];
        ArrayList&lt;Integer&gt; pathList = new ArrayList&lt;&gt;();
        //Agrega origen al path[]
        pathList.add(s);
        printAllPathsUtil(s, d, isVisited, pathList);
    }
    /*Función recursiva que imprime 
    Todos los caminos de u a d.
    isVisited[] mantiene rastro de
    los vertices en el camino actual
    localPathList&lt;&gt; almacena vertices actuales
    en el camino actual*/
    static void printAllPathsUtil(Integer u, Integer d,
            boolean[] isVisited,
            List&lt;Integer&gt; localPathList) {
        // Marca el nodo actual
        isVisited[u] = true;
        if (u.equals(d)) {
            System.out.println(localPathList);
            // Si coincidencia encontrada entonces
            // no se necesita atravesar más profundo
            isVisited[u] = false;
            return;
        }
        // Recorre todos los vertices 
        //adyacentes al actual vertice 
        for (Integer i : adjList[u]) {
            if (!isVisited[i]) {
                // Almacena el nodo actual
                // en path[]
                localPathList.add(i);
                printAllPathsUtil(i, d, isVisited, localPathList);
                localPathList.remove(i);
            }
        }
        // Marca el nodo actual
        isVisited[u] = false;
    }

    public static void main(String[] args) {
        //Crea el grafo
        initGraph(4);
        //camino desde hasta
        addEdge(0, 1);
        addEdge(0, 2);
        addEdge(0, 3);
        addEdge(2, 0);
        addEdge(2, 1);
        addEdge(1, 3);
        // inicio arbitrario
        int s = 0;
        // destino arbitrario
        int d = 3;
        System.out.println(&quot;Los siguientes son todos los diferentes&quot;
                + &quot;caminos de &quot; + s + &quot; a &quot; + d);
        printAllPaths(s, d);
    }
}
</java>
  <cpp>#include &lt;bits/stdc++.h&gt;
using namespace std;

// función de utilidad para impresion
// encontrando todos los caminos
void printpath(vector&lt;int&gt;&amp; path) {
    int size = path.size();
    for (int i = 0; i &lt; size; i++)
        cout &lt;&lt; path[i] &lt;&lt; &quot; &quot;;
    cout &lt;&lt; endl;
}
// Funcion para revisar si el vertice actual
// ya se encuentra presente en el camino
int isNotVisited(int x, vector&lt;int&gt;&amp; path) {
    int size = path.size();
    for (int i = 0; i &lt; size; i++)
        if (path[i] == x)
            return 0;
    return 1;
}
// Funcion de utilidad para encontrar los caminos dentro de un grafo
// desde el inicio hasta el fin dado
void findpaths(vector&lt;vector&lt;int&gt;&gt; &amp;g, int inicio, int destino, int v) {
    // Crear una cola que almacena los caminos
    queue&lt;vector&lt;int&gt;&gt; q;
    // vector de caminos que almacena el camino actual
    vector&lt;int&gt; path;
    path.push_back(inicio);
    q.push(path);
    while (!q.empty()) {
        path = q.front();
        q.pop();
        int last = path[path.size() - 1];
        // Si el ultimo vertice es el destino deseado
        // entonces se imprime el camino
        if (last == destino)
            printpath(path);
        // Atravesar a todos los nodos conectados al vÃ©rtice actual
        // y empujar una nueva ruta a la cola
        for (int i = 0; i &lt; g[last].size(); i++) {
            if (isNotVisited(g[last][i], path)) {
                vector&lt;int&gt; newpath(path);
                newpath.push_back(g[last][i]);
                q.push(newpath);
            }
        }
    }
}

int main() {
    vector&lt;vector&lt;int&gt;&gt; g;
    // Numero de vertices
    int v = 4;
    g.resize(4);
    // Contruccion del grafo
    g[0].push_back(3);
    g[0].push_back(1);
    g[0].push_back(2);
    g[1].push_back(3);
    g[2].push_back(0);
    g[2].push_back(1);
    //inicio y destino
    int inicio = 2, destino = 3;
    cout &lt;&lt; &quot;Los caminos desde &quot; &lt;&lt; inicio
            &lt;&lt; &quot; hasta &quot; &lt;&lt; destino &lt;&lt; &quot; son \n&quot;;
    // Llamada a la funcion que permitirá¡ encontrar los caminos
    // recibiendo como parametros la matriz de caminos, el inicio, el
    // y la cantidad de vertices
    findpaths(g, inicio, destino, v);
    return 0;
}
</cpp>
  <py>from collections import defaultdict
 
class Graph: 
    def __init__(self, vertices): 
        self.V = vertices  
        self.graph = defaultdict(list)   
    def addEdge(self, u, v): 
        self.graph[u].append(v) 
    def printAllPathsUtil(self, u, d, visited, path): 
        visited[u] = True
        path.append(u)  
        if u == d: 
            print path 
        else: 
            for i in self.graph[u]: 
                if visited[i] == False: 
                    self.printAllPathsUtil(i, d, visited, path) 
        path.pop() 
        visited[u] = False

    def printAllPaths(self, s, d): 
        visited = [False] * (self.V)  
        path = [] 
        self.printAllPathsUtil(s, d, visited, path) 
g = Graph(4) 
g.addEdge(0, 1) 
g.addEdge(0, 2) 
g.addEdge(0, 3) 
g.addEdge(2, 0) 
g.addEdge(2, 1) 
g.addEdge(1, 3) 
s = 2 ; d = 3
print (&quot;Siguiendo los diferentes caminos desde %d a %d :&quot; %(s, d)) 
g.printAllPaths(s, d) 
</py>
  <orden>8</orden>
  <suborden>4</suborden>
  <fecha_creacion>2020-12-05 00:45:46</fecha_creacion>
  <fecha_modificacion>2020-12-06 20:30:46</fecha_modificacion>
</row>
<row>
  <ID>135</ID>
  <supergrupo>Grafos </supergrupo>
  <tema>Domino DFS</tema>
  <texto>El efecto dominó o reacción en cadena es el efecto acumulativo producido cuando un acontecimiento origina una cadena de otros acontecimientos similares.
Se produce cuando un pequeño cambio origina un cambio similar a su lado, que a su vez causa otro similar, y así sucesivamente en una secuencia lineal. Recibe este nombre, por analogía con la caída de una hilera de fichas de dominó colocadas en posición vertical. El efecto dominó también puede hacer referencia a una cadena de acontecimientos no materiales.
El término, en sus distintos usos, se ha hecho popular por su analogía al efecto mecánico, una fila de fichas de dominó al caer una ficha detrás de otra, aunque típicamente se refiere a una secuencia enlazada de acontecimientos donde el tiempo entre acontecimientos sucesivos es relativamente pequeño. 
</texto>
  <complejidad_tiempo>Mejor caso :    O(|v|+|e|)  Peor caso : O(|v|+|e|)  Promedio: O(|v|+|e|) </complejidad_tiempo>
  <java>//Programa java que usando DFS busca cuantos dominos
// caen desde un origen

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Scanner;

/* EJEMPLO DE INGRESO
9 6 3
1 2
2 5
5 3
4 3
6 7
7 8
1
6
4*/
public class DominoDFS {
    static final int MAX = 10001;
    static ArrayList&lt;ArrayList&lt;Integer&gt;&gt; ady
            = new ArrayList&lt;ArrayList&lt;Integer&gt;&gt;(MAX);
    static Scanner sc = new Scanner(System.in);
    //la cantidad total de dominos que caerán
    static int total;
    //arreglo de domino caido
    static boolean visitado[] = new boolean[MAX];

    public static void main(String[] args) {
        //número de dominos, cantidad de enlaces, consultas
        int V, M, Q, x, y, origen;
        V = sc.nextInt();
        M = sc.nextInt();
        Q = sc.nextInt();
        for (int i = 0; i &lt; V; i++) {
            ady.add(new ArrayList&lt;&gt;());
        }
        while (M &gt; 0) {
            //domino x hace caer a domino y
            x = sc.nextInt();
            y = sc.nextInt();
            ady.get(x).add(y);
            M--;
        }
        while (Q &gt; 0) {
            //domino origen
            origen = sc.nextInt();
            total = 0;
            Arrays.fill(visitado, false);
            dfs(origen);
            System.out.printf(&quot;%d\n&quot;, total);
            Q--;
        }

    }

    static void dfs(int u) { //domino origen
        //aumento en mi respuesta la caida de un domino
        total++;
        //domino &quot;u&quot; cayo
        visitado[u] = true;
        //verifico los demás posibles 
        //domino que caeran si impulso &quot;u&quot;
        for (int v = 0; v &lt; ady.get(u).size(); ++v) {
            //si el domino adyacente no 
            //cayó entonces es elsiguiente a evaluar
            if (!visitado[ady.get(u).get(v)]) {
                //recursivamente veo que dominos 
                //caeran a partir del adyacente de &quot;u&quot;
                dfs(ady.get(u).get(v));
            }
        }
    }
}
</java>
  <cpp>#include&lt;bits/stdc++.h&gt;
#define MAX 10001
using namespace std;
vector &lt;vector&lt;int&gt; &gt;ady(MAX);
int total = 0;
bool visited[MAX];

void DFS(int u) {
    total++;
    visited[u] = true;
    for (int v = 0; v &lt; ady[u].size(); v++) {
        if (!visited[ady[u][v]]) {
            DFS(ady[u][v]);
        }
    }
}

int main() {
    int dominos, caminos, busquedas, desde, hasta, origen;
    cin&gt;&gt;dominos;
    cin&gt;&gt;caminos;
    cin&gt;&gt;busquedas;
    while (caminos &gt; 0) {
        cin &gt;&gt; desde&gt;&gt;hasta;
        ady[desde].push_back(hasta);
        caminos--;
    }
    while (busquedas) {
        cin&gt;&gt;origen;
        total = 0;
        memset(visited, 0, sizeof visited);
        DFS(origen);
        cout &lt;&lt; &quot;Dominos tumbados : &quot; &lt;&lt; total &lt;&lt; endl;
        busquedas--;
    }
    return 0;
}
</cpp>
  <py>null</py>
  <orden>8</orden>
  <suborden>5</suborden>
  <fecha_creacion>2020-12-05 00:45:47</fecha_creacion>
  <fecha_modificacion>2020-12-06 20:30:46</fecha_modificacion>
</row>
<row>
  <ID>136</ID>
  <supergrupo>Grafos </supergrupo>
  <tema>Laberintos BFS</tema>
  <texto>Un laberinto es un pasatiempo gráfico consistente en trazar una línea desde un punto de origen situado en el exterior de un laberinto a uno de destino situado generalmente en el centro o bien en el lado opuesto. La dificultad consiste en encontrar un camino directo hasta el lugar deseado. El laberinto, por su propia configuración, contiene diferentes vías sin salida (de mayor o menor longitud) y solo un recorrido correcto.</texto>
  <complejidad_tiempo>Mejor caso :    O(|v|+|e|)  Peor caso : O(|v|+|e|)  Promedio: O(|v|+|e|) </complejidad_tiempo>
  <java>// Programa java que realiza laberintos con BFS

import java.util.Arrays;
import java.util.LinkedList;
import java.util.Queue;
import java.util.Scanner;

public class ExitTheMazeBFS {

    /* Ejemplo de ingreso
8 8
.......I
.#######
.#......
.#.S...S
.###.#.#
.#...#.#
.#.###.#
........
     */
    //máximo número de filas y columnas del laberinto
    static final int MAX = 100;
    static Scanner sc = new Scanner(System.in);
    //laberinto
    static char ady[][] = new char[MAX][MAX];
    //arreglo de estados visitados
    static boolean visitado[][] = new boolean[MAX][MAX];
    //incremento en coordenada x
    static int dx[] = {0, 0, 1, -1};
    //incremento en coordanada y
    static int dy[] = {1, -1, 0, 0};
    //altura y ancho del laberinto
    static int h, w;
    //Arreglo para mostrar la ruta que se siguio
    static Estado prev[][] = new Estado[MAX][MAX];

    static class Estado {
        int x; // Fila del estado
        int y; // Columna del estado
        int d; // Distancia del estado
        // Constructor
        Estado(int x1, int y1, int d1) {
            this.x = x1;
            this.y = y1;
            this.d = d1;
        }

        Estado() {
        }
    }

    public static void main(String[] args) {
        int x = 0, y = 0;
        System.out.println(&quot;Ingrese altura del laberinto: &quot;);
        h = sc.nextInt();
        System.out.println(&quot;Ingrese ancho del laberinto: &quot;);
        w = sc.nextInt();
        sc.nextLine();
        System.out.printf(&quot;\nIngrese el laberinto, con un solo &quot;
                + &quot;valor inicial I, valor final sera S: \n&quot;);
        for (int i = 0; i &lt; h; ++i) {
            String aux = sc.nextLine();
            for (int j = 0; j &lt; w; ++j) {
                ady[i][j] = aux.charAt(j);
                //obtengo coordenada de valor inicial
                if (ady[i][j] == &#39;I&#39;) {
                    x = i;
                    y = j;
                }
            }
        }
        //MOSTRAMOS LABERINTO
        for (int i = 0; i &lt; h; ++i) {
            for (int j = 0; j &lt; w; ++j) {
                System.out.printf(&quot;%c&quot;, ady[i][j]);
            }
            System.out.printf(&quot;\n&quot;);
        }
        int min = BFS(x, y, h, w);
        if (min != -1) {
            System.out.printf(&quot;Menor número de pasos: %d\n&quot;, min);
        } else {
            System.out.println(&quot;No se pudo llegar al destino&quot;);
        }

    }
    //Funcion para imprimir la ruta encontrada
    //Ingresan las coordenadas del nodo final
    static void print(int x, int y) {
        //El arreglo prev posee las coordenadas del nodo 
        //anterior, por ello empezamos desde el final
        //El proceso termina al momento de preguntar 
        //por el anterior del nodo inicial, como pusimos -1
        //Preguntamos hasta que nuestro anterior sea diferente de -1
        for (int i = x, j = y; prev[i][j].d != -1; i
                = prev[x][y].x, j = prev[x][y].y) {
            ady[i][j] = &#39;*&#39;;
            x = i;
            y = j;
        }

        System.out.printf(&quot;Camino con menor número de pasos\n&quot;);
        for (int i = 0; i &lt; h; ++i) {
            for (int j = 0; j &lt; w; ++j) {
                System.out.printf(&quot;%c&quot;, ady[i][j]);
            }
            System.out.printf(&quot;\n&quot;);
        }
    }
    //coordenadas de inicial &quot;I&quot; y dimensiones de laberinto
    static int BFS(int x, int y, int h, int w) {
        //Estado inicial, distancia = 0
        Estado inicial = new Estado(x, y, 0);
        //Cola de todos los posibles Estados por
        //los que se pase para llegar al destino
        Queue&lt;Estado&gt; Q = new LinkedList&lt;&gt;();
        //Insertamos el estado inicial en la Cola.
        //marcamos como no visitado
        Q.offer(inicial);
        for (int i = 0; i &lt; MAX; i++) {
            Arrays.fill(visitado[i], false);
        }
        //el inicial no tiene una ruta anterior puesto que es  primero
        prev[x][y] = new Estado(-1, -1, -1);
        //Mientras cola no este vacia
        while (!Q.isEmpty()) {
            //Obtengo de la cola el estado actual, 
            //en un comienzo será el inicial
            Estado actual = Q.peek();
            //Saco el elemento de la cola
            Q.poll();
            //Si se llego al destino (punto final)
            if (ady[actual.x][actual.y] == &#39;S&#39;) {
                //imprimo la ruta del camino más corto
                print(actual.x, actual.y);
                //Retornamos distancia recorrida hasta ese momento
                return actual.d;
            }
            //Marco como visitado dicho estado para no volver a recorrerlo
            visitado[actual.x][actual.y] = true;
            //Recorremos hasta 4 porque tenemos 4 posibles adyacentes
            for (int i = 0; i &lt; 4; ++i) {
                //nx y ny tendran la coordenada adyacente
                int nx = dx[i] + actual.x;
                //ejemplo en i=0 y actual 
                //(3,4) -&gt; 3+dx[0]=3+0=3, 
                //4+dy[0]=4+1=5, nueva coordenada (3,5)
                int ny = dy[i] + actual.y;
                //aqui comprobamos que la coordenada 
                //adyacente no sobrepase las dimensiones del laberinto
                //además comprobamos que no sea 
                //pared &quot;#&quot; y no este visitado
                if (nx &gt;= 0 &amp;&amp; nx &lt; h &amp;&amp; ny &gt;= 0
                        &amp;&amp; ny &lt; w &amp;&amp; ady[nx][ny] != &#39;#&#39; &amp;&amp; !visitado[nx][ny]) {
                    //Creamos estado adyacente aumento en 
                    //1 la distancia recorrida
                    Estado adyacente = new Estado(nx, ny, actual.d + 1);
                    //Agregamos adyacente a la cola
                    Q.offer(adyacente);
                    //El previo del nuevo nodo es el actual.
                    prev[nx][ny] = actual;
                }
            }
        }
        return -1;
    }
}
</java>
  <cpp>#include&lt;bits/stdc++.h&gt;
#define MAX 100
using namespace std;

struct Estado {
    int x;
    int y;
    int d;
};
char ady[MAX][MAX];
bool visited[MAX][MAX];
int dx[] = {0, 0, 1, -1};
int dy[] = {1, -1, 0, 0};
int h, w;
Estado prev[MAX][MAX];

void print(int x, int y) {
    for (int i = x, j = y; prev[i][j].d != -1; i = prev[x][y].x, j = prev[x][y].y) {
        ady[i][j] = &#39;*&#39;;
        x = i;
        y = j;
    }
    cout &lt;&lt; &quot;camino con menor pasos&quot; &lt;&lt; endl;
    for (int i = 0; i &lt; h; i++) {
        for (int j = 0; j &lt; w; j++) {
            cout &lt;&lt; ady[i][j];
        }
        cout &lt;&lt; endl;
    }
}

int BFS(int x, int y, int h, int w) {
    Estado inicial;
    inicial.x = x;
    inicial.y = y;
    inicial.d = 0;
    queue&lt;Estado&gt; Q;
    Q.push(inicial);
    for (int i = 0; i &lt; MAX; ++i) {
        memset(visited[i], false, sizeof visited[i]);
    }
    Estado nuevo;
    nuevo.x = -1;
    nuevo.y = -1;
    nuevo.d = -1;
    prev[x][y] = nuevo;
    while (!Q.empty()) {
        Estado actual = Q.front();
        Q.pop();
        if (ady[actual.x][actual.y] == &#39;S&#39;) {
            print(actual.x, actual.y);
            return actual.d;
        }
        visited[actual.x][actual.y] = true;
        for (int i = 0; i &lt; 4; i++) {
            int nx = dx[i] + actual.x;
            int ny = dy[i] + actual.y;
            if (nx &gt;= 0 &amp;&amp; nx &lt; h &amp;&amp; ny &gt;= 0 &amp;&amp; ny &lt; w &amp;&amp; ady[nx][ny] != &#39;#&#39; &amp;&amp; !visited[nx][ny]) {
                Estado adyacente;
                adyacente.x = nx;
                adyacente.y = ny;
                adyacente.d = actual.d + 1;
                Q.push(adyacente);
                prev[nx][ny] = actual;
            }
        }
    }
    return -1;
}

int main() {
    int x = 0;
    int y = 0;
    cout &lt;&lt; &quot;altura\n&quot;;
    cin&gt;&gt;h;
    cout &lt;&lt; &quot;ancho\n&quot;;
    cin&gt;&gt;w;
    cin.ignore();
    for (int i = 0; i &lt; h; i++) {
        string aux;
        getline(cin, aux);
        for (int j = 0; j &lt; w; j++) {
            ady[i][j] = aux[j];
            if (ady[i][j] == &#39;I&#39;) {
                x = i;
                y = j;
            }
        }
    }
    for (int i = 0; i &lt; h; i++) {
        for (int j = 0; j &lt; w; j++) {
            cout &lt;&lt; ady[i][j];
        }
        cout &lt;&lt; endl;
    }
    int mini = BFS(x, y, h, w);
    if (mini != -1) {
        cout &lt;&lt; &quot;El menor numero de pasos es &quot; &lt;&lt; mini;
    } else {
        cout &lt;&lt; &quot;No se pudo llegar&quot;;
    }
    return 0;
}
</cpp>
  <py>null</py>
  <orden>8</orden>
  <suborden>6</suborden>
  <fecha_creacion>2020-12-05 00:45:47</fecha_creacion>
  <fecha_modificacion>2020-12-06 20:30:47</fecha_modificacion>
</row>
<row>
  <ID>137</ID>
  <supergrupo>Grafos </supergrupo>
  <tema>15.8) Conteo de caminos DFS</tema>
  <texto>Cuente el número total de caminos o vías que existen entre dos vértices en un grafo dirigido, estos caminos no contienen un ciclo, la simple razón de esto es que un ciclo contiene infinito número de caminos y esto crea problema.
El problema puede ser resuelto usando backtracking, esto es si tomamos un camino y empezamos a andar por él, si nos lleva al vértice de destino entonces contamos el camino y nos devolvemos a tomar otro camino, si el camino no nos lleva al vértice destino, descartamos este camino.
</texto>
  <complejidad_tiempo>Mejor caso :    O(|v|+|e|)  Peor caso : O(|v|+|e|)  Promedio: O(|v|+|e|) </complejidad_tiempo>
  <java>// Programa java que cuenta todos los caminos de un
// inicio a un destino. 

import java.util.Arrays;
import java.util.Iterator;
import java.util.LinkedList;

public class CountAllPaths {

    public static void main(String args[]) {
        Graph g = new Graph(4);
        g.addEdge(0, 1);
        g.addEdge(0, 2);
        g.addEdge(0, 3);
        g.addEdge(2, 0);
        g.addEdge(2, 1);
        g.addEdge(1, 3);
         //Origen - destino
        int s = 2, d = 3;
        System.out.println(g.countPaths(s, d));
    }

    static class Graph {
        // Número de vertices
        private int V;
        // array de listas de adyacencia
        private LinkedList&lt;Integer&gt; adj[];
        Graph(int v) {
            V = v;
            adj = new LinkedList[v];
            for (int i = 0; i &lt; v; ++i) {
                adj[i] = new LinkedList&lt;&gt;();
            }
        }
        //agrgar caminos en un grafo
        void addEdge(int v, int w) {
            //agrega w a las listas de v
            adj[v].add(w);
        }
        // Un metodo recursivo que cuenta
        // todos los caminos de u a d 
        int countPathsUtil(int u, int d,
                boolean visited[],
                int pathCount) {
            //Marca el nodo actual como visitado
            //y lo imprime
            visited[u] = true;
            // Si el vertice actual es igual
            // al destino, incrementa el conteo
            if (u == d) {
                pathCount++;
            } // Recore todos los vertices  
            // adyacentes a este vertice
            else {
                Iterator&lt;Integer&gt; i = adj[u].listIterator();
                while (i.hasNext()) {
                    int n = i.next();
                    if (!visited[n]) {
                        pathCount = countPathsUtil(n, d,
                                visited,
                                pathCount);
                    }
                }
            }
            visited[u] = false;
            return pathCount;
        }
        // Retorna conteo de caminos desde s a d
        int countPaths(int s, int d) {
            //Marca todos los vertices como no visitados
            boolean visited[] = new boolean[V];
            Arrays.fill(visited, false);
            int pathCount = 0;
            pathCount = countPathsUtil(s, d,
                    visited,
                    pathCount);
            return pathCount;
        }
    }
}
</java>
  <cpp>#include&lt;bits/stdc++.h&gt;
#define MAX 101
using namespace std;
vector&lt;int&gt; adj[MAX];

struct Graph {
    int V;

    void addEdge(int v, int w) {
        adj[v].push_back(w);
    }

    int countPathsUtil(int u, int d, bool visited[], int pathCount) {
        visited[u] = true;
        if (u == d) {
            pathCount++;
        } else {
            for (int i = 0; i &lt; adj[u].size(); i++) {
                int n = adj[u][i];
                if (!visited[n]) {
                    pathCount = countPathsUtil(n, d, visited, pathCount);
                }
            }
        }
        visited[u] = false;
        return pathCount;
    }

    int countPaths(int s, int d) {
        bool visited[V];
        memset(visited, false, sizeof visited);
        int pathcount = 0;
        pathcount = countPathsUtil(s, d, visited, pathcount);
        return pathcount;
    }
};

int main() {
    Graph g;
    g.V = 4;
    g.addEdge(0, 1);
    g.addEdge(0, 2);
    g.addEdge(0, 3);
    g.addEdge(2, 0);
    g.addEdge(2, 1);
    g.addEdge(1, 3);
    int s = 2, d = 3;
    cout &lt;&lt; g.countPaths(s, d);
    return 0;
}
</cpp>
  <py>null</py>
  <orden>8</orden>
  <suborden>7</suborden>
  <fecha_creacion>2020-12-05 00:45:47</fecha_creacion>
  <fecha_modificacion>2020-12-06 20:30:48</fecha_modificacion>
</row>
<row>
  <ID>138</ID>
  <supergrupo>Grafos </supergrupo>
  <tema>Ciclo en un grafo dirigido</tema>
  <texto>Dado un grafo dirigido, verificar si el grafo contiene un ciclo o no, la función debe retornar true si el grafo dado contiene al menos un ciclo, de lo contrario retorne false.
DFS puede ser usado para detectar un ciclo en un grafo, DFS para un grafo conectado produce un árbol, hay un ciclo en un grafo solo si hay un camino de regreso presente en el grafo. Un camino de regreso es un camino de un nodo a sí mismo, o uno de sus antecesores en el árbol producido por el DFS.
Para un grafo desconexo, tenemos el bosque DFS como salida, para detectar un ciclo, podemos verificar los arboles individuales en búsqueda de caminos de regreso.
Para detectar un camino de regreso, podemos rastrear los vértices actuales en una pila de recursión de la función de DFS transverso, si llegamos a un vértice que ya está en la pila de recursión entonces hay un ciclo en el árbol, el camino que conecta el vértice actual a un vértice en la pila recursión es el camino de regreso, Usamos recStack[] para mantener rastreado los vértices de la pila de recursión.
La complejidad de tiempo de este método es la misma complejidad de tiempo de un DFS transverso la cual es  O(V+E) siendo V la cantidad de vértices y E la cantidad de caminos.
</texto>
  <complejidad_tiempo>Mejor caso :    O(|v|+|e|)  Peor caso : O(|v|+|e|)  Promedio: O(|v|+|e|) </complejidad_tiempo>
  <java>// Programa java que detecta ciclo en un grafo

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;

public class CycleInADirectedGraph {

    static class Graph {
        private final int V;
        private final List&lt;List&lt;Integer&gt;&gt; adj;
        public Graph(int V) {
            this.V = V;
            adj = new ArrayList&lt;&gt;(V);
            for (int i = 0; i &lt; V; i++) {
                adj.add(new LinkedList&lt;&gt;());
            }
        }
        private boolean isCyclicUtil(int i, boolean[] visited,
                boolean[] recStack) {
            /* Marca el nodo actual como visitado 
            y parte de la pila de recursión*/
            if (recStack[i]) {
                return true;
            }
            if (visited[i]) {
                return false;
            }
            visited[i] = true;
            recStack[i] = true;
            List&lt;Integer&gt; children = adj.get(i);
//funcion lambda
if (children.stream().anyMatch((c) -&gt; (isCyclicUtil(c, visited, recStack)))) {
                return true;
            }
//  for (Integer c: children) 
//  if (isCyclicUtil(c, visited, recStack)) 
//  return true;             recStack[i] = false;
            return false;
        }
        private void addEdge(int source, int dest) {
            adj.get(source).add(dest);
        }
        /* Retorna true si el grafo tiene un ciclo, si no falso*/
        private boolean isCyclic() {
            //Marca todos los vetices como no visitados
            // y no parte de la pila de recursión
            boolean[] visited = new boolean[V];
            boolean[] recStack = new boolean[V];
            for (int i = 0; i &lt; V; i++) {
                if (isCyclicUtil(i, visited, recStack)) {
                    return true;
                }
            }
            return false;
        }

        public static void main(String[] args) {
            Graph graph = new Graph(4);
            graph.addEdge(0, 1);
            graph.addEdge(0, 2);
            graph.addEdge(1, 2);
            graph.addEdge(2, 0);
            graph.addEdge(2, 3);
            graph.addEdge(3, 3);
            if (graph.isCyclic()) {
                System.out.println(&quot;El grafo contiene un ciclo&quot;);
            } else {
                System.out.println(&quot;El grafo no contiene&quot;
                        + &quot;un ciclo&quot;);
            }
        }
    }
}
</java>
  <cpp>#include&lt;bits/stdc++.h&gt;
#define MAX 101
using namespace std;
vector&lt;vector&lt;int&gt; &gt; adj(MAX);

struct Graph {
    int V;

    void addEdge(int source, int dest) {
        adj[source].push_back(dest);
    }

    bool isCycleUtil(int i, bool visited[], bool recStack[]) {
        if (recStack[i]) {
            return true;
        }
        if (visited[i]) {
            return false;
        }
        visited[i] = true;
        recStack[i] = true;
        vector&lt;int&gt; children = adj[i];
        for (int c = 0; c &lt; children.size(); c++) {
            if (isCycleUtil(children[c], visited, recStack)) {
                return true;
            }
        }
        recStack[i] = false;
        return false;
    }

    bool iscyclic() {
        bool visit[V];
        bool recStack[V];
        memset(visit, false, sizeof visit);
        memset(recStack, false, sizeof recStack);
        for (int i = 0; i &lt; V; i++) {
            if (isCycleUtil(i, visit, recStack)) {
                return true;
            }
        }
        return false;
    }
};

int main() {
    Graph g;
    g.V = 4;
    g.addEdge(0, 1);
    g.addEdge(0, 2);
    g.addEdge(1, 2);
    g.addEdge(2, 0);
    g.addEdge(2, 3);
    g.addEdge(3, 3);
    if (g.iscyclic()) {
        cout &lt;&lt; &quot;el grafo SI tiene un ciclo&quot;;
    } else {
        cout &lt;&lt; &quot;el grafo NO tiene un ciclo&quot;;
    }
    return 0;
}
</cpp>
  <py>null</py>
  <orden>8</orden>
  <suborden>8</suborden>
  <fecha_creacion>2020-12-05 00:45:48</fecha_creacion>
  <fecha_modificacion>2020-12-06 20:30:48</fecha_modificacion>
</row>
<row>
  <ID>139</ID>
  <supergrupo>Grafos </supergrupo>
  <tema>DFS Cerramiento transitivo</tema>
  <texto>Dado un grafo dirigido, encontrar si un vértice v es alcanzable desde otro vértice u para todos los pares de vértices (u,v) en el grafo dado, aquí alcanzable significa que existe un camino desde el vértice u a v, la matriz de habilidad de alcance es llamada cerramiento transitivo de un grafo.
La solución está basada en el algoritmo de Floyd Warshall, 
Los pasos abstractos de este algoritmo son:
- Crear una matriz tc[V][V] que pueda tener finalmente el cerramiento transitivo de un grafo dado, inicializar todas sus entradas como 0.
- Llamar DFS por cada nodo del grado para marcar vértices alcanzables en tc[][]. En llamadas recursivas de DFS no podemos llamar DFS para un vértice adyacente si este ya fue marcado como alcanzable en tc[].
El código usa listas de adyacencia para el grafo de entrada y construye una matriz tc[V][V] tal que tc[u][v] será true si v es alcanzable desde u.
</texto>
  <complejidad_tiempo>Mejor caso :    O(|v|+|e|)  Peor caso : O(|v|+|e|)  Promedio: O(|v|+|e|) </complejidad_tiempo>
  <java>//Programa java que imprime el cerramiento transitivo de un grafo

import java.util.ArrayList;
import java.util.Arrays;

public class DFSTransitiveClosure {

    public static void main(String[] args) {
        Graph g = new Graph(4);
        g.addEdge(0, 1);
        g.addEdge(0, 2);
        g.addEdge(1, 2);
        g.addEdge(2, 0);
        g.addEdge(2, 3);
        g.addEdge(3, 3);
        System.out.println(&quot;Matriz de cerramiento transitivo es &quot;);
        g.transitiveClosure();
    }

    static class Graph {
        // número de vertices
        private int vertices;
        // lista de adyacencia 
        private ArrayList&lt;Integer&gt;[] adjList;
        // para almacenar el cerramiento transitivo
        private int[][] tc;
        // Constructor 
        public Graph(int vertices) {
            // inicializa el conteo de vertices
            this.vertices = vertices;
            this.tc = new int[this.vertices][this.vertices];
            // initializa lista de adyacencia
            initAdjList();
        }
        private void initAdjList() {
            adjList = new ArrayList[vertices];
            for (int i = 0; i &lt; vertices; i++) {
                adjList[i] = new ArrayList&lt;&gt;();
            }
        }
        // Agregar caminos
        public void addEdge(int u, int v) {
            adjList[u].add(v);
        }
        // buscando cerramiento transitivo
        public void transitiveClosure() {
            for (int i = 0; i &lt; vertices; i++) {
                dfsUtil(i, i);
            }
            for (int i = 0; i &lt; vertices; i++) {
                System.out.println(Arrays.toString(tc[i]));
            }
        }

        private void dfsUtil(int s, int v) {
            // Marca alcance desde s a v como true
            tc[s][v] = 1;
            // Encuentra todos los vertices alcanzables 
            // atraves de v
            for (int adj : adjList[v]) {
                if (tc[s][adj] == 0) {
                    dfsUtil(s, adj);
                }
            }
        }
    }
}
</java>
  <cpp>null</cpp>
  <py>null</py>
  <orden>8</orden>
  <suborden>9</suborden>
  <fecha_creacion>2020-12-05 00:45:48</fecha_creacion>
  <fecha_modificacion>2020-12-06 20:30:49</fecha_modificacion>
</row>
<row>
  <ID>140</ID>
  <supergrupo>Grafos </supergrupo>
  <tema>BFS para grafos desconexos</tema>
  <texto>Por ejemplo asumamos que todos los vértices son alcanzables desde un vértice inicial, pero en el caso de un grafo desconexo o que cualquier vértice es inalcanzable desde todos los vértices, un BFS normal no nos da la salida deseada, por lo que se utiliza esta modificación del BFS.</texto>
  <complejidad_tiempo>Mejor caso :    O(|v|+|e|)  Peor caso : O(|v|+|e|)  Promedio: O(|v|+|e|) </complejidad_tiempo>
  <java>// Implementación de BFS modificado

import java.util.*;

public class DisconnectedGraphBFS {
    // Implementando grafo usando HashMap 
    static HashMap&lt;Integer, LinkedList&lt;Integer&gt;&gt; graph = new HashMap&lt;&gt;();
    // Agregar caminos al grafo
    public static void addEdge(int a, int b) {
        if (graph.containsKey(a)) {
            LinkedList&lt;Integer&gt; l = graph.get(a);
            l.add(b);
            graph.put(a, l);
        } else {
            LinkedList&lt;Integer&gt; l = new LinkedList&lt;&gt;();
            l.add(b);
            graph.put(a, l);
        }
    }

    public static void bfshelp(int s, ArrayList&lt;Boolean&gt; visited) {
        // Crea una cola para el BFS
        LinkedList&lt;Integer&gt; q = new LinkedList&lt;&gt;();
        //Marca el nodo actual como visitado y lo encola
        q.add(s);
        visited.set(s, true);
        while (!q.isEmpty()) {
            // Desencola un vertice de la cola y la imprime
            int f = q.poll();
            System.out.print(f + &quot; &quot;);
            // Verifica cuando el nodo actual esta conectado
            // a otro nodo o no
            if (graph.containsKey(f)) {
                Iterator&lt;Integer&gt; i = graph.get(f).listIterator();
                // Obtiene todos los nodos adyacentes 
                // del nodo desencolado f, si no ha sido visitado
                // lo marca y lo encola
                while (i.hasNext()) {
                    int n = i.next();
                    if (!visited.get(n)) {
                        visited.set(n, true);
                        q.add(n);
                    }
                }
            }
        }
    }

    //Fución BFS que verifica cada nodo
    public static void bfs(int vertex) {
        ArrayList&lt;Boolean&gt; visited = new ArrayList&lt;&gt;();
        //Marcando cada nodo como no visitado
        for (int i = 0; i &lt; vertex; i++) {
            visited.add(i, false);
        }
        for (int i = 0; i &lt; vertex; i++) {
            //Verificando cuantos nodos no han sido visitados
            if (!visited.get(i)) {
                bfshelp(i, visited);
            }
        }
    }

    public static void main(String[] args) {
        int v = 5;
        addEdge(0, 4);
        addEdge(1, 2);
        addEdge(1, 3);
        addEdge(1, 4);
        addEdge(2, 3);
        addEdge(3, 4);
        bfs(v);
    }
}
</java>
  <cpp>null</cpp>
  <py>null</py>
  <orden>8</orden>
  <suborden>10</suborden>
  <fecha_creacion>2020-12-05 00:45:48</fecha_creacion>
  <fecha_modificacion>2020-12-06 20:30:49</fecha_modificacion>
</row>
<row>
  <ID>141</ID>
  <supergrupo>Grafos </supergrupo>
  <tema>Ciclo de Euler en un grafo dirigido</tema>
  <texto>Un camino de Euler es un camino en un grafo que visita cada camino exactamente una vez, el circuito de Euler es un camino de Euler que empieza y termina en el mismo vértice.
Un grafo es euleriano si tiene un ciclo de Euler.
Un grafo dirigido tiene un ciclo de Euler si las siguientes condiciones son verdad:
1) Todos los vértices con grado no cero pertenecen a una sola componente fuertemente conectada.
2) En los grados, el grado de entrada es igual al grado de salida
Podemos detectar componentes fuertemente conectadas usando el DFS de Kosaraju.
Para comparar los grados de entrada y salida, necesitamos almacenar los grados de entrada y salida de cada vértice, el grado de salida puede ser obtenido por el tamaño de la lista de adyacencia, en grado de entrada puede ser almacenado creando un array de igual tamaño al número de vértices.
La complejidad de tiempo de esta implementación es de O(V+E), luego de correr el algoritmo de Kosaraju, atravesamos todos los vértices y comparamos los grados de salida y entrada, esto toma O(V) tiempo.
</texto>
  <complejidad_tiempo>Mejor caso :    O(|v|+|e|)  Peor caso : O(|v|+|e|)  Promedio: O(|v|+|e|) </complejidad_tiempo>
  <java>// Programa java que verifica si un grafo es Euleriano

import java.util.*;
import java.util.LinkedList;

public class EulerianCycleDirectedGraph {

    public static void main(String[] args) throws java.lang.Exception {
        Graph g = new Graph(5);
        g.addEdge(1, 0);
        g.addEdge(0, 2);
        g.addEdge(2, 1);
        g.addEdge(0, 3);
        g.addEdge(3, 4);
        g.addEdge(4, 0);
        if (g.isEulerianCycle()) {
            System.out.println(&quot;El grafo dado es euleriano &quot;);
        } else {
            System.out.println(&quot;El grafo dado no es euleriano &quot;);
        }
    }

    static class Graph {
        private int V;   // Número de vertices
        private LinkedList&lt;Integer&gt; adj[];//Lista de adyacencia
        private int in[];            //Manteniendo los grados
        //Constructor 
        Graph(int v) {
            V = v;
            adj = new LinkedList[v];
            in = new int[V];
            for (int i = 0; i &lt; v; ++i) {
                adj[i] = new LinkedList();
                in[i] = 0;
            }
        }
        //Agregar caminos 
        void addEdge(int v, int w) {
            adj[v].add(w);
            in[w]++;
        }

        void DFSUtil(int v, Boolean visited[]) {
            // Marca nodo actual como visitado
            visited[v] = true;
            int n;
            //  recorre todos los nodos adyacentes a este vertice 
            Iterator&lt;Integer&gt; i = adj[v].iterator();
            while (i.hasNext()) {
                n = i.next();
                if (!visited[n]) {
                    DFSUtil(n, visited);
                }
            }
        }
        // Retornar el transpuesto de este grafo 
        Graph getTranspose() {
            Graph g = new Graph(V);
            for (int v = 0; v &lt; V; v++) {
                Iterator&lt;Integer&gt; i = adj[v].listIterator();
                while (i.hasNext()) {
                    g.adj[i.next()].add(v);
                    (g.in[v])++;
                }
            }
            return g;
        }
        // Verifica si el grafo esta fuertemente conectado
        Boolean isSC() {
            /*Paso 1: Marca todos los vertices como 
            no visitados (Primer DFS)*/
            Boolean visited[] = new Boolean[V];
            for (int i = 0; i &lt; V; i++) {
                visited[i] = false;
            }
            /* Paso 2: Hace DFS transverso 
            iniciando del primer vertice*/
            DFSUtil(0, visited);
            //  Si DFS no visita todos los nodos, retorna falso 
            for (int i = 0; i &lt; V; i++) {
                if (visited[i] == false) {
                    return false;
                }
            }
            /* Paso 3: Crea un grafo reversado*/
            Graph gr = getTranspose();
            /* Paso 4: marca todos los vertices 
            como no visitados (Segundo dfs)*/
            for (int i = 0; i &lt; V; i++) {
                visited[i] = false;
            }
            /* Paso 5: hacer DFS para el grafo reverso 
            iniciando desde el vertice primero
            debe ser el mismo que el primer DFS*/
            gr.DFSUtil(0, visited);
            // Si todos los vertices no son visitados en el segund
            // DFS retorna falso
            for (int i = 0; i &lt; V; i++) {
                if (visited[i] == false) {
                    return false;
                }
            }
            return true;
        }

        /* Esta función retorna true si encuentra un 
        ciclo de euler, falso si no*/
        Boolean isEulerianCycle() {
            // verifica si todos los vertices con grado no cero
            // viendo si estan conectados
            if (isSC() == false) {
                return false;
            }
            // Verifica si en grado de entrada y 
            // salida cada vertice es igual 
            for (int i = 0; i &lt; V; i++) {
                if (adj[i].size() != in[i]) {
                    return false;
                }
            }
            return true;
        }
    }
}
</java>
  <cpp>#include &lt;bits/stdc++.h&gt;
#define FAST ios_base::sync_with_stdio(false);cin.tie(NULL);

using namespace std;

const int MAX_V = 90;

struct Graph {
    int V;
    vector&lt;int&gt; adj[MAX_V];
    int in[MAX_V];

    Graph(int v) {
        V = v;
        for (int i = 0; i &lt; V; i++) {
            in[i] = 0;
        }
    }

    void addEdge(int source, int destiny) {
        adj[source].push_back(destiny);
        in[destiny]++;
    }

    void DFSUtil(int v, bool visited[]) {
        visited[v] = true;
        int n;
        for (int i = 0; i &lt; adj[v].size(); ++i) {
            n = adj[v][i];
            if (!visited[n]) {
                DFSUtil(n, visited);
            }
        }
    }

    Graph getTranspose() {
        Graph ge(V);
        for (int v = 0; v &lt; V; v++) {
            for (int i : adj[v]) {
                ge.adj[i].push_back(v);
                ge.in[v]++;
            }
        }
        return ge;
    }

    bool isSC() {
        bool visited[V];
        memset(visited, false, V);
        DFSUtil(0, visited);
        for (int i = 0; i &lt; V; i++) {
            if (visited[i] == false) {
                return false;
            }
        }
        Graph gr = getTranspose();
        memset(visited, false, sizeof visited);
        gr.DFSUtil(0, visited);
        for (int i = 0; i &lt; V; i++) {
            if (visited[i] == false) {
                return false;
            }
        }
        return true;
    }

    bool isEulerian() {
        if (isSC() == false) {
            return false;
        }
        for (int i = 0; i &lt; V; i++) {
            if (adj[i].size() != in[i]) {
                return false;
            }
        }
        return true;
    }
};

int main() {
    FAST
            int vertices, caminos;
    cin &gt;&gt; vertices &gt;&gt; caminos;
    Graph g(vertices);
    for (int i = 0; i &lt; caminos; i++) {
        int inicio, destino;
        cin &gt;&gt; inicio &gt;&gt; destino;
        g.addEdge(inicio, destino);
    }
    if (g.isEulerian()) {
        cout &lt;&lt; &quot;El grafo dado es Euleriano&quot; &lt;&lt; endl;
    } else {
        cout &lt;&lt; &quot;El grafo dado no es Euleriano&quot; &lt;&lt; endl;
    }
    return 0;
}
</cpp>
  <py>null</py>
  <orden>8</orden>
  <suborden>11</suborden>
  <fecha_creacion>2020-12-05 00:45:49</fecha_creacion>
  <fecha_modificacion>2020-12-06 20:30:50</fecha_modificacion>
</row>
<row>
  <ID>142</ID>
  <supergrupo>Grafos </supergrupo>
  <tema>Camino de Euler en un grafo no dirigido </tema>
  <texto>¿Es possible dibujar un grafo dado sin levantar el lápiz del papel y sin pasar por los caminos más de una vez?
Un grafo es llamado euleriano si tiene un ciclo de Euler y es llamado semi-euleriano si tiene un camino de Euler, el problema es similar al camino Hamiltoniano, podemos verificar si un grafo es euleriano o no en tiempo polinómico, de O(V+E).
Las siguientes son propiedades interesantes de los grafos no dirigidos con un camino euleriano y ciclo, podemos usar esta propiedades para encontrar si un grafo es euleriano o no.
Ciclo euleriano
Un grafo no dirigido tiene un ciclo de Euler si las siguientes dos condiciones son ciertas:
- Todos los vértices con grado no cero estan conectados, no nos importa los vértices con grado cero porque no pertenecen a el ciclo de Euler o el camino, solo estamos considerando los caminos.
- Todos los vértices tienen grado par.
Camino euleriano
Un grafo no dirigido tiene un camino euleriano si las dos siguientes condiciones se cumplen:
- La misma primera condición de un ciclo de Euler
- Si dos vértices tienen grado impar y todos los demás vértices tienen grado par, note que solo un vértice con grado impar no es posible en un grafo no dirigido, la suma de todos los grados es siempre par en un grafo no dirigido.
Note que un grafo sin caminos se considera euleriano porque no hay caminos que atravesar.
En el camino euleriano, cada vez que visitamos un vértice v, nosotros caminamos a través de dos caminos no visitados, con un punto de fin como v, por lo tanto todos los vértices medios en el camino euleriano deben tener grado par, para el ciclo euleriano cualquier vértice puede ser vértice medio, sin embargo todos los vértices deben tener grado par.
</texto>
  <complejidad_tiempo>Mejor caso :    O(|v|+|e|)  Peor caso : O(|v|+|e|)  Promedio: O(|v|+|e|) </complejidad_tiempo>
  <java>// Programa java que busca camino euleriano
// de un grafo

import java.util.*;
import java.util.LinkedList;

public class EulerianPathUndirectedGraph {

    public static void main(String args[]) {
        // Creamos varios ejemplos de grafos para probar
        Graph g1 = new Graph(5);
        g1.addEdge(1, 0);
        g1.addEdge(0, 2);
        g1.addEdge(2, 1);
        g1.addEdge(0, 3);
        g1.addEdge(3, 4);
        g1.test();
        Graph g2 = new Graph(5);
        g2.addEdge(1, 0);
        g2.addEdge(0, 2);
        g2.addEdge(2, 1);
        g2.addEdge(0, 3);
        g2.addEdge(3, 4);
        g2.addEdge(4, 0);
        g2.test();
        Graph g3 = new Graph(5);
        g3.addEdge(1, 0);
        g3.addEdge(0, 2);
        g3.addEdge(2, 1);
        g3.addEdge(0, 3);
        g3.addEdge(3, 4);
        g3.addEdge(1, 3);
        g3.test();
        /* Crearemos un grafo con tres vertices
        conectados en forma de ciclo*/
        Graph g4 = new Graph(3);
        g4.addEdge(0, 1);
        g4.addEdge(1, 2);
        g4.addEdge(2, 0);
        g4.test();
        /* Creamos un grafo con vertices con grado cero*/
        Graph g5 = new Graph(3);
        g5.test();
    }

    static class Graph {

        private int V;
        private LinkedList&lt;Integer&gt; adj[];
        // Constructor 
        Graph(int v) {
            V = v;
            adj = new LinkedList[v];
            for (int i = 0; i &lt; v; ++i) {
                adj[i] = new LinkedList();
            }
        }
        //Agregar caminos
        void addEdge(int v, int w) {
            adj[v].add(w);
            adj[w].add(v); //El grafo es no dirigido
        }

        void DFSUtil(int v, boolean visited[]) {
            visited[v] = true;
            Iterator&lt;Integer&gt; i = adj[v].listIterator();
            while (i.hasNext()) {
                int n = i.next();
                if (!visited[n]) {
                    DFSUtil(n, visited);
                }
            }
        }

        boolean isConnected() {
            boolean visited[] = new boolean[V];
            int i;
            for (i = 0; i &lt; V; i++) {
                visited[i] = false;
            }
            for (i = 0; i &lt; V; i++) {
                if (!adj[i].isEmpty()) {
                    break;
                }
            }
            //Si no hay caminos en el grafo, retorna true
            if (i == V) {
                return true;
            }
            DFSUtil(i, visited);
            for (i = 0; i &lt; V; i++) {
                if (visited[i] == false &amp;&amp; adj[i].size() &gt; 0) {
                    return false;
                }
            }
            return true;
        }

        int isEulerian() {
            if (isConnected() == false) {
                return 0;
            }
            // Cuenta vertices con grado impar 
            int odd = 0;
            for (int i = 0; i &lt; V; i++) {
                if (adj[i].size() % 2 != 0) {
                    odd++;
                }
            }
            // Si cuenta es más de 2, el grafo no es euleriano
            if (odd &gt; 2) {
                return 0;
            }
            //si odd es 2, es semieuleriano
            //Si odd es 0, es eulerian0 
            return (odd == 2) ? 1 : 2;
        }
        void test() {
            int res = isEulerian();
            switch (res) {
                case 0:
                    System.out.println(&quot;Grafo no es euleriano&quot;);
                    break;
                case 1:
                    System.out.println(&quot;Grafo tiene un camino de euler&quot;);
                    break;
                default:
                    System.out.println(&quot;Grafo tiene ciclo de euler&quot;);
                    break;
            }
        }
    }
}
</java>
  <cpp>#include &lt;bits/stdc++.h&gt;
#define MAX 101
using namespace std;
vector&lt;vector&lt;int&gt; &gt;adj(MAX);
int in[MAX];

void clean() {
    adj.clear();
    adj.erase(adj.begin(), adj.begin() + adj.size());
    memset(in, 0, sizeof in);
}

struct Graph {
    int V;

    void addEdge(int v, int w) {
        adj[v].push_back(w);
        adj[w].push_back(v);
    }

    void DFSUtil(int v, bool visited[]) {
        visited[v] = true;
        int n;
        for (int i = 0; i &lt; adj[v].size(); ++i) {
            n = adj[v][i];
            if (!visited[n]) {
                DFSUtil(n, visited);
            }
        }
    }

    bool isConnected() {
        bool visited[V];
        int i;
        memset(visited, false, sizeof visited);
        for (i = 0; i &lt; V; i++) {
            if (!adj[i].empty()) {
                break;
            }
        }
        if (i == V) {
            return true;
        }
        DFSUtil(i, visited);
        for (i = 0; i &lt; V; i++) {
            if (visited[i] == false &amp;&amp; adj[i].size() &gt; 0) {
                return false;
            }
        }
        return true;
    }

    int isEulerian() {
        if (isConnected() == false) {
            return 0;
        }
        int odd = 0;
        for (int i = 0; i &lt; V; i++) {
            if (adj[i].size() % 2 != 0) {
                odd++;
            }
        }
        if (odd &gt; 2) {
            return 0;
        }
        return (odd == 2) ? 1 : 2;
    }

    void test() {
        int res = isEulerian();
        switch (res) {
            case 0:
                cout &lt;&lt; &quot;Grafo no euleriano&quot; &lt;&lt; endl;
                break;
            case 1:
                cout &lt;&lt; &quot;Grafo tiene camino de euler&quot; &lt;&lt; endl;
                break;
            case 2:
                cout &lt;&lt; &quot;Grafo tiene ciclo de euler&quot; &lt;&lt; endl;
                break;
        }
    }

    void init() {
        adj.clear();
        memset(in, 0, sizeof in);
    }

};

int main() {
    /*
    Graph g1;
    g1.init();
    g1.V=5;
    g1.addEdge(1, 0);
    g1.addEdge(0, 2);
    g1.addEdge(2, 1);
    g1.addEdge(0, 3);
    g1.addEdge(3, 4);
    g1.test();
    Graph g2;
    g2.init();
    g2.V=5;
    g2.addEdge(1, 0);
    g2.addEdge(0, 2);
    g2.addEdge(2, 1);
    g2.addEdge(0, 3);
    g2.addEdge(3, 4);
    g2.addEdge(4, 0);
    g2.test();
     */
    Graph g3;
    g3.init();
    g3.V = 5;
    g3.addEdge(1, 0);
    g3.addEdge(0, 2);
    g3.addEdge(2, 1);
    g3.addEdge(0, 3);
    g3.addEdge(3, 4);
    g3.addEdge(1, 3);
    g3.test();
    /*
    Graph g4;
    g4.init();
    g4.V=3;
    g4.addEdge(0, 1);
    g4.addEdge(1, 2);
    g4.addEdge(2, 0);
    g4.test();
    Graph g5;
    g5.init();
    g5.V=3;
    g5.test();
     */

}
</cpp>
  <py>null</py>
  <orden>8</orden>
  <suborden>12</suborden>
  <fecha_creacion>2020-12-05 00:45:49</fecha_creacion>
  <fecha_modificacion>2020-12-06 20:30:51</fecha_modificacion>
</row>
<row>
  <ID>143</ID>
  <supergrupo>Grafos </supergrupo>
  <tema>Ciclo Hamiltoniano</tema>
  <texto>El camino Hamiltoniano de un grafo no dirigido es un camino que visita cada vértice exactamente una vez, un ciclo Hamiltoniano es un camino Hamiltoniano que tiene un camino desde el último vértice al primer vértice del camino Hamiltoniano, debemos determinar si un grafo tiene ciclo Hamiltoniano o no, si lo contiene imprimir el camino.
Nuestra entrada será un array graph[v][v] donde v es el número de vértices en el grafo y graph[][] es la matriz de adyacencia representando el grafo, un valor graph[i][j] es 1 si existe un camino directo de I a j, de lo contrario será 0.
Nuestra salida será un array path[v] que deberá contener el camino Hamiltoniano, path[i] puede representar el iesimo vértice en el camino Hamiltoniano. El código debe también retornar si no existe ciclo Hamiltoniano en el grafo.
Se crea un array de camino vacío y se le agrega el vértice 0 a él, se agregan los otros vértices iniciando desde el vértice 1, antes de añadir un vértice, se verifica por cual es el adyacente del anterior añadido y si no se ha añadido ya, si encontramos tal vértice, añadimos el vértice como parte de la solución, si no lo encontramos retornamos false.
Note que el código siempre imprime el ciclo iniciando de 0, el punto de inicio no importa ya que el ciclo puede empezar de cualquier punto, si se quiere cambiar el punto de inicio, se deben hacer dos cambios al código de abajo.
Cambie  “path[0] = 0;” por “path[0] = s;” donde s es el nuevo punto de inicio, también cambie el ciclo “for (int v = 1; v &lt; V; v++)&quot; en hamCycleUtil() por &quot;for (int v = 0; v &lt; V; v++)&quot;.
</texto>
  <complejidad_tiempo>Mejor caso :    O(|v|+|e|)  Peor caso : O(|v|+|e|)  Promedio: O(|v|+|e|) </complejidad_tiempo>
  <java>/* Programa java que soluciona el ciclo de Hamilton
usando backtracking*/

public class HamiltonianCycle {

    static final int V = 5;
    static int path[];

    /* Una función de utilidad para comprobar si el vértice v puede ser
       añadido en el índice &#39;pos&#39;en el ciclo hamiltoniano
       construido hasta ahora (almacenado en &#39;path[]&#39;)*/
    static boolean isSafe(int v, int graph[][], int path[], int pos) {
        /*Verifica si este vertice es adyacente del 
        anterior vertice */
        if (graph[path[pos - 1]][v] == 0) {
            return false;
        }
        /* Verifica si el vertice ya esta incluido*/
        for (int i = 0; i &lt; pos; i++) {
            if (path[i] == v) {
                return false;
            }
        }
        return true;
    }

    static boolean hamCycleUtil(int graph[][], int path[], int pos) {
        /* Caso base:Si todos los vertices estan incluidos en  
           el ciclo hamiltoniano*/
        if (pos == V) {
            // Y si hay un camino de el ultimo al primer vertice
            return graph[path[pos - 1]][path[0]] == 1;
        }
        /*Prueba diferentes vértices como próximo candidato
        en el ciclo hamiltoniano. No intentamos con 0, 
        ya que incluimos 0 como punto de partida en hamCycle ()*/
        for (int v = 1; v &lt; V; v++) {
            /* Verifica si este vertice puede ser añadido al
            ciclo hamiltoniano*/
            if (isSafe(v, graph, path, pos)) {
                path[pos] = v;
                /* Recorre hasta construir el camino*/
                if (hamCycleUtil(graph, path, pos + 1) == true) {
                    return true;
                }
                path[pos] = -1;
            }
        }
        /* Si no hay vertice para añadir al ciclo
        retorna falso*/
        return false;
    }

    /* Esta función resuelve el problema del ciclo hamiltoniano usando
       backtracking. Utiliza principalmente hamCycleUtil () para resolver el
       problema. Devuelve falso si no hay ciclo hamiltoniano.
       posible, de lo contrario devuelve verdadero e imprime la ruta.
       Tenga en cuenta que puede haber más de una solución,
       Esta función imprime una de las soluciones factibles.*/
    static int hamCycle(int graph[][]) {
        path = new int[V];
        for (int i = 0; i &lt; V; i++) {
            path[i] = -1;
        }
        /* Pongamos el vértice 0 como el primer vértice en el camino.
           Si hay un ciclo hamiltoniano, entonces el camino puede ser
           Comenzó desde cualquier punto del ciclo ya que la gráfica es
           no dirigido*/
        path[0] = 0;
        if (hamCycleUtil(graph, path, 1) == false) {
            System.out.println(&quot;\nNo existe solución&quot;);
            return 0;
        }
        printSolution(path);
        return 1;
    }

    // Imprimir solución
    static void printSolution(int path[]) {
        System.out.println(&quot;Solución existe: Este&quot;
                + &quot; es uno de los ciclos hamiltoniano&quot;);
        for (int i = 0; i &lt; V; i++) {
            System.out.print(&quot; &quot; + path[i] + &quot; &quot;);
        }
        System.out.println(&quot; &quot; + path[0] + &quot; &quot;);
    }

    public static void main(String args[]) {
        /*Tenemos el siguiente grafo 
           (0)--(1)--(2) 
            |   / \   | 
            |  /   \  | 
            | /     \ | 
           (3)-------(4)    */
        int graph1[][] = {{0, 1, 0, 1, 0},
        {1, 0, 1, 1, 1},
        {0, 1, 0, 0, 1},
        {1, 1, 0, 0, 1},
        {0, 1, 1, 1, 0},};
        // Imprimir solución
        hamCycle(graph1);
        /*Tenemos el siguiente grafo 
           (0)--(1)--(2) 
            |   / \   | 
            |  /   \  | 
            | /     \ | 
           (3)       (4)    */
        int graph2[][] = {{0, 1, 0, 1, 0},
        {1, 0, 1, 1, 1},
        {0, 1, 0, 0, 1},
        {1, 1, 0, 0, 0},
        {0, 1, 1, 0, 0},};
        // Imprimir solución
        hamCycle(graph2);
    }
}
</java>
  <cpp>#include&lt;bits/stdc++.h&gt;
#include&lt;cstdlib&gt;
#define MAX 256
using namespace std;
const int V = 5;
int path[MAX];

bool isSafe(int v, int graph[V][V], int path[], int pos) {
    if (graph[path[pos - 1]][v] == 0)return false;
    for (int i = 0; i &lt; pos; i++) {
        if (path[i] == v)return false;
    }
    return true;
}

bool hamCycleUtil(int graph[V][V], int path[], int pos) {
    if (pos == V)return graph[path[pos - 1]][path[0]] == 1;
    for (int v = 1; v &lt; V; v++) {
        if (isSafe(v, graph, path, pos)) {
            path[pos] = v;
            if (hamCycleUtil(graph, path, pos + 1) == true)return true;
        }
        path[pos] = -1;
    }
    return false;
}

void printSolution(int path[]) {
    cout &lt;&lt; &quot;Solucion existente&quot; &lt;&lt; endl;
    for (int i = 0; i &lt; V; i++) {
        cout &lt;&lt; path[i] &lt;&lt; &quot; &quot;;
    }
    cout &lt;&lt; endl;
}

int hamCycle(int graph[V][V]) {
    path[V];
    memset(path, -1, sizeof path);
    path[0] = 0;
    if (hamCycleUtil(graph, path, 1) == false) {
        cout &lt;&lt; &quot;NO existe ciclo hamiltoniano&quot; &lt;&lt; endl;
        return 0;
    }
    printSolution(path);
    return 1;
}

int main() {
    int graph1[V][V] = {
        {0, 1, 0, 1, 0},
        {1, 0, 1, 1, 1},
        {0, 1, 0, 0, 1},
        {1, 1, 0, 0, 1},
        {0, 1, 1, 1, 0},};
    // Imprimir soluciÃ³n
    hamCycle(graph1);
    int graph2[V][V] = {
        {0, 1, 0, 1, 0},
        {1, 0, 1, 1, 1},
        {0, 1, 0, 0, 1},
        {1, 1, 0, 0, 0},
        {0, 1, 1, 0, 0},};
    // Imprimir soluciÃ³n
    hamCycle(graph2);
}
</cpp>
  <py>null</py>
  <orden>8</orden>
  <suborden>13</suborden>
  <fecha_creacion>2020-12-05 00:45:49</fecha_creacion>
  <fecha_modificacion>2020-12-06 20:30:51</fecha_modificacion>
</row>
<row>
  <ID>144</ID>
  <supergrupo>Grafos </supergrupo>
  <tema>El tour del caballo de ajedrez </tema>
  <texto>El backtracking es un paradigma algorítmico que intenta diferentes soluciones hasta que encuentra una solución que “Funciona”. Problemas los cuales son típicamente resueltos con técnicas de backtracking tienen una propiedad en común, estos problemas puede solo ser resueltos intentando cada posible configuración y cada configuración es intentada una sola vez, una solución ingenua para estos problemas es intentar todas las configuraciones e imprimir una configuración que siga las restricciones dadas por el problema. Backtracking funciona en forma incremental y es una optimización sobre las soluciones ingenuas donde todas las posibles configuraciones son generadas e intentadas.
 
Ilustración 15 15 Formas de solución para el caballero en el tablero de ajedrez
Backtracking funciona de forma incremental para atacar problemas, típicamente iniciamos desde un vector de solución vacío, y uno por uno vamos agregando ítems, cuando agregamos un ítem podemos verificar si agregando el siguiente ítem violamos alguna de las restricciones del problema, si lo hace eliminamos ese elemento e intentamos otras alternativas. Si ninguna de las alternativas funciona entonces volvemos a la fase previa y removemos el ítem anterior dado en la fase anterior. Si alcanzamos la fase inicial entonces decimos que no existe solución, si agregamos un valor que no viola alguna restricción entonces recursivamente agregamos ítems uno por uno, si el vector de solución se completa imprimimos la solución.

El siguiente es el backtracking del problema del tour del caballo en el tablero de ajedrez.
- Si todos los cuadrados son visitados imprima la solución
- Si no 
a) Agregue uno de los siguientes movimientos posibles al vector de solución y recursivamente verifique si este movimiento lleva a una solución (Un caballo puede hacer máximo 8 movimientos, aquí escogemos alguno de esos 8 movimientos).
b) Si el movimiento escogido arriba no lleva a una solución entonces removemos este movimiento del vector de solución e intentamos otros movimientos alternativos.
c) Si ninguna de las alternativas funciona, retornamos falso (Retornando falso podemos remover el anterior ítem agregado en recursión y si el falso es retornado a la recursión inicial entonces no existe solución.
</texto>
  <complejidad_tiempo>Mejor caso :    O(|v|+|e|)  Peor caso : O(|v|+|e|)  Promedio: O(|v|+|e|) </complejidad_tiempo>
  <java>// Programa java para el problema del tour del caballo
public class KnightTourBacktracking {

    static int N = 8;

    /* Una función que verifica si i.j es
    indice valido para un tablero n*n*/
    static boolean isSafe(int x, int y, int sol[][]) {
        return (x &gt;= 0 &amp;&amp; x &lt; N &amp;&amp; y &gt;= 0
                &amp;&amp; y &lt; N &amp;&amp; sol[x][y] == -1);
    }

    /* Imprimir la solución*/
    static void printSolution(int sol[][]) {
        for (int x = 0; x &lt; N; x++) {
            for (int y = 0; y &lt; N; y++) {
                System.out.print(sol[x][y] + &quot;\t&quot;);
            }
            System.out.println();
        }
    }
        /*Esta función resuelve el problema de Knight Tour.
       utilizando Backtracking. Esta función principalmente
       utiliza solveKTUtil () para resolver el problema. Eso
       devuelve falso si no es posible realizar un recorrido completo,
       De lo contrario, devuelve true e imprime el recorrido.
       Tenga en cuenta que puede haber más de una
       soluciones, esta función imprime una de las
       soluciones viables.*/
    static boolean solveKT() {
        int sol[][] = new int[N][N];
        /* Inicializando la matriz de solución*/
        for (int x = 0; x &lt; N; x++) {
            for (int y = 0; y &lt; N; y++) {
                sol[x][y] = -1;
            }
        }
        /* xMove[] y yMove[] define el siguiente movimiento del caballo 
          xMove[] para siguiente valor en x
          yMove[] para siguiente valor en y */
        int xMove[] = {2, 1, -1, -2, -2, -1, 1, 2};
        int yMove[] = {1, 2, 2, 1, -1, -2, -2, -1};
        //Desde que el caballero inicie en el primer bloque
        sol[0][0] = 0;
        if (!solveKTUtil(0, 0, 1, sol, xMove, yMove)) {
            System.out.println(&quot;No existe la solución&quot;);
            return false;
        } else {
            printSolution(sol);
        }
        return true;
    }

    static boolean solveKTUtil(int x, int y, int movei,
            int sol[][], int xMove[],
            int yMove[]) {
        int k, next_x, next_y;
        if (movei == N * N) {
            return true;
        }
        /* Intenta todos los movimientos desde la coordenada
        x  y y*/
        for (k = 0; k &lt; 8; k++) {
            next_x = x + xMove[k];
            next_y = y + yMove[k];
            if (isSafe(next_x, next_y, sol)) {
                sol[next_x][next_y] = movei;
                if (solveKTUtil(next_x, next_y, movei + 1,
                        sol, xMove, yMove)) {
                    return true;
                } else {
                    sol[next_x][next_y] = -1;// backtracking 
                }
            }
        }
        return false;
    }
    public static void main(String args[]) {
        solveKT();
    }
}
</java>
  <cpp>#include &lt;bits/stdc++.h&gt;
#define tablero 101
using namespace std;
int N = 12;

bool isSafe(int x, int y, int sol[tablero][tablero]) {
    return (x &gt;= 0 &amp;&amp; x &lt; N &amp;&amp; y &gt;= 0 &amp;&amp; y &lt; N &amp;&amp; sol[x][y] == -1);
}

void printSolution(int sol[tablero][tablero]) {
    for (int x = 0; x &lt; N; x++) {
        for (int y = 0; y &lt; N; y++) {
            cout &lt;&lt; sol[x][y] &lt;&lt; &quot;\t&quot;;
        }
        cout &lt;&lt; endl;
    }
}

bool solveKUtil(int x, int y, int movei, int sol[tablero][tablero], int xMove[tablero], int yMove[tablero]) {
    int k, next_x, next_y;
    if (movei == N * N) {
        return true;
    }
    for (k = 0; k &lt; N; k++) {
        next_x = x + xMove[k];
        next_y = y + yMove[k];
        if (isSafe(next_x, next_y, sol)) {
            sol[next_x][next_y] = movei;
            if (solveKUtil(next_x, next_y, movei + 1, sol, xMove, yMove)) {
                return true;
            } else {
                sol[next_x][next_y] = -1;
            }
        }
    }
    return false;
}

bool solveKT() {
    int sol[tablero][tablero];
    for (int x = 0; x &lt; N; x++) {
        for (int y = 0; y &lt; N; y++) {
            sol[x][y] = -1;
        }
    }
    int xMove[8] = {2, 1, -1, -2, -2, -1, 1, 2};
    int yMove[8] = {1, 2, 2, 1, -1, -2, -2, -1};
    sol[0][0] = 0;
    if (!solveKUtil(0, 0, 1, sol, xMove, yMove)) {
        cout &lt;&lt; &quot;No existe la solucion&quot; &lt;&lt; endl;
        return false;
    } else {
        printSolution(sol);
    }
    return true;
}

int main() {
    solveKT();
}
</cpp>
  <py>null</py>
  <orden>8</orden>
  <suborden>14</suborden>
  <fecha_creacion>2020-12-05 00:45:50</fecha_creacion>
  <fecha_modificacion>2020-12-06 20:30:52</fecha_modificacion>
</row>
<row>
  <ID>145</ID>
  <supergrupo>Grafos </supergrupo>
  <tema>15.16) Kosaraju DFS  Componentes fuertemente conexas </tema>
  <texto>Dado un grafo dirigido, encontrar si el grafo se encuentra fuertemente conectado o no, un grado es fuertemente conectado si hay un camino entre cualquier par de vértices.
Esto es fácil para un grafo no dirigido, solo tenemos que hacer BFS y DFS comenzando desde cualquier vértice, si BFS o DFS visita todos los vértices, entonces el grado no dirigido dado está conectado, esta aproximación no funciona con un grafo dirigido.
Una simple idea es usar un algoritmo de todos los caminos más cortos entre todos los pares como Floyd Warshall o encontrar el cerramiento transitivo del grafo, la complejidad de tiempo de este método es de O (v^3).
Podemos también hacer DFS V veces iniciando desde cada vértice, si alguno de los DFS no visita todos los vértices entonces el grafo no es fuertemente conectado. Este algoritmo toma O (V*(V+E)) en complejidad de tiempo, el cual puede ser el mismo del cerramiento transitivo para un grafo denso.
Una mayor idea puede ser el algoritmo de componentes fuertemente conectadas (SCC), podemos encontrar todos los SCC en O (V+E) tiempo, si el número de SCC es 1, entonces el grafo es fuertemente conectado, el algoritmo de SCC hace trabajo extra cuando busca todos los SCC.
El siguiente es un algoritmo simple basado en el DFS de Kosaraju el cual realiza dos DFS transversos en el grafo.
1) Inicializa todos los vértices como no visitados.
2) Hace un DFS transverso del grado iniciando desde cualquier vértice v, si este DFS transverso no visita todos los vértices, entonces retorna falso.
3) Reversa todos los arcos (O encuentra transpuesta o reversa de grafo)
4) Marque todos los vértices como no visitados en el grafo reverso
5) Hacer un DFS transverso del grafo reversado iniciando desde el mismo vértice v, si el DFS transverso no visita todos los vértices entonces retorna falso, de otro modo retorna true.
La idea es, si cada nodo puede ser alcanzado de un vértice v, y cada nodo puede alcanzar v, entonces el grafo es fuertemente conectado. En el paso dos podemos verificar si todos los vértices son alcanzables desde v, en el paso 4 verificamos si todos los vértices puede alcanzar v (En el grafo reverso, si todos los vértices son alcanzables desde v entonces todos los vértices pueden alcanzar v en el grafo original).
La complejidad de tiempo de esta implementaciones es la misma de DFS, el cual es O (V+E) si el grafo está representado usando listas de adyacencia.
</texto>
  <complejidad_tiempo>Mejor caso :    O(|v|+|e|)  Peor caso : O(|v|+|e|)  Promedio: O(|v|+|e|) </complejidad_tiempo>
  <java>// Programa java que verifica si un grafo es 
// fuertemente conectado

import java.util.*;
import java.util.LinkedList;

public class KosarajuDFSStronglyConnected {

    public static void main(String args[]) {
        Graph g1 = new Graph(5);
        g1.addEdge(0, 1);
        g1.addEdge(1, 2);
        g1.addEdge(2, 3);
        g1.addEdge(3, 0);
        g1.addEdge(2, 4);
        g1.addEdge(4, 2);
        if (g1.isSC()) {
            System.out.println(&quot;Si&quot;);
        } else {
            System.out.println(&quot;No&quot;);
        }
        Graph g2 = new Graph(4);
        g2.addEdge(0, 1);
        g2.addEdge(1, 2);
        g2.addEdge(2, 3);
        if (g2.isSC()) {
            System.out.println(&quot;Si&quot;);
        } else {
            System.out.println(&quot;No&quot;);
        }
    }

    static class Graph {
        private int V;
        private LinkedList&lt;Integer&gt; adj[];
        Graph(int v) {
            V = v;
            adj = new LinkedList[v];
            for (int i = 0; i &lt; v; ++i) {
                adj[i] = new LinkedList();
            }
        }
        void addEdge(int v, int w) {
            adj[v].add(w);
        }

        void DFSUtil(int v, Boolean visited[]) {
            visited[v] = true;
            int n;
            Iterator&lt;Integer&gt; i = adj[v].iterator();
            while (i.hasNext()) {
                n = i.next();
                if (!visited[n]) {
                    DFSUtil(n, visited);
                }
            }
        }
        // Obtiene el transpuesto de un grafo
        Graph getTranspose() {
            Graph g = new Graph(V);
            for (int v = 0; v &lt; V; v++) {
                Iterator&lt;Integer&gt; i = adj[v].listIterator();
                while (i.hasNext()) {
                    g.adj[i.next()].add(v);
                }
            }
            return g;
        }
        //Verifica si el grafo esta fuertemente conectado
        Boolean isSC() {
            /*Paso 1: marcar todos los vertices como no visitados
            (primer DFS)*/
            Boolean visited[] = new Boolean[V];
            for (int i = 0; i &lt; V; i++) {
                visited[i] = false;
            }
            //Paso 2: DFS transverso desde el primer vertice
            DFSUtil(0, visited);
            // si no visita todos, retorna falso
            for (int i = 0; i &lt; V; i++) {
                if (visited[i] == false) {
                    return false;
                }
            }
            // Paso 3: crear grafo transpuesto
            Graph gr = getTranspose();
            // Paso 4: marcar todos los vertices como no visitados
            // (Segundo DFS)
            for (int i = 0; i &lt; V; i++) {
                visited[i] = false;
            }
            /* Paso 5: hacer DFS en el grafo reversado*/
            gr.DFSUtil(0, visited);
            /* Si todos los vertices no son visitados, retorne falso*/
            for (int i = 0; i &lt; V; i++) {
                if (visited[i] == false) {
                    return false;
                }
            }
            return true;
        }
    }
}
</java>
  <cpp>null</cpp>
  <py>null</py>
  <orden>8</orden>
  <suborden>15</suborden>
  <fecha_creacion>2020-12-05 00:45:50</fecha_creacion>
  <fecha_modificacion>2020-12-06 20:30:53</fecha_modificacion>
</row>
<row>
  <ID>146</ID>
  <supergrupo>Grafos </supergrupo>
  <tema>Mínimo de movimientos de un caballo de ajedrez </tema>
  <texto>Dado una mesa de ajedrez cuadrada de tamaño NxN, la posición de un caballo y la posición objetivo, necesitamos encontrar la mínima cantidad de pasos que un caballo toma para llegar a la posición objetivo.
Este problema puede verse como el camino más corto en un grafo sin pesos, sin embargo usamos BFS ´para resolver este problema, intentamos todos las 8 posibles posiciones donde un caballo puede llegar desde su posición, si la posición alcanzable no ha sido visitada ya y está dentro del tablero, agregamos este estado dentro de la cola con una distancia de 1 más que su estado padre, finalmente retornamos la distancia de la posición objetivo cuando sale de la cola.
El siguiente código implementa BFS para la búsqueda a través de las celdas, donde cada celda contiene sus coordenadas y distancias desde el nodo inicial, en el peor de los casos el código visita todas las celdas del tablero, haciendo que el la complejidad del peor de los casos sea O(n^2).
</texto>
  <complejidad_tiempo>Mejor caso :    O(|v|+|e|)  Peor caso : O(v2)  Promedio: O(|v|+|e|) </complejidad_tiempo>
  <java>//Programa java que encuentra la minima cantidad de pasos
// para alcanzar una celda especifica con un caballo

import java.util.Vector;

public class MinimumMovesKnight {

    /*Clase que almacena los datos de una celda*/
    static class cell {

        int x, y;
        int dis;

        public cell(int x, int y, int dis) {
            this.x = x;
            this.y = y;
            this.dis = dis;
        }
    }

    /* Utilidad que retorna s (x,y) yace dentro del tablero*/
    static boolean isInside(int x, int y, int N) {
        return x &gt;= 1 &amp;&amp; x &lt;= N &amp;&amp; y &gt;= 1 &amp;&amp; y &lt;= N;
    }

    /* Retorna los minimos pasos para llegar al objetivo*/
    static int minStepToReachTarget(int knightPos[], int targetPos[],
            int N) {
        // dirección x y y, donde el caballo puede llegar 
        int dx[] = {-2, -1, 1, 2, -2, -1, 1, 2};
        int dy[] = {-1, -2, -2, -1, 1, 2, 2, 1};
        // Vector para almacenar los estados del caballo
        Vector&lt;cell&gt; q = new Vector&lt;&gt;();
        // Agrega la posicion inicial con distancia 0
        q.add(new cell(knightPos[0], knightPos[1], 0));
        cell t;
        int x, y;
        boolean visit[][] = new boolean[N + 1][N + 1];
        //Hacer todas las celdas sin visitar
        for (int i = 1; i &lt;= N; i++) {
            for (int j = 1; j &lt;= N; j++) {
                visit[i][j] = false;
            }
        }

        // visitar estado inicial
        visit[knightPos[0]][knightPos[1]] = true;
        // ciclo hasta que quede solo un valor 
        while (!q.isEmpty()) {
            t = q.firstElement();
            q.remove(0);
            /* Si la celda actual es igual al objetivo
            retorne su distancia*/
            if (t.x == targetPos[0] &amp;&amp; t.y == targetPos[1]) {
                return t.dis;
            }
            // Ciclo de todos los estados alcancables
            for (int i = 0; i &lt; 8; i++) {
                x = t.x + dx[i];
                y = t.y + dy[i];
                if (isInside(x, y, N) &amp;&amp; !visit[x][y]) {
                    visit[x][y] = true;
                    q.add(new cell(x, y, t.dis + 1));
                }
            }
        }
        return Integer.MAX_VALUE;
    }

    public static void main(String[] args) {
        int N = 30;
        int knightPos[] = {1, 1};
        int targetPos[] = {30, 30};
        System.out.println(minStepToReachTarget(knightPos, targetPos, N));
    }
}
</java>
  <cpp>null</cpp>
  <py>null</py>
  <orden>8</orden>
  <suborden>16</suborden>
  <fecha_creacion>2020-12-05 00:45:50</fecha_creacion>
  <fecha_modificacion>2020-12-06 20:30:53</fecha_modificacion>
</row>
<row>
  <ID>147</ID>
  <supergrupo>Grafos </supergrupo>
  <tema>El problema de las N reinas</tema>
  <texto>El problema de las N reinas es aquel en donde se colocan N reinas en un tablero de NxN de tal manera que dos reinas no puedan atacarse una con otra.
La idea es colocar reinas una por una en diferentes columnas, iniciando desde la columna de más a la izquierda, cuando colocamos una reina en una columna, verificamos por colisiones con las reinas ya colocadas, en la columna actual, si encontramos una fila en la cual no hay colisión marcamos esta columna y fila como parte de la solución, si nosotros no encontramos tal fila en donde haya colisión entonces se retrocede y se retorna falso.
1) Iniciar desde la columna de más a la izquierda.
2) Si todas las reinas han sido colocadas, retornar true
3) Intentar todas las filas de la  columna actual
Realizar lo siguiente para cada columna intentada
a) si la reina puede ser colocada seguramente en esta fila entonces marcar esta [fila, columna] como parte de la solución y recursivamente verificar si colocando una reina aquí se llega a la solución.
b) Si colocando una reina en [fila,columa] se llega a una solución, entonces retorne true.
c) Si colocando una reina no se llega a la solución entonces desmarque esta fila y columna (Paso atrás) y vaya al paso A para intentar otras filas.
4) Si todas las filas han sido probadas y ninguna funciona retorne falso para activar el backtracking.
</texto>
  <complejidad_tiempo>Mejor caso :    O(v3)  Peor caso : O(v3) Promedio: O(v3) </complejidad_tiempo>
  <java>/* Programa JAVA que resuelve el problema de las N reinas
usando backtracking*/
public class NQueenProblem {
    final int N = 4;

    void printSolution(int board[][]) {
        for (int i = 0; i &lt; N; i++) {
            for (int j = 0; j &lt; N; j++) {
                System.out.print(&quot; &quot; + board[i][j]
                        + &quot; &quot;);
            }
            System.out.println();
        }
    }
/*Una función de utilidad para comprobar si una reina puede
       colocarse en board[row][col]. Tenga en cuenta que 
       La función se llama cuando &quot;col&quot; reinas ya están
       Colocadas en columnas de 0 a col -1. Así que necesitamos
       para comprobar sólo el lado izquierdo para las reinas atacantes*/
    boolean isSafe(int board[][], int row, int col) {
        int i, j;
        /*Verifica esta fila en el lado izquierdo*/
        for (i = 0; i &lt; col; i++) {
            if (board[row][i] == 1) {
                return false;
            }
        }
        /*Verifica la diagonal superior de la izquierda*/
        for (i = row, j = col; i &gt;= 0 &amp;&amp; j &gt;= 0; i--, j--) {
            if (board[i][j] == 1) {
                return false;
            }
        }
        /*Diagonal baja desde la izquierda*/
        for (i = row, j = col; j &gt;= 0 &amp;&amp; i &lt; N; i++, j--) {
            if (board[i][j] == 1) {
                return false;
            }
        }
        return true;
    }

    boolean solveNQUtil(int board[][], int col) {
        /* Caso base: Si todas las reinas estan
        puestas, retorne true*/
        if (col &gt;= N) {
            return true;
        }
        /*Considere esta columna e intente colocando esta 
        reina en todas las filas una por una*/
        for (int i = 0; i &lt; N; i++) {
            /* Verifica si la reina puede ser puesta
            en board[i][col] */
            if (isSafe(board, i, col)) {
                board[i][col] = 1;
                /*Recursivamente pone todas las reinas*/
                if (solveNQUtil(board, col + 1) == true) {
                    return true;
                }
                board[i][col] = 0; // BACKTRACK 
            }
        }
        /*Si la reina no puede ser puesta en 
        ninguna fila en esta columna,r retorna falso*/
        return false;
    }

    /*Esta función resuelve el problema de N Queen usando
    Backtracking. Utiliza principalmente solveNQUtil() 
    para resolver el problema. Devuelve false si no se 
    pueden colocar las reinas; de lo contrario, devuelve 
    true e imprime la ubicación de las reinas en forma de 
    1s. Tenga en cuenta que puede haber más de una solución,
    esta función imprime una de las soluciones posibles.*/
    boolean solveNQ() {
        int board[][] = {{0, 0, 0, 0},
        {0, 0, 0, 0},
        {0, 0, 0, 0},
        {0, 0, 0, 0}
        };
        if (solveNQUtil(board, 0) == false) {
            System.out.print(&quot;Solución no existe&quot;);
            return false;
        }
        printSolution(board);
        return true;
    }

    public static void main(String args[]) {
        NQueenProblem Queen = new NQueenProblem();
        Queen.solveNQ();
    }
}
</java>
  <cpp>null</cpp>
  <py>null</py>
  <orden>8</orden>
  <suborden>17</suborden>
  <fecha_creacion>2020-12-05 00:45:50</fecha_creacion>
  <fecha_modificacion>2020-12-06 20:30:54</fecha_modificacion>
</row>
<row>
  <ID>148</ID>
  <supergrupo>Grafos </supergrupo>
  <tema>Ordenamiento topológico</tema>
  <texto>Ordenamiento topológico de un grafo dirigido aciclico (DAG) es un ordenamiento lineal de vértices tales que por cada camino dirigido uv, el vértice u venga antes de v en el orden, si el grafo no es DAG no es posible el ordenamiento topológico.
En DFS imprimimos un vértice y luego recursivamente llamamos DFS para los vértices adyacentes, en el ordenamiento topológico necesitamos imprimir un vértice antes de sus vértices adyacentes.
</texto>
  <complejidad_tiempo>Mejor caso :    O(|v|+|e|)  Peor caso : O(|v|+|e|)  Promedio: O(|v|+|e|) </complejidad_tiempo>
  <java>// Programa java que imprime el ordenamiendo topologico
// de un grafo dirigido

import java.util.*;

public class TopologicalSorting {
    public static void main(String args[]) {
        Graph g = new Graph(6);
        g.addEdge(5, 2);
        g.addEdge(5, 0);
        g.addEdge(4, 0);
        g.addEdge(4, 1);
        g.addEdge(2, 3);
        g.addEdge(3, 1);
        System.out.println(&quot;Siguiendo el ordenamiento topologico &quot;
                + &quot;del grafo dado &quot;);
        g.topologicalSort();
    }

    static class Graph {
        private int V;
        private LinkedList&lt;Integer&gt; adj[];
        Graph(int v) {
            V = v;
            adj = new LinkedList[v];
            for (int i = 0; i &lt; v; ++i) {
                adj[i] = new LinkedList();
            }
        }

        void addEdge(int v, int w) {
            adj[v].add(w);
        }

        void topologicalSortUtil(int v, boolean visited[],
                Stack stack) {
            visited[v] = true;
            Integer i;
            Iterator&lt;Integer&gt; it = adj[v].iterator();
            while (it.hasNext()) {
                i = it.next();
                if (!visited[i]) {
                    topologicalSortUtil(i, visited, stack);
                }
            }
            stack.push(new Integer(v));
        }
        void topologicalSort() {
            Stack stack = new Stack();
            boolean visited[] = new boolean[V];
            for (int i = 0; i &lt; V; i++) {
                visited[i] = false;
            }
            for (int i = 0; i &lt; V; i++) {
                if (visited[i] == false) {
                    topologicalSortUtil(i, visited, stack);
                }
            }
            // Imprime el contenido de la pila
            while (stack.empty() == false) {
                System.out.print(stack.pop() + &quot; &quot;);
            }
        }
    }
}
</java>
  <cpp>null</cpp>
  <py>null</py>
  <orden>8</orden>
  <suborden>18</suborden>
  <fecha_creacion>2020-12-05 00:45:51</fecha_creacion>
  <fecha_modificacion>2020-12-06 20:30:54</fecha_modificacion>
</row>
<row>
  <ID>149</ID>
  <supergrupo>Grafos </supergrupo>
  <tema>Algoritmo de Kahn para ordenamiento topológico </tema>
  <texto>Ordenamiento topológico para un grafo dirigido aciclico (DAG) es un ordenamiento lineal de vértices el cual por cada camino dirigido UV, el vértice U viene antes de V en el ordenamiento, el ordenamiento topológico no es posible si el grafo no es un DAG.
Los pasos de este algoritmo son los siguientes:
1) Calcule los grados de entrada de cada vértice en el DAG presente e inicialice el conteo de los nodos visitados como 0.
2) Tome todos los vértices con grado de entrada como o y agréguelos en una cola
3) Remueva un vértice de la cola y entonces incremente el conteo de nodos visitados por 1
4) Decremente el grado de entrada en 1 en todos los nodos vecinos, si el grado de entrada de los nodos vecinos es cero, agréguelos a la cola.
5) Repita el paso 3 hasta que la cola este vacía.
6) Si el conteo de nodos visitados no es igual al número de notos en el grado entonces el ordenamiento topológico no es posible en este grafo.
¿Cómo encontrar el grado de entrada en cada nodo?
Existen dos vías  para encontrar el grado de entrada de  cada nodo.
Tomaremos un array de grado de entrada para mantener rastreo de estos.
1) Atraviese el array de nodos y simplemente incremente el conteo del nodo de destino en 1-
for each node in Nodes
    indegree[node] = 0;
for each edge(src,dest) in Edges
    indegree[dest]++
2) Atraviese la lista de cada nodo e incremente el grado de entrada de todos los nodos conectados con él en 1
for each node in Nodes
        If (list[node].size()!=0) then
        for each dest in list
            indegree[dest]++;
La complejidad de tiempo se da por: el ciclo externo será ejecutado V número de veces y el interno será ejecutado E número de veces, la complejidad resultante será de O(V+E).
</texto>
  <complejidad_tiempo>Mejor caso :    O(|v|+|e|)  Peor caso : O(|v|+|e|)  Promedio: O(|v|+|e|) </complejidad_tiempo>
  <java>// Programa java que imprime el ordenamiento topologico
// de un grafo  

import java.util.*;

public class KahnAlgorithmTopologicalSorting {

    public static void main(String args[]) {
        Graph g = new Graph(6);
        g.addEdge(5, 2);
        g.addEdge(5, 0);
        g.addEdge(4, 0);
        g.addEdge(4, 1);
        g.addEdge(2, 3);
        g.addEdge(3, 1);
        System.out.println(&quot;Siguiendo su ordenamiento topologico &quot;);
        g.topologicalSort();
    }

    static class Graph {
        int V;
        List&lt;Integer&gt; adj[];
        public Graph(int V)// Constructor 
        {
            this.V = V;
            adj = new ArrayList[V];
            for (int i = 0; i &lt; V; i++) {
                adj[i] = new ArrayList&lt;&gt;();
            }
        }
        // Agregar caminos
        public void addEdge(int u, int v) {
            adj[u].add(v);
        }

        public void topologicalSort() {
            // Crea un array para almaccenar los indegrees
            // de todos los vertices e inicializa en 0
            int indegree[] = new int[V];
            // Atraviesa las listas de adyacencia para llenar
            // grados de los vertices       
            for (int i = 0; i &lt; V; i++) {
                ArrayList&lt;Integer&gt; temp = (ArrayList&lt;Integer&gt;) adj[i];
                temp.forEach((node) -&gt; {
                    indegree[node]++;
                });
            }
            /* Crea una cola y encola todos los vertices
            con grado 0*/
            Queue&lt;Integer&gt; q = new LinkedList&lt;&gt;();
            for (int i = 0; i &lt; V; i++) {
                if (indegree[i] == 0) {
                    q.add(i);
                }
            }
            // Inicializa el conteo de vertices visitados
            int cnt = 0;
            // Crea un vector que almacena el resultado
            ArrayList&lt;Integer&gt; topOrder = new ArrayList&lt;Integer&gt;();
            while (!q.isEmpty()) {
                int u = q.poll();
                topOrder.add(u);
  //Funcion lamba Reemplazable con un for
                adj[u].stream().filter((node) -&gt; (--indegree[node] == 0)).forEachOrdered((node) -&gt; {
                    q.add(node);
                });
                cnt++;
            }
            // Verifica si hay ciclo       
            if (cnt != V) {
                System.out.println(&quot;There exists a cycle in the graph&quot;);
                return;
            }
            //Imprime el ordenamiento topologico             
            for (int i : topOrder) {
                System.out.print(i + &quot; &quot;);
            }
        }
    }
}
</java>
  <cpp>null</cpp>
  <py>null</py>
  <orden>8</orden>
  <suborden>19</suborden>
  <fecha_creacion>2020-12-05 00:45:51</fecha_creacion>
  <fecha_modificacion>2020-12-06 20:30:55</fecha_modificacion>
</row>
<row>
  <ID>150</ID>
  <supergrupo>Grafos </supergrupo>
  <tema>Caminos más cortos mediante Dijkstra</tema>
  <texto>Dado un grafo y un vértice origen en el grafo, encuentre los caminos más cortos del origen a todos los vértices en el grafo dado.

La complejidad de tiempo de esta implementación es de O (V*E) si el grafo de entrada está representado usando una lista de adyacencia. Tener en cuenta que Dijkstra no procesa pesos negativos y no detecta ciclos negativos.
</texto>
  <complejidad_tiempo>Mejor caso :    O(v*e)  Peor caso : O(v2)  Promedio: O(v*e) </complejidad_tiempo>
  <java>// Implementación java del algoritmo de Dijkstra que
// busca el camino más corto de un nodo al resto
/*
 EJEMPLO DE INPUT
 5 9
 1 2 7
 1 4 2
 2 3 1
 2 4 2
 3 5 4
 4 2 3
 4 3 8
 4 5 5
 5 3 5
 1
 */
import java.util.*;

public class DijkstraSP {

    //similar a los defines de C++
    static final int MAX = 10005; //maximo número de vértices
    static final int INF = 1 &lt;&lt; 30; //definimos un valor 
    //grande que represente la distancia infinita
    //inicial, basta conque sea superior al maximo 
    //valor del peso en alguna de las aristas
    //En el caso de java usamos una clase que 
    //representara el pair de C++

    static class Node implements Comparable&lt;Node&gt; {

        int first, second;

        Node(int d, int p) { //constructor
            this.first = d;
            this.second = p;
        }

        @Override
        public int compareTo(Node other) { //es necesario 
            //definir un comparador para el
            //correcto funcionamiento del PriorityQueue
            if (second &gt; other.second) {
                return 1;
            }
            if (second == other.second) {
                return 0;
            }
            return -1;
        }
    };

    static Scanner sc = new Scanner(System.in); //para lectura de datos
    static List&lt; List&lt; Node&gt;&gt; ady = new ArrayList&lt; List&lt; Node&gt;&gt;(); //lista de adyacencia
    static int distancia[] = new int[MAX]; // distancia de vértice inicial
    //vértice con ID = u
    static boolean visitado[] = new boolean[MAX]; //para vértices visitados
    static PriorityQueue&lt; Node&gt; Q = new PriorityQueue&lt;Node&gt;();
    //usamos el comparador definido para 
    //que el de menor valor este en el tope
    static int V; //número de vertices
    static int previo[] = new int[MAX]; //para la impresion de caminos

    //función de inicialización
    static void init() {
        for (int i = 0; i &lt;= V; ++i) {
            distancia[i] = INF; //inicializamos todas 
            //las distancias con valor infinito
            visitado[i] = false; //inicializamos todos 
            //los vértices como no visitados
            previo[i] = -1; //inicializamos el previo 
            //del vertice i con -1
        }
    }

    //Paso de relajacion
    static void relajacion(int actual, int adyacente, int peso) {
        //Si la distancia del origen al vertice actual + 
        //peso de su arista es menor a la distancia del
        //origen al vertice adyacente
        if (distancia[actual] + peso &lt; distancia[adyacente]) {
            //relajamos el vertice actualizando la distancia
            distancia[adyacente] = distancia[actual] + peso;
            //a su vez actualizamos el vértice previo
            previo[adyacente] = actual;
            //agregamos adyacente a la cola de prioridad
            Q.add(new Node(adyacente, distancia[adyacente]));
        }
    }
    //Impresion del camino más corto desde el vertice inicial y final ingresados
    static void print(int destino) {
        if (previo[destino] != -1) //si aun poseo un vertice previo
        {
            print(previo[destino]); //recursivamente sigo explorando
        }
        //terminada la recursion imprimo los vertices
        //recorridos
        System.out.printf(&quot;%d &quot;, destino);
    }

    static void dijkstra(int inicial) {
        init(); //inicializamos nuestros arreglos
        //Insertamos el vértice inicial en la Cola de Prioridad
        Q.add(new Node(inicial, 0));
        //Este paso es importante, inicializamos la distancia del
        //inicial como 0
        distancia[inicial] = 0;
        int actual, adyacente, peso;
        while (!Q.isEmpty()) { //Mientras cola no este vacia
            //Obtengo de la cola el nodo con menor peso, en un
            //comienzo será el inicial
            actual = Q.element().first;
            Q.remove(); //Sacamos el elemento de la cola
            if (visitado[actual]) {
                continue; //Si el vértice actual ya fue visitado entonces sigo
            }//sacando elementos de la cola
            visitado[actual] = true; //Marco como visitado el vértice actual
            //reviso sus adyacentes del
            //vertice actual
            for (int i = 0; i &lt; ady.get(actual).size(); ++i) {
                adyacente = ady.get(actual).get(i).first; //id del vertice adyacente
                //peso de la arista que une actual
                //con adyacente ( actual , adyacente )
                peso = ady.get(actual).get(i).second;
                //si el vertice adyacente no fue visitado
                if (!visitado[adyacente]) {
                    //realizamos el paso de relajacion
                    relajacion(actual, adyacente, peso);
                }
            }
        }

        System.out.printf(&quot;Distancias más cortas iniciando en vertice %d\n&quot;, inicial);
        for (int i = 1; i &lt;= V; ++i) {
            System.out.printf(&quot;Vertice %d , distancia más corta = %d\n&quot;, i, distancia[i]);
        }

        System.out.println(&quot;\n**************Impresion de camino más corto**************&quot;);
        System.out.printf(&quot;Ingrese vertice destino: &quot;);
        int destino;
        destino = sc.nextInt();
        print(destino);
        System.out.printf(&quot;\n&quot;);
    }

    public static void main(String[] args) {
        int E, origen, destino, peso, inicial;

        V = sc.nextInt();
        E = sc.nextInt();
        for (int i = 0; i &lt;= V; ++i) {
            ady.add(new ArrayList&lt;Node&gt;()); //inicializamos lista de
        }//adyacencia
        for (int i = 0; i &lt; E; ++i) {
            origen = sc.nextInt();
            destino = sc.nextInt();
            peso = sc.nextInt();
            ady.get(origen).add(new Node(destino, peso)); //grafo dirigido
            //ady.get( destino ).add( new Node( origen , peso ) ); //no dirigido
        }
        System.out.print(&quot;Ingrese el vertice inicial: &quot;);
        inicial = sc.nextInt();
        dijkstra(inicial);
    }
}
</java>
  <cpp>#include&lt;bits/stdc++.h&gt;
#include&lt;cstdlib&gt;
//---------------//
#define MAX 10005
const int INF = 1 &lt;&lt; 30;
//---------------// 
using namespace std;

struct Node {
    int destino, peso;

    Node(int _destino, int _peso) : destino(_destino), peso(_peso) {
    }

    Node() : destino(-1), peso(-1) {
    }
};

struct State {
    int destino;
    int peso;

    State(int _destino, int _peso) : destino(_destino), peso(_peso) {
    }

    bool operator&lt;(const State &amp;b) const {
        return peso &gt; b.peso;
    }
};
vector &lt;vector&lt;Node&gt; &gt;ady(MAX);
int distancia[MAX];
bool visited[MAX];
priority_queue&lt;State&gt; Q;
int previo[MAX];

void init(int V) {
    for (int i = 1; i &lt;= V; i++) {
        distancia[i] = INF;
    }
}

void relajacion(int actual, int adyacente, int peso) {
    if (distancia[actual] + peso &lt; distancia[adyacente]) {
        distancia[adyacente] = distancia[actual] + peso;
        previo[adyacente] = actual;
        Q.push(State{adyacente, distancia[adyacente]});
    }
}

void print(int destino) {
    if (previo[destino] != -1) {
        print(previo[destino]);
    }
    cout &lt;&lt; destino &lt;&lt; &quot; &quot;;
}

void dijkstra(int inicial, int V) {
    init(V);
    Q.push(State{inicial, 0});
    distancia[inicial] = 0;
    int actual, adyacente, peso;
    while (!Q.empty()) {
        actual = Q.top().destino;
        Q.pop();
        if (visited[actual]) {
            continue;
        }
        visited[actual] = true;
        for (int i = 0; i &lt; ady[actual].size(); i++) {
            adyacente = ady[actual][i].destino;
            peso = ady[actual][i].peso;
            if (!visited[adyacente]) {
                relajacion(actual, adyacente, peso);
            }
        }
    }
    cout &lt;&lt; &quot;distancia mas corta iniciada desde &quot; &lt;&lt; inicial &lt;&lt; endl;
    for (int i = 1; i &lt;= V; i++) {
        cout &lt;&lt; &quot;vertice &quot; &lt;&lt; i &lt;&lt; &quot; distancia mas corta = &quot; &lt;&lt; distancia[i] &lt;&lt; endl;
    }
    cout &lt;&lt; &quot;impresion del camino mas corto&quot; &lt;&lt; endl;
    int destino;
    cin&gt;&gt;destino;
    print(destino);
    cout &lt;&lt; endl;
}

int main() {
    memset(previo, -1, sizeof previo);
    int V, E, origen, destino, peso, inicial;
    cin &gt;&gt; V&gt;&gt;E;
    for (int i = 0; i &lt; E; i++) {
        cin &gt;&gt; origen &gt;&gt; destino&gt;&gt;peso;
        ady[origen].push_back(Node{destino, peso}); //dirigido
        //ady[destino].push_back(Node{origen,peso});// no dirigido
    }
    cout &lt;&lt; &quot;Inserte el verice inicial&quot; &lt;&lt; endl;
    cin&gt;&gt;inicial;
    dijkstra(inicial, V);
}
</cpp>
  <py>null</py>
  <orden>8</orden>
  <suborden>20</suborden>
  <fecha_creacion>2020-12-05 00:45:51</fecha_creacion>
  <fecha_modificacion>2020-12-06 20:30:56</fecha_modificacion>
</row>
<row>
  <ID>151</ID>
  <supergrupo>Grafos </supergrupo>
  <tema>15.22) Caminos más cortos mediante Bellman-Ford </tema>
  <texto>Dado un grafo y un vértice de origen src en el grafo, encontrar los caminos más cortos desde src a todos los vértices en el grafo dado, el grafo puede contener caminos con pesos negativos. Si hay un ciclo de peso negativo, entonces las distancias más cortas no son calculadas, se reporta el ciclo negativo.
1) Este paso inicializa las distancias desde el origen de todos los vértices como infinito y la distancia al origen en si como 0, crea un array dist[] de tamaño V con todos los valores como infinito excepto dist[src] donde src es el vértice origen.
2) Este paso calcula las distancias más cortas, esto se realiza V-1 veces.
3) si dist[v] &gt; dist[u] + peso del camino uv, entonces actualice dist[] en dist[v] = dist[u] + weight of edge uv
4) Este paso verifica si hay un ciclo negativo en el grafo, se realiza lo siguiente:
5) si dist[v] &gt; dist[u] + peso del camino uv, entonces “El grafo contiene un ciclo negativo”
La idea del paso 3 es, el paso 2 garantiza las distancias más cortas si el grafo no contiene un ciclo de peso negativo, si iteramos a través de todos los caminos una vez más y obtenemos un camino más corto para cualquier vértice, entonces  ahí hay un ciclo negativo.
Como en otros problemas de programación dinámica, el algoritmo calcula los caminos más cortos de manera del atrás hacia adelante, primero calcula las distancias más cortas las cuales tienen  al menos una arista en el camino, luego calcula los caminos más cortos con al menos dos aristas, y así en adelante, luego de la iesima iteración del ciclo exterior, los caminos más cortos con al menos i aristas son calculados, ahí puede haber un máximo de V-1 aristas en un camino simple, por eso el ciclo externo se corre V-1 veces, la idea es, asumiendo que ahí no hay ciclo negativo, si calculamos los caminos más cortos con al menos i aristas, entonces una interacción sobre todos las aristas garantiza darnos el camino más corto con al menos i+1 artistas.
Ejemplo basado en la imagen anterior:

Dado el vértice origen 0, inicializamos todas las distancias como infinito, excepto la distancia al origen mismo, el número total de vértices en el grafo es 5 y todos los caminos deben ser procesados 4 veces.
Todos las aristas son procesadas en el siguiente orden, (B, E), (D, B), (B, D), (A, B), (A, C), (D, C), (B, C), (E, D). Tenemos las siguientes distancias cuando todos las aristas son procesadas por primera vez, la primera fila 
La primera iteración garantiza darnos todos los caminos más cortos los cuales tienen un largo de una arista, obtenemos las distancias siguientes cuando todos las aristas son procesadas por segunda vez.
La segunda iteración garantiza darnos todos los caminos más cortos que sean de 2 aristas más larga, el algoritmo procesa los caminos 2 veces más, las distancias son minimizadas luego de la segunda iteración, y la tercera y cuarta no actualiza distancias...
1) Pesos negativos son encontrados en varias aplicaciones de grafos, por ejemplo en vez de pagar el costo por un camino, podemos obtener ventaja si seguimos el camino.
2) Bellman-Ford trabaja mejor que Dijkstra para sistemas distribuidos, a diferencia de Dijkstra en donde necesitamos encontrar el valor menor de todos los vértices, en Bellman-Ford necesitamos considerar uno por uno.
</texto>
  <complejidad_tiempo>Mejor caso :    O(v2*e)  Peor caso : O(v3)  Promedio: O(v2*e) </complejidad_tiempo>
  <java>// Implementación java del algoritmo de BellmanFord
// para la busqueda del camino más corto de un vertice al
// resto y con capacidad de detección de ciclo negativo

import java.util.ArrayList;
import java.util.List;
import java.util.Scanner;

public class BellmanFordSP {

    static final int MAX = 105;
    static final int INF = 1 &lt;&lt; 30;
    static int[] previo = new int[MAX];
    static int[] distancia = new int[MAX];
    static int vertices;
    static List&lt;List&lt;Node&gt;&gt; adyacencia = new ArrayList&lt;List&lt;Node&gt;&gt;();
    static Scanner sc = new Scanner(System.in);

    static void inicializacion() {
        for (int i = 0; i &lt;= vertices; i++) {
            distancia[i] = INF;
            previo[i] = -1;
        }
    }

    static class Node {
        int first, second;
        public Node(int destino, int peso) {
            this.first = destino;
            this.second = peso;
        }
    }

    static void print(int destino) {
        if (previo[destino] != -1) {
            print(previo[destino]);
        }
        System.out.printf(&quot;%d &quot;, destino);
    }

    static boolean relajacion(int actual, int adyacente, int peso) {
        if (distancia[actual] + peso &lt; distancia[adyacente]) {
            distancia[adyacente] = distancia[actual] + peso;
            previo[adyacente] = actual;
            return true;
        }
        return false;
    }

    static void bellmanFord(int inicial) {
        inicializacion();
        distancia[inicial] = 0;
        for (int i = 0; i &lt; vertices - 1; i++) {
            for (int actual = 0; actual &lt; vertices; actual++) {
                for (int j = 0; j &lt; adyacencia.get(actual).size(); j++) {
                    int adyacente = adyacencia.get(actual).get(j).first;
                    int peso = adyacencia.get(actual).get(j).second;
                    relajacion(actual, adyacente, peso);
                }
            }
        }
        for (int actual = 0; actual &lt; vertices; actual++) {
            for (int j = 0; j &lt; adyacencia.get(actual).size(); j++) {
                int adyacente = adyacencia.get(actual).get(j).first;
                int peso = adyacencia.get(actual).get(j).second;
                if (relajacion(actual, adyacente, peso)) {
                    System.out.println(&quot;Existe ciclo negativo&quot;);
                    return;
                }
            }
        }
        System.out.println(&quot;No existe ciclo negativo&quot;);
        System.out.printf(&quot;Distancias más corteas iniciando en el nodo %d\n&quot;, inicial);
        for (int i = 0; i &lt; vertices; i++) {
            System.out.printf(&quot;Nodo %d , distancia más corta = %d\n&quot;, i, distancia[i]);
        }
        System.out.println(&quot;\n ________Camino más corto____&quot;);
        System.out.println(&quot;Ingrese vertice destino: &quot;);
        int destino = sc.nextInt();
        print(destino);
        System.out.println(&quot;&quot;);
    }

    public static void main(String[] args) {
        int E, origen, destino, peso, inicial;
        vertices = sc.nextInt();
        E = sc.nextInt();
        for (int i = 0; i &lt; 10; i++) {
            adyacencia.add(new ArrayList&lt;&gt;());
        }
        for (int i = 0; i &lt; E; i++) {
            origen = sc.nextInt();
            destino = sc.nextInt();
            peso = sc.nextInt();
            adyacencia.get(origen).add(new Node(destino, peso));
        }
        System.out.printf(&quot;Ingrese el nodo inicial: &quot;);
        inicial = sc.nextInt();
        bellmanFord(inicial);
    }
}
</java>
  <cpp>#include&lt;bits/stdc++.h&gt;
#include&lt;cstdlib&gt;
//---------------//
#define MAX 105
using namespace std;
int previo[MAX];
int distancia[MAX];

void init(int vertices) {
    for (int i = 0; i &lt;= vertices; i++) {
        distancia[i] = INT_MAX;
        previo[i] = -1;
    }
}

void printPath(int destino) {
    if (previo[destino] != -1)printPath(previo[destino]);
    printf(&quot;%d &quot;, destino);
}

bool relajacion(int actual, int adyacente, int peso) {
    if (distancia[actual] + peso &lt; distancia[adyacente]) {
        distancia[adyacente] = distancia[actual] + peso;
        previo[adyacente] = actual;
        return true;
    }
    return false;
}
vector&lt;vector&lt;pair &lt;int, int&gt; &gt; &gt;ady(MAX);

void BellmanFord(int inicial, int vertices) {
    init(vertices);
    distancia[inicial] = 0;
    for (int i = 0; i &lt; vertices; i++) {
        for (int actual = 0; actual &lt; vertices; actual++) {
            for (int j = 0; j &lt; ady[actual].size(); j++) {
                int adyacente = ady[actual][j].first;
                int peso = ady[actual][j].second;
                relajacion(actual, adyacente, peso);
            }
        }
    }
    for (int actual = 0; actual &lt; vertices; actual++) {
        for (int j = 0; j &lt; ady[actual].size(); j++) {
            int adyacente = ady[actual][j].first;
            int peso = ady[actual][j].second;
            if (relajacion(actual, adyacente, peso)) {
                printf(&quot;Existe ciclo negativo\n&quot;);
                return;
            }
        }
    }
    printf(&quot;No existe ciclo negativo\ndistancias mas corta desde el nodo %d&quot;, inicial);
    for (int i = 0; i &lt;= vertices; i++) {
        printf(&quot;nodo %d distancia mas corta = %d\n&quot;, i, distancia[i]);
    }
    printf(&quot;camino mas corto hasta un destino\n&quot;);
    int destino;
    cin&gt;&gt;destino;
    printPath(destino);
    cout &lt;&lt; endl;
}

int main() {
    int E, origen, destino, peso, inicial, vertices;
    cin &gt;&gt; vertices&gt;&gt;E;
    for (int i = 0; i &lt; E; i++) {
        cin &gt;&gt; origen &gt;&gt; destino&gt;&gt;peso;
        ady[origen].push_back(make_pair(destino, peso)); //dirigido
        //ady[destino].push_back(make_pair{origen,peso});//NO dirigido
    }
    printf(&quot;Nodo inicial : &quot;);
    cin&gt;&gt;inicial;
    BellmanFord(inicial, vertices);
}
</cpp>
  <py>null</py>
  <orden>8</orden>
  <suborden>21</suborden>
  <fecha_creacion>2020-12-05 00:45:52</fecha_creacion>
  <fecha_modificacion>2020-12-06 20:30:56</fecha_modificacion>
</row>
<row>
  <ID>152</ID>
  <supergrupo>Grafos </supergrupo>
  <tema>Caminos más cortos entre todos los nodos mediante Floyd-Warshall</tema>
  <texto>El algoritmo de Floyd Warshall se usa para la resolución de todos los caminos más cortos de todos los pares, el problema es encontrar las distancias más pequeñas entre cada par de vértices dado un grafo de caminos con pesos.
Inicializamos la matriz de la solución igual que la matriz de entrada del grafo en el primer paso, luego actualizamos la matriz de solución considerando todos los vértices en un vértice intermedio, la idea es uno por uno tomar todos los vértices y actualizar todos los caminos más cortos los cuales incluyen el vértice seleccionado como el vértice intermedio en el camino más corto. Cuando tomamos el vértice de número k como un vértice intermedio ya estamos considerando vértices {0,1,2…k-1} como intermedios, para cada par (i,j) del origen al destino respetivamente existen dos posibles casos.
1) k no es un vértice intermedio en el camino más corto de i a j, mantenemos el valor de dist[i][j] como esta.
2) K es un vértice intermedio en el camino más corto de i a j, actualizamos el valor de dist[i][j] como dist[i][k] + dist[k][j] if dist[i][j] &gt; dist[i][k] + dist[k][j]
La complejidad de tiempo es: O(V^3) o O(N^3).
El programa solo imprime las distancias más cortas, podemos modificar la solución para imprimir el camino más corto ordenando la información del predecesor en una matriz separada.
El valor de INF puede ser tomado de INT_MAX o Integer.MAX_VALUE, lo que nos permite manejar el los valores máximos posibles.
</texto>
  <complejidad_tiempo>Mejor caso :    O(v3  Peor caso : O(v3)  Promedio: O(v3) </complejidad_tiempo>
  <java>// Programa java que busca todos los caminos más cortos
// en un grafo

import java.util.ArrayList;
import java.util.Scanner;

public class Main {

    static int INF = 9999;
    static int V = 0;
    //grafo en matriz fija
    static int[][] graph;
    //matriz que almacena el camino recorrido
    static int[][] next;

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        V = sc.nextInt();
        graph = new int[V][V];
        next = new int[V][V];
        int E = sc.nextInt();
        //Inicializa todo en infinito
        for (int i = 0; i &lt; V; i++) {
            for (int j = 0; j &lt; V; j++) {
                graph[i][j] = INF;
            }
        }
        // De un nodo al mismo nodo es 0
        for (int i = 0; i &lt; V; i++) {
            graph[i][i] = 0;
        }
        for (int i = 0; i &lt; E; i++) {
            graph[sc.nextInt()][sc.nextInt()] = sc.nextInt();
        }
        floydWarshall(graph);
        ArrayList&lt;Integer&gt; path;
        System.out.println(&quot;El camino mas corto desde 0 a 3: &quot;);
        //Construit camino
        path = constructPath(0, 3);
        //imprimir camino
        printPath(path);
    }

    static void floydWarshall(int graph[][]) {
        int dist[][] = new int[V][V];
        int i, j, k;
        /*Inicialice la matriz de solución igual que 
            la matriz del gráfico de entrada. O podemos 
            decir que los valores iniciales de las distancias 
            más cortas se basan en las rutas más cortas, 
            considerando que no hay vértice intermedio. */
        for (i = 0; i &lt; V; i++) {
            for (j = 0; j &lt; V; j++) {
                dist[i][j] = graph[i][j];
                // Si no hay camino entre i y j
                if (graph[i][j] == INF) {
                    next[i][j] = -1;
                } else {
                    next[i][j] = j;
                }
            }
        }

            /*Agregue todos los vértices uno por uno al conjunto 
            de vértices intermedios.
            ---&gt; Antes del inicio de una iteración, tenemos 
            distancias más cortas entre todos los pares de vértices, 
            de modo que las distancias más cortas consideran solo
            los vértices en el conjunto {0, 1, 2, .. k-1} como 
            vértices intermedios.
            ----&gt; Después del final de una iteración, el vértice 
            número k se agrega al conjunto de vértices intermedios 
            y el conjunto se convierte en {0, 1, 2, ... k} */
        for (k = 0; k &lt; V; k++) {
            //Toma todos los vertices como inicio uno por uno
            for (i = 0; i &lt; V; i++) {
                /* Toma todos los vertices como destino del
                    incio del origen seleccionado*/
                for (j = 0; j &lt; V; j++) {
                    // Si vertice k esa en el camino más corto
                    // desde i a j, actualiza el valor de dist[i][j]
                    // No podemos viajar por un camino si no existe
                    if (dist[i][k] == INF|| dist[k][j] == INF) {
                        continue;
                    }
                    if (dist[i][j] &gt; dist[i][k]+ dist[k][j]) {
                        dist[i][j] = dist[i][k]+ dist[k][j];
                        next[i][j] = next[i][k];
                    }
                }
            }
        }
        //Imprime la matriz de distancias cortas
        printSolution(dist);
    }

    static ArrayList&lt;Integer&gt; constructPath(int u, int v) {
        // si no hay camino devuelve una lista vacia
        if (next[u][v] == -1) {
            return new ArrayList&lt;&gt;();
        }
        // Almacenando el camino en el vector
        ArrayList&lt;Integer&gt; path = new ArrayList&lt;&gt;();
        path.add(u);
        while (u != v) {
            u = next[u][v];
            path.add(u);
        }
        return path;
    }

    static void printPath(ArrayList&lt;Integer&gt; path) {
        int n = path.size();
        for (int i = 0; i &lt; n - 1; i++) {
            System.out.print(path.get(i) + &quot; -&gt; &quot;);
        }
        System.out.println(path.get(n - 1) + &quot; -&gt; &quot;);
    }

    static void printSolution(int dist[][]) {
        System.out.println(&quot;La siguiente matriz muestra las distancias &quot;
                + &quot;más cortas entre cada par de vertices&quot;);
        for (int i = 0; i &lt; V; ++i) {
            for (int j = 0; j &lt; V; ++j) {
                if (dist[i][j] == Main.INF) {
                    System.out.print(&quot;INF &quot;);
                } else {
                    System.out.print(dist[i][j] + &quot; &quot;);
                }
            }
            System.out.println();
        }
    }
}
</java>
  <cpp>#include&lt;bits/stdc++.h&gt;
#include&lt;cstdlib&gt;
//--------------//
#define INF 9999
#define MAX 256
using namespace std;
const int V = 4;
int next[V][V];

void printPath(vector&lt;int&gt; path) {
    int n = path.size() - 1;
    for (int i = 0; i &lt; n - 1; i++) {
        cout &lt;&lt; path[i] &lt;&lt; &quot; -&gt; &quot;;
    }
    cout &lt;&lt; path[n - 1] &lt;&lt; &quot; -&gt; &quot; &lt;&lt; endl;
}

int constructPath(int u, int v) {
    if (next[u][v] == -1) {
        return 0;
    }
    vector&lt;int&gt;path;
    path.push_back(u);
    while (u != v) {
        u = next[u][v];
        path.push_back(u);
    }
    printPath(path);
    return 1;
}

void printSolution(int dist[V][V]) {
    cout &lt;&lt; &quot;La siguiente matriz muestra las distancias mas cortas entre cada par de vertices\n&quot;;
    for (int i = 0; i &lt; V; ++i) {
        for (int j = 0; j &lt; V; ++j) {
            if (dist[i][j] == INF) {
                cout &lt;&lt; &quot;INF \t&quot;;
            } else {
                cout &lt;&lt; dist[i][j] &lt;&lt; &quot;\t&quot;;
            }
        }
        cout &lt;&lt; endl;
    }
}

void floydWarshall(int graph[V][V]) {
    int dist[V][V];
    int i, j, k;
    for (i = 0; i &lt; V; i++) {
        for (j = 0; j &lt; V; j++) {
            dist[i][j] = graph[i][j];
            if (graph[i][j] == INF) {
                next[i][j] = -1;
            } else {
                next[i][j] = j;
            }
        }
    }
    for (k = 0; k &lt; V; k++) {
        for (i = 0; i &lt; V; i++) {
            for (j = 0; j &lt; V; j++) {
                if (dist[i][k] == INF || dist[k][j] == INF) {
                    continue;
                }
                if (dist[i][k] + dist[k][j] &lt; dist[i][j]) {
                    dist[i][j] = dist[i][k] + dist[k][j];
                    next[i][j] = next[i][k];
                }
            }
        }
    }
    printSolution(dist);
}

int main() {
    int E, a, b, c;
    cin&gt;&gt;E;
    int graph[V][V];
    for (int i = 0; i &lt; V; i++) {
        for (int j = 0; j &lt; V; j++) {
            graph[i][j] = INF;
        }
    }
    for (int i = 0; i &lt; V; i++) {
        graph[i][i] = 0;
    }
    for (int i = 0; i &lt; E; i++) {
        cin &gt;&gt; a &gt;&gt; b&gt;&gt;c;
        graph[a][b] = c;
    }
    floydWarshall(graph);
    constructPath(0, 3);
}
</cpp>
  <py>null</py>
  <orden>8</orden>
  <suborden>22</suborden>
  <fecha_creacion>2020-12-05 00:45:52</fecha_creacion>
  <fecha_modificacion>2020-12-06 20:30:57</fecha_modificacion>
</row>
<row>
  <ID>153</ID>
  <supergrupo>Grafos </supergrupo>
  <tema>Caminos más cortos en un grafo binario</tema>
  <texto>Dado un grafo donde cada camino tiene un peso de 0 o 1, un vértice inicial también es dado, encuentre el camino más corto desde el origen hasta cualquier otro vértice.
En el BFS normal de un grafo, todos los caminos son de igual peso, pero en BFS 0-1 ALGUNOS caminos pueden tener peso 0 y algunos 1, en este no podemos usar un array de booleanos para marcar los nodos visitados pero en cada paso podemos verificar la condición de distancia optima, usamos una cola de doble fin para almacenar el nodo, mientras realizamos BFS si un camino es encontrado con peso 0 el nodo es empujado al frente de la doble cola y si el camino tiene peso 1 es empujado atrás en la doble cola.
Esta aproximación es similar a Dijkstra en que si la distancia más corta a un nodo es relajada por el nodo anterior entonces solo será empujada en la cola.
La idea de arriba trabaja en todos los casos, cuando sacamos un vértice, es el vértice de mínimo peso de todos los vértices restantes, si hay un vértice de peso 0 adyacente a el entonces este adyacente tiene la misma distancia, si hay un adyacente de peso 1, entonces este adyacente tiene la máxima distancia de todos los vértices en la cola doble, (Porque todos los otros vértices son adyacentes de actual eliminado vértice o adyacente de los anteriores eliminados).
Este problema puede ser resuelto con Dijkstra pero el tiempo de complejidad seria de O(E + V Log V) donde por BFS puede ser de O(V+E).
</texto>
  <complejidad_tiempo>Mejor caso :    O(v+e)  Peor caso : O(v+e)  Promedio: O(v+e) </complejidad_tiempo>
  <java>//Programa java que implementa el camino más corto
// en un grafo binario

import java.util.ArrayDeque;
import java.util.ArrayList;
import java.util.Deque;

public class BinaryGraphShortestPath {
    //Número de vertices
    static int V = 9;
    // Lista de listas que almacena los caminos
    static ArrayList&lt;ArrayList&lt;node&gt;&gt; edges = new ArrayList&lt;ArrayList&lt;node&gt;&gt;();
    public static void main(String[] args) {
        for (int i = 0; i &lt; V; i++) {
            edges.add(new ArrayList&lt;&gt;());
        }
        addEdge(0, 1, 0);
        addEdge(0, 7, 1);
        addEdge(1, 7, 1);
        addEdge(1, 2, 1);
        addEdge(2, 3, 0);
        addEdge(2, 5, 0);
        addEdge(2, 8, 1);
        addEdge(3, 4, 1);
        addEdge(3, 5, 1);
        addEdge(4, 5, 1);
        addEdge(5, 6, 1);
        addEdge(6, 7, 1);
        addEdge(7, 8, 1);
        int src = 0;//Nodo inicial
        zeroOneBFS(src);
    }

    static void zeroOneBFS(int src) {
        // Inicializa las distancias desde el nodo inicial
        int dist[] = new int[V];
        for (int i = 0; i &lt; V; i++) {
            dist[i] = Integer.MAX_VALUE;
        }
        //cola doble para el BFS. 
        Deque&lt;Integer&gt; Q = new ArrayDeque&lt;&gt;();
        dist[src] = 0;
        Q.add(src);
        while (!Q.isEmpty()) {
            int v = Q.getFirst();
            Q.removeFirst();
            for (int i = 0; i &lt; edges.get(v).size(); i++) {
                //Busca la distancia optima
                if (dist[edges.get(v).get(i).to] &gt; dist[v] + edges.get(v).get(i).weight) {
                    dist[edges.get(v).get(i).to] = dist[v] + edges.get(v).get(i).weight;
                    /* pone peso caminos de peso 0 al frente y 1 atras para 
                    que los vertices puedan ser procesados en orden ascendente
                    por sus pesos*/
                    if (edges.get(v).get(i).weight == 0) {
                        Q.addFirst(edges.get(v).get(i).to);
                    } else {
                        Q.addLast(edges.get(v).get(i).to);
                    }
                }
            }
        }
        //imprimiendo los caminos más cortos
        for (int i = 0; i &lt; V; i++) {
            System.out.print(dist[i] + &quot; &quot;);
        }
        System.out.println(&quot;&quot;);
    }
    static void addEdge(int u, int v, int wt) {
        edges.get(u).add(new node(v, wt));
        edges.get(v).add(new node(u, wt));
    }
    // una estructura que representa los caminos
    static class node {
        // Dos variables, una denora el nodo
        // destino y otra el peso
        int to, weight;
        public node(int to, int weight) {
            this.to = to;
            this.weight = weight;
        }
    }
}
</java>
  <cpp>null</cpp>
  <py>null</py>
  <orden>8</orden>
  <suborden>23</suborden>
  <fecha_creacion>2020-12-05 00:45:52</fecha_creacion>
  <fecha_modificacion>2020-12-06 20:30:57</fecha_modificacion>
</row>
<row>
  <ID>154</ID>
  <supergrupo>Grafos </supergrupo>
  <tema>Grafo bipartito</tema>
  <texto>Un grafo bipartito es un grafo cuyos vértices pueden ser divididos en dos sets independientes, U y V en donde cada arista (u, v) conecta un vértice de U a V o un vértice de V a U. En otras palabras para cada arista (u,v) u pertenece a U y v pertenece a V, o viceversa, también podemos decir que no hay aristas que conecte vértices del mismo set.
Un grafo bipartito es posible si el coloramiento del grafo es posible usando dos colores los cuales los vértices de un set son coloreados del mismo color.
Una aproximación para verificar si un grafo es bipartito es verificar si el grafo es coloreable o no usando backtracking.
El siguiente es un algoritmo simple de verificación de bipartito usando  BFS.
1) Asigna el color ROJO al vértice origen (Poniéndolo en el set U)
2) Colorea todos los vecinos con color AZUL (poniéndolos en el set V)
3) Colorear todos los vecinos del vecino anterior de color ROJO (Poniéndolos en U)
4) De esta forma se asigna color a todos los vértices los cuales satisfacen todas las restricciones del coloramiento.
5) Mientras asignamos colores, si encontramos un vecino que esta coloreado del mismo color del actual vértice entonces el grafo no puede ser coloreado, es decir no es bipartito.
El algoritmo solo funciona si el grafo es fuertemente conectado, en el código siempre empezamos desde el origen 0 y asumimos que los vértices son visitados desde el, una observación importante es un  grafo sin aristas es también bipartito, 
La complejidad de tiempo de esta aproximación es la misma del BFS, O(V^2) si el grafo es representado con listas de adyacencia, se convierte en O(V+E).
</texto>
  <complejidad_tiempo>Mejor caso :    O(v+e)  Peor caso : O(v+e)  Promedio: O(v+e) </complejidad_tiempo>
  <java>//Programa java que encuentra si un grafo es 
//bipartito o no

import java.util.*;

public class BipartiteGraph {

    final static int V = 4;

    static boolean isBipartite(int G[][], int src) {
        /*Crear una matriz de colores para almacenar los 
        colores asignados a todas las verificaciones. 
        El número de vértice se utiliza como índice en 
        esta matriz. El valor &#39;-1&#39; de colorArr [i] se 
        usa para indicar que no se asigna ningún color 
        al vértice &#39;i&#39;. El valor 1 se utiliza para indicar 
        que el primer color está asignado y el valor 0 
        indica que el segundo color está asignado.*/
        int colorArr[] = new int[V];
        for (int i = 0; i &lt; V; ++i) {
            colorArr[i] = -1;
        }
        //Asigna primer color al origen
        colorArr[src] = 1;
        //Crea una cola de número de vertices
        // y encola el vertice origen 
        LinkedList&lt;Integer&gt; q = new LinkedList&lt;&gt;();
        q.add(src);
        while (!q.isEmpty()) {
            // Descola un vertice de la cola
            int u = q.poll();
            //Retorna falso si hay un autociclo
            if (G[u][u] == 1) {
                return false;
            }
            //Encuentra todos los vertoces adyacentes sin color 
            for (int v = 0; v &lt; V; ++v) {
                // Un camino de u a v existe
                // y destino v no esta coloreado
                if (G[u][v] == 1 &amp;&amp; colorArr[v] == -1) {
                    //Asigna color alternativo para esta adyacencia
                    colorArr[v] = 1 - colorArr[u];
                    q.add(v);
                } /*Un camino de u a v existe y el destino 
                esta del mismo color que u*/ 
                else if (G[u][v] == 1 &amp;&amp; colorArr[v] == colorArr[u]) {
                    return false;
                }
            }
        }
        // Si llegamos aqui, todos los vertoces adyacentes pueden
        // ser coloreados con color alternativo
        return true;
    }

    public static void main(String[] args) {
        int G[][] = {{0, 1, 0, 1},
        {1, 0, 1, 0},
        {0, 1, 0, 1},
        {1, 0, 1, 0}
        };
        if (isBipartite(G, 0)) {
            System.out.println(&quot;Si&quot;);
        } else {
            System.out.println(&quot;No&quot;);
        }
    }
}
</java>
  <cpp>#include&lt;bits/stdc++.h&gt;
#include&lt;cstdlib&gt;
using namespace std;
const int V = 4;

bool isBipartite(int G[V][V], int src) {
    int colorArr[V];
    memset(colorArr, -1, sizeof colorArr);
    colorArr[src] = 1;
    vector&lt;int&gt;q;
    q.push_back(src);
    while (!q.empty()) {
        int u = q.front();
        q.erase(q.begin());
        if (G[u][u] == 1) {
            return false;
        }
        for (int v = 0; v &lt; V; v++) {
            if (G[u][v] == 1 &amp;&amp; colorArr[v] == 1) {
                colorArr[v] = 1 - colorArr[u];
                q.push_back(v);
            } else if (G[u][v] == 1 &amp;&amp; colorArr[v] == colorArr[u]) {
                return false;
            }
        }
    }
    return true;
}

int main() {
    int G[V][V] = {
        {0, 1, 0, 1},
        {1, 0, 1, 0},
        {0, 1, 0, 1},
        {1, 0, 1, 0}};
    if (isBipartite(G, 0)) {
        cout &lt;&lt; &quot;Es bipartito&quot; &lt;&lt; endl;
    } else {
        cout &lt;&lt; &quot;NO Es bipartito&quot; &lt;&lt; endl;
    }
}
</cpp>
  <py>V = 4

def isBipartite(G, src):
    global V
    colorarr = [-1 for x in range(V)]
    colorarr[src] = 1
    q = []
    q.append(src)
    while not len(q) == 0:
        u = q.pop()
        if G[u][u] == 1:
            return False
    for v in range(V):
        if G[u][v] == 1 and colorarr[v] == -1:
            colorarr[v] = 1 - colorarr[u]
            q.append(v)
        elif G[u][v] and colorarr[v] == colorarr[u]:
            return False
    return True

G = [[0, 1, 0, 1], [1, 0, 1, 0], [0, 1, 0, 1], [1, 0, 1, 0]]
if isBipartite(G, 0):
    print(&quot;Es bipartitio&quot;)
else:
    print(&quot;No es bipartitio&quot;)

</py>
  <orden>8</orden>
  <suborden>24</suborden>
  <fecha_creacion>2020-12-05 00:45:53</fecha_creacion>
  <fecha_modificacion>2020-12-06 20:30:58</fecha_modificacion>
</row>
<row>
  <ID>155</ID>
  <supergrupo>Grafos </supergrupo>
  <tema>Union Find</tema>
  <texto>Una estructura de datos para conjuntos disjuntos, es una estructura de datos que mantiene un conjunto de elementos particionados en un número de conjuntos disjuntos no se solapan los conjuntos). Un algoritmo Unión-Buscar es un algoritmo que realiza dos importantes operaciones en esta estructura de datos:
Buscar: Determina a cual subconjunto pertenece un elemento. Esta operación puede usarse para verificar si dos elementos están en el mismo conjunto.
Union: Une dos subconjuntos en uno solo.
La otra operación importante CrearConjunto es generalmente trivial, esta crea un conjunto con un elemento dado. Con estas tres operaciones, muchos problemas prácticos de particionamiento pueden ser resueltos.
Con el fin de definir estas operaciones más precisamente, es necesario representar los conjuntos de alguna manera. Una aproximación común es seleccionar un elemento fijo de cada conjunto, llamado el representativo, para representar el conjunto como un todo. Entonces Buscar(x) retorna el elemento representativo del conjunto al cual x pertenece, y Unión toma como argumento dos elementos representativos de dos conjuntos respectivamente.
</texto>
  <complejidad_tiempo>Mejor caso :    O(v+e)  Peor caso : O(v+e)  Promedio: O(v+e) </complejidad_tiempo>
  <java>//Programa java que usa el algoritmo UNION FIND 
// para verificar componentes conexas
/*
INPUT
9 7
2 0
7 0
3 1
1 0
6 4
8 5
4 5
 */
import java.util.*;

public class UnionFind {

    static final int MAX = 10005; //maximo número de vértices
    static int padre[] = new int[MAX]; //Este arreglo contiene el padre del i-esimo nodo
    static int rango[] = new int[MAX]; //profundidad de cada vértice

    //Método de inicialización
    static void MakeSet(int n) {
        for (int i = 0; i &lt; n; ++i) {
            padre[i] = i; //Inicialmente el padre de cada vértice es el mismo vértice
            rango[i] = 0; //Altura o rango de cada vértice es 0
        }
    }   
    //Método para encontrar la raiz del vértice actual X
    static int Find(int x) {
        if (x == padre[x]) { //Si estoy en la raiz
            return x; //Retorno la raiz
        } //else return Find( padre[ x ] ); //De otro modo busco el padre del vértice actual, hasta llegar a la raiz.
        else {
            return padre[x] = Find(padre[x]); //Compresion de caminos
        }
    }
    //Método para unir 2 componentes conexas
    static void Union(int x, int y) {
        int xRoot = Find(x); //Obtengo la raiz de la componente del vértice X
        int yRoot = Find(y); //Obtengo la raiz de la componente del vértice Y
        padre[xRoot] = yRoot; //Mezclo ambos arboles o conjuntos, actualizando su padre de alguno de ellos como la raiz de otro
    }

    //Método para unir 2 componentes conexas usando sus alturas (rangos)
    static void UnionbyRank(int x, int y) {
        int xRoot = Find(x); //Obtengo la raiz de la componente del vértice X
        int yRoot = Find(y); //Obtengo la raiz de la componente del vértice Y
        if (rango[xRoot] &gt; rango[yRoot]) { //en este caso la altura de la componente del vértice X es
            //mayor que la altura de la componente del vértice Y.
            padre[yRoot] = xRoot; //el padre de ambas componentes será el de mayor altura
        } else { //en este caso la altura de la componente del vértice Y es mayor o igual que la de X
            padre[xRoot] = yRoot; //el padre de ambas componentes será el de mayor altura
            if (rango[xRoot] == rango[yRoot]) { //si poseen la misma altura
                rango[yRoot]++; //incremento el rango de la nueva raíz
            }
        }
    }

    static int root[] = new int[MAX]; //tendra las raices de las componentes conexas luego de aplicar el método
    static int numComponentes; //variable para el número total de componentes conexas
    //Método para obtener el número de componentes conexas luego de realizar las conexiones respectivas

    static int getNumberConnectedComponents(int n) {
        numComponentes = 0;
        for (int i = 0; i &lt; n; ++i) {
            if (padre[i] == i) { //Si el padre del vértice i es el mismo vértice entonces es raíz
                //if( Find( i ) == i ){ //podemos usamos find para el mismo proposito y
                //para que se realice compresion de caminos
                root[numComponentes++] = i; //almaceno la raiz de cada nueva componente
                // numComponentes++;
            }
        }
        return numComponentes;
    }

    static int numVertices[] = new int[MAX]; //almacenara la cantidad de vértices para la i-esima raiz.
    //Método para obtener la raiz y el número de vértices de cada componente conexa
    //será necesario primero tener la cantidad de componentes conexas
    //podemos llamar 1ero al metodo getNumberConnectedComponents o incluir porcion de su codigo en este

    static void getNumberNodes(int n) {
        Arrays.fill(numVertices, 0); //inicializo mi contador de vértices
        for (int i = 0; i &lt; n; ++i) {
            numVertices[Find(i)]++; //incremento la raíz del vértice i
        }
        for (int i = 0; i &lt; numComponentes; ++i) {
            System.out.printf(&quot;Componente %d: Raiz = %d , Nro nodos = %d.\n&quot;, i + 1, root[i], numVertices[root[i]]);
        }
    }

    //Método que me determina si 2 vértices estan o no en la misma componente conexa
    static boolean sameComponent(int x, int y) {
        if (Find(x) == Find(y)) {
            return true; //si poseen la misma raíz
        }
        return false;
    }

    public static void main(String[] args) {
        int V, E, origen, destino;
        Scanner sc = new Scanner(System.in);
        V = sc.nextInt();
        E = sc.nextInt(); //tengamos número de vertices y aristas
        MakeSet(V); //inicializamos los conjuntos
        for (int i = 0; i &lt; E; ++i) {
            origen = sc.nextInt();
            destino = sc.nextInt();
            UnionbyRank(origen, destino); //union de elementos
        }
        System.out.printf(&quot;El número de componentes conexas es: %d\n&quot;, getNumberConnectedComponents(V));
        getNumberNodes(V);

    }

}
</java>
  <cpp>null</cpp>
  <py>null</py>
  <orden>8</orden>
  <suborden>25</suborden>
  <fecha_creacion>2020-12-05 00:45:53</fecha_creacion>
  <fecha_modificacion>2020-12-06 20:30:59</fecha_modificacion>
</row>
<row>
  <ID>156</ID>
  <supergrupo>Grafos </supergrupo>
  <tema>Árbol de expansión mínima de Kruskal</tema>
  <texto>Dado un grafo conexo y no dirigido, un árbol de expansión del grafo es el subgrafo que es el árbol que conecta todos los vértices juntos, un solo grafo puede tener muchos árboles de expansión diferentes, un árbol de expansión mínima (MST) o árbol de expansión de peso mínimo para un grafo ponderado, conexo y no dirigido es el árbol de expansión con el peso menor o igual a cualquier otro árbol de expansión. El peso de un árbol de expansión es la suma de los pesos dados en cada camino del árbol de expansión.
¿Cuantos caminos tiene un árbol de expansión mínima?
Un MST tiene (V-1) caminos donde V es el número de vértices en el grafo dado.
Los siguientes son los pasos para encontrar el MST con el algoritmo de Kruskal.
1) ordene todos los caminos en orden incremental dado su peso.
2) Tome el camino más pequeño, verifique si forma un ciclo con el árbol formado hasta ahora, si el ciclo no es formado, incluya este camino, si no descártelo
3) Repita el paso 2 hasta que haya (V-1) caminos en el árbol de expansión.
El paso 2 usa el algoritmo Union-Find para detectar ciclos.
El algoritmo es un algoritmo voraz, la voracidad escogida es tomar el camino de tamaño más pequeño lo que no causa un ciclo en el MST construido hasta ese punto
La complejidad de tiempo de este algoritmo es de O(ElogE) or O(ElogV). Ordenar los caminos toma O(ELogE) tiempo, luego de ordenar iteramos a través de todos los caminos y aplicamos el algoritmo Union-Find, Las operaciones de unir y encontrar puede tomar al menos O(LogV) tiempo, entonces la complejidad completa es O(ELogE + ELogV) tiempo. El valor de W puede ser al menos O (V^2) entonces O (LogV) son O (LogE) iguales. 
</texto>
  <complejidad_tiempo>Mejor caso :    O(eLog(e)+ eLog(v))  Peor caso : O(eLog(e)+ eLog(v)) 
Promedio: O(eLog(e)+ eLog(v)) 
</complejidad_tiempo>
  <java>//Implementación java de busqueda del 
// arbol de expansión minima usando el algoritmo de Kruskal
/*
 EJEMPLO DE INPUT
 9 14
 1 2 4
 1 8 9
 2 3 9
 2 8 11
 3 4 7
 3 9 2
 3 6 4
 4 5 10
 4 6 15
 5 6 11
 6 7 2
 7 8 1
 7 9 6
 8 9 7

 EJEMPLO VERIFICACION DE MST
9 11
 1 2 4
 1 8 9
 2 3 9
 2 8 11
 3 9 2
 7 8 1
 7 9 6
 8 9 7
 4 5 10
 4 6 15
 5 6 11
 */
import java.util.Arrays;
import java.util.Comparator;
import java.util.Scanner;

public class KruskalMST {

    static final int MAX = 1005; //maximo número de vértices
    //UNION-FIND
    static int padre[] = new int[MAX]; //Este arreglo contiene el padre del i-esimo nodo
    //Método de inicialización
    static void MakeSet(int n) {
        for (int i = 1; i &lt;= n; ++i) {
            padre[i] = i;
        }
    }
    //Método para encontrar la raiz del vértice actual X
    static int Find(int x) {
        return (x == padre[x]) ? x : (padre[x] = Find(padre[x]));
    }
    //Método para unir 2 componentes conexas
    static void Union(int x, int y) {
        padre[Find(x)] = Find(y);
    }
    //Método que me determina si 2 vértices estan o no en la misma componente conexa
    static boolean sameComponent(int x, int y) {
        if (Find(x) == Find(y)) {
            return true;
        }
        return false;
    }
    ///FIN UNION-FIND
    static int V, E; //número de vertices y aristas
    //Estructura arista( edge )

    static class Edge implements Comparator&lt;Edge&gt; {
        int origen; //Vértice origen
        int destino; //Vértice destino
        int peso; //Peso entre el vértice origen y destino
        Edge() {
        }
        //Comparador por peso, me servira al momento de ordenar lo realizara en orden ascendente
        //Ordenar de forma descendente para obtener el arbol de expansion maxima
        @Override
        public int compare(Edge e1, Edge e2) {
            //return e2.peso - e1.peso; //Arbol de expansion maxima
            return e1.peso - e2.peso; //Arbol de expansion minima
        }
    };

    static Edge arista[] = new Edge[MAX]; //Arreglo de aristas para el uso en kruskal
    static Edge MST[] = new Edge[MAX]; //Arreglo de aristas del MST encontrado
    static void KruskalMST() {
        int origen, destino, peso;
        int total = 0; //Peso total del MST
        int numAristas = 0; //Número de Aristas del MST
        MakeSet(V); //Inicializamos cada componente
        Arrays.sort(arista, 0, E, new Edge()); //Ordenamos las aristas por su comparador
        for (int i = 0; i &lt; E; ++i) {
            origen = arista[i].origen; //Vértice origen de la arista actual
            destino = arista[i].destino; //Vértice destino de la arista actual
            peso = arista[i].peso; //Peso de la arista actual
            //Verificamos si estan o no en la misma componente conexa
            if (!sameComponent(origen, destino)) { //Evito ciclos
                total += peso; //Incremento el peso total del MST
                MST[numAristas++] = arista[i]; //Agrego al MST la arista actual
                Union(origen, destino); //Union de ambas componentes en una sola
            }
        }

        //Si el MST encontrado no posee todos los vértices mostramos mensaje de error
        //Para saber si contiene o no todos los vértices basta con que el número
        //de aristas sea igual al número de vertices - 1
        if (V - 1 != numAristas) {
            System.out.println(&quot;No existe MST valido para el grafo ingresado, el grafo debe ser conexo.&quot;);
            return;
        }
        System.out.println(&quot;-----El MST encontrado contiene las siguientes aristas-----&quot;);
        for (int i = 0; i &lt; numAristas; ++i) {
            System.out.printf(&quot;( %d , %d ) : %d\n&quot;, MST[i].origen, MST[i].destino, MST[i].peso);
        }
        System.out.printf(&quot;El costo minimo de todas las aristas del MST es : %d\n&quot;, total);
    }

    //( vertice u , vertice v ) : peso
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in); //para lectura de datos
        V = sc.nextInt();
        E = sc.nextInt();
        //Realizamos el ingreso del grafo, almacenando las aristas en un arreglo con los datos respectivos
        for (int i = 0; i &lt; E; ++i) {
            arista[i] = new Edge();
            arista[i].origen = sc.nextInt();
            arista[i].destino = sc.nextInt();
            arista[i].peso = sc.nextInt();
            //arista[ i ] = new Arista( sc.nextInt() , );
        }
        KruskalMST();
    }
}
</java>
  <cpp>#include &lt;bits/stdc++.h&gt;
#define MAX 1005
using namespace std;
int padre[MAX];

struct Edge {
    int origen, destino, peso;

    bool operator&lt;(const Edge &amp;t) {
        return peso &lt; t.peso;
    }
};
//set de nodos para indicar cuales son sus padre e hijos

void makeSet(int n) {
    for (int i = 0; i &lt;= n; i++) {
        padre[i] = i;
    }
}

int find(int x) {
    return (x == padre[x] ? x : (padre[x] = find(padre[x])));
}

void Union(int x, int y) {
    padre[find(x)] = find(y);
}

bool sameComponent(int x, int y) {
    if (find(x) == find(y)) {
        return true;
    }
    return false;
}
Edge aristas[MAX];
Edge MST[MAX];
vector&lt;Edge&gt;vec;

void KruskalMST(int V, int E) {
    int origen, destino, peso;
    int total = 0;
    int numAristas = 0;
    makeSet(V);
    sort(vec.begin(), vec.end());
    for (int i = 0; i &lt; E; i++) {
        origen = vec[i].origen;
        destino = vec[i].destino;
        peso = vec[i].peso;
        if (!sameComponent(origen, destino)) {
            total += peso;
            MST[numAristas++] = vec[i];
            Union(origen, destino);
        }
    }
    if (V - 1 != numAristas) {
        cout &lt;&lt; &quot;No existe MST valido para el grafo ingresado este debe ser conexo&quot; &lt;&lt; endl;
        return;
    }
    cout &lt;&lt; &quot;MST encontrado contiene las siguientes aristas&quot; &lt;&lt; endl;
    for (int i = 0; i &lt; numAristas; i++) {
        cout &lt;&lt; MST[i].origen &lt;&lt; &quot;,&quot; &lt;&lt; MST[i].destino &lt;&lt; &quot;:&quot; &lt;&lt; MST[i].peso &lt;&lt; endl;
    }
    cout &lt;&lt; &quot;el costo minimo de todas las aristas de MST es : &quot; &lt;&lt; total &lt;&lt; endl;
}

int main() {
    int V, E;
    cin &gt;&gt; V&gt;&gt;E;
    for (int i = 0; i &lt; E; i++) {
        Edge aristas[i];
        cin &gt;&gt; aristas[i].origen;
        cin &gt;&gt; aristas[i].destino;
        cin &gt;&gt; aristas[i].peso;
        vec.push_back(aristas[i]);
    }
    KruskalMST(V, E);
}
</cpp>
  <py>null</py>
  <orden>8</orden>
  <suborden>26</suborden>
  <fecha_creacion>2020-12-05 00:45:53</fecha_creacion>
  <fecha_modificacion>2020-12-06 20:30:59</fecha_modificacion>
</row>
<row>
  <ID>157</ID>
  <supergrupo>Grafos </supergrupo>
  <tema>Árbol de expansión mínima de Prim</tema>
  <texto>El algoritmo de Prim es también un algoritmo voraz, comienza con un árbol de expansión vacío, la idea es mantener dos conjuntos de vértices, el primero contiene los vértices ya incluidos en el MST, la otra contiene los vértices que no han sido incluidos aun, en cada paso, se considera todos los caminos que conectan dos sets, y toma el camino con mínimo peso de esos caminos, luego de tomar el camino, se mueve el otro punto final del camino al set conteniendo el MST.
Un grupo de caminos que conectan dos sets de vértices en un grafo es llamado corte en la teoría de grafos, entonces en cada paso del algoritmo de Prim, nosotros buscamos un corte (de dos conjuntos, uno contiene los vértices ya en el MST y el otro el resto de vértices), tome el camino de mínimo peso del corte e incluye este vértice al conjunto MST. 

La idea detrás del algoritmo de Prim es simple, un árbol de expansión significa que todos los vértices deben estar conectados, entonces los dos conjuntos disjuntos de vértices deben estar conectados para hacer un árbol de expansión. Y ellos deben estar conectados con el camino de peso mínimo para realizar un árbol de expansión mínima.
1) Crear un set mstSet que mantenga rastro de los vértices ya incluidos en el MST.
2) Asignar un valor key a todos los vértices en el grafo de entrada, inicializar los valores key como INFINITO, asignar el valor key como 0 para el primer vértice entonces este es tomado primero.
3) Mientras mstSet no incluya todos los vértices.
a) Tomar un vértice u el cual no esté en el mstSet y tenga el valor key mínimo
b) Incluir u al mstSet
c) Actualizar el valor key de todos los vértices adyacentes de u, para actualizar los valores key, se itera a través de todos los vértices adyacentes v, si el peso del camino u-v es menos que el valor key anterior de v, actualice el valor key como peso de u-v.
La idea de usar valores key es tomar el camino de mínimo peso como el corte, los valores key son usados únicamente por los vértices que no han sido incluidos en el MST, el valor key de estos vértices indican los caminos de peso mínimo conectándolos con el set de vértices incluidos en el MST.
Por ejemplo:

- El set mstSet esta inicialmente vacío y los keys asignados a los vértices son {0, INF, INF, INF, INF, INF, INF, INF} donde INF indica infinito, ahora tomamos el vértices con el valor key menor el vértice 0 es tomado, se incluye en el mstSetm entonces mstSet se convierte en {0}, luego de incluir al mstSet, se actualizan los valores key de los vértices adyacentes, los vértices adyacentes  de 0 son 1 y 7, los valores key de 1 y 7 son actualizados como 4 y 8.
- Se toma el vértice con el menor valor key y no incluido ya en el MST, (no en mstSet), el vértice 1 es tomado y añadido al mstSet por lo que se convierte en {0,1}, se actualiza los valores key de los vértices adyacentes de 1, el valor key del vértice 2 se convierte en 8.
- Se toma el vértice con el valor key mínimo y no incluido en MST, podemos tomar el vértice 7 o 2, tomaremos el 7, entonces el mstSet es {0,1,7}, actualizamos los valores key de los vértices adyacentes de 7, el valor key del vértice 6 y 8 se convierten en finitos, en 1 y 7.
- Tome el vértice con el valor key mínimo, y no incluido ya en MST, el vértice 6 es tomado entonces el mstSet se convierte en {0,1,7,6}, se actualizan los valores key y los vértices adyacentes de 6m el valor de 5 y 8 es actualizado.
- Repetimos los pasos de arriba hasta que mstSet incluya todos los vértices del grafo dado.
</texto>
  <complejidad_tiempo>Mejor caso :    O(v3) Peor caso : O(v3) Promedio: O(v3) </complejidad_tiempo>
  <java>//Programa java que calcula el MST de un grafo

import java.util.LinkedList;
import java.util.PriorityQueue;
import java.util.Comparator;

public class PrimMSTFULL {

    public static void main(String[] args) {
        int V = 9;
        Graph graph = new Graph(V);
        addEdge(graph, 0, 1, 4);
        addEdge(graph, 0, 7, 8);
        addEdge(graph, 1, 2, 8);
        addEdge(graph, 1, 7, 11);
        addEdge(graph, 2, 3, 7);
        addEdge(graph, 2, 8, 2);
        addEdge(graph, 2, 5, 4);
        addEdge(graph, 3, 4, 9);
        addEdge(graph, 3, 5, 14);
        addEdge(graph, 4, 5, 10);
        addEdge(graph, 5, 6, 2);
        addEdge(graph, 6, 7, 1);
        addEdge(graph, 6, 8, 6);
        addEdge(graph, 7, 8, 7);
        prims_mst(graph);
    }

    static class node1 {
        int dest;
        int weight;
        node1(int a, int b) {
            dest = a;
            weight = b;
        }
    }

    static class Graph {
        int V;
        LinkedList&lt;node1&gt;[] adj;
        Graph(int e) {
            V = e;
            adj = new LinkedList[V];
            for (int o = 0; o &lt; V; o++) {
                adj[o] = new LinkedList&lt;&gt;();
            }
        }
    }

    static class node {
        int vertex;
        int key;
    }

    /* Comparador de la priorityQueue
     retorna 1 si node0.key &gt; node1.key 
     retorna 0 si node0.key &lt; node1.key y
    retorna -1 otherwise */
    static class comparator implements Comparator&lt;node&gt; {

        @Override
        public int compare(node node0, node node1) {
            return node0.key - node1.key;
        }
    }
    static void addEdge(Graph graph, int src, int dest, int weight) {
        node1 node0 = new node1(dest, weight);
        node1 node = new node1(src, weight);
        graph.adj[src].addLast(node0);
        graph.adj[dest].addLast(node);
    }

    // Buscar MST
    static void prims_mst(Graph graph) {
        Boolean[] mstset = new Boolean[graph.V];
        node[] e = new node[graph.V];
        int[] parent = new int[graph.V];
        for (int o = 0; o &lt; graph.V; o++) {
            e[o] = new node();
        }
        for (int o = 0; o &lt; graph.V; o++) {
            //inicializar en falso
            mstset[o] = false;
            // Inicial valores key en infinito
            e[o].key = Integer.MAX_VALUE;
            e[o].vertex = o;
            parent[o] = -1;
        }
        // incluir el vertice inicial en el MST
        mstset[0] = true;
        e[0].key = 0;
        PriorityQueue&lt;node&gt; queue = new PriorityQueue&lt;&gt;(graph.V, new comparator());
        for (int o = 0; o &lt; graph.V; o++) {
            queue.add(e[o]);
        }
        while (!queue.isEmpty()) {
            node node0 = queue.poll();
            mstset[node0.vertex] = true;
            for (node1 iterator : graph.adj[node0.vertex]) {
                if (mstset[iterator.dest] == false) {
                    if (e[iterator.dest].key &gt; iterator.weight) {
                        queue.remove(e[iterator.dest]);
                        e[iterator.dest].key = iterator.weight;
                        queue.add(e[iterator.dest]);
                        parent[iterator.dest] = node0.vertex;
                    }
                }
            }
        }
        // Imprimir el par de vertices del mst 
        for (int o = 1; o &lt; graph.V; o++) {
            System.out.println(parent[o] + &quot; &quot;
                    + &quot;-&quot;
                    + &quot; &quot; + o);
        }
    }
}

//Version 2:
//Programa java que busca el arbol de expansión 
// minima de minimo costo

import java.util.ArrayList;
import java.util.List;
import java.util.PriorityQueue;
import java.util.Scanner;

public class PrimMSTMinValue {

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        N = sc.nextInt();
        G = new Vertex[N];
        for (int i = 0; i &lt; G.length; i++) {
            G[i] = new Vertex();
        }
        E = sc.nextInt();
        for (int i = 0; i &lt; E; i++) {
            int from, to, w;
            from = sc.nextInt();
            to = sc.nextInt();
            w = sc.nextInt();
            G[from].adj.add(new Edge(to, w));
            G[to].adj.add(new Edge(from, w));
        }
        System.out.println(prim());

    }

    static PriorityQueue&lt;QueueItem&gt; Q;
    static int E;
    static boolean[] intree;
    static int N;
    static Vertex[] G;
    
    static class QueueItem implements Comparable&lt;QueueItem&gt; {
        int v, w;
        public QueueItem(int v, int w) {
            this.v = v;
            this.w = w;
        }
        @Override
        public int compareTo(QueueItem q) {
            if (this.w != q.w) {
                return this.w - q.w;
            }
            return this.v - q.v;
        }
    }

    static void process(int u) {
        intree[u] = true;
        G[u].adj.forEach((e) -&gt; {
            int v = e.to, w = e.w;
            if (!intree[v]) {
                Q.offer(new QueueItem(v, w));
            }
        });
    }

    static int prim() {
        intree = new boolean[N];
        Q = new PriorityQueue&lt;&gt;();
        int cost = 0;
        process(0);
        while (!Q.isEmpty()) {
            QueueItem qi = Q.poll();
            int v = qi.v, w = qi.w;
            if (!intree[v]) {
                cost += w;
                process(v);
            }
        }
        return cost;
    }

    static class Vertex {
        List&lt;Edge&gt; adj;
        public Vertex() {
            adj = new ArrayList&lt;&gt;();
        }
    }

    static class Edge {
        int to, w;
        public Edge(int to, int w) {
            this.to = to;
            this.w = w;
        }
    }
}
</java>
  <cpp>null</cpp>
  <py>null</py>
  <orden>8</orden>
  <suborden>27</suborden>
  <fecha_creacion>2020-12-05 00:45:54</fecha_creacion>
  <fecha_modificacion>2020-12-06 20:31:00</fecha_modificacion>
</row>
<row>
  <ID>158</ID>
  <supergrupo>DP</supergrupo>
  <tema>Knapsack 0/1</tema>
  <texto>Dados pesos y valores de n ítems, ponga esos ítems en una mochila de capacidad W, para obtener el máximo valor total en la mochila, en otras palabras dados dos arrays de enteros val[0..n-1] y wt[0…-1] los cuales representan los valores y pesos asociados a los n ítems respectivamente. También dado un entero W el cual representa la capacidad de la mochila, encuentre el máximo valor subset de val[] tal que esa suma de los pesos de este subset es menor o igual a w, no se puede romper un ítem, se tiene que tomar o no tomar, (propiedad 0-1).
Una simple solución es considerar todos los subsets de ítems y calcular el peso total y valor de todos los subsets, considere solo los subsets los cuales el peso total es menor a W, de todos los subsets tome el que tenga el máximo valor de peso.
Considere todos los subsets de ítems, puede haber dos casos para cada ítem:
1) El ítem está incluido en el subset optimo
2) El ítem no está incluido en el subset optimo
Con esto, el máximo valor puede ser obtenido de n ítems es máximo siguiendo los dos siguientes valores,
1) El máximo valor obtenido por n-1 ítems y peso W (Excluyendo el enésimo ítem)
2) Valor del enésimo ítem más el máximo valor obtenido por n-1 ítems y W menos el peso del enésimo ítem (Incluyendo el enésimo ítem).
SI el peso del enésimo ítem es mayor que W, entonces el enésimo ítem no puede ser incluido y el caso 1 es la única posibilidad.
Desde que los subproblemas son evaluados de nuevo, este problema tiene la propiedad de sobreponer subproblemas. Entonces el problema de  la mochila 0-1 tiene ambas propiedades de un problema de programación dinámica, como otros problemas de programación dinámica, recomputaciones de subproblemas iguales pueden ser evadidos construyendo una matriz temporal desde el fondo, el código usa esta metodología.
La complejidad de tiempo de este algoritmo es de O(nW) donde n es el número de ítems y W el peso de la mochila.
</texto>
  <complejidad_tiempo>null</complejidad_tiempo>
  <java>/*Implementación java del problema 0-1 Knapsack */
public class KnapsackRecursive {
//Función de utilidad que retorna el mayor de dos números

    static int max(int a, int b) {
        return (a &gt; b) ? a : b;
    }
    // Retorna el maximo valor que puede ser 
    //Puesto en una knapsack de capacidad w

    static int knapSack(int W, int wt[], int val[], int n) {
        // Caso base
        if (n == 0 || W == 0) {
            return 0;
        }
        /*Si el peso de el nesimo item es más
        que la capacidad el knapsack, entonces
        este item no puede ser icluido en una 
        solución optima*/
        if (wt[n - 1] &gt; W) {
            return knapSack(W, wt, val, n - 1);
        } // Retorna el maximo de dos casos:
        //1) nesimo termino incluido
        //2) no incluido
        else {
            return max(val[n - 1] + knapSack(W - wt[n - 1], wt, val, n - 1),
                    knapSack(W, wt, val, n - 1));
        }
    }

    public static void main(String args[]) {
        int val[] = new int[]{60, 100, 120};
        int wt[] = new int[]{10, 20, 30};
        int W = 50;
        int n = val.length;
        System.out.println(knapSack(W, wt, val, n));
    }
}
// Implementación java que usa programación dinamica
// para solucionar el problema de 0-1 Knapsack

public class KnapsackDP {
    //Función de utilidad que retorna el maximo de dos enteros
    static int max(int a, int b) {
        return (a &gt; b) ? a : b;
    }
    // Retorna el maximo valor que puede ser puesto en un
    //knapsack de capacidad w
    static int knapSack(int W, int wt[], int val[], int n) {
        int i, w;
        int K[][] = new int[n + 1][W + 1];
        // Construye la tabla K[][]de abajo hacia arriba
        for (i = 0; i &lt;= n; i++) {
            for (w = 0; w &lt;= W; w++) {
                if (i == 0 || w == 0) {
                    K[i][w] = 0;
                } else if (wt[i - 1] &lt;= w) {
                    K[i][w] = max(val[i - 1]
                            + K[i - 1][w - wt[i - 1]], K[i - 1][w]);
                } else {
                    K[i][w] = K[i - 1][w];
                }
            }
        }

        return K[n][W];
    }

    public static void main(String args[]) {
        int val[] = new int[]{60, 100, 120};
        int wt[] = new int[]{10, 20, 30};
        int W = 50;
        int n = val.length;
        System.out.println(knapSack(W, wt, val, n));
    }
}
</java>
  <cpp>null</cpp>
  <py>null</py>
  <orden>9</orden>
  <suborden>0</suborden>
  <fecha_creacion>2020-12-05 00:45:54</fecha_creacion>
  <fecha_modificacion>2020-12-06 20:32:33</fecha_modificacion>
</row>
<row>
  <ID>159</ID>
  <supergrupo>DP</supergrupo>
  <tema>Cambio de monedas</tema>
  <texto>Dado un valor N, si queremos hacer el cambio de N centavos y tenemos suministros infinitos de cada uno de las S = {S1, S2,.., Sm} monedas con valor, ¿de cuantas formas podemos hacer el cambio? El orden de las monedas no importa
Dado un valor N, queremos hacer el cambio por N centavos, y tenemos suministros de cada una, por  ejemplo, para N=4, y S={1,2,3}, existen 4 soluciones {1,1,1,1},{1,1,2},{2,2},{1,3}. Entonces la salida debe ser 4, para N=10, y S={2,5,3,6} existen 6 soluciones {2,2,2,2,2}, {2,2,3,3}, {2,2,6}, {2,3,5} y {5,5}. Entonces la salida debe ser 5.
Para contar el total el números de soluciones podemos dividir todos los sets solución en dos sets.
1) Soluciones que no contienen emesima moneda o Sm.
2) Soluciones que al menos contienen una Sm.
Dejaremos ser count(S[],m,n) la función de conteo del número de soluciones, luego estas pueden ser escritas como suma de count(S[], m-1, n) y count(S[], m, n-Sm).
Por lo tanto, el problema tiene una propiedad se subestructura optima haciendo que el problema pueda ser resuelto usando soluciones a subproblemas.
Complejidad de tiempo: O(mn)
</texto>
  <complejidad_tiempo>null</complejidad_tiempo>
  <java>// Programa java que resuelve el problema
// del cambio de monedas

public class CoinExchange {

    // Retorna el conteo de formás que podemos
    // sumar S[0...m-1] monedas para obtener n 
    static int count(int S[], int m, int n) {
        // Si n es 0 entonces 1 es la solución 
        // (No incluir ninguna moneda 
        if (n == 0) {
            return 1;
        }
        // Si n es menos que 0 entonces no hay solución
        if (n &lt; 0) {
            return 0;
        }
        /*Si no hay monedas y n es mayor que 0, no existe solución*/
        if (m &lt;= 0 &amp;&amp; n &gt;= 1) {
            return 0;
        }
        // count es la suma de las soluciónes (i) 
        // incluyendo S[m-1] (ii) excluyendo S[m-1] 
        return count(S, m - 1, n)
                + count(S, m, n - S[m - 1]);
    }

    public static void main(String[] args) {
        int arr[] = {1, 2, 3};
        int m = arr.length;
        System.out.println(count(arr, m, 4));
    }
}
</java>
  <cpp>null</cpp>
  <py>null</py>
  <orden>9</orden>
  <suborden>1</suborden>
  <fecha_creacion>2020-12-05 00:45:54</fecha_creacion>
  <fecha_modificacion>2020-12-06 20:32:33</fecha_modificacion>
</row>
<row>
  <ID>160</ID>
  <supergrupo>DP</supergrupo>
  <tema>Longest Increasing Subsequence</tema>
  <texto>El problema de la  secuencia incremental más larga (LIS), es encontrar la longitud de la subsecuencia más larga dada una secuencia la cual todos los elementos de la subsecuencia están ordenados en orden ascendente, por ejemplo la longitud de a LIS para {10, 22, 9, 33, 21, 50, 41, 60, 80} es 6 y LIS es {10, 22, 33, 50, 60, 80}.
Dejaremos arr [0...n-1] ser el array de entrada y L(i) ser la longitud de la LIS finalizando en el índice I tal que arr[i] es el último elemento de la LIS.
Entonces L(i) puede ser recursivamente escrito como:
L(i) = 1 + max( L(j) ) donde 0 &lt; j &lt; i y arr[j] &lt; arr[i]; 
o
L(i) = 1, Si no existe tal j.
Para encontrar la LIS de un array dado, necesitamos retornar max(L(i)) donde 0 &lt; i &lt; n.
Por lo tanto vemos que el problema LIS satisface la propiedad de la subestructura óptima como el problema principal puede ser resuelto usando soluciones a subproblemas.

Note que la complejidad de tiempo de esta programación dinámica es O(nLogn).
</texto>
  <complejidad_tiempo>null</complejidad_tiempo>
  <java>
public class LongestIncreasingSubsequence {

    static int max_ref;

    /* Para hacer uso de llamadas recursivas, esta función debe devolver.
   dos cosas:
   1) Longitud de LIS que termina con el elemento arr [n-1]. Usamos
      max_ending_here para este propósito
   2) Máximo global ya que el LIS puede terminar con un elemento
      antes de arr [n-1] max_ref se usa para este propósito.
   El valor de LIS de la matriz completa de tamaño n se almacena en
   * max_ref cual es nuestro resultado final*/
    static int _lis(int arr[], int n) {
        // Caso base
        if (n == 1) {
            return 1;
        }
        // &#39;max_ending_here&#39; es el tamaño de LIS 
        // terminando con arr[n-1] 
        int res, max_ending_here = 1;
        for (int i = 1; i &lt; n; i++) {
            res = _lis(arr, i);
            if (arr[i - 1] &lt; arr[n - 1] &amp;&amp; res + 1 &gt; max_ending_here) {
                max_ending_here = res + 1;
            }
        }
        if (max_ref &lt; max_ending_here) {
            max_ref = max_ending_here;
        }
        return max_ending_here;
    }

    static int lis(int arr[], int n) {
        // Guarda el resultado 
        max_ref = 1;
        //Almacena su resultado en max 
        _lis(arr, n);
        //Retorna el maximo
        return max_ref;
    }

    public static void main(String args[]) {
        int arr[] = {10, 22, 9, 33, 21, 50, 41, 60};
        int n = arr.length;
        System.out.println(&quot;Tamaño de la subsecuencia incremental más larga&quot;
                + &quot; es &quot; + lis(arr, n) + &quot;\n&quot;);
    }
}
</java>
  <cpp>null</cpp>
  <py>null</py>
  <orden>9</orden>
  <suborden>2</suborden>
  <fecha_creacion>2020-12-05 00:45:55</fecha_creacion>
  <fecha_modificacion>2020-12-06 20:32:34</fecha_modificacion>
</row>
<row>
  <ID>161</ID>
  <supergrupo>DP</supergrupo>
  <tema>Longest Common SubString</tema>
  <texto>Dados dos strings X y Y encuentre el substring común más largo. Dejaremos que M y N sean las longitudes del primer y segundo string respectivamente.
Una simple solución es uno por uno considerar todos los substrings del primer string y por cada substring verificar su es un substring en el segundo substring, mantenemos rastro del string de longitud máxima, ahí pueden haber O(m^2) substrings y podemos encontrar si un string es substring de otro string en tiempo O(n), entonces el tiempo general de este método será O(n * m2)
Programación dinámica puede ser usada para encontrar el string común más largo en O(n*m) tiempo, la idea es encontrar el sufijo común más largo para todos los substrings de ambos strings y almacena estas longitudes en la tabla.
El sufijo común más largo tiene propiedad de subestructura propia.
Si el último carácter coincide, entonces reducimos ambas longitudes en 1.
- LCSuff(X, Y, m, n) = LCSuff(X, Y, m-1, n-1) + 1 if X[m-1] = Y[n-1]
Si el último carácter no coincide, entonces el resultado es 0, por ejemplo:
- LCSuff(X, Y, m, n) = 0 if (X[m-1] != Y[n-1])
Ahora consideramos sufijos de diferentes substrings terminando en diferentes índices, el sufijo común más largo, su longitud es el substring común más largo.
- LCSubStr(X, Y, m, n) = Max(LCSuff(X, Y, i, j)) donde 1 &lt;= i &lt;= m y 1 &lt;= j &lt;= n
Complejidad de tiempo: O(m*n)
</texto>
  <complejidad_tiempo>null</complejidad_tiempo>
  <java>/* Implementación java que encuentra el substring comun más 
largo usando programación dinamica*/
public class LongestCommonSubString {

    static int LCSubStr(char X[], char Y[], int m, int n) {

        int LCStuff[][] = new int[m + 1][n + 1];
        int result = 0;  //Para almacenar el tamaño del substring 
        for (int i = 0; i &lt;= m; i++) {
            for (int j = 0; j &lt;= n; j++) {
                if (i == 0 || j == 0) {
                    LCStuff[i][j] = 0;
                } else if (X[i - 1] == Y[j - 1]) {
                    LCStuff[i][j] = LCStuff[i - 1][j - 1] + 1;
                    result = Integer.max(result, LCStuff[i][j]);
                } else {
                    LCStuff[i][j] = 0;
                }
            }
        }
        return result;
    }

    public static void main(String[] args) {
        String X = &quot;hola mundo&quot;;
        String Y = &quot;mundo&quot;;
        int m = X.length();
        int n = Y.length();
        System.out.println(&quot;El tamaño del substring cómun más largo es &quot;
                + LCSubStr(X.toCharArray(), Y.toCharArray(), m, n));
    }
}

</java>
  <cpp>null</cpp>
  <py>null</py>
  <orden>9</orden>
  <suborden>3</suborden>
  <fecha_creacion>2020-12-05 00:45:55</fecha_creacion>
  <fecha_modificacion>2020-12-06 20:32:35</fecha_modificacion>
</row>
<row>
  <ID>162</ID>
  <supergrupo>DP</supergrupo>
  <tema>Triángulo de Pascal</tema>
  <texto>El triángulo de Pascal es un triángulo de números enteros, infinito y simétrico Se empieza con un 1 en la primera fila, y en las filas siguientes se van colocando números de forma que cada uno de ellos sea la suma de los dos números que tiene encima. Se supone que los lugares fuera del triángulo contienen ceros, de forma que los bordes del triángulo están formados por unos.
- Los números del triángulo de Pascal coinciden con los números combinatorios.
- El número combinatorio Cm n (n sobre m) se encuentra en el triángulo en la fila n+1, en el lugar m+1. 
- El número combinatorio Cm n (n sobre m) que representa el número de grupos de m elementos que pueden hacerse de entre un conjunto de n (por ejemplo, (4 sobre 2) nos da el número de parejas distintas que podrían hacerse en un grupo de cuatro personas), se encuentra en el triángulo en la fila n+1, en el lugar m+1. 
- Podemos saber que el número de parejas posibles que decíamos antes es 6 si miramos el tercer número de la quinta fila. 
Esto hace que el triángulo sea útil como representación de estos números, y proporciona una buena forma de intuir sus propiedades.
- La fórmula general del llamado Binomio de Newton (a + b)n está formada por unos coeficientes que coinciden con la línea número n+1 del triángulo de Pascal (la que empieza por 1 y n).
- Si el primer elemento de una fila es un número primo, todos los números de esa fila serán divisibles por él (menos el 1, claro). Así, en la fila 7: (1 7 21 35 35 21 7 1), los números 7,21 y 35 son divisibles por 7.
- La suma de los elementos de cualquier fila es el resultado de elevar 2 al número que define a esa fila. 
- La serie de Fibonacci puede ser encontrada también en el triángulo de Pascal. Dividiendo al mismo según las líneas que mostramos en el diagrama, los números atrapados entre ellas suman cada uno de los elementos de esta sucesión.
</texto>
  <complejidad_tiempo>null</complejidad_tiempo>
  <java>//Código java que realiza el triángulo de Pascal

public class PascalTriangle {

    static void printPascal(int n) {
        /* Itera atraves de cada linea y la imprime
        con sus entradas*/
        for (int line = 0; line &lt; n; line++) {
            // Cada linea tiene u número de enteror
            //igual al número de linea
            for (int i = 0; i &lt;= line; i++) {
                System.out.print(binomialCoeff(line, i) + &quot; &quot;);
            }
            System.out.println();
        }
    }

    static int binomialCoeff(int n, int k) {
        int res = 1;
        if (k &gt; n - k) {
            k = n - k;
        }
        for (int i = 0; i &lt; k; ++i) {
            res *= (n - i);
            res /= (i + 1);
        }
        return res;
    }

    public static void main(String args[]) {
        int n = 7;
        printPascal(n);
    }
}
</java>
  <cpp>null</cpp>
  <py>null</py>
  <orden>9</orden>
  <suborden>4</suborden>
  <fecha_creacion>2020-12-05 00:45:55</fecha_creacion>
  <fecha_modificacion>2020-12-06 20:32:35</fecha_modificacion>
</row>
<row>
  <ID>163</ID>
  <supergrupo>Archivos</supergrupo>
  <tema>Lectura desde archivos</tema>
  <texto>Cada lenguaje tiene diferentes funciones que permiten realizar esto, aquí les presentamos varios ejemplos en los tres lenguajes, necesitaremos primero crear los siguientes archivos de texto en la misma carpeta en la que se encuentre el proyecto (Puede variar).</texto>
  <complejidad_tiempo>Archivos de entrada
IO_in1.txt 3
1 2
5 7
6 3
IO_in2.txt 1 2
5 7
6 3
0 0
1 1
IO_in3.txt 1 2
5 7
6 3
IO_in4.txt 1 1
2 3 4
3 8 1 1
4 7 2 9 3
5 1 1 1 1 1
IO_in5.txt 1
3 4
8 1 1
7 2 9 3
1 1 1 1 1
</complejidad_tiempo>
  <java>import java.util.*;
import java.io.*;

class IO {

    public static void main(String[] args) throws Exception {
        // Comente todas las líneas y solo descomente el código de 
        // demostración que le interese

        // Detectar el directorio actual por si es necesario
        // hay que diferencias entre URL relativa y URL absoluta
        // se necesita determinar si es necesario  colocar la ruta completa
        // dependiendo del sistema operativo
        System.out.println(System.getProperty(&quot;user.dir&quot;));
        Scanner sc = new Scanner(new File(System.getProperty(&quot;user.dir&quot;)
                + &quot;\\src\\ready\\IO_in1.txt&quot;));
        int TC = sc.nextInt(); // número de casos de prueba
        while (TC-- &gt; 0) { // atajo para repetir hasta 0
            int a = sc.nextInt(), b = sc.nextInt(); // calcular respuesta
            System.out.println(a + b); // sobre la marcha
        }

//        Scanner sc = new Scanner(new File(&quot;IO_in2.txt&quot;));
//        int a, b;
//        // detenerse cuando ambos enteros sean 0
//        while (true) {
//            a = sc.nextInt();
//            b = sc.nextInt();
//            if ((a == 0) &amp;&amp; (b == 0)) {
//                break;
//            }
//            System.out.println(a + b);
//        }
//
//        Scanner sc = new Scanner(new File(&quot;IO_in3.txt&quot;));
//        // La clase de escáner tiene el método hasNext
//        while (sc.hasNext()) {
//            int a = sc.nextInt(), b = sc.nextInt();
//            System.out.println(a + b);
//        }
//
//        Scanner sc = new Scanner(new File(&quot;IO_in3.txt&quot;)); // mismo archivo de 
//        // entrada que antes
//        int c = 0;
//        while (sc.hasNext()) {
//            int a = sc.nextInt(), b = sc.nextInt();
//            // observe los dos &#39;\ n&#39;, Java System.out también tiene printf
//            System.out.printf(&quot;Case %d: %d\n\n&quot;, ++c, a + b);
//        }
//
//        Scanner sc = new Scanner(new File(&quot;IO_in3.txt&quot;)); // mismo archivo 
//        // de entrada que antes
//        int c = 0;
//        while (sc.hasNext()) {
//            int a = sc.nextInt(), b = sc.nextInt();
//            if (c &gt; 0) {
//                System.out.println(); // 2do / más casos
//            }
//            System.out.printf(&quot;Case %d: %d\n&quot;, ++c, a + b);
//        }
//
//        Scanner sc = new Scanner(new File(&quot;IO_in4.txt&quot;));
//        while (sc.hasNext()) {
//            int k = sc.nextInt();
//            int ans = 0, v;
//            while (k-- &gt; 0) {
//                v = sc.nextInt();
//                ans += v;
//            }
//            System.out.println(ans);
//        }
//
//        Scanner sc = new Scanner(new File(&quot;IO_in5.txt&quot;));
//        while (sc.hasNext()) { // sigue en bucle
//            String[] token = sc.nextLine().split(&quot; &quot;);
//            int ans = 0;
//            for (int i = 0; i &lt; token.length; ++i) {
//                ans += Integer.parseInt(token[i]);
//            }
//            System.out.println(ans);
//        }
    }
}
</java>
  <cpp>#include &lt;bits/stdc++.h&gt;
using namespace std;

int main() {
    // Comente todas las líneas y solo descomente el código de demostración que le interese

    freopen(&quot;IO_in1.txt&quot;, &quot;r&quot;, stdin);
    int TC;
    scanf(&quot;%d&quot;, &amp;TC); // número de casos de prueba
    while (TC--) { // atajo para repetir hasta 0
        int a, b;
        scanf(&quot;%d %d&quot;, &amp;a, &amp;b);
        printf(&quot;%d\n&quot;, a + b); // calcular sobre la marcha
    }

    //   freopen(&quot;IO_in2.txt&quot;, &quot;r&quot;, stdin);
    //   int a, b;
    //   // detenerse cuando ambos enteros sean 0
    //   while (scanf(&quot;%d %d&quot;, &amp;a, &amp;b), (a || b))
    //     printf(&quot;%d\n&quot;, a+b);
    //
    //   freopen(&quot;IO_in3.txt&quot;, &quot;r&quot;, stdin);
    //   int a, b;
    //   // scanf devuelve el número de elementos leídos
    //   while (scanf(&quot;%d %d&quot;, &amp;a, &amp;b) == 2)
    //   // o puede verificar EOF, es decir
    //   // while (scanf (&quot;% d% d&quot;, &amp; a, &amp; b)! = EOF)
    //     printf(&quot;%d\n&quot;, a+b);
    //
    //   freopen(&quot;IO_in3.txt&quot;, &quot;r&quot;, stdin); // mismo archivo de entrada que antes
    //   int a, b, c = 0;
    //   while (scanf(&quot;%d %d&quot;, &amp;a, &amp;b) != EOF)
    //     // note los dos &#39;\ n&#39;
    //     printf(&quot;Case %d: %d\n\n&quot;, ++c, a+b);
    //
    //   freopen(&quot;IO_in3.txt&quot;, &quot;r&quot;, stdin); // mismo archivo de entrada que antes
    //   int a, b, c = 0;
    //   while (scanf(&quot;%d %d&quot;, &amp;a, &amp;b) != EOF) {
    //     if (c &gt; 0) printf(&quot;\n&quot;); // 2do / más casos
    //     printf(&quot;Case %d: %d\n&quot;, ++c, a+b);
    //   }
    //
    //   freopen(&quot;IO_in4.txt&quot;, &quot;r&quot;, stdin);
    //   int k;
    //   while (scanf(&quot;%d&quot;, &amp;k) != EOF) {
    //     int ans = 0, v;
    //     while (k--) { scanf(&quot;%d&quot;, &amp;v); ans += v; }
    //     printf(&quot;%d\n&quot;, ans);
    //   }
    //
    //   freopen(&quot;IO_in5.txt&quot;, &quot;r&quot;, stdin);
    //   while (1) { // sigue en bucle
    //     int ans = 0, v;
    //     char dummy;
    //     while (scanf(&quot;%d%c&quot;, &amp;v, &amp;dummy) != EOF) {
    //       ans += v;
    //       if (dummy == &#39;\n&#39;) break; // prueba EOLN
    //     }
    //     if (feof(stdin)) break; // tprueba EOF
    //     printf(&quot;%d\n&quot;, ans);
    //   }

    return 0;
}

</cpp>
  <py># Comente todas las líneas y solo descomente el código de 
# demostración que le interese

# IO_in1.txt
import sys
inputs = iter(sys.stdin.readlines())
TC = int(next(inputs))
for _ in range(TC):
    print(sum(map(int, next(inputs).split())))

## IO_in2.txt
#import sys
#for line in sys.stdin.readlines():
#    if line == &#39;0 0\n&#39;: break
#    print(sum(map(int, line.split())))
#
## IO_in3.txt
#import sys
#for line in sys.stdin.readlines():
#    print(sum(map(int, line.split())))
#
## IO_in3.txt, mismo archivo de entrada que antes
#import sys
#for c, line in enumerate(sys.stdin.readlines(), 1):
#    print(&quot;Case %s: %s\n&quot; % (c, sum(map(int, line.split()))))
#
## IO_in3.txt, mismo archivo de entrada que antes
#import sys
#for c, line in enumerate(sys.stdin.readlines(), 1):
#    if c &gt; 1: print()
#    print(&quot;Case %s: %s&quot; % (c, sum(map(int, line.split()))))
#
## IO_in4.txt
#import sys
#for line in sys.stdin.readlines():
#    print(sum(map(int, line.split()[1:]))) # skip the first integer
#
## IO_in5.txt
#import sys
#for line in sys.stdin.readlines():
#    print(sum(map(int, line.split())))
</py>
  <orden>12</orden>
  <suborden>1</suborden>
  <fecha_creacion>2020-12-05 01:56:08</fecha_creacion>
  <fecha_modificacion>2020-12-06 20:36:17</fecha_modificacion>
</row>
<row>
  <ID>164</ID>
  <supergrupo>Archivos</supergrupo>
  <tema>Escritura de archivos </tema>
  <texto></texto>
  <complejidad_tiempo>null</complejidad_tiempo>
  <java>// Creando un archivo de texto usando FileWriter

import java.io.FileWriter;
import java.io.IOException;

public class WriteFile {

    public static void main(String[] args) throws IOException {
        // Aceptar una cadena
        String str = &quot;Programación competitiva&quot;;
        // adjuntar un archivo a FileWriter
        FileWriter fw = new FileWriter(&quot;output.txt&quot;);
        // leer caracteres de la cadena y escribir en FileWriter
        fw.write(str);
        System.out.println(&quot;Writing successful&quot;);
        //close the file 
        fw.close();
    }
}
</java>
  <cpp>#include &lt;bits/stdc++.h&gt; 
using namespace std;

int main() {
    // fstream es la clase Stream para leer y escribir desde / hacia archivos.
    // file es objeto de la clase fstream
    fstream file;

    // abrir el archivo &quot;out.txt&quot; en el modo de salida (escritura)
    // ios::out Abierto para operaciones de salida.
    file.open(&quot;out.txt&quot;, ios::out);

    // Si no se crea ningún archivo, muestre el mensaje de error.
    if (!file) {
        cout &lt;&lt; &quot;Error in creating file!!!&quot;;
        return 0;
    }
    file &lt;&lt; &quot;programación competitiva&quot; &lt;&lt; endl;

    cout &lt;&lt; &quot;File created successfully.&quot;;
    // cerrando el archivo.
    // La razón por la que necesita llamar a close () al final del ciclo 
    // es que al intentar abrir un nuevo archivo sin cerrar 
    // el primer archivo fallará.
    file.close();

    return 0;
}
</cpp>
  <py># Abrir un archivo
file1 = open(&#39;myfile.txt&#39;, &#39;w&#39;) 
L = [&quot;Programación competitiva \n&quot;, &quot;artemis \n&quot;, &quot;NMA \n&quot;] 
s = &quot;hola mundo\n&quot;

# Escribir una cadena en un archivo
file1.write(s) 

# Escribir varias cadenas a la vez
file1.writelines(L) 

# Archivo de cierre
file1.close() 

# Comprobando si los datos están escritos en un archivo o no
file1 = open(&#39;myfile.txt&#39;, &#39;r&#39;) 
print(file1.read()) 
file1.close() 
</py>
  <orden>12</orden>
  <suborden>2</suborden>
  <fecha_creacion>2020-12-05 01:56:08</fecha_creacion>
  <fecha_modificacion>2022-03-08 11:38:01</fecha_modificacion>
</row>
<row>
  <ID>165</ID>
  <supergrupo>Matemática</supergrupo>
  <tema>Test de primalidad AKS</tema>
  <texto>Hay varias pruebas de primalidad disponibles para verificar si el número es primo o no, como el teorema de Fermat, la prueba de primaria de Miller-Rabin y mucho más. Pero el problema con todos ellos es que todos son de naturaleza probabilística. Entonces, aquí viene otro método, es decir, la prueba de primalidad AKS (prueba de primalidad de Agrawal-Kayal-Saxena) y es determinísticamente correcto para cualquier número general.
Características de la prueba de primalidad de AKS:

1. El algoritmo AKS se puede utilizar para verificar la primacía de cualquier número general dado.

2. El tiempo máximo de ejecución del algoritmo se puede expresar como un polinomio sobre el número de dígitos del número objetivo.

3. Se garantiza que el algoritmo distingue de forma determinista si el número objetivo es primo o compuesto.

4. La exactitud de AKS no está condicionada a ninguna hipótesis subsidiaria no probada.

Esta congruencia se puede verificar en tiempo polinomial cuando r es polinomial a los dígitos de n. El algoritmo AKS evalúa esta congruencia para un gran conjunto de valores a, cuyo tamaño es polinomial a los dígitos de n. La prueba de validez del algoritmo AKS muestra que uno puede encontrar r y un conjunto de valores a con las propiedades anteriores, de modo que si las congruencias se cumplen, entonces n es una potencia de un primo. El enfoque de fuerza bruta requeriría la expansión del polinomio (x - a) ^ n y una reducción (mod n) de los coeficientes n + 1 resultantes.
Como debe ser coprimo a n. Entonces, para implementar este algoritmo podemos verificar tomando a = 1, pero para valores grandes de n debemos tomar valores grandes de a.
El algoritmo se basa en la condición de que si n es cualquier número, entonces es primo si:
(x - 1) ^ n - (x ^ n - 1) es divisible por n.
Comprobando n = 3:
(x-1) ^ 3 - (x ^ 3 - 1)
= (x ^ 3 - 3x ^ 2 + 3x - 1) - (x ^ 3 - 1)
= -3x ^ 2 + 3x
Como todos los coeficientes son divisibles por n, es decir, 3, 3 (n) es primo.
A medida que aumenta el número, aumenta el tamaño.
El código se basa en esta condición y puede verificar números primos hasta 64.
</texto>
  <complejidad_tiempo>null</complejidad_tiempo>
  <java>/*Verifica si el número es primo, este programa demuestra el concepto detras del
Algoritmo AKS (solo funciona hasta n=64*/
public class AKSPrimalityTest {

    // array usado para almacenar coeficientes
    static long c[] = new long[100];

    /*
    Función que calcula los coeficientes de 
    (x - 1)^n - (x^n - 1) con ayuda del triangulo de pascal
     */
    static void coef(int n) {
        c[0] = 1;
        for (int i = 0; i &lt; n; c[0] = -c[0], i++) {
            c[1 + i] = 1;
            for (int j = i; j &gt; 0; j--) {
                c[j] = c[j - 1] - c[j];
            }
        }
    }

    //función de verificación de un numero primo
    static boolean isPrime(int n) {

        //Calculando todos los coeficientes 
        //por la función coef y almacenando todos
        //los coeficientes en en el array c.
        coef(n);
        //restando c [n] y sumando c [0] por 1
        //como (x - 1) ^ n - (x ^ n - 1), aquí
        //se resta c [n] por 1 y se suma
        //1 en expresión.
        c[0]++;
        c[n]--;
        //comprobando todos los coeficientes si
        //son divisibles por n o no.
        //si n no es primo, entonces el bucle se rompe
        //y (i&gt; 0).
        int i = n;
        while ((i--) &gt; 0 &amp;&amp; c[i] % n == 0);
        // Retorna true si todos los coeficientes son divisibles por n
        return i &lt; 0;
    }

    public static void main(String[] args) {
        int n = 37;
        if (isPrime(n)) {
            System.out.println(&quot;Prime&quot;);
        } else {
            System.out.println(&quot;Not Prime&quot;);
        }
    }
}
</java>
  <cpp>#include &lt;cstdlib&gt;
#include &lt;bits/stdc++.h&gt;
using namespace std;
long c[100];

static void coef(int n) {
    c[0] = 1;
    for (int i = 0; i &lt; n; c[0] = -c[0], i++) {
        c[1 + i] = 1;
        for (int j = i; j &gt; 0; j--)
            c[j] = c[j - 1] - c[j];
    }
}

bool isPrime(int n) {
    coef(n);
    c[0]++;
    c[n]--;
    int i = n;
    while ((i--) &gt; 0 &amp;&amp; c[i] % n == 0);
    return i &lt; 0;
}

int main() {
    int n = 37;
    if (isPrime(n))
        cout &lt;&lt; &quot;Primo&quot; &lt;&lt; endl;
    else
        cout &lt;&lt; &quot;No es primo&quot; &lt;&lt; endl;
}
</cpp>
  <py>c = [0] * 100 
def coef(n): 
    c[0] = 1 
    for i in range(n): 
        c[1 + i] = 1 
        for j in range(i, 0, -1): 
            c[j] = c[j - 1] - c[j] 
        c[0] = -c[0] 
                
def isPrime(n): 
    coef(n) 
    c[0] = c[0] + 1 
    c[n] = c[n] - 1 
    i = n 
    while (i &gt; -1 and c[i] % n == 0): 
        i = i - 1 
    return True if i &lt; 0 else False 

n = 37; 
if (isPrime(n)): 
    print(&quot;Prime&quot;) 
else: 
    print(&quot;Not Prime&quot;)
</py>
  <orden>6</orden>
  <suborden>58</suborden>
  <fecha_creacion>2020-12-05 01:56:08</fecha_creacion>
  <fecha_modificacion>2022-03-08 11:38:01</fecha_modificacion>
</row>
<row>
  <ID>166</ID>
  <supergrupo>Matemática</supergrupo>
  <tema>Test de primalidad Miller-Rabin</tema>
  <texto>Dado un número n, compruebe si es primo o no.
Este método es un método probabilístico (como Fermat), pero generalmente se prefiere al método de Fermat.

¿Como funciona esto?
1. El teorema de Fermat establece que, si n es un número primo, entonces para cada a, 1 &lt;= a &lt;n, an-1% n = 1
2. Los casos base aseguran que n debe ser impar. Dado que n es impar, n-1 debe ser par. Y un número par se puede escribir como d * 2s donde d es un número impar y s&gt; 0.
3. A partir de los dos puntos anteriores, por cada número elegido al azar en el rango [2, n-2], el valor de ad * 2r% n debe ser 1.
4. De acuerdo con el Lema de Euclides, si x2% n = 1 o (x2 - 1)% n = 0 o (x-1) (x + 1)% n = 0. Entonces, para que n sea primo, n divide (x-1) on divide (x + 1). Lo que significa x% n = 1 o x% n = -1.

De los puntos 2 y 3, podemos concluir
For n to be prime, either
	ad % n = 1 
        OR 
    ad*2i % n = -1 
    for some i, where 0 &lt;= i &lt;= r-1.

</texto>
  <complejidad_tiempo>null</complejidad_tiempo>
  <java>//La función de Miller-Rabin determina si un número 
//dado es o no un número primo. 

public class MillerRabin {

    static boolean isPrime(long p) {
        if (p &lt; 2 || (p != 2 &amp;&amp; p % 2 == 0)) {
            return false;
        }
        long s = p - 1;
        while (s % 2 == 0) {
            s /= 2;
        }
        for (int i = 0; i &lt; 5; i++) {
            long a = (long) (Math.random() * p) % (p - 1) + 1;
            long temp = s;
            long mod = modpow(a, temp, p);
            while (temp != p - 1 &amp;&amp; mod != 1 &amp;&amp; mod != p - 1) {
                mod = modmul(mod, mod, p);
                temp *= 2;
            }
            if (mod != p - 1 &amp;&amp; temp % 2 == 0) {
                return false;
            }
        }
        return true;
    }

    static long modpow(long a, long b, long mod) {
        if (b == 0) {
            return 1;
        }
        if (b % 2 == 0) {
            long temp = modpow(a, b / 2, mod);
            return (temp * temp) % mod;
        } else {
            long temp = modpow(a, b - 1, mod);
            return (temp * a) % mod;
        }
    }

    public static long modmul(long a, long b, long mod) {
        long x = 0;
        long y = a % mod;
        while (b &gt; 0) {
            if (b % 2 == 1) {
                x = (x + y) % mod;
            }
            y = (y &lt;&lt; 1) % mod;
            b &gt;&gt;= 1;
        }
        return x % mod;
    }

    public static void main(String[] args) {
        for (int i = 0; i &lt; 100; i++) {
            System.out.println(i + &quot; &quot; + isPrime(i));
        }
    }
}
</java>
  <cpp>#include &lt;bits/stdc++.h&gt; 
using namespace std;

long modmul(long a, long b, long mod) {
    long x = 0;
    long y = a % mod;
    while (b &gt; 0) {
        if (b % 2 == 1) {
            x = (x + y) % mod;
        }
        y = (y &lt;&lt; 1) % mod;
        b &gt;&gt;= 1;
    }
    return x % mod;
}

long modpow(long a, long b, long mod) {
    if (b == 0) {
        return 1;
    }
    if (b % 2 == 0) {
        long temp = modpow(a, b / 2, mod);
        return (temp * temp) % mod;
    } else {
        long temp = modpow(a, b - 1, mod);
        return (temp * a) % mod;
    }
}

bool isPrime(long p) {
    if (p &lt; 2 || (p != 2 &amp;&amp; p % 2 == 0)) {
        return false;
    }
    long s = p - 1;
    while (s % 2 == 0) {
        s /= 2;
    }
    for (int i = 0; i &lt; 5; i++) {
        long a = (long) (0.5 * p) % (p - 1) + 1;
        long temp = s;
        long mod = modpow(a, temp, p);
        while (temp != p - 1 &amp;&amp; mod != 1 &amp;&amp; mod != p - 1) {
            mod = modmul(mod, mod, p);
            temp *= 2;
        }
        if (mod != p - 1 &amp;&amp; temp % 2 == 0) {
            return false;
        }
    }
    return true;
}

int main() {
    for (int i = 0; i &lt; 100; i++) {
        cout &lt;&lt; i &lt;&lt; &quot; &quot; &lt;&lt; isPrime(i) &lt;&lt; endl;
    }
}
</cpp>
  <py>def modmul(a, b, mod):
    x = 0;
    y = a % mod;
    while (b &gt; 0):
        if (b % 2 == 1):
            x = (x + y) % mod;
        y = (y &lt;&lt; 1) % mod
        b &gt;&gt;= 1
    return x % mod


def modpow(a, b, mod):
    if (b == 0):
        return 1
    if (b % 2 == 0):
        temp = modpow(a, b / 2, mod)
        return (temp * temp) % mod
    else:
        temp = modpow(a, b - 1, mod)
        return (temp * a) % mod;
    
def isPrime(p):
    if (p &lt; 2 or (p != 2 and p % 2 == 0)):
        return False
    s = p - 1
    while (s % 2 == 0):
        s /= 2
    for i in range (5):
        a = int((0.5 * p) % (p - 1) + 1)
        temp = s
        mod = modpow(a, temp, p)
        while (temp != p - 1 and mod != 1 and mod != p - 1):
            mod = modmul(mod, mod, p)
            temp *= 2
        if (mod != p - 1 and temp % 2 == 0):
            return False
    return True
for i in range (100):
    print(str(i) + &quot; &quot; + str(isPrime(i)))
</py>
  <orden>6</orden>
  <suborden>59</suborden>
  <fecha_creacion>2020-12-05 01:56:09</fecha_creacion>
  <fecha_modificacion>2022-03-08 11:40:32</fecha_modificacion>
</row>
<row>
  <ID>167</ID>
  <supergrupo>Matemática</supergrupo>
  <tema>Criba de Sundaram</tema>
  <texto>Dado un número n, imprima todos los números primos menores o iguales an.
1) En general la criba de Sundaram, produce primos menores que (2 * x +2) para un número dado x. Como queremos primos menores que n, reducimos n-1 a la mitad. Lo llamamos nNew, nNew = (n-1) / 2;
    Por ejemplo, si n = 102, entonces nNew = 50.
                 si n = 103, entonces nNew = 51
2) Cree una array marked[n] que se utilizará para separar números de la forma i + j + 2ij de otros donde 1 &lt;= i &lt;= j

3) Inicialice todas las entradas de marked[] como falsa.

4) Marque todos los números de la forma i + j + 2ij como verdaderos donde 1 &lt;= i &lt;= j, ciclo para i = 1 a nNew
	a) j = i;
b) Haga un ciclo mientras (i + j + 2 * i * j) 2, luego imprima 2 como primer primo.
5) Los números primos restantes tienen la forma 2i + 1 donde i es el índice de números NO marcados. Entonces imprima 2i + 1 para todo i tal que marked[i] sea falso.



¿Como funciona esto?
Cuando producimos nuestra salida final, producimos todos los enteros de la forma 2x + 1 (es decir, son impares) excepto 2 que se maneja por separado.
Sea q un número entero de la forma 2x + 1.
q se excluye si y solo si x es de la forma i + j + 2ij. Eso significa:
q = 2(i + j + 2ij) + 1
  = (2i + 1)(2j + 1)
Entonces, un entero impar se excluye de la lista final si y solo si tiene una factorización de la forma (2i + 1) (2j + 1) es decir, si tiene un factor impar no trivial.
</texto>
  <complejidad_tiempo>null</complejidad_tiempo>
  <java>// Programa Java para imprimir primos menores que n usando la criba de Sundaram.

import java.util.Arrays;

public class SieveSundaram {

    // Imprime todos los números primos más pequeños
    static int SieveOfSundaram(int n) {

        // En general la criba de Sundaram, produce números primos menores que 
        //(2 * x + 2) para un número dado x. Como queremos primos menores que n, 
        // reducimos n a la mitad
        int nNew = (n - 1) / 2;

        // Esta matriz se usa para separar números de la 
        // forma i + j + 2ij de otros donde 1 &lt;= i &lt;= j
        boolean marked[] = new boolean[nNew + 1];

        // Inicializar todos los elementos como no marcados
        Arrays.fill(marked, false);

        // Lógica principal de Sundaram. Marque todos los números 
        // de la forma i + j + 2ij como verdaderos donde 1 &lt;= i &lt;= j
        for (int i = 1; i &lt;= nNew; i++) {
            for (int j = i; (i + j + 2 * i * j) &lt;= nNew; j++) {
                marked[i + j + 2 * i * j] = true;
            }
        }

        // Dado que 2 es un número primo
        if (n &gt; 2) {
            System.out.print(2 + &quot; &quot;);
        }

        // Imprime otros primos. Los números primos restantes son de la 
        // forma 2 * i + 1, de modo que marcado [i] es falso. 
        for (int i = 1; i &lt;= nNew; i++) {
            if (marked[i] == false) {
                System.out.print(2 * i + 1 + &quot; &quot;);
            }
        }
        return -1;
    }


    public static void main(String[] args) {
        int n = 20;
        SieveOfSundaram(n);
    }
}
</java>
  <cpp>#include &lt;bits/stdc++.h&gt; 
using namespace std;

int SieveOfSundaram(int n) {

    int nNew = (n - 1) / 2;
    bool marked[nNew + 1];
    memset(marked, false, sizeof (marked));
    for (int i = 1; i &lt;= nNew; i++)
        for (int j = i; (i + j + 2 * i * j) &lt;= nNew; j++)
            marked[i + j + 2 * i * j] = true;
    if (n &gt; 2)
        cout &lt;&lt; 2 &lt;&lt; &quot; &quot;;
    for (int i = 1; i &lt;= nNew; i++)
        if (marked[i] == false)
            cout &lt;&lt; 2 * i + 1 &lt;&lt; &quot; &quot;;
}

int main(void) {
    int n = 20;
    SieveOfSundaram(n);
    return 0;
} 
</cpp>
  <py>def SieveOfSundaram(n): 
    nNew = int((n - 1) / 2); 
    marked = [0] * (nNew + 1); 
    for i in range(1, nNew + 1): 
        j = i; 
        while((i + j + 2 * i * j) &lt;= nNew): 
            marked[i + j + 2 * i * j] = 1; 
            j += 1; 
    if (n &gt; 2): 
        print(2, end=&quot; &quot;); 
  
    for i in range(1, nNew + 1): 
        if (marked[i] == 0): 
            print((2 * i + 1), end=&quot; &quot;); 
  
n = 20; 
SieveOfSundaram(n); 
</py>
  <orden>6</orden>
  <suborden>60</suborden>
  <fecha_creacion>2020-12-05 01:56:09</fecha_creacion>
  <fecha_modificacion>2022-03-08 11:40:32</fecha_modificacion>
</row>
<row>
  <ID>168</ID>
  <supergrupo>Matemática</supergrupo>
  <tema>Criba de Atkin</tema>
  <texto>Dado un límite, imprima todos los números primos menores o iguales al límite dado.
El tamiz de Atkin es un algoritmo moderno para encontrar todos los números primos hasta un número entero especificado. Comparado con el antiguo Tamiz de Eratóstenes, que delimita múltiplos de primos, realiza un trabajo preliminar y luego marca múltiplos de cuadrados de primos, por eso tiene una mejor complejidad teórica asintótica, esta complejidad es Complejidad de (N / (log log N) ).

1. Cree una lista de resultados, completa con 2, 3 y 5.
2. Cree una lista tamiz con una entrada para cada entero positivo; todas las entradas de esta lista deben marcarse inicialmente como no principales.
3. Para cada número de entrada n en la lista de tamices, con módulo sesenta resto r:
1. Si r es 1, 13, 17, 29, 37, 41, 49 o 53, invierta la entrada para cada posible solución a 4x2 + y2 = n.

2. Si r es 7, 19, 31 o 43, invierta la entrada para cada posible solución a 3x2 + y2 = n.

3. Si r es 11, 23, 47 o 59, invierta la entrada para cada posible solución a 3x2 - y2 = n cuando x&gt; y.

4. Si r es otra cosa, ignórela por completo.

4. Empiece con el número más bajo de la lista de tamiz.
5. Tome el siguiente número en la lista tamiz aún marcado como principal.
6. Incluya el número en la lista de resultados.
7. Eleve al cuadrado el número y marque todos los múltiplos de ese cuadrado como no primos. Tenga en cuenta que los múltiplos que se pueden factorizar por 2, 3 o 5 no necesitan marcarse, ya que se ignorarán en la enumeración final de primos.
8. Repita los pasos del cuatro al siete.

¿Cómo funciona?
1. El algoritmo trata 2, 3 y 5 como casos especiales y simplemente los agrega al conjunto de números primos para empezar.
2. Como la criba de Eratóstenes, comenzamos con una lista de números que queremos investigar. Supongamos que queremos encontrar números primos &lt;= 100, luego hacemos una lista para [5, 100]. Como se explica en (1), 2, 3 y 5 son casos especiales y 4 no es primo.
3. El algoritmo habla en términos de residuos de módulo 60. .
4. Todos los números con un resto de módulo sesenta 1, 13, 17, 29, 37, 41, 49 o 53 tienen un resto de módulo doce de 1 o 5. Estos números son primos si y solo si el número de soluciones a 4 × 2 + y2 = n es impar y el número no tiene cuadrados. Un cuadrado entero libre es aquel que no es divisible por ningún cuadrado perfecto distinto de 1.
5. Todos los números con un resto módulo sesenta 7, 19, 31 o 43 tienen un resto módulo seis de 1. Estos números son primos si y solo si el número de soluciones de 3x2 + y2 = n es impar y el número es squarefree.
6. Todos los números con un resto de módulo sesenta 11, 23, 47 o 59 tienen un resto de módulo doce de 11. Estos números son primos si y sólo si el número de soluciones de 3x2 - y2 = n es impar y el número es squarefree.
Veamos cómo genera primos hasta 20:
1    2    3    4    5    6    7    8    9    10
11  12   13    14   15   16   17  18   19    20
Paso 0:
El estado de todos los números al inicio es Falso. El número especial es 2, 3 y 5 que se sabe que son primos.
Paso 1:
Genere valores para las condiciones.
 
Paso 2:
Cambiando el estado según la condición.
Los valores anteriores de n en la tabla generada en el ciclo x, y se probarán para la condición de módulo.

Columna 1: si (valor de la columna1)% 12 == 1 o 5
luego invierta el estado del tamiz para ese número.
Estamos tomando un mod con 12 en lugar de 60, esto se debe a que si tomamos el mod 60, tenemos que considerar muchos r como 1, 13, 17, 29, 37, 41, 49 o 53 y para todos estos r, mod 12 es 1 o 5. (hecho solo para reducir el tamaño de la expresión)

Columna 2: si (valor de la columna2)% 12 == 7
luego invierta el estado del tamiz para ese número.

Columna 3: si (valor de la columna3)% 12 == 11
luego invierta el estado del tamiz para ese número.

Paso 3 :
Comprobación de estado libre de cuadrados: si algún número de nuestra lista está en el cuadrado de cualquier número, elimínelo.

Paso 4 :
Creando una matriz de números primos para los que el estado es verdadero.
es decir, 2 3 5 7 11 13 17 19
Paso 5:
Imprime la salida en la pantalla.
</texto>
  <complejidad_tiempo>null</complejidad_tiempo>
  <java>// Programa Java para la implementación de la criba de Atkin

public class SieveAtkin {

    static int SieveOfAtkin(int limit) {
        // 2 y 3 son conocidos por ser primos
        if (limit &gt; 2) {
            System.out.print(2 + &quot; &quot;);
        }

        if (limit &gt; 3) {
            System.out.print(3 + &quot; &quot;);
        }

        // Inicializar la matriz de tamices con valores falsos
        boolean sieve[] = new boolean[limit];

        for (int i = 0; i &lt; limit; i++) {
            sieve[i] = false;
        }

        /* Se marca sieve[n] es verdadero si uno de los
         lo siguiente es cierto:
         a) n = (4 * x * x) + (y * y) tiene un número impar de soluciones, 
         es decir, existe un número impar de pares distintos (x, y) que 
         satisfacen la ecuación y n% 12 = 1 o n% 12 = 5.
         b) n = (3 * x * x) + (y * y) tiene un número impar de soluciones 
         yn% 12 = 7
         c) n = (3 * x * x) - (y * y) tiene un número impar de soluciones, 
         x&gt; y y n% 12 = 11 */
        for (int x = 1; x * x &lt; limit; x++) {
            for (int y = 1; y * y &lt; limit; y++) {

                // Parte principal de la criba de Atkin
                int n = (4 * x * x) + (y * y);
                if (n &lt;= limit &amp;&amp; (n % 12 == 1 || n % 12 == 5)) {
                    sieve[n] ^= true;
                }

                n = (3 * x * x) + (y * y);
                if (n &lt;= limit &amp;&amp; n % 12 == 7) {
                    sieve[n] ^= true;
                }

                n = (3 * x * x) - (y * y);
                if (x &gt; y &amp;&amp; n &lt;= limit &amp;&amp; n % 12 == 11) {
                    sieve[n] ^= true;
                }
            }
        }

        // Marcar todos los múltiplos de cuadrados como no primos
        for (int r = 5; r * r &lt; limit; r++) {
            if (sieve[r]) {
                for (int i = r * r; i &lt; limit;
                        i += r * r) {
                    sieve[i] = false;
                }
            }
        }

        // Imprima primos usando sieve[] 
        for (int a = 5; a &lt; limit; a++) {
            if (sieve[a]) {
                System.out.print(a + &quot; &quot;);
            }
        }
        return 0;
    }

    public static void main(String[] args) {
        int limit = 20;
        SieveOfAtkin(limit);
    }
}
</java>
  <cpp>#include &lt;bits/stdc++.h&gt; 
using namespace std;

int SieveOfAtkin(int limit) {
    if (limit &gt; 2)
        cout &lt;&lt; 2 &lt;&lt; &quot; &quot;;
    if (limit &gt; 3)
        cout &lt;&lt; 3 &lt;&lt; &quot; &quot;;

    bool sieve[limit];
    for (int i = 0; i &lt; limit; i++)
        sieve[i] = false;

    for (int x = 1; x * x &lt; limit; x++) {
        for (int y = 1; y * y &lt; limit; y++) {

            int n = (4 * x * x) + (y * y);
            if (n &lt;= limit &amp;&amp; (n % 12 == 1 || n % 12 == 5))
                sieve[n] ^= true;

            n = (3 * x * x) + (y * y);
            if (n &lt;= limit &amp;&amp; n % 12 == 7)
                sieve[n] ^= true;

            n = (3 * x * x) - (y * y);
            if (x &gt; y &amp;&amp; n &lt;= limit &amp;&amp; n % 12 == 11)
                sieve[n] ^= true;
        }
    }

    for (int r = 5; r * r &lt; limit; r++) {
        if (sieve[r]) {
            for (int i = r * r; i &lt; limit; i += r * r)
                sieve[i] = false;
        }
    }

    for (int a = 5; a &lt; limit; a++)
        if (sieve[a])
            cout &lt;&lt; a &lt;&lt; &quot; &quot;;
}

int main(void) {
    int limit = 20;
    SieveOfAtkin(limit);
    return 0;
} 
</cpp>
  <py>def SieveOfAtkin(limit): 
    if (limit &gt; 2): 
        print(2, end=&quot; &quot;) 
    if (limit &gt; 3): 
        print(3, end=&quot; &quot;) 
    sieve = [False] * limit 
    for i in range(0, limit): 
        sieve[i] = False
    x = 1
    while(x * x &lt; limit): 
        y = 1
        while(y * y &lt; limit): 
            n = (4 * x * x) + (y * y) 
            if (n &lt;= limit and (n % 12 == 1 or 
                n % 12 == 5)): 
                sieve[n] ^= True
            n = (3 * x * x) + (y * y) 
            if (n &lt;= limit and n % 12 == 7): 
                sieve[n] ^= True
  
            n = (3 * x * x) - (y * y) 
            if (x &gt; y and n &lt;= limit and 
                n % 12 == 11): 
                sieve[n] ^= True
            y += 1
        x += 1
    r = 5
    while(r * r &lt; limit): 
        if (sieve[r]): 
            for i in range(r * r, limit, r * r): 
                sieve[i] = False
          
    for a in range(5, limit): 
        if (sieve[a]): 
            print(a, end=&quot; &quot;) 
  
limit = 20
SieveOfAtkin(limit) 
</py>
  <orden>6</orden>
  <suborden>61</suborden>
  <fecha_creacion>2020-12-05 01:56:09</fecha_creacion>
  <fecha_modificacion>2022-03-08 11:40:32</fecha_modificacion>
</row>
<row>
  <ID>169</ID>
  <supergrupo>Matemática</supergrupo>
  <tema>Exponenciación binaria</tema>
  <texto>Dados tres números x, y y p, calcule (xy)% p.
A continuación se muestra la propiedad modular fundamental que se utiliza para calcular de manera eficiente la potencia bajo aritmética modular.
(ab) mod p = ( (a mod p) (b mod p) ) mod p 
Por ejemplo a = 50,  b = 100, p = 13
50  mod 13  = 11
100 mod 13  = 9
(50 * 100) mod 13 = ( (50 mod 13) * (100 mod 13) ) mod 13 
or (5000) mod 13 = ( 11 * 9 ) mod 13
or 8 = 8
</texto>
  <complejidad_tiempo>null</complejidad_tiempo>
  <java>// Computando iterativamente la potencia modular

public class BinaryExp {

    //Función iterativa para calcular
    //(x ^ y)% p en O (log y)
    static int power(int x, int y, int p) {
        // Inicializar resultado
        int res = 1;
        // Actualiza x si es más
        // que o igual ap
        x = x % p;
        if (x == 0) {
            return 0; //  en caso de que x sea divisible por p
        }
        while (y &gt; 0) {
            //si y es impar, multiplicar x con res 
            if ((y &amp; 1) == 1) {
                res = (res * x) % p;
            }
            // y debe ser par ahora 
            // y = y / 2 
            y = y &gt;&gt; 1;
            x = (x * x) % p;
        }
        return res;
    }

    public static void main(String args[]) {
        int x = 2;
        int y = 5;
        int p = 13;
        System.out.println(power(x, y, p));
    }
}
</java>
  <cpp>#include &lt;cstdlib&gt;
#include &lt;bits/stdc++.h&gt;

using namespace std;

int power(int x, int y, int p) {
    int res = 1;
    x = x % p;
    if (x == 0) return 0;
    while (y &gt; 0) {
        if ((y &amp; 1) == 1)
            res = (res * x) % p;
        y = y &gt;&gt; 1;
        x = (x * x) % p;
    }
    return res;
}

int main() {

    cout &lt;&lt; power(x, y, p) &lt;&lt; endl;
}
</cpp>
  <py>def power(x, y, p):
    res = 1
    x = x % p
    if x == 0: 
        return 0
    while y &gt; 0:
        if ((y &amp; 1) == 1):
            res = (res * x) % p
        y = y &gt;&gt; 1
        x = (x * x) % p
    return res
x = 2
y = 5
p = 13
print(power(x, y, p))
</py>
  <orden>6</orden>
  <suborden>62</suborden>
  <fecha_creacion>2020-12-05 01:56:10</fecha_creacion>
  <fecha_modificacion>2022-03-08 11:40:51</fecha_modificacion>
</row>
<row>
  <ID>170</ID>
  <supergrupo>Matemática</supergrupo>
  <tema>Conteo de digitos </tema>
  <texto>Cuente el número de dígitos en un entero largo ingresado por un usuario.
Podemos usar log10 (logaritmo de base 10) para contar el número de dígitos de números positivos (el logaritmo no está definido para números negativos).
Recuento de dígitos de N = límite superior de log10 (N).
</texto>
  <complejidad_tiempo>null</complejidad_tiempo>
  <java>// Código JAVA para contar el número de dígitos en un entero

public class CountDigit {

    static int countDigit(long n) {
        return (int) Math.floor(Math.log10(n) + 1);
    }

    public static void main(String[] args) {
        long n = 345289467;
        System.out.print(&quot;Number of digits : &quot; + countDigit(n));
    }
}
</java>
  <cpp>#include &lt;bits/stdc++.h&gt; 
using namespace std;

int countDigit(long long n) {
    return floor(log10(n) + 1);
}

int main(void) {
    long long n = 345289467;
    cout &lt;&lt; &quot;Number of digits : &quot; &lt;&lt; countDigit(n);
    return 0;
}
</cpp>
  <py>import math 

def countDigit(n): 
        return math.floor(math.log(n, 10)+1) 
n = 345289467
print (&quot;Number of digits : % d&quot;%(countDigit(n))) 
</py>
  <orden>6</orden>
  <suborden>63</suborden>
  <fecha_creacion>2020-12-05 01:56:10</fecha_creacion>
  <fecha_modificacion>2022-03-08 11:44:37</fecha_modificacion>
</row>
<row>
  <ID>171</ID>
  <supergrupo>Matemática</supergrupo>
  <tema>BigInteger Modular</tema>
  <texto>Dado un número grande &quot;num&quot; representado como una cadena y un entero x, encuentre el valor de &quot;num% x&quot; o &quot;num mod x&quot;. La salida se espera como un número entero.
Ejemplos:
Entrada: num = &quot;12316767678678&quot;, a = 10
Salida: num (mod a) = 8
La idea es procesar todos los dígitos uno por uno y usar la propiedad que xy (mod a) = ((x (mod a) * y) (mod a)). A continuación se muestra la implementación.
</texto>
  <complejidad_tiempo>null</complejidad_tiempo>
  <java>//Calcula n % m. Utilizar cuando n es un número muy muy grande.

public class BigIntegerMod {

    static int mod(String n, int m) {
        int r = 0;
        for (int i = 0; i &lt; n.length(); i++) {
            r = (r * 10 + (n.charAt(i) - &#39;0&#39;)) % m;
        }
        return r;
    }
    public static void main(String[] args) {
        System.out.println(mod(&quot;9564784542&quot;, 10));
    }
}
</java>
  <cpp>#include &lt;cstdlib&gt;
#include &lt;bits/stdc++.h&gt;

using namespace std;

int mod(string n, int m) {
    int r = 0;
    for (int i = 0; i &lt; n.size(); i++) {
        r = (r * 10 + (n.at(i) - &#39;0&#39;)) % m;
    }
    return r;
}

int main() {
    cout&lt;&lt;(mod(&quot;9564784542&quot;, 10))&lt;&lt;endl;
}
</cpp>
  <py>def mod(num, a): 
    res = 0 
    for i in range(0, len(num)): 
        res = (res * 10 + int(num[i])) % a; 
    return res 

num = &quot;9564784542&quot;; 
print(mod(num, 10)) 
</py>
  <orden>6</orden>
  <suborden>64</suborden>
  <fecha_creacion>2020-12-05 01:56:10</fecha_creacion>
  <fecha_modificacion>2022-03-08 11:49:59</fecha_modificacion>
</row>
<row>
  <ID>172</ID>
  <supergrupo>Matemática</supergrupo>
  <tema>Residuo Chino</tema>
  <texto>Se nos dan dos matrices num [0..k-1] y rem [0..k-1]. En num [0..k-1], cada par es coprime (mcd para cada par es 1). Necesitamos encontrar un número mínimo positivo x tal que:

     x % num[0]    =  rem[0], 
     x % num[1]    =  rem[1], 
     .......................
     x % num[k-1]  =  rem[k-1] 

Básicamente, se nos dan k números que son coprimos por pares, y se nos dan restos de estos números cuando se divide un número desconocido x por ellos. Necesitamos encontrar el valor mínimo posible de x que produce residuos dados.
Ejemplos:
Entrada: num [] = {5, 7}, rem [] = {1, 3}
Salida: 31

Explicación:
31 es el número más pequeño tal que:
   (1) Cuando lo dividimos entre 5, obtenemos el resto 1.
   (2) Cuando lo dividimos entre 7, obtenemos el resto 3.

Entrada: num [] = {3, 4, 5}, rem [] = {2, 3, 1}
Salida: 11

Explicación:
11 es el número más pequeño tal que:
   (1) Cuando lo dividimos por 3, obtenemos el resto 2.
   (2) Cuando lo dividimos entre 4, obtenemos el resto 3.
   (3) Cuando lo dividimos entre 5, obtenemos el resto 1.

El teorema chino del resto establece que siempre existe una x que satisface las congruencias dadas. A continuación se muestra el enunciado del teorema adaptado de wikipedia.
Sean num [0], num [1],… num [k-1] enteros positivos que son coprimos por pares. Entonces, para cualquier secuencia dada de enteros rem [0], rem [1],… rem [k-1], existe un entero x que resuelve el siguiente sistema de congruencias simultáneas.
Ilustración 2 9 Teorema del residuo chino
 

La primera parte es clara que existe una x. La segunda parte básicamente establece que todas las soluciones (incluida la mínima) producen el mismo resto cuando se dividen como subproducto de n [0], num [1], .. num [k-1]. En el ejemplo anterior, el producto es 3 * 4 * 5 = 60. Y 11 es una solución, otras soluciones son 71, 131, .. etc. Todas estas soluciones producen el mismo resto cuando se dividen por 60, es decir, son de forma 11 + m * 60 donde m&gt; = 0.

La solución se basa en la siguiente fórmula.
x =  ( ∑ (rem[i]*pp[i]*inv[i]) ) % prod
   Where 0 &lt;= i &lt;= n-1

rem[i] array de residuos

prod es producto de todos los números dados
prod = num[0] * num[1] * ... * num[k-1]

pp[i] es producto de todo dividido por num[i]
pp[i] = prod / num[i]

inv[i] = Modular Multiplicativo Inverso de
         pp[i] con respecto a num[i]

</texto>
  <complejidad_tiempo>null</complejidad_tiempo>
  <java>//Programa Java para demostrar el
//funcionamiento del teorema del resto chino

public class ChineseRemainder {

    //Devuelve el módulo inverso de a con respecto a m 
    //utilizando el algoritmo de Euclides extendido.
    static int inv(int a, int m) {
        int m0 = m, t, q;
        int x0 = 0, x1 = 1;

        if (m == 1) {
            return 0;
        }
        // Aplicando algoritmo de Euclides extendido
        while (a &gt; 1) {
            // q es cociente
            q = a / m;
            t = m;
            // m es el resto ahora, proceso igual que el algoritmo de euclides
            m = a % m;
            a = t;

            t = x0;

            x0 = x1 - q * x0;

            x1 = t;
        }
        // Hacer x1 positivo
        if (x1 &lt; 0) {
            x1 += m0;
        }

        return x1;
    }

    // k es el tamaño de num [] y rem [].
    // Devuelve el número más pequeño
    // x tal que:
    // x% num [0] = rem [0],
    // x% num [1] = rem [1],
    // ..................
    // x% num [k-2] = rem [k-1]
    // Supuesto: los números en num [] son 
    // coprimos por pares (mcd para cada par es 1)
    static int findMinX(int num[], int rem[], int k) {
        // Calcular el producto de todos los números
        int prod = 1;
        for (int i = 0; i &lt; k; i++) {
            prod *= num[i];
        }
        int result = 0;
        for (int i = 0; i &lt; k; i++) {
            int pp = prod / num[i];
            result += rem[i] * inv(pp, num[i]) * pp;
        }

        return result % prod;
    }

    public static void main(String args[]) {
        int num[] = {3, 4, 5};
        int rem[] = {2, 3, 1};
        int k = num.length;
        System.out.println(&quot;x is &quot; + findMinX(num, rem, k));
    }
}
</java>
  <cpp>#include&lt;bits/stdc++.h&gt; 
using namespace std;

int inv(int a, int m) {
    int m0 = m, t, q;
    int x0 = 0, x1 = 1;
    if (m == 1)
        return 0;
    while (a &gt; 1) {
        q = a / m;
        t = m;
        m = a % m, a = t;
        t = x0;
        x0 = x1 - q * x0;
        x1 = t;
    }
    if (x1 &lt; 0)
        x1 += m0;
    return x1;
}

int findMinX(int num[], int rem[], int k) {
    int prod = 1;
    for (int i = 0; i &lt; k; i++)
        prod *= num[i];
    int result = 0;
    for (int i = 0; i &lt; k; i++) {
        int pp = prod / num[i];
        result += rem[i] * inv(pp, num[i]) * pp;
    }
    return result % prod;
}

int main(void) {
    int num[] = {3, 4, 5};
    int rem[] = {2, 3, 1};
    int k = sizeof (num) / sizeof (num[0]);
    cout &lt;&lt; &quot;x is &quot; &lt;&lt; findMinX(num, rem, k);
    return 0;
}
</cpp>
  <py>def inv(a, m): 
    m0 = m 
    x0 = 0
    x1 = 1
    if (m == 1): 
        return 0
    while (a &gt; 1): 
        q = a // m 
        t = m 
        m = a % m 
        a = t 
        t = x0 
        x0 = x1 - q * x0 
        x1 = t 
    if (x1 &lt; 0): 
        x1 = x1 + m0 
    return x1 

def findMinX(num, rem, k): 
    prod = 1
    for i in range(0, k): 
        prod = prod * num[i] 
    result = 0
    for i in range(0, k): 
        pp = prod // num[i] 
        result = result + rem[i] * inv(pp, num[i]) * pp 
    return result % prod 
num = [3, 4, 5] 
rem = [2, 3, 1] 
k = len(num) 
print(&quot;x is &quot;, findMinX(num, rem, k)) 
</py>
  <orden>6</orden>
  <suborden>65</suborden>
  <fecha_creacion>2020-12-05 01:56:11</fecha_creacion>
  <fecha_modificacion>2022-03-08 11:56:49</fecha_modificacion>
</row>
<row>
  <ID>173</ID>
  <supergrupo>Matemática</supergrupo>
  <tema>Logaritmo discreto</tema>
  <texto>Dados tres números enteros a, b y m. Encuentre un número entero k tal que a ^ k≡b donde a y m son primos relativos. Si no es posible que ningún k satisfaga esta relación, imprima -1.</texto>
  <complejidad_tiempo>null</complejidad_tiempo>
  <java>// Programa Java para calcular logaritmos discretos

public class DiscreteLogarithm {

    /* Función iterativa para calcular (x ^ y)% p en
         O (log y) */
    static int powmod(int x, int y, int p) {
        int res = 1; // inicializar resultado

        x = x % p; // Actualice x si es más de o
        // igual a p
        while (y &gt; 0) {
            // Si y es impar, multiplica x con el resultado
            if ((y &amp; 1) &gt; 0) {
                res = (res * x) % p;
            }

            // y debe ser par ahora 
            y = y &gt;&gt; 1; // y = y/2 
            x = (x * x) % p;
        }
        return res;
    }

    // Función para calcular k para a, b, m dados
    static int discreteLogarithm(int a, int b, int m) {

        int n = (int) (Math.sqrt(m) + 1);

        int[] value = new int[m];

        // Almacene todos los valores de a ^ (n * i) de LHS
        for (int i = n; i &gt;= 1; --i) {
            value[powmod(a, i * n, m)] = i;
        }

        for (int j = 0; j &lt; n; ++j) {
            // Calcule (a ^ j) * by compruebe si hay colisión
            int cur = (powmod(a, j, m) * b) % m;
            // Si ocurre una colisión, es decir, LHS = RHS
            if (value[cur] &gt; 0) {
                int ans = value[cur] * n - j;
                // Compruebe si y se encuentra por debajo de m o no
                if (ans &lt; m) {
                    return ans;
                }
            }
        }
        return -1;
    }

    public static void main(String[] args) {
        int a = 2, b = 3, m = 5;
        System.out.println(discreteLogarithm(a, b, m));

        a = 3;
        b = 7;
        m = 11;
        System.out.println(discreteLogarithm(a, b, m));
    }
}
</java>
  <cpp>#include&lt;bits/stdc++.h&gt; 
using namespace std;

int discreteLogarithm(int a, int b, int m) {
    int n = (int) sqrt(m) + 1;
    int an = 1;
    for (int i = 0; i &lt; n; ++i)
        an = (an * a) % m;
    unordered_map&lt;int, int&gt; value;
    for (int i = 1, cur = an; i &lt;= n; ++i) {
        if (!value[ cur ])
            value[ cur ] = i;
        cur = (cur * an) % m;
    }
    for (int i = 0, cur = b; i &lt;= n; ++i) {
        if (value[cur]) {
            int ans = value[cur] * n - i;
            if (ans &lt; m)
                return ans;
        }
        cur = (cur * a) % m;
    }
    return -1;
}

int main() {
    int a = 2, b = 3, m = 5;
    cout &lt;&lt; discreteLogarithm(a, b, m) &lt;&lt; endl;
    a = 3, b = 7, m = 11;
    cout &lt;&lt; discreteLogarithm(a, b, m);
}
</cpp>
  <py>import math

def powmod(x, y, p): 
    res = 1; 
    x = x % p;
    while (y &gt; 0):  
        if (y &amp; 1): 
            res = (res * x) % p; 
        y = y &gt;&gt; 1; # y = y/2 
        x = (x * x) % p; 
    return res; 

def discreteLogarithm(a, b, m): 
    n = int(math.sqrt(m) + 1); 
    value = [0] * m; 
    for i in range(n, 0, -1): 
        value[powmod (a, i * n, m)] = i; 
    for j in range(n): 
        cur = (powmod (a, j, m) * b) % m; 
        if (value[cur]): 
            ans = value[cur] * n - j; 
            if (ans &lt; m): 
                return ans; 
    return -1; 

a = 2; 
b = 3; 
m = 5; 
print(discreteLogarithm(a, b, m)); 
a = 3; 
b = 7; 
m = 11; 
print(discreteLogarithm(a, b, m)); 
</py>
  <orden>6</orden>
  <suborden>66</suborden>
  <fecha_creacion>2020-12-05 01:56:11</fecha_creacion>
  <fecha_modificacion>2022-03-08 11:58:23</fecha_modificacion>
</row>
<row>
  <ID>174</ID>
  <supergrupo>Matemática</supergrupo>
  <tema>Eliminación Gaussiana</tema>
  <texto>Nos ocuparemos de una matriz de coeficientes. La eliminación gaussiana no funciona en matrices singulares (conducen a la división por cero).
Entrada: para N incógnitas, la entrada es una matriz aumentada de tamaño N x (N + 1). Una columna adicional es para el lado derecho 
  mat[N][N+1] = {
		   {3.0, 2.0,-4.0, 3.0},
                 {2.0, 3.0, 3.0, 15.0},
                 {5.0, -3, 1.0, 14.0}
                };
Resultado: La solución a las ecuaciones es:
        3.000000
        1.000000
        2.000000

Explicación:
La matriz dada representa las siguientes ecuaciones

3.0X1 + 2.0X2 - 4.0X3 =  3.0
2.0X1 + 3.0X2 + 3.0X3 = 15.0
5.0X1 - 3.0X2 +    X3 = 14.0

Existe una solución única para las ecuaciones dadas, las soluciones son:
X1 = 3.0, X2 = 1.0, X3 = 2.0, 


Forma escalonada de fila: se dice que la matriz está en r.e.f. si se cumplen las siguientes condiciones:
 
1. El primer elemento distinto de cero en cada fila, llamado coeficiente principal, es 1.
2. Cada coeficiente principal está en una columna a la derecha del coeficiente principal de la fila anterior.
3. Las filas con todos ceros están debajo de las filas con al menos un elemento distinto de cero.

 
Forma escalonada de fila reducida: se dice que la matriz está en r.r.e.f. si se cumplen las siguientes condiciones:
1. Todas las condiciones para r.e.f.
2. El coeficiente principal de cada fila es la única entrada distinta de cero en su columna.
El algoritmo trata principalmente de realizar una secuencia de operaciones en las filas de la matriz. Lo que nos gustaría tener en cuenta al realizar estas operaciones es que queremos convertir la matriz en una matriz triangular superior en forma escalonada. Las operaciones pueden ser:
1. Intercambio de dos filas
2. Multiplicar una fila por un escalar distinto de cero
3. Agregar a una fila un múltiplo de otra

El proceso:
1. Eliminación hacia adelante: reducción a la forma escalonada de fila. Usándolo uno puede saber si no hay soluciones, o una solución única, o infinitas soluciones.
2. Sustitución hacia atrás: reducción adicional a la forma escalonada de fila reducida.

Algoritmo:
1. Pivote parcial: encuentre el k-ésimo pivote intercambiando filas, para mover la entrada con el valor absoluto más grande a la posición del pivote. Esto imparte estabilidad computacional al algoritmo.
2. Para cada fila debajo del pivote, calcule el factor f que hace que la entrada k sea cero, y para cada elemento de la fila reste el quinto múltiplo del elemento correspondiente en la fila k.
3. Repita los pasos anteriores para cada desconocido. Nos quedaremos con una r.e.f. parcial. matriz.
Complejidad de tiempo: Dado que para cada pivote recorremos la parte a su derecha para cada fila debajo de él, O (n) * (O (n) * O (n)) = O (n3).
También podemos aplicar la eliminación gaussiana para calcular:
1. Rango de una matriz
2. Determinante de una matriz
3. Inversa de una matriz cuadrada invertible
</texto>
  <complejidad_tiempo>null</complejidad_tiempo>
  <java>//Resuelve sistemas de ecuaciones lineales 
//por eliminación Gaussiana. matrix contiene los 
//valores de la matriz cuadrada y result los resultados de 
//las ecuaciones. Retorna un vector con el valor de las n 
//incongnitas. Los resultados pueden necesitar redondeo.

import java.util.ArrayList;
import java.util.Random;

public class GaussianElimination {

    static int MAX = 100;
    static int n = 3;
    static double matrix[][] = new double[MAX][MAX];
    static double result[] = new double[MAX];

    static ArrayList&lt;Double&gt; gauss() {
        ArrayList&lt;Double&gt; ans = new ArrayList&lt;Double&gt;();
        for (int i = 0; i &lt; n; i++) {
            ans.add(0.0);
        }
        double temp;
        for (int i = 0; i &lt; n; i++) {
            int pivot = i;
            for (int j = i + 1; j &lt; n; j++) {
                temp = Math.abs(matrix[j][i]) - Math.abs(matrix[pivot][i]);
                if (temp &gt; 0.000001) {
                    pivot = j;
                }
            }
            double temp2[] = new double[n];
            System.arraycopy(matrix[i], 0, temp2, 0, n);
            System.arraycopy(matrix[pivot], 0, matrix[i], 0, n);
            System.arraycopy(temp2, 0, matrix[pivot], 0, n);
            temp = result[i];
            result[i] = result[pivot];
            result[pivot] = temp;
            if (!(Math.abs(matrix[i][i]) &lt; 0.000001)) {
                for (int k = i + 1; k &lt; n; k++) {
                    temp = -matrix[k][i] / matrix[i][i];
                    matrix[k][i] = 0;
                    for (int l = i + 1; l &lt; n; l++) {
                        matrix[k][l] += matrix[i][l] * temp;
                    }
                    result[k] += result[i] * temp;
                }
            }
        }
        for (int m = n - 1; m &gt;= 0; m--) {
            temp = result[m];
            for (int i = n - 1; i &gt; m; i--) {
                temp -= ans.get(i) * matrix[m][i];
            }
            ans.set(m, temp / matrix[m][m]);
        }
        return ans;
    }

    public static void main(String[] args) {
        Random r = new Random();
        for (int i = 0; i &lt; n; i++) {
            for (int j = 0; j &lt; n; j++) {
                matrix[i][j] = r.nextInt(20);
            }
        }
        for (int i = 0; i &lt; n; i++) {
            result[i] = r.nextInt(10);
        }
        for (int i = 0; i &lt; n; i++) {
            for (int j = 0; j &lt; n; j++) {
                System.out.print(matrix[i][j] + &quot; &quot;);
            }
            System.out.print(&quot;= &quot; + result[i]);
            System.out.println(&quot;&quot;);
        }
        ArrayList&lt;Double&gt; res = gauss();
        for (Double re : res) {
            System.out.print(re + &quot; &quot;);
        }
    }
}
</java>
  <cpp>#include &lt;bits/stdc++.h&gt;
#include &lt;cstdlib&gt;
using namespace std;
const int MAX = 100;
int n = 3;
double matrix[MAX][MAX];
double result[MAX];

vector&lt;double&gt; gauss() {
    vector&lt;double&gt; ans;
    for (int i = 0; i &lt; n; i++) {
        ans.emplace_back(0.0);
    }
    double temp;
    for (int i = 0; i &lt; n; i++) {
        int pivot = i;
        for (int j = i + 1; j &lt; n; j++) {
            temp = abs(matrix[j][i]) - abs(matrix[pivot][i]);
            if (temp &gt; 0.000001) {
                pivot = j;
            }
        }
        double temp2[n];
        copy(matrix[i], matrix[i] + n, temp2);
        copy(matrix[pivot], matrix[pivot] + n, matrix[i]);
        copy(temp2, temp2 + n, matrix[pivot]);
        temp = result[i];
        result[i] = result[pivot];
        result[pivot] = temp;
        if (!(abs(matrix[i][i]) &lt; 0.000001)) {
            for (int k = i + 1; k &lt; n; k++) {
                temp = -matrix[k][i] / matrix[i][i];
                matrix[k][i] = 0;
                for (int l = i + 1; l &lt; n; l++) {
                    matrix[k][l] += matrix[i][l] * temp;
                }
                result[k] += result[i] * temp;
            }
        }
    }
    for (int m = n - 1; m &gt;= 0; m--) {
        temp = result[m];
        for (int i = n - 1; i &gt; m; i--) {
            temp -= ans.at(i) * matrix[m][i];
        }
        auto itPos = ans.begin() + m;
        ans.insert(itPos, temp / matrix[m][m]);
        itPos = ans.begin() + m + 1;
        ans.erase(itPos);
    }
    return ans;
}

int main() {
    for (int i = 0; i &lt; n; i++) {
        for (int j = 0; j &lt; n; j++) {
            matrix[i][j] = rand() % 100;
        }
    }
    for (int i = 0; i &lt; n; i++) {
        result[i] = rand() % 100;
    }
    for (int i = 0; i &lt; n; i++) {
        for (int j = 0; j &lt; n; j++) {
            cout &lt;&lt; matrix[i][j] &lt;&lt; &quot; &quot;;
        }
        cout &lt;&lt; &quot;= &quot; &lt;&lt; result[i];
        cout &lt;&lt; endl;
    }
    vector&lt;double&gt; res = gauss();
    for (double re : res) {
        cout &lt;&lt; re &lt;&lt; &quot; &quot;;
    }
}
</cpp>
  <py>import math
import random as rand
MAX = 100
n = 3
matrix = [[0.0 for i in range (MAX)]for i in range (MAX)]
result = [0.0 for i in range (MAX)]
def gauss():
    ans = [0.0 for i in range (n)]
    for i in range (n):
        pivot = i
        for j in range (i + 1, n-1, -1):
            temp = abs(matrix[j][i]) - abs(matrix[pivot][i])
            if (temp &gt; 0.000001):
                pivot = j;
        temp2 = [0.0 for k in range (n)]
        temp2 = matrix[i]
        matrix[i] = matrix[pivot]
        matrix[pivot] = temp2
        temp = result[i]
        result[i] = result[pivot]
        result[pivot] = temp
        if (not(abs(matrix[i][i]) &lt; 0.000001)):
            for k in range (i + 1, n-1, -1):
                temp = -matrix[k][i] / matrix[i][i]
                matrix[k][i] = 0
                for l in range (i + 1, n-1, -1):
                    matrix[k][l] += matrix[i][l] * temp
                result[k] += result[i] * temp;
    for m in range (n-1, 0-1, -1):            
        temp = result[m]
        for i in range (n-1, m-1, -1):
            temp -= ans[i] * matrix[m][i]
        ans[m] = matrix[m][m]
    return ans

for i in range (n):
    for j in range (n):
        matrix[i][j] = rand.randint(0, 100)
for i in range (n):
    result[i] = rand.randint(0, 100)
for i in range (n):
    print(matrix[i][0:3])
    print(&quot;= &quot; + str(result[i]))
res = gauss();
print(res)
</py>
  <orden>6</orden>
  <suborden>67</suborden>
  <fecha_creacion>2020-12-05 01:56:11</fecha_creacion>
  <fecha_modificacion>2022-03-08 11:58:23</fecha_modificacion>
</row>
<row>
  <ID>175</ID>
  <supergrupo>Matemática</supergrupo>
  <tema>Últimos dos dígitos de una potencia de 2</tema>
  <texto>Dado un número n, necesitamos encontrar los dos últimos dígitos de 2n.
Ejemplos:
Entrada: n = 7
Salida: 28

Entrada: n = 72
Salida: 96
2 ^ 72 = 4722366482869645213696

La forma eficiente es mantener solo 2 dígitos después de cada multiplicación. Esta idea es muy similar a la discutida en Exponenciación modular donde se discute una forma general de encontrar (a ^ b)% c, aquí en este caso c es 10 ^ 2 ya que los dos últimos dígitos solo son necesarios.
</texto>
  <complejidad_tiempo>null</complejidad_tiempo>
  <java>// Código Java para encontrar los 2 últimos dígitos de 2 ^ n

public class LastTwoDigits2powN {

    /* Función iterativa para calcular (x ^ y)% p en O (log y) */
    static int power(long x, long y,
            long p) {
        int res = 1; // Inicializar resultado
        x = x % p; // Actualiza x si es mayor o igual que p
        while (y &gt; 0) {
            // Si y es impar, multiplica x con el resultado 
            long r = y &amp; 1;
            if (r == 1) {
                res = (res * (int) x) % (int) p;
            }
            // y debe ser par ahora
            y = y &gt;&gt; 1; // y = y/2 
            x = (x * x) % p;
        }
        return res;
    }

    // función para calcular el número de dígitos en x
    static int numberOfDigits(int x) {
        int i = 0;
        while (x != 0) {
            x /= 10;
            i++;
        }
        return i;
    }

    // Función Java para imprimir los últimos 2 dígitos de 2 ^ n
    static void LastTwoDigit(int n) {
        System.out.print(&quot;Last &quot; + 2
                + &quot; digits of &quot; + 2 + &quot;^&quot;);
        System.out.print(n + &quot; = &quot;);

        // Generando 10 ^ 2
        int temp = 1;
        for (int i = 1; i &lt;= 2; i++) {
            temp *= 10;
        }
        // Llamar exponenciación modular
        temp = power(2, n, temp);

        // Imprimiendo ceros más a la izquierda. Dado que (2 ^ n)% 2 puede 
        // tener dígitos menores que 2. En ese caso, necesitamos imprimir ceros
        for (int i = 0;
                i &lt; (2 - numberOfDigits(temp)); i++) {
            System.out.print(0 + &quot; &quot;);
        }

        // Si la temperatura no es cero, imprima la temperatura.
        // Si la temperatura es cero, entonces ya está impreso
        if (temp != 0) {
            System.out.println(temp);
        }
    }

    public static void main(String[] args) {
        int n = 72;
        LastTwoDigit(n);
    }
}
</java>
  <cpp>#include &lt;cstdlib&gt;
#include &lt;bits/stdc++.h&gt; 
using namespace std;

int power(long x, long y, long p) {
    int res = 1;
    x = x % p;
    while (y &gt; 0) {
        long r = y &amp; 1;
        if (r == 1) {
            res = (res * (int) x) % (int) p;
        }
        y = y &gt;&gt; 1;
        x = (x * x) % p;
    }
    return res;
}

int numberOfDigits(int x) {
    int i = 0;
    while (x != 0) {
        x /= 10;
        i++;
    }
    return i;
}

void LastTwoDigit(int n) {
    cout &lt;&lt; &quot;Last &quot; &lt;&lt; 2 &lt;&lt; &quot;digits of &quot; &lt;&lt; 2 &lt;&lt; &quot;^&quot;;
    cout &lt;&lt; n &lt;&lt; &quot; = &quot;;
    int temp = 1;
    for (int i = 1; i &lt;= 2; i++) {
        temp *= 10;
    }
    temp = power(2, n, temp);
    for (int i = 0;
            i &lt; (2 - numberOfDigits(temp)); i++) {
        cout &lt;&lt; 0 &lt;&lt; &quot; &quot;;
    }
    if (temp != 0) {
        cout &lt;&lt; temp &lt;&lt; endl;
    }
}

int main() {
    int n = 72;
    LastTwoDigit(n);
}
</cpp>
  <py>def power(x, y, p):
    res = 1
    x = x % p
    while (y &gt; 0):
        r = y &amp; 1
        if (r == 1):
            res = (res * int (x)) % int(p)
        y = y &gt;&gt; 1
        x = (x * x) % p
    return res

def numberOfDigits(x):
    i = 0
    while (x != 0):
        x /= 10
        i += 1
    return i

def LastTwoDigit(n):
    print(&quot;Last &quot; + str(2) + &quot;digits of &quot; + str(2) + &quot;^&quot; + str(n) + &quot; = &quot;)
    temp = 1
    for i in range (1, 3):
        temp *= 10
    temp = power(2, n, temp)
    aux = (2 - numberOfDigits(temp))
    for i in range (aux):
        print(str(0) + &quot; &quot;)
    if (temp != 0):
        print(temp);
n = 72
LastTwoDigit(n)
</py>
  <orden>6</orden>
  <suborden>68</suborden>
  <fecha_creacion>2020-12-05 01:56:12</fecha_creacion>
  <fecha_modificacion>2022-03-08 11:58:23</fecha_modificacion>
</row>
<row>
  <ID>176</ID>
  <supergrupo>Matemática</supergrupo>
  <tema>Ecuaciones lineales diofantinas</tema>
  <texto>Una ecuación diofántica es una ecuación polinomial, generalmente en dos o más incógnitas, de modo que solo se requieren las soluciones integrales. Una solución integral es una solución tal que todas las variables desconocidas toman solo valores enteros.

Dados tres números enteros a, b, c que representan una ecuación lineal de la forma: ax + by = c. Determina si la ecuación tiene una solución tal que xey son ambos valores integrales.

Ejemplos:
Entrada: a = 3, b = 6, c = 9
Salida: posible
Explicación: La ecuación resulta ser,
3x + 6y = 9 una solución integral sería
x = 1, y = 1

Entrada: a = 3, b = 6, c = 8
Salida: no posible
Explicación: o valores integrales de x e y
existe que puede satisfacer la ecuación 3x + 6y = 8

Entrada: a = 2, b = 5, c = 1
Salida: posible
Explicación: Varias soluciones integrales
posibles son, (-2,1), (3, -1) etc.

Para las ecuaciones lineales de ecuaciones diofánticas, existen soluciones integrales si y solo si, el MCD de los coeficientes de las dos variables divide perfectamente el término constante. En otras palabras, la solución integral existe si, MCD (a, b) divide c.
Por tanto, el algoritmo para determinar si una ecuación tiene una solución integral es bastante sencillo.

• Encuentra MCD de a y b
• Compruebe si c% GCD (a, b) == 0
• Si es así, imprima Posible
• Otra impresión no es posible
</texto>
  <complejidad_tiempo>null</complejidad_tiempo>
  <java>// Programa Java para buscar soluciones de ecuaciones diofánticas

public class LinearDiophantineEquations {

    // Función de utilidad para encontrar el GCD de dos números
    static int gcd(int a, int b) {
        return (a % b == 0)
                ? Math.abs(b) : gcd(b, a % b);
    }

    // Esta función comprueba si son posibles soluciones enteras
    static boolean isPossible(int a,
            int b, int c) {
        return (c % gcd(a, b) == 0);
    }

    public static void main(String[] args) {
        int a = 3, b = 6, c = 9;
        if (isPossible(a, b, c)) {
            System.out.println(&quot;Possible&quot;);
        } else {
            System.out.println(&quot;Not Possible&quot;);
        }
        a = 3;
        b = 6;
        c = 8;
        if (isPossible(a, b, c)) {
            System.out.println(&quot;Possible&quot;);
        } else {
            System.out.println(&quot;Not Possible&quot;);
        }
        a = 2;
        b = 5;
        c = 1;
        if (isPossible(a, b, c)) {
            System.out.println(&quot;Possible&quot;);
        } else {
            System.out.println(&quot;Not Possible&quot;);
        }
    }
}
</java>
  <cpp>#include &lt;cstdlib&gt;
#include &lt;bits/stdc++.h&gt; 
using namespace std;

int gcd(int a, int b) {
    return (a % b == 0) ? abs(b) : gcd(b, a % b);
}

bool isPossible(int a, int b, int c) {
    return (c % gcd(a, b) == 0);
}

int main() {
    int a = 3, b = 6, c = 9;
    if (isPossible(a, b, c)) {
        cout &lt;&lt; &quot;Possible&quot; &lt;&lt; endl;
    } else {
        cout &lt;&lt; &quot;Not Possible&quot; &lt;&lt; endl;
    }
    a = 3;
    b = 6;
    c = 8;
    if (isPossible(a, b, c)) {
        cout &lt;&lt; &quot;Possible&quot; &lt;&lt; endl;
    } else {
        cout &lt;&lt; &quot;Not Possible&quot; &lt;&lt; endl;
    }
    a = 2;
    b = 5;
    c = 1;
    if (isPossible(a, b, c)) {
        cout &lt;&lt; &quot;Possible&quot; &lt;&lt; endl;
    } else {
        cout &lt;&lt; &quot;Not Possible&quot; &lt;&lt; endl;
    }
}
</cpp>
  <py>def gcd(a, b):
    if(a % b == 0):
        return abs(b)
    else:
        return gcd(b, a % b)

def isPossible(a, b, c):
    return (c % gcd(a, b) == 0)
a = 3
b = 6
c = 9
if (isPossible(a, b, c)):
    
    print(&quot;Possible&quot;)
else:
    print(&quot;Not Possible&quot;) 
a = 3
b = 6
c = 8
if (isPossible(a, b, c)):
    print(&quot;Possible&quot;)
else:
    print(&quot;Not Possible&quot;)
a = 2;
b = 5;
c = 1;
if (isPossible(a, b, c)):
    print(&quot;Possible&quot;)
else:
    print(&quot;Not Possible&quot;)
</py>
  <orden>6</orden>
  <suborden>69</suborden>
  <fecha_creacion>2020-12-05 01:56:12</fecha_creacion>
  <fecha_modificacion>2022-03-08 12:01:48</fecha_modificacion>
</row>
<row>
  <ID>177</ID>
  <supergrupo>Matemática</supergrupo>
  <tema>Exponenciación de matrices</tema>
  <texto>¿Cuál es la complejidad de tiempo mínima para encontrar el número n de Fibonacci?
Podemos encontrar el número n de Fibonacci en el tiempo O (Log n) usando la exponenciación matricial.

Para resolver la exponenciación matricial asumimos un ecuación de recurrencia lineal como a continuación:
F (n) = a * F (n-1) + segundo * F (n-2) + c * F (n-3) para n&gt; = 3
. . . . . Ecuación (1) donde a, b y c son constantes.

Para esta relación de recurrencia, depende de tres valores anteriores.
Ahora intentaremos representar la Ecuación (1) en términos de la matriz.

[First Matrix] = [Second matrix] * [Third Matrix]
| F(n)   |     =   Matrix &#39;C&#39;    *  | F(n-1) |
| F(n-1) |                          | F(n-2) |
| F(n-2) |                          | F(n-3) |
 
La dimensión de la primera matriz es 3 x 1.
La dimensión de la tercera matriz también es 3 x 1.

Entonces la dimensión de la segunda matriz debe ser 3 x 3
[Para que se cumpla la regla de la multiplicación.]

Ahora necesitamos llenar la Matriz &#39;C&#39;.

Entonces de acuerdo con nuestra ecuación.
F(n) = a*F(n-1) + b*F(n-2) + c*F(n-3)
F(n-1) = F(n-1)
F(n-2) = F(n-2)

C = [a b c
     1 0 0
     0 1 0]

Ahora la relación entre la matriz se convierte en: 
[First Matrix]  [Second matrix]       [Third Matrix]
| F(n)   |  =  | a b c |  *           | F(n-1) |
| F(n-1) |     | 1 0 0 |              | F(n-2) |
| F(n-2) |     | 0 1 0 |              | F(n-3) |

Supongamos los valores iniciales para este caso: -
F(0) = 0
F(1) = 1
F(2) = 1

Entonces, necesitamos obtener F (n) en términos de estos valores.

Entonces, para n = 3, la ecuación (1) cambia a
| F(3) |  =  | a b c |  *           | F(2) |
| F(2) |     | 1 0 0 |              | F(1) |
| F(1) |     | 0 1 0 |              | F(0) |

Ahora de manera similar para n = 4
| F(4) |  =  | a b c |  *           | F(3) |
| F(3) |     | 1 0 0 |              | F(2) |
| F(2) |     | 0 1 0 |              | F(1) |

             - - - -  2 veces - - -
| F(4) |  =  | a b c |  * | a b c | *       | F(2) |
| F(3) |     | 1 0 0 |    | 1 0 0 |         | F(1) |
| F(2) |     | 0 1 0 |    | 0 1 0 |         | F(0) |

Entonces, para in, la Ecuación (1) cambia a

                - - - - - - - - n -2 veces - - - -  -       
| F(n)   |  =  | a b c | * | a b c | * ... * | a b c | * | F(2) |
| F(n-1) |     | 1 0 0 |   | 1 0 0 |         | 1 0 0 |   | F(1) |
| F(n-2) |     | 0 1 0 |   | 0 1 0 |         | 0 1 0 |   | F(0) |


| F(n)   |  =  [ | a b c | ] ^ (n-2)   *  | F(2) |
| F(n-1) |     [ | 1 0 0 | ]              | F(1) |
| F(n-2) |     [ | 0 1 0 | ]              | F(0) |

Entonces, simplemente podemos multiplicar nuestra Segunda matriz n-2 veces y luego multiplicarla con la tercera matriz para obtener el resultado. La multiplicación se puede hacer en (log n) tiempo usando el algoritmo Divide and Conquer para el poder.

Consideremos el problema de encontrar el término n de una serie definida usando la siguiente recurrencia.
enésimo término,
     F (n) = F (n-1) + F (n-2) + F (n-3), n&gt; = 3
Casos base:
     F (0) = 0, F (1) = 1, F (2) = 1
Podemos encontrar el término n usando lo siguiente:
Poniendo a = 1, b = 1 y c = 1 en la fórmula anterior

| F(n)   |  =  [ | 1 1 1 | ] ^ (n-2)   *  | F(2) |
| F(n-1) |     [ | 1 0 0 | ]              | F(1) |
| F(n-2) |     [ | 0 1 0 | ]              | F(0) 
Complejidad temporal de esta solución: O (log n)
</texto>
  <complejidad_tiempo>null</complejidad_tiempo>
  <java>// Programa JAVA para encontrar el valor de f (n) donde
// f (n) se define como
// F (n) = F (n-1) + F (n-2) + F (n-3), n&gt; = 3
// Casos base:
// F (0) = 0, F (1) = 1, F (2) = 1

public class MatrixExponentiation {

    // Una función de utilidad para multiplicar dos matrices a [][] y b [][]. 
    // El resultado de la multiplicación se almacena en b [][]
    static void multiply(int a[][], int b[][]) {
        // Crear una matriz auxiliar para almacenar elementos 
        // de la matriz de multiplicación.
        int mul[][] = new int[3][3];
        for (int i = 0; i &lt; 3; i++) {
            for (int j = 0; j &lt; 3; j++) {
                mul[i][j] = 0;
                for (int k = 0; k &lt; 3; k++) {
                    mul[i][j] += a[i][k]
                            * b[k][j];
                }
            }
        }

        // almacenar el resultado de la multiplicación en a [][]
        for (int i = 0; i &lt; 3; i++) {
            for (int j = 0; j &lt; 3; j++) // Actualizando nuestra matriz
            {
                a[i][j] = mul[i][j];
            }
        }
    }

    // Función para calcular F subir a potencia n-2.
    static int power(int F[][], int n) {
        int M[][] = {{1, 1, 1}, {1, 0, 0},
        {0, 1, 0}};
        // Multiplíquelo con valores iniciales, es decir, con F (0) = 0,
        // F (1) = 1, F (2) = 1
        if (n == 1) {
            return F[0][0] + F[0][1];
        }
        power(F, n / 2);
        multiply(F, F);
        if (n % 2 != 0) {
            multiply(F, M);
        }
        // Multiplíquelo con valores iniciales, es decir, 
        // con F (0) = 0, F (1) = 1, F (2) = 1
        return F[0][0] + F[0][1];
    }

    // Devuelve el n-ésimo término de una serie definida
    // usando la siguiente relación de recurrencia.
    // f (n) se define como
    // f (n) = f (n-1) + f (n-2) + f (n-3), n&gt; = 3
    // Casos base:
    // f (0) = 0, f (1) = 1, f (2) = 1
    static int findNthTerm(int n) {
        int F[][] = {{1, 1, 1}, {1, 0, 0},
        {0, 1, 0}};

        return power(F, n - 2);
    }

    public static void main(String[] args) {
        int n = 5;
        System.out.println(&quot;F(5) is &quot; + findNthTerm(n));
    }
}
</java>
  <cpp>#include&lt;bits/stdc++.h&gt; 
using namespace std;

void multiply(int a[3][3], int b[3][3]) {
    int mul[3][3];
    for (int i = 0; i &lt; 3; i++) {
        for (int j = 0; j &lt; 3; j++) {
            mul[i][j] = 0;
            for (int k = 0; k &lt; 3; k++) {
                mul[i][j] += a[i][k]
                        * b[k][j];
            }
        }
    }
    for (int i = 0; i &lt; 3; i++) {
        for (int j = 0; j &lt; 3; j++) {
            a[i][j] = mul[i][j];
        }
    }
}

int power(int F[3][3], int n) {
    int M[3][3] = {
        {1, 1, 1},
        {1, 0, 0},
        {0, 1, 0}
    };
    if (n == 1) {
        return F[0][0] + F[0][1];
    }
    power(F, n / 2);
    multiply(F, F);
    if (n % 2 != 0) {
        multiply(F, M);
    }
    return F[0][0] + F[0][1];
}

int findNthTerm(int n) {
    int F[3][3] = {
        {1, 1, 1},
        {1, 0, 0},
        {0, 1, 0}
    };

    return power(F, n - 2);
}

int main() {
    int n = 5;
    cout &lt;&lt; &quot;F(5) is &quot; &lt;&lt; findNthTerm(n) &lt;&lt; endl;
}
</cpp>
  <py>def multiply(a, b):
    mul = [[0 for i in range (3)]for j in range (3)]
    for i in range (3):
        for j in range(3):
            mul[i][j] = 0
            for k in range(3):
                mul[i][j] += a[i][k] * b[k][j]
    for i in range (3):
        for j in range(3):
            a[i][j] = mul[i][j]
 
def power(F, n):
    M = [[1, 1, 1],
        [1, 0, 0],
        [0, 1, 0]]
    if (n == 1):
        return F[0][0] + F[0][1]
    power(F, n / 2)
    multiply(F, F)
    if (n % 2 != 0):
        multiply(F, M)
    return F[0][0] + F[0][1]

def findNthTerm(n):
    F = [[1, 1, 1],
        [1, 0, 0],
        [0, 1, 0]]
    return power(F, n - 2)

n = 5
print(&quot;F(5) is &quot; + str(findNthTerm(n)));
</py>
  <orden>6</orden>
  <suborden>70</suborden>
  <fecha_creacion>2020-12-05 01:56:12</fecha_creacion>
  <fecha_modificacion>2022-03-08 12:01:47</fecha_modificacion>
</row>
<row>
  <ID>178</ID>
  <supergrupo>Matemática</supergrupo>
  <tema>Verificación de cuadrados mágicos</tema>
  <texto>Dada una matriz, comprueba si es un cuadrado mágico o no. Un cuadrado mágico es una matriz n x n de elementos distintos de 1 a n2 donde la suma de cualquier fila, columna o diagonal es siempre igual al mismo número.
Ejemplos:
Entrada: n = 3
 2   7   6
  9   5   1
  4   3   8
Salida: matriz mágica
Explicación: En la matriz, la suma de cada fila y cada columna y la suma diagonal es igual = 15.

Entrada: n = 3
  1   2   2 
  2   2   1
  2   1   2
Resultado: No es una matriz mágica
Explicación: En la matriz, la suma de cada fila y cada columna y la suma de las diagonales no es la misma.

1. Encuentre la suma de la diagonal principal y la diagonal secundaria.
2. Calcule la suma de cada fila y columna.
3. Si la suma de la diagonal principal y la diagonal secundaria es igual a la suma de cada fila y la suma de cada columna, entonces es una matriz mágica.
</texto>
  <complejidad_tiempo>null</complejidad_tiempo>
  <java>// Programa JAVA para verificar si una matriz dada es matriz mágica o no

public class IsMagicSquare {

    static int N = 3;

    // Devuelve verdadero si mat [][] es un cuadrado mágico, de lo contrario devuelve falso.
    static boolean isMagicSquare(int mat[][]) {

        // calcular la suma de la diagonal prima
        int sum = 0, sum2 = 0;
        for (int i = 0; i &lt; N; i++) {
            sum = sum + mat[i][i];
        }

        // la diagonal secundaria
        for (int i = 0; i &lt; N; i++) {
            sum2 = sum2 + mat[i][N - 1 - i];
        }

        if (sum != sum2) {
            return false;
        }

        // Para sumas de filas
        for (int i = 0; i &lt; N; i++) {

            int rowSum = 0;
            for (int j = 0; j &lt; N; j++) {
                rowSum += mat[i][j];
            }

            // compruebe si la suma de cada fila es igual a la suma diagonal principal
            if (rowSum != sum) {
                return false;
            }
        }

        // Para sumas de columnas
        for (int i = 0; i &lt; N; i++) {

            int colSum = 0;
            for (int j = 0; j &lt; N; j++) {
                colSum += mat[j][i];
            }

            // compruebe si la suma de cada columna es igual 
            // a la suma diagonal principal
            if (sum != colSum) {
                return false;
            }
        }

        return true;
    }

    public static void main(String[] args) {
        int mat[][] = {{2, 7, 6},
        {9, 5, 1},
        {4, 3, 8}};

        if (isMagicSquare(mat)) {
            System.out.println(&quot;Magic Square&quot;);
        } else {
            System.out.println(&quot;Not a magic&quot;
                    + &quot; Square&quot;);
        }
    }
}
</java>
  <cpp>#include &lt;bits/stdc++.h&gt; 

#define N 3 
using namespace std;

bool isMagicSquare(int mat[][N]) {

    int sum = 0, sum2 = 0;
    for (int i = 0; i &lt; N; i++)
        sum = sum + mat[i][i];
    for (int i = 0; i &lt; N; i++)
        sum2 = sum2 + mat[i][N - 1 - i];

    if (sum != sum2)
        return false;

    for (int i = 0; i &lt; N; i++) {

        int rowSum = 0;
        for (int j = 0; j &lt; N; j++)
            rowSum += mat[i][j];

        if (rowSum != sum)
            return false;
    }


    for (int i = 0; i &lt; N; i++) {

        int colSum = 0;
        for (int j = 0; j &lt; N; j++)
            colSum += mat[j][i];
        if (sum != colSum)
            return false;
    }

    return true;
}

int main() {
    int mat[][N] = {
        { 2, 7, 6},
        { 9, 5, 1},
        { 4, 3, 8}
    };

    if (isMagicSquare(mat))
        cout &lt;&lt; &quot;Magic Square&quot;;
    else
        cout &lt;&lt; &quot;Not a magic Square&quot;;

    return 0;
} 
</cpp>
  <py>N = 3

def isMagicSquare(mat): 
    s = 0 
    for i in range(0, N): 
        s = s + mat[i][i] 

    s2 = 0
    for i in range(0, N): 
        s2 = s2 + mat[i][N-i-1] 
  
    if(s != s2): 
        return False
 
    for i in range(0, N): 
        rowSum = 0;      
        for j in range(0, N): 
            rowSum += mat[i][j] 
         
        if (rowSum != s): 
            return False

    for i in range(0, N): 
        colSum = 0
        for j in range(0, N): 
            colSum += mat[j][i] 
        if (s != colSum): 
            return False
  
    return True
   
mat = [[2, 7, 6], 
    [9, 5, 1], 
    [4, 3, 8]] 
      
if (isMagicSquare(mat)): 
    print(&quot;Magic Square&quot;) 
else: 
    print(&quot;Not a magic Square&quot;) 
</py>
  <orden>6</orden>
  <suborden>71</suborden>
  <fecha_creacion>2020-12-05 01:56:13</fecha_creacion>
  <fecha_modificacion>2022-03-08 12:01:48</fecha_modificacion>
</row>
<row>
  <ID>179</ID>
  <supergrupo>Matemática</supergrupo>
  <tema>Búsqueda de datos faltantes en cuadrados mágicos </tema>
  <texto>Dado un tapete de matriz de 3X3 con los elementos de la diagonal izquierda que faltan (establecido en 0), considerando que la suma de cada fila, columna y diagonal de la matriz original era igual, la tarea es encontrar los elementos diagonales que faltan e imprimir la matriz original.
Ejemplos:
Entrada: mat[][] = {{0, 7, 6}, {9, 0, 1}, {4, 3, 0}}
Salida:
2 7 6
9 5 1
4 3 8
Suma de filas = Suma de columnas = Suma diagonal = 15
Entrada: mat[][] = {{0, 1, 1}, {1, 0, 1}, {1, 1, 0}}
Salida:
1 1 1
1 1 1
1 1 1
Enfoque: Sea Sum la suma total excluyendo los elementos diagonales,
Sum = suma total de la matriz dada - diagonalSum
Suma = (3 * rowSum) - diagonalSum
Sum = (2 * rowSum) [Dado que, columnSum = rowSum = diagonalSum]
rowSum = Sum / 2
Por lo tanto, podemos insertar un elemento en cada fila de modo que la suma de la fila sea rowSum
</texto>
  <complejidad_tiempo>null</complejidad_tiempo>
  <java>// JPrograma Java para llenar espacios en blanco con números

public class MagicSquareMissing {

    // Función para imprimir la matriz original
    static int printFilledDiagonal(int sq[][]) {
        // Calcular la suma de todos los elementos de la matriz
        int sum = 0;
        for (int i = 0; i &lt; 3; i++) {
            for (int j = 0; j &lt; 3; j++) {
                sum += sq[i][j];
            }
        }

        // Suma requerida de cada fila (del enfoque)
        sum /= 2;

        for (int i = 0; i &lt; 3; i++) {
            // Suma de filas excluyendo el elemento diagonal
            int rowSum = 0;
            for (int j = 0; j &lt; 3; j++) {
                rowSum += sq[i][j];
            }
            // Elemento que debe insertarse en el 
            // elemento diagonal de la fila actual
            sq[i][i] = sum - rowSum;
        }

        // Imprime la matriz actualizada
        for (int i = 0; i &lt; 3; i++) {
            for (int j = 0; j &lt; 3; j++) {
                System.out.print(sq[i][j] + &quot; &quot;);
            }
            System.out.println();
        }
        return 0;
    }

    public static void main(String[] args) {
        int sq[][] = {
            {0, 7, 6},
            {9, 0, 1},
            {4, 3, 0}
        };

        printFilledDiagonal(sq);
    }

}
</java>
  <cpp>#include &lt;bits/stdc++.h&gt; 
using namespace std;

int printFilledDiagonal(int sq[][3]) {

    int sum = 0;
    for (int i = 0; i &lt; 3; i++)
        for (int j = 0; j &lt; 3; j++)
            sum += sq[i][j];

    sum /= 2;

    for (int i = 0; i &lt; 3; i++) {
        int rowSum = 0;
        for (int j = 0; j &lt; 3; j++)
            rowSum += sq[i][j];
        sq[i][i] = sum - rowSum;
    }

    for (int i = 0; i &lt; 3; i++) {
        for (int j = 0; j &lt; 3; j++)
            cout &lt;&lt; sq[i][j] &lt;&lt; &quot; &quot;;
        cout &lt;&lt; endl;
    }
}

int main() {
    int sq[3][3] = {
        { 0, 7, 6},
        { 9, 0, 1},
        { 4, 3, 0}
    };

    printFilledDiagonal(sq);
    return 0;
} 
</cpp>
  <py>def printFilledDiagonal(sq):  
  
    Sum = 0
    for i in range(0, 3):  
        for j in range(0, 3):  
            Sum += sq[i][j]  
 
    Sum = Sum // 2
  
    for i in range(0, 3):  
        rowSum = 0
        for j in range(0, 3):  
            rowSum += sq[i][j]  
 
        sq[i][i] = Sum - rowSum  
      
    for i in range(0, 3):  
        for j in range(0, 3):  
            print(sq[i][j], end=&quot; &quot;)  
        print() 
        
sq = [[0, 7, 6], 
    [9, 0, 1], 
    [4, 3, 0]]  

printFilledDiagonal(sq)  
      
</py>
  <orden>6</orden>
  <suborden>72</suborden>
  <fecha_creacion>2020-12-05 01:56:13</fecha_creacion>
  <fecha_modificacion>2022-03-08 12:01:47</fecha_modificacion>
</row>
<row>
  <ID>180</ID>
  <supergrupo>Matemática</supergrupo>
  <tema>Intercambio mínimo entre esquinas</tema>
  <texto>Dado el número N de elementos, encuentre el número mínimo de intercambios requeridos para que el elemento máximo esté al principio y el elemento mínimo esté al final con la condición de que solo se permita el intercambio de elementos adyacentes.

Ejemplos:
Entrada: a [] = {3, 1, 5, 3, 5, 5, 2}
Salida: 6
Paso 1: intercambie 5 con 1 para hacer el array como {3, 5, 1, 3, 5, 5, 2}
Paso 2: intercambia 5 por 3 para hacer el array como {5, 3, 1, 3, 5, 5, 2}
Paso 3: intercambia 1 con 3 a su derecha para hacer el array como {5, 3, 3, 1, 5, 5, 2}
Paso 4: intercambie 1 con 5 a su derecha para hacer el array como {5, 3, 3, 5, 1, 5, 2}
Paso 5: intercambia 1 con 5 a su derecha para hacer el array como {5, 3, 3, 5, 5, 1, 2}
Paso 6: intercambie 1 con 2 a su derecha para hacer el array como {5, 3, 3, 5, 5, 2, 1}
Después de realizar 6 operaciones de intercambio, 5 está al principio y 1 al final
Entrada: a [] = {5, 6, 1, 3}
Salida: 2

El enfoque será encontrar el índice del elemento más grande (sea l). Encuentre el índice del elemento más grande más a la izquierda si el elemento más grande aparece en el array más de una vez. De manera similar, encuentre el índice del elemento más pequeño más a la derecha (sea r). Existen dos casos para solucionar este problema.
1. Caso 1: Si l &lt;r: Número de intercambios = l + (n-r-1)
2. Caso 2: Si l&gt; r: Número de intercambios = l + (n-r-2), ya que ya se realizó un intercambio mientras se intercambiaba el elemento más grande al frente
</texto>
  <complejidad_tiempo>null</complejidad_tiempo>
  <java>// Programa Java para contar Número mínimo de intercambios para que el
// elemento más grande esté al principio y el elemento más pequeño esté al final

import java.io.*;

public class MinimumAdjacentSwapsMaxMinCorners {

    public static void minimumSwaps(int a[], int n) {
        int maxx = -1, minn = a[0], l = 0, r = 0;
        for (int i = 0; i &lt; n; i++) {
            // Índice del elemento más grande situado más a la izquierda
            if (a[i] &gt; maxx) {
                maxx = a[i];
                l = i;
            }
            // Índice del elemento más pequeño situado más a la derecha
            if (a[i] &lt;= minn) {
                minn = a[i];
                r = i;
            }
        }
        if (r &lt; l) {
            System.out.println(l + (n - r - 2));
        } else {
            System.out.println(l + (n - r - 1));
        }
    }

    public static void main(String args[]) throws IOException {
        int a[] = {5, 6, 1, 3};
        int n = a.length;
        minimumSwaps(a, n);
    }
}
</java>
  <cpp>null</cpp>
  <py>null</py>
  <orden>6</orden>
  <suborden>73</suborden>
  <fecha_creacion>2020-12-05 01:56:13</fecha_creacion>
  <fecha_modificacion>2022-03-08 12:01:47</fecha_modificacion>
</row>
<row>
  <ID>181</ID>
  <supergrupo>Matemática</supergrupo>
  <tema>Multiplicación modular</tema>
  <texto>Considere a continuación un método simple para multiplicar dos números.
Una solución simple que causa un desbordamiento cuando el valor de (a% mod) * (b% mod) supera el valor máximo de long long int  

#define ll long long
ll multiply(ll a, ll b, ll mod) 
{ 
   return ((a % mod) * (b % mod)) % mod; 
}

La función anterior funciona bien cuando la multiplicación no da como resultado un desbordamiento. Pero si los números de entrada son tales que el resultado de la multiplicación supera el límite máximo.
Por ejemplo, el método anterior falla cuando mod = 1011, a = 9223372036854775807 (mayor largo int largo) yb = 9223372036854775807 (mayor int largo largo). Tenga en cuenta que puede haber valores más pequeños para los que puede fallar. Puede haber muchos más ejemplos de valores más pequeños. De hecho, cualquier conjunto de valores para los que la multiplicación puede generar un valor superior al límite máximo.

¿Cómo evitar el desbordamiento?
Podemos multiplicar de forma recursiva para superar la dificultad del desbordamiento. Para multiplicar a * b, primero calcula a * b / 2 y luego súmalo dos veces. Para calcular a * b / 2, calcule a * b / 4 y así sucesivamente (similar al algoritmo de exponenciación log n).

// Computar (a * b) % mod
multiply(a,  b, mod)
1)  ll res = 0; // Inicializar resultado
2)  a = a % mod.
3)  While (b &gt; 0)
        a) Si b es impar, agregue &#39;a&#39; al resultado.
               res = (res + a) % mod
        b) Multiplica &#39;a&#39; por 2
           a = (a * 2) % mod
        c) Dividir &#39;b&#39; por 2
           b = b/2  
4)  Return res 
</texto>
  <complejidad_tiempo>null</complejidad_tiempo>
  <java>// Realiza la operación (a * b) % mod minimizando posibles desbordamientos.

public class ModMultiplication {

    public static long modmul(long a, long b, long mod) {
        long x = 0;
        long y = a % mod;
        while (b &gt; 0) {
            if (b % 2 == 1) {
                x = (x + y) % mod;
            }
            y = (y &lt;&lt; 1) % mod;
            b &gt;&gt;= 1;
        }
        return x % mod;
    }

    public static void main(String[] args) {
        System.out.println(modmul(2, 2, 2));
    }
}
</java>
  <cpp>#include &lt;bits/stdc++.h&gt; 
using namespace std;

long modmul(long a, long b, long mod) {
    long x = 0;
    long y = a % mod;
    while (b &gt; 0) {
        if (b % 2 == 1) {
            x = (x + y) % mod;
        }
        y = (y &lt;&lt; 1) % mod;
        b &gt;&gt;= 1;
    }
    return x % mod;
}

int main() {
    cout &lt;&lt; modmul(2, 2, 2) &lt;&lt; endl;
}
</cpp>
  <py>def modmul(a, b, mod):
    x = 0
    y = a % mod
    while (b &gt; 0):
        if (b % 2 == 1):
            x = (x + y) % mod
        y = (y &lt;&lt; 1) % mod;
        b &gt;&gt;= 1;
    return x % mod;
print(modmul(2, 2, 2))
</py>
  <orden>6</orden>
  <suborden>74</suborden>
  <fecha_creacion>2020-12-05 01:56:14</fecha_creacion>
  <fecha_modificacion>2022-03-08 12:01:47</fecha_modificacion>
</row>
<row>
  <ID>182</ID>
  <supergrupo>Matemática</supergrupo>
  <tema>Next Permutation</tema>
  <texto>Dada una matriz o cadena, la tarea es encontrar la siguiente permutación lexicográficamente mayor de la misma.

Ejemplos:
Entrada: string = &quot;gfg&quot;
Salida: ggf

Entrada: arr [] = {1, 2, 3}
Salida: {1, 3, 2}

En C ++, hay una función específica que nos ahorra mucho código. Está en el archivo de encabezado #include &lt;algorithm&gt;. La función es next_permutation (a.begin (), a.end ()). Se utiliza para reorganizar los elementos en el rango [primero, último) en la siguiente permutación lexicográficamente mayor. Una permutación es cada uno de los N! posibles disposiciones que pueden tomar los elementos (donde N es el número de elementos en el rango). Se pueden ordenar diferentes permutaciones según cómo se comparan lexicográficamente entre sí.
Aparentemente, Java no proporciona ningún método incorporado.


1. Encuentre el sufijo no creciente más largo y encuentre el pivote.
2. Si el sufijo es la matriz completa, entonces no hay permutación de orden superior para los datos.
3. Encuentre el sucesor del pivote situado más a la derecha.
4. Cambie el sucesor y el pivote.
5. Invierta el sufijo.
</texto>
  <complejidad_tiempo>null</complejidad_tiempo>
  <java>// Programa Java para implementar el método next_permutation

import java.util.Arrays;

public class NextPermutation {

    // Función para intercambiar los datos presentes en los índices izquierdo y derecho
    public static int[] swap(int data[], int left, int right) {

        // Intercambiar los datos
        int temp = data[left];
        data[left] = data[right];
        data[right] = temp;

        // Devuelve la matriz actualizada
        return data;
    }

    // Función para invertir la submatriz comenzando 
    // de izquierda a derecha ambos inclusive
    public static int[] reverse(int data[], int left, int right) {

        // Invertir la submatriz
        while (left &lt; right) {
            int temp = data[left];
            data[left++] = data[right];
            data[right--] = temp;
        }

        // Devuelve la matriz actualizada
        return data;
    }

    // Función para encontrar la siguiente permutación de la matriz de enteros dada
    public static boolean findNextPermutation(int data[]) {

        // Si el conjunto de datos dado está vacío o contiene solo 
        // un elemento next_permutation no es posible
        if (data.length &lt;= 1) {
            return false;
        }

        int last = data.length - 2;

        // encuentra el sufijo no creciente más largo y encuentra el pivote
        while (last &gt;= 0) {
            if (data[last] &lt; data[last + 1]) {
                break;
            }
            last--;
        }

        // Si no hay un par creciente, no hay permutación de orden superior
        if (last &lt; 0) {
            return false;
        }

        int nextGreater = data.length - 1;

        // Encuentra el sucesor más a la derecha del pivote
        for (int i = data.length - 1; i &gt; last; i--) {
            if (data[i] &gt; data[last]) {
                nextGreater = i;
                break;
            }
        }

        // Intercambiar el sucesor y el pivote
        data = swap(data, nextGreater, last);

        // Invertir el sufijo
        data = reverse(data, last + 1, data.length - 1);

        // Devuelve verdadero cuando se realiza next_permutation
        return true;
    }

    public static void main(String args[]) {
        int data[] = {1, 2, 3};
        if (!findNextPermutation(data)) {
            System.out.println(&quot;There is no higher&quot;
                    + &quot; order permutation &quot;
                    + &quot;for the given data.&quot;);
        } else {
            System.out.println(Arrays.toString(data));
        }
    }
}
</java>
  <cpp>#include &lt;algorithm&gt; 
#include &lt;iostream&gt; 
using namespace std;

int main() {
    int arr[] = {1, 2, 3};
    int n = sizeof (arr) / sizeof (arr[0]);

    sort(arr, arr + n);

    cout &lt;&lt; &quot;The &quot; &lt;&lt; n &lt;&lt; &quot;! possible permutations with &quot; &lt;&lt; n &lt;&lt; &quot; elements:\n&quot;;
    do {
        cout &lt;&lt; arr[0] &lt;&lt; &quot; &quot; &lt;&lt; arr[1] &lt;&lt; &quot; &quot; &lt;&lt; arr[2] &lt;&lt; &quot;\n&quot;;
    } while (next_permutation(arr, arr + 3));

    cout &lt;&lt; &quot;After loop: &quot; &lt;&lt; arr[0] &lt;&lt; &#39; &#39;
            &lt;&lt; arr[1] &lt;&lt; &#39; &#39; &lt;&lt; arr[2] &lt;&lt; &#39;\n&#39;;

    return 0;
}
</cpp>
  <py>def swap(data, left, right):
    temp = data[left]
    data[left] = data[right]
    data[right] = temp
    return data

def reverse(data, left, right):
    while (left &lt; right):
        temp = data[left]
        left += 1
        data[left] = data[right]
        right -= 1
        data[right] = temp
    return data;

def findNextPermutation(data):
    if (len(data) &lt;= 1):
        return False;
    last = len(data) - 2
    while (last &gt;= 0):
        if (data[last] &lt; data[last + 1]):
            break
        last -= 1
    if (last &lt; 0):
        return False
    nextGreater = len(data) - 1
    for i in range (len(data)-1, last, -1):
        if (data[i] &gt; data[last]):
            nextGreater = i
            break
    data = swap(data, nextGreater, last);
    data = reverse(data, last + 1, len(data) - 1);
    return True


data = [1, 2, 3]
if (findNextPermutation(data) == False):
    print(&quot;There is no higher&quot;
          + &quot; order permutation &quot;
          + &quot;for the given data.&quot;)
else:
    print(data)

</py>
  <orden>6</orden>
  <suborden>75</suborden>
  <fecha_creacion>2020-12-05 01:56:14</fecha_creacion>
  <fecha_modificacion>2022-03-08 12:01:47</fecha_modificacion>
</row>
<row>
  <ID>183</ID>
  <supergrupo>Matemática</supergrupo>
  <tema>Prev Permutation</tema>
  <texto>Dada una palabra, encuentre una permutación lexicográficamente más pequeña de ella. Por ejemplo, la permutación lexicográficamente más pequeña de &quot;4321&quot; es &quot;4312&quot; y la siguiente permutación más pequeña de &quot;4312&quot; es &quot;4231&quot;. Si la cadena está ordenada en orden ascendente, la siguiente permutación lexicográficamente más pequeña no existe.
Hemos discutido next_permutation () que modifica una cadena para que almacene permutación lexicográficamente más pequeña. STL también proporciona std :: prev_permutation. Devuelve &quot;verdadero&quot; si la función pudiera reorganizar el objeto como una permutación lexicográficamente más pequeña. De lo contrario, devuelve &quot;falso&quot;.
</texto>
  <complejidad_tiempo>null</complejidad_tiempo>
  <java>import java.util.Arrays;

public class PrevPermutation {

    public static boolean prev_permutation(int[] arr) {
        int len = arr.length;
        int i = len - 1;
        // 1. encuentra el mayor i donde arr [i - 1]&gt; arr [i]
        while (i &gt; 0) {
            if (arr[i - 1] &gt; arr[i]) {
                break;
            }
            i--;
        }
        if (i &lt;= 0) {
            return false;
        }
        // 2. encontrar el mayor j donde arr [i - 1]&gt; arr [j] yj&gt; = i
        int j = len - 1;
        while (j &gt;= i) {
            if (arr[i - 1] &gt; arr[j]) {
                break;
            }
            j--;
        }
        // 3. intercambiar elementos entre arr [i-1] y arr [j]
        swap(i - 1, j, arr);
        // 4. invertir elementos desde i hasta el final de la matriz
        len--;
        while (i &lt; len) {
            swap(i, len, arr);
            len--;
            i++;
        }
        return true;
    }

    public static void swap(int x, int y, int[] arr) {
        int temp = arr[x];
        arr[x] = arr[y];
        arr[y] = temp;
    }

    public static void main(String[] args) {
        int data[] = {3, 2, 1};
        while (prev_permutation(data)) {
            System.out.println(Arrays.toString(data));
        }
    }
}

</java>
  <cpp>#include &lt;algorithm&gt; 
#include &lt;iostream&gt; 
using namespace std;

int main() {
    int arr[] = {1, 2, 3};
    int n = sizeof (arr) / sizeof (arr[0]);

    sort(arr, arr + n);
    reverse(arr, arr + n);

    cout &lt;&lt; &quot;The &quot; &lt;&lt; n &lt;&lt; &quot;! possible permutations with &quot; &lt;&lt; n &lt;&lt; &quot; elements:\n&quot;;
    do {
        cout &lt;&lt; arr[0] &lt;&lt; &quot; &quot; &lt;&lt; arr[1] &lt;&lt; &quot; &quot; &lt;&lt; arr[2] &lt;&lt; &quot;\n&quot;;
    } while (prev_permutation(arr, arr + 3));

    cout &lt;&lt; &quot;After loop: &quot; &lt;&lt; arr[0] &lt;&lt; &#39; &#39; &lt;&lt; arr[1]
            &lt;&lt; &#39; &#39; &lt;&lt; arr[2] &lt;&lt; &#39;\n&#39;;
    return 0;
}

</cpp>
  <py>def swap(x, y, arr):
    temp = arr[x]
    arr[x] = arr[y]
    arr[y] = temp
    
def prev_permutation(arr):
    lenght = len(arr)
    i = lenght - 1
    while (i &gt; 0):
        if (arr[i - 1] &gt; arr[i]):
            break
        i -= 1
    if (i &lt;= 0):
        return False
    j = lenght - 1
    while (j &gt;= i):
        if (arr[i - 1] &gt; arr[j]):
            break
        j -= 1
    swap(i - 1, j, arr);
    lenght -= 1
    while (i &lt; lenght):
        swap(i, lenght, arr)
        lenght -= 1
        i += 1
    return True;
data = [3, 2, 1]
while (prev_permutation(data)):
    print(data)
</py>
  <orden>6</orden>
  <suborden>76</suborden>
  <fecha_creacion>2020-12-05 01:56:14</fecha_creacion>
  <fecha_modificacion>2022-03-08 12:01:47</fecha_modificacion>
</row>
<row>
  <ID>184</ID>
  <supergrupo>Matemática</supergrupo>
  <tema>Tripletas pitagóricas</tema>
  <texto>Un triplete pitagórico es un conjunto de tres enteros positivos a, b y c tales que a2 + b2 = c2. Dado un límite, genere todos los Triples pitagóricos con valores menores que el límite dado.
Entrada: límite = 20
Salida: 3 4 5
        	  8 6 10
           5 12 13
           15 8 17
           12 16 20
Una solución simple es generar estos tripletes más pequeños que el límite dado utilizando tres bucles anidados. Para cada triplete, verifique si la condición pitagórica es verdadera, si es verdadera, luego imprima el triplete. La complejidad temporal de esta solución es O (límite3) donde &quot;límite&quot; se da límite.
Una solución eficiente puede imprimir todos los tripletes en el tiempo O (k) donde k es el número de tripletes impresos. La idea es usar la relación de suma cuadrada del triplete pitagórico, es decir, la suma de los cuadrados de a y b es igual al cuadrado de c, podemos escribir estos números en términos de m y n de manera que,
	a = m2 - n2
       b = 2 * m * n
       c  = m2 + n2
porque,
       a2 = m4 + n4 – 2 * m2 * n2
       b2 = 4 * m2 * n2
       c2 = m4 + n4 + 2* m2 * n2
Podemos ver que a2 + b2 = c2, por lo que en lugar de iterar para a, b y c, podemos iterar para m y n y podemos generar estos tripletes.
</texto>
  <complejidad_tiempo>null</complejidad_tiempo>
  <java>// Programa Java para generar tripletes pitagóricos 
// más pequeños que un límite dado

public class PythagoreanTriplets {

    // Función para generar tripletes pitagóricos menores que el límite
    static void pythagoreanTriplets(int limit) {

        // triplete: a ^ 2 + b ^ 2 = c ^ 2
        int a, b, c = 0;

        // bucle de 2 a max_limit
        int m = 2;

        // Limitar c limitaría todo a, b y c
        while (c &lt; limit) {

            // ahora bucle en j de 1 a i-1
            for (int n = 1; n &lt; m; ++n) {
                // Evaluar e imprimir tripletes usando 
                // la relación entre a, by c
                a = m * m - n * n;
                b = 2 * m * n;
                c = m * m + n * n;

                if (c &gt; limit) {
                    break;
                }

                System.out.println(a + &quot; &quot; + b + &quot; &quot; + c);
            }
            m++;
        }
    }

    public static void main(String args[]) {
        int limit = 20;
        pythagoreanTriplets(limit);
    }
}
</java>
  <cpp>#include &lt;bits/stdc++.h&gt; 

void pythagoreanTriplets(int limit) {

    int a, b, c = 0;
    int m = 2;

    while (c &lt; limit) {
        for (int n = 1; n &lt; m; ++n) {
            a = m * m - n * n;
            b = 2 * m * n;
            c = m * m + n * n;
            if (c &gt; limit)
                break;
            printf(&quot;%d %d %d\n&quot;, a, b, c);
        }
        m++;
    }
}

int main() {
    int limit = 20;
    pythagoreanTriplets(limit);
    return 0;
} 
</cpp>
  <py>def pythagoreanTriplets(limits) : 
    c, m = 0, 2
    while c &lt; limits : 
        for n in range(1, m) : 
            a = m * m - n * n 
            b = 2 * m * n 
            c = m * m + n * n 
            if c &gt; limits : 
                break
  
            print(a, b, c) 
  
        m = m + 1
        
limit = 20
pythagoreanTriplets(limit) 
</py>
  <orden>6</orden>
  <suborden>77</suborden>
  <fecha_creacion>2020-12-05 01:56:14</fecha_creacion>
  <fecha_modificacion>2022-03-08 12:01:47</fecha_modificacion>
</row>
<row>
  <ID>185</ID>
  <supergrupo>Matemática</supergrupo>
  <tema>Horas posibles</tema>
  <texto>Dada una temporización de uno o dos dígitos, calcule las posibilidades de ocurrencia de otras temporizaciones (incluida la que brilla intensamente) con respecto a los segmentos brillantes, asumiendo que algunos segmentos pueden no estar brillantes.
La visualización de los números se realiza mediante una pantalla de siete segmentos. Se garantiza que los palos que se muestran actualmente funcionan bien.
 
Examples:
Entrada: 78
Salida: 5

Entrada: 05
Salida: 8
Explicación:
Ejemplo 1: 7 se puede reemplazar por 5 números diferentes 9, 3, 8, 0 y 7 (si ninguno de los segmentos está roto) y 8 se puede reemplazar por solo 1 número, es decir, el 8 en sí mismo (si ninguno de los segmentos está roto) , por lo tanto, la respuesta es 5 * 1 = 5.
Ejemplo 2: 0 se puede reemplazar por 2 números, 8 y 0, mientras que 5 se puede reemplazar por 4 números diferentes. Entonces, la respuesta es 4 * 2 = 8.

Aproximación :
Calcule para cada número del 0 al 9 qué dígitos son posibles sumando o
quitando exactamente una varilla de la pantalla. Almacene esto en una matriz y la respuesta será el producto del valor de la matriz de ambos dígitos de la entrada.
</texto>
  <complejidad_tiempo>null</complejidad_tiempo>
  <java>// Programa Java para calcular posibles tiempos.

public class PossibleTimings {
    // Array que almacena diferentes números de dígitos, 
    // un dígito en particular se puede reemplazar con

    static int num[] = {2, 7, 2, 3, 3, 4, 2, 5, 1, 2};

    public static void possibleTimings(String n) {
        System.out.println(num[(n.charAt(0) - &#39;0&#39;)]
                * num[n.charAt(1) - &#39;0&#39;]);
    }

    public static void main(String args[]) {
        String n = &quot;05&quot;;
        possibleTimings(n);
    }
}
</java>
  <cpp>#include &quot;bits/stdc++.h&quot; 
using namespace std;

int num[] = {2, 7, 2, 3, 3, 4, 2, 5, 1, 2};

void possibleTimings(string n) {
    cout &lt;&lt; (num[(n.at(0) - &#39;0&#39;)]
            * num[n.at(1) - &#39;0&#39;]) &lt;&lt; endl;
}

int main() {
    string n = &quot;05&quot;;
    possibleTimings(n);
}
</cpp>
  <py>num = [2, 7, 2, 3, 3, 4, 2, 5, 1, 2]
def possibleTimings(n):
    print(num[(ord(n[0]) - ord(&#39;0&#39;))] * num[ord(n[1]) - ord(&#39;0&#39;)]) 

n = &quot;05&quot;
possibleTimings(n)
</py>
  <orden>6</orden>
  <suborden>78</suborden>
  <fecha_creacion>2020-12-05 01:56:15</fecha_creacion>
  <fecha_modificacion>2022-03-08 12:01:47</fecha_modificacion>
</row>
<row>
  <ID>186</ID>
  <supergrupo>Matemática</supergrupo>
  <tema>Factorización prima</tema>
  <texto>Podemos calcular la factorización prima de un número &quot;n&quot; en O (sqrt (n)). Pero el método O (sqrt n) se agota cuando necesitamos responder múltiples consultas sobre factorización prima.

Concepto clave: Nuestra idea es almacenar el factor primo más pequeño (SPF) para cada número. Luego, para calcular la factorización prima del número dado dividiendo el número dado de forma recursiva con su factor primo más pequeño hasta que se convierta en 1.

Para calcular el factor primo más pequeño de cada número, usaremos el tamiz de eratóstenes. En la criba original, cada vez que marcamos un número como no primo, almacenamos el factor primo más pequeño correspondiente para ese número.

Ahora, después de que hayamos terminado de calcular previamente el factor primo más pequeño para cada número, dividiremos nuestro número n (cuya factorización prima se calculará) por su factor primo más pequeño correspondiente hasta que n se convierta en 1.
Pseudocódigo para factorización prima asumiendo que los SPF se calculan:

PrimeFactors [] // Para almacenar el resultado

i = 0 // Índice en PrimeFactors

mientras que n! = 1:

    // SPF: factor primo más pequeño
    PrimeFactors [i] = SPF [n]
    yo ++
    n = n / SPF [n]

Nota: El código anterior funciona bien para n hasta el orden de 10 ^ 7. Más allá de esto, enfrentaremos problemas de memoria.
Complejidad de tiempo: el cálculo previo para el factor primo más pequeño se realiza en O (n log log n) utilizando un tamiz. Donde, como en el paso de cálculo, estamos dividiendo el número cada vez por el número primo más pequeño hasta que se convierte en 1. Entonces, consideremos el peor de los casos en el que cada vez el SPF es 2. Por lo tanto, tendrá log n pasos de división. Por tanto, podemos decir que nuestra Complejidad de Tiempo será O (log n) en el peor de los casos.
</texto>
  <complejidad_tiempo>null</complejidad_tiempo>
  <java>//Guarda en factors la lista de factores primos de n de menor a 
//mayor. IMPORTANTE: Debe ejecutarse primero Sieve of Eratosthenes 
//(al menos hasta un numero mayor a la raiz cuadrada de n).

import java.util.ArrayList;

public class PrimeFactorization {

    static int MAX = 1000000;
    static int SQRT = 1000;
    static ArrayList&lt;Integer&gt; primes = new ArrayList&lt;&gt;();
    static boolean marked[] = new boolean[MAX + 1];
    static ArrayList&lt;Integer&gt; factors = new ArrayList&lt;&gt;();

    public static void primeFactors(int n) {
        factors.clear();
        for (int i = 0, p = primes.get(i); p * p &lt;= n; p = primes.get(++i)) {
            while (n % p == 0) {
                factors.add(p);
                n /= p;
            }
        }
        if (n &gt; 1) {
            factors.add(n);
        }
    }

    static void sieve() {
        marked[1] = true;
        int i = 2;
        for (; i &lt;= SQRT; ++i) {
            if (!marked[i]) {
                primes.add(i);
                for (int j = i * i; j &lt;= MAX; j += i) {
                    marked[j] = true;
                }
            }
        }
        for (; i &lt;= MAX; ++i) {
            if (!marked[i]) {
                primes.add(i);
            }
        }
    }

    public static void main(String[] args) {
        sieve();
        primeFactors(100);
        for (Integer i : factors) {
            System.out.print(i + &quot; &quot;);
        }
        System.out.println(&quot;&quot;);
    }
}
</java>
  <cpp>#include &lt;bits/stdc++.h&gt; 
using namespace std;
int const MAX = 1000000;
int SQRT = 1000;
vector&lt;int&gt; primes;
bool marked[MAX + 1];
vector&lt;int&gt; factors;

void primeFactors(int n) {
    factors.clear();
    for (int i = 0, p = primes[i]; p * p &lt;= n; p = primes[++i]) {
        while (n % p == 0) {
            factors.emplace_back(p);
            n /= p;
        }
    }
    if (n &gt; 1) {
        factors.emplace_back(n);
    }
}

void sieve() {
    marked[1] = true;
    int i = 2;
    for (; i &lt;= SQRT; ++i) {
        if (!marked[i]) {
            primes.emplace_back(i);
            for (int j = i * i; j &lt;= MAX; j += i) {
                marked[j] = true;
            }
        }
    }
    for (; i &lt;= MAX; ++i) {
        if (!marked[i]) {
            primes.emplace_back(i);
        }
    }
}

int main() {
    sieve();
    primeFactors(100);
    for (int i : factors) {
        cout &lt;&lt; i &lt;&lt; &quot; &quot;;
    }
    cout &lt;&lt; endl;
}
</cpp>
  <py>import math
 

def primeFactors(n): 
        
    while n % 2 == 0: 
        print 2, 
        n = n / 2
    for i in range(3, int(math.sqrt(n)) + 1, 2): 
        while n % i == 0: 
            print i, 
            n = n / i 
                        
    if n &gt; 2: 
        print n 
                


n = 100
primeFactors(n) 
</py>
  <orden>6</orden>
  <suborden>79</suborden>
  <fecha_creacion>2020-12-05 01:56:15</fecha_creacion>
  <fecha_modificacion>2022-03-08 12:01:47</fecha_modificacion>
</row>
<row>
  <ID>187</ID>
  <supergrupo>Matemática</supergrupo>
  <tema>Raiz primitiva</tema>
  <texto>Dado un número primo n, la tarea consiste en encontrar su raíz primitiva en módulo n. La raíz primitiva de un número primo n es un entero r entre [1, n-1] tal que los valores de r ^ x (mod n) donde x está en el rango [0, n-2] son diferentes. Devuelve -1 si n es un número no primo.
Ejemplos:
Entrada: 7
Resultado: raíz primitiva más pequeña = 3
Explicación: n = 7
3 ^ 0 (mod 7) = 1
3 ^ 1 (mod 7) = 3
3 ^ 2 (mod 7) = 2
3 ^ 3 (mod 7) = 6
3 ^ 4 (mod 7) = 4
3 ^ 5 (mod 7) = 5

Entrada: 761
Resultado: raíz primitiva más pequeña = 6
Una solución simple es probar todos los números del 2 al n-1. Para cada número r, calcule los valores de r ^ x (mod n) donde x está en el rango [0, n-2]. Si todos estos valores son diferentes, devuelva r, de lo contrario continúe con el siguiente valor de r. Si se prueban todos los valores de r, devuelve -1.

Una solución eficiente se basa en el siguiente hecho.
Si el orden multiplicativo de un número r módulo n es igual a la Función Totient de Euler Φ (n) (Note que la Función Totient de Euler para un primo n es n-1), entonces es una raíz primitiva.

1- Función Totient de Euler phi = n-1 [Suponiendo que n es primo]
1- Encuentra todos los factores primos de phi.
2- Calcule todas las potencias para seguir calculando
   usando (phi / factores primos) uno por uno.
3- Compruebe todos los numerados para todas las potencias de i = 2
   a n-1 es decir (i ^ potencias) módulo n.
4- Si es 1, entonces &#39;i&#39; no es una raíz primitiva de n.
5- Si nunca es 1, devuelve i ;.

Aunque puede haber múltiples raíces primitivas para un número primo, solo nos preocupa el más pequeño. Si desea encontrar todas las raíces, continúe el proceso hasta p-1 en lugar de dividir al encontrar la primera raíz primitiva.
</texto>
  <complejidad_tiempo>null</complejidad_tiempo>
  <java>// Programa Java para encontrar la raíz primitiva de un número n dado

import java.util.*;

public class PrimitiveRoot {

    // Devuelve verdadero si n es primo
    static boolean isPrime(int n) {
        // casos esquina
        if (n &lt;= 1) {
            return false;
        }
        if (n &lt;= 3) {
            return true;
        }
        // Esto está marcado para que podamos omitir los cinco 
        // números del medio en el ciclo inferior
        if (n % 2 == 0 || n % 3 == 0) {
            return false;
        }

        for (int i = 5; i * i &lt;= n; i = i + 6) {
            if (n % i == 0 || n % (i + 2) == 0) {
                return false;
            }
        }

        return true;
    }

    /* Función iterativa para calcular (x ^ n)% p en O (logy) */
    static int power(int x, int y, int p) {
        int res = 1;     // Inicializar resultado

        x = x % p; // Actualiza x si es mayor o igual que p

        while (y &gt; 0) {
            // Si y es impar, multiplica x con el resultado
            if (y % 2 == 1) {
                res = (res * x) % p;
            }

            // y debe ser par ahora
            y = y &gt;&gt; 1; // y = y/2 
            x = (x * x) % p;
        }
        return res;
    }

    // Función de utilidad para almacenar factores primos de un número
    static void findPrimefactors(HashSet&lt;Integer&gt; s, int n) {
        // Imprime el número de 2 que dividen n 
        while (n % 2 == 0) {
            s.add(2);
            n = n / 2;
        }

        // n debe ser extraño en este punto. Entonces podemos 
        // omitir un elemento (Note i = i +2)
        for (int i = 3; i &lt;= Math.sqrt(n); i = i + 2) {
            // Mientras yo divide n, imprime i y divide n
            while (n % i == 0) {
                s.add(i);
                n = n / i;
            }
        }
        // Esta condición es para manejar el caso 
        // cuando n es un número primo mayor que 2
        if (n &gt; 2) {
            s.add(n);
        }
    }

    // Función para encontrar la raíz primitiva más pequeña de n
    static int findPrimitive(int n) {
        HashSet&lt;Integer&gt; s = new HashSet&lt;&gt;();

        // Compruebe si n es primo o no
        if (isPrime(n) == false) {
            return -1;
        }

        // Encuentre el valor de la función Euler Totient de n 
        // Dado que n es un número primo, el valor de la función Euler 
        // Totient es n-1 ya que hay n-1 números primos relativos.
        int phi = n - 1;
        // Encuentra factores primos de phi y guárdalos en un conjunto 
        findPrimefactors(s, phi);
        // Compruebe todos los números del 2 al phi
        for (int r = 2; r &lt;= phi; r++) {
            // Repita todos los factores primos de phi. 
            // y verificamos si encontramos una potencia con valor 1
            boolean flag = false;
            for (Integer a : s) {
                // Compruebe si r ^ ((phi) / primefactors) mod n es 1 o no
                if (power(r, phi / (a), n) == 1) {
                    flag = true;
                    break;
                }
            }

            // Si no hubiera potencia con valor 1.
            if (flag == false) {
                return r;
            }
        }

        // Si no se encuentra raíz primitiva
        return -1;
    }

    public static void main(String[] args) {
        int n = 761;
        System.out.println(&quot; Smallest primitive root of &quot; + n
                + &quot; is &quot; + findPrimitive(n));
    }
}
</java>
  <cpp>#include&lt;bits/stdc++.h&gt; 
using namespace std;

bool isPrime(int n) {

    if (n &lt;= 1) return false;
    if (n &lt;= 3) return true;
    if (n % 2 == 0 || n % 3 == 0) return false;
    for (int i = 5; i * i &lt;= n; i = i + 6)
        if (n % i == 0 || n % (i + 2) == 0)
            return false;
    return true;
}

int power(int x, unsigned int y, int p) {
    int res = 1;
    x = x % p;
    while (y &gt; 0) {
        if (y &amp; 1)
            res = (res * x) % p;
        y = y &gt;&gt; 1;
        x = (x * x) % p;
    }
    return res;
}

void findPrimefactors(unordered_set&lt;int&gt; &amp;s, int n) {

    while (n % 2 == 0) {
        s.insert(2);
        n = n / 2;
    }

    for (int i = 3; i &lt;= sqrt(n); i = i + 2) {
        while (n % i == 0) {
            s.insert(i);
            n = n / i;
        }
    }
    if (n &gt; 2)
        s.insert(n);
}

int findPrimitive(int n) {
    unordered_set&lt;int&gt; s;
    if (isPrime(n) == false)
        return -1;
    int phi = n - 1;
    findPrimefactors(s, phi);
    for (int r = 2; r &lt;= phi; r++) {
        bool flag = false;
        for (auto it = s.begin(); it != s.end(); it++) {
            if (power(r, phi / (*it), n) == 1) {
                flag = true;
                break;
            }
        }
        if (flag == false)
            return r;
    }
    return -1;
}

int main() {
    int n = 761;
    cout &lt;&lt; &quot; Smallest primitive root of &quot; &lt;&lt; n
            &lt;&lt; &quot; is &quot; &lt;&lt; findPrimitive(n);
    return 0;
}
</cpp>
  <py>from math import sqrt
 
def isPrime(n): 
    if (n &lt;= 1): 
        return False
    if (n &lt;= 3): 
        return True
    if (n % 2 == 0 or n % 3 == 0): 
        return False
    i = 5
    while(i * i &lt;= n): 
        if (n % i == 0 or n % (i + 2) == 0): 
            return False
        i = i + 6
    return True

def power(x, y, p): 
    res = 1 
    x = x % p 
    while (y &gt; 0): 
        if (y &amp; 1): 
            res = (res * x) % p 
        y = y &gt;&gt; 1 
        x = (x * x) % p 
    return res 

def findPrimefactors(s, n): 
    while (n % 2 == 0): 
        s.add(2) 
        n = n // 2
    for i in range(3, int(sqrt(n)), 2): 
        while (n % i == 0): 
            s.add(i) 
            n = n // i 
    if (n &gt; 2): 
        s.add(n) 

def findPrimitive(n): 
    s = set() 
    if (isPrime(n) == False): 
        return -1 
    phi = n - 1
    findPrimefactors(s, phi) 
    for r in range(2, phi + 1): 

        flag = False
        for it in s: 

            if (power(r, phi // it, n) == 1): 

                flag = True
                break
                         
        if (flag == False): 
            return r 

    return -1

n = 761
print(&quot;Smallest primitive root of&quot;, 
      n, &quot;is&quot;, findPrimitive(n)) 
</py>
  <orden>6</orden>
  <suborden>80</suborden>
  <fecha_creacion>2020-12-05 01:56:15</fecha_creacion>
  <fecha_modificacion>2022-03-08 12:03:39</fecha_modificacion>
</row>
<row>
  <ID>188</ID>
  <supergrupo>Matemática</supergrupo>
  <tema>Series geométricas bajo condiciones </tema>
  <texto>Una progresión geométrica es una secuencia de enteros b1, b2, b3,…, donde para cada i&gt; 1, el término respectivo satisface la condición bi = bi-1 * q, donde q se llama la razón común de la progresión.
Dada la progresión geométrica b definida por dos enteros b1 y q, y m enteros &quot;malos&quot; a1, a2, .., am, y un entero l, escribe todos los términos de progresión uno por uno (incluido el repetitivo) while condición | bi | &lt;= l está satisfecho (| x | significa valor absoluto de x).


Calcule cuántos números habrá en nuestra secuencia, o imprima &quot;inf&quot; en el caso de infinitos números enteros.
Nota: Si un término es igual a uno de los números enteros “malos”, omítalo y avanza al siguiente término.
Ejemplos:
Entrada: b1 = 3, q = 2, l = 30,
        m = 4
        6 14 25 48
Salida: 3
La progresión será 3 12 24.
6 también estará allí, pero porque
es un número entero malo, no lo incluiremos

Entrada: b1 = 123, q = 1, l = 2143435
        m = 4
        123 11 -5453 141245
Salida: 0
Como el valor de q es 1, la progresión
siempre será 123 y se volvería infinito
pero como es un número entero malo,
no lo incluirá y por lo tanto nuestro valor
se convertirá en 0

Entrada: b1 = 123, q = 1, l = 2143435
        m = 4
        5234 11-5453 141245
Salida: inf
En este caso, el valor será infinito
porque la serie siempre será 123 como
q es 1 y 123 no es un número entero incorrecto.

Aproximación:
Podemos dividir nuestra solución en diferentes casos:
Caso 1: si el valor inicial de la serie es mayor que el límite dado, la salida es 0.
Caso 2: Si el valor inicial de la serie oq es 0, hay tres casos más:
Caso 2.a: Si no se da 0 como un número entero incorrecto, la respuesta se convertirá en inf.
Caso 2.b: Si b1! = 0 pero q es 0 y b1 tampoco es un número entero incorrecto, la respuesta será 1.
Caso 2.c: Si 0 se da como un número entero incorrecto y b1 = 0, la respuesta será 0.
Caso 3: Si q = 1 comprobaremos si b1 se da como un entero incorrecto o no. Si es así, la respuesta será 0; de lo contrario, la respuesta será inf.
Caso 4: Si q = -1, verifique si b1 y -b1 están presentes o no, si están presentes nuestra respuesta será 0, de lo contrario nuestra respuesta será inf.
Caso 5: Si ninguno de los casos anteriores se cumple, simplemente ejecute un ciclo para b1 hasta l y calcule el número de elementos.
</texto>
  <complejidad_tiempo>null</complejidad_tiempo>
  <java>// Programa Java para encontrar el número de términos en series geométricas

import java.util.*;

public class TermsGeometricSerieswithConditions {

    // Un mapa para realizar un seguimiento de los números enteros incorrectos
    static HashMap&lt;Integer, Boolean&gt; map = new HashMap&lt;&gt;();

    // Función para calcular el No. de elementos de nuestra serie
    static void progression(int b1, int q, int l,
            int m, int[] bad) {

        // Actualización del valor de nuestro mapa
        for (int i = 0; i &lt; m; i++) {
            map.put(bad[i], true);
        }
        // si el valor inicial es mayor que nuestro límite dado 
        if (Math.abs(b1) &gt; l) {
            System.out.print(&quot;0&quot;);
        } // si q o el valor inicial es 0
        else if (q == 0 || b1 == 0) {
            // si 0 no es un número entero incorrecto, 
            // la respuesta se convierte en inf
            if (!map.containsKey(0)) {
                System.out.print(&quot;inf&quot;);
            } // si q es 0 y b1 no lo es y b1
            // no es un número entero malo, la respuesta se convierte en 1
            else if (map.get(0) == true &amp;&amp; !map.containsKey(b1)) {
                System.out.print(&quot;1&quot;);
            } // de lo contrario, si 0 es un número entero incorrecto y b1 
            // también es un número incorrecto, la respuesta se convierte en 0
            else {
                System.out.print(&quot;0&quot;);
            }
        } // si q es 1
        else if (q == 1) {
            // y b1 no es un número entero incorrecto, 
            // la respuesta se convierte en inf
            if (!map.containsKey(b1)) {
                System.out.print(&quot;inf&quot;);
            } // si no, la respuesta es 0
            else {
                System.out.print(&quot;0&quot;);
            }

        } // si q es -1
        else if (q == -1) {
            // y b1 o -b1 no está presente la respuesta se convierte en inf
            if (!map.containsKey(b1) || !map.containsKey(-1 * b1)) {
                System.out.print(&quot;inf&quot;);
            } // si no, la respuesta se convierte en 0
            else {
                System.out.print(&quot;0&quot;);
            }

        } // si ninguno de los casos anteriores es cierto, 
        // simplemente calcule el número de elementos en nuestra serie
        else {
            int co = 0;
            while (Math.abs(b1) &lt;= l) {
                if (!map.containsKey(b1)) {
                    co++;
                }
                b1 *= q;
            }
            System.out.print(co);
        }
    }

    public static void main(String[] args) {
        // valor inicial de la serie, número a multiplicar, límite dentro del
        // cual nuestra serie, número de enteros incorrectos dado
        int b1 = 3, q = 2, l = 30, m = 4;

        // Enteros malos
        int[] bad = {6, 14, 25, 48};

        progression(b1, q, l, m, bad);
    }
}
</java>
  <cpp>#include &lt;bits/stdc++.h&gt; 
using namespace std;

map&lt;int, bool&gt; mapp;

void progression(int b1, int q, int l, int m, int bad[]) {

    for (int i = 0; i &lt; m; i++)
        mapp[bad[i]] = 1;
    if (abs(b1) &gt; l)
        cout &lt;&lt; &quot;0&quot;;

    else if (q == 0 || b1 == 0) {
        if (mapp[0] != 1)
            cout &lt;&lt; &quot;inf&quot;;
        else if (mapp[0] == 1 &amp;&amp; mapp[b1] != 1)
            cout &lt;&lt; &quot;1&quot;;

        else
            cout &lt;&lt; &quot;0&quot;;
    } else if (q == 1) {

        if (mapp[b1] != 1)
            cout &lt;&lt; &quot;inf&quot;;
        else
            cout &lt;&lt; &quot;0&quot;;
    } else if (q == -1) {

        if (mapp[b1] != 1 || mapp[-1 * b1] != 1)
            cout &lt;&lt; &quot;inf&quot;;
        else
            cout &lt;&lt; &quot;0&quot;;
    } else {
        int co = 0;
        while (abs(b1) &lt;= l) {
            if (mapp[b1] != 1)
                co++;
            b1 *= 1LL * q;
        }
        cout &lt;&lt; co;
    }
}

int main() {
    int b1 = 3, q = 2, l = 30, m = 4;
    int bad[4] = {6, 14, 25, 48};
    progression(b1, q, l, m, bad);
    return 0;
} 
</cpp>
  <py>mpp = dict() 
  
def progression(b1, q, l, m, bad): 
    for i in range(m): 
        mpp[bad[i]] = 1
    if (abs(b1) &gt; l): 
        print(&quot;0&quot;, end=&quot;&quot;) 
    elif (q == 0 or b1 == 0): 
        if (0 not in mpp.keys()): 
            print(&quot;inf&quot;, end=&quot;&quot;) 
        elif (mpp[0] == 1 and b1 not in mpp.keys()): 
            print(&quot;1&quot;, end=&quot;&quot;) 
        else: 
            print(&quot;0&quot;, end=&quot;&quot;) 
    elif (q == 1): 
        if (b1 not in mpp.keys()): 
            print(&quot;inf&quot;, end=&quot;&quot;) 
        else: # else answer is 0 
            print(&quot;0&quot;, end=&quot;&quot;) 
  
    elif (q == -1): 
        if (b1 not in mpp.keys() or -1 * b1 not in mpp.keys()): 
            print(&quot;inf&quot;, end=&quot;&quot;) 
        else:
            print(&quot;0&quot;, end=&quot;&quot;) 
    else:
        co = 0
        while (abs(b1) &lt;= l): 
            if (b1 not in mpp.keys()): 
                co += 1
            b1 *= q 
        print(co, end=&quot;&quot;) 
  
  

b1 = 3
q = 2
l = 30
m = 4
  
bad = [6, 14, 25, 48] 
progression(b1, q, l, m, bad) 
</py>
  <orden>6</orden>
  <suborden>81</suborden>
  <fecha_creacion>2020-12-05 01:56:16</fecha_creacion>
  <fecha_modificacion>2022-03-08 12:03:39</fecha_modificacion>
</row>
<row>
  <ID>189</ID>
  <supergrupo>Matemática</supergrupo>
  <tema>Verificando si existe una progresión geométrica</tema>
  <texto>Una secuencia de números se llama progresión geométrica si la razón de dos términos consecutivos es siempre la misma. En términos simples, significa que el siguiente número de la serie se calcula multiplicando un número fijo por el número anterior de la serie. Por ejemplo, 2, 4, 8, 16 es un GP porque la proporción de dos términos consecutivos cualesquiera de la serie (diferencia común) es el mismo (4/2 = 8/4 = 16/8 = 2).
 
Hechos sobre la progresión geométrica:
1. Término inicial: en una progresión geométrica, el primer número se llama término inicial.
2. Razón común: la razón entre un término en la secuencia y el término anterior se denomina &quot;razón común&quot;.
3. El comportamiento de una secuencia geométrica depende del valor de la razón común. Si la razón común es:
• Positiva, todos los términos tendrán el mismo signo que el término inicial.
• Negativa, los términos se alternarán entre positivo y negativo.
• Mayor que 1, habrá un crecimiento exponencial hacia el infinito positivo o negativo (según el signo del término inicial).
• 1, la progresión es una secuencia constante.
• Entre -1 y 1 pero no cero, habrá una caída exponencial hacia cero.
• -1, la progresión es una secuencia alterna.
• Menos de -1, para los valores absolutos hay un crecimiento exponencial hacia el infinito (sin signo), debido al signo alterno.
Fórmula del enésimo término de una progresión geométrica:
Si &quot;a&quot; es el primer término y &quot;r&quot; es la razón común, la fórmula explícita es


¿Cómo comprobamos si una serie es progresión geométrica o no?
Encontremos la razón de los términos consecutivos, por lo que podemos decir que la razón de los términos consecutivos de las secuencias dadas es 13 o una constante. Entonces esta secuencia está formando una progresión geométrica.
</texto>
  <complejidad_tiempo>null</complejidad_tiempo>
  <java>// Programa Java para verificar si una matriz 
// determinada puede formar una progresión geométrica

public class IsGeometricProgression {

    // función para comprobar que la serie es progresión geométrica o no
    static boolean is_geometric(int arr[], int n) {
        if (n == 1) {
            return true;
        }

        // Calcular la proporción
        int ratio = arr[1] / (arr[0]);

        //Compruebe la proporción de los restantes
        for (int i = 1; i &lt; n; i++) {
            if ((arr[i] / (arr[i - 1])) != ratio) {
                return false;
            }
        }
        return true;
    }

    public static void main(String[] args) {
        int arr[] = {2, 6, 18, 54};
        int n = arr.length;

        if (is_geometric(arr, n)) {
            System.out.println(&quot;True&quot;);
        } else {
            System.out.println(&quot;False&quot;);
        }
    }
}
</java>
  <cpp>#include &lt;bits/stdc++.h&gt; 
using namespace std;

bool is_geometric(int arr[], int n) {
    if (n == 1)
        return true;

    int ratio = arr[1] / (arr[0]);

    for (int i = 1; i &lt; n; i++) {
        if ((arr[i] / (arr[i - 1])) != ratio) {
            return false;
        }
    }
    return true;
}

int main() {
    int arr[] = {2, 6, 18, 54};
    int n = sizeof (arr) / sizeof (arr[0]);

    (is_geometric(arr, n)) ? (cout &lt;&lt; &quot;True&quot; &lt;&lt; endl) : (cout &lt;&lt; &quot;False&quot; &lt;&lt; endl);

    return 0;
} 
</cpp>
  <py>def is_geometric(li): 
    if len(li) &lt;= 1: 
        return True
    ratio = li[1]/float(li[0]) 
     
    for i in range(1, len(li)): 
        if li[i]/float(li[i-1]) != ratio:  
            return False
    return True
  
print(is_geometric([2, 6, 18, 54])) 
</py>
  <orden>6</orden>
  <suborden>82</suborden>
  <fecha_creacion>2020-12-05 01:56:16</fecha_creacion>
  <fecha_modificacion>2022-03-08 12:03:39</fecha_modificacion>
</row>
<row>
  <ID>190</ID>
  <supergrupo>Matemática</supergrupo>
  <tema>Subsecuencias únicas de tamaño k</tema>
  <texto>Dada un array de N números y un entero K. La tarea es imprimir el número de subsecuencias únicas posibles de longitud K.
Ejemplos:
Entrada: a [] = {1, 2, 3, 4}, k = 3
Salida: 4.
Las subsecuencias únicas son:
{1, 2, 3}, {1, 2, 4}, {1, 3, 4}, {2, 3, 4}

Entrada: a [] = {1, 1, 1, 2, 2, 2}, k = 3
Salida: 4
Las subsecuencias únicas son
{1, 1, 1}, {1, 1, 2}, {1, 2, 2}, {2, 2, 2}

Enfoque: Existe una fórmula bien conocida de cuántas subsecuencias de longitud fija K se pueden elegir entre N objetos únicos. Pero el problema aquí tiene varias diferencias. Uno de ellos es que el orden en las subsecuencias es importante y debe conservarse como en la secuencia original. Para tal problema, no puede haber una fórmula combinatoria lista porque los resultados dependen del orden de la matriz original.
La idea principal es tratar de forma recurrente la longitud de la subsecuencia. En cada paso recurrente, muévase del final al principio y cuente las combinaciones únicas usando el recuento de combinaciones únicas más cortas del paso anterior. Más estrictamente en cada paso j, mantenemos un array de longitud N y cada elemento en el lugar p significa cuántas subsecuencias únicas con longitud j encontramos a la derecha del elemento en el lugar i, incluido el propio i.
</texto>
  <complejidad_tiempo>null</complejidad_tiempo>
  <java>import java.util.*;

public class UniqueSubsequencesklength {

// Function which returns the numbe of
// unique subsequences of length K
    static int solution(int[] A, int N, int k) {

        // Bases cases
        if (N &lt; k || N &lt; 1 || k &lt; 1) {
            return 0;
        }
        if (N == k) {
            return 1;
        }

        // Prepare arrays for recursion
        int[] v1 = new int[N];
        int[] v2 = new int[N];
        int[] v3 = new int[N];

        // Initiate separately for k = 1
        // intiate the last element
        v2[N - 1] = 1;
        v3[A[N - 1] - 1] = 1;

        // Initiate all other elements of k = 1
        for (int i = N - 2; i &gt;= 0; i--) {

            // Initialize the front element
            // to vector v2
            v2[i] = v2[i + 1];

            // If element v[a[i]-1] is 0
            // then increment it in vector v2
            if (v3[A[i] - 1] == 0) {
                v2[i]++;
                v3[A[i] - 1] = 1;
            }
        }

        // Iterate for all possible values of K
        for (int j = 1; j &lt; k; j++) {

            // Fill the vectors with 0
            Arrays.fill(v3, 0);

            // Fill(v1.begin(), v1.end(), 0)
            // the last must be 0 as from last
            // no unique subarray can be formed
            v1[N - 1] = 0;

            // Iterate for all index from which 
            // unique subsequences can be formed
            for (int i = N - 2; i &gt;= 0; i--) {

                // Add the number of subsequence 
                // formed from the next index
                v1[i] = v1[i + 1];

                // Start with combinations on the
                // next index
                v1[i] = v1[i] + v2[i + 1];

                // Remove the elements which have
                // already been counted
                v1[i] = v1[i] - v3[A[i] - 1];

                // Update the number used
                v3[A[i] - 1] = v2[i + 1];
            }
        }

        // Last answer is stored in v2
        return v2[0];
    }

// Driver Code
    public static void main(String[] args) {
        int a[] = {1, 2, 3, 4};
        int n = a.length;
        int k = 3;

        System.out.print(solution(a, n, k));
    }
}
</java>
  <cpp>#include &lt;bits/stdc++.h&gt; 
using namespace std;

int solution(vector&lt;int&gt;&amp; A, int k) {
    const int N = A.size();
    if (N &lt; k || N &lt; 1 || k &lt; 1)
        return 0;
    if (N == k)
        return 1;

    vector&lt;int&gt; v1(N, 0);
    vector&lt;int&gt; v2(N, 0);
    vector&lt;int&gt; v3(N, 0);

    v2[N - 1] = 1;
    v3[A[N - 1] - 1] = 1;

    for (int i = N - 2; i &gt;= 0; i--) {

        v2[i] = v2[i + 1];
        if (v3[A[i] - 1] == 0) {
            v2[i]++;
            v3[A[i] - 1] = 1;
        }
    }

    for (int j = 1; j &lt; k; j++) {

        fill(v3.begin(), v3.end(), 0);
        v1[N - 1] = 0;

        for (int i = N - 2; i &gt;= 0; i--) {

            v1[i] = v1[i + 1];
            v1[i] = v1[i] + v2[i + 1];
            v1[i] = v1[i] - v3[A[i] - 1];
            v3[A[i] - 1] = v2[i + 1];
        }
        v2 = v1;
    }
    return v2[0];
}

void solve(int a[], int n, int k) {
    vector&lt;int&gt; v;
    v.assign(a, a + n);
    cout &lt;&lt; solution(v, k);
}

int main() {
    int a[] = {1, 2, 3, 4};
    int n = sizeof (a) / sizeof (a[0]);
    int k = 3;
    solve(a, n, k);

    return 0;
} 
</cpp>
  <py>def solution(A, k):

    N = len(A)
    if (N &lt; k or N &lt; 1 or k &lt; 1):
        return 0
    if (N == k):
        return 1
    v1 = [0] * (N)
    v2 = [0] * N
    v3 = [0] * N
    v2[N - 1] = 1
    v3[A[N - 1] - 1] = 1

    for i in range(N - 2, -1, -1):
        v2[i] = v2[i + 1]
        if (v3[A[i] - 1] == 0):
            v2[i] += 1
            v3[A[i] - 1] = 1
                
    for j in range(1, k):
        v3 = [0] * N
        v1[N - 1] = 0
        for i in range(N - 2, -1, -1):
            v1[i] = v1[i + 1]
            v1[i] = v1[i] + v2[i + 1]
            v1[i] = v1[i] - v3[A[i] - 1]
            v3[A[i] - 1] = v2[i + 1]
        
        for i in range(len(v1)):
            v2[i] = v1[i]
        
    return v2[0]

def solve(a, n, k):
    v = a
    print(solution(v, k))


a = [1, 2, 3, 4]
n = len(a)
k = 3
solve(a, n, k)
</py>
  <orden>6</orden>
  <suborden>83</suborden>
  <fecha_creacion>2020-12-05 01:56:16</fecha_creacion>
  <fecha_modificacion>2022-03-08 12:03:39</fecha_modificacion>
</row>
<row>
  <ID>191</ID>
  <supergrupo>Matemática</supergrupo>
  <tema>Bisección</tema>
  <texto>* f (b) &lt;0 yf (x) es continua en [a, b]. Aquí f (x) representa una ecuación algebraica o trascendental. Encuentre la raíz de la función en el intervalo [a, b] (O encuentre un valor de x tal que f (x) sea 0).
Ejemplo:
Entrada: una función de x, por ejemplo x3 - x2 + 2.
       Y dos valores: a = -200 yb = 300 tales que
       f (a) * f (b) &lt;0, es decir, f (a) yf (b) tienen
       signos opuestos.
Salida: El valor de la raíz es: -1,0025
        O cualquier otro valor con permitido
        desviación de la raíz.
¿Qué son las funciones algebraicas y trascendentales?
La función algebraica es aquella que se puede representar en forma de polinomios como f (x) = a1x3 + a2x2 +… .. + e donde aa1, a2,… son constantes yx es una variable.
Las funciones trascendentales son funciones no algebraicas, por ejemplo f (x) = sin (x) * x - 3 o f (x) = ex + x2 o f (x) = ln (x) + x….
¿Qué es el método de bisección?
El método también se denomina método de reducción a la mitad del intervalo, método de búsqueda binaria o método de dicotomía. Este método se usa para encontrar la raíz de una ecuación en un intervalo dado que es el valor de &quot;x&quot; para el cual f (x) = 0.
El método se basa en el Teorema del valor intermedio que establece que si f (x) es una función continua y hay dos números reales ayb tales que f (a) * f (b) 0 yf (b) &lt;0) , entonces se garantiza que tiene al menos una raíz entre ellos.
Supuestos:

1. f (x) es una función continua en el intervalo [a, b]
2. f (a) * f (b) &lt;0
Pasos:
1. Encuentre el punto medio c = (a + b) / 2.
2. Si f (c) == 0, entonces c es la raíz de la solución.
3. De lo contrario, f (c)! = 0
1. Si el valor f (a) * f (c) &lt;0, la raíz se encuentra entre ay c. Entonces recurrimos para ayc
2. De lo contrario Si f (b) * f (c) &lt;0, entonces la raíz se encuentra entre by c. Entonces recurrimos by c.
3. La otra función dada no sigue uno de los supuestos.
Dado que la raíz puede ser un número de punto flotante, repetimos los pasos anteriores mientras que la diferencia entre ayb es menor que un valor. (Un valor muy pequeño).
 
Complejidad temporal: - La complejidad temporal de este método depende de los valores asumidos y de la función.
¿Cuáles son los pros y los contras?
La ventaja del método de bisección es que se garantiza que convergerá. La desventaja del método de bisección es que no puede detectar múltiples raíces.
En general, el método de bisección se utiliza para obtener una aproximación inicial aproximada de la solución. Luego, se utilizan métodos convergentes más rápidos para encontrar la solución.
</texto>
  <complejidad_tiempo>null</complejidad_tiempo>
  <java>// Programa Java para la implementación del método de 
// bisección para resolver ecuaciones

public class Bisection {

    static final float EPSILON = (float) 0.01;

    // Una función de ejemplo cuya solución se determina mediante el método de
    // bisección. La función es x ^ 3 - x ^ 2 + 2
    static double func(double x) {
        return x * x * x - x * x + 2;
    }

    // Imprime la raíz de func (x) con error de EPSILON
    static void bisection(double a, double b) {
        if (func(a) * func(b) &gt;= 0) {
            System.out.println(&quot;You have not assumed&quot;
                    + &quot; right a and b&quot;);
            return;
        }
        double c = a;
        while ((b - a) &gt;= EPSILON) {
            // Encuentra el punto medio
            c = (a + b) / 2;

            // Compruebe si el punto medio es la raíz
            if (func(c) == 0.0) {
                break;
            } // Decide el lado para repetir los pasos
            else if (func(c) * func(a) &lt; 0) {
                b = c;
            } else {
                a = c;
            }
        }
        //imprime el valor de c hasta 4 lugares decimales
        System.out.printf(&quot;The value of root is : %.4f&quot;,
                c);
    }

    public static void main(String[] args) {
        // Valores iniciales asumidos
        double a = -200, b = 300;
        bisection(a, b);
    }
}
</java>
  <cpp>#include&lt;bits/stdc++.h&gt; 
using namespace std;
#define EPSILON 0.01 

double func(double x) {
    return x * x * x - x * x + 2;
}

void bisection(double a, double b) {
    if (func(a) * func(b) &gt;= 0) {
        cout &lt;&lt; &quot;You have not assumed right a and b\n&quot;;
        return;
    }

    double c = a;
    while ((b - a) &gt;= EPSILON) {
        c = (a + b) / 2;

        if (func(c) == 0.0)
            break;

        else if (func(c) * func(a) &lt; 0)
            b = c;
        else
            a = c;
    }
    cout &lt;&lt; &quot;The value of root is : &quot; &lt;&lt; c;
}

int main() {
    double a = -200, b = 300;
    bisection(a, b);
    return 0;
} 
</cpp>
  <py>def func(x): 
    return x * x * x - x * x + 2
   
def bisection(a, b): 
  
    if (func(a) * func(b) &gt;= 0): 
        print(&quot;You have not assumed right a and b\n&quot;) 
        return
   
    c = a 
    while ((b-a) &gt;= 0.01): 
        c = (a + b) / 2
        if (func(c) == 0.0): 
            break
  
        if (func(c) * func(a) &lt; 0): 
            b = c 
        else: 
            a = c 
              
    print(&quot;The value of root is : &quot;, &quot;%.4f&quot; % c) 
      

a = -200
b = 300
bisection(a, b) 
</py>
  <orden>6</orden>
  <suborden>84</suborden>
  <fecha_creacion>2020-12-05 01:56:17</fecha_creacion>
  <fecha_modificacion>2022-03-08 12:03:39</fecha_modificacion>
</row>
<row>
  <ID>192</ID>
  <supergrupo>Matemática</supergrupo>
  <tema>Interpolación de LaGrange</tema>
  <texto>¿Qué es la interpolación?
La interpolación es un método para encontrar nuevos puntos de datos dentro del rango de un conjunto discreto de puntos de datos conocidos. En otras palabras, la interpolación es la técnica para estimar el valor de una función matemática, para cualquier valor intermedio de la variable independiente.
Por ejemplo, en la tabla dada se nos dan 4 conjuntos de puntos de datos discretos, para una función desconocida f (x):
 
¿Como encontrarlo?
Aquí podemos aplicar la fórmula de interpolación de Lagrange para obtener nuestra solución.
La fórmula de interpolación de Lagrange:
Si, y = f (x) toma los valores y0, y1,…, yn correspondientes ax = x0, x1,…, xn entonces, 
Este método se prefiere sobre sus contrapartes como el método de Newton porque es aplicable incluso para valores de x desigualmente espaciados.
Podemos usar técnicas de interpolación para encontrar un punto de datos intermedio, digamos en x = 3.
Complejidad:
La complejidad temporal de la solución anterior es O (n2) y el espacio auxiliar es O (1).
</texto>
  <complejidad_tiempo>null</complejidad_tiempo>
  <java>// Programa Java para la implementación de la interpolación de Lagrange

public class LagrangeInterpolation {

    // Para representar un punto de datos correspondiente ax e y = f (x)
    static class Data {

        int x, y;

        public Data(int x, int y) {
            super();
            this.x = x;
            this.y = y;
        }

    };

    // función para interpolar los puntos de datos dados utilizando 
    // la fórmula de Lagrange xi corresponde al nuevo punto de datos cuyo
    // valor se va a obtener n representa el número de puntos de datos conocidos 
    static double interpolate(Data f[], int xi, int n) {
        double result = 0; // Initialize result 

        for (int i = 0; i &lt; n; i++) {
            //Calcule los términos individuales de la fórmula anterior
            double term = f[i].y;
            for (int j = 0; j &lt; n; j++) {
                if (j != i) {
                    term = term * (xi - f[j].x) / (f[i].x - f[j].x);
                }
            }

            // Agregar término actual al resultado
            result += term;
        }

        return result;
    }

    public static void main(String[] args) {
        // Agregar término actual al resultado
        Data f[] = {new Data(0, 2), new Data(1, 3),
            new Data(2, 12), new Data(5, 147)};

        // Usando la función de interpolación para 
        // obtener un punto de datos correspondiente ax = 3
        System.out.print(&quot;Value of f(3) is : &quot;
                + (int) interpolate(f, 3, 4));
    }
}
</java>
  <cpp>#include&lt;bits/stdc++.h&gt; 
using namespace std;

struct Data {
    int x, y;
};

double interpolate(Data f[], int xi, int n) {
    double result = 0;
    for (int i = 0; i &lt; n; i++) {
        double term = f[i].y;
        for (int j = 0; j &lt; n; j++) {
            if (j != i)
                term = term * (xi - f[j].x) / double(f[i].x - f[j].x);
        }
        result += term;
    }

    return result;
}

int main() {
    Data f[] = {
        {0, 2},
        {1, 3},
        {2, 12},
        {5, 147}
    };
    cout &lt;&lt; &quot;Value of f(3) is : &quot; &lt;&lt; interpolate(f, 3, 5);
    return 0;
} 
</cpp>
  <py>class Data: 
    def __init__(self, x, y): 
        self.x = x 
        self.y = y 
  

def interpolate(f, xi, n): 
    result = 0.0
    for i in range(n): 
        term = f[i].y 
        for j in range(n): 
            if j != i: 
                term = term * (xi - f[j].x) / (f[i].x - f[j].x) 
        result += term 
  
    return result 
f = [Data(0, 2), Data(1, 3), Data(2, 12), Data(5, 147)] 

print(&quot;Value of f(3) is :&quot;, interpolate(f, 3, 4))

</py>
  <orden>6</orden>
  <suborden>85</suborden>
  <fecha_creacion>2020-12-05 01:56:17</fecha_creacion>
  <fecha_modificacion>2022-03-08 12:05:45</fecha_modificacion>
</row>
<row>
  <ID>193</ID>
  <supergrupo>Matemática</supergrupo>
  <tema>Interpolación inversa de LaGrange</tema>
  <texto>La tarea dada es encontrar el valor de x para una y dada de una función desconocida y = f (x) donde se dan los valores de algunos pares de puntos (x, y).
El proceso de encontrar el valor de la variable independiente x para un valor dado de y que se encuentra entre dos valores tabulados con la ayuda del conjunto dado de observación para una función desconocida se conoce como interpolación inversa.
Esto se usa a menudo para verificar si la exactitud de la salida y para una función desconocida, es decir, cuánto argumento x para esta salida y difiere de la entrada original.
Este método se puede utilizar incluso cuando los puntos están espaciados de forma desigual. Aquí x se expresa en función de y.
Ejemplos:
Entrada: Encuentre el valor de x donde y = 4.5 y los puntos dados son 
Salida: 2.79501
Explicación: Aquí el número de puntos de datos dados = 4 e y = 4.5
Entonces, poniendo los valores de todo xey en la fórmula de interpolación inversa dada anteriormente obtenemos,

 
De aquí obtenemos,
El valor de x = 2.79501 donde el valor de y = 4.5
 
Algoritmo:
Aquí, los datos son una lista de puntos que consta de xey y n es el número de puntos de datos.
PASO - 1: Inicializar el valor final x = 0
PASO - 2: PARA i = 1 an do
     PASO - 3: Inicializar xi = datos [i] .x
     PASO - 4: PARA j = 1 an hacer
         PASO - 5: SI i! = J hago
             PASO - 6: Multiplica xi por (y - dato [j] .y) y divide por (dato [i] .y - dato [j] .y)
         TERMINARA SI
     ENDFOR
     PASO - 7: Suma xi a x
ENDFOR
PASO - 8: Devuelve el valor final de x
PASO - 9: FIN
</texto>
  <complejidad_tiempo>null</complejidad_tiempo>
  <java>// Código Java para resolver interpolación inversa

public class InvLagrangeInterpolation {

    // Considere una estructura para mantener juntos cada par de xey
    static class Data {

        double x, y;

        public Data(double x, double y) {
            super();
            this.x = x;
            this.y = y;
        }

    };

    // Función para calcular la interpolación inversa
    static double inv_interpolate(Data[] d, int n, double y) {
        // Inicializar x final
        double x = 0;
        int i, j;
        for (i = 0; i &lt; n; i++) {
            // Calcula cada término de la fórmula dada
            double xi = d[i].x;
            for (j = 0; j &lt; n; j++) {

                if (j != i) {
                    xi = xi * (y - d[j].y) / (d[i].y - d[j].y);
                }
            }

            //Agregar término al resultado final
            x += xi;
        }
        return x;
    }

    public static void main(String[] args) {

        // Conjunto de datos de muestra de 4 
        // puntos Aquí encontramos el valor de x cuando y = 4.5
        Data[] d = {new Data(1.27, 2.3),
            new Data(2.25, 2.95),
            new Data(2.5, 3.5),
            new Data(3.6, 5.1)};

        // Tamaño del conjunto de datos
        int n = 4;

        // Valor de muestra y
        double y = 4.5;

        // Usar la función de interpolación inversa 
        // para encontrar el valor de x cuando y = 4.5
        System.out.printf(&quot;Value of x at y = 4.5 : %.5f&quot;,
                inv_interpolate(d, n, y));
    }
}
</java>
  <cpp>#include &lt;bits/stdc++.h&gt; 
using namespace std;

struct Data {
    double x, y;
};

double inv_interpolate(Data d[], int n, double y) {
    double x = 0;
    int i, j;
    for (i = 0; i &lt; n; i++) {
        double xi = d[i].x;
        for (j = 0; j &lt; n; j++) {
            if (j != i) {
                xi = xi * (y - d[j].y) / (d[i].y - d[j].y);
            }
        }
        x += xi;
    }

    return x;
}

int main() {
    Data d[] = {
        { 1.27, 2.3},
        { 2.25, 2.95},
        { 2.5, 3.5},
        { 3.6, 5.1}
    };

    int n = 4;
    double y = 4.5;
    cout &lt;&lt; &quot;Value of x at y = 4.5 : &quot;
            &lt;&lt; inv_interpolate(d, n, y);
    return 0;
} 
</cpp>
  <py>class Data: 
    def __init__(self, x, y): 
        self.x = x 
        self.y = y 
  

def inv_interpolate(d, n,  y) : 
    x = 0
    for i in range(n): 
        xi = d[i].x 
        for j in range(n): 
            if j != i: 
                xi = (xi * (y - d[j].y) / 
                      (d[i].y - d[j].y)) 
        x += xi 
    return x 
d = [Data(1.27, 2.3),  
     Data(2.25, 2.95),  
     Data(2.5, 3.5),  
     Data(3.6, 5.1)] 

n = 4
y = 4.5
print(&quot;Value of x at y = 4.5 :&quot;,  
       round(inv_interpolate(d, n, y), 5)) 
</py>
  <orden>6</orden>
  <suborden>86</suborden>
  <fecha_creacion>2020-12-05 01:56:17</fecha_creacion>
  <fecha_modificacion>2022-03-08 12:05:45</fecha_modificacion>
</row>
<row>
  <ID>194</ID>
  <supergrupo>Matemática</supergrupo>
  <tema>Raiz mediante Newton</tema>
  <texto>Dado un número entero N y un nivel de tolerancia L, la tarea es encontrar la raíz cuadrada de ese número usando el método de Newton.
Ejemplos:
Entrada: N = 16, L = 0.0001
Salida: 4
42 = 16
Entrada: N = 327, L = 0.00001
Salida: 18.0831

Método de Newton:
Sea N cualquier número, entonces la raíz cuadrada de N puede estar dada por la fórmula:

root = 0.5 * (X + (N / X)) donde X es cualquier conjetura que se puede suponer que es N o 1.
• En la fórmula anterior, X es cualquier raíz cuadrada asumida de N y raíz es la raíz cuadrada correcta de N.
• El límite de tolerancia es la diferencia máxima entre X y la raíz permitida.
Enfoque: se pueden seguir los siguientes pasos para calcular la respuesta:
1. Asigne X a la propia N.
2. Ahora, inicie un ciclo y siga calculando la raíz que seguramente se moverá hacia la raíz cuadrada correcta de N.
3. Verifique la diferencia entre la X supuesta y la raíz calculada, si aún no está dentro de la tolerancia, actualice la raíz y continúe.
4. Si la raíz calculada entra dentro de la tolerancia permitida, salga del ciclo.
5. Imprima la raíz.
</texto>
  <complejidad_tiempo>null</complejidad_tiempo>
  <java>// Implementación Java de la raíz cuadrada de Newton

public class NewtonSquareRoot {

    // Función para devolver la raíz cuadrada de un número usando el método de Newton
    static double squareRoot(double n, double l) {
        // Suponiendo la sqrt de n como n solamente
        double x = n;

        // La conjetura cerrada se almacenará en la raíz.
        double root;

        // Para contar el número de iteraciones
        int count = 0;

        while (true) {
            count++;

            // Calcular más cerrado x
            root = 0.5 * (x + (n / x));

            // Compruebe la cercanía
            if (Math.abs(root - x) &lt; l) {
                break;
            }

            // Actualizar root
            x = root;
        }

        return root;
    }

    public static void main(String[] args) {
        double n = 327;
        double l = 0.00001;

        System.out.println(squareRoot(n, l));
    }
}
</java>
  <cpp>#include &lt;bits/stdc++.h&gt; 
using namespace std;

double squareRoot(double n, float l) {
    double x = n;
    double root;
    int count = 0;

    while (1) {
        count++;
        root = 0.5 * (x + (n / x));
        if (abs(root - x) &lt; l)
            break;
        x = root;
    }

    return root;
}

int main() {
    double n = 327;
    float l = 0.00001;
    cout &lt;&lt; squareRoot(n, l);
    return 0;
} 
</cpp>
  <py>def squareRoot(n, l):  
    x = n  
    count = 0 
    while (1): 
        count += 1 
        root = 0.5 * (x + (n / x))  
        if (abs(root - x) &lt; l): 
            break 
        x = root 
  
    return root  
  
n = 327
l = 0.00001 
print(squareRoot(n, l))  
</py>
  <orden>6</orden>
  <suborden>87</suborden>
  <fecha_creacion>2020-12-05 01:56:18</fecha_creacion>
  <fecha_modificacion>2022-03-08 12:05:45</fecha_modificacion>
</row>
<row>
  <ID>195</ID>
  <supergrupo>Matemática</supergrupo>
  <tema>Raiz mediante Newton Raphson </tema>
  <texto>Dada una función f (x) en un número flotante x y una estimación inicial de la raíz, encuentre la raíz de la función en el intervalo. Aquí f (x) representa una ecuación algebraica o trascendental.
Para simplificar, hemos asumido que la derivada de la función también se proporciona como entrada.
Ejemplo:
Entrada: una función de x (por ejemplo, x3 - x2 + 2),
       función derivada de x (3x2 - 2x para el ejemplo anterior)
       y una suposición inicial x0 = -20
Salida: El valor de la raíz es: -1,00
        O cualquier otro valor cercano a la raíz.

El método de bisección vs el método de posición falsa
Comparación con los dos métodos anteriores:

1. En los métodos anteriores, se nos dio un intervalo. Aquí se requiere un valor aproximado inicial de raíz.
2. Se garantiza que los dos métodos anteriores convergerán, Newton Rahhson puede no converger en algunos casos.
3. El método de Newton Raphson requiere derivada. Algunas funciones pueden resultar difíciles de
imposible de diferenciar.
4. Para muchos problemas, el método de Newton Raphson converge más rápido que los dos métodos anteriores.
5. Además, puede identificar raíces repetidas, ya que no busca cambios en el signo de f (x) explícitamente
La formula:
A partir de la estimación inicial x1, el método de Newton Raphson utiliza la siguiente fórmula para encontrar el siguiente valor de x, es decir, xn + 1 del valor anterior xn.
 
Algoritmo:
Entrada: x inicial, func (x), derivFunc (x)
Salida: Raíz de Func ()
1. Calcule los valores de func (x) y derivFunc (x) para una x inicial dada
2. Calcule h: h = func (x) / derivFunc (x)
3. Si bien h es mayor que el error permitido ε
1. h = func (x) / derivFunc (x)
2. x = x - h

¿Como funciona esto?
La idea es dibujar una recta tangente af (x) en el punto x1. El punto donde la línea tangente cruza el eje x debería ser una mejor estimación de la raíz que x1. Llame a este punto x2. Calcula f (x2) y dibuja una recta tangente en x2.
 
Sabemos que la pendiente de la recta de (x1, f (x1)) a (x2, 0) es f &#39;(x1)) donde f&#39; representa la derivada de f.
f &#39;(x1) = (0 - f (x1)) / (x2 - x1)

f &#39;(x1) * (x2 - x1) = - f (x1)

x2 = x1 - f (x1) / f &#39;(x1)

Al encontrar este punto &#39;x2&#39;, nos acercamos a la raíz.
Tenemos que seguir repitiendo el paso anterior hasta que nos acerquemos mucho a
la raíz o la encontramos.

En general,
xn + 1 = xn - f (xn) / f &#39;(xn)
Explicación alternativa usando la serie de Taylor:
Sea x1 la estimación inicial.

Podemos escribir x2 de la siguiente manera:
  xn + 1 = xn + h ------- (1)
Aquí h sería un valor pequeño que puede ser positivo o negativo.

Según la serie de Taylor,
ƒ (x) que es infinitamente diferenciable se puede escribir como se muestra a continuación
f (xn + 1) = f (xn + h)
       = f (xn) + h * f &#39;(xn) + ((h * h) / 2!) * (f&#39; &#39;(xn)) + ...

Como buscamos la raíz de la función, f (xn + 1) = 0

f (xn) + h * f &#39;(xn) + ((h * h) / 2!) * (f&#39; &#39;(xn)) + ... = 0

Ahora que h es pequeño, h * h sería muy pequeño.
Entonces, si ignoramos los términos de orden superior, obtenemos

f (xn) + h * f &#39;(xn) = 0

Sustituyendo este valor de h = xn + 1 - xn de la ecuación (1) obtenemos,
f (xn) + (xn + 1 - xn) * f &#39;(xn) = 0

xn + 1 = xn - f (xn) / f &#39;(xn)
Notas:
1. Generalmente usamos este método para mejorar el resultado obtenido por el método de bisección o el método de falsa posición.
2. El método babilónico para la raíz cuadrada se deriva del método de Newton-Raphson.
</texto>
  <complejidad_tiempo>null</complejidad_tiempo>
  <java>// Programa Java para la implementación del Método 
// Newton Raphson para resolver ecuaciones

public class NewtonRaphsonRoot {

    static final double EPSILON = 0.001;

    // Una función de ejemplo cuya solución se determina mediante el 
    // método de bisección. La función es x ^ 3 - x ^ 2 + 2
    static double func(double x) {
        return x * x * x - x * x + 2;
    }

    // Derivada de la función anterior que es 3 * x ^ x - 2 * x
    static double derivFunc(double x) {
        return 3 * x * x - 2 * x;
    }

    // Función para encontrar la raíz
    static void newtonRaphson(double x) {
        double h = func(x) / derivFunc(x);
        while (Math.abs(h) &gt;= EPSILON) {
            h = func(x) / derivFunc(x);
            // x (yo + 1) = x (yo) - f (x) / f &#39;(x)
            x = x - h;
        }

        System.out.print(&quot;The value of the&quot;
                + &quot; root is : &quot;
                + Math.round(x * 100.0) / 100.0);
    }

    public static void main(String[] args) {

        // Valores iniciales asumidos
        double x0 = -20;
        newtonRaphson(x0);
    }
}
</java>
  <cpp>#include&lt;bits/stdc++.h&gt; 
#define EPSILON 0.001 
using namespace std;

double func(double x) {
    return x * x * x - x * x + 2;
}

double derivFunc(double x) {
    return 3 * x * x - 2 * x;
}

void newtonRaphson(double x) {
    double h = func(x) / derivFunc(x);
    while (abs(h) &gt;= EPSILON) {
        h = func(x) / derivFunc(x);

        x = x - h;
    }

    cout &lt;&lt; &quot;The value of the root is : &quot; &lt;&lt; x;
}

int main() {
    double x0 = -20;
    newtonRaphson(x0);
    return 0;
} 
</cpp>
  <py>def func(x): 
    return x * x * x - x * x + 2
  
def derivFunc(x): 
    return 3 * x * x - 2 * x 
  
def newtonRaphson(x): 
    h = func(x) / derivFunc(x) 
    while abs(h) &gt;= 0.0001: 
        h = func(x) / derivFunc(x) 
        x = x - h 
      
    print(&quot;The value of the root is : &quot;, 
          &quot;%.4f&quot; % x) 
  
x0 = -20 
newtonRaphson(x0) 
</py>
  <orden>6</orden>
  <suborden>88</suborden>
  <fecha_creacion>2020-12-05 01:56:18</fecha_creacion>
  <fecha_modificacion>2022-03-08 12:05:45</fecha_modificacion>
</row>
<row>
  <ID>196</ID>
  <supergrupo>Matemática</supergrupo>
  <tema>Teorema de Lucas</tema>
  <texto>Usando el teorema de Lucas para nCr% p:
El teorema de Lucas básicamente sugiere que el valor de nCr se puede calcular multiplicando los resultados de niCri donde ni y ri son dígitos individuales en la misma posición en representaciones en base p de nyr respectivamente.
La idea es calcular niCri uno por uno para los dígitos individuales ni y ri en base p. Dado que estos dígitos están en base p, nunca necesitaríamos más de O (p) espacio y la complejidad temporal de estos cálculos individuales estaría limitada por O (p2).

Complejidad temporal: La complejidad temporal de esta solución es O (p2 * Logp n). Hay dígitos O (Logp n) en la representación base p de n. Cada uno de estos dígitos es menor que p, por lo tanto, los cálculos para dígitos individuales toman O (p2). Tenga en cuenta que estos cálculos se realizan mediante el método DP que lleva O (n * r) tiempo.
Implementación alternativa con tiempo O (p2 + Logp n) y espacio O (p2):
La idea es precalcular el triángulo de Pascal para el tamaño p x py almacenarlo en una matriz 2D. Todos los valores necesarios ahora tomarían O (1) tiempo. Por tanto, la complejidad del tiempo total se convierte en O (p2 + Logp n).
</texto>
  <complejidad_tiempo>null</complejidad_tiempo>
  <java>// Una solución basada en el teorema de Lucas para calcular nCr% p

public class LucasTheorem {

    // Devuelve nCr% p. En este programa basado en el Teorema de Lucas, 
    // esta función solo se llama para n &lt;p y r &lt;p. 
    static int nCrModpDP(int n, int r, int p) {
        // La matriz C va a almacenar la última fila del triángulo pascal al 
        // final. Y la última entrada de la última fila es nCr
        int[] C = new int[r + 1];
        C[0] = 1; // Fila superior del triángulo de Pascal
        // Uno por construye las filas restantes del Triángulo Pascal de arriba a abajo
        for (int i = 1; i &lt;= n; i++) {
            // Llene las entradas de la fila actual utilizando 
            // los valores de la fila anterior
            for (int j = Math.min(i, r); j &gt; 0; j--) // nCj = (n-1)Cj + (n-1)C(j-1); 
            {
                C[j] = (C[j] + C[j - 1]) % p;
            }
        }
        return C[r];
    }

    // Función basada en el Teorema de Lucas que devuelve nCr% p Esta 
    // función funciona como una función recursiva de conversión 
    // decimal a binaria. Primero calculamos los últimos dígitos 
    // de nyr en base p, luego recurrimos para los dígitos restantes
    static int nCrModpLucas(int n, int r, int p) {
        // Caso base
        if (r == 0) {
            return 1;
        }
        // Calcule los últimos dígitos de nyr en base p
        int ni = n % p;
        int ri = r % p;

        // Calcule el resultado de los últimos dígitos calculados 
        // anteriormente y de los dígitos restantes. Multiplica los 
        // dos resultados y calcula el resultado de la 
        // multiplicación en módulo p.
        return (nCrModpLucas(n / p, r / p, p)
                * // Últimos dígitos de nyr
                nCrModpDP(ni, ri, p)) % p; // Dígitos restantes
    }

    public static void main(String[] args) {
        int n = 1000, r = 900, p = 13;
        System.out.println(&quot;Value of nCr % p is &quot; + nCrModpLucas(n, r, p));
    }
}
</java>
  <cpp>#include&lt;bits/stdc++.h&gt; 
using namespace std;

int nCrModpDP(int n, int r, int p) {

    int C[r + 1];
    memset(C, 0, sizeof (C));
    C[0] = 1;

    for (int i = 1; i &lt;= n; i++) {

        for (int j = min(i, r); j &gt; 0; j--)
            C[j] = (C[j] + C[j - 1]) % p;
    }
    return C[r];
}

int nCrModpLucas(int n, int r, int p) {

    if (r == 0)
        return 1;
    int ni = n % p, ri = r % p;

    return (nCrModpLucas(n / p, r / p, p) * nCrModpDP(ni, ri, p)) % p;
}

int main() {
    int n = 1000, r = 900, p = 13;
    cout &lt;&lt; &quot;Value of nCr % p is &quot; &lt;&lt; nCrModpLucas(n, r, p);
    return 0;
}
</cpp>
  <py>def nCrModpDP(n, r, p): 
    C = [0] * (n + 1);
    C[0] = 1; 
    for i in range(1, (n + 1)): 
        j = min(i, r); 
        while(j &gt; 0): 
            C[j] = (C[j] + C[j - 1]) % p; 
            j -= 1; 
    return C[r]; 
    
def nCrModpLucas(n, r, p): 

    if (r == 0): 
        return 1; 
    ni = int(n % p); 
    ri = int(r % p); 
    return (nCrModpLucas(int(n / p), int(r / p), p) *
            nCrModpDP(ni, ri, p)) % p;  
n = 1000; 
r = 900; 
p = 13; 
print(&quot;Value of nCr % p is&quot;, 
      nCrModpLucas(n, r, p)); 
</py>
  <orden>6</orden>
  <suborden>88</suborden>
  <fecha_creacion>2020-12-05 01:56:18</fecha_creacion>
  <fecha_modificacion>2022-03-08 12:05:45</fecha_modificacion>
</row>
<row>
  <ID>197</ID>
  <supergrupo>Geometría</supergrupo>
  <tema>Ángulos</tema>
  <texto>Ángulo es un concepto de la Geometría para referirse al espacio comprendido entre la intersección de dos líneas que parten de un mismo punto o vértice, y que es medido en grados.</texto>
  <complejidad_tiempo>null</complejidad_tiempo>
  <java>//Dados 3 puntos A, B, y C, determina el valor del angulo ABC (origen en B) 
//en radianes. 
//Si se desea convertir a grados sexagesimales, 
//revisar degrees and radians.

import java.awt.Point;

public class Angle {

    static double angle(Point a, Point b, Point c) {
        Vec ba = toVector(b, a);
        Vec bc = toVector(b, c);
        return Math.acos((ba.x * bc.x + ba.y * bc.y) / Math.sqrt((ba.x * ba.x + ba.y * ba.y) * (bc.x * bc.x + bc.y * bc.y)));
    }

    static class Vec {

        public double x, y;

        public Vec(double _x, double _y) {
            this.x = _x;
            this.y = _y;
        }
    }

    static Vec toVector(Point a, Point b) {
        return new Vec(b.x - a.x, b.y - a.y);
    }

    static double DegToRad(double d) {
        return d * Math.PI / 180.0;
    }

    static double RadToDeg(double r) {
        return r * 180.0 / Math.PI;
    }

    public static void main(String[] args) {
        Point[] puntos = new Point[]{new Point(0, 0),
            new Point(1, 0), new Point(0, 1)};
        double res = angle(puntos[0], puntos[1], puntos[2]);
        System.out.println(res);
        System.out.println(RadToDeg(res));
    }

</java>
  <cpp>#include &lt;cstdlib&gt;
#include &lt;bits/stdc++.h&gt;
using namespace std;
#define PI  acos(-1.0)

struct Point {
    double x, y;

    Point() {
        x = y = 0.0;
    }

    Point(double _x, double _y) : x(_x), y(_y) {
    }

    bool operator==(Point other) const {
        return (fabs(x - other.x) &lt; 1e-9 &amp;&amp; (fabs(y - other.y) &lt; 1e-9));
    }
};

struct Vec {
    double x, y;

    Vec(double _x, double _y) : x(_x), y(_y) {
    }
};

Vec toVector(Point a, Point b) {
    return Vec(b.x - a.x, b.y - a.y);
}

double angle(Point a, Point b, Point c) {
    Vec ba = toVector(b, a);
    Vec bc = toVector(b, c);
    return acos((ba.x * bc.x + ba.y * bc.y) / sqrt((ba.x * ba.x + ba.y * ba.y) * (bc.x * bc.x + bc.y * bc.y)));
}

double DegToRad(double d) {
    return d * acos(-1.0) / 180.0;
}

double RadToDeg(double r) {
    return r * 180.0 / acos(-1.0);
}

int main() {
    vector&lt;Point&gt; puntos;
    Point a = {0, -1};
    Point b = {0, 0};
    Point c = {0, 1};
    puntos.emplace_back(a);
    puntos.emplace_back(b);
    puntos.emplace_back(c);
    double res = angle(puntos.at(0), puntos.at(1), puntos.at(2));
    cout &lt;&lt; res &lt;&lt; endl;
    cout &lt;&lt; RadToDeg(res) &lt;&lt; endl;
}
</cpp>
  <py>import math as math
class Point:
    def __init__(self, x, y):
        self.x = x
        self.y = y
 
    def equals(self, other):
        if (abs(self.x - other.x) &lt; 1e-9 and (abs(self.y - other.y) &lt; 1e-9)):
            return True
        return False
class Vec:
    def __init__(self, x, y):
        self.x = x
        self.y = y
def toVector(a, b):
    return Vec(b.x - a.x, b.y - a.y)
def angle(a, b, c):
    ba = toVector(b, a)
    bc = toVector(b, c)
    return math.acos((ba.x * bc.x + ba.y * bc.y) / math.sqrt((ba.x * ba.x + ba.y * ba.y) * (bc.x * bc.x + bc.y * bc.y)))


def DegToRad (d):
    return d * math.acos(-1.0) / 180.0


def RadToDeg(r): 
    return r * 180.0 / math.acos(-1.0)
puntos = []
puntos.append(Point(0, -1))
puntos.append(Point(0, 0))
puntos.append(Point(0, 1))
res = angle(puntos[0], puntos[1], puntos[2]);
print(res)
print(RadToDeg(res))

</py>
  <orden>7</orden>
  <suborden>20</suborden>
  <fecha_creacion>2020-12-06 19:51:35</fecha_creacion>
  <fecha_modificacion>2022-03-08 12:13:57</fecha_modificacion>
</row>
<row>
  <ID>198</ID>
  <supergrupo>Geometría</supergrupo>
  <tema>Puntos 2D</tema>
  <texto>El PUNTO es una «figura geométrica» adimensional: no tiene longitud, área, volumen, ni otro ángulo dimensional. No es un objeto físico. Describe una posición en el espacio, determinada respecto de un sistema de coordenadas preestablecido.

A los puntos se les suele nombrar con una letra mayúscula: A, B, C, etc.

 

El concepto de punto, como ente geométrico, surge en la antigua concepción griega de la geometría, compilada en Alejandría por Euclides en su tratado Los Elementos, dando una definición de punto excluyente: «lo que no tiene ninguna parte». El punto, en la geometría clásica se basa en la idea de que era un concepto intuitivo, el ente geométrico «sin dimensiones», y sólo era necesario asumir la noción de punto.

Esa cuestión fue analizada por A. N. Whitehead en: Una investigación sobre los principios naturales de conocimiento (An Inquiry Concerning the Principles of Natural Knowledge), y El concepto de la Naturaleza (The concept of Nature). En estos libros se expone la «relación de inclusión». En Proceso y Realidad (Process and Reality) Whitehead propone un nuevo enfoque basado en la «relación de conexión» topológica. También H. J. Schmidt plantea una visión totalmente distinta del punto geométrico.


Determinación geométrica

Un punto puede determinarse con diversos sistemas de referencia:

En el sistema de coordenadas cartesianas, se determina mediante las distancias ortogonales a los ejes principales, que se indican con dos letras o números: (x, y) en el plano; y con tres en el espacio (x, y, z).

En coordenadas polares, mediante su distancia al centro y la medida angular respecto del eje de referencia: (r, θ).

En coordenadas esféricas, mediante su distancia al centro y la medida angular respecto de los ejes de referencia: (r, θ, φ).

En coordenadas cilíndricas, mediante coordenadas radial, acimutal y altura: (ρ, φ, z).

También se pueden emplear sistemas de coordenadas elípticas, parabólicas, esferoidales, toridales, etc.


SEGMENTO

Un segmento, en geometría, es un fragmento de recta que está comprendido entre dos puntos.

ó también

Segmento es la porción de recta limitada por dos puntos, llamados extremos.

Tipos de segmentos

Segmento nulo: Un segmento es nulo cuando sus extremos coinciden.


Segmentos consecutivos

Dos segmentos son consecutivos cuando tienen un extremo en común.	 

Según pertenezcan o no a la misma línea, se clasifican en:

Colineales

No colineales: Los segmentos consecutivos no colineales, llamados poligonal o quebrada, pueden ser abiertos o cerrados según tengan o no extremos comunes el primer y el último segmento que lo forman. Las poligonales cerradas forman polígonos.
 
LA RECTA

En geometría euclidiana, la recta o línea recta, es el ente ideal que se extiende en una misma dirección, existe en una sola dimensión y contiene infinitos puntos; está compuesta de infinitos segmentos (el fragmento de línea más corto que une dos puntos). También se describe como la sucesión continua e indefinida de puntos en una sola dimensión, o sea, no posee principio ni fin.
 
La Recta se nombra con una letra Minúscula o dos Mayúsculas y se lee la recta AB, la recta HG y la recta m.
 
LA SEMIRECTA

La Semirecta se nombra con dos Mayúsculas y se lee la Semirecta AB, la Semirecta HG.

PLANO

En geometría, un plano es el ente ideal que sólo posee dos dimensiones, y contiene infinitos puntos y rectas; es uno de los entes geométricos fundamentales junto con el punto y la recta.

Solamente puede ser definido o descrito en relación a otros elementos geométricos similares. Se suele describir apoyándose en los postulados característicos, que determinan las relaciones entre los entes geométricos fundamentales. .-Cuando se habla de un plano, se está haciendo referencia a la superficie geométrica que no posee volumen (es decir, que es sólo bidimensional) y que posee un número infinito de rectas y puntos que lo cruzan de un lado al otro. Sin embargo, cuando el término se utiliza en plural, se está hablando de aquel material que es elaborado como una representación gráfica de superficies de diferente tipo. Los planos son especialmente utilizados en ingeniería, arquitectura y diseño ya que sirven para diagramar en una superficie plana otras superficies que son regularmente tridimensionales.

Un plano queda definido por los siguientes elementos geométricos:

Tres puntos no alineados.
Una recta y un punto exterior a ella.
Dos rectas paralelas.
Dos rectas que se cortan

Los planos suelen nombrarse con una letra del alfabeto griego: Alfa (α), Beta (β), Theta (θ), Fi (φ) entre otras

Suele representarse gráficamente, para su mejor visualización, como una figura delimitada por bordes irregulares (para indicar que el dibujo es una parte de una superficie infinita).
</texto>
  <complejidad_tiempo>null</complejidad_tiempo>
  <java>// La clase punto será la base sobre la cual se ejecuten otros algoritmos. 

 public class PointClass {

    static class Point {

        public double x, y;

        public Point() {
            this.x = this.y = 0.0;
        }

        public Point(double _x, double _y) {
            this.x = _x;
            this.y = _y;
        }

        public boolean equals(Point other) {
            if (Math.abs(this.x - other.x) &lt; 1e-9 &amp;&amp; (Math.abs(this.y - other.y) &lt; 1e-9)) {
                return true;
            }
            return false;
        }

    }
    
     public static void main(String[] args) {
         //coordenadas en x y y
         Point A= new Point(0, 0);
     }
}
</java>
  <cpp>#include &quot;bits/stdc++.h&quot; 
using namespace std;

struct Point {
    double x, y;

    Point() {
        x = y = 0.0;
    }

    Point(double _x, double _y) : x(_x), y(_y) {
    }

    bool operator==(Point other) const {
        return (fabs(x - other.x) &lt; 1e-9 &amp;&amp; (fabs(y - other.y) &lt; 1e-9));
    }
};

int main() {
    Point A = Point(0, 0);
}
</cpp>
  <py>class Point:
    def __init__(self, x, y):
        self.x = x
        self.y = y
 
    def compare(self, other):
        if (abs(self.x - other.x) &lt; 1e-9 and (abs(self.y - other.y) &lt; 1e-9)):
            return True
        return False
    
A = Point(0, 0)
</py>
  <orden>7</orden>
  <suborden>21</suborden>
  <fecha_creacion>2020-12-06 19:51:35</fecha_creacion>
  <fecha_modificacion>2022-03-08 12:13:57</fecha_modificacion>
</row>
<row>
  <ID>199</ID>
  <supergrupo>Geometría</supergrupo>
  <tema>Perímetro de un polígono</tema>
  <texto>El perímetro y el área son dos elementos fundamentales en matemáticas. Para cuantificar el espacio físico y también para proveer las bases de matemáticas más avanzadas como en el álgebra, trigonometría, y cálculo. El perímetro es una medida de la distancia alrededor de una figura y el área nos da una idea de qué tanta superficie cubre dicha figura.
 
 
Perímetro
 
El perímetro de una figura de dos dimensiones es la distancia alrededor de la figura. Algunas personas encuentran útil pensar “peri-metro” donde peri es “periferia” y metro es “medida”.
 
Si la figura es un polígono, entonces puede sumar todas las longitudes de sus lados para encontrar el perímetro. 
</texto>
  <complejidad_tiempo>null</complejidad_tiempo>
  <java>//Calcula el perímetro de un polígono representado 
//como un vector de puntos. 
//IMPORTANTE: Definir P[0] = P[n-1] para cerrar el polígono. 
//La estructura point debe estar definida, al igual que el
//método euclideanDistance.

import java.util.ArrayList;
import java.awt.Point;

public class Perimeter {

    public static double perimeter(ArrayList&lt;Point&gt; P) {
        double result = 0.0;
        for (int i = 0; i &lt; P.size() - 1; i++) {
            result += euclideanDistance(P.get(i), P.get(i + 1));
        }
        return result;
    }

    /*Trabajando con la clase Point*/
    static double euclideanDistance(Point p1, Point p2) {
        return Math.hypot(p1.x - p2.x, p1.y - p2.y);
    }

    /*Trabajando con los valores x y y de cada punto*/
    static double euclideanDistance(double x1, double y1, double x2, double y2) {
        return Math.hypot(x2 - x1, y2 - y1);
    }

    public static void main(String[] args) {
        ArrayList&lt;Point&gt; polygon = new ArrayList&lt;&gt;();
        polygon.add(new Point(0, 0));
        polygon.add(new Point(1, 0));
        polygon.add(new Point(1, 1));
        polygon.add(new Point(0, 1));
        polygon.add(new Point(0, 0));
        System.out.println(perimeter(polygon));
    }
}
</java>
  <cpp>using namespace std;

struct Point {
    double x, y;

    Point() {
        x = y = 0.0;
    }

    Point(double _x, double _y) : x(_x), y(_y) {
    }

};

double euclideanDistance(Point p1, Point p2) {
    return hypot(p1.x - p2.x, p1.y - p2.y);
}

double perimeter(vector&lt;Point&gt; P) {
    double result = 0.0;
    for (int i = 0; i &lt; P.size() - 1; i++) {
        result += euclideanDistance(P[i], P[i + 1]);
    }
    return result;
}

double euclideanDistance(double x1, double y1, double x2, double y2) {
    return hypot(x2 - x1, y2 - y1);
}

int main() {
    vector&lt;Point&gt; polygon;
    polygon.emplace_back(Point(0, 0));
    polygon.emplace_back(Point(1, 0));
    polygon.emplace_back(Point(1, 1));
    polygon.emplace_back(Point(0, 1));
    polygon.emplace_back(Point(0, 0));
    cout &lt;&lt; perimeter(polygon) &lt;&lt; endl;
}
</cpp>
  <py>import math as math
class Point:
    def __init__(self, x, y):
        self.x = x
        self.y = y
        
def euclideanDistance(p1, p2):
    return math.hypot(p1.x - p2.x, p1.y - p2.y)

def perimeter(P):
    result = 0.0
    for i in range (len(P)-1):
        result += euclideanDistance(P[i], P[i + 1])
    return result;

polygon = []
polygon.append(Point(0, 0));
polygon.append(Point(1, 0));
polygon.append(Point(1, 1));
polygon.append(Point(0, 1));
polygon.append(Point(0, 0));
print(perimeter(polygon))
</py>
  <orden>7</orden>
  <suborden>22</suborden>
  <fecha_creacion>2020-12-06 19:51:36</fecha_creacion>
  <fecha_modificacion>2022-03-08 12:13:57</fecha_modificacion>
</row>
<row>
  <ID>200</ID>
  <supergrupo>Geometría</supergrupo>
  <tema>Area de un  polígono</tema>
  <texto>Las fórmulas para calcular el área de un polígono son diferentes según si el polígono es regular o irregular:
Polígono regular: es un polígono con todos los lados y ángulos iguales.
Polígono irregular: polígono con con los lados y ángulos desiguales.
 
Mientras que el área del polígono regular se calcula a partir de un lado y la apotema, el área del polígono irregular requiere de métodos alternativos de cálculo de áreas: método de triangulación o determinante de Gauss.
Área del polígono regular
El área de un polígono regular se calcula a partir de su perímetro y su apotema. Sea P el polígono regular con N lados, su área es:
 
En un polígono regular, el perímetro se puede determinar por el producto del número de lados por la longitud de uno de los lados, es decir, Perímetro=N·L. O sea:
 
Área del polígono irregular
El cálculo del área de un polígono irregular requiere de métodos alternativos de cálculo de áreas. El método más común es dividir el polígono en N triángulos (siendo N el número de lados del polígono) y calcular la área como suma de las áreas de los triángulos. 
 
El área del polígono irregular se puede calcular mediante dos procedimientos alternativos: el método de triangulación o el determinante de Gauss.
</texto>
  <complejidad_tiempo>null</complejidad_tiempo>
  <java>//Calcula el area de un polígono representado como un 
//ArrayList de puntos. 
//IMPORTANTE: Definir P[0] = P[n-1] para cerrar el polígono. 
//El algorítmo utiliza el metodo de determinante 
//de la matriz de puntos de la figura. 

import java.util.ArrayList;
import java.awt.Point;

public class Area {

    public static double area(ArrayList&lt;Point&gt; P) {
        double result = 0.0;
        for (int i = 0; i &lt; P.size() - 1; i++) {
            result += ((P.get(i).x * P.get(i + 1).y) - (P.get(i + 1).x *            P.get(i).y));
        }
        return Math.abs(result) / 2.0;
    }

    public static void main(String[] args) {
        ArrayList&lt;Point&gt; puntos = new ArrayList&lt;&gt;();
        //los puntos deben ir en orden
        puntos.add(new Point(0, 0));
        puntos.add(new Point(0, 1));
        puntos.add(new Point(1, 1));
        puntos.add(new Point(1, 0));
        //Definir el ultimo punto igual que el primero para cerrar el poligono
        puntos.add(new Point(0, 0));
        System.out.println(area(puntos));
    }
}
</java>
  <cpp>#include &lt;cstdlib&gt;
#include &lt;bits/stdc++.h&gt;
using namespace std;

struct Point {
    double x, y;

    Point() {
        x = y = 0.0;
    }

    Point(double _x, double _y) : x(_x), y(_y) {
    }

    bool operator==(Point other) const {
        return (fabs(x - other.x) &lt; 1e-9 &amp;&amp; (fabs(y - other.y) &lt; 1e-9));
    }
};

double area(vector&lt;Point&gt; P) {
    double result = 0.0;
    for (int i = 0; i &lt; P.size() - 1; i++) {
        result += ((P.at(i).x * P.at(i + 1).y) - (P.at(i + 1).x * P.at(i).y));
    }
    return abs(result) / 2.0;
}

int main() {
    vector&lt;Point&gt; puntos;
    puntos.emplace_back(Point(0, 0));
    puntos.emplace_back(Point(0, 1));
    puntos.emplace_back(Point(1, 1));
    puntos.emplace_back(Point(1, 0));
    puntos.emplace_back(Point(0, 0));
    cout &lt;&lt; area(puntos) &lt;&lt; endl;
}
</cpp>
  <py>class Point:
    def __init__(self, x, y):
        self.x = x
        self.y = y
 
    def equals(self, other):
        if (abs(self.x - other.x) &lt; 1e-9 and (abs(self.y - other.y) &lt; 1e-9)):
            return True
        return False
def area(P):
    result = 0.0
    for i in range (len(P)-1):
        result += ((P[i].x * P[i + 1].y) - (P[i + 1].x * P[i].y))
    return abs(result) / 2.0;
puntos = []
puntos.append(Point(0, 0))
puntos.append(Point(0, 1))
puntos.append(Point(1, 1))
puntos.append(Point(1, 0))
puntos.append(Point(0, 0))
print(area(puntos))
</py>
  <orden>7</orden>
  <suborden>23</suborden>
  <fecha_creacion>2020-12-06 19:51:36</fecha_creacion>
  <fecha_modificacion>2022-03-08 12:13:57</fecha_modificacion>
</row>
<row>
  <ID>201</ID>
  <supergrupo>Geometría</supergrupo>
  <tema>Intersección de círculos</tema>
  <texto>Hay dos círculos A y B con sus centros C1 (x1, y1) y C2 (x2, y2) y radio R1 y R2. La tarea es comprobar que ambos círculos A y B se toquen o no.
Ejemplos:
Entrada: C1 = (3, 4)
         C2 = (14, 18)
         R1 = 5, R2 = 8
Resultado: Los círculos no se tocan entre sí.

Entrada: C1 = (2, 3)
         C2 = (15, 28)
         R1 = 12, R2 = 10
Resultado: los círculos se cruzan entre sí.

Entrada: C1 = (-10, 8)
         C2 = (14, -24)
         R1 = 30, R2 = 10
Entrada: -10 8
         14-24
         30 10
Salida: Círculos se tocan entre sí.
La distancia entre los centros C1 y C2 se calcula como
  C1C2 = raíz cuadrada ((x1 - x2) 2 + (y1 - y2) 2).
Hay tres condiciones que surgen.
1. Si C1C2 == R1 + R2
      Los círculos A y B se tocan entre sí.
2. Si C1C2&gt; R1 + R2
      Los círculos A y B no se tocan entre sí.
3. Si C1C2 &lt;R1 + R2
       El círculo se cruza entre sí.
</texto>
  <complejidad_tiempo>null</complejidad_tiempo>
  <java>// Programa Java para comprobar si dos círculos se tocan o no.

public class CircleIntersect {

    static int circle(int x1, int y1, int x2,
            int y2, int r1, int r2) {
        int distSq = (x1 - x2) * (x1 - x2)
                + (y1 - y2) * (y1 - y2);
        int radSumSq = (r1 + r2) * (r1 + r2);
        if (distSq == radSumSq) {
            return 1;
        } else if (distSq &gt; radSumSq) {
            return -1;
        } else {
            return 0;
        }
    }

    public static void main(String[] args) {
        int x1 = -10, y1 = 8;
        int x2 = 14, y2 = -24;
        int r1 = 30, r2 = 10;
        int t = circle(x1, y1, x2,
                y2, r1, r2);
        if (t == 1) {
            System.out.println(&quot;Circle touch to&quot;
                    + &quot; each other.&quot;);
        } else if (t &lt; 0) {
            System.out.println(&quot;Circle not touch&quot;
                    + &quot; to each other.&quot;);
        } else {
            System.out.println(&quot;Circle intersect&quot;
                    + &quot; to each other.&quot;);
        }
    }
}
</java>
  <cpp>#include&lt;bits/stdc++.h&gt; 
#include&lt;cstdlib&gt;
using namespace std;

int circle(int x1, int y1, int x2,
        int y2, int r1, int r2) {
    int distSq = (x1 - x2) * (x1 - x2)
            + (y1 - y2) * (y1 - y2);
    int radSumSq = (r1 + r2) * (r1 + r2);
    if (distSq == radSumSq) {
        return 1;
    } else if (distSq &gt; radSumSq) {
        return -1;
    } else {
        return 0;
    }
}

int main() {
    int x1 = -10, y1 = 8;
    int x2 = 14, y2 = -24;
    int r1 = 30, r2 = 10;
    int t = circle(x1, y1, x2,
            y2, r1, r2);
    if (t == 1) {
        cout &lt;&lt; &quot;Circle touch to each other.&quot; &lt;&lt; endl;
    } else if (t &lt; 0) {
        cout &lt;&lt; &quot;Circle not touch to each other.&quot; &lt;&lt; endl;
    } else {
        cout &lt;&lt; &quot;Circle intersect to each other.&quot; &lt;&lt; endl;
    }
}
</cpp>
  <py>def circle(x1, y1, x2, y2, r1, r2):
    distSq = (x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2)
    radSumSq = (r1 + r2) * (r1 + r2)
    if (distSq == radSumSq):
        return 1
    elif (distSq &gt; radSumSq):
        return -1
    else: 
        return 0

x1 = -10
y1 = 8
x2 = 14
y2 = -24
r1 = 30
r2 = 10
t = circle(x1, y1, x2, y2, r1, r2)
if (t == 1):
    print(&quot;Circle touch to each other.&quot;)
elif (t &lt; 0):
    print(&quot;Circle not touch to each other.&quot;)
else:
    print(&quot;Circle intersect to each other.&quot;)
</py>
  <orden>7</orden>
  <suborden>24</suborden>
  <fecha_creacion>2020-12-06 19:51:36</fecha_creacion>
  <fecha_modificacion>2022-03-08 12:13:57</fecha_modificacion>
</row>
<row>
  <ID>202</ID>
  <supergrupo>Geometría</supergrupo>
  <tema>Limpieza del cuarto</tema>
  <texto>Dada una habitación con cuadrículas cuadradas que tienen &quot;*&quot; y &quot;.&quot; Que representan celdas normales y desordenadas respectivamente.
Debe averiguar si la habitación se puede limpiar o no.
Hay una máquina que le ayuda en esta tarea, pero es capaz de limpiar solo la celda normal. Las celdas desordenadas no se pueden limpiar con la máquina hasta que haya limpiado la celda normal en su fila o columna. Ahora, verifique si la habitación se puede limpiar o no.
La entrada es la siguiente:
La primera línea contiene el tamaño de la habitación. Las siguientes n líneas contienen una descripción para cada fila en la que la fila [i] [j] es &quot;&quot; si está más desordenada que otras, de lo contrario, es &quot;&quot; si es una celda normal.
Ejemplos:
Entrada: 3
        . **
        . **
        . **
Resultado: Sí, la habitación se puede limpiar.
        1 1
        2 1
        3 1
Entrada: 4
       ****
       .. *.
       .. *.
       .. *.
Resultado: la casa no se puede limpiar.
Aproximación :
El número mínimo de celdas puede ser n. Es la única respuesta posible, ya que debe tener un elemento de tipo &quot;&quot; en cada fila y columna diferente. Si una columna determinada y una fila determinada contienen &quot;&quot; en todas las celdas, se sabe que la casa no se puede limpiar. Recorra cada fila y encuentre el &quot;&quot; que se puede utilizar para la máquina. Use este paso dos veces, verifique cada columna para cada fila y luego verifique cada fila para cada columna. Luego, verifique si alguno de los dos da una respuesta como n. Si es así, la casa se puede limpiar, de lo contrario no. Este enfoque nos dará la respuesta mínima requerida.

En el primer ejemplo, la máquina limpiará la celda (1, 1), (2, 1), (3, 1) para limpiar toda la habitación.
En el segundo ejemplo, cada celda de la fila tiene &quot;&quot; y cada celda de la columna contiene &quot;&quot;, por lo que la casa no se puede limpiar. La fila no se puede limpiar de ninguna manera.
</texto>
  <complejidad_tiempo>null</complejidad_tiempo>
  <java>// código java para encontrar si la casa se puede limpiar o no

import java.util.ArrayList;

public class CleaningRoom {

    static class Pair {

        int a, b;

        public Pair(int a, int b) {
            this.a = a;
            this.b = b;
        }
    }
    // El array A almacena el string
    static int A[][] = new int[105][105];
    // ans almacena el par de índices que la máquina va a limpiar
    static ArrayList&lt;Pair&gt; ans = new ArrayList&lt;&gt;();

    // Función para imprimir el vector de pares
    static void print() {
        System.out.println(&quot;Yes, the house can be cleaned.&quot;);
        for (int i = 0; i &lt; ans.size(); i++) {
            System.out.println((ans.get(i).a + &quot; &quot; + ans.get(i).b));
        }
    }

    static void solve(int n) {
        // inserta cada primera celda en cada fila que contenga &#39;.&#39;
        for (int i = 0; i &lt; n; i++) {
            for (int j = 0; j &lt; n; j++) {
                if (A[i][j] == &#39;.&#39;) {
                    ans.add(new Pair(i + 1, j + 1));
                    break;
                }
            }
        }
        // Si el número total de celdas es n, la casa se puede limpiar
        if (ans.size() == n) {
            print();
            return;
        }
        ans = new ArrayList&lt;&gt;();
        // inserta cada primera celda en cada columna que contenga &#39;.&#39;
        for (int i = 0; i &lt; n; i++) {
            for (int j = 0; j &lt; n; j++) {
                if (A[i][j] == &#39;.&#39;) {
                    ans.add(new Pair(i + 1, j + 1));
                    break;
                }
            }
        }
        // Si el número total de celdas es n, la casa se puede limpiar
        if (ans.size() == n) {
            print();
            return;
        }
        System.out.println(&quot;house cannot be cleaned.&quot;);
    }

    public static void main(String[] args) {
        int n = 3;
        String s = &quot;&quot;;
        s += &quot;.**&quot;;
        s += &quot;.**&quot;;
        s += &quot;.**&quot;;
        int k = 0;
        // Bucle para insertar letras de cadena en la matriz
        for (int i = 0; i &lt; n; i++) {
            for (int j = 0; j &lt; n; j++) {
                A[i][j] = s.charAt(k);
                k += 1;
            }
        }
        solve(n);
    }

}
</java>
  <cpp>#include &lt;bits/stdc++.h&gt; 
using namespace std;
char A[105][105];
vector&lt;pair&lt;int, int&gt; &gt; ans;

void print() {
    cout &lt;&lt; &quot;Yes, the house can be&quot;
            &lt;&lt; &quot; cleaned.&quot; &lt;&lt; endl;

    for (int i = 0; i &lt; ans.size(); i++)
        cout &lt;&lt; ans[i].first &lt;&lt; &quot; &quot;
            &lt;&lt; ans[i].second &lt;&lt; endl;
}

int solve(int n) {
    for (int i = 0; i &lt; n; i++) {
        for (int j = 0; j &lt; n; j++) {
            if (A[i][j] == &#39;.&#39;) {
                ans.push_back(make_pair(i + 1, j + 1));
                break;
            }
        }
    }
    if (ans.size() == n) {
        print();
        return 0;
    }

    ans.clear();

    for (int i = 0; i &lt; n; i++) {
        for (int j = 0; j &lt; n; j++) {
            if (A[j][i] == &#39;.&#39;) {
                ans.push_back(make_pair(i + 1, j + 1));
                break;
            }
        }
    }
    if (ans.size() == n) {
        print();
        return 0;
    }
    cout &lt;&lt; &quot;house cannot be cleaned.&quot; &lt;&lt; endl;
}

int main() {
    int n = 3;
    string s = &quot;&quot;;
    s += &quot;.**&quot;;
    s += &quot;.**&quot;;
    s += &quot;.**&quot;;
    int k = 0;
    for (int i = 0; i &lt; n; i++) {
        for (int j = 0; j &lt; n; j++)
            A[i][j] = s[k++];
    }
    solve(n);
    return 0;
}
</cpp>
  <py>A = [[0 for i in range(105)] for j in range(105)] 
ans = [] 

def printt(): 
      
    print(&quot;Yes, the house can be cleaned.&quot;) 
    for i in range(len(ans)): 
        print(ans[i][0], ans[i][1]) 
          
def solve(n): 
    global ans 
    for i in range(n): 
        for j in range(n): 
            if (A[i][j] == &#39;.&#39;): 
                ans.append([i + 1, j + 1]) 
                break
    if (len(ans) == n): 
        printt() 
        return 0
          
    ans = [] 

    for i in range(n): 
        for j in range(n): 
            if (A[j][i] == &#39;.&#39;): 
                ans.append([i + 1, j + 1]) 
                break
    if (len(ans) == n): 
        printt() 
        return 0
    print(&quot;house cannot be cleaned.&quot;) 
  

n = 3
s = &quot;&quot; 
s += &quot;.**&quot;
s += &quot;.**&quot;
s += &quot;.**&quot;
k = 0
for i in range(n): 
    for j in range(n): 
        A[i][j] = s[k] 
        k += 1
  
solve(n) 
</py>
  <orden>7</orden>
  <suborden>25</suborden>
  <fecha_creacion>2020-12-06 19:51:37</fecha_creacion>
  <fecha_modificacion>2022-03-08 12:13:57</fecha_modificacion>
</row>
<row>
  <ID>203</ID>
  <supergrupo>Geometría</supergrupo>
  <tema>Distancia Euclidiana</tema>
  <texto>Se le dan dos coordenadas (x1, y1) y (x2, y2) de un gráfico bidimensional. Calcula la distancia entre ellos.
Ejemplos:
Entrada: x1, y1 = (3, 4)
         x2, y2 = (7, 7)
Salida: 5

Entrada: x1, y1 = (3, 4)
         x2, y2 = (4, 3)
Salida: 1.41421
</texto>
  <complejidad_tiempo>null</complejidad_tiempo>
  <java>//Halla la distancia euclideana de 2 puntos en dos dimensiones (x,y). Para usar el primer método, debe definirse previamente la clase Point

import java.awt.Point;

public class EuclideanDistance {

    /*Trabajando con la clase Point*/
    static double euclideanDistance(Point p1, Point p2) {
        return Math.hypot(p1.x - p2.x, p1.y - p2.y);
    }

    /*Trabajando con los valores x y y de cada punto*/
    static double euclideanDistance(double x1, double y1, double x2, double y2) {
        return Math.hypot(x2 - x1, y2 - y1);
    }

    public static void main(String[] args) {
        System.out.println(euclideanDistance(new Point(0, 0), new Point(20, 20)));
        System.out.println(euclideanDistance(0, 0, 20, 20));
    }

}
</java>
  <cpp>#include &lt;cstdlib&gt;
#include &lt;bits/stdc++.h&gt;
using namespace std;

struct Point {
    double x, y;

    Point() {
        x = y = 0.0;
    }

    Point(double _x, double _y) : x(_x), y(_y) {
    }

    bool operator==(Point other) const {
        return (fabs(x - other.x) &lt; 1e-9 &amp;&amp; (fabs(y - other.y) &lt; 1e-9));
    }
};

double euclideanDistance(Point p1, Point p2) {
    return hypot(p1.x - p2.x, p1.y - p2.y);
}

double euclideanDistance(double x1, double y1, double x2, double y2) {
    return hypot(x2 - x1, y2 - y1);
}

int main() {
    cout &lt;&lt; euclideanDistance(Point(0, 0), Point(20, 20)) &lt;&lt; endl;
    cout &lt;&lt; euclideanDistance(0, 0, 20, 20) &lt;&lt; endl;

}
</cpp>
  <py>import math
class Point:
    def __init__(self, x, y):
        self.x = x
        self.y = y
 
    def equals(self, other):
        if (abs(self.x - other.x) &lt; 1e-9 and (abs(self.y - other.y) &lt; 1e-9)):
            return True
        return False
def euclideanDistance1(p1, p2):
    return math.hypot(p1.x - p2.x, p1.y - p2.y);


def euclideanDistance(x1, y1, x2, y2):
    return math.hypot(x2 - x1, y2 - y1)
print(euclideanDistance1(Point(0, 0), Point(20, 20)))
print(euclideanDistance(0, 0, 20, 20))
</py>
  <orden>7</orden>
  <suborden>26</suborden>
  <fecha_creacion>2020-12-06 19:51:37</fecha_creacion>
  <fecha_modificacion>2022-03-08 12:13:57</fecha_modificacion>
</row>
<row>
  <ID>204</ID>
  <supergrupo>Geometría</supergrupo>
  <tema>Vector geométrico</tema>
  <texto>Un vector director es un vector que da la dirección de una recta y también la orienta, es decir, le da un sentido determinado.
En el plano, en el espacio tridimensional o en cualquier espacio vectorial, una recta se puede definir con dos puntos o, de manera equivalente, con un punto y un vector director. En efecto, a partir de dos puntos distintos A y B se obtiene un punto, digamos A, y un vector director u = AB. Recíprocamente, con un punto A de la recta y un vector director u se construye un segundo punto de la misma, definido por AB = u. Esta recta se escribe (AB) o (A, u).
</texto>
  <complejidad_tiempo>null</complejidad_tiempo>
  <java>import java.awt.Point;
//Dados dos puntos A y B, crea el vector A-&gt;B. 
//Es llamado Vec para no confundirlo con vector 
//como colección de elementos.

public class GeometricVector {

    static class Vec {

        public double x, y;

        public Vec(double _x, double _y) {
            this.x = _x;
            this.y = _y;
        }
    }

    static Vec toVector(Point a, Point b) {
        return new Vec(b.x - a.x, b.y - a.y);
    }

    public static void main(String[] args) {
        Point a = new Point(0, 0);
        Point b = new Point(5, 5);
        Vec segmento = toVector(a, b);
    }
}
</java>
  <cpp>#include &lt;bits/stdc++.h&gt;
#include &lt;cstdlib&gt;
using namespace std;

struct Point {
    double x, y;

    Point() {
        x = y = 0.0;
    }

    Point(double _x, double _y) : x(_x), y(_y) {
    }

    bool operator==(Point other) const {
        return (fabs(x - other.x) &lt; 1e-9 &amp;&amp; (fabs(y - other.y) &lt; 1e-9));
    }
};

struct Vec {
    double x, y;

    Vec(double _x, double _y) : x(_x), y(_y) {
    }
};

Vec toVector(Point a, Point b) {
    return Vec(b.x - a.x, b.y - a.y);
}

int main() {
    Point a = {0, 0};
    Point b = {5, 5};
    Vec segmento = toVector(a, b);
}
</cpp>
  <py>class Point:
    def __init__(self, x, y):
        self.x = x
        self.y = y
 
    def equals(self, other):
        if (abs(self.x - other.x) &lt; 1e-9 and (abs(self.y - other.y) &lt; 1e-9)):
            return True
        return False
class Vec:
    def __init__(self, x, y):
        self.x = x
        self.y = y
def toVector(a, b):
    return Vec(b.x - a.x, b.y - a.y)
def angle(a, b, c):
    ba = toVector(b, a)
    bc = toVector(b, c)
    return math.acos((ba.x * bc.x + ba.y * bc.y) / math.sqrt((ba.x * ba.x + ba.y * ba.y) * (bc.x * bc.x + bc.y * bc.y)))

a = Point(0, 0)
b = Point(5, 5)
segmento = toVector(a, b)
</py>
  <orden>7</orden>
  <suborden>27</suborden>
  <fecha_creacion>2020-12-06 19:51:37</fecha_creacion>
  <fecha_modificacion>2022-03-08 12:13:57</fecha_modificacion>
</row>
<row>
  <ID>205</ID>
  <supergrupo>Geometría</supergrupo>
  <tema>Punto dentro de un polígono</tema>
  <texto>Dado un polígono y un punto &quot;p&quot;, averigüe si &quot;p&quot; se encuentra dentro del polígono o no. Los puntos que se encuentran en el borde se consideran dentro

A continuación se presenta una idea sencilla para comprobar si un punto está dentro o fuera.
1) Dibuja una línea horizontal a la derecha de cada punto y extiéndela hasta el infinito

1) Cuente el número de veces que la línea se cruza con los bordes del polígono.

2) Un punto está dentro del polígono si el recuento de intersecciones es impar o
    el punto se encuentra en un borde de polígono. Si ninguna de las condiciones es verdadera, entonces
    el punto se encuentra afuera.
 
¿Cómo manejar el punto &quot;g&quot; en la figura anterior?
Tenga en cuenta que debemos devolver verdadero si el punto se encuentra en la línea o igual que uno de los vértices del polígono dado. Para manejar esto, después de verificar si la línea desde &quot;p&quot; hasta el extremo se interseca, verificamos si &quot;p&quot; es colineal con los vértices de la línea actual del polígono. Si es coliear, entonces verificamos si el punto &quot;p&quot; se encuentra en el lado actual del polígono, si se encuentra, devolvemos verdadero, de lo contrario falso.
</texto>
  <complejidad_tiempo>null</complejidad_tiempo>
  <java>//Determina si un punto pt se encuentra en el polígono 
//P. Este polígono se define como un vector de puntos, 
//donde el punto 0 y n-1 son el mismo. 
import java.util.ArrayList;
import java.awt.Point;

public class PointtInPolygon {

    static boolean ccw(Point p, Point q, Point r) {
        return cross(toVector(p, q), toVector(p, r)) &gt; 0;
    }

    static boolean inPolygon(Point pt, ArrayList&lt;Point&gt; P) {
        if (P.isEmpty()) {
            return false;
        }
        double sum = 0;
        for (int i = 0; i &lt; P.size() - 1; i++) {
            if (ccw(pt, P.get(i), P.get(i + 1))) {
                sum += angle(P.get(i), pt, P.get(i + 1));
            } else {
                sum -= angle(P.get(i), pt, P.get(i + 1));
            }
        }
        if (Math.abs(Math.abs(sum) - 2 * Math.acos(-1.0)) &lt; 1e-9) {
            return true;
        }
        return false;
    }

    static double cross(Vec a, Vec b) {
        return a.x * b.y - a.y * b.x;
    }

    static boolean collinear(Point p, Point q, Point r) {
        return Math.abs(cross(toVector(p, q), toVector(p, r))) &lt; 1e-9;
    }

    static double angle(Point a, Point b, Point c) {
        Vec ba = toVector(b, a);
        Vec bc = toVector(b, c);
        return Math.acos((ba.x * bc.x + ba.y * bc.y) / Math.sqrt((ba.x * ba.x + ba.y * ba.y) * (bc.x * bc.x + bc.y * bc.y)));
    }

    static class Vec {

        public double x, y;

        public Vec(double _x, double _y) {
            this.x = _x;
            this.y = _y;
        }
    }

    static Vec toVector(Point a, Point b) {
        return new Vec(b.x - a.x, b.y - a.y);
    }

    public static void main(String[] args) {
        ArrayList&lt;Point&gt; polygon = new ArrayList&lt;&gt;();
        polygon.add(new Point(0, 0));
        polygon.add(new Point(2, 0));
        polygon.add(new Point(2, 2));
        polygon.add(new Point(0, 2));
        polygon.add(new Point(0, 0));
        Point punto = new Point(1, 1);
        if (inPolygon(punto, polygon)) {
            System.out.println(&quot;Si&quot;);
        } else {
            System.out.println(&quot;No&quot;);
        }
    }
}
</java>
  <cpp>#include &quot;bits/stdc++.h&quot; 
using namespace std;

struct Point {
    double x, y;

    Point() {
        x = y = 0.0;
    }

    Point(double _x, double _y) : x(_x), y(_y) {
    }

    bool operator==(Point other) const {
        return (fabs(x - other.x) &lt; 1e-9 &amp;&amp; (fabs(y - other.y) &lt; 1e-9));
    }
};

struct Vec {
    double x, y;

    Vec(double _x, double _y) {
        x = _x;
        y = _y;
    }
};

static Vec toVector(Point a, Point b) {
    return Vec(b.x - a.x, b.y - a.y);
}

double angle(Point a, Point b, Point c) {
    Vec ba = toVector(b, a);
    Vec bc = toVector(b, c);
    return acos((ba.x * bc.x + ba.y * bc.y) / sqrt((ba.x * ba.x + ba.y * ba.y) * (bc.x * bc.x + bc.y * bc.y)));
}

double cross(Vec a, Vec b) {
    return a.x * b.y - a.y * b.x;
}

bool ccw(Point p, Point q, Point r) {
    return cross(toVector(p, q), toVector(p, r)) &gt; 0;
}

bool inPolygon(Point pt, vector&lt;Point&gt; P) {
    if (P.empty()) {
        return false;
    }
    double sum = 0;
    for (int i = 0; i &lt; P.size() - 1; i++) {
        if (ccw(pt, P[i], P[i + 1])) {
            sum += angle(P[i], pt, P[i + 1]);
        } else {
            sum -= angle(P[i], pt, P[i + 1]);
        }
    }
    if (abs(abs(sum) - 2 * acos(-1.0)) &lt; 1e-9) {
        return true;
    }
    return false;
}

bool collinear(Point p, Point q, Point r) {
    return abs(cross(toVector(p, q), toVector(p, r))) &lt; 1e-9;
}

int main() {
    vector&lt;Point&gt; polygon;
    polygon.emplace_back(Point(0, 0));
    polygon.emplace_back(Point(2, 0));
    polygon.emplace_back(Point(2, 2));
    polygon.emplace_back(Point(0, 2));
    polygon.emplace_back(Point(0, 0));
    Point punto = Point(1, 1);
    if (inPolygon(punto, polygon)) {
        cout &lt;&lt; &quot;Si&quot; &lt;&lt; endl;
    } else {
        cout &lt;&lt; &quot;No&quot; &lt;&lt; endl;
    }
}
</cpp>
  <py>import math
 
class Point:
    def __init__(self, x, y):
        self.x = x
        self.y = y
 
    def compare(self, other):
        if (abs(self.x - other.x) &lt; 1e-9 and (abs(self.y - other.y) &lt; 1e-9)):
            return True
        return False
    
class Vec:
    def __init__(self, x, y):
        self.x = x
        self.y = y
   
def toVector(a, b):
    return Vec(b.x - a.x, b.y - a.y)

def angle(a, b, c):
    ba = toVector(b, a)
    bc = toVector(b, c)
    return math.acos((ba.x * bc.x + ba.y * bc.y) / math.sqrt((ba.x * ba.x + ba.y * ba.y) * (bc.x * bc.x + bc.y * bc.y)))

def cross(a, b):
    return a.x * b.y - a.y * b.x


def ccw(p, q, r):
    return cross(toVector(p, q), toVector(p, r)) &gt; 0

def inPolygon(pt, P):
    if (len(P) == 0):
        return false;
    sum = 0;
    for i in range (len(P)-1):
        if (ccw(pt, P[i], P[i + 1])):
            sum += angle(P[i], pt, P[i + 1])
        else:
            sum -= angle(P[i], pt, P[i + 1])
    if (abs(abs(sum) - 2 * math.acos(-1.0)) &lt; 1e-9):
        return True
    return False

def collinear(p, q, r):
    return abs(cross(toVector(p, q), toVector(p, r))) &lt; 1e-9

polygon = []
polygon.append(Point(0, 0));
polygon.append(Point(2, 0));
polygon.append(Point(2, 2));
polygon.append(Point(0, 2));
polygon.append(Point(0, 0));
punto = Point(1, 1)
if (inPolygon(punto, polygon)):
    print(&quot;Si&quot;)
else:
    print(&quot;No&quot;)
</py>
  <orden>7</orden>
  <suborden>28</suborden>
  <fecha_creacion>2020-12-06 19:51:38</fecha_creacion>
  <fecha_modificacion>2022-03-08 12:13:57</fecha_modificacion>
</row>
<row>
  <ID>206</ID>
  <supergrupo>Geometría</supergrupo>
  <tema>Algoritmo lazo de zapato para áreas de polígonos</tema>
  <texto>Dadas las coordenadas ordenadas de un polígono con n vértices. Encuentra el área del polígono. Aquí ordenados significa que las coordenadas se dan en sentido horario o antihorario desde el primer vértice hasta el último.
Ejemplos:
Entrada: X [] = {0, 4, 4, 0}, Y [] = {0, 0, 4, 4};
Salida: 16

Entrada: X [] = {0, 4, 2}, Y [] = {0, 0, 4}
Salida: 8
Podemos calcular el área de un polígono usando la fórmula de Cordones.
Area: 
 = | 1/2 [(x1y2 + x2y3 + ... + xn-1yn + xny1) -
           (x2y1 + x3y2 + ... + xnyn-1 + x1yn)] |
¿Por qué se llama Fórmula de cordones de zapatos?
La fórmula se llama así por la forma en que la evaluamos.
Ejemplo:
Deje que los vértices de entrada sean
 (0, 1), (2, 3) y (4, 7).

El procedimiento de evaluación coincide con el proceso de vinculación
cordones de zapatos.

Escribimos vértices como se muestra a continuación
  0 1
  2 3
  4 7
  0 1 [escrito dos veces]

evaluamos términos positivos como se muestra a continuación
  0 \ 1
  2 \ 3
  4 \ 7
  0 1
es decir, 0 * 3 + 2 * 7 + 4 * 1 = 18

evaluamos los términos negativos de la siguiente manera
  0 1
  2/3
  4/7
  0/1
es decir, 0 * 7 + 4 * 3 + 2 * 1 = 14

Área = 1/2 (18 - 14) = 2
¿Como funciona esto?
Siempre podemos dividir un polígono en triángulos. La fórmula del área se obtiene tomando cada arista AB y calculando el área (con signo) del triángulo ABO con un vértice en el origen O, tomando el producto cruzado (que da el área de un paralelogramo) y dividiéndolo por 2. Como uno envuelve el polígono, estos triángulos con área positiva y negativa se superpondrán, y las áreas entre el origen y el polígono se cancelarán y sumarán 0, mientras que solo queda el área dentro del triángulo de referencia.
</texto>
  <complejidad_tiempo>null</complejidad_tiempo>
  <java>// Programa Java para evaluar el área de un polígono usando la fórmula del cordón

public class ShoelacePoly {

    // (X [i], Y [i]) son coordenadas del i-ésimo punto.
    public static double polygonArea(double X[], double Y[],
            int n) {
        // Inicializar área
        double area = 0.0;

        // Calcular el valor de la fórmula del cordón
        int j = n - 1;
        for (int i = 0; i &lt; n; i++) {
            area += (X[j] + X[i]) * (Y[j] - Y[i]);

            // j es el vértice anterior a i
            j = i;
        }

        // Return valor absoluto
        return Math.abs(area / 2.0);
    }

    public static void main(String[] args) {
        double X[] = {0, 2, 4};
        double Y[] = {1, 3, 7};

        int n = 3;
        System.out.println(polygonArea(X, Y, n));
    }

}
</java>
  <cpp>#include &lt;bits/stdc++.h&gt; 
using namespace std;

double polygonArea(double X[], double Y[], int n) {
    double area = 0.0;

    int j = n - 1;
    for (int i = 0; i &lt; n; i++) {
        area += (X[j] + X[i]) * (Y[j] - Y[i]);
        j = i;
    }
    return abs(area / 2.0);
}

int main() {
    double X[] = {0, 2, 4};
    double Y[] = {1, 3, 7};

    int n = sizeof (X) / sizeof (X[0]);

    cout &lt;&lt; polygonArea(X, Y, n);
} 
</cpp>
  <py>def polygonArea(X, Y, n): 
    area = 0.0
    j = n - 1
    for i in range(0, n): 
        area += (X[j] + X[i]) * (Y[j] - Y[i]) 
    return int(abs(area / 2.0)) 
  
X = [0, 2, 4] 
Y = [1, 3, 7] 
n = len(X) 
print(polygonArea(X, Y, n)) 
</py>
  <orden>7</orden>
  <suborden>29</suborden>
  <fecha_creacion>2020-12-06 19:51:38</fecha_creacion>
  <fecha_modificacion>2022-03-08 12:13:57</fecha_modificacion>
</row>
<row>
  <ID>207</ID>
  <supergrupo>Geometría</supergrupo>
  <tema>Números de cuadrados en un rectángulo </tema>
  <texto>Dado un rectángulo de m x n, ¿cuántos cuadrados tiene?
Ejemplos:
Entrada: m = 2, n = 2
Salida: 5
Hay 4 cuadrados de tamaño 1x1 +
           1 cuadrado de tamaño 2x2.

Entrada: m = 4, n = 3
Salida: 20
Hay 12 cuadrados de tamaño 1x1 +
           6 cuadrados de tamaño 2x2 +
           2 cuadrados de tamaño 3x3.

Resolvamos primero este problema para m = n, es decir, para un cuadrado:
Para m = n = 1, salida: 1
Para m = n = 2, salida: 4 + 1 [4 de tamaño 1 × 1 + 1 de tamaño 2 × 2]
Para m = n = 3, salida: 9 + 4 + 1 [9 de tamaño 1 × 1 + 4 de tamaño 2 × 2 + 1 de tamaño 3 × 3]
Para m = n = 4, salida 16 + 9 + 4 + 1 [16 de tamaño 1 × 1 + 9 de tamaño 2 × 2 + 4 de tamaño 3 × 3 + 1 de tamaño 4 × 4]
En general, parece ser n ^ 2 + (n-1) ^ 2 +… 1 = n (n + 1) (2n + 1) / 6

Resolvamos este problema cuando m puede no ser igual an:
Supongamos que m &lt;= n

De la explicación anterior, sabemos que el número de cuadrados en una matriz de m x m es m (m + 1) (2m + 1) / 6
¿Qué sucede cuando agregamos una columna, es decir, cuál es el número de cuadrados en la matriz m x (m + 1)?
Cuando agregamos una columna, el número de cuadrados aumentados es m + (m-1) +… + 3 + 2 + 1
[m cuadrados de tamaño 1 × 1 + (m-1) cuadrados de tamaño 2 × 2 +… + 1 cuadrado de tamaño m x m]
Que es igual a m (m + 1) / 2
Entonces, cuando agregamos (n-m) columnas, el número total de cuadrados aumentados es (n-m) * m (m + 1) / 2.
Entonces, el número total de cuadrados es m (m + 1) (2m + 1) / 6 + (n-m) * m (m + 1) / 2.
Usando la misma lógica podemos probar cuando n &lt;= m.
Entonces, en general,
Número total de cuadrados = m x (m + 1) x (2m + 1) / 6 +
                          (n-m) x m x (m + 1) / 2

cuando n es una dimensión mayor
Usando la lógica anterior para el rectángulo, también podemos probar que el número de cuadrados en un cuadrado es n (n + 1) (2n + 1) / 6
</texto>
  <complejidad_tiempo>null</complejidad_tiempo>
  <java>// Programa Java para contar cuadrados en un rectángulo de tamaño m x n

public class NumberSquaresRectangle {

    // Devuelve el recuento de todos los cuadrados 
    // en un rectángulo de tamaño m x n
    static int countSquares(int m,
            int n) {
        // Si n es menor, intercambie my n
        if (n &lt; m) {
            // intercambio (m, n)
            int temp = m;
            m = n;
            n = temp;
        }
        // Ahora n es una dimensión mayor, aplica la fórmula
        return m * (m + 1) * (2 * m + 1)
                / 6 + (n - m) * m * (m + 1) / 2;
    }

    public static void main(String[] args) {
        int m = 4, n = 3;
        System.out.println(&quot;Count of squares is &quot;
                + countSquares(m, n));
    }
}
</java>
  <cpp>#include&lt;iostream&gt; 
using namespace std;

int countSquares(int m, int n) {
    if (n &lt; m)
        swap(m, n);
    return m * (m + 1) * (2 * m + 1) /
            6 + (n - m) * m * (m + 1) / 2;
}

int main() {
    int m = 4, n = 3;
    cout &lt;&lt; &quot;Count of squares is &quot;
            &lt;&lt; countSquares(m, n);
} 
</cpp>
  <py>def countSquares(m, n): 
    if(n &lt; m): 
        temp = m 
        m = n 
        n = temp 
    return ((m * (m + 1) * (2 * m + 1) / 
            6 + (n - m) * m * (m + 1) / 2)) 
  
m = 4 
n = 3
print(&quot;Count of squares is &quot;, countSquares(m, n)) 
</py>
  <orden>7</orden>
  <suborden>30</suborden>
  <fecha_creacion>2020-12-06 19:51:38</fecha_creacion>
  <fecha_modificacion>2022-03-08 12:13:57</fecha_modificacion>
</row>
<row>
  <ID>208</ID>
  <supergrupo>Geometría</supergrupo>
  <tema>Algoritmo de Jarvis para cascos convexos</tema>
  <texto>Dado un conjunto de puntos en el plano. el casco convexo del conjunto es el polígono convexo más pequeño que contiene todos los puntos del mismo.
Ilustración 3 8 Casco convexo
 
¿Cómo verificar si dos segmentos de línea dados se cruzan?
La idea del algoritmo de Jarvis es simple, comenzamos desde el punto más a la izquierda (o punto con el valor mínimo de la coordenada x) y seguimos envolviendo puntos en dirección contraria a las agujas del reloj. La gran pregunta es, dado un punto p como punto actual, ¿cómo encontrar el siguiente punto en la salida? La idea es utilizar la orientación () aquí. El siguiente punto se selecciona como el punto que vence a todos los demás puntos en la orientación en sentido antihorario, es decir, el siguiente punto es q si para cualquier otro punto r, tenemos &quot;orientación (p, q, r) = en sentido antihorario&quot;. A continuación se muestra el algoritmo detallado.
1) Inicialice p como punto más a la izquierda.
2) Haga lo siguiente mientras no regresemos al primer punto (o al extremo izquierdo).
… ..A) El siguiente punto q es el punto tal que el triplete (p, q, r) es en sentido antihorario para cualquier otro punto r.
… ..B) siguiente [p] = q (Almacenar q como siguiente de p en el casco convexo de salida).
… ..C) p = q (Establecer p como q para la siguiente iteración).

Complejidad del tiempo: para cada punto del casco, examinamos todos los demás puntos para determinar el siguiente. La complejidad del tiempo es? (M * n) donde n es el número de puntos de entrada y m es el número de puntos de salida o de casco (m &lt;= n). En el peor de los casos, la complejidad del tiempo es O (n 2). El peor caso ocurre cuando todos los puntos están en el casco (m = n)

</texto>
  <complejidad_tiempo>null</complejidad_tiempo>
  <java>// Programa Java para encontrar el casco convexo de un conjunto de puntos.

import java.util.*;

class ConvexHullJarvis {

    static class Point {

        int x, y;

        Point(int x, int y) {
            this.x = x;
            this.y = y;
        }
    }

    // Encontrar la orientación del triplete ordenado (p, q, r). 
    // La función devuelve los siguientes valores
    // 0 -&gt; p, q y r son colineales
    // 1 -&gt; En sentido horario
    // 2 -&gt; en sentido antihorario
    public static int orientation(Point p, Point q, Point r) {
        int val = (q.y - p.y) * (r.x - q.x)
                - (q.x - p.x) * (r.y - q.y);

        if (val == 0) {
            return 0;  // collinear 
        }
        return (val &gt; 0) ? 1 : 2; // reloj o en sentido antihorario
    }

    // Imprime el casco convexo de un conjunto de n puntos.
    public static void convexHull(Point points[], int n) {
        // Debe haber al menos 3 puntos
        if (n &lt; 3) {
            return;
        }

        // Inicializar resultado
        ArrayList&lt;Point&gt; hull = new ArrayList&lt;&gt;();

        // Encuentra el punto más a la izquierda
        int l = 0;
        for (int i = 1; i &lt; n; i++) {
            if (points[i].x &lt; points[l].x) {
                l = i;
            }
        }

        // Comience desde el punto más a la izquierda, continúe 
        // moviéndose en sentido antihorario hasta llegar al punto de 
        // inicio nuevamente. Este ciclo se ejecuta O (h) veces donde h 
        // es el número de puntos en el resultado o la salida. 
        int p = l, q;
        do {
            // Agregar el punto actual al resultado
            hull.add(points[p]);

            // Busque un punto &#39;q&#39; tal que la orientación (p, x, q) sea 
            // en sentido antihorario para todos los puntos &#39;x&#39;. La idea es 
            // realizar un seguimiento del último punto visitado más en sentido 
            // antihorario en q. Si algún punto &#39;i&#39; está más en sentido 
            // contrario a las agujas del reloj que q, actualice q.
            q = (p + 1) % n;

            for (int i = 0; i &lt; n; i++) {
                // Si i está más en sentido antihorario que la q actual, actualice q
                if (orientation(points[p], points[i], points[q])
                        == 2) {
                    q = i;
                }
            }

            // Ahora q es el más en sentido antihorario con respecto a p.
            // Establezca p como q para la próxima iteración, de modo que 
            // q se agregue al resultado &#39;casco&#39;
            p = q;

        } while (p != l);  // Mientras no llegamos primer point 

        // Print Result 
        for (Point temp : hull) {
            System.out.println(&quot;(&quot; + temp.x + &quot;, &quot;
                    + temp.y + &quot;)&quot;);
        }
    }

    public static void main(String[] args) {
        Point points[] = new Point[7];
        points[0] = new Point(0, 3);
        points[1] = new Point(2, 3);
        points[2] = new Point(1, 1);
        points[3] = new Point(2, 1);
        points[4] = new Point(3, 0);
        points[5] = new Point(0, 0);
        points[6] = new Point(3, 3);
        int n = points.length;
        convexHull(points, n);
    }
}
</java>
  <cpp>#include &lt;bits/stdc++.h&gt; 
using namespace std;

struct Point {
    int x, y;
};

int orientation(Point p, Point q, Point r) {
    int val = (q.y - p.y) * (r.x - q.x) -
            (q.x - p.x) * (r.y - q.y);

    if (val == 0) return 0;
    return (val &gt; 0) ? 1 : 2;
}

void convexHull(Point points[], int n) {

    if (n &lt; 3) return;
    vector&lt;Point&gt; hull;
    int l = 0;
    for (int i = 1; i &lt; n; i++)
        if (points[i].x &lt; points[l].x)
            l = i;

    int p = l, q;
    do {

        hull.push_back(points[p]);

        q = (p + 1) % n;
        for (int i = 0; i &lt; n; i++) {
            if (orientation(points[p], points[i], points[q]) == 2)
                q = i;
        }

        p = q;

    } while (p != l);

    for (int i = 0; i &lt; hull.size(); i++)
        cout &lt;&lt; &quot;(&quot; &lt;&lt; hull[i].x &lt;&lt; &quot;, &quot;
            &lt;&lt; hull[i].y &lt;&lt; &quot;)\n&quot;;
}

int main() {
    Point points[] = {
        {0, 3},
        {2, 2},
        {1, 1},
        {2, 1},
        {3, 0},
        {0, 0},
        {3, 3}
    };
    int n = sizeof (points) / sizeof (points[0]);
    convexHull(points, n);
    return 0;
} 
</cpp>
  <py>class Point: 
    def __init__(self, x, y): 
        self.x = x 
        self.y = y 
  
def Left_index(points): 
      
    minn = 0
    for i in range(1, len(points)): 
        if points[i].x &lt; points[minn].x: 
            minn = i 
        elif points[i].x == points[minn].x: 
            if points[i].y &gt; points[minn].y: 
                minn = i 
    return minn 
  
def orientation(p, q, r): 
    val = (q.y - p.y) * (r.x - q.x) - \ (q.x - p.x) * (r.y - q.y) 
    if val == 0: 
        return 0
    elif val &gt; 0: 
        return 1
    else: 
        return 2
  
def convexHull(points, n): 
    if n &lt; 3: 
        return
    l = Left_index(points) 
    hull = [] 
    p = l 
    q = 0
    while(True): 
        hull.append(p) 
        q = (p + 1) % n 
        for i in range(n): 
            if(orientation(points[p], 
               points[i], points[q]) == 2): 
                q = i 
        p = q 
        if(p == l): 
            break
 
    for each in hull: 
        print(points[each].x, points[each].y) 
  
points = [] 
points.append(Point(0, 3)) 
points.append(Point(2, 2)) 
points.append(Point(1, 1)) 
points.append(Point(2, 1)) 
points.append(Point(3, 0)) 
points.append(Point(0, 0)) 
points.append(Point(3, 3)) 
convexHull(points, len(points)) 
</py>
  <orden>7</orden>
  <suborden>31</suborden>
  <fecha_creacion>2020-12-06 19:51:38</fecha_creacion>
  <fecha_modificacion>2022-03-08 12:13:57</fecha_modificacion>
</row>
<row>
  <ID>209</ID>
  <supergrupo>Strings</supergrupo>
  <tema>Algoritmo Z</tema>
  <texto>Este algoritmo encuentra todas las apariciones de un patrón en un texto en tiempo lineal. Deje que la longitud del texto sea n y el patrón sea m, entonces el tiempo total tomado es O (m + n) con complejidad de espacio lineal. Ahora podemos ver que la complejidad del tiempo y el espacio es la misma que la del algoritmo KMP, pero este algoritmo es más simple de entender.
En este algoritmo, construimos una array Z.
¿Qué es Z Array?
Para una cadena str [0..n-1], la array Z tiene la misma longitud que la cadena. Un elemento Z [i] de la array Z almacena la longitud de la subcadena más larga a partir de str [i], que también es un prefijo de str [0..n-1]. La primera entrada de la array Z significa menos, ya que la cadena completa siempre es un prefijo de sí misma.
Ejemplo:
Índice 0 1 2 3 4 5 6 7 8 9 10 11
Texto a a b c a a b x a a a z
Valores Z X 1 0 0 3 1 0 0 2 2 1 0
Más ejemplos:
str = &quot;aaaaaa&quot;
Z [] = {x, 5, 4, 3, 2, 1}

str = &quot;aabaacd&quot;
Z [] = {x, 1, 0, 2, 1, 0, 0}

str = &quot;abababab&quot;
Z [] = {x, 0, 6, 0, 4, 0, 2, 0}
 
¿Cómo es útil la array Z en la búsqueda de patrones en tiempo lineal?
La idea es concatenar patrón y texto, y crear una cadena “P $ T” donde P es patrón, $ es un carácter especial que no debe estar presente en patrón y texto, y T es texto. Construya la array Z para cadenas concatenadas. En la array Z, si el valor Z en cualquier punto es igual a la longitud del patrón, entonces el patrón está presente en ese punto.
Ejemplo:
Patrón P = &quot;aab&quot;, Texto T = &quot;baabaa&quot;

La cadena concatenada es = &quot;aab $ baabaa&quot;

La array Z para la cadena concatenada anterior es {x, 1, 0, 0, 0,
                                          3, 1, 0, 2, 1}.
Dado que la longitud del patrón es 3, el valor 3 en la array Z
indica presencia de patrón.
¿Cómo construir una array Z?
     Una solución simple consiste en ejecutar dos bucles anidados, el bucle externo va a cada índice y el bucle interno encuentra la longitud del prefijo más largo que coincide con la subcadena que comienza en el índice actual. La complejidad temporal de esta solución es O (n2).

      Podemos construir una array Z en tiempo lineal.
La idea es mantener un intervalo [L, R] que es el intervalo con el máximo R
tal que [L, R] es una subcadena de prefijo (subcadena que también es prefijo).

Los pasos para mantener este intervalo son los siguientes:

1) Si i&gt; R entonces no hay subcadena de prefijo que comience antes de i y
   termina después de i, por lo que restablecemos L y R y calculamos nuevo [L, R] comparando
   str [0 ..] a str [i ..] y obtener Z [i] (= R-L + 1).

2) Si i &lt;= R entonces sea K = i-L, ahora Z [i]&gt; = min (Z [K], R-i + 1) porque
   str [i ..] coincide con str [K ..] para al menos R-i + 1 caracteres (están en
   [L, R] intervalo que sabemos que es una subcadena de prefijo).
   Ahora surgen dos sub casos:
      a) Si Z [K] &lt;R-i + 1 entonces no hay una subcadena de prefijo que comience en
         str [i] (de lo contrario Z [K] sería más grande) entonces Z [i] = Z [K] y
         el intervalo [L, R] permanece igual.
      b) Si Z [K]&gt; = R-i + 1 entonces es posible extender el intervalo [L, R]
         por lo tanto, estableceremos L como i y comenzaremos a emparejar desde str [R] en adelante y
         obtener un nuevo R, entonces actualizaremos el intervalo [L, R] y calcularemos Z [i] (= R-L + 1).
El algoritmo se ejecuta en tiempo lineal porque nunca comparamos caracteres menores que R y con la coincidencia aumentamos R en uno para que haya como máximo comparaciones T. En el caso de desajuste, el desajuste ocurre solo una vez para cada i (debido a que R se detiene), esa es otra comparación como máximo de T que genera complejidad lineal general.
</texto>
  <complejidad_tiempo>null</complejidad_tiempo>
  <java>// Un programa Java que implementa el algoritmo Z para la búsqueda de patrones

public class Zalgorithm {

    // imprime todas las apariciones del patrón en el texto usando algo Z
    public static void search(String text, String pattern) {
        // Crear cadena concatenada &quot;P $ T&quot;
        String concat = pattern + &quot;$&quot; + text;
        int l = concat.length();

        int Z[] = new int[l];
        // Construir matriz Z
        getZarr(concat, Z);

        // ahora recorriendo la matriz Z para la condición coincidente
        for (int i = 0; i &lt; l; ++i) {
            // si Z [i] (región coincidente) es igual al patrón
            // longitud tenemos el patrón
            if (Z[i] == pattern.length()) {
                System.out.println(&quot;Pattern found at index &quot;
                        + (i - pattern.length() - 1));
            }
        }
    }

    // Rellena la matriz Z para una cadena determinada str [] 
    private static void getZarr(String str, int[] Z) {

        int n = str.length();

        // [L, R] crea una ventana que coincida con el prefijo de s
        int L = 0, R = 0;

        for (int i = 1; i &lt; n; ++i) {
            // si i&gt; R nada coincide, entonces calcularemos. Z [i] de manera ingenua.
            if (i &gt; R) {
                L = R = i;
                // R-L = 0 en el inicio, por lo que comenzará a verificar desde 
                // el índice 0. Por ejemplo, para &quot;ababab&quot; ei = 1, el valor de 
                // R sigue siendo 0 y Z [i] se convierte en 0. 
                // Para la cadena &quot;aaaaaa&quot; e i = 1, Z [i] y R se convierten en 5
                while (R &lt; n &amp;&amp; str.charAt(R - L) == str.charAt(R)) {
                    R++;
                }

                Z[i] = R - L;
                R--;

            } else {

                // k = i-L entonces k corresponde al número que coincide en el intervalo [L, R].
                int k = i - L;
                // si Z [k] es menor que el intervalo restante, entonces Z [i] 
                // será igual a Z [k]. Por ejemplo, str = &quot;ababab&quot;, 
                // i = 3, R = 5 y L = 2
                if (Z[k] &lt; R - i + 1) {
                    Z[i] = Z[k];
                } // Por ejemplo, str = &quot;aaaaaa&quot; e i = 2, R es 5,
                // L es 0 
                else {
                    // de lo contrario, comience desde R y verifique manualmente
                    L = i;
                    while (R &lt; n &amp;&amp; str.charAt(R - L) == str.charAt(R)) {
                        R++;
                    }

                    Z[i] = R - L;
                    R--;
                }
            }
        }
    }

    public static void main(String[] args) {
        String text = &quot;GEEKS FOR GEEKS&quot;;
        String pattern = &quot;GEEK&quot;;
        search(text, pattern);
    }
}
</java>
  <cpp>#include&lt;iostream&gt; 
using namespace std;

void getZarr(string str, int Z[]);

void search(string text, string pattern) {
    string concat = pattern + &quot;$&quot; + text;
    int l = concat.length();

    int Z[l];
    getZarr(concat, Z);

    for (int i = 0; i &lt; l; ++i) {
        if (Z[i] == pattern.length())
            cout &lt;&lt; &quot;Pattern found at index &quot;
                &lt;&lt; i - pattern.length() - 1 &lt;&lt; endl;
    }
}

void getZarr(string str, int Z[]) {
    int n = str.length();
    int L, R, k;
    L = R = 0;
    for (int i = 1; i &lt; n; ++i) {

        if (i &gt; R) {
            L = R = i;
            while (R &lt; n &amp;&amp; str[R - L] == str[R])
                R++;
            Z[i] = R - L;
            R--;
        } else {
            k = i - L;
            if (Z[k] &lt; R - i + 1)
                Z[i] = Z[k];
            else {
                L = i;
                while (R &lt; n &amp;&amp; str[R - L] == str[R])
                    R++;
                Z[i] = R - L;
                R--;
            }
        }
    }
}

int main() {
    string text = &quot;GEEKS FOR GEEKS&quot;;
    string pattern = &quot;GEEK&quot;;
    search(text, pattern);
    return 0;
}
</cpp>
  <py>def getZarr(string, z): 
    n = len(string) 
    l, r, k = 0, 0, 0
    for i in range(1, n): 
        if i &gt; r: 
            l, r = i, i 
            while r &lt; n and string[r - l] == string[r]: 
                r += 1
            z[i] = r - l 
            r -= 1
        else: 

            k = i - l 
            if z[k] &lt; r - i + 1: 
                z[i] = z[k] 
            else: 
                l = i 
                while r &lt; n and string[r - l] == string[r]: 
                    r += 1
                z[i] = r - l 
                r -= 1

def search(text, pattern): 
    concat = pattern + &quot;$&quot; + text 
    l = len(concat) 
    z = [0] * l 
    getZarr(concat, z) 
    for i in range(l): 
        if z[i] == len(pattern): 
            print(&quot;Pattern found at index&quot;, 
                  i - len(pattern) - 1) 

text = &quot;GEEKS FOR GEEKS&quot;
pattern = &quot;GEEK&quot;
search(text, pattern) 
</py>
  <orden>5</orden>
  <suborden>6</suborden>
  <fecha_creacion>2020-12-06 19:51:39</fecha_creacion>
  <fecha_modificacion>2022-03-08 12:17:06</fecha_modificacion>
</row>
<row>
  <ID>210</ID>
  <supergrupo>Strings</supergrupo>
  <tema>Supersecuencia común más corta</tema>
  <texto>Dadas dos cadenas str1 y str2, la tarea es encontrar la longitud de la cadena más corta que tiene str1 y str2 como subsecuencias.
Ejemplos:
Entrada: str1 = &quot;geek&quot;, str2 = &quot;eke&quot;
Salida: 5
Explicación:
La cadena &quot;geeke&quot; tiene ambas cadenas &quot;geek&quot;
y &quot;eke&quot; como subsecuencias.

Entrada: str1 = &quot;AGGTAB&quot;, str2 = &quot;GXTXAYB&quot;
Salida: 9
Explicación:
La cadena &quot;AGXGTXAYB&quot; tiene ambas cadenas
&quot;AGGTAB&quot; y &quot;GXTXAYB&quot; como subsecuencias.
Este problema está estrechamente relacionado con el problema de subsecuencia común más largo. A continuación se muestran los pasos.
1) Encuentre la subsecuencia común más larga (lcs) de dos cadenas dadas. Por ejemplo, lcs de &quot;geek&quot; y &quot;eke&quot; es &quot;ek&quot;.
2) Inserte caracteres que no sean lcs (en su orden original en cadenas) en los lcs que se encuentran arriba y devuelva el resultado. Entonces &quot;ek&quot; se convierte en &quot;geeke&quot;, que es la supersecuencia común más corta.
Consideremos otro ejemplo, str1 = &quot;AGGTAB&quot; y str2 = &quot;GXTXAYB&quot;. LCS de str1 y str2 es &quot;GTAB&quot;. Una vez que encontramos LCS, insertamos caracteres de ambas cadenas en orden y obtenemos &quot;AGXGTXAYB&quot;

¿Como funciona esto?
Necesitamos encontrar una cadena que tenga ambas cadenas como subsecuencias y que sea la más corta. Si ambas cadenas tienen todos los caracteres diferentes, el resultado es la suma de longitudes de dos cadenas dadas. Si hay caracteres comunes, no los queremos varias veces, ya que la tarea es minimizar la longitud. Por lo tanto, primero encontramos la subsecuencia común más larga, tomamos una aparición de esta subsecuencia y agregamos caracteres adicionales.
Duración de la supersecuencia más corta
= (Suma de longitudes de dos cadenas dadas)
- (Longitud de LCS de dos cadenas dadas)

Complejidad temporal de la solución anterior exponencial O (2min (m, n)). Dado que hay subproblemas superpuestos, podemos resolver este problema recursivo de manera eficiente utilizando la programación dinámica. A continuación se muestra la implementación basada en programación dinámica. La complejidad temporal de esta solución es O (mn).
</texto>
  <complejidad_tiempo>null</complejidad_tiempo>
  <java>// Un programa Java basado en programación dinámica para encontrar 
// la longitud de la supersecuencia más corta

public class ShortestCommonSupersequence {

    // Devuelve la longitud de la supersecuencia más corta de X e Y
    static int superSeq(String X, String Y,
            int m, int n) {
        int[][] dp = new int[m + 1][n + 1];

        // Llene la tabla de abajo hacia arriba
        for (int i = 0; i &lt;= m; i++) {
            for (int j = 0; j &lt;= n; j++) {
                // Los pasos siguientes siguen la recurrencia anterior
                if (i == 0) {
                    dp[i][j] = j;
                } else if (j == 0) {
                    dp[i][j] = i;
                } else if (X.charAt(i - 1) == Y.charAt(j - 1)) {
                    dp[i][j] = 1 + dp[i - 1][j - 1];
                } else {
                    dp[i][j] = 1 + Math.min(dp[i - 1][j],
                            dp[i][j - 1]);
                }
            }
        }

        return dp[m][n];
    }

    public static void main(String args[]) {
        String X = &quot;AGGTAB&quot;;
        String Y = &quot;GXTXAYB&quot;;
        System.out.println(&quot;Length of the shortest supersequence is &quot;
                + superSeq(X, Y, X.length(), Y.length()));
    }
}
</java>
  <cpp>#include&lt;bits/stdc++.h&gt; 
using namespace std;

int superSeq(char* X, char* Y, int m, int n) {
    int dp[m + 1][n + 1];
    for (int i = 0; i &lt;= m; i++) {
        for (int j = 0; j &lt;= n; j++) {
            if (!i)
                dp[i][j] = j;
            else if (!j)
                dp[i][j] = i;
            else if (X[i - 1] == Y[j - 1])
                dp[i][j] = 1 + dp[i - 1][j - 1];
            else
                dp[i][j] = 1 + min(dp[i - 1][j],
                    dp[i][j - 1]);
        }
    }

    return dp[m][n];
}

int main() {
    char X[] = &quot;AGGTAB&quot;;
    char Y[] = &quot;GXTXAYB&quot;;
    cout &lt;&lt; &quot;Length of the shortest supersequence is &quot;
            &lt;&lt; superSeq(X, Y, strlen(X), strlen(Y));
    return 0;
}
</cpp>
  <py>def superSeq(X, Y, m, n): 
    dp = [[0] * (n + 2) for i in range(m + 2)] 
    for i in range(m + 1): 
        for j in range(n + 1): 
            if (not i): dp[i][j] = j 
            elif (not j): dp[i][j] = i 
                        
            elif (X[i - 1] == Y[j - 1]): 
                dp[i][j] = 1 + dp[i - 1][j - 1] 
                                
            else: dp[i][j] = 1 + min(dp[i - 1][j], 
                                     dp[i][j - 1])              
    return dp[m][n] 

X = &quot;AGGTAB&quot;
Y = &quot;GXTXAYB&quot;
print(&quot;Length of the shortest supersequence is %d&quot;
      % superSeq(X, Y, len(X), len(Y))) 
</py>
  <orden>5</orden>
  <suborden>7</suborden>
  <fecha_creacion>2020-12-06 19:51:39</fecha_creacion>
  <fecha_modificacion>2022-03-08 12:17:06</fecha_modificacion>
</row>
<row>
  <ID>211</ID>
  <supergrupo>Strings</supergrupo>
  <tema>Trie</tema>
  <texto>Trie es una estructura de datos de recuperación de información eficiente. Con Trie, las complejidades de la búsqueda se pueden llevar al límite óptimo (longitud de la clave). Si almacenamos claves en un árbol de búsqueda binario, un BST bien balanceado necesitará un tiempo proporcional a M * log N, donde M es la longitud máxima de la cadena y N es el número de claves en el árbol. Usando Trie, podemos buscar la clave en tiempo O (M). Sin embargo, la penalización está en los requisitos de almacenamiento de Trie.
 
Cada nodo de Trie consta de múltiples ramas. Cada rama representa un posible carácter de claves. Necesitamos marcar el último nodo de cada clave como nodo de fin de palabra. Un campo de nodo Trie isEndOfWord se utiliza para distinguir el nodo como nodo de fin de palabra. Una estructura simple para representar nodos del alfabeto inglés puede ser la siguiente:

// Trie nodo
estructura TrieNode
{
     struct TrieNode * children [ALPHABET_SIZE];
     // isEndOfWord es verdadero si el nodo
     // representa el final de una palabra
     bool isEndOfWord;
};
Insertar una llave en Trie es un enfoque simple. Cada carácter de la clave de entrada se inserta como un nodo Trie individual. Tenga en cuenta que los niños son una matriz de punteros (o referencias) a los nodos de prueba del siguiente nivel. El carácter clave actúa como un índice en los hijos de la matriz. Si la clave de entrada es nueva o una extensión de la clave existente, necesitamos construir nodos no existentes de la clave y marcar el final de la palabra para el último nodo. Si la clave de entrada es un prefijo de la clave existente en Trie, simplemente marcamos el último nodo de la clave como el final de una palabra. La longitud de la clave determina la profundidad de Trie.

La búsqueda de una clave es similar a la operación de inserción, sin embargo, solo comparamos los caracteres y nos movemos hacia abajo. La búsqueda puede terminar debido al final de una cadena o la falta de clave en el trie. En el primer caso, si el campo isEndofWord del último nodo es verdadero, entonces la clave existe en el trie. En el segundo caso, la búsqueda termina sin examinar todos los caracteres de la clave, ya que la clave no está presente en el trie.
La siguiente imagen explica la construcción de trie utilizando las claves que se dan en el ejemplo siguiente,
                       raíz
                    / \ \
                    t a b
                    | | |
                    h n y
                    | | \ |
                    e s y e
                 / | |
                 yo r w
                 | | |
                 r e e
                        |
                        r
En la imagen, cada carácter es de tipo trie_node_t. Por ejemplo, la raíz es de tipo trie_node_t, y sus hijos a, byt están llenos, todos los demás nodos de la raíz serán NULL. De manera similar, &quot;a&quot; en el siguiente nivel es tener un solo hijo (&quot;n&quot;), todos los demás hijos son NULL. Los nodos de las hojas están en azul.
Insertar y buscar cuesta O (key_length), sin embargo, los requisitos de memoria de Trie es O (ALPHABET_SIZE * key_length * N) donde N es el número de claves en Trie. Hay una representación eficiente de los nodos trie (por ejemplo, trie comprimido, árbol de búsqueda ternario, etc.) para minimizar los requisitos de memoria de trie.

Tries es un árbol que almacena cuerdas. El número máximo de hijos de un nodo es igual al tamaño del alfabeto. Trie admite operaciones de búsqueda, inserción y eliminación en tiempo O (L) donde L es la longitud de la clave.
Hashing: - En hash, convertimos la clave a un valor pequeño y el valor se usa para indexar datos. El hash admite operaciones de búsqueda, inserción y eliminación en tiempo O (L) en promedio.
BST autoequilibrado: la complejidad temporal de las operaciones de búsqueda, inserción y eliminación en un árbol de búsqueda binaria (BST) autoequilibrado (como árbol rojo-negro, árbol AVL, árbol de expansión, etc.) es O (L + Log n) donde n es el número total de palabras y L es la longitud de la palabra. La ventaja de los BST autoequilibrantes es que mantienen el orden, lo que hace que las operaciones como mínimo, máximo, más cercano (piso o techo) y k-ésimo sean más rápidas.

¿Por qué Trie? : -
1. Con Trie, podemos insertar y encontrar cadenas en tiempo O (L) donde L representa la longitud de una sola palabra. Obviamente, esto es más rápido que BST. Esto también es más rápido que Hashing debido a la forma en que se implementa. No necesitamos calcular ninguna función hash. No se requiere manejo de colisiones (como lo hacemos en direccionamiento abierto y encadenamiento separado)
2. Otra ventaja de Trie es que podemos imprimir fácilmente todas las palabras en orden alfabético, lo que no es posible con hash.
3. Podemos realizar búsquedas de prefijos (o autocompletar) de manera eficiente con Trie.

Problemas con Trie: 
La principal desventaja de los intentos es que necesitan mucha memoria para almacenar las cadenas. Para cada nodo tenemos demasiados punteros de nodo (igual al número de caracteres del alfabeto), si se trata de espacio, entonces el Árbol de búsqueda ternario puede ser preferido para implementaciones de diccionario. En Ternary Search Tree, la complejidad temporal de la operación de búsqueda es O (h) donde h es la altura del árbol. Ternary Search Trees también admite otras operaciones compatibles con Trie, como la búsqueda de prefijos, la impresión en orden alfabético y la búsqueda de vecinos más cercanos.
La conclusión final con respecto a la estructura de datos de los intentos es que son más rápidos pero requieren una gran memoria para almacenar las cadenas.
</texto>
  <complejidad_tiempo>null</complejidad_tiempo>
  <java>// Implementación Java de operaciones de búsqueda e inserción en Trie 

public class Trie {

    // Tamaño del alfabeto (número de símbolos)
    static final int ALPHABET_SIZE = 26;

    // nodo trie
    static class TrieNode {

        TrieNode[] children = new TrieNode[ALPHABET_SIZE];

        // isEndOfWord es verdadero si el nodo representa el final de una palabra
        boolean isEndOfWord;

        TrieNode() {
            isEndOfWord = false;
            for (int i = 0; i &lt; ALPHABET_SIZE; i++) {
                children[i] = null;
            }
        }
    };

    static TrieNode root;

    // Si no está presente, inserta la clave en trie 
    // Si la clave es el prefijo del nodo trie, solo marca el nodo hoja
    static void insert(String key) {
        int level;
        int length = key.length();
        int index;

        TrieNode pCrawl = root;

        for (level = 0; level &lt; length; level++) {
            index = key.charAt(level) - &#39;a&#39;;
            if (pCrawl.children[index] == null) {
                pCrawl.children[index] = new TrieNode();
            }

            pCrawl = pCrawl.children[index];
        }

        // marcar el último nodo como hoja
        pCrawl.isEndOfWord = true;
    }

    // // Devuelve verdadero si la clave está presente en verdadero, de lo contrario es falso
    static boolean search(String key) {
        int level;
        int length = key.length();
        int index;
        TrieNode pCrawl = root;

        for (level = 0; level &lt; length; level++) {
            index = key.charAt(level) - &#39;a&#39;;

            if (pCrawl.children[index] == null) {
                return false;
            }

            pCrawl = pCrawl.children[index];
        }

        return (pCrawl != null &amp;&amp; pCrawl.isEndOfWord);
    }

    public static void main(String args[]) {
        // Datos de entrada (use solo &#39;a&#39; a &#39;z&#39; y minúsculas)
        String keys[] = {&quot;the&quot;, &quot;a&quot;, &quot;there&quot;, &quot;answer&quot;, &quot;any&quot;,
            &quot;by&quot;, &quot;bye&quot;, &quot;their&quot;};

        String output[] = {&quot;Not present in trie&quot;, &quot;Present in trie&quot;};

        root = new TrieNode();

        // Construir trie
        int i;
        for (i = 0; i &lt; keys.length; i++) {
            insert(keys[i]);
        }

        // Buscar diferentes claves 
        if (search(&quot;the&quot;) == true) {
            System.out.println(&quot;the --- &quot; + output[1]);
        } else {
            System.out.println(&quot;the --- &quot; + output[0]);
        }

        if (search(&quot;these&quot;) == true) {
            System.out.println(&quot;these --- &quot; + output[1]);
        } else {
            System.out.println(&quot;these --- &quot; + output[0]);
        }

        if (search(&quot;their&quot;) == true) {
            System.out.println(&quot;their --- &quot; + output[1]);
        } else {
            System.out.println(&quot;their --- &quot; + output[0]);
        }

        if (search(&quot;thaw&quot;) == true) {
            System.out.println(&quot;thaw --- &quot; + output[1]);
        } else {
            System.out.println(&quot;thaw --- &quot; + output[0]);
        }

    }
}
</java>
  <cpp>#include &lt;iostream&gt; 
#include &lt;memory&gt; 

using namespace std;
#define ALPHABET_SIZE 26 

class TrieNode { 
public:
    shared_ptr&lt;TrieNode&gt; children[ALPHABET_SIZE];

    bool isWord;

    TrieNode() {
        for (int i = 0; i &lt; ALPHABET_SIZE; i++) {
            children[i] = shared_ptr&lt;TrieNode&gt;();
        }
        isWord = false;
    }
};




class Trie  {     
    shared_ptr&lt;TrieNode&gt; root;
    int Total_words;

public:
    Trie() {
        root = shared_ptr&lt;TrieNode&gt;
                (new TrieNode());
        Total_words = 0;
    }

    ~Trie() {
    }

    int i2c(char c) {
        return static_cast&lt;int&gt; (c - &#39;a&#39;);
    }

    void insertWord(string&amp; trieString) {
        shared_ptr&lt;TrieNode&gt; current = root;
        for (int i = 0; i &lt; trieString.size(); i++) {

            if (current-&gt;children[i2c(trieString[i])] ==
                    shared_ptr&lt;TrieNode&gt;(nullptr)) {
                current-&gt;children[i2c(trieString[i])] =
                        shared_ptr&lt;TrieNode&gt;(new TrieNode());
            }
            current = (current-&gt;children[i2c(trieString[i])]);
        } 
        current-&gt;isWord = true;
    }


    bool searchWord(string&amp; trieString) {
        shared_ptr&lt;TrieNode&gt; current = root;

        for (int i = 0; i &lt; trieString.size(); i++) {

            if (current-&gt;children[i2c(trieString[i])] ==
                    shared_ptr&lt;TrieNode&gt;(nullptr))
                return false;
            current = current-&gt;children[i2c(trieString[i])];
        }

        if (current-&gt;isWord == true)
            return true;

        return false;
    }

    bool Partdelete(string&amp; trieString, shared_ptr&lt;TrieNode&gt;&amp;
            checkout) {

        if (checkout == nullptr)
            return false;

        if (trieString.size() == 0) {
            if (checkout-&gt;isWord == true) {
                checkout-&gt;isWord = false;
                return true;
            }
            return false;
        }

        string part = trieString.substr(1);

        if (Partdelete(part, checkout-&gt;
                children[i2c(trieString[0])])) {

            if (isEmptyNode(checkout-&gt;
                    children[i2c(trieString[0])])) {
                checkout-&gt;children[i2c(trieString[0])].
                        reset();

                checkout-&gt;children[i2c(trieString[0])] =
                        nullptr;

                return true;
            }
            else
                return true;
        }
        else
            return false;

        return false;
    }


    bool deleteWord(string&amp; trieString) {
        if (Partdelete(trieString, root))
            return true;
        return false;
    }

    bool isEmptyNode(shared_ptr&lt;TrieNode&gt; check) const {
        for (int i = 0; i &lt; ALPHABET_SIZE; i++) {
            if (check-&gt;children[i] != nullptr ||
                    check-&gt;isWord == true)
                return false;
        }
        return true;
    }
};


int main() {
    shared_ptr&lt;Trie&gt; myTrie(new Trie());

    string word1 = &quot;geeksfor&quot;;
    string word2 = &quot;geeksforgeeks&quot;;
    string word3 = &quot;nothing&quot;;

    myTrie-&gt;insertWord(word1);

    if (myTrie-&gt;searchWord(word1))
        cout &lt;&lt; word1 &lt;&lt; &quot;: Is Present&quot; &lt;&lt; endl;
    else
        cout &lt;&lt; word1 &lt;&lt; &quot;: Not Present&quot; &lt;&lt; endl;

    if (myTrie-&gt;searchWord(word3))
        cout &lt;&lt; word3 &lt;&lt; &quot;: Is Present&quot; &lt;&lt; endl;
    else
        cout &lt;&lt; word3 &lt;&lt; &quot;: Not Present&quot; &lt;&lt; endl;

    myTrie-&gt;insertWord(word2);

    if (myTrie-&gt;deleteWord(word2))
        cout &lt;&lt; word2 &lt;&lt; &quot;: Successfully deleted&quot; &lt;&lt; endl;
    else
        cout &lt;&lt; word2 &lt;&lt; &quot;: Not Present&quot; &lt;&lt; endl;

    if (myTrie-&gt;searchWord(word2))
        cout &lt;&lt; word2 &lt;&lt; &quot;: Is Present&quot; &lt;&lt; endl;
    else
        cout &lt;&lt; word2 &lt;&lt; &quot;: Not Present&quot; &lt;&lt; endl;

}
</cpp>
  <py>class TrieNode: 
    def __init__(self): 
        self.children = [None] * 26

        self.isEndOfWord = False

class Trie: 
    def __init__(self): 
        self.root = self.getNode() 

    def getNode(self): 
        return TrieNode() 

    def _charToIndex(self, ch): 
        return ord(ch)-ord(&#39;a&#39;) 


    def insert(self, key): 
                
        pCrawl = self.root 
        length = len(key) 
        for level in range(length): 
            index = self._charToIndex(key[level]) 

            if not pCrawl.children[index]: 
                pCrawl.children[index] = self.getNode() 
            pCrawl = pCrawl.children[index] 

        pCrawl.isEndOfWord = True

    def search(self, key): 
                 
        pCrawl = self.root 
        length = len(key) 
        for level in range(length): 
            index = self._charToIndex(key[level]) 
            if not pCrawl.children[index]: 
                return False
            pCrawl = pCrawl.children[index] 

        return pCrawl != None and pCrawl.isEndOfWord 

def main(): 

    keys = [&quot;the&quot;, &quot;a&quot;, &quot;there&quot;, &quot;anaswe&quot;, &quot;any&quot;, 
        &quot;by&quot;, &quot;their&quot;] 
    output = [&quot;Not present in trie&quot;, 
        &quot;Present in trie&quot;] 
    t = Trie() 
    for key in keys: 
        t.insert(key) 
    print(&quot;{} ---- {}&quot;.format(&quot;the&quot;, output[t.search(&quot;the&quot;)])) 
    print(&quot;{} ---- {}&quot;.format(&quot;these&quot;, output[t.search(&quot;these&quot;)])) 
    print(&quot;{} ---- {}&quot;.format(&quot;their&quot;, output[t.search(&quot;their&quot;)])) 
    print(&quot;{} ---- {}&quot;.format(&quot;thaw&quot;, output[t.search(&quot;thaw&quot;)])) 

main() 
</py>
  <orden>5</orden>
  <suborden>8</suborden>
  <fecha_creacion>2020-12-06 19:51:39</fecha_creacion>
  <fecha_modificacion>2022-03-08 12:17:06</fecha_modificacion>
</row>
<row>
  <ID>212</ID>
  <supergrupo>Strings</supergrupo>
  <tema>Hash polinómico</tema>
  <texto>¿Qué es String-Hashing?
El hash de cadena es la forma de convertir una cadena en un número entero conocido como hash de esa cadena.
Un hash ideal es aquel en el que existen mínimas posibilidades de colisión (es decir, 2 cadenas diferentes que tienen el mismo hash).
Función hash polinomial rodante
En esta técnica de hash, el hash de una cadena se calcula como: 
Donde P y M son algunos números positivos. Y s [0], s [1], s [2]… s [n-1] son los valores asignados a cada carácter en el alfabeto inglés (a-&gt; 1, b-&gt; 2,… z-&gt; 26).
Valores apropiados para P y M

• P: el valor de P puede ser cualquier número primo aproximadamente igual al número de caracteres diferentes utilizados.
Por ejemplo: si la cadena de entrada contiene solo letras minúsculas del alfabeto inglés, entonces P = 31 es el valor apropiado de P.
Si la cadena de entrada contiene letras mayúsculas y minúsculas, entonces P = 53 es una opción adecuada.
• M: la probabilidad de que dos cadenas aleatorias choquen es inversamente proporcional am. Por lo tanto, m debería ser un número primo grande.
M = 10 ^ 9 + 9 es una buena opción.
</texto>
  <complejidad_tiempo>null</complejidad_tiempo>
  <java>// Implementación de Java de la función Polynomial Rolling Hash

public class PolynomialRollingHash {

    // Función para calcular el hash de un String
    static long polynomialRollingHash(String str) {

        // P y M
        int p = 31;
        int m = (int) (1e9 + 9);
        long power_of_p = 1;
        long hash_val = 0;
        // Bucle para calcular el valor hash 
        // iterando sobre los elementos de String
        for (int i = 0; i &lt; str.length(); i++) {
            hash_val = (hash_val + (str.charAt(i)
                    - &#39;a&#39; + 1) * power_of_p) % m;
            power_of_p = (power_of_p * p) % m;
        }
        return hash_val;
    }

    public static void main(String[] args) {
        String str1 = &quot;holaholaholo&quot;;
        System.out.print(&quot;Hash of &#39;&quot; + str1 + &quot;&#39; = &quot;
                + polynomialRollingHash(str1));
    }
}
</java>
  <cpp>#include &lt;bits/stdc++.h&gt;
using namespace std;

long long polynomialRollingHash(string const&amp; str) {
    int p = 31;
    int m = 1e9 + 9;
    long long power_of_p = 1;
    long long hash_val = 0;
    for (int i = 0; i &lt; str.length(); i++) {
        hash_val
                = (hash_val
                + (str[i] - &#39;a&#39; + 1) * power_of_p)
                % m;
        power_of_p
                = (power_of_p * p) % m;
    }
    return hash_val;
}

int main() {
    string str1 = &quot;geeksforgeeks&quot;;
    string str2 = &quot;geeks&quot;;

    cout &lt;&lt; &quot;Hash of &#39;&quot; &lt;&lt; str1 &lt;&lt; &quot;&#39; = &quot;
            &lt;&lt; polynomialRollingHash(str1);
    cout &lt;&lt; endl;
}
</cpp>
  <py>def polynomialRollingHash(str):
        
    # P and M
    p = 31
    m = 1e9 + 9
    power_of_p = 1
    hash_val = 0
    for i in range(len(str)):
        hash_val = ((hash_val + (ord(str[i]) -
                    ord(&#39;a&#39;) + 1) *
                    power_of_p) % m)

        power_of_p = (power_of_p * p) % m

    return int(hash_val)

str1 = &quot;geeksforgeeks&quot;

print(&quot;Hash of &#39;{}&#39; = {}&quot;.format(
      str1, polynomialRollingHash(str1)))
</py>
  <orden>5</orden>
  <suborden>9</suborden>
  <fecha_creacion>2020-12-06 19:51:40</fecha_creacion>
  <fecha_modificacion>2022-03-08 12:17:06</fecha_modificacion>
</row>
<row>
  <ID>213</ID>
  <supergrupo>Strings</supergrupo>
  <tema>El más pequeño lexicográficamente</tema>
  <texto>Escriba código para encontrar el mínimo lexicográfico en una matriz circular, p. Ej. para la matriz BCABDADAB, el mínimo lexicográfico es ABBCABDAD
Restricción de entrada: 1 &lt;n &lt;1000
Ejemplos:
Entrada: GEEKSQUIZ
Salida: EEKSQUIZG

Entrada: GFG
Salida: FGG

Entrada: CAPABCQ
Salida: ABCQCAP
Aquí necesitamos encontrar el índice inicial de rotación mínima y luego imprimir la rotación.

1) Asuma inicialmente que 0 es el mínimo actual
    índice inicial.
2) Haz un bucle a través de i = 1 hasta n-1.
    a) Para cada comienzo de secuencia de comparación
       en i con el índice inicial mínimo actual
    b) Si la secuencia que comienza en i es lexicográficamente
       más pequeño, actualizar el mínimo actual comenzando
       índice.
Complejidad del tiempo: O (n ^ 2)
Espacio auxiliar: O (1)
</texto>
  <complejidad_tiempo>null</complejidad_tiempo>
  <java>// Programa Java para encontrar la secuencia lexicográficamente más pequeña con rotaciones.

public class LexoSmallest {
    // Función para comparar lexicográficamente dos secuencias con diferentes 
    // índices de inicio. Devuelve verdadero si la secuencia que comienza 
    // con y es lexicográficamente mayor.

    static boolean compareSeq(char[] S, int x, int y, int n) {
        for (int i = 0; i &lt; n; i++) {
            if (S[x] &lt; S[y]) {
                return false;
            } else if (S[x] &gt; S[y]) {
                return true;
            }
            x = (x + 1) % n;
            y = (y + 1) % n;
        }
        return true;
    }

    // Función para encontrar el índice inicial de la secuencia 
    // lexicográficamente más pequeña
    static int smallestSequence(char[] S, int n) {
        int index = 0;
        for (int i = 1; i &lt; n; i++) // si la nueva secuencia es más pequeña
        {
            if (compareSeq(S, index, i, n)) // cambiar el índice del mínimo actual
            {
                index = i;
            }
        }

        return index;
    }

    // Función para imprimir la secuencia lexicográficamente más pequeña 
    static void printSmallestSequence(String str, int n) {
        char[] S = str.toCharArray();
        int starting_index = smallestSequence(S, n);
        for (int i = 0; i &lt; n; i++) {
            System.out.print(S[(starting_index + i) % n]);
        }
    }

    public static void main(String[] args) {
        String S = &quot;DCACBCAA&quot;;
        int n = 8;
        printSmallestSequence(S, n);
    }
}
</java>
  <cpp>#include &lt;cstdlib&gt;
#include &lt;bits/stdc++.h&gt; 
using namespace std;

bool compareSeq(char S[], int x, int y, int n) {
    for (int i = 0; i &lt; n; i++) {
        if (S[x] &lt; S[y]) {
            return false;
        } else if (S[x] &gt; S[y]) {
            return true;
        }
        x = (x + 1) % n;
        y = (y + 1) % n;
    }
    return true;
}

int smallestSequence(char S[], int n) {
    int index = 0;
    for (int i = 1; i &lt; n; i++) {
        if (compareSeq(S, index, i, n)) {
            index = i;
        }
    }
    return index;
}

void printSmallestSequence(string str, int n) {
    char S[str.size() + 1];
    strcpy(S, str.c_str());
    int starting_index = smallestSequence(S, n);
    for (int i = 0; i &lt; n; i++) {
        cout &lt;&lt; S[(starting_index + i) % n];
    }
}

int main() {
    string S = &quot;DCACBCAA&quot;;
    int n = 8;
    printSmallestSequence(S, n);
}
</cpp>
  <py>def compareSeq(S, x, y, n):
    for i in range (n):
        if (S[x] &lt; S[y]):
            return False
        elif (S[x] &gt; S[y]):
            return True
        x = (x + 1) % n
        y = (y + 1) % n
    return True


def smallestSequence(S, n):
    index = 0
    for i in range (n):
        if (compareSeq(S, index, i, n)):
            index = i
    return index


def printSmallestSequence(str, n):
    starting_index = smallestSequence(S, n);
    for i in range (n):
        print(str[(starting_index + i) % n])
    
S = &quot;DCACBCAA&quot;
n = 8
printSmallestSequence(S, n);
</py>
  <orden>5</orden>
  <suborden>10</suborden>
  <fecha_creacion>2020-12-06 19:51:40</fecha_creacion>
  <fecha_modificacion>2022-03-08 12:17:06</fecha_modificacion>
</row>
<row>
  <ID>214</ID>
  <supergrupo>Strings</supergrupo>
  <tema>Convirtiendo una cadena dadas restricciones</tema>
  <texto>Dadas dos cadenas contiene tres caracteres, es decir, &quot;A&quot;, &quot;B&quot; y &quot;#&quot; únicamente. Compruebe si es posible convertir la primera cadena en otra cadena realizando las siguientes operaciones en la cadena primero.
1- &quot;A&quot; solo puede moverse hacia la izquierda
2- &quot;B&quot; solo puede moverse hacia la derecha
3- Ni &#39;A&#39; ni &#39;B&#39; se cruzan
Si es posible, imprima &quot;Sí&quot;; de lo contrario, &quot;No&quot;.

Ejemplos:
Entrada: str1 = ”# A # B # B #“, str2 = ”A ### B # B”
Salida: si
Explicacion:
&#39;A&#39; en str1 está a la derecha de la &#39;A&#39; en str2 por lo que &#39;A&#39; de str1 puede moverse fácilmente hacia la izquierda porque no hay &#39;B&#39; en sus posiciones izquierdas y para la primera &#39;B&#39; en str1 se deja a la &#39; B &#39;en str2 para que&#39; B &#39;de str2 pueda moverse fácilmente hacia la derecha porque no hay&#39; A &#39;en sus posiciones correctas y es lo mismo para la siguiente&#39; B &#39;, por lo que str1 se puede convertir fácilmente en str2.
Entrada: str1 = &quot;# A # B #&quot;, str2 = &quot;# B # A #&quot;
Salida: No
Explicacion:
Aquí, la primera &quot;A&quot; en str1 se deja a la &quot;A&quot; en str2 y, según la condición, &quot;A&quot; no puede moverse hacia la derecha. entonces str1 no se puede convertir en str2.
Método:
1-La longitud de ambas cuerdas debe ser la misma
2-No. de A y B en ambas cadenas deben ser iguales
3-El orden de A y B en ambas cadenas debe ser el mismo (por ejemplo: si &quot;A&quot; viene antes de &quot;B&quot; en la cadena en segundo lugar, la misma secuencia debe seguirse primero en la cadena)
</texto>
  <complejidad_tiempo>null</complejidad_tiempo>
  <java>public class ConvertStringIntoAnotherGivenConstraints {

    //Función para comprobar si es posible 
    //convertir la primera cadena en otra cadena o no.
    static boolean isItPossible(char[] str1, char[] str2,
            int m, int n) {
        // Para comprobar que la longitud de ambas cadenas es igual o no
        if (m != n) {
            return false;
        }
        // Para comprobar La frecuencia de A y B es igual en ambas cadenas o no.
        if (count(str1, &#39;A&#39;)
                != count(str2, &#39;A&#39;)
                || count(str1, &#39;B&#39;)
                != count(str2, &#39;B&#39;)) {
            return false;
        }
        // Empieza a atravesar
        for (int i = 0; i &lt; m; i++) {
            if (str1[i] != &#39;#&#39;) {
                for (int j = 0; j &lt; n; j++) {
                    // Comprobar que no se crucen dos elementos.
                    if ((str2[j] != str1[i]) &amp;&amp; str2[j] != &#39;#&#39;) {
                        return false;
                    }
                    if (str2[j] == str1[i]) {
                        str2[j] = &#39;#&#39;;
                        // Para comprobar si es posible moverse 
                        // hacia la izquierda o no.
                        if (str1[i] == &#39;A&#39; &amp;&amp; i &lt; j) {
                            return false;
                        }
                        // Para comprobar si es posible 
                        // moverse hacia la derecha o no.
                        if (str1[i] == &#39;B&#39; &amp;&amp; i &gt; j) {
                            return false;
                        }

                        break;
                    }
                }
            }
        }
        return true;
    }

    private static int count(char[] str1, char c) {
        int count = 0;
        for (char temp : str1) {
            if (c == temp) {
                count++;
            }
        }
        return count;
    }

    public static void main(String[] args) {
        String str1 = &quot;A#B#&quot;;
        String str2 = &quot;A##B&quot;;
        int m = str1.length();
        int n = str2.length();
        System.out.print(isItPossible(str1.toCharArray(), str2.toCharArray(), m, n)
                ? &quot;Yes\n&quot; : &quot;No\n&quot;);
    }
}
</java>
  <cpp>#include &lt;bits/stdc++.h&gt; 
using namespace std;

bool isItPossible(string str1, string str2, int m, int n) {
    if (m != n)
        return false;
    if (count(str1.begin(), str1.end(), &#39;A&#39;) !=
            count(str2.begin(), str2.end(), &#39;A&#39;) ||
            count(str1.begin(), str1.end(), &#39;B&#39;) !=
            count(str2.begin(), str2.end(), &#39;B&#39;))
        return false;
    for (int i = 0; i &lt; m; i++) {
        if (str1[i] != &#39;#&#39;) {
            for (int j = 0; j &lt; n; j++) {
                if ((str2[j] != str1[i]) &amp;&amp; str2[j] != &#39;#&#39;)
                    return false;
                if (str2[j] == str1[i]) {
                    str2[j] = &#39;#&#39;;
                    if (str1[i] == &#39;A&#39; &amp;&amp; i &lt; j)
                        return false;
                    if (str1[i] == &#39;B&#39; &amp;&amp; i &gt; j)
                        return false;
                    break;
                }
            }
        }
    }
    return true;
}

int main() {
    string str1 = &quot;A#B#&quot;;
    string str2 = &quot;A##B&quot;;
    int m = str1.length();
    int n = str2.length();
    isItPossible(str1, str2, m, n) ? cout &lt;&lt; &quot;Yes\n&quot; : cout &lt;&lt; &quot;No\n&quot;;
    return 0;
}
</cpp>
  <py>def isItPossible(str1, str2, m, n): 
    if (m != n): 
        return False
    if str1.count(&#39;A&#39;) != str2.count(&#39;A&#39;) \ or str1.count(&#39;B&#39;) != str2.count(&#39;B&#39;): 
        return False
    for i in range(m): 
        if (str1[i] != &#39;#&#39;): 
            for j in range(n): 
                if ((str2[j] != str1[i]) and str2[j] != &#39;#&#39;): 
                    return False
                if (str2[j] == str1[i]): 
                    str2[j] = &#39;#&#39;
                    if (str1[i] == &#39;A&#39; and i &lt; j): 
                        return False
                    if (str1[i] == &#39;B&#39; and i &gt; j): 
                        return False
                    break
                                
    return True
str1 = &quot;A#B#&quot;
str2 = &quot;A##B&quot;
m = len(str1) 
n = len(str2) 
str1 = list(str1) 
str2 = list(str2) 
if(isItPossible(str1, str2, m, n)): 
    print(&quot;Yes&quot;) 
else: 
    print(&quot;No&quot;) 
</py>
  <orden>5</orden>
  <suborden>11</suborden>
  <fecha_creacion>2020-12-06 19:51:40</fecha_creacion>
  <fecha_modificacion>2022-03-08 12:17:06</fecha_modificacion>
</row>
<row>
  <ID>215</ID>
  <supergrupo>BitWise</supergrupo>
  <tema>Encontrar dos números de sumandos XOR</tema>
  <texto>Dada la suma y xor de dos números X e Y s.t. suma y xor, necesitamos encontrar los números minimizando el valor de X.
Ejemplos:
Entrada: S = 17
        X = 13
Salida: a = 2
         b = 15

Entrada: S = 1870807699
        X = 259801747
Salida: a = 805502976
         b = 1065304723

Entrada: S = 1639
        X = 1176
Resultado: No existen tales números
Variables utilizadas:
X ==&gt; XOR de dos números
S ==&gt; Suma de dos números
X [i] ==&gt; Valor del i-ésimo bit en X
S [i] ==&gt; Valor del i-ésimo bit en S
Una solución simple es generar todos los pares posibles con un XOR dado. Para generar todos los pares, podemos seguir las siguientes reglas.
1. Si X [i] es 1, entonces tanto a [i] como b [i] deberían ser diferentes, tenemos dos casos.
2. Si X [i] es 0, entonces tanto a [i] como b [i] deberían ser iguales. tenemos dos casos.
Entonces generamos 2 ^ n pares posibles donde n es el número de bits en X. Luego, para cada par, verificamos si su suma es S o no.
Una solución eficiente se basa en el siguiente hecho.
S = X + 2 * A
donde A = a Y b
Podemos verificar el hecho anterior usando el proceso de suma. En resumen, siempre que vemos ambos bits 1 (es decir, Y es 1), hacemos el bit resultante 0 y agregamos 1 como acarreo, lo que significa que cada bit en Y se desplaza a la izquierda por 1 O el valor de Y se multiplica por 2 y se suma.
Entonces podemos encontrar A = (S - X) / 2.
Una vez que encontramos A, podemos encontrar todos los bits de &quot;a&quot; y &quot;b&quot; usando las siguientes reglas.
1. Si X [i] = 0 y A [i] = 0, entonces a [i] = b [i] = 0. Sólo una posibilidad para este bit.
2. Si X [i] = 0 y A [i] = 1, entonces a [i] = b [i] = 1. Sólo una posibilidad para este bit.
3. Si X [i] = 1 y A [i] = 0, entonces (a [i] = 1 yb [i] = 0) o (a [i] = 0 y b [i] = 1), podemos elegir cualquiera de los dos.
4. Si X [i] = 1 y A [i] = 1, el resultado no es posible (Nota X [i] = 1 significa bits diferentes)
Sea la sumatoria S y XOR sea X.
</texto>
  <complejidad_tiempo>null</complejidad_tiempo>
  <java>// Java program to find two numbers with  
// given Sum and XOR such that value of  
// first number is minimum.  

public class FindTwoNumbersFromSumandXOR {

// Function that takes in the sum and XOR  
// of two numbers and generates the two  
// numbers such that the value of X is  
// minimized  
    static void compute(long S, long X) {
        long A = (S - X) / 2;
        int a = 0, b = 0;
        final int LONG_FIELD_SIZE = 8;

        // Traverse through all bits  
        for (int i = 0; i &lt; 8 * LONG_FIELD_SIZE; i++) {
            long Xi = (X &amp; (1 &lt;&lt; i));
            long Ai = (A &amp; (1 &lt;&lt; i));
            if (Xi == 0 &amp;&amp; Ai == 0) {
                // Let us leave bits as 0.  
            } else if (Xi == 0 &amp;&amp; Ai &gt; 0) {
                a = ((1 &lt;&lt; i) | a);
                b = ((1 &lt;&lt; i) | b);
            } else if (Xi &gt; 0 &amp;&amp; Ai == 0) {
                a = ((1 &lt;&lt; i) | a);

                // We leave i-th bit of b as 0.  
            } else // (Xi == 1 &amp;&amp; Ai == 1)  
            {
                System.out.println(&quot;Not Possible&quot;);
                return;
            }
        }
        System.out.println(&quot;a = &quot; + a + &quot;\nb = &quot; + b);
    }

// Driver function  
    public static void main(String[] args) {
        long S = 17, X = 13;
        compute(S, X);

    }
}
</java>
  <cpp>#include &lt;bits/stdc++.h&gt; 
#include &lt;cstdlib&gt;
using namespace std;

void compute(long S, long X) {
    long A = (S - X) / 2;
    int a = 0, b = 0;
    const int LONG_FIELD_SIZE = 8;
    for (int i = 0; i &lt; 8 * LONG_FIELD_SIZE; i++) {
        long Xi = (X &amp; (1 &lt;&lt; i));
        long Ai = (A &amp; (1 &lt;&lt; i));
        if (Xi == 0 &amp;&amp; Ai == 0) {
        } else if (Xi == 0 &amp;&amp; Ai &gt; 0) {
            a = ((1 &lt;&lt; i) | a);
            b = ((1 &lt;&lt; i) | b);
        } else if (Xi &gt; 0 &amp;&amp; Ai == 0) {
            a = ((1 &lt;&lt; i) | a);
        } else {
            cout &lt;&lt; &quot;Not Possible&quot; &lt;&lt; endl;
            return;
        }
    }
    cout &lt;&lt; &quot;a = &quot; &lt;&lt; a &lt;&lt; &quot;\nb = &quot; &lt;&lt; b &lt;&lt; endl;
}

int main() {
    long S = 17, X = 13;
    compute(S, X);
}
</cpp>
  <py>def compute(S, X):
    A = (S - X) / 2
    a = 0
    b = 0
    LONG_FIELD_SIZE = 8
    leng = 8 * LONG_FIELD_SIZE
    for i in range (leng):
        Xi = (X &amp; (1 &lt;&lt; i))
        Ai = (A &amp; (1 &lt;&lt; i))
        if (Xi == 0 and Ai == 0):
            c = 0
        elif (Xi == 0 and Ai &gt; 0):
            a = ((1 &lt;&lt; i) | a)
            b = ((1 &lt;&lt; i) | b)
        elif (Xi &gt; 0 and Ai == 0):
            a = ((1 &lt;&lt; i) | a);
        else:
            cout &lt;&lt; &quot;Not Possible&quot; &lt;&lt; endl;
            return;
    print(&quot;a = &quot; + str(a) + &quot;\nb = &quot; + str(b))
S = 17
X = 13
compute(S, X);
</py>
  <orden>4</orden>
  <suborden>20</suborden>
  <fecha_creacion>2020-12-06 19:51:41</fecha_creacion>
  <fecha_modificacion>2022-03-08 12:18:28</fecha_modificacion>
</row>
<row>
  <ID>216</ID>
  <supergrupo>BitWise</supergrupo>
  <tema>Cantidad de formas para realizar XOR en dos números</tema>
  <texto>Dadas dos cadenas binarias s1 y s2. El XOR de ellos es X, la tarea es encontrar el número de formas de intercambiar posiciones de dos bits en la cadena s1 de manera que el XOR formado entre los nuevos s1 y s2 no sea lo mismo que X.
Ejemplos:
Entrada: s1 = &quot;01011&quot;, s2 = &quot;11001&quot;
Salida: 4
intercambiar bits de índice (basado en 1) (1, 4), (2, 3), (3, 4) o (3, 5) de modo que se cambie el valor XOR.
Entrada: s1 = &quot;011000&quot;, s2 = &quot;010011&quot;
Salida: 6

Aproximación:
1. Cuente el número de unos y ceros en s1.
2. Recorra la cadena s1 y compruebe dos casos:
• 0 y 0 en s1 [i] y s2 [i], al reemplazar 0 con 1, cambiará el valor XOR.
• 1 y 0 en s1 [i] y s2 [i], ya que reemplazar 1 con 0 cambiará el valor XOR.
3. Para el primer caso, el número de formas de reemplazo será el número de unos, unos ya utilizados.
4. Para el segundo caso, el número de formas de reemplazo será el número de ceros, ceros ya usados.
5. La suma de varias formas en ambos casos será la respuesta.
</texto>
  <complejidad_tiempo>null</complejidad_tiempo>
  <java>// Programa Java para encontrar Número de formas de cambiar el 
// XOR de dos números intercambiando los bits

public class WaysToXORTwoNumbers {

    // Función que devuelve el número de intercambios de bits de modo que xor es diferente
    static int countWays(String s1,
            String s2) {
        int c1 = 0, c0 = 0;
        int n = s1.length();

        // atravesar y contar 1 y 0
        for (int i = 0; i &lt; n; i++) {
            if (s1.charAt(i) == &#39;1&#39;) {
                c1++;
            } else {
                c0++;
            }
        }
        int used1 = 0, used0 = 0;
        int ways = 0;

        // atravesar el string
        for (int i = 0; i &lt; n; i++) {

            // si ambas posiciones son 0
            if (s1.charAt(i) == &#39;0&#39;
                    &amp;&amp; s2.charAt(i) == &#39;0&#39;) {
                // agregue el número de unos, ya que cambiará el XOR
                ways += c1;
                // restar el número de los ya usados
                ways -= used1;
                // se han utilizado ceros
                used0++;
            } // cuando 1 y 0, para cambiar XOR, tenemos que reemplazar 1 por 0
            else if (s1.charAt(i) == &#39;1&#39;
                    &amp;&amp; s2.charAt(i) == &#39;0&#39;) {
                // agregar el número de ceros
                ways += c0;
                // restar el número de ceros ya usados
                ways -= used0;
                // cuenta 1 se usa
                used1++;
            }
        }
        return ways;
    }

    public static void main(String[] args) {
        String s1 = &quot;01011&quot;;
        String s2 = &quot;11001&quot;;
        System.out.println(countWays(s1, s2));
    }
}
</java>
  <cpp>#include &lt;bits/stdc++.h&gt; 
using namespace std;

int countWays(string s1, string s2) {
    int c1 = 0, c0 = 0;
    int n = s1.length();
    for (int i = 0; i &lt; n; i++) {
        if (s1[i] == &#39;1&#39;)
            c1++;
        else
            c0++;
    }
    int used1 = 0, used0 = 0;
    int ways = 0;

    for (int i = 0; i &lt; n; i++) {
        if (s1[i] == &#39;0&#39; and s2[i] == &#39;0&#39;) {
            ways += c1;
            ways -= used1;
            used0++;
        } else if (s1[i] == &#39;1&#39; and s2[i] == &#39;0&#39;) {
            ways += c0;
            ways -= used0;
            used1++;
        }
    }
    return ways;
}

int main() {
    string s1 = &quot;01011&quot;;
    string s2 = &quot;11001&quot;;

    cout &lt;&lt; countWays(s1, s2);
    return 0;
}
</cpp>
  <py>def countWays(s1, s2): 

    c1 = 0
    c0 = 0
    n = len(s1) 
    for i in range(0, n): 
        if (s1[i] == &#39;1&#39;): 
            c1 += 1
        else: 
            c0 += 1
        
    used1 = 0
    used0 = 0
    ways = 0

    for i in range(0, n): 
        if (s1[i] == &#39;0&#39; and s2[i] == &#39;0&#39;): 
            ways += c1 
            ways -= used1 
            used0 += 1
        elif (s1[i] == &#39;1&#39; and s2[i] == &#39;0&#39;): 
            ways += c0 
            ways -= used0 
            used1 += 1

    return ways 
s1 = &quot;01011&quot;
s2 = &quot;11001&quot;
print(countWays(s1, s2)) 
</py>
  <orden>4</orden>
  <suborden>21</suborden>
  <fecha_creacion>2020-12-06 19:51:41</fecha_creacion>
  <fecha_modificacion>2022-03-08 12:18:28</fecha_modificacion>
</row>
<row>
  <ID>217</ID>
  <supergrupo>BitWise</supergrupo>
  <tema>Ecuaciones BitWise para multiplicación de un numero por n</tema>
  <texto>En números enteros sin signo, el desplazamiento lógico hacia la izquierda equivale a una multiplicación por 2 y el desplazamiento lógico hacia la derecha equivale a una división por 2. En la división (desplazamiento hacia la derecha), se pierde el bit menos significativo, dando como resultado un truncamiento del resultado (redondeo hacia abajo, hacia menos infinito). Así, 6 / 2 es igual a 3, pero 7 / 2 es igual a 3,5, pero el 0,5 se pierde quedando el resultado en 3.
Los programadores de lenguaje ensamblador usan esta propiedad para hacer multiplicaciones y divisiones rápidas, de enteros sin signo, por una potencia de 2, en donde n desplazamientos equivalen a multiplicar o dividir por 2n. También, si el procesador no tiene operaciones de multiplicación y división de enteros, o si éstas son muy lentas, se puede multiplicar o dividir usando desplazamientos y sumas para multiplicar y desplazamientos y restas para dividir.
</texto>
  <complejidad_tiempo>null</complejidad_tiempo>
  <java>import java.util.ArrayList;
import java.util.TreeMap;

public class BitwiseMultiplication {

    static boolean powerof2(int x) {
        return x != 0 &amp;&amp; ((x &amp; (x - 1)) == 0);
    }

    static int suma(int n) {
        return (~(-(1 &lt;&lt; n))) &lt;&lt; 1;
    }

    static int nith(int n) {
        return (int) ((Math.log(n + 2) / Math.log(2)) - 1);
    }

    static String bitsum(ArrayList&lt;Integer&gt; arr, String n, int len) {
        ArrayList&lt;Integer&gt; rev = new ArrayList&lt;&gt;();
        TreeMap&lt;String, Integer&gt; counter = new TreeMap&lt;&gt;();
        String serie = &quot;&quot;;
        for (int i : arr) {
            for (int j = 1; j &lt;= nith(i); ++j) {
                rev.add(j);
            }
        }
        for (int i : rev) {
            int aux = 0;
            for (int j : rev) {
                if (j == i) {
                    aux++;
                }
            }
            counter.put(&quot;(&quot; + n + &quot;&lt;&lt;&quot; + i + &quot;)&quot;, aux);
        }
        for (String s : counter.keySet()) {
            String key = s;
            int value = counter.get(s);
            if (powerof2(value) &amp;&amp; value != 1) {
                serie += &quot;(&quot; + key + &quot;&lt;&lt;&quot; + ((int) (Math.log(value) / Math.log(2))) + &quot;) + &quot;;
                continue;
            }
            for (int j = 0; j &lt; value; j++) {
                serie += &quot; &quot; + key + &quot; + &quot;;
            }
        }
        if (arr.get(len - 1) == 1) { // si el n es impar se le añade el ultimo termino n como sumando; si es par no se le añade
            return serie + &quot; &quot; + n;
        }
        return serie;
    }

    public static void main(String[] args) {
        int n = 7; //numero al cual le quiero calcular la ecuación
        int N = n; //una copia del numero
        ArrayList&lt;Integer&gt; arr = new ArrayList&lt;&gt;();
        while (suma(nith(n)) &gt; 0) { //cálculos los términos de 2^n - 2 tales que su suma me da n (si n es impar siempre falta un 1) y los voy almacenando en un vector
            arr.add(suma(nith(n)));
            n -= suma(nith(n));
        }
        int sumarr = 0;
        for (int i = 0; i &lt; arr.size(); ++i) {
            sumarr += arr.get(i);//sumo los termino del vector
        }
        if (sumarr &lt; N) {//si la suma no me da mi N añado el 1 que me falta
            arr.add(1);
        }
        System.out.println(&quot;x*&quot; + N + &quot; -&gt; &quot; + bitsum(arr, &quot;x&quot;, arr.size())); //imprime la ecuación
    }

}
</java>
  <cpp>#include&lt;bits/stdc++.h&gt;
#include&lt;cstdlib&gt;
#include &lt;math.h&gt;
#include &lt;iterator&gt;
using namespace std;
#define FAST ios_base::sync_with_stdio(false);cin.tie(NULL);cout.tie(0);

bool powerof2(int x) {
    return x != 0 &amp; &amp; ((x &amp; (x - 1)) == 0);
}

int suma(int n) {
    return ( ~(-(1 &lt;&lt; n))) &lt;&lt; 1;
}

int nith(int n) {
    return (int) (log2(n + 2) - 1);
}

string bitsum(vector &lt; int &gt; arr, string n, int len) {
    vector &lt; int &gt; rev;
    map &lt; string, int &gt; counter;
    string serie = &quot;&quot;;
    for (int i : arr) {
        for (int j = 1; j &lt;= nith(i); + + j) {
            rev.push_back(j);
        }
    }
    for (int i : rev) {
        int aux = 0;
        for (int j : rev) {
            if (j == i) {
                aux + +;
            }
        }
        string dat = &quot;(&quot; + n + &quot;&lt;&lt;&quot; + to_string(i) + &quot;)&quot;;
        counter.insert(pair &lt; string, int &gt; (dat, aux));
    }
    map &lt; string, int &gt; ::iterator itr;
    for (itr = counter.begin(); itr != counter.end(); + + itr) {
        string key = itr - &gt; first;
        int value = itr - &gt; second;
        if (powerof2(value) &amp; &amp; value != 1) {
            serie += &quot;(&quot; + key + &quot;&lt;&lt;&quot; + to_string(((int) (log2(value)))) + &quot;) + &quot;;
            continue;
        }
        for (int j = 0; j &lt; value; j + +) {
            serie += &quot; &quot; + key + &quot; + &quot;;
        }
    }
    if (arr[len - 1] == 1) {
        return serie + &quot; &quot; + n;
    }
    return serie;
}

int main() {
    FAST;
    int n = 7;
    int N = n;
    vector &lt; int &gt; arr;
    while (suma(nith(n))) {
        arr.push_back(suma(nith(n)));
        n -= suma(nith(n));
    }
    int sumarr = 0;
    for (int i = 0; i &lt; arr.size(); + + i) {
        sumarr += arr[i];
    }
    if (sumarr &lt; N) {
        arr.push_back(1);
    }
    cout &lt;&lt; &quot;x*&quot; &lt;&lt; N &lt;&lt; &quot; -&gt; &quot; &lt;&lt; bitsum(arr, &quot;x&quot;, arr.size()) &lt;&lt; endl;
}
</cpp>
  <py>from sys import stdin, stdout
from collections import Counter
from math import log2

in_, out = stdin.readline, stdout.write


def powerof2(n):
    x = n
    y = not(n &amp; (n - 1))
    return x and y

suma = lambda n: (~(-(1 &lt;&lt; n))) &lt;&lt; 1

nith = lambda n: int(log2(n + 2) - 1)


def bitsum(arr, n):
    serie = str()
    lista = []
    for i in arr:
        for j in range(1, nith(i) + 1):
            lista.append(f&quot;({n}&lt;&lt;{j})&quot;)
    v = dict(Counter(lista))
    for i in v:
        if powerof2(v[i]) and v[i] != 1:
            serie += f&quot;({i}&lt;&lt;{int(log2(v[i]))}) + &quot;
            continue
        for j in range(v[i]):
            serie += f&quot;{i} + &quot;
    if arr[-1] == 1:
        return serie[:-3] + f&quot; + {n}&quot;
    return serie[:-3]

n = 7
N = n
arr = []

while suma(nith(n)):
    arr.append(suma(nith(n)))
    n -= suma(nith(n))

if sum(arr) != N:
    arr.append(1)

out(f&quot;x*{N} -&gt; {bitsum(arr,&#39;x&#39;)}\n&quot;)
</py>
  <orden>4</orden>
  <suborden>22</suborden>
  <fecha_creacion>2020-12-06 19:51:41</fecha_creacion>
  <fecha_modificacion>2022-03-08 12:18:28</fecha_modificacion>
</row>
<row>
  <ID>218</ID>
  <supergrupo>BitWise</supergrupo>
  <tema>Bitmasking (Parte 1)</tema>
  <texto>Considere la siguiente declaración de problema.
Hay 100 tipos diferentes de límites, cada uno con una identificación única de 1 a 100. Además, hay &quot;n&quot; personas, cada una con una colección de un número variable de límites. Un día todas estas personas deciden ir a una fiesta con gorra, pero para verse únicas decidieron que ninguna usaría el mismo tipo de gorra. Por lo tanto, cuente el número total de arreglos o formas en que ninguno de ellos use el mismo tipo de gorra.
Restricciones: 1 &lt;= n &lt;= 10 Ejemplo:
La primera línea contiene el valor de n, las siguientes n líneas contienen colecciones
de todas las n personas.
Entrada:
3
5 100 1 // Recogida de la primera persona.
2 // Recogida de la segunda persona.
5 100 // Recogida de la tercera persona.

Salida:
4
Explicación: Todas las formas posibles válidas son (5, 2, 100), (100, 2, 5),
            (1, 2, 5) y (1, 2, 100)
Dado que, el número de formas podría ser grande, entonces el módulo de salida 1000000007
Le recomendamos encarecidamente que minimice su navegador e intente esto usted mismo primero.
Una solución simple es probar todas las combinaciones posibles. Comience eligiendo el primer elemento del primer conjunto, marcándolo como visitado y repita para los conjuntos restantes. Es básicamente una solución basada en Backtracking.
Una mejor solución es utilizar Bitmasking y DP. Primero introduzcamos Bitmasking.



¿Qué es la máscara de bits?
Supongamos que tenemos una colección de elementos que están numerados de 1 a N. Si queremos representar un subconjunto de este conjunto, entonces puede ser codificado por una secuencia de N bits (usualmente llamamos a esta secuencia una “máscara”). En nuestro subconjunto elegido, el elemento i-ésimo le pertenece si y solo si el bit i-ésimo de la máscara está establecido, es decir, es igual a 1. Por ejemplo, la máscara 10000101 significa que el subconjunto del conjunto [1… 8 ] consta de los elementos 1, 3 y 8. Sabemos que para un conjunto de N elementos hay un total de 2N subconjuntos, por lo que son posibles 2N máscaras, una que representa cada subconjunto. Cada máscara es, de hecho, un número entero escrito en notación binaria.
Nuestra metodología principal es asignar un valor a cada máscara (y, por lo tanto, a cada subconjunto) y así calcular los valores para nuevas máscaras utilizando valores de las máscaras ya calculadas. Por lo general, nuestro objetivo principal es calcular el valor / solución para el conjunto completo, es decir, para la máscara 11111111. Normalmente, para encontrar el valor para un subconjunto X, eliminamos un elemento de todas las formas posibles y usamos valores para los subconjuntos obtenidos X&#39;1, X &#39; 2…, X&#39;k para calcular el valor / solución de X. Esto significa que los valores de X&#39;i ya deben haberse calculado, por lo que debemos establecer un orden en el que se considerarán las máscaras. Es fácil ver que el orden natural funciona: revise las máscaras en orden creciente de los números correspondientes. Además, a veces, comenzamos con el subconjunto vacío X y agregamos elementos de todas las formas posibles y usamos los valores de los subconjuntos obtenidos X&#39;1, X&#39;2 ..., X&#39;k para calcular el valor / solución para X.

Usamos principalmente las siguientes notaciones / operaciones en máscaras:
bit (i, mask) - el i-ésimo bit de máscara

count (máscara): el número de bits distintos de cero en la máscara
primero (máscara): el número del bit distinto de cero más bajo en la máscara
set (i, mask) - establece el bit i en la máscara

check (i, máscara) - comprobar el bit i en la máscara

¿Cómo se resuelve este problema usando Bitmasking + DP?

La idea es aprovechar el hecho de que hay hasta 10 personas. Entonces podemos usar una variable entera como una máscara de bits para almacenar qué persona usa gorra y cuál no.

Sea i el número de límite actual (los límites de 1 a i-1 ya están
procesado). Dejemos que la máscara de variable entera indica que las personas w
orejas y no gorras. Si el bit i&#39;th está configurado en máscara, entonces
i&#39;th persona lleva una gorra, de lo contrario no.

             // considere el caso en el que no se incluye el tope
                     // en el arreglo
countWays (máscara, i) = countWays (máscara, i + 1) +
                    
                    // cuando se incluye el tope en el arreglo
                    // entonces, asigne este límite a todas las personas posibles
                    // uno por uno y se repite para las personas restantes.
                    ∑ countWays (máscara | (1 &lt;&lt; j), i + 1)
                       por cada persona j que pueda usar gorra i
 
Tenga en cuenta que la expresión &quot;máscara | (1 &lt;&lt; j)&quot; establece j&#39;th bit en máscara.
Y una persona puede usar gorra i si está en la lista de gorra de la persona
proporcionado como entrada.
Si dibujamos el árbol de recursividad completo, podemos observar que muchos subproblemas se resuelven una y otra vez. Entonces usamos Programación Dinámica. Se utiliza una tabla dp [] [] de modo que en cada entrada dp [i] [j], i es la máscara y j es el número de límite.

Como queremos acceder a todas las personas que pueden usar una gorra determinada, utilizamos una matriz de vectores, capList [101]. Un valor capList [i] indica la lista de personas que pueden usar gorra i.
</texto>
  <complejidad_tiempo>null</complejidad_tiempo>
  <java>// Usando bitmasking para resolver el problema del numero de formas de 
// usar sombrero

import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.util.ArrayList;

public class Bitmasking1 {

    static final int MOD = 1000000007;

    // Objecto lector 
    static BufferedReader br = new BufferedReader(new InputStreamReader(System.in));

    //capList[i]esimo vector contiene la lista de personas que 
    //tienen un sombrero con id i, id está entre 1 y 100, 
    //por lo que declaramos una array de 101 vectores ya 
    //que la indexación comienza desde 0.
    static ArrayList&lt;Integer&gt; capList[] = new ArrayList[101];

    //dp [2 ^ 10] [101] .. en dp [i] [j], i denota la máscara, 
    //es decir, indica cuántas personas y qué personas llevan sombrero. 
    //j denota el primer j sombrero utilizado. Entonces, dp [i] [j] 
    //indica el número de formas en que asignamos j sombreros para 
    //enmascarar i de tal manera que ninguno de ellos use el mismo gorro
    static int dp[][] = new int[1025][101];

    //Esto se usa para el caso base, tiene todos los N bits configurados, 
    //por lo que indica si todas las N personas están usando un sombrero.
    static int allmask;

    //Máscara es el conjunto de personas, i es cap-id 
    //(OR el número de sombreros procesados a partir del primer sombrero).
    static long countWaysUtil(int mask, int i) {
        //Si todas las personas están usando gorra, 
        //hemos terminado y esta es una forma, regrese 1
        if (mask == allmask) {
            return 1;
        }

        //Si no todo el mundo está usando una gorra y además no 
        //quedan más gorras para procesar, 
        //entonces no hay forma, entonces devuelve 0;
        if (i &gt; 100) {
            return 0;
        }

        // Si ya hemos resuelto este subproblema, devolvemos la respuesta.
        if (dp[mask][i] != -1) {
            return dp[mask][i];
        }

        //Maneras en las que no incluimos este límite 
        //en nuestro arreglo o conjunto de soluciones.
        long ways = countWaysUtil(mask, i + 1);

        // size es el número total de personas que tienen un límite con la identificación i. 
        int size = capList[i].size();

        //Por lo tanto, asigne uno a uno el sombrero iesimo a 
        //todas las personas posibles y repita para los sombreros restantes.
        for (int j = 0; j &lt; size; j++) {
            //Si la persona capList [i] [j] ya está usando una gorra, 
            //continúe, ya que no podemos asignarle esta gorra.
            if ((mask &amp; (1 &lt;&lt; capList[i].get(j))) != 0) {
                continue;
            }// De lo contrario, asígnele este sombrero y repita 
            //para los sombreros restantes con un nuevo vector de máscara actualizado
            else {
                ways += countWaysUtil(mask | (1 &lt;&lt; capList[i].get(j)), i + 1);
            }
            ways %= MOD;
        }
        // Guarde el resultado y devuélvalo.
        return dp[mask][i] = (int) ways;
    }

    // Lee n líneas de la entrada estándar para el caso de prueba actual
    static void countWays(int n) throws Exception {
        String str;
        String split[];
        int x;

        for (int i = 0; i &lt; n; i++) {
            str = br.readLine();
            split = str.split(&quot; &quot;);

            // mientras haya palabras en split[]
            for (int j = 0; j &lt; split.length; j++) {
                // agregue la i-ésima persona en la lista de cap si con id x
                x = Integer.parseInt(split[j]);
                capList[x].add(i);
            }

        }
        //Todas las máscaras se utilizan para comprobar si 
        //todas las personas están incluidas o no,
        //establezca todos los n bits como 1
        allmask = (1 &lt;&lt; n) - 1;
        // Inicializar todas las entradas en dp como -1
        for (int[] is : dp) {
            for (int i = 0; i &lt; is.length; i++) {
                is[i] = -1;
            }
        }
        // Llamar a la función recursiva contar formas
        System.out.println(countWaysUtil(0, 1));
    }

    public static void main(String args[]) throws Exception {
        int n; //numero de personas en cada caso de prueba
        // inicializando vector de listas
        for (int i = 0; i &lt; capList.length; i++) {
            capList[i] = new ArrayList&lt;&gt;();
        }
        //3
        //5 100 1
        //2
        //5 100
        n = Integer.parseInt(br.readLine());
        countWays(n);
        // salida -&gt; 4
    }
}
</java>
  <cpp>// C++ program to find number of ways to wear hats 
#include&lt;bits/stdc++.h&gt; 
#define MOD 1000000007 
using namespace std;

vector&lt;int&gt; capList[101];
int dp[1025][101];
int allmask;

long long int countWaysUtil(int mask, int i) {
    if (mask == allmask) return 1;
    if (i &gt; 100) return 0;
    if (dp[mask][i] != -1) return dp[mask][i];
    long long int ways = countWaysUtil(mask, i + 1);
    int size = capList[i].size();
    for (int j = 0; j &lt; size; j++) {
        if (mask &amp; (1 &lt;&lt; capList[i][j])) continue;
        else ways += countWaysUtil(mask | (1 &lt;&lt; capList[i][j]), i + 1);
        ways %= MOD;
    }
    return dp[mask][i] = ways;
}

void countWays(int n) {
    string temp, str;
    int x;
    getline(cin, str);
    for (int i = 0; i &lt; n; i++) {
        getline(cin, str);
        stringstream ss(str);
        while (ss &gt;&gt; temp) {
            stringstream s;
            s &lt;&lt; temp;
            s &gt;&gt; x;
            capList[x].push_back(i);
        }
    }
    allmask = (1 &lt;&lt; n) - 1;
    memset(dp, -1, sizeof dp);
    cout &lt;&lt; countWaysUtil(0, 1) &lt;&lt; endl;
}

int main() {
    int n;
    cin &gt;&gt; n;
    countWays(n);
    return 0;
}
</cpp>
  <py>from collections import defaultdict
 
class AssignCap: 
    def __init__(self): 
        self.allmask = 0
        self.total_caps = 100
        self.caps = defaultdict(list) 

    def countWaysUtil(self, dp, mask, cap_no): 
        if mask == self.allmask: 
            return 1
        if cap_no &gt; self.total_caps: 
            return 0
        if dp[mask][cap_no] != -1: 
            return dp[mask][cap_no] 
        ways = self.countWaysUtil(dp, mask, cap_no + 1)  
        if cap_no in self.caps: 
            for ppl in self.caps[cap_no]: 
                if mask &amp; (1 &lt;&lt; ppl): continue
                ways += self.countWaysUtil(dp, mask | (1 &lt;&lt; ppl), cap_no + 1) 
                ways = ways % (10 ** 9 + 7)  
        dp[mask][cap_no] = ways 
        return dp[mask][cap_no] 
    def countWays(self, N): 
        for ppl in range(N): 
            cap_possessed_by_person = map(int, raw_input().strip().split()) 
            for i in cap_possessed_by_person: 
                self.caps[i].append(ppl) 
        self.allmask = (1 &lt;&lt; N) -1
        dp = [[-1 for j in range(self.total_caps + 1)] for i in range(2 ** N)] 
        print self.countWaysUtil(dp, 0, 1,) 

def main(): 
    No_of_people = input()  
    AssignCap().countWays(No_of_people) 
main() 
</py>
  <orden>4</orden>
  <suborden>23</suborden>
  <fecha_creacion>2020-12-06 19:51:42</fecha_creacion>
  <fecha_modificacion>2022-03-08 12:18:28</fecha_modificacion>
</row>
<row>
  <ID>219</ID>
  <supergrupo>DP</supergrupo>
  <tema>El problema de los globos y las monedas</tema>
  <texto>Se nos han dado N globos, cada uno con una cantidad de monedas asociadas. Al reventar un globo i, el número de monedas ganadas es igual a A [i-1] * A [i] * A [i + 1]. Además, los globos i-1 e i + 1 ahora se vuelven adyacentes. Encuentra la máxima ganancia posible obtenida después de reventar todos los globos. Suponga un 1 adicional en cada límite.
Ejemplos:
Entrada: 5, 10
Salida: 60
Explicación - Primera ráfaga 5, monedas = 1 * 5 * 10
              Luego revienta 10, monedas + = 1 * 10 * 1
              Total = 60

Entrada: 1, 2, 3, 4, 5
Salida: 110

Primero, considere una submatriz de índices de izquierda a derecha (inclusive).
Si asumimos que el globo en el índice Último es el último globo en reventar en este subarreglo, diríamos que la ganancia acuñada es-A [izquierda-1] * A [último] * A [derecha + 1].
Además, la moneda total ganada sería este valor, más dp [izquierda] [último - 1] + dp [último + 1] [derecha], donde dp [i] [j] significa la moneda máxima ganada para la submatriz con índices yo, j.
Por lo tanto, para cada valor de Izquierda y Derecha, necesitamos encontrar y elegir un valor de Último con la máxima moneda ganada y actualizar la matriz dp.
Nuestra respuesta es el valor en dp [1] [N].
</texto>
  <complejidad_tiempo>null</complejidad_tiempo>
  <java>//Programa Java para ilustrar el problema del BurstBalloon

public class BurstBalloonMaximizeCoins {

    public static int getMax(int[] A, int N) {

        // Agregar globos de borde
        int[] B = new int[N + 2];
        B[0] = B[N + 1] = 1;

        for (int i = 1; i &lt;= N; i++) {
            B[i] = A[i - 1];
        }

        // Declaración de array DP
        int[][] dp = new int[N + 2][N + 2];

        for (int length = 1;
                length &lt; N + 1; length++) {
            for (int left = 1;
                    left &lt; N - length + 2; left++) {
                int right = left + length - 1;

                //Para una submatriz de índices a la izquierda, a la derecha. 
                //Este bucle más interno encuentra la última explosión del globo.
                for (int last = left;
                        last &lt; right + 1; last++) {
                    dp[left][right] = Math.max(
                            dp[left][right],
                            dp[left][last - 1]
                            + B[left - 1] * B[last]
                            * B[right + 1]
                            + dp[last + 1][right]);
                }
            }
        }
        return dp[1][N];
    }

    public static void main(String args[]) {
        int[] A = {1, 2, 3, 4, 5};
        int N = A.length;
        System.out.println(getMax(A, N));
    }
}
</java>
  <cpp>#include &lt;bits/stdc++.h&gt; 
#include &lt;iostream&gt; 
using namespace std;

int getMax(int A[], int N) {
    int B[N + 2];
    B[0] = 1;
    B[N + 1] = 1;
    for (int i = 1; i &lt;= N; i++)
        B[i] = A[i - 1];
    int dp[N + 2][N + 2];
    memset(dp, 0, sizeof (dp));

    for (int length = 1; length &lt; N + 1; length++) {
        for (int left = 1; left &lt; N - length + 2; left++) {
            int right = left + length - 1;
            for (int last = left; last &lt; right + 1; last++) {
                dp[left][right] = max(dp[left][right],
                        dp[left][last - 1] +
                        B[left - 1] * B[last] * B[right + 1] +
                        dp[last + 1][right]);
            }
        }
    }
    return dp[1][N];
}

int main() {
    int A[] = {1, 2, 3, 4, 5};
    int N = sizeof (A) / sizeof (A[0]);
    cout &lt;&lt; getMax(A, N) &lt;&lt; endl;
}
</cpp>
  <py>def getMax(A): 
    N = len(A) 
    A = [1] + A + [1]
    dp = [[0 for x in range(N + 2)] for y in range(N + 2)] 
      
    for length in range(1, N + 1): 
        for left in range(1, N-length + 2): 
            right = left + length -1
            for last in range(left, right + 1): 
                dp[left][right] = max(dp[left][right], \ 
                                      dp[left][last-1] + \ 
                                      A[left-1] * A[last] * A[right + 1] + \ 
                                      dp[last + 1][right]) 
    return(dp[1][N]) 
  
A = [1, 2, 3, 4, 5] 
print(getMax(A)) 
</py>
  <orden>9</orden>
  <suborden>5</suborden>
  <fecha_creacion>2020-12-06 19:51:42</fecha_creacion>
  <fecha_modificacion>2022-03-08 12:19:51</fecha_modificacion>
</row>
<row>
  <ID>220</ID>
  <supergrupo>DP</supergrupo>
  <tema>El problema de apilamiento de cajas</tema>
  <texto>Se le da un conjunto de n tipos de cajas rectangulares en 3D, donde la i ^ ésima caja tiene altura h (i), ancho w (i) y profundidad d (i) (todos números reales). Desea crear una pila de cajas lo más alta posible, pero solo puede apilar una caja encima de otra caja si las dimensiones de la base 2-D de la caja inferior son estrictamente más grandes que las del 2- D base de la caja superior. Por supuesto, puede rotar una caja para que cualquier lado funcione como base. También está permitido utilizar varias instancias del mismo tipo de caja.
 
El problema de apilamiento de cajas es una variación del problema LIS (Longest increasing subsequence). Necesitamos construir una pila de altura máxima.
Los siguientes son los puntos clave a tener en cuenta en el planteamiento del problema:
1) Una caja puede colocarse encima de otra caja solo si tanto el ancho como la profundidad de la caja colocada en la parte superior son menores que el ancho y la profundidad de la caja inferior respectivamente.
2) Podemos rotar cajas de manera que el ancho sea menor que la profundidad. Por ejemplo, si hay un cuadro con dimensiones {1x2x3} donde 1 es la altura, 2 × 3 es la base, entonces puede haber tres posibilidades, {1x2x3}, {2x1x3} y {3x1x2}
3) Podemos utilizar varias instancias de cajas. Lo que significa es que podemos tener dos rotaciones diferentes de una caja como parte de nuestra pila de altura máxima.
A continuación se muestra la solución basada en la solución DP del problema LIS.

1) Genere las 3 rotaciones de todas las cajas. El tamaño de la matriz de rotación se convierte en 3 veces el tamaño de la matriz original. Por simplicidad, consideramos que el ancho es siempre menor o igual que la profundidad.
2) Ordene los cuadros 3n generados anteriormente en orden decreciente de área base.
3) Después de clasificar las cajas, el problema es el mismo que LIS con la siguiente propiedad de subestructura óptima.
MSH (i) = Altura máxima posible de la pila con la caja i en la parte superior de la pila
MSH (i) = {Max (MSH (j)) + altura (i)} donde j &lt;i y ancho (j)&gt; ancho (i) y profundidad (j)&gt; profundidad (i).
Si no existe tal j, entonces MSH (i) = altura (i)
4) Para obtener la altura máxima general, devolvemos max (MSH (i)) donde 0 &lt;i &lt;n

En el programa, los cuadros de entrada dados son {4, 6, 7}, {1, 2, 3}, {4, 5, 6}, {10, 12, 32}. A continuación se muestran todas las rotaciones de las cajas en orden decreciente del área de la base.
   10 x 12 x 32
   12 x 10 x 32
   32 x 10 x 12
   4 x 6 x 7
   4 x 5 x 6
   6 x 4 x 7
   5 x 4 x 6
   7 x 4 x 6
   6 x 4 x 5
   1 x 2 x 3
   2 x 1 x 3
   3 x 1 x 2
La altura 60 se obtiene mediante cuadros {{3, 1, 2}, {1, 2, 3}, {6, 4, 5}, {4, 5, 6}, {4, 6, 7}, {32 , 10, 12}, {10, 12, 32}}
</texto>
  <complejidad_tiempo>null</complejidad_tiempo>
  <java>/* Implementación de programación dinámica del problema de 
   apilamiento de cajas en Java*/
import java.util.*;

public class BoxStackingProblem {

    /* Representación de una caja */
    static class Box implements Comparable&lt;Box&gt; {

        // h -&gt; altura, w -&gt; ancho,
        // d -&gt; profundidad
        int h, w, d, area;

        // para simplificar la solución, mantenga siempre w &lt;= d
        // Constructor para inicializar el objeto
        public Box(int h, int w, int d) {
            this.h = h;
            this.w = w;
            this.d = d;
        }

        // Para ordenar la matriz de cajas según el 
        // área en orden decreciente de área
        @Override
        public int compareTo(Box o) {
            return o.area - this.area;
        }
    }

    /* Devuelve la altura de la pila más alta que se puede 
    formar con un tipo de cajas determinado */
    static int maxStackHeight(Box arr[], int n) {
        Box[] rot = new Box[n * 3];
        /* Se crea una nueva matriz de cajas, considerando las 3 posibles 
        rotaciones, con un ancho siempre mayor que igual al ancho */
        for (int i = 0; i &lt; n; i++) {
            Box box = arr[i];

            /* Caja original*/
            rot[3 * i] = new Box(box.h, Math.max(box.w, box.d),
                    Math.min(box.w, box.d));

            /* Primera rotación de caja*/
            rot[3 * i + 1] = new Box(box.w, Math.max(box.h, box.d),
                    Math.min(box.h, box.d));

            /* Segunda rotación de caja*/
            rot[3 * i + 2] = new Box(box.d, Math.max(box.w, box.h),
                    Math.min(box.w, box.h));
        }

        /* Cálculo del área base de
        cada una de las cajas.*/
        for (int i = 0; i &lt; rot.length; i++) {
            rot[i].area = rot[i].w * rot[i].d;
        }

        /* Clasificación de las cajas según el área en orden no creciente.*/
        Arrays.sort(rot);
        int count = 3 * n;
        /* Inicializar los valores de msh para todos
            índices
        msh [i] -&gt; Altura máxima de pila posible con 
        la casilla i en la parte superior */
        int[] msh = new int[count];
        for (int i = 0; i &lt; count; i++) {
            msh[i] = rot[i].h;
        }

        /* Calcular valores optimizados de msh [] de forma ascendente */
        for (int i = 0; i &lt; count; i++) {
            msh[i] = 0;
            Box box = rot[i];
            int val = 0;

            for (int j = 0; j &lt; i; j++) {
                Box prevBox = rot[j];
                if (box.w &lt; prevBox.w &amp;&amp; box.d &lt; prevBox.d) {
                    val = Math.max(val, msh[j]);
                }
            }
            msh[i] = val + box.h;
        }

        int max = -1;

        /* Elija el máximo de todos los valores de msh */
        for (int i = 0; i &lt; count; i++) {
            max = Math.max(max, msh[i]);
        }

        return max;
    }

    public static void main(String[] args) {
        Box[] arr = new Box[4];
        arr[0] = new Box(4, 6, 7);
        arr[1] = new Box(1, 2, 3);
        arr[2] = new Box(4, 5, 6);
        arr[3] = new Box(10, 12, 32);

        System.out.println(&quot;The maximum possible &quot;
                + &quot;height of stack is &quot;
                + maxStackHeight(arr, 4));
    }
}
</java>
  <cpp>#include&lt;stdio.h&gt; 
#include&lt;stdlib.h&gt; 

struct Box {
    int h, w, d;
};

int min(int x, int y) {
    return (x &lt; y) ? x : y;
}

int max(int x, int y) {
    return (x &gt; y) ? x : y;
}

int compare(const void *a, const void * b) {
    return ( (*(Box *) b).d * (*(Box *) b).w) -
            ((*(Box *) a).d * (*(Box *) a).w);
}

int maxStackHeight(Box arr[], int n) {

    Box rot[3 * n];
    int index = 0;
    for (int i = 0; i &lt; n; i++) {
        rot[index].h = arr[i].h;
        rot[index].d = max(arr[i].d, arr[i].w);
        rot[index].w = min(arr[i].d, arr[i].w);
        index++;

        rot[index].h = arr[i].w;
        rot[index].d = max(arr[i].h, arr[i].d);
        rot[index].w = min(arr[i].h, arr[i].d);
        index++;

        rot[index].h = arr[i].d;
        rot[index].d = max(arr[i].h, arr[i].w);
        rot[index].w = min(arr[i].h, arr[i].w);
        index++;
    }

    n = 3 * n;

    qsort(rot, n, sizeof (rot[0]), compare);
    //Uncomment following two lines to print all rotations 
    // for (int i = 0; i &lt; n; i++ ) 
    // printf(&quot;%d x %d x %d\n&quot;, rot[i].h, rot[i].w, rot[i].d); 
    int msh[n];
    for (int i = 0; i &lt; n; i++)
        msh[i] = rot[i].h;

    for (int i = 1; i &lt; n; i++)
        for (int j = 0; j &lt; i; j++)
            if (rot[i].w &lt; rot[j].w &amp;&amp;
                    rot[i].d &lt; rot[j].d &amp;&amp;
                    msh[i] &lt; msh[j] + rot[i].h
                    ) {
                msh[i] = msh[j] + rot[i].h;
            }


    int max = -1;
    for (int i = 0; i &lt; n; i++)
        if (max &lt; msh[i])
            max = msh[i];

    return max;
}

int main() {
    Box arr[] = {
        {4, 6, 7},
        {1, 2, 3},
        {4, 5, 6},
        {10, 12, 32}
    };
    int n = sizeof (arr) / sizeof (arr[0]);

    printf(&quot;The maximum possible height of stack is %d\n&quot;,
            maxStackHeight(arr, n));

    return 0;
}
</cpp>
  <py>class Box: 
    def __init__(self, h, w, d): 
        self.h = h 
        self.w = w 
        self.d = d 

    def __lt__(self, other): 
        return self.d * self.w &lt; other.d * other.w 

def maxStackHeight(arr, n): 
    rot = [Box(0, 0, 0) for _ in range(3 * n)] 
    index = 0
    for i in range(n): 
        rot[index].h = arr[i].h 
        rot[index].d = max(arr[i].d, arr[i].w) 
        rot[index].w = min(arr[i].d, arr[i].w) 
        index += 1
        rot[index].h = arr[i].w 
        rot[index].d = max(arr[i].h, arr[i].d) 
        rot[index].w = min(arr[i].h, arr[i].d) 
        index += 1
        rot[index].h = arr[i].d 
        rot[index].d = max(arr[i].h, arr[i].w) 
        rot[index].w = min(arr[i].h, arr[i].w) 
        index += 1
    n *= 3
    rot.sort(reverse=True) 

    # Uncomment following two lines to print 
    # all rotations 
    # for i in range(n): 
    #    print(rot[i].h, &#39;x&#39;, rot[i].w, &#39;x&#39;, rot[i].d) 

    msh = [0] * n 

    for i in range(n): 
        msh[i] = rot[i].h 
    for i in range(1, n): 
        for j in range(0, i): 
            if (rot[i].w &lt; rot[j].w and
                rot[i].d &lt; rot[j].d): 
                if msh[i] &lt; msh[j] + rot[i].h: 
                    msh[i] = msh[j] + rot[i].h 

    maxm = -1
    for i in range(n): 
        maxm = max(maxm, msh[i]) 

    return maxm 


arr = [Box(4, 6, 7), Box(1, 2, 3), 
    Box(4, 5, 6), Box(10, 12, 32)] 
n = len(arr) 
print(&quot;The maximum possible height of stack is&quot;, 
      maxStackHeight(arr, n)) 
</py>
  <orden>9</orden>
  <suborden>6</suborden>
  <fecha_creacion>2020-12-06 19:51:42</fecha_creacion>
  <fecha_modificacion>2022-03-08 12:19:51</fecha_modificacion>
</row>
<row>
  <ID>221</ID>
  <supergrupo>DP</supergrupo>
  <tema>Secuencia máxima de sumas incrementales desde prefijos</tema>
  <texto>Dada una matriz de n enteros positivos, escriba un programa para encontrar la suma máxima de subsecuencia creciente desde el prefijo hasta el índice i-ésimo y también incluya un elemento k-ésimo dado que está después de i, es decir, k&gt; i.
Ejemplos:
 
Entrada: arr [] = {1, 101, 2, 3, 100, 4, 5} i-ésimo índice = 4 (el elemento del cuarto índice es 100) K-ésimo índice = 6 (el elemento del sexto índice es 5.)
Salida: 11
Explicación:
Por lo tanto, necesitamos calcular la suma máxima de la subsecuencia (1 101 2 3 100 5) de modo que 5 se incluya necesariamente en la subsecuencia, por lo que la respuesta es 11 por subsecuencia (1 2 3 5).
Entrada: arr [] = {1, 101, 2, 3, 100, 4, 5} i-ésimo índice = 2 (el elemento en el segundo índice es 2) K-ésimo índice = 5 (el elemento en el quinto índice es 4.)
Salida: 7
Explicación:
Por lo tanto, debemos calcular la suma máxima de la subsecuencia (1101 2 4) de modo que 4 se incluya necesariamente en la subsecuencia, por lo que la respuesta es 7 por subsecuencia (1 2 4).

Enfoque ingenuo:
 
1. Construya una nueva matriz que contenga elementos hasta el índice i y el elemento k.
2. Calcule de forma recursiva todas las subsecuencias crecientes.
3. Descarte todas las subsecuencias que no tengan el k-ésimo elemento incluido.
4. Calcule la suma máxima de las subsecuencias restantes y visualícela.

Mejor enfoque: utilice un enfoque dinámico para mantener una tabla dp [] []. El valor de dp [i] [k] almacena la suma máxima de la subsecuencia creciente hasta el índice i y que contiene el elemento k.

Enfoque eficiente: este problema consiste básicamente en encontrar que la suma máxima de la subsecuencia creciente hasta el índice i dado es que todos los elementos de la subsecuencia son menores que el elemento kth (índice) o arr [k]. Por lo tanto, encuentre la subsecuencia creciente de suma máxima.
 
Por ejemplo: arr [] = {1, 101, 2, 3, 100, 4, 5}, index = 4; k = 6;
Ahora, necesitamos encontrar la subsecuencia de suma máxima desde la matriz hasta el índice 4 dado que todos los elementos de esa subsecuencia son menores que arr [k] que es 5. Ahora, iterando a través de la matriz.
Para i = 0; como 1 &lt;5; max subsecuencia creciente {1}, max = 1.
Para i = 1; como 101&gt; 5; omita esta entrada. Subsecuencia creciente máx. {1}, máx = 1.
Para i = 2; como 2 &lt;5; max subsecuencia creciente {1, 2}, max = 3.
Para i = 3; como 3 &lt;5; max subsecuencia creciente {1, 2, 3}, max = 6.
Para i = 4; como 100&gt; 5; omita esta entrada. Subsecuencia creciente máx. {1, 2, 3}, máx = 6.
como índice = 4; por lo tanto, deténgase aquí y la respuesta será max + a [k] = 6 + 5 = 11.
</texto>
  <complejidad_tiempo>null</complejidad_tiempo>
  <java>// Programa Java para encontrar la suma máxima que aumenta la subsecuencia 
// del índice i-ésimo e incluye el índice k-ésimo.

public class MaximumSumIncreasingSubsequenceFromPrefix {

    static int pre_compute(int a[], int n,
            int index, int k) {
        int dp[][] = new int[n][n];

        // Inicializando la primera fila del dp[][].
        for (int i = 0; i &lt; n; i++) {
            if (a[i] &gt; a[0]) {
                dp[0][i] = a[i] + a[0];
            } else {
                dp[0][i] = a[i];
            }
        }

        // Creando la matriz dp[][].
        for (int i = 1; i &lt; n; i++) {
            for (int j = 0; j &lt; n; j++) {
                if (a[j] &gt; a[i] &amp;&amp; j &gt; i) {
                    if (dp[i - 1][i] + a[j]
                            &gt; dp[i - 1][j]) {
                        dp[i][j] = dp[i - 1][i]
                                + a[j];
                    } else {
                        dp[i][j] = dp[i - 1][j];
                    }
                } else {
                    dp[i][j] = dp[i - 1][j];
                }
            }
        }

        // Calcular para i = 4 y k = 6.
        return dp[index][k];
    }

    public static void main(String[] args) {
        int a[] = {1, 101, 2, 3, 100, 4, 5};
        int n = a.length;
        int index = 4, k = 6;
        System.out.println(
                pre_compute(a, n, index, k));
    }
}
</java>
  <cpp>#include &lt;bits/stdc++.h&gt; 
using namespace std;

int pre_compute(int a[], int n, int index, int k) {
    int dp[n][n];

    for (int i = 0; i &lt; n; i++) {
        if (a[i] &gt; a[0]) {
            dp[0][i] = a[i] + a[0];
        } else {
            dp[0][i] = a[i];
        }
    }

    for (int i = 1; i &lt; n; i++) {
        for (int j = 0; j &lt; n; j++) {
            if (a[j] &gt; a[i] &amp;&amp; j &gt; i) {
                if (dp[i - 1][i] + a[j]
                        &gt; dp[i - 1][j]) {
                    dp[i][j] = dp[i - 1][i]
                            + a[j];
                } else {
                    dp[i][j] = dp[i - 1][j];
                }
            } else {
                dp[i][j] = dp[i - 1][j];
            }
        }
    }

    return dp[index][k];
}

int main() {
    int a[] = {1, 101, 2, 3, 100, 4, 5};
    int n = sizeof (a) / sizeof (a[0]);
    int index = 4, k = 6;
    cout &lt;&lt; pre_compute(a, n, index, k) &lt;&lt; endl;
}
</cpp>
  <py>def pre_compute(a, n, index, k):
    dp = [[0 for i in range(n)]for j in range(n)]
    for i in range (n):
        if (a[i] &gt; a[0]):
            dp[0][i] = a[i] + a[0]
        else:
            dp[0][i] = a[i]

    for i in range (n):
        for j in range (n):
            if (a[j] &gt; a[i] and j &gt; i):
                if (dp[i - 1][i] + a[j] &gt; dp[i - 1][j]):
                    dp[i][j] = dp[i - 1][i] + a[j];
                else:
                    dp[i][j] = dp[i - 1][j]
            else:
                dp[i][j] = dp[i - 1][j]
    return dp[index][k];

a = [1, 101, 2, 3, 100, 4, 5]
n = len(a)
index = 4
k = 6
print(pre_compute(a, n, index, k) + 1)
</py>
  <orden>9</orden>
  <suborden>7</suborden>
  <fecha_creacion>2020-12-06 19:51:43</fecha_creacion>
  <fecha_modificacion>2022-03-08 12:19:51</fecha_modificacion>
</row>
<row>
  <ID>222</ID>
  <supergrupo>DP</supergrupo>
  <tema>Minima suma en particiones </tema>
  <texto>Dado un conjunto de números enteros, la tarea es dividirlo en dos conjuntos S1 y S2 de manera que la diferencia absoluta entre sus sumas sea mínima.
Si hay un conjunto S con n elementos, entonces si asumimos que Subconjunto1 tiene m elementos, Subconjunto2 debe tener n-m elementos y el valor de abs (suma (Subconjunto1) - suma (Subconjunto2)) debe ser mínimo.
Ejemplo:
Entrada: arr [] = {1, 6, 11, 5}
Salida: 1
Explicación:
Subconjunto1 = {1, 5, 6}, suma de Subconjunto1 = 12
Subconjunto2 = {11}, suma de Subconjunto2 = 11

Solución recursiva
El enfoque recursivo consiste en generar todas las sumas posibles a partir de todos los valores de la matriz y comprobar qué solución es la más óptima.
Para generar sumas, incluimos el elemento i en el conjunto 1 o no lo incluimos, es decir, lo incluimos en el conjunto 2.

Complejidad del tiempo:
Todas las sumas pueden ser generadas por
(1) incluyendo ese elemento en el conjunto 1.
(2) sin incluir ese elemento en el conjunto 1.
Entonces las posibles combinaciones son: -
arr [0] (1 o 2) -&gt; 2 valores
arr [1] (1 o 2) -&gt; 2 valores
.
.
.
arr [n] (2 o 2) -&gt; 2 valores
Entonces, la complejidad del tiempo será 2 * 2 * ..... * 2 (Para n veces),
eso es O (2 ^ n).

Programación dinámica
El problema se puede resolver mediante programación dinámica cuando la suma de los elementos no es demasiado grande. Podemos crear una matriz 2D dp [n + 1] [suma + 1] donde n es un número de elementos en un conjunto dado y suma es la suma de todos los elementos. Podemos construir la solución de forma ascendente.



La tarea consiste en dividir el conjunto en dos partes.
Consideraremos los siguientes factores para dividirlo.
Dejar
  dp [n + 1] [suma + 1] = {1 si algún subconjunto del 1 al i tiene una suma
                      igual a j
                   0 de lo contrario}
    
    i varía de {1..n}
    j oscila entre {0 .. (suma de todos los elementos)}

Entonces
    dp [n + 1] [suma + 1] será 1 si
    1) La suma j se logra incluyendo el ítem i.
    2) La suma j se obtiene excluyendo el ítem i.

Sea la suma de todos los elementos S.

Para encontrar la diferencia de suma mínima, w tenemos que encontrar j tales
ese Min {suma - j * 2: dp [n] [j] == 1}
    donde j varía de 0 a suma / 2

La idea es que la suma de S1 es j y debería ser la más cercana
a sum / 2, es decir, 2 * j debe ser el más cercano a sum.

Complejidad de tiempo = O (n * suma) donde n es el número de elementos y suma es la suma de todos los elementos.
</texto>
  <complejidad_tiempo>null</complejidad_tiempo>
  <java>// Un programa Java recursivo para resolver el problema de partición de suma mínima.

public class MinimumSumPartition {
    // Devuelve el valor mínimo de la diferencia de los dos conjuntos.

    static int findMin(int arr[], int n) {
        // Calcular la suma de todos los elementos
        int sum = 0;
        for (int i = 0; i &lt; n; i++) {
            sum += arr[i];
        }

        // Cree una matriz para almacenar los resultados de los subproblemas
        boolean dp[][] = new boolean[n + 1][sum + 1];

        // Inicialice la primera columna como verdadera. 
        // La suma 0 es posible con todos los elementos.
        for (int i = 0; i &lt;= n; i++) {
            dp[i][0] = true;
        }

        // Inicialice la fila superior, excepto dp [0] [0], 
        // como falso. Con 0 elementos, no es posible ninguna otra suma excepto 0
        for (int i = 1; i &lt;= sum; i++) {
            dp[0][i] = false;
        }

        // Llene la tabla de partición de abajo hacia arriba
        for (int i = 1; i &lt;= n; i++) {
            for (int j = 1; j &lt;= sum; j++) {
                // Si se excluye el i-ésimo elemento
                dp[i][j] = dp[i - 1][j];

                // Si se incluye i&#39;th elemento
                if (arr[i - 1] &lt;= j) {
                    dp[i][j] |= dp[i - 1][j - arr[i - 1]];
                }
            }
        }

        // Inicialice la diferencia de dos sumas.
        int diff = Integer.MAX_VALUE;

        // Encuentre el j más grande tal que dp [n] [j] 
        // sea verdadero donde j hace un ciclo de suma / 2 t0 0
        for (int j = sum / 2; j &gt;= 0; j--) {
            if (dp[n][j] == true) {
                diff = sum - 2 * j;
                break;
            }
        }
        return diff;
    }

    public static void main(String[] args) {
        int arr[] = {3, 1, 4, 2, 2, 1};
        int n = arr.length;
        System.out.println(&quot;The minimum difference between 2 sets is &quot;
                + findMin(arr, n));
    }
}
</java>
  <cpp>#include &lt;bits/stdc++.h&gt; 
using namespace std;

int findMin(int arr[], int n) {

    int sum = 0;
    for (int i = 0; i &lt; n; i++)
        sum += arr[i];

    bool dp[n + 1][sum + 1];

    for (int i = 0; i &lt;= n; i++)
        dp[i][0] = true;

    for (int i = 1; i &lt;= sum; i++)
        dp[0][i] = false;
    for (int i = 1; i &lt;= n; i++) {
        for (int j = 1; j &lt;= sum; j++) {
            dp[i][j] = dp[i - 1][j];
            if (arr[i - 1] &lt;= j)
                dp[i][j] |= dp[i - 1][j - arr[i - 1]];
        }
    }
    int diff = INT_MAX;
    for (int j = sum / 2; j &gt;= 0; j--) {
        if (dp[n][j] == true) {
            diff = sum - 2 * j;
            break;
        }
    }
    return diff;
}

int main() {
    int arr[] = {3, 1, 4, 2, 2, 1};
    int n = sizeof (arr) / sizeof (arr[0]);
    cout &lt;&lt; &quot;The minimum difference between 2 sets is &quot;
            &lt;&lt; findMin(arr, n);
    return 0;
}
</cpp>
  <py>import sys
 

def findMin(a, n):      
    su = 0
    su = sum(a) 
    dp = [[0 for i in range(su + 1)] 
        for j in range(n + 1)] 
    for i in range(n + 1): 
        dp[i][0] = True
    for j in range(1, su + 1): 
        dp[0][j] = False
    for i in range(1, n + 1): 
        for j in range(1, su + 1): 
            dp[i][j] = dp[i - 1][j]  
            if a[i - 1] &lt;= j: 
                dp[i][j] |= dp[i - 1][j - a[i - 1]] 
    diff = sys.maxsize 
    for j in range(su // 2, -1, -1): 
        if dp[n][j] == True: 
            diff = su - (2 * j) 
            break
                        
    return diff 
        
a = [3, 1, 4, 2, 2, 1] 
n = len(a) 
        
print(&quot;The minimum difference between &quot;
      &quot;2 sets is &quot;, findMin(a, n)) 
</py>
  <orden>9</orden>
  <suborden>8</suborden>
  <fecha_creacion>2020-12-06 19:51:43</fecha_creacion>
  <fecha_modificacion>2022-03-08 12:19:51</fecha_modificacion>
</row>
<row>
  <ID>223</ID>
  <supergrupo>DP</supergrupo>
  <tema>Camino más largo en una matriz usando DP</tema>
  <texto>Dada una matriz n * n donde todos los números son distintos, encuentre la ruta de longitud máxima (comenzando desde cualquier celda) de modo que todas las celdas a lo largo de la ruta estén en orden creciente con una diferencia de 1.
Podemos movernos en 4 direcciones desde una celda dada (i, j), es decir, podemos movernos a (i + 1, j) o (i, j + 1) o (i-1, j) o (i, j -1) con la condición de que las celdas adyacentes tengan una diferencia de 1.
Ejemplo:
Entrada: mat [] [] = {{1, 2, 9}
                   {5, 3, 8}
                   {4, 6, 7}}
Salida: 4
El camino más largo es 6-7-8-9.
La idea es simple, calculamos la ruta más larga comenzando con cada celda. Una vez que hemos calculado el máximo para todas las celdas, devolvemos el máximo de todas las rutas más largas. Una observación importante en este enfoque son muchos subproblemas superpuestos. Por lo tanto, este problema se puede resolver de manera óptima mediante la programación dinámica.
A continuación se muestra una implementación basada en Programación dinámica que usa una tabla de búsqueda dp [] [] para verificar si un problema ya está resuelto o no.
La complejidad temporal de la solución es O (n2). Puede parecer más a primera vista. Si miramos más de cerca, podemos notar que todos los valores de dp [i] [j] se calculan solo una vez.
</texto>
  <complejidad_tiempo>null</complejidad_tiempo>
  <java>// Programa Java para encontrar la ruta más larga en una matriz con restricciones dadas

public class DPLongestPath {

    public static int n = 3;

    // Función que devuelve la longitud de la ruta más larga que comienza con mat [i] [j]
    // Esta función usa principalmente la tabla de búsqueda dp [n] [n]
    static int findLongestFromACell(int i, int j, int mat[][], int dp[][]) {
        // Base case 
        if (i &lt; 0 || i &gt;= n || j &lt; 0 || j &gt;= n) {
            return 0;
        }

        // Si este subproblema ya está resuelto
        if (dp[i][j] != -1) {
            return dp[i][j];
        }

        // Para almacenar las longitudes de la ruta en las cuatro direcciones
        int x = Integer.MIN_VALUE, y = Integer.MIN_VALUE, z = Integer.MIN_VALUE, w = Integer.MIN_VALUE;
        // Dado que todos los números son únicos y están en el 
        // rango de 1 an * n, hay al menos una dirección posible desde cualquier celda
        if (j &lt; n - 1 &amp;&amp; ((mat[i][j] + 1) == mat[i][j + 1])) {
            x = dp[i][j] = 1 + findLongestFromACell(i, j + 1, mat, dp);
        }

        if (j &gt; 0 &amp;&amp; (mat[i][j] + 1 == mat[i][j - 1])) {
            y = dp[i][j] = 1 + findLongestFromACell(i, j - 1, mat, dp);
        }

        if (i &gt; 0 &amp;&amp; (mat[i][j] + 1 == mat[i - 1][j])) {
            z = dp[i][j] = 1 + findLongestFromACell(i - 1, j, mat, dp);
        }

        if (i &lt; n - 1 &amp;&amp; (mat[i][j] + 1 == mat[i + 1][j])) {
            w = dp[i][j] = 1 + findLongestFromACell(i + 1, j, mat, dp);
        }

        // Si ninguno de los cuatro adyacentes es uno mayor, tomaremos 1; 
        // de lo contrario, elegiremos el máximo de las cuatro direcciones.
        return dp[i][j] = Math.max(x, Math.max(y, Math.max(z, Math.max(w, 1))));
    }

    // Función que devuelve la longitud de la ruta más 
    // larga que comienza con cualquier celda
    static int finLongestOverAll(int mat[][]) {
        // Inicializar resultado
        int result = 1;

        // Cree una tabla de búsqueda y complete todas las entradas en ella como -1
        int[][] dp = new int[n][n];
        for (int i = 0; i &lt; n; i++) {
            for (int j = 0; j &lt; n; j++) {
                dp[i][j] = -1;
            }
        }

        // Calcule la ruta más larga comenzando desde todas las celdas
        for (int i = 0; i &lt; n; i++) {
            for (int j = 0; j &lt; n; j++) {
                if (dp[i][j] == -1) {
                    findLongestFromACell(i, j, mat, dp);
                }

                // Actualizar el resultado si es necesario
                result = Math.max(result, dp[i][j]);
            }
        }

        return result;
    }

    public static void main(String[] args) {
        int mat[][] = {{1, 2, 9},
        {5, 3, 8},
        {4, 6, 7}};
        System.out.println(&quot;Length of the longest path is &quot; + finLongestOverAll(mat));
    }
}
</java>
  <cpp>#include &lt;bits/stdc++.h&gt; 
#define n 3 
using namespace std;

int findLongestFromACell(int i, int j, int mat[n][n], int dp[n][n]) {
    if (i &lt; 0 || i &gt;= n || j &lt; 0 || j &gt;= n)
        return 0;
    if (dp[i][j] != -1)
        return dp[i][j];
    int x = INT_MIN, y = INT_MIN, z = INT_MIN, w = INT_MIN;

    if (j &lt; n - 1 &amp;&amp; ((mat[i][j] + 1) == mat[i][j + 1]))
        x = 1 + findLongestFromACell(i, j + 1, mat, dp);

    if (j &gt; 0 &amp;&amp; (mat[i][j] + 1 == mat[i][j - 1]))
        y = 1 + findLongestFromACell(i, j - 1, mat, dp);

    if (i &gt; 0 &amp;&amp; (mat[i][j] + 1 == mat[i - 1][j]))
        z = 1 + findLongestFromACell(i - 1, j, mat, dp);

    if (i &lt; n - 1 &amp;&amp; (mat[i][j] + 1 == mat[i + 1][j]))
        w = 1 + findLongestFromACell(i + 1, j, mat, dp);

    return dp[i][j] = max(x, max(y, max(z, max(w, 1))));
}

int finLongestOverAll(int mat[n][n]) {
    int result = 1;
    int dp[n][n];
    memset(dp, -1, sizeof dp);
    for (int i = 0; i &lt; n; i++) {
        for (int j = 0; j &lt; n; j++) {
            if (dp[i][j] == -1)
                findLongestFromACell(i, j, mat, dp);
            result = max(result, dp[i][j]);
        }
    }

    return result;
}

int main() {
    int mat[n][n] = {
        { 1, 2, 9},
        { 5, 3, 8},
        { 4, 6, 7}
    };
    cout &lt;&lt; &quot;Length of the longest path is &quot;
            &lt;&lt; finLongestOverAll(mat);
    return 0;
} 
</cpp>
  <py>n = 3 
def findLongestFromACell(i, j, mat, dp): 

    if (i &lt; 0 or i &gt;= n or j &lt; 0 or j &gt;= n): 
        return 0

    if (dp[i][j] != -1):  
        return dp[i][j] 
    x, y, z, w = -1, -1, -1, -1
    if (j &lt; n-1 and ((mat[i][j] + 1) == mat[i][j + 1])): 
        x = 1 + findLongestFromACell(i, j + 1, mat, dp) 
  
    if (j &gt; 0 and (mat[i][j] + 1 == mat[i][j-1])):  
        y = 1 + findLongestFromACell(i, j-1, mat, dp) 
  
    if (i &gt; 0 and (mat[i][j] + 1 == mat[i-1][j])): 
        z = 1 + findLongestFromACell(i-1, j, mat, dp) 
  
    if (i &lt; n-1 and (mat[i][j] + 1 == mat[i + 1][j])): 
        w = 1 + findLongestFromACell(i + 1, j, mat, dp) 
    dp[i][j] = max(x, max(y, max(z, max(w, 1)))) 
    return dp[i][j] 
  
def finLongestOverAll(mat): 
    result = 1 
    dp = [[-1 for i in range(n)]for i in range(n)] 
    for i in range(n): 
        for j in range(n): 
            if (dp[i][j] == -1): 
                findLongestFromACell(i, j, mat, dp) 
            result = max(result, dp[i][j]);  
    return result 
  
mat = [[1, 2, 9], 
    [5, 3, 8], 
    [4, 6, 7]]  
print(&quot;Length of the longest path is &quot;, finLongestOverAll(mat)) 
</py>
  <orden>9</orden>
  <suborden>9</suborden>
  <fecha_creacion>2020-12-06 19:51:43</fecha_creacion>
  <fecha_modificacion>2022-03-08 12:19:51</fecha_modificacion>
</row>
<row>
  <ID>224</ID>
  <supergrupo>Grafos</supergrupo>
  <tema>Puntos de articulación</tema>
  <texto>Un vértice en un gráfico conectado no dirigido es un punto de articulación (o vértice de corte) si al eliminarlo (y las aristas a través de él) se desconecta el gráfico. Los puntos de articulación representan vulnerabilidades en una red conectada: puntos únicos cuya falla dividiría la red en 2 o más componentes. Son útiles para diseñar redes confiables.
Para un gráfico no dirigido desconectado, un punto de articulación es una eliminación de vértices que aumenta el número de componentes conectados.
A continuación se muestran algunos ejemplos de gráficos con puntos de articulación rodeados de color rojo.

¿Cómo encontrar todos los puntos de articulación en un gráfico dado?
Un enfoque simple es eliminar uno por uno todos los vértices y ver si la eliminación de un vértice causa un gráfico desconectado. Los siguientes son pasos de enfoque simple para gráficos conectados.
1) Para cada vértice v, haga lo siguiente
… ..A) Eliminar v del gráfico
..… b) Vea si el gráfico permanece conectado (podemos usar BFS o DFS)
… ..C) Suma v de nuevo al gráfico

La complejidad del tiempo del método anterior es O (V * (V + E)) para un gráfico representado mediante una lista de adyacencia. ¿Podemos hacerlo mejor?

Un algoritmo O (V + E) para encontrar todos los puntos de articulación (AP)
La idea es utilizar DFS (Depth First Search). En DFS, seguimos los vértices en forma de árbol llamados árbol DFS. En el árbol DFS, un vértice u es padre de otro vértice v, si v es descubierto por u (obviamente v es un adyacente de u en el gráfico). En el árbol DFS, un vértice u es un punto de articulación si se cumple una de las dos condiciones siguientes.
1) u es la raíz del árbol DFS y tiene al menos dos hijos.
2) u no es la raíz del árbol DFS y tiene un hijo v tal que ningún vértice en el subárbol enraizado con v tiene una arista posterior a uno de los antepasados (en el árbol DFS) de u.

Hacemos un recorrido DFS de un gráfico dado con código adicional para averiguar los puntos de articulación (AP). En el recorrido DFS, mantenemos una matriz padre [] donde padre [u] almacena padre del vértice u. Entre los dos casos mencionados anteriormente, el primer caso es fácil de detectar. Para cada vértice, cuente los niños. Si el vértice u actualmente visitado es raíz (el padre [u] es NULO) y tiene más de dos hijos, imprímalo.

¿Cómo manejar el segundo caso? El segundo caso es más complicado. Mantenemos un disc de matriz [] para almacenar el tiempo de descubrimiento de los vértices. Para cada nodo u, necesitamos encontrar el vértice visitado más temprano (el vértice con el tiempo mínimo de descubrimiento) que se puede alcanzar desde el subárbol enraizado con u. Así que mantenemos una matriz adicional baja [] que se define de la siguiente manera.

low [u] = min (disc [u], disc [w])
donde w es un antepasado de u y hay una arista posterior de
algún descendiente de u a w.
</texto>
  <complejidad_tiempo>null</complejidad_tiempo>
  <java>//Encontrando los puntos de articulación en un grafo no dirigido 

import java.util.Iterator;
import java.util.LinkedList;


public class ArticulationBridges {
    // Esta clase representa un gráfico no dirigido 
    // usando una lista de adyacencia
    static class Graph {

        private int V; // No. de vertices 

        // array de listas para la representación de la adyacencia
        private LinkedList&lt;Integer&gt; adj[];
        int time = 0;
        static final int NIL = -1;
        Graph(int v) {
            V = v;
            adj = new LinkedList[v];
            for (int i = 0; i &lt; v; ++i) {
                adj[i] = new LinkedList();
            }
        }

        //Agregar caminos en el grafo
        void addEdge(int v, int w) {
            adj[v].add(w); 
            adj[w].add(v); 
        }

        //Una función recursiva que encuentra puntos de articulación usando DFS
        //u -&gt; El vértice a visitar a continuación
        //visited [] -&gt; mantiene un tramo de vértices visitados
        //disc [] -&gt; Almacena las veces de descubrimiento de los vértices visitados
        //parent [] -&gt; Almacena los vértices principales en el árbol DFS
        //ap [] -&gt; Almacenar puntos de articulación
        void APUtil(int u, boolean visited[], int disc[],
                int low[], int parent[], boolean ap[]) {

            // conteo de hijos en el arbol de DFS
            int children = 0;

            // Marcando el nodo actual como visitado
            visited[u] = true;

            // Inicializar las veces de descubrimiento y el valor bajo
            disc[u] = low[u] = ++time;

            // Pasa por todos los vértices adyacentes a este
            Iterator&lt;Integer&gt; i = adj[u].iterator();
            while (i.hasNext()) {
                int v = i.next(); // v es adyacente de u 
                //Si v aún no se ha visitado, conviértalo en hijo de u en el 
                //árbol DFS y recurse para él
                if (!visited[v]) {
                    children++;
                    parent[v] = u;
                    APUtil(v, visited, disc, low, parent, ap);

                    //Compruebe si el subárbol enraizado con v 
                    //tiene una conexión con uno de los antepasados de u
                    low[u] = Math.min(low[u], low[v]);

                    //u es un punto de articulación en los siguientes casos
                    //(1) u es la raíz del árbol DFS y tiene dos o más hijos.
                    if (parent[u] == NIL &amp;&amp; children &gt; 1) {
                        ap[u] = true;
                    }

                    //(2) Si u no es raíz y el valor bajo de uno de sus hijos es 
                    //mayor que el valor de descubrimiento de u.
                    if (parent[u] != NIL &amp;&amp; low[v] &gt;= disc[u]) {
                        ap[u] = true;
                    }
                } // Actualice el valor bajo de u para las llamadas a funciones 
                  // padre.
                else if (v != parent[u]) {
                    low[u] = Math.min(low[u], disc[v]);
                }
            }
        }

        // La función para hacer un recorrido DFS. Utiliza la función recursiva APUtil ()
        void AP() {
            boolean visited[] = new boolean[V];
            int disc[] = new int[V];
            int low[] = new int[V];
            int parent[] = new int[V];
            boolean ap[] = new boolean[V]; // para almacenar los puntos 
            //de articulación

            // Inicializar matrices parent y 
            //visited, y ap (punto de articulación)
            for (int i = 0; i &lt; V; i++) {
                parent[i] = NIL;
                visited[i] = false;
                ap[i] = false;
            }
            //Llame a la función auxiliar recursiva para encontrar puntos de 
            //articulación en el árbol DFS enraizado con el vértice &#39;i&#39;
            for (int i = 0; i &lt; V; i++) {
                if (visited[i] == false) {
                    APUtil(i, visited, disc, low, parent, ap);
                }
            }

            // Ahora ap [] contiene puntos de articulación, imprímalos
            for (int i = 0; i &lt; V; i++) {
                if (ap[i] == true) {
                    System.out.print(i + &quot; &quot;);
                }
            }
        }
    }

    public static void main(String args[]) {
        System.out.println(&quot;Puntos de articulación en el grafo &quot;);
        Graph g1 = new Graph(5);
        g1.addEdge(1, 0);
        g1.addEdge(0, 2);
        g1.addEdge(2, 1);
        g1.addEdge(0, 3);
        g1.addEdge(3, 4);
        g1.AP();
        System.out.println();

        System.out.println(&quot;Puntos de articulación en el grafo&quot;);
        Graph g2 = new Graph(4);
        g2.addEdge(0, 1);
        g2.addEdge(1, 2);
        g2.addEdge(2, 3);
        g2.AP();
        System.out.println();

        System.out.println(&quot;Puntos de articulación en el grafo &quot;);
        Graph g3 = new Graph(7);
        g3.addEdge(0, 1);
        g3.addEdge(1, 2);
        g3.addEdge(2, 0);
        g3.addEdge(1, 3);
        g3.addEdge(1, 4);
        g3.addEdge(1, 6);
        g3.addEdge(3, 5);
        g3.addEdge(4, 5);
        g3.AP();
    }
}
</java>
  <cpp>#include &lt;cstdlib&gt;
#include &lt;bits/stdc++.h&gt;
#define  MAX 105
using namespace std;

struct Graph {
    int V;
    vector&lt;int&gt; adj[MAX];
    int time = 0;
    int NIL = -1;

    void addEdge(int v, int w) {
        adj[v].emplace_back(w);
        adj[w].emplace_back(v);
    }

    void APUtil(int u, bool visited[], int disc[],
            int low[], int parent[], bool ap[]) {
        static int time = 0;
        int children = 0;
        visited[u] = true;
        disc[u] = low[u] = ++time;
        for (int i = 0; i &lt; adj[u].size(); i++) {
            int v = adj[u].at(i);
            if (!visited[v]) {
                children++;
                parent[v] = u;
                APUtil(v, visited, disc, low, parent, ap);
                low[u] = min(low[u], low[v]);
                if (parent[u] == NIL &amp;&amp; children &gt; 1)
                    ap[u] = true;
                if (parent[u] != NIL &amp;&amp; low[v] &gt;= disc[u])
                    ap[u] = true;
            } else if (v != parent[u])
                low[u] = min(low[u], disc[v]);
        }
    }

    void AP() {
        bool visited[V];
        int disc[V];
        int low [V];
        int parent[V];
        bool ap[V];
        for (int i = 0; i &lt; V; i++) {
            parent[i] = NIL;
            visited[i] = false;
            ap[i] = false;
        }
        for (int i = 0; i &lt; V; i++)
            if (visited[i] == false)
                APUtil(i, visited, disc, low, parent, ap);
        for (int i = 0; i &lt; V; i++)
            if (ap[i] == true)
                cout &lt;&lt; i &lt;&lt; &quot; &quot;;
    }


};

int main() {
    // Create graphs given in above diagrams 
    cout &lt;&lt; &quot;Puntos de articulación en el grafo&quot; &lt;&lt; endl;
    Graph g1;
    g1.V = 5;
    g1.addEdge(1, 0);
    g1.addEdge(0, 2);
    g1.addEdge(2, 1);
    g1.addEdge(0, 3);
    g1.addEdge(3, 4);
    g1.AP();
    cout &lt;&lt; endl;

    cout &lt;&lt; &quot;Puntos de articulación en el grafo&quot; &lt;&lt; endl;
    Graph g2;
    g2.V = 4;
    g2.addEdge(0, 1);
    g2.addEdge(1, 2);
    g2.addEdge(2, 3);
    g2.AP();
    cout &lt;&lt; endl;

    cout &lt;&lt; &quot;Puntos de articulación en el grafo&quot; &lt;&lt; endl;
    Graph g3;
    g3.V=7;
    g3.addEdge(0, 1);
    g3.addEdge(1, 2);
    g3.addEdge(2, 0);
    g3.addEdge(1, 3);
    g3.addEdge(1, 4);
    g3.addEdge(1, 6);
    g3.addEdge(3, 5);
    g3.addEdge(4, 5);
    g3.AP();
}
</cpp>
  <py>from collections import defaultdict 

class Graph: 
        def __init__(self,vertices): 
                self.V= vertices 
                self.graph = defaultdict(list)
                self.Time = 0
        def addEdge(self,u,v): 
                self.graph[u].append(v) 
                self.graph[v].append(u) 
        def APUtil(self,u, visited, ap, parent, low, disc): 
                children =0
                visited[u]= True
                disc[u] = self.Time 
                low[u] = self.Time 
                self.Time += 1
                for v in self.graph[u]: 
                        if visited[v] == False : 
                                parent[v] = u 
                                children += 1
                                self.APUtil(v, visited, ap, parent, low, disc) 
                                low[u] = min(low[u], low[v]) 
                                if parent[u] == -1 and children &gt; 1: 
                                        ap[u] = True
                                if parent[u] != -1 and low[v] &gt;= disc[u]: 
                                        ap[u] = True                     
                        elif v != parent[u]: 
                                low[u] = min(low[u], disc[v]) 
        def AP(self): 
                visited = [False] * (self.V) 
                disc = [float(&quot;Inf&quot;)] * (self.V) 
                low = [float(&quot;Inf&quot;)] * (self.V) 
                parent = [-1] * (self.V) 
                ap = [False] * (self.V) 
                for i in range(self.V): 
                        if visited[i] == False: 
                                self.APUtil(i, visited, ap, parent, low, disc) 
                for index, value in enumerate (ap): 
                        if value == True: print index, 
g1 = Graph(5) 
g1.addEdge(1, 0) 
g1.addEdge(0, 2) 
g1.addEdge(2, 1) 
g1.addEdge(0, 3) 
g1.addEdge(3, 4) 
print &quot;Puntos de articulacion en el grafo &quot;
g1.AP() 
g2 = Graph(4) 
g2.addEdge(0, 1) 
g2.addEdge(1, 2) 
g2.addEdge(2, 3) 
print &quot;Puntos de articulacion en el grafo &quot;
g2.AP() 
g3 = Graph (7) 
g3.addEdge(0, 1) 
g3.addEdge(1, 2) 
g3.addEdge(2, 0) 
g3.addEdge(1, 3) 
g3.addEdge(1, 4) 
g3.addEdge(1, 6) 
g3.addEdge(3, 5) 
g3.addEdge(4, 5) 
print &quot;Puntos de articulacion en el grafo &quot;
g3.AP() 
</py>
  <orden>8</orden>
  <suborden>28</suborden>
  <fecha_creacion>2020-12-06 19:51:44</fecha_creacion>
  <fecha_modificacion>2022-03-08 12:28:52</fecha_modificacion>
</row>
<row>
  <ID>225</ID>
  <supergrupo>Grafos</supergrupo>
  <tema>Puentes </tema>
  <texto>Una arista en un gráfico conectado no dirigido es un puente si, al eliminarlo, se desconecta el gráfico. Para un gráfico desconectado no dirigido, la definición es similar, un puente es una eliminación de aristas que aumenta el número de componentes desconectados.
Al igual que los puntos de articulación, los puentes representan vulnerabilidades en una red conectada y son útiles para diseñar redes confiables. Por ejemplo, en una red de computadoras cableada, un punto de articulación indica las computadoras críticas y un puente indica los cables o conexiones críticas.
A continuación se muestran algunos gráficos de ejemplo con puentes resaltados en color rojo.

¿Cómo encontrar todos los puentes en un gráfico dado?
Un enfoque simple es eliminar uno por uno todos las aristas y ver si la eliminación de una arista provoca un gráfico desconectado. Los siguientes son pasos de enfoque simple para gráficos conectados.
1) Para cada arista (u, v), haga lo siguiente
… ..A) Eliminar (u, v) del gráfico
..… b) Vea si el gráfico permanece conectado (podemos usar BFS o DFS)
… ..C) Suma (u, v) de nuevo al gráfico.

La complejidad de tiempo del método anterior es O (E * (V + E)) para un gráfico representado usando una lista de adyacencia. ¿Podemos hacerlo mejor?
Un algoritmo O (V + E) para encontrar todos los puentes
La idea es similar al algoritmo O (V + E) para los puntos de articulación. Hacemos un recorrido DFS del gráfico dado. En el árbol DFS, una arista (u, v) (u es el padre de v en el árbol DFS) es puente si no existe ninguna otra alternativa para llegar a u o un ancestro de u del subárbol enraizado con v, el valor low [v] indica el vértice visitado más temprano que se puede alcanzar desde el subárbol enraizado con v. La condición para que una arista (u, v) sea un puente es &quot;low [v]&gt; disc [u]&quot;.
</texto>
  <complejidad_tiempo>null</complejidad_tiempo>
  <java>// buscando los puentes en un grafo

import java.util.Iterator;
import java.util.LinkedList;

public class BridgesInGraph {

    static private int V; // No. de vertices 

    // Array de listas representando el grafo
    static private LinkedList&lt;Integer&gt; adj[];
    static int time = 0;
    static final int NIL = -1;

    static void init(int v) {
        V = v;
        adj = new LinkedList[v];
        for (int i = 0; i &lt; v; ++i) {
            adj[i] = new LinkedList();
        }
    }

    // Agregando caminos en el grafo
    static void addEdge(int v, int w) {
        adj[v].add(w);
        adj[w].add(v);
    }

    // Una función recursiva que busca e imprime puentes
    // usando DFS transversal
    // u -&gt; El vértice a visitar a continuación
    // visited [] -&gt; mantiene un tramo de vértices visitados
    // disc [] -&gt; Almacena las veces de descubrimiento de los vértices visitados
    // parent [] -&gt; Almacena los vértices padre en el árbol DFS
    static void bridgeUtil(int u, boolean visited[], int disc[],
            int low[], int parent[]) {
        // Marcar nodo actual como visitado
        visited[u] = true;
        // Inicializar el tiempo de descubrimiento y el valor bajo
        disc[u] = low[u] = ++time;

        // Pasa por todos los vértices adyacentes a este
        Iterator&lt;Integer&gt; i = adj[u].iterator();
        while (i.hasNext()) {
            int v = i.next(); // v es la corriente adyacente a u

            // Si v aún no se ha visitado, conviértalo en hijo
            // de u en el árbol DFS y recurra en el.
            // Si v aún no se ha visitado, repita para ello
            if (!visited[v]) {
                parent[v] = u;
                bridgeUtil(v, visited, disc, low, parent);

                //Compruebe si el subárbol enraizado con v tiene 
                //una conexión con uno de los antepasados de u
                low[u] = Math.min(low[u], low[v]);

                //Si el vértice más bajo accesible desde el subárbol 
                //debajo de v está debajo de u en el árbol DFS, 
                //entonces u-v es un puente
                if (low[v] &gt; disc[u]) {
                    System.out.println(u + &quot; &quot; + v);
                }
            } // Actualice el valor bajo de u para las llamadas a funciones principales. 
            else if (v != parent[u]) {
                low[u] = Math.min(low[u], disc[v]);
            }
        }
    }

    // Función basada en DFS para encontrar todos los puentes. 
    // Utiliza la función recursiva bridgeUtil ()
    static void bridge() {
        // Marcar todos los vértices como no visitados
        boolean visited[] = new boolean[V];
        int disc[] = new int[V];
        int low[] = new int[V];
        int parent[] = new int[V];

        // Inicializa parent, visited, y ap(articulation point)
        for (int i = 0; i &lt; V; i++) {
            parent[i] = NIL;
            visited[i] = false;
        }

        //Llame a la función auxiliar recursiva para encontrar 
        //puentes en el árbol DFS enraizado con el vértice &#39;i&#39;
        for (int i = 0; i &lt; V; i++) {
            if (visited[i] == false) {
                bridgeUtil(i, visited, disc, low, parent);
            }
        }
    }

    public static void main(String args[]) {
        System.out.println(&quot;Bridges in first graph &quot;);
        init(5);
        addEdge(1, 0);
        addEdge(0, 2);
        addEdge(2, 1);
        addEdge(0, 3);
        addEdge(3, 4);
        bridge();
        System.out.println();
        System.out.println(&quot;Bridges in second graph &quot;);
        init(4);
        addEdge(0, 1);
        addEdge(1, 2);
        addEdge(2, 3);
        bridge();
        System.out.println();

    }
}
</java>
  <cpp>#include&lt;iostream&gt; 
#include &lt;list&gt; 
#define NIL -1 
#define MAX 10000
using namespace std;

struct Graph {
    int V;
    list&lt;int&gt; adj[MAX];

    void addEdge(int v, int w) {
        adj[v].push_back(w);
        adj[w].push_back(v);
    }

    void bridgeUtil(int u, bool visited[], int disc[],
            int low[], int parent[]) {
        static int time = 0;
        visited[u] = true;
        disc[u] = low[u] = ++time;
        list&lt;int&gt;::iterator i;
        for (i = adj[u].begin(); i != adj[u].end(); ++i) {
            int v = *i;
            if (!visited[v]) {
                parent[v] = u;
                bridgeUtil(v, visited, disc, low, parent);
                low[u] = min(low[u], low[v]);
                if (low[v] &gt; disc[u])
                    cout &lt;&lt; u &lt;&lt; &quot; &quot; &lt;&lt; v &lt;&lt; endl;
            } else if (v != parent[u])
                low[u] = min(low[u], disc[v]);
        }
    }

    void bridge() {
        bool visited[V];
        int disc [V];
        int low [V];
        int parent[V];

        for (int i = 0; i &lt; V; i++) {
            parent[i] = NIL;
            visited[i] = false;
        }
        for (int i = 0; i &lt; V; i++)
            if (visited[i] == false)
                bridgeUtil(i, visited, disc, low, parent);
    }
};

int main() {
    cout &lt;&lt; &quot;\nBridges in first graph \n&quot;;
    Graph g1;
    g1.V = 5;
    g1.addEdge(1, 0);
    g1.addEdge(0, 2);
    g1.addEdge(2, 1);
    g1.addEdge(0, 3);
    g1.addEdge(3, 4);
    g1.bridge();

    cout &lt;&lt; &quot;\nBridges in second graph \n&quot;;
    Graph g2;
    g2.V = 2;
    g2.addEdge(0, 1);
    g2.addEdge(1, 2);
    g2.addEdge(2, 3);
    g2.bridge();
}
</cpp>
  <py>from collections import defaultdict
 
class Graph: 

    def __init__(self, vertices): 
        self.V = vertices 
        self.graph = defaultdict(list) 
        self.Time = 0
    def addEdge(self, u, v): 
        self.graph[u].append(v) 
        self.graph[v].append(u) 

    def bridgeUtil(self, u, visited, parent, low, disc): 
        visited[u] = True
        disc[u] = self.Time 
        low[u] = self.Time 
        self.Time += 1
        for v in self.graph[u]: 
            if visited[v] == False: 
                parent[v] = u 
                self.bridgeUtil(v, visited, parent, low, disc) 
                low[u] = min(low[u], low[v]) 
                if low[v] &gt; disc[u]: 
                    print (&quot;%d %d&quot; % (u, v)) 
                
            elif v != parent[u]: 
                low[u] = min(low[u], disc[v]) 

    def bridge(self): 
        visited = [False] * (self.V) 
        disc = [float(&quot;Inf&quot;)] * (self.V) 
        low = [float(&quot;Inf&quot;)] * (self.V) 
        parent = [-1] * (self.V) 

        for i in range(self.V): 
            if visited[i] == False: 
                self.bridgeUtil(i, visited, parent, low, disc) 

g1 = Graph(5) 
g1.addEdge(1, 0) 
g1.addEdge(0, 2) 
g1.addEdge(2, 1) 
g1.addEdge(0, 3) 
g1.addEdge(3, 4) 


print &quot;Bridges in first graph &quot;
g1.bridge() 

g2 = Graph(4) 
g2.addEdge(0, 1) 
g2.addEdge(1, 2) 
g2.addEdge(2, 3) 
print &quot;\nBridges in second graph &quot;
g2.bridge() 
</py>
  <orden>8</orden>
  <suborden>29</suborden>
  <fecha_creacion>2020-12-06 19:51:44</fecha_creacion>
  <fecha_modificacion>2022-03-08 12:28:52</fecha_modificacion>
</row>
<row>
  <ID>226</ID>
  <supergrupo>Grafos</supergrupo>
  <tema>Combinatorias en arboles ordenados</tema>
  <texto>Un árbol ordenado es un árbol orientado en el que los hijos de un nodo están ordenados de alguna manera. Es un árbol enraizado en el que se especifica un orden para los hijos de cada vértice. A esto se le llama “árbol plano” porque ordenar los hijos equivale a incrustar el árbol en el plano, con la raíz en la parte superior y los hijos de cada vértice más abajo que ese vértice.
El árbol ordenado se puede especificar más como árbol ordenado etiquetado y árbol ordenado no etiquetado.
Árboles ordenados etiquetados: un árbol etiquetado es un árbol donde a cada vértice se le asigna un número único de 1 a n.
 
Si T1 y T2 son árboles ordenados. Entonces, T1! = T2 de lo contrario T1 = T2.

Árboles ordenados sin etiquetar: un árbol sin etiquetar es un árbol en el que cada vértice no está etiquetado. A continuación se muestran los posibles árboles ordenados sin etiquetar que tienen 3 vértices.
</texto>
  <complejidad_tiempo>null</complejidad_tiempo>
  <java>// código java para encontrar el número de 
//árboles ordenados con un número determinado 
//de bordes y hojas

public class CombinatoricsOnOrderedTrees {

    // La función devuelve el valor del
    // Coeficiente binomial C (n, k)
    static int binomialCoeff(int n, int k) {
        int[][] C = new int[n + 1][k + 1];
        int i, j;
        // Calculate value of Binomial 
        // Coefficient in bottom up manner 
        for (i = 0; i &lt;= n; i++) {
            for (j = 0; j &lt;= Math.min(i, k); j++) {
                if (j == 0 || j == i) {
                    C[i][j] = 1;
                } // Calcular valor usando valores previamente almacenados
                else {
                    C[i][j] = C[i - 1][j - 1]
                            + C[i - 1][j];
                }
            }
        }
        return C[n][k];
    }

    // Función para calcular el número
    // de árboles con exactamente k hojas.
    static int k_Leaves(int n, int k) {
        int ans = (binomialCoeff(n, k)
                * binomialCoeff(n, k - 1)) / n;
        System.out.println(&quot;Number of trees &quot;
                + &quot;having 4 edges and exactly 2 &quot;
                + &quot;leaves : &quot; + ans);
        return 0;
    }

    // Función para calcular el número total de
    // nodos de grado d en estos árboles.
    static int numberOfNodes(int n, int d) {
        int ans = binomialCoeff(2 * n - 1 - d,
                n - 1);
        System.out.println(&quot;Number of nodes &quot;
                + &quot;of degree 1 in a tree having 4 &quot;
                + &quot;edges : &quot; + ans);
        return 0;
    }

    // Función para calcular el número de
    // árboles en los que la raíz tiene grado r.
    static int rootDegreeR(int n, int r) {
        int ans = r * binomialCoeff(2 * n
                - 1 - r, n - 1);
        ans = ans / n;
        System.out.println(&quot;Number of trees &quot;
                + &quot;having 4 edges where root has&quot;
                + &quot; degree 2 : &quot; + ans);
        return 0;
    }

    public static void main(String[] args) {
        // Número de árboles que tienen 3
        // caminos y exactamente 2 hojas
        k_Leaves(3, 2);
        // Número de nodos de grado
        // 3 en un árbol que tiene 4 caminos
        numberOfNodes(3, 1);
        // Número de árboles que tienen 3
        // caminos donde la raíz tiene grado 2
        rootDegreeR(3, 2);
    }
}
</java>
  <cpp>#include&lt;bits/stdc++.h&gt; 
#include&lt;cstdlib&gt;
using namespace std;

int binomialCoeff(int n, int k) {
    int C [n + 1][k + 1] = {0};
    int i, j;
    for (i = 0; i &lt;= n; i++) {
        for (j = 0; j &lt;= min(i, k); j++) {
            if (j == 0 || j == i) {
                C[i][j] = 1;
            } else {
                C[i][j] = C[i - 1][j - 1] + C[i - 1][j];
            }
        }
    }
    return C[n][k];
}

static int k_Leaves(int n, int k) {
    int ans = (binomialCoeff(n, k)
            * binomialCoeff(n, k - 1)) / n;
    cout &lt;&lt; &quot;Number of trees having 4 edges and exactly 2 leaves : &quot;
            &lt;&lt; ans &lt;&lt; endl;
    return 0;
}

static int numberOfNodes(int n, int d) {
    int ans = binomialCoeff(2 * n - 1 - d, n - 1);
    cout &lt;&lt; &quot;Number of nodes of degree 1 in a tree having 4 edges : &quot;
            &lt;&lt; ans &lt;&lt; endl;
    return 0;
}

static int rootDegreeR(int n, int r) {
    int ans = r * binomialCoeff(2 * n
            - 1 - r, n - 1);
    ans = ans / n;
    cout &lt;&lt; &quot;Number of trees having 4 edges where root has degree 2 : &quot;
            &lt;&lt; ans &lt;&lt; endl;
    return 0;
}

int main() {
    k_Leaves(3, 2);
    numberOfNodes(3, 1);
    rootDegreeR(3, 2);
}
</cpp>
  <py>import math
def binomialCoeff(n, k):
    C = [[0 for i in range(k + 1)] for i in range (n + 1)]
    for i in range (n + 1):
        aux = min(i, k)
        for j in range (aux + 1):
            if (j == 0 or j == i):
                C[i][j] = 1
            else:
                C[i][j] = C[i - 1][j - 1] + C[i - 1][j];
    return C[n][k];

def k_Leaves(n, k):
    ans = (binomialCoeff(n, k) * binomialCoeff(n, k - 1)) / n
    print(&quot;Number of trees having 4 edges and exactly 2 leaves : &quot; + str(ans))

def numberOfNodes(n, d):
    ans = binomialCoeff(2 * n - 1 - d, n - 1);
    print(&quot;Number of nodes of degree 1 in a tree having 4 edges : &quot; + str(ans))

def rootDegreeR(n, r):
    ans = r * binomialCoeff(2 * n- 1 - r, n - 1)
    ans = ans / n
    print(&quot;Number of trees having 4 edges where root has degree 2 : &quot; + str(ans))

k_Leaves(3, 2); 
numberOfNodes(3, 1); 
rootDegreeR(3, 2);
</py>
  <orden>8</orden>
  <suborden>30</suborden>
  <fecha_creacion>2020-12-06 19:51:44</fecha_creacion>
  <fecha_modificacion>2022-03-08 12:28:52</fecha_modificacion>
</row>
<row>
  <ID>227</ID>
  <supergrupo>Grafos</supergrupo>
  <tema>Conjuntos disjuntos</tema>
  <texto>Considere una situación con varias personas y las siguientes tareas que se realizarán en ellas.
1. Agregue una nueva relación de amistad, es decir, una persona x se convierte en amiga de otra persona y.
2. Encuentre si el individuo x es amigo del individuo y (amigo directo o indirecto)
Ejemplo:
Nos dan 10 personas que dicen:
a, b, c, d, e, f, g, h, yo, j

A continuación se muestran las relaciones que se agregarán.
a &lt;-&gt; b
b &lt;-&gt; d
c &lt;-&gt; f
c &lt;-&gt; i
j &lt;-&gt; e
g &lt;-&gt; j
Y dadas consultas como si a es amigo de d o no.
Básicamente, necesitamos crear los siguientes 4 grupos y mantener una conexión de acceso rápido entre los elementos del grupo:
G1 = {a, b, d}
G2 = {c, f, i}
G3 = {e, g, j}
G4 = {h}
Problema: Encontrar si xey pertenecen al mismo grupo o no, es decir, encontrar si xey son amigos directos / indirectos.
Solución: dividir a los individuos en diferentes conjuntos de acuerdo con los grupos en los que se encuentran. Este método se conoce como estructura de datos de conjuntos disjuntos que mantiene la colección de conjuntos disjuntos y cada conjunto está representado por su representante, que es uno de sus miembros.
Aproximación:
• ¿Cómo resolver conjuntos? Inicialmente, todos los elementos pertenecen a conjuntos diferentes. Después de trabajar en las relaciones dadas, seleccionamos a un miembro como representante. Puede haber muchas formas de seleccionar un representante, una simple es seleccionar con el índice más grande.
• ¿Compruebe si hay 2 personas en el mismo grupo? Si los representantes de dos personas son iguales, se harán amigos.
 
Estructuras de datos utilizadas:
Array: una array de enteros, denominada padre []. Si estamos tratando con n elementos, el elemento i de la array representa el elemento i. Más precisamente, el i-ésimo elemento de la array es el padre del i-ésimo elemento. Estas relaciones crean uno o más árboles virtuales.
Árbol: es un conjunto disjunto. Si dos elementos están en el mismo árbol, entonces están en el mismo conjunto disjunto. El nodo raíz (o el nodo más alto) de cada árbol se denomina representante del conjunto. Siempre hay un único representante de cada conjunto. Una regla simple para identificar al representante es, si i es el representante de un conjunto, entonces padre [i] = i. Si yo no es el representante de su conjunto, entonces se puede encontrar viajando por el árbol hasta que encontremos al representante.
 
Operaciones:
Buscar: se puede implementar atravesando recursivamente la array principal hasta que lleguemos a un nodo que es padre de sí mismo.
// Encuentra al representante del conjunto
// que yo es un elemento de
int encontrar (int i)
{
    // Si i es el padre de sí mismo
    si (padre [i] == i)
    {
        // Entonces yo es el representante de
        // este conjunto
        volver i;
    }
    más
    {
        // De lo contrario, si yo no es el padre de
        // en sí mismo, entonces yo no es el
        // representante de su conjunto. Así que nosotros
        // llama recursivamente Find en su padre
        return find (padre [i]);
    }
}
Unión: Toma como insumo dos elementos. Y encuentra los representantes de sus conjuntos usando la operación de búsqueda, y finalmente coloca uno de los árboles (que representa el conjunto) debajo del nodo raíz del otro árbol, fusionando efectivamente los árboles y los conjuntos.
// Une el conjunto que incluye i
// y el conjunto que incluye j
unión vacía (int i, int j)
{
    // Encuentra los representantes
    // (o los nodos raíz) para el conjunto
    // eso incluye i
    
    int irep = this.Find (i),

    // Y haz lo mismo con el set
    // eso incluye j
    int jrep = this.Find (j);

    // Hacer el padre del representante de i
    // ser el representante de j de forma eficaz
    // moviendo todo el conjunto de i al conjunto de j)
    this.Parent [irep] = jrep;
}
Mejoras (unión por rango y compresión de ruta)
La eficiencia depende en gran medida de la altura del árbol. Necesitamos minimizar la altura del árbol para mejorar la eficiencia. Podemos usar Path Compression y Union por métodos de rango para hacerlo.
Compresión de ruta (modificaciones para encontrar ()): acelera la estructura de datos al comprimir la altura de los árboles. Se puede lograr insertando un pequeño mecanismo de almacenamiento en caché en la operación de búsqueda. Eche un vistazo al código para obtener más detalles:
// Encuentra el representante del conjunto que yo
// es un elemento de.
int encontrar (int i)
{
    // Si i es el padre de sí mismo
    si (Padre [i] == i)
    {
        // Entonces yo soy el representante
        volver i;
    }
    más
    {
        // Encontrar al representante de forma recursiva.
        int resultado = buscar (Padre [i]);

        // Almacenamos en caché el resultado moviendo el nodo i
        // directamente bajo el representante de este
        // establecer
        Padre [i] = resultado;
       
        // Y luego devolvemos el resultado
        devolver resultado;
     }
}
Unión por rango: En primer lugar, necesitamos una nueva array de números enteros llamada rango []. El tamaño de esta array es el mismo que el de la array principal. Si i es un representante de un conjunto, el rango [i] es la altura del árbol que representa el conjunto.

Ahora recuerde que, en la operación Union, no importa cuál de los dos árboles se mueva debajo del otro (vea los dos últimos ejemplos de imágenes arriba). Ahora lo que queremos hacer es minimizar la altura del árbol resultante. Si estamos uniendo dos árboles (o conjuntos), llamémoslos izquierda y derecha, entonces todo depende del rango de la izquierda y el rango de la derecha.
• Si el rango de la izquierda es menor que el rango de la derecha, entonces es mejor moverse hacia la izquierda debajo de la derecha, porque eso no cambiará el rango de la derecha (mientras que moverse hacia la derecha debajo de la izquierda aumentaría la altura). De la misma manera, si el rango de la derecha es menor que el rango de la izquierda, entonces debemos movernos a la derecha debajo de la izquierda.
• Si los rangos son iguales, no importa qué árbol va debajo del otro, pero el rango del resultado siempre será uno mayor que el rango de los árboles.
// Une el conjunto que incluye i y el conjunto
// eso incluye j
unión vacía (int i, int j)
{
    // Encuentra los representantes (o los nodos raíz)
    // para el conjunto que incluye i
    int irep = this.find (i);

    // Y haz lo mismo con el conjunto que incluye j
    int jrep = this.Find (j);

    // Los elementos están en el mismo conjunto, no es necesario
    // unir cualquier cosa.
    si (irep == jrep)
        regreso;

    // Obtener el rango del árbol de i
    irank = Rango [irep],

    // Obtener el rango del árbol de j
    jrank = Rango [jrep];

    // Si el rango de i es menor que el rango de j
    si (irank &lt;bromeo)
    {
        // Luego mueve i debajo de j
        this.parent [irep] = jrep;
    }

    // De lo contrario, si el rango de j es menor que el rango de i
    más si (broma &lt;irank)
    {
        // Luego mueve j debajo de i
        this.Parent [jrep] = irep;
    }

    // De lo contrario, si sus rangos son los mismos
    más
    {

        // Luego mueve i debajo de j (no importa
        // cual va donde)
        this.Parent [irep] = jrep;

        // E incrementa el árbol de resultados
        // clasificar por 1
        Rango [jrep] ++;
    }
}
</texto>
  <complejidad_tiempo>null</complejidad_tiempo>
  <java>//Estructura de datos para modelar 
//una colección de conjuntos disyuntos.
//Permite determinar de manera eficiente 
//a que conjunto pertenece un elemento,
//si dos elementos se encuentran en un mismo 
//conjunto y unir dos conjuntos disyuntos en un uno.

public class DisjointSet {

    static class DisjointUnionSets {

        int[] rank, parent;
        int n;

        public DisjointUnionSets(int n) {
            rank = new int[n];
            parent = new int[n];
            this.n = n;
            makeSet();
        }

        // Crea n conjuntos con un solo elemento en cada uno
        void makeSet() {
            for (int i = 0; i &lt; n; i++) {
                // Inicialmente, todos los elementos están en su propio conjunto.
                parent[i] = i;
            }
        }

        // Devuelve representativo del conjunto de x
        int find(int x) {
            // Encuentra el representante del conjunto del que x es un elemento de
            if (parent[x] != x) {
                // si x no es el padre de sí mismo Entonces 
                // x no es el representante de su conjunto,
                parent[x] = find(parent[x]);
                // entonces llamamos recursivamente Find en su padre y movemos 
                // el nodo de i directamente debajo del 
                // representante de este conjunto
            }

            return parent[x];
        }

        // Une el conjunto que incluye x y el conjunto que incluye x
        void union(int x, int y) {
            // Encuentra representantes de dos conjuntos
            int xRoot = find(x), yRoot = find(y);
            // Los elementos están en el mismo conjunto, no es necesario unir nada.
            if (xRoot == yRoot) {
                return;
            }

            // Si el rango de x es menor que el rango de y
            if (rank[xRoot] &lt; rank[yRoot]) // Luego mueva y debajo de x 
            //para que la profundidad del árbol permanezca menor
            {
                parent[xRoot] = yRoot;
            } // De lo contrario, si el rango de y es menor que el rango de x
            else if (rank[yRoot] &lt; rank[xRoot]) // Luego mueva y debajo de x 
            //para que la profundidad del árbol permanezca menor
            {
                parent[yRoot] = xRoot;
            } else // si los rangos son los mismos
            {
                // Luego mueva y debajo de x (no importa cuál vaya a dónde)
                parent[yRoot] = xRoot;
                // E incrementar el rango del árbol de resultados en 1
                rank[xRoot] = rank[xRoot] + 1;
            }
        }
    }

    public static void main(String[] args) {
        // Sea 5 personas con identificadores como 0, 1, 2, 3 y 4
        int n = 5;
        DisjointUnionSets dus
                = new DisjointUnionSets(n);

        // 0 es amigo de 2
        dus.union(0, 2);

        // 4 es amigo de 2
        dus.union(4, 2);

        // 3 es amigo de 1
        dus.union(3, 1);

        // Verifica si 4 es amigo de 0
        if (dus.find(4) == dus.find(0)) {
            System.out.println(&quot;Yes&quot;);
        } else {
            System.out.println(&quot;No&quot;);
        }

        // Verifica si 1 es amigo de 0
        if (dus.find(1) == dus.find(0)) {
            System.out.println(&quot;Yes&quot;);
        } else {
            System.out.println(&quot;No&quot;);
        }
    }
}
</java>
  <cpp>#include &lt;iostream&gt; 
#define MAX 105
using namespace std;

struct DisjSet {
    int rank[MAX], parent[MAX], n;

    DisjSet(int n) {
        this-&gt;n = n;
        makeSet();
    }

    void makeSet() {
        for (int i = 0; i &lt; n; i++) {
            parent[i] = i;
        }
    }

    int find(int x) {
        if (parent[x] != x) {
            parent[x] = find(parent[x]);
        }
        return parent[x];
    }

    void Union(int x, int y) {
        int xset = find(x);
        int yset = find(y);
        if (xset == yset)
            return;
        if (rank[xset] &lt; rank[yset]) {
            parent[xset] = yset;
        } else if (rank[xset] &gt; rank[yset]) {
            parent[yset] = xset;
        } else {
            parent[yset] = xset;
            rank[xset] = rank[xset] + 1;
        }
    }
};

int main() {
    DisjSet obj(5);
    obj.Union(0, 2);
    obj.Union(4, 2);
    obj.Union(3, 1);
    if (obj.find(4) == obj.find(0))
        cout &lt;&lt; &quot;Yes\n&quot;;
    else
        cout &lt;&lt; &quot;No\n&quot;;
    if (obj.find(1) == obj.find(0))
        cout &lt;&lt; &quot;Yes\n&quot;;
    else
        cout &lt;&lt; &quot;No\n&quot;;

    return 0;
}
</cpp>
  <py>class DisjSet: 
    def __init__(self, n): 
        self.rank = [1] * n 
        self.parent = [i for i in range(n)] 
    def find(self, x):  
        if (self.parent[x] != x): 
            self.parent[x] = self.find(self.parent[x]) 

        return self.parent[x] 
    def Union(self, x, y): 
        xset = self.find(x) 
        yset = self.find(y) 
        if xset == yset: 
            return
        if self.rank[xset] &lt; self.rank[yset]: 
            self.parent[xset] = yset 
        elif self.rank[xset] &gt; self.rank[yset]: 
            self.parent[yset] = xset 
        else: 
            self.parent[yset] = xset 
            self.rank[xset] = self.rank[xset] + 1


obj = DisjSet(5) 
obj.Union(0, 2) 
obj.Union(4, 2) 
obj.Union(3, 1) 
if obj.find(4) == obj.find(0): 
    print(&#39;Yes&#39;) 
else: 
    print(&#39;No&#39;) 
if obj.find(1) == obj.find(0): 
    print(&#39;Yes&#39;) 
else: 
    print(&#39;No&#39;) 
</py>
  <orden>8</orden>
  <suborden>31</suborden>
  <fecha_creacion>2020-12-06 19:51:45</fecha_creacion>
  <fecha_modificacion>2022-03-08 12:28:52</fecha_modificacion>
</row>
<row>
  <ID>228</ID>
  <supergrupo>Grafos</supergrupo>
  <tema>Union de conjuntos disjuntos en un árbol </tema>
  <texto>Dado un árbol y pesos de nodos. Los pesos son números enteros no negativos. La tarea consiste en encontrar el tamaño máximo de un subárbol de un árbol dado, de modo que todos los nodos tengan pesos iguales.

Ejemplos:
 
Entrada: Número de nodos = 7
        Pesos de los nodos = 1 2 6 4 2 0 3
        aristas = (1, 2), (1, 3), (2, 4),
                (2, 5), (4, 6), (6, 7)
Salida: tamaño máximo del subárbol
con nodos ponderados pares = 4
Explicacion:
El subárbol de nodos {2, 4, 5, 6} da el tamaño máximo.

Entrada: Número de nodos = 6
        Pesos de los nodos = 2 4 0 2 2 6
        aristass = (1, 2), (2, 3), (3, 4),
                (4, 5), (1, 6)
Salida: tamaño máximo del subárbol
con nodos ponderados pares = 6
Explicacion:
El árbol dado da el tamaño máximo.
 
Enfoque: podemos encontrar una solución simplemente ejecutando DFS en el árbol. La solución DFS nos da la respuesta en O (n). Pero, ¿cómo podemos usar DSU para este problema? Primero iteramos a través de todos las aristas. Si ambos nodos son pares en pesos, hacemos una unión de ellos. El conjunto de nodos con tamaño máximo es la respuesta. Si usamos union-find con compresión de ruta, la complejidad del tiempo es O (n).
</texto>
  <complejidad_tiempo>null</complejidad_tiempo>
  <java>// Código Java para encontrar el subárbol máximo de 
// modo que todos los nodos tengan un peso par

public class DisjoinSetUnionTree {

    static final int N = 100010;

    // Estructura para camino
    static class Edge {

        int u, v;

        public Edge(int u, int v) {
            this.u = u;
            this.v = v;
        }
    }

    /* &#39;id&#39;: almacena el padre de un nodo.
     &#39;sz&#39;: almacena el tamaño de un árbol DSU. */
    static int[] id = new int[N];
    static int[] sz = new int[N];

    // Función para asignar root
    static int Root(int idx) {
        int i = idx;
        while (i != id[i]) {
            id[i] = id[id[i]];
            i = id[i];
        }
        return i;
    }

    // Función para encontrar Unión
    static void Union(int a, int b) {
        int i = Root(a), j = Root(b);
        if (i != j) {
            if (sz[i] &gt;= sz[j]) {
                id[j] = i;
                sz[i] += sz[j];
                sz[j] = 0;
            } else {
                id[i] = j;
                sz[j] += sz[i];
                sz[i] = 0;
            }
        }
    }

    // Función de utilidad para Union
    static void UnionUtil(Edge e[], int W[], int q) {
        for (int i = 0; i &lt; q; i++) {
            // Camino entre &#39;u&#39; y &#39;v&#39;
            int u, v;
            u = e[i].u;
            v = e[i].v;
            u--;
            v--;

            // Si los pesos de &#39;u&#39; y &#39;v&#39; son pares, los unimos.
            if (W[u] % 2 == 0 &amp;&amp; W[v] % 2 == 0) {
                Union(u, v);
            }
        }
    }

    // Función para encontrar el tamaño máximo del árbol DSU
    static int findMax(int n, int W[]) {
        int maxi = 0;
        for (int i = 1; i &lt; n; i++) {
            if (W[i] % 2 == 0) {
                maxi = Math.max(maxi, sz[i]);
            }
        }
        return maxi;
    }

    public static void main(String[] args) {
        /* 
        Los nodos están indexados en 0 en este código, 
        por lo que tenemos que hacer los cambios 
        necesarios mientras tomamos entradas
         */
        // Pesos de nodos
        int W[] = {1, 2, 6, 4, 2, 0, 3};

        // Número de nodos en un árbol
        int n = W.length;

        // Inicializando cada nodo como un árbol con un solo nodo.
        for (int i = 0; i &lt; n; i++) {
            id[i] = i;
            sz[i] = 1;
        }

        Edge e[] = {new Edge(1, 2), new Edge(1, 3),
            new Edge(2, 4), new Edge(2, 5),
            new Edge(4, 6), new Edge(6, 7)};

        int q = e.length;
        UnionUtil(e, W, q);
        // Encuentre el tamaño máximo del árbol DSU.
        int maxi = findMax(n, W);
        System.out.printf(&quot;Maximum size of the subtree with &quot;);
        System.out.printf(&quot;even weighted nodes = %d\n&quot;, maxi);
    }
}
</java>
  <cpp>#include&lt;bits/stdc++.h&gt; 

using namespace std;

#define N 100010 

struct Edge {
    int u, v;
};

int id[N], sz[N];

int Root(int idx) {
    int i = idx;
    while (i != id[i])
        id[i] = id[id[i]], i = id[i];
    return i;
}

void Union(int a, int b) {
    int i = Root(a), j = Root(b);
    if (i != j) {
        if (sz[i] &gt;= sz[j]) {
            id[j] = i, sz[i] += sz[j];
            sz[j] = 0;
        } else {
            id[i] = j, sz[j] += sz[i];
            sz[i] = 0;
        }
    }
}

void UnionUtil(struct Edge e[], int W[], int q) {
    for (int i = 0; i &lt; q; i++) {
        int u, v;
        u = e[i].u, v = e[i].v;
        u--, v--;
        if (W[u] % 2 == 0 &amp;&amp; W[v] % 2 == 0)
            Union(u, v);
    }
}

int findMax(int n, int W[]) {
    int maxi = 0;
    for (int i = 1; i &lt;= n; i++)
        if (W[i] % 2 == 0)
            maxi = max(maxi, sz[i]);

    return maxi;
}

int main() {
    int W[] = {1, 2, 6, 4, 2, 0, 3};
    int n = sizeof (W) / sizeof (W[0]);
    for (int i = 0; i &lt; n; i++)
        id[i] = i, sz[i] = 1;
    Edge e[] = {
        {1, 2},
        {1, 3},
        {2, 4},
        {2, 5},
        {4, 6},
        {6, 7}
    };
    int q = sizeof (e) / sizeof (e[0]);
    UnionUtil(e, W, q);
    .
    int maxi = findMax(n, W);
    printf(&quot;Maximum size of the subtree with &quot;);
    printf(&quot;even weighted nodes = %d\n&quot;, maxi);

    return 0;
} 
</cpp>
  <py>N = 100010
class Edge:
    def __init__(self, u, v):
        self.u = u
        self.v = v

id = [0 for i in range(N)]
sz = [0 for i in range(N)]

def Root(idx):
    i = idx
    while (i != id[i]):
        id[i] = id[id[i]]
        i = id[i]
    return i

def Union(a, b):
    i = Root(a)
    j = Root(b)
    if (i != j):
        if (sz[i] &gt;= sz[j]):
            id[j] = i
            sz[i] += sz[j]
            sz[j] = 0;
        else:
            id[i] = j
            sz[j] += sz[i]
            sz[i] = 0;
 

def UnionUtil(e, W, q):
    for i in range (q):
        u = e[i].u
        v = e[i].v
        u -= 1
        v -= 1
        if (W[u] % 2 == 0 and W[v] % 2 == 0):
            Union(u, v)

def findMax(n, W):
    maxi = 0
    for i in range (1, n):
        if (W[i] % 2 == 0):
            maxi = max(maxi, sz[i])
    return maxi;


W = [1, 2, 6, 4, 2, 0, 3]
n = len(W);
for i in range (n):
    id[i] = i
    sz[i] = 1

e = [Edge(1, 2), Edge(1, 3),
    Edge(2, 4), Edge(2, 5),
    Edge(4, 6), Edge(6, 7)]
q = len(e);
UnionUtil(e, W, q);
maxi = findMax(n, W);
print(&quot;Maximum size of the subtree with &quot;)
print(&quot;even weighted nodes = &quot;, maxi);
</py>
  <orden>8</orden>
  <suborden>32</suborden>
  <fecha_creacion>2020-12-06 19:51:45</fecha_creacion>
  <fecha_modificacion>2022-03-08 12:28:52</fecha_modificacion>
</row>
<row>
  <ID>229</ID>
  <supergrupo>Grafos</supergrupo>
  <tema>Llenado mediante inundaciones</tema>
  <texto>En MS-Paint, cuando llevamos el pincel a un píxel y hacemos clic, el color de la región de ese píxel se reemplaza con un nuevo color seleccionado. A continuación se muestra el enunciado del problema para realizar esta tarea.
Dada una pantalla 2D, la ubicación de un píxel en la pantalla y un color, reemplace el color del píxel dado y todos los píxeles adyacentes del mismo color con el color dado.
Ejemplo:
Entrada:
pantalla [M] [N] = {	 {1, 1, 1, 1, 1, 1, 1, 1},
              		 {1, 1, 1, 1, 1, 1, 0, 0},
               		 {1, 0, 0, 1, 1, 0, 1, 1},
              		 {1, 2, 2, 2, 2, 0, 1, 0},
               		 {1, 1, 1, 2, 2, 0, 1, 0},
              		 {1, 1, 1, 2, 2, 2, 2, 0},
              		 {1, 1, 1, 1, 1, 2, 1, 1},
               		 {1, 1, 1, 1, 1, 2, 2, 1},
              			 };
    x = 4, y = 4, nuevoColor = 3
Los valores en la pantalla 2D dada
  indicar los colores de los píxeles.
xey son coordenadas del pincel,
   newColor es el color que
debe reemplazar el color anterior en
   pantalla [x] [y] y todos los alrededores
píxeles con el mismo color.

Salida:
La pantalla debe cambiarse a siguiente.
pantalla [M] [N] = {	{1, 1, 1, 1, 1, 1, 1, 1},
               		{1, 1, 1, 1, 1, 1, 0, 0},
              		{1, 0, 0, 1, 1, 0, 1, 1},
               		{1, 3, 3, 3, 3, 0, 1, 0},
               		{1, 1, 1, 3, 3, 0, 1, 0},
               		{1, 1, 1, 3, 3, 3, 3, 0},
              		{1, 1, 1, 1, 1, 3, 1, 1},
               		{1, 1, 1, 1, 1, 3, 3, 1},
              		 };
 

1: - Uso de recursividad
La idea es simple, primero reemplazamos el color del píxel actual, luego repetimos para 4 puntos circundantes. El siguiente es un algoritmo detallado.
// Una función recursiva para reemplazar
// color anterior &#39;prevC&#39; en &#39;(x, y)&#39;
// y todos los píxeles circundantes de (x, y)
// con nuevo color &#39;newC&#39; y
floodFil (pantalla [M] [N], x, y, prevC, newC)
1) Si xoy está fuera de la pantalla, regrese.
2) Si el color de la pantalla [x] [y] no es el mismo que prevC, regrese
3) Se repite para norte, sur, este y oeste.
    floodFillUtil (pantalla, x + 1, y, prevC, newC);
    floodFillUtil (pantalla, x-1, y, prevC, newC);
    floodFillUtil (pantalla, x, y + 1, prevC, newC);
    floodFillUtil (pantalla, x, y-1, prevC, newC);

Método 2: usar el enfoque BFS
Algoritmo para el enfoque basado en BFS:
1. Cree una cola de parejas.
2. Inserte un índice inicial dado en la cola.
3. Marque el índice inicial como visitado en vis [] [] matriz.
4. Hasta que la cola no esté vacía, repita los pasos 3.1 a 3.6
• Toma el elemento frontal de la cola
• Salir de la cola
• Almacene el valor / color actual en las coordenadas sacadas de la cola (precolor)
• Actualizar el valor / color del índice actual que se saca de la cola
• Verifique las 4 direcciones, es decir, (x + 1, y), (x-1, y), (x, y + 1), (x, y-1) es válido o no y si es válido, verifique ese valor en esa coordenada debe ser igual al precolor y el valor de esa coordenada en vis [] [] es 0.
• Si toda la condición anterior es verdadera, empuje la coordenada correspondiente en la cola y marque como 1 en vis [] []
5. Imprima la matriz.
</texto>
  <complejidad_tiempo>null</complejidad_tiempo>
  <java>// Programa Java para implementar el algoritmo de relleno por inundación

public class FloodFill {

// Dimensiones de la pantalla 
    static int M = 8;
    static int N = 8;

    // Una función recursiva para reemplazar el color anterior &#39;prevC&#39; en 
    // &#39;(x, y)&#39; y todos los píxeles circundantes de (x, y) con el nuevo color &#39;newC&#39; 
    static void floodFillUtil(int screen[][], int x, int y,
            int prevC, int newC) {
        if (x &lt; 0 || x &gt;= M || y &lt; 0 || y &gt;= N) {
            return;
        }
        if (screen[x][y] != prevC) {
            return;
        }
        // Reemplazar el color en (x, y)
        screen[x][y] = newC;
        // ir recursivamente para norte, este, sur y oeste
        floodFillUtil(screen, x + 1, y, prevC, newC);
        floodFillUtil(screen, x - 1, y, prevC, newC);
        floodFillUtil(screen, x, y + 1, prevC, newC);
        floodFillUtil(screen, x, y - 1, prevC, newC);
    }

    // se encuentra principalmente el color anterior en (x, y)
    // y llama a floodFillUtil ()
    static void floodFill(int screen[][], int x, int y, int newC) {
        int prevC = screen[x][y];
        floodFillUtil(screen, x, y, prevC, newC);
    }

    public static void main(String[] args) {
        int screen[][] = {{1, 1, 1, 1, 1, 1, 1, 1},
        {1, 1, 1, 1, 1, 1, 0, 0},
        {1, 0, 0, 1, 1, 0, 1, 1},
        {1, 2, 2, 2, 2, 0, 1, 0},
        {1, 1, 1, 2, 2, 0, 1, 0},
        {1, 1, 1, 2, 2, 2, 2, 0},
        {1, 1, 1, 1, 1, 2, 1, 1},
        {1, 1, 1, 1, 1, 2, 2, 1},};
        int x = 4, y = 4, newC = 3;
        floodFill(screen, x, y, newC);

        System.out.println(&quot;Updated screen after call to floodFill: &quot;);
        for (int i = 0; i &lt; M; i++) {
            for (int j = 0; j &lt; N; j++) {
                System.out.print(screen[i][j] + &quot; &quot;);
            }
            System.out.println();
        }
    }
}
</java>
  <cpp>#include&lt;iostream&gt; 
using namespace std;

#define M 8 
#define N 8 

void floodFillUtil(int screen[][N], int x, int y, int prevC, int newC) {
    if (x &lt; 0 || x &gt;= M || y &lt; 0 || y &gt;= N)
        return;
    if (screen[x][y] != prevC)
        return;
    if (screen[x][y] == newC)
        return;
    screen[x][y] = newC;
    floodFillUtil(screen, x + 1, y, prevC, newC);
    floodFillUtil(screen, x - 1, y, prevC, newC);
    floodFillUtil(screen, x, y + 1, prevC, newC);
    floodFillUtil(screen, x, y - 1, prevC, newC);
}

void floodFill(int screen[][N], int x, int y, int newC) {
    int prevC = screen[x][y];
    floodFillUtil(screen, x, y, prevC, newC);
}

int main() {
    int screen[M][N] = {
        {1, 1, 1, 1, 1, 1, 1, 1},
        {1, 1, 1, 1, 1, 1, 0, 0},
        {1, 0, 0, 1, 1, 0, 1, 1},
        {1, 2, 2, 2, 2, 0, 1, 0},
        {1, 1, 1, 2, 2, 0, 1, 0},
        {1, 1, 1, 2, 2, 2, 2, 0},
        {1, 1, 1, 1, 1, 2, 1, 1},
        {1, 1, 1, 1, 1, 2, 2, 1},
    };
    int x = 4, y = 4, newC = 3;
    floodFill(screen, x, y, newC);
    cout &lt;&lt; &quot;Updated screen after call to floodFill: \n&quot;;
    for (int i = 0; i &lt; M; i++) {
        for (int j = 0; j &lt; N; j++)
            cout &lt;&lt; screen[i][j] &lt;&lt; &quot; &quot;;
        cout &lt;&lt; endl;
    }
}
</cpp>
  <py>M = 8
N = 8
def floodFillUtil(screen, x, y, prevC, newC): 
    if (x &lt; 0 or x &gt;= M or y &lt; 0 or
        y &gt;= N or screen[x][y] != prevC or
        screen[x][y] == newC): 
        return
    screen[x][y] = newC 
    floodFillUtil(screen, x + 1, y, prevC, newC) 
    floodFillUtil(screen, x - 1, y, prevC, newC) 
    floodFillUtil(screen, x, y + 1, prevC, newC) 
    floodFillUtil(screen, x, y - 1, prevC, newC) 
def floodFill(screen, x, y, newC): 
    prevC = screen[x][y] 
    floodFillUtil(screen, x, y, prevC, newC) 
screen = [[1, 1, 1, 1, 1, 1, 1, 1], 
    [1, 1, 1, 1, 1, 1, 0, 0], 
    [1, 0, 0, 1, 1, 0, 1, 1], 
    [1, 2, 2, 2, 2, 0, 1, 0], 
    [1, 1, 1, 2, 2, 0, 1, 0], 
    [1, 1, 1, 2, 2, 2, 2, 0], 
    [1, 1, 1, 1, 1, 2, 1, 1], 
    [1, 1, 1, 1, 1, 2, 2, 1]] 

x = 4
y = 4
newC = 3
floodFill(screen, x, y, newC) 
print (&quot;Updated screen after call to floodFill:&quot;) 
for i in range(M): 
    print(screen[i]) 

</py>
  <orden>8</orden>
  <suborden>33</suborden>
  <fecha_creacion>2020-12-06 19:51:45</fecha_creacion>
  <fecha_modificacion>2022-03-08 12:28:52</fecha_modificacion>
</row>
<row>
  <ID>230</ID>
  <supergrupo>Grafos</supergrupo>
  <tema>Algoritmo de Ford-Fulkerson para máximos flujos</tema>
  <texto>Dado un gráfico que representa una red de flujo donde cada arista tiene una capacidad. También dados dos vértices fuente &quot;s&quot; y sumidero &quot;t&quot; en el gráfico, encuentre el flujo máximo posible de s a t con las siguientes restricciones:

a) El flujo en una arista no excede la capacidad dada del arista.
b) El flujo entrante es igual al flujo saliente para cada vértice excepto s y t.
 
La siguiente es una idea simple del algoritmo Ford-Fulkerson:
1) Comience con el flujo inicial como 0.
2) Si bien hay un camino creciente desde la fuente hasta el sumidero.
Agregue este flujo de ruta para fluir.
3) Retorne el flujo.

Complejidad de tiempo: La complejidad de tiempo del algoritmo anterior es O (max_flow * E). Ejecutamos un bucle mientras hay una ruta de aumento. En el peor de los casos, podemos agregar 1 unidad de flujo en cada iteración. Por tanto, la complejidad del tiempo se convierte en O (max_flow * E).
¿Cómo implementar el algoritmo simple anterior?
Primero definamos el concepto de Gráfico Residual que se necesita para comprender la implementación.

El gráfico residual de una red de flujo es un gráfico que indica un flujo adicional posible. Si hay una ruta desde la fuente hasta el sumidero en el gráfico residual, entonces es posible agregar flujo. Cada arista de un gráfico residual tiene un valor llamado capacidad residual que es igual a la capacidad original de la arista menos el flujo de corriente. La capacidad residual es básicamente la capacidad actual de la arista.

Hablemos ahora de los detalles de implementación. La capacidad residual es 0 si no hay arista entre dos vértices del gráfico residual. Podemos inicializar el gráfico residual como gráfico original ya que no hay flujo inicial y la capacidad residual inicial es igual a la capacidad original. Para encontrar una ruta de aumento, podemos hacer un BFS o DFS del gráfico residual. Hemos utilizado BFS en la siguiente implementación. Usando BFS, podemos averiguar si hay una ruta desde la fuente hasta el sumidero. BFS también crea una matriz principal []. Usando la matriz principal [], atravesamos la ruta encontrada y encontramos el flujo posible a través de esta ruta al encontrar la capacidad residual mínima a lo largo de la ruta. Posteriormente agregamos el flujo de ruta encontrado al flujo general.
Lo importante es que necesitamos actualizar las capacidades residuales en el gráfico de residuos. Restamos el flujo de la ruta de todos las aristas a lo largo de la ruta y agregamos el flujo de la ruta a lo largo de las aristas inversos Necesitamos agregar el flujo de la ruta a lo largo de las aristas inversas porque más tarde es posible que necesitemos enviar el flujo en dirección inversa

La implementación anterior del algoritmo Ford Fulkerson se llama algoritmo Edmonds-Karp. La idea de Edmonds-Karp es utilizar BFS en la implementación de Ford Fulkerson, ya que BFS siempre elige un camino con un número mínimo de aristas. Cuando se utiliza BFS, la complejidad de tiempo del peor de los casos se puede reducir a O (VE2). La implementación anterior usa una representación de matriz de adyacencia, aunque donde BFS toma tiempo O (V2), la complejidad de tiempo de la implementación anterior es O (EV3).

Este es un problema importante ya que surge en muchas situaciones prácticas. Los ejemplos incluyen, maximizar el transporte con límites de tráfico dados, maximizar el flujo de paquetes en las redes de computadoras.
</texto>
  <complejidad_tiempo>null</complejidad_tiempo>
  <java>// Programa Java para la implementación del algoritmo Ford Fulkerson

import java.util.LinkedList;

public class FordFulkersonMaxFlow {

    static final int V = 6; //Número de vértices en el gráfico

    /* Devuelve verdadero si hay una ruta desde la fuente &#39;s&#39; hasta el sumidero 
    &#39;t&#39; en el gráfico residual. También llena parent [] 
    para almacenar la ruta */
    static boolean bfs(int rGraph[][], int s, int t, int parent[]) {
        // Cree una matriz visitada y marque todos los vértices como no visitados
        boolean visited[] = new boolean[V];
        for (int i = 0; i &lt; V; ++i) {
            visited[i] = false;
        }
        // Cree una cola, ponga en cola el vértice de origen y 
        // marque el vértice de origen como visitado
        LinkedList&lt;Integer&gt; queue = new LinkedList&lt;&gt;();
        queue.add(s);
        visited[s] = true;
        parent[s] = -1;
        // Bucle BFS estándar
        while (!queue.isEmpty()) {
            int u = queue.poll();
            for (int v = 0; v &lt; V; v++) {
                if (visited[v] == false &amp;&amp; rGraph[u][v] &gt; 0) {
                    queue.add(v);
                    parent[v] = u;
                    visited[v] = true;
                }
            }
        }

        // Si alcanzamos el sumidero en BFS a partir de la fuente, 
        // devolvemos verdadero, de lo contrario falso
        return (visited[t] == true);
    }

    // Devuelve el caudal máximo de s - t en el gráfico dado
    static int fordFulkerson(int graph[][], int s, int t) {
        int u, v;

        // Cree un grafo residual y llene el grafo residual con las capacidades 
        // dadas en el grafo original como capacidades residuales en el grafo 
        // residual donde rGraph [i] [j] indica la capacidad residual del 
        // borde de i a j (si hay un borde. If rGraph [i] [j] es 0,
        // entonces no hay)
        int rGraph[][] = new int[V][V];
        for (u = 0; u &lt; V; u++) {
            for (v = 0; v &lt; V; v++) {
                rGraph[u][v] = graph[u][v];
            }
        }

        // Esta matriz está llena de BFS y para almacenar la ruta
        int parent[] = new int[V];
        int max_flow = 0; // No hay flujo inicialmente

        // Aumente el flujo mientras hay un camino desde la fuente hasta el sumidero
        while (bfs(rGraph, s, t, parent)) {
            // Encuentre la capacidad residual mínima de los bordes a lo largo 
            // del camino llenado por BFS. O podemos decir encontrar 
            // el flujo máximo a través del camino encontrado.
            int path_flow = Integer.MAX_VALUE;
            for (v = t; v != s; v = parent[v]) {
                u = parent[v];
                path_flow = Math.min(path_flow, rGraph[u][v]);
            }
            // actualizar las capacidades residuales de los bordes e invertir 
            // los bordes a lo largo del camino
            for (v = t; v != s; v = parent[v]) {
                u = parent[v];
                rGraph[u][v] -= path_flow;
                rGraph[v][u] += path_flow;
            }

            // Agregue el flujo de ruta al flujo general
            max_flow += path_flow;
        }

        // Devuelve el flujo general
        return max_flow;
    }

    public static void main(String[] args) throws java.lang.Exception {
        int graph[][] = new int[][]{{0, 16, 13, 0, 0, 0},
        {0, 0, 10, 12, 0, 0},
        {0, 4, 0, 0, 14, 0},
        {0, 0, 9, 0, 0, 20},
        {0, 0, 0, 7, 0, 4},
        {0, 0, 0, 0, 0, 0}
        };
        System.out.println(&quot;The maximum possible flow is &quot;
                + fordFulkerson(graph, 0, 5));
    }
}
</java>
  <cpp>#include &lt;iostream&gt; 
#include &lt;limits.h&gt; 
#include &lt;string.h&gt; 
#include &lt;queue&gt; 
using namespace std;

#define V 6 

bool bfs(int rGraph[V][V], int s, int t, int parent[]) {

    bool visited[V];
    memset(visited, 0, sizeof (visited));
    queue &lt;int&gt; q;
    q.push(s);
    visited[s] = true;
    parent[s] = -1;

    while (!q.empty()) {
        int u = q.front();
        q.pop();
        for (int v = 0; v &lt; V; v++) {
            if (visited[v] == false &amp;&amp; rGraph[u][v] &gt; 0) {
                q.push(v);
                parent[v] = u;
                visited[v] = true;
            }
        }
    }
    return (visited[t] == true);
}

int fordFulkerson(int graph[V][V], int s, int t) {
    int u, v;
    int rGraph[V][V];
    for (u = 0; u &lt; V; u++)
        for (v = 0; v &lt; V; v++)
            rGraph[u][v] = graph[u][v];
    int parent[V];
    int max_flow = 0;
    while (bfs(rGraph, s, t, parent)) {
        int path_flow = INT_MAX;
        for (v = t; v != s; v = parent[v]) {
            u = parent[v];
            path_flow = min(path_flow, rGraph[u][v]);
        }
        for (v = t; v != s; v = parent[v]) {
            u = parent[v];
            rGraph[u][v] -= path_flow;
            rGraph[v][u] += path_flow;
        }
        max_flow += path_flow;
    }
    return max_flow;
}

int main() {
    int graph[V][V] = {
        {0, 16, 13, 0, 0, 0},
        {0, 0, 10, 12, 0, 0},
        {0, 4, 0, 0, 14, 0},
        {0, 0, 9, 0, 0, 20},
        {0, 0, 0, 7, 0, 4},
        {0, 0, 0, 0, 0, 0}
    };
    cout &lt;&lt; &quot;The maximum possible flow is &quot; &lt;&lt; fordFulkerson(graph, 0, 5);
    return 0;
}
</cpp>
  <py>class Graph: 

    def __init__(self, graph): 
        self.graph = graph 
        self. ROW = len(graph) 
        #self.COL = len(gr[0]) 
                
    def BFS(self, s, t, parent): 
        visited = [False] * (self.ROW) 
        queue = [] 
        queue.append(s) 
        visited[s] = True
        while queue: 
            u = queue.pop(0) 
            for ind, val in enumerate(self.graph[u]): 
                if visited[ind] == False and val &gt; 0: 
                    queue.append(ind) 
                    visited[ind] = True
                    parent[ind] = u 
        return True if visited[t] else False

    def FordFulkerson(self, source, sink): 
        parent = [-1] * (self.ROW) 
        max_flow = 0 
        while self.BFS(source, sink, parent):  
            path_flow = float(&quot;Inf&quot;) 
            s = sink 
            while(s != source): 
                path_flow = min (path_flow, self.graph[parent[s]][s]) 
                s = parent[s] 

            max_flow += path_flow 
            v = sink 
            while(v != source): 
                u = parent[v] 
                self.graph[u][v] -= path_flow 
                self.graph[v][u] += path_flow 
                v = parent[v] 
        return max_flow 

graph = [[0, 16, 13, 0, 0, 0], 
    [0, 0, 10, 12, 0, 0], 
    [0, 4, 0, 0, 14, 0], 
    [0, 0, 9, 0, 0, 20], 
    [0, 0, 0, 7, 0, 4], 
    [0, 0, 0, 0, 0, 0]] 
g = Graph(graph) 
source = 0; sink = 5
print (&quot;The maximum possible flow is %d &quot; % g.FordFulkerson(source, sink)) 
</py>
  <orden>8</orden>
  <suborden>34</suborden>
  <fecha_creacion>2020-12-06 19:51:46</fecha_creacion>
  <fecha_modificacion>2022-03-08 12:28:52</fecha_modificacion>
</row>
<row>
  <ID>231</ID>
  <supergrupo>Grafos</supergrupo>
  <tema>Antecesor común más bajo</tema>
  <texto>El ancestro común más bajo (ACB LCA) es un concepto dentro de la Teoría de grafos y Ciencias de la computación. Sea T un árbol con raíz y n nodos. El ancestro común más bajo entre dos nodos v y w se define como el nodo más bajo en T que tiene a v y w como descendientes (donde se permite a un nodo ser descendiente de él mismo).
El ACB de v y w en T es el ancestro compartido de v y w que está localizado más lejos de la raíz. El cómputo del ancestro común más bajo puede ser útil, por ejemplo, como parte de un procedimiento para determinar la distancia entre pares de nodos en un árbol: la distancia de v a w puede ser calculada como la distancia desde la raíz hasta v, sumada con la distancia desde la raíz hasta w, menos dos veces la distancia desde la raíz hasta su ancestro común más bajo.
En una estructura de datos árbol donde cada nodo referencia a su padre, el ancestro común más bajo puede ser determinado de forma muy simple encontrando la primera intersección de los caminos desde v and w hasta la raíz. En general, el tiempo computacional requerido por este algoritmo es O(h) donde h es la altura del árbol (longitud del camino más largo desde una hoja hasta la raíz). Sin embargo, existen muchos algoritmos para procesar árboles con los que el ancestro común más bajo puede ser encontrado de forma más rápida.
Se puede buscar en tiempo constante por pregunta después de un preprocesamiento en tiempo lineal.
Sin preprocesamiento se puede mejorar el tiempo de cómputo del algoritmo ingenuo hasta O(log h) almacenando los caminos a través del árbol usando skew-binary random access lists, premitiendo aún al árbol ser extendido en tiempo constante
 
En el diagrama anterior, el LCA de 10 y 14 es 12 y el LCA de 10 y 12 es 12.
  (1) Cree una matriz padre y almacene el padre del i-ésimo nodo en ella. El padre del nodo raíz debe ser -1.
(2) Ahora, acceda a todos los nodos desde el nodo deseado &quot;m&quot; hasta el nodo raíz y márquelos como visitados.
(3) Por último, acceda a todos los nodos desde el nodo deseado &quot;n&quot; hasta que llegue el primer nodo visitado.
(4) Este nodo es el ancestro común más bajo
</texto>
  <complejidad_tiempo>null</complejidad_tiempo>
  <java>import java.util.ArrayList;

public class LowestCommonAncestor {

    static final int MAX = 100005; //Cantidad maxima de nodos
    static final int LOG2 = 17; //log2(MAX)+1
    //ArrayList&lt;edge&gt; g[] = new ArrayList[MAX]; //Lista de adyacencia
    static ArrayList&lt;Integer&gt; g[] = new ArrayList[MAX]; //Lista de adyacencia
    static int dep[] = new int[MAX]; //Almacena la profundidad de cada nodo
    static int par[][] = new int[MAX][LOG2]; //Almacena los padres para responder las consultas
    //int rmq[][] = new int[MAX][LOG2]; //Almacena los pesos para responder las consultas
    static int nodos, aristas; //Cantidad de nodos y aristas 

    /*static class edge {
    int v, w; 
    
    edge(int _v, int _w){
        v = _v;
        w = _w;
    }
};*/
    static int lca(int u, int v) {
        //int ans = -1;
        if (dep[u] &lt; dep[v]) {
            int aux = u;
            u = v;
            v = aux;
        }
        int diff = dep[u] - dep[v];
        for (int i = LOG2 - 1; i &gt;= 0; i--) {
            if ((diff &amp; (1 &lt;&lt; i)) &gt; 0) {
                //ans = Math.max(ans, rmq[u][i]);
                u = par[u][i];
            }
        }
        //if (u == v) return ans;
        if (u == v) {
            return u;
        }
        for (int i = LOG2 - 1; i &gt;= 0; i--) {
            if (par[u][i] != par[v][i]) {
                //ans = Math.max(ans, Math.max(rmq[u][i], rmq[v][i]));
                u = par[u][i];
                v = par[v][i];
            }
        }
        //return Math.max(ans, Math.max(rmq[u][0], rmq[v][0]));
        return par[u][0];
    }

    static void dfs(int u, int p, int d) {
        dep[u] = d;
        par[u][0] = p;
        for (int v /* edge ed*/ : g[u]) {
            //int v = ed.v;
            if (v != p) {
                //rmq[v][0] = ed.w;
                dfs(v, u, d + 1);
            }
        }
    }

    static void build() {
        for (int i = 0; i &lt; nodos; i++) {
            dep[i] = -1;
        }
        for (int i = 0; i &lt; nodos; i++) {
            if (dep[i] == -1) {
                //rmq[i][0] = -1;
                dfs(i, i, 0);
            }
        }
        for (int j = 0; j &lt; LOG2 - 1; j++) {
            for (int i = 0; i &lt; nodos; i++) {
                par[i][j + 1] = par[par[i][j]][j];
                //rmq[i][j+1] = Math.max(rmq[ par[i][j] ][j], rmq[i][j]);
            }
        }
    }

    static void init() {
        for (int i = 0; i &lt;= nodos; i++) {
            g[i] = new ArrayList&lt;&gt;();
        }
    }

    public static void main(String[] args) {
        nodos = 5;
        aristas = 4;
        init();
        g[0].add(1);
        g[0].add(2);
        g[2].add(3);
        g[3].add(4);
        build();
        System.out.println(lca(2, 1));
    }
}
</java>
  <cpp>#include &lt;cstdlib&gt;
#include &lt;bits/stdc++.h&gt; 
using namespace std;
const int MAX = 100005;
const int LOG2 = 17;
//vector&lt;edge&gt; g[MAX];
vector&lt;int&gt; g[MAX];
int dep[MAX];
int par[MAX][LOG2];
int rmq[MAX][LOG2];
static int nodos, aristas;

struct edge {
    int v, w;

    edge(int _v, int _w) {
        v = _v;
        w = _w;
    }
};

int lca(int u, int v) {
    //int ans = -1;
    if (dep[u] &lt; dep[v]) {
        int aux = u;
        u = v;
        v = aux;
    }
    int diff = dep[u] - dep[v];
    for (int i = LOG2 - 1; i &gt;= 0; i--) {
        if ((diff &amp; (1 &lt;&lt; i)) &gt; 0) {
            //ans = max(ans, rmq[u][i]);
            u = par[u][i];
        }
    }
    //if (u == v) return ans;
    if (u == v) {
        return u;
    }
    for (int i = LOG2 - 1; i &gt;= 0; i--) {
        if (par[u][i] != par[v][i]) {
            //ans = max(ans, max(rmq[u][i], rmq[v][i]));
            u = par[u][i];
            v = par[v][i];
        }
    }
    //return max(ans, max(rmq[u][0], rmq[v][0]));
    return par[u][0];
}

void dfs(int u, int p, int d) {
    dep[u] = d;
    par[u][0] = p;
    for (int v /* edge ed*/ : g[u]) {
        //int v = ed.v;
        if (v != p) {
            //rmq[v][0] = ed.w;
            dfs(v, u, d + 1);
        }
    }
}

void build() {
    for (int i = 0; i &lt; nodos; i++) {
        dep[i] = -1;
    }
    for (int i = 0; i &lt; nodos; i++) {
        if (dep[i] == -1) {
            //rmq[i][0] = -1;
            dfs(i, i, 0);
        }
    }
    for (int j = 0; j &lt; LOG2 - 1; j++) {
        for (int i = 0; i &lt; nodos; i++) {
            par[i][j + 1] = par[par[i][j]][j];
            //rmq[i][j+1] = max(rmq[ par[i][j] ][j], rmq[i][j]);
        }
    }
}

void init() {
    for (int i = 0; i &lt;= nodos; i++) {
        //        g[i] = new ArrayList&lt;&gt;();
    }
}

int main() {
    nodos = 5;
    aristas = 4;
    init();
    g[0].emplace_back(1);
    g[0].emplace_back(2);
    g[2].emplace_back(3);
    g[3].emplace_back(4);
    build();
    cout &lt;&lt; (lca(2, 1)) &lt;&lt; endl;
}
</cpp>
  <py>MAX = 100005
LOG2 = 17
#vector&lt;edge&gt; g[MAX];
g = [[]for i in range (MAX)]
dep = [0 for i in range (MAX)]
par = [[0 for j in range (MAX)]for i in range (LOG2)]
rmq = [[0 for j in range (MAX)]for i in range (LOG2)]
class edge:
    def __init__(self, v, w):
        self.v = v
        self.w = w
        
def lca(u, v):
    #int ans = -1;
    if (dep[u] &lt; dep[v]):
        aux = u;
        u = v;
        v = aux;
    diff = dep[u] - dep[v];
    for i in range (LOG2-1, -1, -1):
        if ((diff &amp; (1 &lt;&lt; i)) &gt; 0):
            #ans = max(ans, rmq[u][i]);
            u = par[u][i];
    #if (u == v) return ans;
    if (u == v):
        return u
    for i in range (LOG2-1, -1, -1):
        if (par[u][i] != par[v][i]):
            #ans = max(ans, max(rmq[u][i], rmq[v][i]));
            u = par[u][i]
            v = par[v][i]
    
    #return max(ans, max(rmq[u][0], rmq[v][0]));
    return par[u][0]

def dfs(u, p, d):
    dep[u] = d
    par[u][0] = p
    for v in g[u]:
        #v = ed.v;
        if (v != p):
            #rmq[v][0] = ed.w
            dfs(v, u, d + 1)
 

def build():
    for i in range (nodos):
        dep[i] = -1
    for i in range (nodos): 
        if (dep[i] == -1):
            #rmq[i][0] = -1;
            dfs(i, i, 0);
    for i in range (LOG2-1):
        for j in range (nodos):
            par[i][j + 1] = par[par[i][j]][j]
            #rmq[i][j+1] = max(rmq[ par[i][j] ][j], rmq[i][j]);
 

def init():
    g = [[]for i in range (MAX)]

nodos = 5
aristas = 4
init()
g[0].append(1)
g[0].append(2)
g[2].append(3)
g[3].append(4)
build();
print(lca(2, 1))
</py>
  <orden>8</orden>
  <suborden>35</suborden>
  <fecha_creacion>2020-12-06 19:51:46</fecha_creacion>
  <fecha_modificacion>2022-03-08 12:28:52</fecha_modificacion>
</row>
<row>
  <ID>232</ID>
  <supergrupo>Grafos</supergrupo>
  <tema>Serpientes y escaleras</tema>
  <texto>Dado un tablero de serpiente y escalera, encuentre el número mínimo de lanzamientos de dados necesarios para llegar al destino o la última celda desde la fuente o la primera celda. Básicamente, el jugador tiene control total sobre el resultado del lanzamiento de dados y quiere averiguar el número mínimo de lanzamientos necesarios para llegar a la última celda.
Si el jugador llega a una celda que es la base de una escalera, el jugador tiene que subir esa escalera y si llega a una celda que es la boca de la serpiente, tiene que bajar hasta la cola de la serpiente sin lanzar un dado.
 
Por ejemplo, considere el tablero que se muestra, el número mínimo de lanzamientos de dados necesarios para llegar a la celda 30 desde la celda 1 es 3.
Los siguientes son los pasos:
a) Primero lanza dos dados para llegar a la celda número 3 y luego escala para llegar a la 22
b) Luego lanza 6 para llegar a 28.
c) Finalmente a través del 2 para llegar a 30.
También puede haber otras soluciones como (2, 2, 6), (2, 4, 4), (2, 3, 5) .. etc.
La idea es considerar el tablero de serpiente y escalera dado como un gráfico dirigido con un número de vértices igual al número de celdas del tablero. El problema se reduce a encontrar el camino más corto en un gráfico. Cada vértice del gráfico tiene una arista hasta los siguientes seis vértices si los siguientes 6 vértices no tienen una serpiente o una escalera. Si alguno de los siguientes seis vértices tiene una serpiente o una escalera, entonces la arista del vértice actual va a la parte superior de la escalera o la cola de la serpiente. Dado que todos las aristas tienen el mismo peso, podemos encontrar de manera eficiente la ruta más corta usando la búsqueda de amplitud primero del gráfico.
A continuación se muestra la implementación de la idea anterior. La entrada está representada por dos cosas, primero es &#39;N&#39; que es el número de celdas en el tablero dado, segundo es una matriz &#39;mover [0… N-1]&#39; de tamaño N. Una entrada de movimiento [i] es -1 si no hay serpiente ni escalera desde i, de lo contrario, el movimiento [i] contiene el índice de la celda de destino para la serpiente o la escalera en i.
La complejidad de tiempo de la solución anterior es O (N) ya que cada celda se agrega y se elimina solo una vez de la cola. Y una operación típica de poner en cola o sacar de cola lleva O (1) tiempo.
</texto>
  <complejidad_tiempo>null</complejidad_tiempo>
  <java>// Programa Java para encontrar el número mínimo de lanzamientos de dados 
// necesarios para llegar a la última celda de la primera celda de una 
// tabla de escalera y serpiente determinada

import java.util.LinkedList;
import java.util.Queue;

public class SnakesAndLadders {
    // Una entrada en la cola utilizada en BFS

    static class qentry {

        int v;// Número de vértice
        int dist;// Distancia de este vértice desde la fuente
    }

    // Esta función devuelve el número mínimo de lanzamientos de dados 
    // necesarios para llegar a la última celda desde la celda 0 en un juego 
    // de serpientes y escaleras. move[] es una matriz de tamaño N donde N es 
    // no. de celdas a bordo Si no hay una serpiente o escalera desde la 
    // celda i, entonces move[i] es -1 De lo contrario, el move[i] contiene 
    // la celda a la que lleva la serpiente o escalera en i.
    static int getMinDiceThrows(int move[], int n) {
        int visited[] = new int[n];
        Queue&lt;qentry&gt; q = new LinkedList&lt;&gt;();
        qentry qe = new qentry();
        qe.v = 0;
        qe.dist = 0;

        // Marque el nodo 0 como visitado y colóquelo.
        visited[0] = 1;
        q.add(qe);

        // Hacer un BFS comenzando desde el vértice en el índice 0
        while (!q.isEmpty()) {
            qe = q.remove();
            int v = qe.v;

            // Si el vértice frontal es el vértice de destino, hemos terminado.
            if (v == n - 1) {
                break;
            }

            // De lo contrario, quite de la cola del vértice frontal y ponga 
            // en cola sus vértices adyacentes (o números de celda 
            // accesibles a través de un lanzamiento de dados)
            for (int j = v + 1; j &lt;= (v + 6) &amp;&amp; j &lt; n; ++j) {
                // Si esta celda ya está visitada, ignore
                if (visited[j] == 0) {
                    // De lo contrario, calcule su distancia y márquela como visitada.
                    qentry a = new qentry();
                    a.dist = (qe.dist + 1);
                    visited[j] = 1;

                    // Compruebe si hay una serpiente o una escalera en &#39;j&#39;, luego la cola de la serpiente o la parte superior de la escalera se convierte en el adyacente de &#39;i&#39;
                    if (move[j] != -1) {
                        a.v = move[j];
                    } else {
                        a.v = j;
                    }
                    q.add(a);
                }
            }
        }

        // Llegamos aquí cuando &#39;qe&#39; tiene el último vértice devuelve la distancia del vértice en &#39;qe&#39;
        return qe.dist;
    }

    public static void main(String[] args) {
        // Construyamos el tablero dado en el diagrama anterior
        int N = 30;
        int moves[] = new int[N];
        for (int i = 0; i &lt; N; i++) {
            moves[i] = -1;
        }

        // Escaleras
        moves[2] = 21;
        moves[4] = 7;
        moves[10] = 25;
        moves[19] = 28;

        // Snakes
        moves[26] = 0;
        moves[20] = 8;
        moves[16] = 3;
        moves[18] = 6;

        System.out.println(&quot;Min Dice throws required is &quot;
                + getMinDiceThrows(moves, N));
    }
}
</java>
  <cpp>#include&lt;iostream&gt; 
#include &lt;queue&gt; 
using namespace std;

struct queueEntry {
    int v;
    int dist;
};

int getMinDiceThrows(int move[], int N) {

    bool *visited = new bool[N];
    for (int i = 0; i &lt; N; i++)
        visited[i] = false;
    queue&lt;queueEntry&gt; q;
    visited[0] = true;
    queueEntry s = {0, 0};
    /
    q.push(s);
    queueEntry qe;
    while (!q.empty()) {
        qe = q.front();
        int v = qe.v;
        if (v == N - 1)
            break;
        q.pop();
        for (int j = v + 1; j &lt;= (v + 6) &amp;&amp; j &lt; N; ++j) {
            if (!visited[j]) {

                queueEntry a;
                a.dist = (qe.dist + 1);
                visited[j] = true;
                if (move[j] != -1)
                    a.v = move[j];
                else
                    a.v = j;
                q.push(a);
            }
        }
    }
    return qe.dist;
}

int main() {
    int N = 30;
    int moves[N];
    for (int i = 0; i &lt; N; i++)
        moves[i] = -1;

    // Ladders 
    moves[2] = 21;
    moves[4] = 7;
    moves[10] = 25;
    moves[19] = 28;

    // Snakes 
    moves[26] = 0;
    moves[20] = 8;
    moves[16] = 3;
    moves[18] = 6;

    cout &lt;&lt; &quot;Min Dice throws required is &quot; &lt;&lt; getMinDiceThrows(moves, N);
    return 0;
}
</cpp>
  <py>class QueueEntry(object): 
    def __init__(self, v=0, dist=0): 
        self.v = v 
        self.dist = dist 
def getMinDiceThrows(move, N): 
    visited = [False] * N 
    queue = [] 
    visited[0] = True
    queue.append(QueueEntry(0, 0)) 
    qe = QueueEntry() 
    while queue: 
        qe = queue.pop(0) 
        v = qe.v 
        if v == N - 1: 
            break
        j = v + 1
        while j &lt;= v + 6 and j &lt; N: 
            if visited[j] is False: 
                a = QueueEntry() 
                a.dist = qe.dist + 1
                visited[j] = True
                a.v = move[j] if move[j] != -1 else j 
                queue.append(a) 
            j += 1
    return qe.dist 
N = 30
moves = [-1] * N 

# Ladders 
moves[2] = 21
moves[4] = 7
moves[10] = 25
moves[19] = 28

# Snakes 
moves[26] = 0
moves[20] = 8
moves[16] = 3
moves[18] = 6

print(&quot;Min Dice throws required is {0}&quot;. 
      format(getMinDiceThrows(moves, N))) 
</py>
  <orden>8</orden>
  <suborden>36</suborden>
  <fecha_creacion>2020-12-06 19:51:46</fecha_creacion>
  <fecha_modificacion>2022-03-08 12:28:52</fecha_modificacion>
</row>
<row>
  <ID>233</ID>
  <supergrupo>Grafos</supergrupo>
  <tema>Camino más corto desde múltiples orígenes en un grafo no ponderado</tema>
  <texto>Suponga que hay n ciudades conectadas por m caminos bidireccionales. Entre ellos hay varios pueblos con una comisaría. Queremos saber la distancia de cada pueblo a la comisaría más cercana. Si el pueblo tiene uno, la distancia es 0.
Ejemplo:
Entrada:
Número de vértices = 6
Número de aristas = 9
Localidades con Comisaría: 1, 5
Aristas:
1 2
1 6
2 6
2 3
3 6
5 4
6 5
3 4
5 3

 
Salida:
1 0
2 1
3 1
4 1
5 0
6 1
 
Enfoque ingenuo: podemos recorrer los vértices y desde cada vértice ejecutar un BFS para encontrar la ciudad más cercana con la estación de policía de ese vértice. Esto tomará O (V.E).

Método eficiente Un método mejor es utilizar el algoritmo de Djikstra de forma modificada. Consideremos una de las fuentes como la fuente original y las otras fuentes como vértices con 0 rutas de costo desde la fuente original. Por lo tanto, empujamos todas las fuentes a la cola de Djikstra con distancia = 0 y el resto de los vértices con distancia = infinito. La distancia mínima de cada vértice desde la fuente original ahora calculada usando el algoritmo de Dijkstra son ahora esencialmente las distancias desde la fuente más cercana.

Explicación: La implementación utiliza un conjunto de pares (distancia desde la fuente, vértice) ordenados según la distancia desde la fuente. Inicialmente, el conjunto contiene las fuentes con distancia = 0 y todos los demás vértices con distancia = infinito.
En cada paso, iremos al vértice con distancia mínima (d) desde la fuente, es decir, el primer elemento del conjunto (la propia fuente en el primer paso con distancia = 0). Pasamos por todos sus vértices adyacentes y si la distancia de cualquier vértice es&gt; d + 1 reemplazamos su entrada en el conjunto con la nueva distancia. Luego eliminamos el vértice actual del conjunto. Continuamos esto hasta que el conjunto esté vacío.
La idea es que no puede haber una ruta más corta al vértice en la parte delantera del conjunto que la actual, ya que cualquier otra ruta será la suma de una ruta más larga (&gt; = su longitud) y una longitud de ruta no negativa (a menos que están considerando aristas negativos).
Dado que todas las fuentes tienen una distancia = 0, al principio, los vértices adyacentes que no son fuentes obtendrán una distancia = 1. Todos los vértices obtendrán distancia = distancia desde su fuente más cercana.

Enfoque más eficiente: Un método aún mejor es usar el BFS de múltiples fuentes, que es una modificación de BFS. Pondremos todos los vértices de origen en la cola al principio en lugar de un solo vértice que era en el caso de BFS estándar. primero visitará todos los vértices de origen. Después de eso, visitará los vértices que están a una distancia de 1 de todos los vértices de origen, luego a una distancia de 2 de todos los vértices de origen, y así sucesivamente.

</texto>
  <complejidad_tiempo>null</complejidad_tiempo>
  <java>// Programa para demostrar BFS de múltiples fuentes

import java.util.ArrayList;
import java.util.Arrays;
import java.util.LinkedList;

public class MultiSourceSPUnweighted {

    static final int N = 1000000;
    // Esta matriz almacena las distancias de los 
    // vértices desde la fuente más cercana.
    static int dist[] = new int[N];
    // Esta matriz booleana es verdadera si se visita el 
    // vértice actual; de lo contrario, es falsa
    static boolean visited[] = new boolean[N];

    static void addEdge(ArrayList&lt;Integer&gt; graph[], int u, int v) {
        // Función para agregar 2 aristas en un gráfico no dirigido
        graph[u].add(v);
        graph[v].add(u);
    }

    // Función BFS de múltiples fuentes
    static void Multisource_BFS(ArrayList&lt;Integer&gt; graph[], LinkedList&lt;Integer&gt; q) {
        while (!q.isEmpty()) {
            int k = q.getFirst();
            q.pollFirst();
            for (Integer i : graph[k]) {
                if (!visited[i]) {
                    // Empujar los vértices adyacentes no visitados con la 
                    // distancia de la fuente actual = la distancia de este vértice + 1
                    q.push(i);
                    dist[i] = dist[k] + 1;
                    visited[i] = true;
                }
            }
        }
    }

    // Esta función calcula la distancia de cada vértice desde la fuente más cercana
    static void nearestTown(ArrayList&lt;Integer&gt; graph[], int n, int sources[], int s) {
        // Crea una cola para BFS 
        LinkedList&lt;Integer&gt; q = new LinkedList&lt;&gt;();
        // Marque todos los vértices de origen como visitados y colóquelos
        for (int i = 0; i &lt; s; i++) {
            q.push(sources[i]);
            visited[sources[i]] = true;
        }
        Multisource_BFS(graph, q);
        // Imprimiendo las distancias
        for (int i = 1; i &lt;= n; i++) {
            System.out.println(i + &quot; &quot; + dist[i]);
        }
    }

    public static void main(String[] args) {
        // Número de vértices
        int n = 6;
        ArrayList&lt;Integer&gt; graph[] = new ArrayList[n + 1];
        Arrays.fill(graph, new ArrayList&lt;&gt;());
        // Caminos 
        addEdge(graph, 1, 2);
        addEdge(graph, 1, 6);
        addEdge(graph, 2, 6);
        addEdge(graph, 2, 3);
        addEdge(graph, 3, 6);
        addEdge(graph, 5, 4);
        addEdge(graph, 6, 5);
        addEdge(graph, 3, 4);
        addEdge(graph, 5, 3);
        // Origenes
        int sources[] = {1, 5};
        int S = sources.length;
        nearestTown(graph, n, sources, S);
    }
}
</java>
  <cpp>#include&lt;bits/stdc++.h&gt; 
using namespace std;
#define N 1000000 

int dist[N];
bool visited[N];

void addEdge(vector&lt;int&gt; graph[], int u, int v) {
    graph[u].push_back(v);
    graph[v].push_back(u);
}

void Multisource_BFS(vector&lt;int&gt; graph[], queue&lt;int&gt;q) {
    while (!q.empty()) {
        int k = q.front();
        q.pop();

        for (auto i : graph[k]) {
            if (!visited[i]) {
                q.push(i);
                dist[i] = dist[k] + 1;
                visited[i] = true;
            }
        }
    }
}

void nearestTown(vector&lt;int&gt; graph[], int n, int sources[], int s) {
    queue&lt;int&gt; q;
    for (int i = 0; i &lt; s; i++) {
        q.push(sources[i]);
        visited[sources[i]] = true;
    }
    Multisource_BFS(graph, q);
    for (int i = 1; i &lt;= n; i++) {
        cout &lt;&lt; i &lt;&lt; &quot; &quot; &lt;&lt; dist[i] &lt;&lt; endl;
    }

}

int main() {
    int n = 6;
    vector&lt;int&gt; graph[n + 1];
    addEdge(graph, 1, 2);
    addEdge(graph, 1, 6);
    addEdge(graph, 2, 6);
    addEdge(graph, 2, 3);
    addEdge(graph, 3, 6);
    addEdge(graph, 5, 4);
    addEdge(graph, 6, 5);
    addEdge(graph, 3, 4);
    addEdge(graph, 5, 3);
    int sources[] = {1, 5};
    int S = sizeof (sources) / sizeof (sources[0]);
    nearestTown(graph, n, sources, S);
    return 0;
}
</cpp>
  <py>N = 1000000
dist = [0 for _ in range (N)]
visited = [0 for _ in range (N)]

def addEdge(graph, u, v):
    graph[u].append(v)
    graph[v].append(u)

def multisourceBFS(graph, q):
    while (len(q) != 0):
        k = q[0]
        q = q[1:]
        for i in graph[k]:
            if (visited[i] == False):
                q.append(i)
                dist[i] = dist[k] + 1
                visited[i] = True
  
def nearestTown(graph, n, sources, s):
    q = []
    for i in range(s):
        q.append(sources[i])
        visited[sources[i]] = True
    multisourceBFS(graph, q)
    for i in range (1, n + 1):
        print(str(i) + &quot; &quot; + str(dist[i]))
        
        
n = 6
graph = [[] for _ in range (n + 1)]
addEdge(graph, 1, 2);
addEdge(graph, 1, 6);
addEdge(graph, 2, 6);
addEdge(graph, 2, 3);
addEdge(graph, 3, 6);
addEdge(graph, 5, 4);
addEdge(graph, 6, 5);
addEdge(graph, 3, 4);
addEdge(graph, 5, 3);
sources = [1, 5]
S = len(sources)
nearestTown(graph, n, sources, S);
</py>
  <orden>8</orden>
  <suborden>37</suborden>
  <fecha_creacion>2020-12-06 19:51:46</fecha_creacion>
  <fecha_modificacion>2022-03-08 12:28:52</fecha_modificacion>
</row>
<row>
  <ID>234</ID>
  <supergrupo>Grafos</supergrupo>
  <tema>Camino más corto en un grafo multi etapas</tema>
  <texto>Un gráfico de etapas múltiples es un gráfico dirigido en el que los nodos se pueden dividir en un conjunto de etapas de modo que todos las aristas sean de una etapa a la siguiente solo (en otras palabras, no hay arista entre los vértices de la misma etapa y desde un vértice de la corriente etapa a etapa anterior).
Nos dan un gráfico de varias etapas, una fuente y un destino, necesitamos encontrar la ruta más corta desde la fuente hasta el destino. Por convención, consideramos el origen en la etapa 1 y el destino como última etapa.
A continuación se muestra un gráfico de ejemplo
 
Ahora hay varias estrategias que podemos aplicar: -
• El método de fuerza bruta para encontrar todos los caminos posibles entre el origen y el destino y luego encontrar el mínimo. Esa es la PEOR estrategia posible.
• Algoritmo de Dijkstra de rutas más cortas de fuente única. Este método encontrará las rutas más cortas desde la fuente a todos los demás nodos, lo que no es necesario en este caso. Por lo tanto, llevará mucho tiempo y ni siquiera utiliza la función ESPECIAL que tiene este gráfico MULTI-ETAPA.
• Método codicioso simple: en cada nodo, elija la ruta de salida más corta. Si aplicamos este enfoque al gráfico de ejemplo anterior, obtenemos la solución como 1 + 4 + 18 = 23. Pero un vistazo rápido al gráfico mostrará caminos mucho más cortos disponibles que 23. ¡Entonces el método codicioso falla!
• La mejor opción es la Programación dinámica. Por lo tanto, debemos encontrar la subestructura óptima, las ecuaciones recursivas y los subproblemas superpuestos.
Subestructura óptima y ecuación recursiva: -

Definimos la notación: - M (x, y) como el costo mínimo para T (nodo objetivo) de la Etapa x, Nodo y.

Distancia más corta desde la etapa 1, nodo 0 a
destino, es decir, 7 es M (1, 0).

// De 0, podemos pasar a 1 o 2 o 3 a
// llegar a 7.
M (1, 0) = mínimo (1 + M (2, 1),
              2 + M (2, 2),
              5 + M (2, 3))
Esto significa que nuestro problema de 0 -&gt; 7 ahora se subdivide en 3 subproblemas: -
Entonces, si tenemos un total de &#39;n&#39; etapas y el objetivo
como T, entonces la condición de parada será: -
M (n-1, yo) = yo ---&gt; T + M (n, T) = yo ---&gt; T
Árbol de recursividad y subproblemas superpuestos: -
Entonces, la jerarquía de evaluaciones M (x, y) se verá así: -
En M (i, j), i es el número de etapa y
j es el número de nodo

                   M (1, 0)
           / | \
          / | \
       M (2, 1) M (2, 2) M (2, 3)
    / \ / \ / \
M (3, 4) M (3, 5) M (3, 4) M (3, 5) M (3, 6) M (3, 6)
 . . . . . .
 . . . . . .
 . . . . . .
Entonces, aquí hemos dibujado una parte muy pequeña del árbol de recursividad y ya podemos ver subproblemas superpuestos. Podemos reducir en gran medida el número de evaluaciones M (x, y) mediante la programación dinámica.
Detalles de implementacion:
La siguiente implementación asume que los nodos están numerados de 0 a N-1 desde la primera etapa (origen) hasta la última etapa (destino). También asumimos que el gráfico de entrada es de varias etapas.
</texto>
  <complejidad_tiempo>null</complejidad_tiempo>
  <java>// Programa Java para encontrar la distancia más 
// corta en un gráfico de varias etapas.

public class MultiStageGraphSP {

    static int N = 8;
    static int INF = Integer.MAX_VALUE;

    // Devuelve la distancia más corta de 0 a N-1.
    public static int shortestDist(int[][] graph) {
        // dist [i] va a almacenar la distancia más corta del nodo i al nodo N-1.
        int[] dist = new int[N];
        dist[N - 1] = 0;

        // Calcular la ruta más corta para el resto de los nodos
        for (int i = N - 2; i &gt;= 0; i--) {

            // Inicializar la distancia desde i hasta el destino (N-1)
            dist[i] = INF;

            // Compruebe todos los nodos de las siguientes etapas 
            // para encontrar la distancia más corta de i a N-1.
            for (int j = i; j &lt; N; j++) {
                // Rechazar si no existe camino
                if (graph[i][j] == INF) {
                    continue;
                }
                // Aplicamos la ecuación recursiva a la distancia al objetivo a 
                // través de j. y compare con la distancia mínima hasta ahora.
                dist[i] = Math.min(dist[i], graph[i][j]
                        + dist[j]);
            }
        }

        return dist[0];
    }

    public static void main(String[] args) {
        // Gráfico almacenado en forma de matriz de adyacencia
        int[][] graph = new int[][]{
            {INF, 1, 2, 5, INF, INF, INF, INF},
            {INF, INF, INF, INF, 4, 11, INF, INF},
            {INF, INF, INF, INF, 9, 5, 16, INF},
            {INF, INF, INF, INF, INF, INF, 2, INF},
            {INF, INF, INF, INF, INF, INF, INF, 18},
            {INF, INF, INF, INF, INF, INF, INF, 13},
            {INF, INF, INF, INF, INF, INF, INF, 2}};

        System.out.println(shortestDist(graph));
    }
}
</java>
  <cpp>#include&lt;bits/stdc++.h&gt; 
using namespace std;
#define N 8
#define INF INT_MAX

int shortestDist(int graph[7][8]) {
    int dist [N];
    dist[N - 1] = 0;

    for (int i = N - 2; i &gt;= 0; i--) {
        dist[i] = INF;
        for (int j = i; j &lt; N; j++) {
            if (graph[i][j] == INF) {
                continue;
            }
            dist[i] = min(dist[i], graph[i][j]
                    + dist[j]);
        }
    }
    return dist[0];
}

int main() {
    int graph[7][8] = {
        {INF, 1, 2, 5, INF, INF, INF, INF},
        {INF, INF, INF, INF, 4, 11, INF, INF},
        {INF, INF, INF, INF, 9, 5, 16, INF},
        {INF, INF, INF, INF, INF, INF, 2, INF},
        {INF, INF, INF, INF, INF, INF, INF, 18},
        {INF, INF, INF, INF, INF, INF, INF, 13},
        {INF, INF, INF, INF, INF, INF, INF, 2}
    };

    cout &lt;&lt; shortestDist(graph) &lt;&lt; endl;
    return 0;
}
</cpp>
  <py>N=8
INF=1&lt;&lt;32
def shortestDist(graph):
    dist=[0 for i in range (N)]
    dist[N - 1] = 0
    for i in range (N-2,-1,-1):
        dist[i] = INF
        for j in range (N):
            if (graph[i][j] == INF):
                continue
            dist[i] = min(dist[i], graph[i][j]+ dist[j])
    return dist[0]


graph= [
    [INF, 1, 2, 5, INF, INF, INF, INF],
    [INF, INF, INF, INF, 4, 11, INF, INF],
    [INF, INF, INF, INF, 9, 5, 16, INF],
    [INF, INF, INF, INF, INF, INF, 2, INF],
    [INF, INF, INF, INF, INF, INF, INF, 18],
    [INF, INF, INF, INF, INF, INF, INF, 13],
    [INF, INF, INF, INF, INF, INF, INF, 2]];
print(shortestDist(graph))
</py>
  <orden>8</orden>
  <suborden>38</suborden>
  <fecha_creacion>2020-12-06 19:51:47</fecha_creacion>
  <fecha_modificacion>2022-03-08 12:28:52</fecha_modificacion>
</row>
<row>
  <ID>235</ID>
  <supergrupo>Grafos</supergrupo>
  <tema>Camino mas corto de k aristas</tema>
  <texto>Dada una dirección y dos vértices &quot;u&quot; y &quot;v&quot; en ella, encuentre la ruta más corta de &quot;u&quot; a &quot;v&quot; con exactamente k aristas en la ruta.
El gráfico se da como representación de matriz de adyacencia donde el valor del gráfico [i] [j] indica el peso de una arista desde el vértice i hasta el vértice j y un valor INF (infinito) indica que no hay arista de i a j.
 
La idea es navegar a través de todas las rutas de longitud k desde u hasta v utilizando el enfoque discutido en la publicación anterior y devolver el peso de la ruta más corta. Una solución simple es comenzar desde u, ir a todos los vértices adyacentes y repetir para los vértices adyacentes con k como k-1, origen como vértice adyacente y destino como v.

La complejidad de tiempo del peor caso de la función anterior es O (Vk) donde V es el número de vértices en el gráfico dado. Simplemente podemos analizar la complejidad del tiempo dibujando un árbol de recursividad. Lo peor ocurre para un gráfico completo. En el peor de los casos, cada nodo interno del árbol de recursividad tendría exactamente V hijos.
Podemos optimizar la solución anterior mediante la programación dinámica. La idea es construir una tabla 3D donde la primera dimensión es la fuente, la segunda dimensión es el destino, la tercera dimensión es el número de aristas desde el origen hasta el destino y el valor es el recuento de paseos. Al igual que otros problemas de programación dinámica, llenamos la tabla 3D de abajo hacia arriba.
La complejidad temporal de la solución basada en DP anterior es O (V3K), que es mucho mejor que la solución ingenua.
</texto>
  <complejidad_tiempo>null</complejidad_tiempo>
  <java>// Programa Java basado en programación dinámica para encontrar 
// la ruta más corta con exactamente k caminos

public class ShortestPathKEdges {
    // Definir número de vértices en el gráfico y valor no finito

    static final int V = 4;
    static final int INF = Integer.MAX_VALUE;

    // Una función recursiva ingenua para contar paseos de u a v con k aristas
    static int shortestPath(int graph[][], int u, int v, int k) {
        // Casos base
        if (k == 0 &amp;&amp; u == v) {
            return 0;
        }
        if (k == 1 &amp;&amp; graph[u][v] != INF) {
            return graph[u][v];
        }
        if (k &lt;= 0) {
            return INF;
        }

        // Inicializar resultado
        int res = INF;

        // Ir a todos los adyacentes de u y repetir
        for (int i = 0; i &lt; V; i++) {
            if (graph[u][i] != INF &amp;&amp; u != i &amp;&amp; v != i) {
                int rec_res = shortestPath(graph, i, v, k - 1);
                if (rec_res != INF) {
                    res = Math.min(res, graph[u][i] + rec_res);
                }
            }
        }
        return res;
    }

    public static void main(String[] args) {
        /* Creemos el grafo que se muestra en el diagrama anterior.*/
        int graph[][] = new int[][]{{0, 10, 3, 2},
        {INF, 0, INF, 7},
        {INF, INF, 0, 6},
        {INF, INF, INF, 0}
        };
        int u = 0, v = 3, k = 2;
        System.out.println(&quot;Weight of the shortest path is &quot;
                + shortestPath(graph, u, v, k));
    }
}
</java>
  <cpp>#include &lt;bits/stdc++.h&gt; 
using namespace std;

#define V 4 
#define INF INT_MAX 

int shortestPath(int graph[][V], int u, int v, int k) {
    if (k == 0 &amp;&amp; u == v) return 0;
    if (k == 1 &amp;&amp; graph[u][v] != INF) return graph[u][v];
    if (k &lt;= 0) return INF;
    int res = INF;
    for (int i = 0; i &lt; V; i++) {
        if (graph[u][i] != INF &amp;&amp; u != i &amp;&amp; v != i) {
            int rec_res = shortestPath(graph, i, v, k - 1);
            if (rec_res != INF)
                res = min(res, graph[u][i] + rec_res);
        }
    }
    return res;
}

int main() {
    int graph[V][V] = {
        {0, 10, 3, 2},
        {INF, 0, INF, 7},
        {INF, INF, 0, 6},
        {INF, INF, INF, 0}
    };
    int u = 0, v = 3, k = 2;
    cout &lt;&lt; &quot;Weight of the shortest path is &quot; &lt;&lt;
            shortestPath(graph, u, v, k);
    return 0;
}
</cpp>
  <py>def shortestPath(graph, u, v, k): 
    V = 4
    INF = 999999999999
    if k == 0 and u == v: 
        return 0
    if k == 1 and graph[u][v] != INF: 
        return graph[u][v] 
    if k &lt;= 0: 
        return INF 
    res = INF 
    for i in range(V): 
        if graph[u][i] != INF and u != i and v != i: 
            rec_res = shortestPath(graph, i, v, k - 1) 
            if rec_res != INF: 
                res = min(res, graph[u][i] + rec_res) 
    return res 


INF = 999999999999
graph = [[0, 10, 3, 2], 
    [INF, 0, INF, 7], 
    [INF, INF, 0, 6], 
    [INF, INF, INF, 0]] 
u = 0
v = 3
k = 2
print(&quot;Weight of the shortest path is&quot;, 
      shortestPath(graph, u, v, k)) 
</py>
  <orden>8</orden>
  <suborden>39</suborden>
  <fecha_creacion>2020-12-06 19:51:47</fecha_creacion>
  <fecha_modificacion>2022-03-08 12:28:52</fecha_modificacion>
</row>
<row>
  <ID>236</ID>
  <supergrupo>Grafos</supergrupo>
  <tema>Algoritmo de Trajano para la búsqueda de componentes fuertemente conexas</tema>
  <texto>Un grafo dirigido está fuertemente conectado si hay una ruta entre todos los pares de vértices. Un componente fuertemente conectado (SCC strongly conected component) de un gráfico dirigido es un subgráfico máximo fuertemente conectado. Por ejemplo, hay 3 SCC en el siguiente gráfico.
 
El algoritmo de Kosaraju para componentes fuertemente conectados dos recorridos DFS de un gráfico, el algoritmo de Tarjan requiere solo un recorrido DFS.
El algoritmo de Tarjan se basa en los siguientes hechos:
1. La búsqueda DFS produce un árbol / bosque DFS
2. Los componentes fuertemente conectados forman subárboles del árbol DFS.
3. Si podemos encontrar el encabezado de tales subárboles, podemos imprimir / almacenar todos los nodos en ese subárbol (incluido el encabezado) y ese será un SCC.
4. No hay arista posterior de un SCC a otro (puede haber aristas transversales, pero las aristas transversales no se utilizarán al procesar el gráfico).
Para encontrar la cabeza de un SCC, calculamos el disco y la matriz baja (como se hizo para el punto de articulación, puente, componente biconectado). Como se discutió en las publicaciones anteriores, bajo [u] indica el vértice visitado más temprano (el vértice con el tiempo mínimo de descubrimiento) que se puede alcanzar desde el subárbol enraizado con u. Un nodo u es cabeza si disc[u] = low[u].

El componente fuertemente conectado se relaciona solo con el gráfico dirigido, pero los valores de disc y low se relacionan con el gráfico dirigido y no dirigido, por lo que en la imagen anterior hemos tomado un gráfico no dirigido.
En la Figura anterior, hemos mostrado un gráfico y su árbol DFS (podría haber diferentes árboles DFS en el mismo gráfico dependiendo del orden en que se atraviesan las aristas).
En el árbol DFS, las flechas continuas son las aristas del árbol y las flechas punteadas son las aristas posteriores (DFS Tree Edges
Los valores de disc y low se muestran en la Figura para cada nodo como (disc / low).
disc: este es el momento en que se visita un nodo por primera vez durante el recorrido DFS. Para los nodos A, B, C, .., J en el árbol DFS, los valores del disc son 1, 2, 3, .., 10.
low: en el árbol DFS, las aristas del árbol nos llevan hacia adelante, desde el nodo ancestro hasta uno de sus descendientes. Por ejemplo, desde el nodo C, las aristas del árbol pueden llevarnos al nodo G, al nodo I, etc. Las aristas posteriores nos llevan hacia atrás, desde un nodo descendiente a uno de sus antepasados. Por ejemplo, desde el nodo G, las aristas posteriores nos llevan a E o C. Si miramos el árbol y la arista posterior juntos, entonces podemos ver que si comenzamos el recorrido desde un nodo, podemos bajar por el árbol a través de las aristas del árbol y luego sube por las aristas traseras. 

Por ejemplo, desde el nodo E, podemos bajar a G y luego subir a C. De manera similar, desde E, podemos bajar a I o J y luego subir a F. El valor &quot;low&quot; de un nodo indica el nivel más alto alcanzable ancestro (con el valor de disc mínimo posible) a través del subárbol de ese nodo. Entonces, para cualquier nodo, el valor low es igual a su valor de disc de todos modos (un nodo es antepasado de sí mismo). Luego miramos en su subárbol y vemos si hay algún nodo que pueda llevarnos a alguno de sus ancestros. Si hay varias aristas posteriores en el subárbol que nos llevan a diferentes ancestros, entonces tomamos el que tiene el valor mínimo de disc (es decir, el más alto). Si miramos el nodo F, tiene dos subárboles. El subárbol con el nodo G, nos lleva a E y C. El otro subárbol nos lleva de regreso a F solamente. Aquí, el antepasado más alto es C, donde F puede alcanzar y, por lo tanto, el valor low de F es 3 (el valor del disc de C).
Con base en la discusión anterior, debe quedar claro que los valores lows de B, C y D son 1 (ya que A es el nodo más alto al que pueden llegar B, C y D). De la misma manera, los valores lows de E, F, G son 3 y los valores lows de H, I, J son 6.
Para cualquier nodo u, cuando se inicia DFS, Low se establecerá en su disc 1st.
Luego, más adelante, DFS se realizará en cada uno de sus hijos v uno por uno, el valor low de u puede cambiarlo en dos casos:
Caso1 (arista del árbol): Si el nodo v aún no se ha visitado, luego de que se complete la DFS de v, el mínimo de low [u] y low [v] se actualizará a low [u].
low [u] = min (low [u], low [v]);
Caso 2 (arista posterior): cuando ya se ha visitado el niño v, el mínimo de low [u] y el disc [v] se actualizarán a low [u].
low [u] = min (low [u], disc [v]);
En el caso dos, ¿podemos tomar low [v] en lugar del disc [v]? . La respuesta es NO. Si puede pensar por qué la respuesta es NO, probablemente haya entendido el concepto Low and Disc.

Los mismos valores Low y Disc ayudan a resolver otros problemas de gráficos como el punto de articulación, el puente y el componente biconectado.
Para rastrear el subárbol enraizado en la cabecera, podemos usar una pila (siga presionando el nodo mientras visita). Cuando se encuentre un nodo principal, saque todos los nodos de la pila hasta que salga de la pila.
Para asegurarnos, no consideramos las aristas cruzadas, cuando llegamos a un nodo que ya está visitado, debemos procesar el nodo visitado solo si está presente en la pila; de lo contrario, ignore el nodo.
</texto>
  <complejidad_tiempo>null</complejidad_tiempo>
  <java>// Programa Java para encontrar componentes fuertemente conectados en un 
// grafo dirigido dado utilizando el algoritmo de Tarjan (DFS único)

import java.util.*;

public class TarjanStronglyConnectedComponents {

    // Esta clase representa un gráfico dirigido 
    // utilizando la representación de lista de adyacencia. 
    static class Graph {

        // No de vértices 
        private int V;

        //Listas de adyacencia
        private LinkedList&lt;Integer&gt; adj[];
        private int Time;

        Graph(int v) {
            V = v;
            adj = new LinkedList[v];

            for (int i = 0; i &lt; v; ++i) {
                adj[i] = new LinkedList();
            }

            Time = 0;
        }

        // Función para agregar una arista al gráfico
        void addEdge(int v, int w) {
            adj[v].add(w);
        }

        // Una función recursiva que encuentra e imprime componentes 
        // fuertemente conectados usando DFS transversal
        // u -&gt; El vértice a visitar a continuación
        // disc[] -&gt; Almacena los tiempos de descubrimiento 
        // de los vértices visitados
        // low[] - &gt;&gt; vértice visitado más temprano (el vértice con tiempo 
        // mínimo de descubrimiento) que se puede alcanzar desde el 
        // subárbol enraizado con el vértice actual
        // st - &gt;&gt; Para almacenar todos los ancestros 
        // conectados (podría ser parte de SCC)
        // stackMember [] -&gt; matriz de bits / índices para 
        // comprobar más rápidamente si un nodo está en la pila
        void SCCUtil(int u, int low[], int disc[],
                boolean stackMember[],
                Stack&lt;Integer&gt; st) {

            // Inicializar el tiempo de descubrimiento y el valor bajo 
            disc[u] = Time;
            low[u] = Time;
            Time += 1;
            stackMember[u] = true;
            st.push(u);
            int n;
            // Pasa por todos los vértices adyacentes a este
            Iterator&lt;Integer&gt; i = adj[u].iterator();
            while (i.hasNext()) {
                n = i.next();
                if (disc[n] == -1) {
                    SCCUtil(n, low, disc, stackMember, st);
                    // Compruebe si el subárbol enraizado con v 
                    // tiene una conexión con uno de los antepasados de u
                    // Caso 1 (según la discusión anterior sobre Disc y Low value)  
                    low[u] = Math.min(low[u], low[n]);
                } else if (stackMember[n] == true) {

                    // Actualice el valor bajo de &#39;u&#39; solo si &#39;v&#39; todavía está 
                    // en la pila (es decir, es un borde posterior, 
                    // no un borde transversal).
                    // Caso 2 (según la discusión anterior sobre Disc y Low value) 
                    low[u] = Math.min(low[u], disc[n]);
                }
            }

            // nodo principal encontrado, saque la pila e imprima un 
            // SCC Para almacenar los vértices extraídos de la pila 
            int w = -1;
            if (low[u] == disc[u]) {
                while (w != u) {
                    w = (int) st.pop();
                    System.out.print(w + &quot; &quot;);
                    stackMember[w] = false;
                }
                System.out.println();
            }
        }

        // La función para hacer un recorrido DFS. Utiliza SCCUtil ()
        void SCC() {

            // Marque todos los vértices como no visitados e Inicialice arrsys 
            // parent y visited, y ap (punto de articulación)
            int disc[] = new int[V];
            int low[] = new int[V];
            for (int i = 0; i &lt; V; i++) {
                disc[i] = -1;
                low[i] = -1;
            }

            boolean stackMember[] = new boolean[V];
            Stack&lt;Integer&gt; st = new Stack&lt;&gt;();

            // Llame a la función auxiliar recursiva para encontrar 
            // puntos de articulación en el árbol DFS enraizado 
            // con el vértice &#39;i&#39;
            for (int i = 0; i &lt; V; i++) {
                if (disc[i] == -1) {
                    SCCUtil(i, low, disc,
                            stackMember, st);
                }
            }
        }

    }

    public static void main(String args[]) {
        Graph g1 = new Graph(5);
        g1.addEdge(1, 0);
        g1.addEdge(0, 2);
        g1.addEdge(2, 1);
        g1.addEdge(0, 3);
        g1.addEdge(3, 4);
        System.out.println(&quot;SSC in first graph &quot;);
        g1.SCC();
        Graph g2 = new Graph(4);
        g2.addEdge(0, 1);
        g2.addEdge(1, 2);
        g2.addEdge(2, 3);
        System.out.println(&quot;\nSSC in second graph &quot;);
        g2.SCC();
        Graph g3 = new Graph(7);
        g3.addEdge(0, 1);
        g3.addEdge(1, 2);
        g3.addEdge(2, 0);
        g3.addEdge(1, 3);
        g3.addEdge(1, 4);
        g3.addEdge(1, 6);
        g3.addEdge(3, 5);
        g3.addEdge(4, 5);
        System.out.println(&quot;\nSSC in third graph &quot;);
        g3.SCC();
        Graph g4 = new Graph(11);
        g4.addEdge(0, 1);
        g4.addEdge(0, 3);
        g4.addEdge(1, 2);
        g4.addEdge(1, 4);
        g4.addEdge(2, 0);
        g4.addEdge(2, 6);
        g4.addEdge(3, 2);
        g4.addEdge(4, 5);
        g4.addEdge(4, 6);
        g4.addEdge(5, 6);
        g4.addEdge(5, 7);
        g4.addEdge(5, 8);
        g4.addEdge(5, 9);
        g4.addEdge(6, 4);
        g4.addEdge(7, 9);
        g4.addEdge(8, 9);
        g4.addEdge(9, 8);
        System.out.println(&quot;\nSSC in fourth graph &quot;);
        g4.SCC();
        Graph g5 = new Graph(5);
        g5.addEdge(0, 1);
        g5.addEdge(1, 2);
        g5.addEdge(2, 3);
        g5.addEdge(2, 4);
        g5.addEdge(3, 0);
        g5.addEdge(4, 2);
        System.out.println(&quot;\nSSC in fifth graph &quot;);
        g5.SCC();
    }
}
</java>
  <cpp>#include&lt;bits/stdc++.h&gt;
#include &lt;cstdlib&gt;
#define MAX 99999
#define NIL -1
using namespace std;
list&lt;int&gt; adj[MAX];

struct Graph {
    int V;

    void initGraph(int v) {
        for (int i = 0; i &lt; v; i++) {
            adj[i].clear();
        }
    }

    void addEdge(int v, int w) {
        adj[v].push_back(w);
    }

    void SCCUtil(int u, int disc[], int low[], stack&lt;int&gt;&amp; st, bool stackMember[]) {
        static int time = 0;
        disc[u] = low[u] = ++time;
        st.push(u);
        stackMember[u] = true;
        for (int i : adj[u]) {
            int v = i;

            if (disc[v] == -1) {
                SCCUtil(v, disc, low, st, stackMember);


                low[u] = min(low[u], low[v]);
            }

            else if (stackMember[v] == true) {
                low[u] = min(low[u], disc[v]);
            }
        }
        int w = 0;
        if (low[u] == disc[u]) {
            while (st.top() != u) {
                w = (int) st.top();
                cout &lt;&lt; w &lt;&lt; &quot; &quot;;
                stackMember[w] = false;
                st.pop();
            }
            w = (int) st.top();
            cout &lt;&lt; w &lt;&lt; &quot;\n&quot;;
            stackMember[w] = false;
            st.pop();
        }
    }

    void SCC() {
        int disc [V];
        int low [V];
        bool stackMember [V];
        stack&lt;int&gt; st;

        for (int i = 0; i &lt; V; i++) {
            disc[i] = NIL;
            low[i] = NIL;
            stackMember[i] = false;
        }

        for (int i = 0; i &lt; V; i++) {
            if (disc[i] == NIL) {
                SCCUtil(i, disc, low, st, stackMember);
            }
        }
    }

};

int main() {
    cout &lt;&lt; &quot;\nSCCs in first graph \n&quot;;
    Graph g1;
    g1.V = 5;
    g1.initGraph(5);
    g1.addEdge(1, 0);
    g1.addEdge(0, 2);
    g1.addEdge(2, 1);
    g1.addEdge(0, 3);
    g1.addEdge(3, 4);
    g1.SCC();

    cout &lt;&lt; &quot;\nSCCs in second graph \n&quot;;
    Graph g2;
    g2.V = 4;
    g2.initGraph(4);
    g2.addEdge(0, 1);
    g2.addEdge(1, 2);
    g2.addEdge(2, 3);
    g2.SCC();

    cout &lt;&lt; &quot;\nSCCs in third graph \n&quot;;
    Graph g3;
    g3.V = 7;
    g3.initGraph(7);
    g3.addEdge(0, 1);
    g3.addEdge(1, 2);
    g3.addEdge(2, 0);
    g3.addEdge(1, 3);
    g3.addEdge(1, 4);
    g3.addEdge(1, 6);
    g3.addEdge(3, 5);
    g3.addEdge(4, 5);
    g3.SCC();

    cout &lt;&lt; &quot;\nSCCs in fourth graph \n&quot;;
    Graph g4;
    g4.V = 11;
    g4.initGraph(11);
    g4.addEdge(0, 1);
    g4.addEdge(0, 3);
    g4.addEdge(1, 2);
    g4.addEdge(1, 4);
    g4.addEdge(2, 0);
    g4.addEdge(2, 6);
    g4.addEdge(3, 2);
    g4.addEdge(4, 5);
    g4.addEdge(4, 6);
    g4.addEdge(5, 6);
    g4.addEdge(5, 7);
    g4.addEdge(5, 8);
    g4.addEdge(5, 9);
    g4.addEdge(6, 4);
    g4.addEdge(7, 9);
    g4.addEdge(8, 9);
    g4.addEdge(9, 8);
    g4.SCC();

    cout &lt;&lt; &quot;\nSCCs in fifth graph \n&quot;;
    Graph g5;
    g5.V = 5;
    g5.initGraph(5);
    g5.addEdge(0, 1);
    g5.addEdge(1, 2);
    g5.addEdge(2, 3);
    g5.addEdge(2, 4);
    g5.addEdge(3, 0);
    g5.addEdge(4, 2);
    g5.SCC();

    cout &lt;&lt; &quot;\nSCCs in sixth graph \n&quot;;
    Graph g6;
    g6.V = 5;
    g6.initGraph(5);
    g6.addEdge(2, 1);
    g6.addEdge(0, 2);
    g6.addEdge(1, 3);
    g6.addEdge(1, 2);
    g6.addEdge(2, 3);
    g6.addEdge(4, 2);
    g6.SCC();

    cout &lt;&lt; &quot;\nSCCs in seventh graph \n&quot;;
    Graph g7;
    g7.V = 4;
    g7.initGraph(4);
    g7.addEdge(0, 1);
    g7.addEdge(1, 2);
    g7.addEdge(2, 3);
    g7.addEdge(0, 3);
    g7.addEdge(1, 0);
    g7.SCC();


    return 0;
}
</cpp>
  <py>from collections import defaultdict
 
   
class Graph: 
   
    def __init__(self, vertices): 
        self.V = vertices  
        self.graph = defaultdict(list)  
        self.Time = 0
  
    def addEdge(self, u, v): 
        self.graph[u].append(v) 
          
    def SCCUtil(self, u, low, disc, stackMember, st): 
  
        disc[u] = self.Time 
        low[u] = self.Time 
        self.Time += 1
        stackMember[u] = True
        st.append(u) 
        for v in self.graph[u]: 
            if disc[v] == -1: 
              
                self.SCCUtil(v, low, disc, stackMember, st) 
 
                low[u] = min(low[u], low[v]) 
            elif stackMember[v] == True:  
                low[u] = min(low[u], disc[v]) 
  

        w = -1 
        if low[u] == disc[u]: 
            while w != u: 
                w = st.pop() 
                print w, 
                stackMember[w] = False
                  
            print&quot;&quot; 
              
    def SCC(self): 
        disc = [-1] * (self.V) 
        low = [-1] * (self.V) 
        stackMember = [False] * (self.V) 
        st = [] 
        for i in range(self.V): 
            if disc[i] == -1: 
                self.SCCUtil(i, low, disc, stackMember, st) 

g1 = Graph(5) 
g1.addEdge(1, 0) 
g1.addEdge(0, 2) 
g1.addEdge(2, 1) 
g1.addEdge(0, 3) 
g1.addEdge(3, 4) 
print &quot;SSC in first graph &quot;
g1.SCC() 
  
g2 = Graph(4) 
g2.addEdge(0, 1) 
g2.addEdge(1, 2) 
g2.addEdge(2, 3) 
print &quot;nSSC in second graph &quot;
g2.SCC() 
  
   
g3 = Graph(7) 
g3.addEdge(0, 1) 
g3.addEdge(1, 2) 
g3.addEdge(2, 0) 
g3.addEdge(1, 3) 
g3.addEdge(1, 4) 
g3.addEdge(1, 6) 
g3.addEdge(3, 5) 
g3.addEdge(4, 5) 
print &quot;nSSC in third graph &quot;
g3.SCC() 
  
g4 = Graph(11) 
g4.addEdge(0, 1) 
g4.addEdge(0, 3) 
g4.addEdge(1, 2) 
g4.addEdge(1, 4) 
g4.addEdge(2, 0) 
g4.addEdge(2, 6) 
g4.addEdge(3, 2) 
g4.addEdge(4, 5) 
g4.addEdge(4, 6) 
g4.addEdge(5, 6) 
g4.addEdge(5, 7) 
g4.addEdge(5, 8) 
g4.addEdge(5, 9) 
g4.addEdge(6, 4) 
g4.addEdge(7, 9) 
g4.addEdge(8, 9) 
g4.addEdge(9, 8) 
print &quot;nSSC in fourth graph &quot;
g4.SCC(); 
  
  
g5 = Graph (5) 
g5.addEdge(0, 1) 
g5.addEdge(1, 2) 
g5.addEdge(2, 3) 
g5.addEdge(2, 4) 
g5.addEdge(3, 0) 
g5.addEdge(4, 2) 
print &quot;nSSC in fifth graph &quot;
g5.SCC();
</py>
  <orden>8</orden>
  <suborden>40</suborden>
  <fecha_creacion>2020-12-06 19:51:47</fecha_creacion>
  <fecha_modificacion>2022-03-08 12:28:52</fecha_modificacion>
</row>
<row>
  <ID>237</ID>
  <supergrupo>Grafos</supergrupo>
  <tema>Máximo cotejamiento bipartito</tema>
  <texto>Una coincidencia en un gráfico bipartito es un conjunto de aristas elegidas de tal manera que no haya dos aristas que compartan un punto final. Una coincidencia máxima es una coincidencia de tamaño máximo (número máximo de aristas). En una coincidencia máxima, si se le agrega algúna arista, ya no es una coincidencia. Puede haber más de una coincidencia máxima para un gráfico bipartito determinado.

Hay muchos problemas del mundo real que pueden formarse como emparejamiento bipartito. Por ejemplo, considere el siguiente problema:
Hay M solicitantes de empleo y N trabajos. Cada solicitante tiene un subconjunto de trabajos que le interesan. Cada oferta de trabajo solo puede aceptar un solicitante y un solicitante de trabajo puede ser designado para un solo trabajo. Busque una asignación de puestos de trabajo a los solicitantes de manera que la mayor cantidad posible de solicitantes consiga trabajo.

Problema de coincidencia máxima bipartita y flujo máximo
El problema de máxima coincidencia bipartita (MBP) se puede resolver convirtiéndolo en una red de flujo
Los siguientes son los pasos.

1) Construya una red de flujo
Debe haber una fuente y un sumidero en una red de flujo. Entonces agregamos una fuente y agregamos aristas desde la fuente a todos los solicitantes. Del mismo modo, agregue aristas de todos los trabajos para hundirlos. La capacidad de cada arista está marcada como 1 unidad.

2) Encuentre el flujo máximo.
Usamos el algoritmo de Ford-Fulkerson para encontrar el flujo máximo en la red de flujo construida en el paso 1. El flujo máximo es en realidad el MBP que estamos buscando.

¿Cómo implementar el enfoque anterior?
Primero definamos las formas de entrada y salida. La entrada tiene la forma de matriz de Edmonds, que es una matriz 2D &quot;bpGraph [M] [N]&quot; con M filas (para M solicitantes de empleo) y N columnas (para N empleos). El valor bpGraph [i] [j] es 1 si el i-ésimo solicitante está interesado en el j&#39;th trabajo; de lo contrario, 0.
La salida es el número máximo de personas que pueden conseguir trabajo.
Una forma sencilla de implementar esto es crear una matriz que represente la representación de la matriz de adyacencia de un gráfico dirigido con M + N + 2 vértices. Llame a fordFulkerson () para la matriz. Esta implementación requiere O ((M + N) * (M + N)) espacio extra.
El espacio adicional se puede reducir y el código se puede simplificar utilizando el hecho de que el gráfico es bipartito y la capacidad de cada arista es 0 o 1. La idea es utilizar el recorrido DFS para encontrar un trabajo para un solicitante (similar a aumentar la ruta en Ford-Fulkerson). Llamamos bpm () para cada solicitante, bpm () es la función basada en DFS que intenta todas las posibilidades para asignar un trabajo al solicitante.

En bpm (), probamos uno por uno todos los trabajos que le interesan a un solicitante &quot;u&quot; hasta que encontramos un trabajo, o todos los trabajos se prueban sin suerte. Para cada trabajo que intentamos, hacemos lo siguiente.
Si un trabajo no se asigna a nadie, simplemente se lo asignamos al solicitante y devolvemos verdadero. Si se asigna un trabajo a otra persona, digamos x, entonces verificamos recursivamente si a x se le puede asignar algún otro trabajo. Para asegurarnos de que x no obtenga el mismo trabajo nuevamente, marcamos el trabajo &quot;v&quot; como se ve antes de hacer una llamada recursiva para x. Si x puede conseguir otro trabajo, cambiamos al solicitante del trabajo &quot;v&quot; y devolvemos verdadero. Usamos una matriz maxR [0..N-1] que almacena los solicitantes asignados a diferentes trabajos.
Si bmp () devuelve verdadero, significa que hay una ruta de aumento en la red de flujo y se agrega 1 unidad de flujo al resultado en maxBPM ().
</texto>
  <complejidad_tiempo>null</complejidad_tiempo>
  <java>// Un programa Java para encontrar la máxima coincidencia bipartita.

public class MaximumBipartiteMatching {

    // M es el número de solicitantes y N es el número de trabajos
    static final int M = 6;
    static final int N = 6;

    // Una función recursiva basada en DFS que devuelve verdadero si es posible una coincidencia para el vértice u
    static boolean bpm(boolean bpGraph[][], int u,
            boolean seen[], int matchR[]) {
        // Prueba cada trabajo uno por uno
        for (int v = 0; v &lt; N; v++) {
            // Si el solicitante u está interesado en el trabajo v y v no es visitado
            if (bpGraph[u][v] &amp;&amp; !seen[v]) {

                // Marcar v como visitado
                seen[v] = true;

                // Si el trabajo &#39;v&#39; no está asignado a un solicitante OR si 
                // el solicitante previamente asignado para el trabajo v 
                // (que es matchR [v]) tiene un trabajo alternativo disponible. 
                // Dado que v está marcado como visitado en la línea anterior, 
                // matchR [v] en la siguiente llamada recursiva no obtendrá el 
                // trabajo &#39;v&#39; nuevamente
                if (matchR[v] &lt; 0 || bpm(bpGraph, matchR[v],
                        seen, matchR)) {
                    matchR[v] = u;
                    return true;
                }
            }
        }
        return false;
    }

    // Marcar v como visitado Devuelve el número máximo de 
    // coincidencias de M a N
    static int maxBPM(boolean bpGraph[][]) {
        // Una matriz para realizar un seguimiento de los solicitantes 
        // asignados a los trabajos. El valor de matchR [i] es el número de 
        // solicitante asignado al trabajo i, el valor -1 indica 
        // que nadie está asignado.
        int matchR[] = new int[N];

        // Inicialmente todos los trabajos están disponibles
        for (int i = 0; i &lt; N; ++i) {
            matchR[i] = -1;
        }

        // Recuento de trabajos asignados a los solicitantes
        int result = 0;
        for (int u = 0; u &lt; M; u++) {
            // Marque todos los trabajos como no se ven para el próximo solicitante.
            boolean seen[] = new boolean[N];
            for (int i = 0; i &lt; N; ++i) {
                seen[i] = false;
            }
            // Averigüe si el solicitante &#39;u&#39; puede conseguir un trabajo
            if (bpm(bpGraph, u, seen, matchR)) {
                result++;
            }
        }
        return result;
    }

    public static void main(String[] args)
            throws java.lang.Exception {
        // Creemos un bpGraph que se muestra en el ejemplo anterior
        boolean bpGraph[][] = new boolean[][]{
            {false, true, true,false, false, false},
            {true, false, false,true, false, false},
            {false, false, true, false, false, false},
            {false, false, true, true, false, false},
            {false, false, false, false, false, false},
            {false, false, false, false, false, true}};
        System.out.println(&quot;Maximum number of applicants that can&quot;
                + &quot; get job is &quot; + maxBPM(bpGraph));
    }
}
</java>
  <cpp>#include &lt;iostream&gt; 
#include &lt;string.h&gt; 
using namespace std;
#define M 6 
#define N 6 

bool bpm(bool bpGraph[M][N], int u,
        bool seen[], int matchR[]) {

    for (int v = 0; v &lt; N; v++) {

        if (bpGraph[u][v] &amp;&amp; !seen[v]) {

            seen[v] = true;

            if (matchR[v] &lt; 0 || bpm(bpGraph, matchR[v],
                    seen, matchR)) {
                matchR[v] = u;
                return true;
            }
        }
    }
    return false;
}

int maxBPM(bool bpGraph[M][N]) {

    int matchR[N];
    memset(matchR, -1, sizeof (matchR));

    int result = 0;
    for (int u = 0; u &lt; M; u++) {
        bool seen[N];
        memset(seen, 0, sizeof (seen));
        if (bpm(bpGraph, u, seen, matchR))
            result++;
    }
    return result;
}

int main() {

    bool bpGraph[M][N] = {
        {0, 1, 1, 0, 0, 0},
        {1, 0, 0, 1, 0, 0},
        {0, 0, 1, 0, 0, 0},
        {0, 0, 1, 1, 0, 0},
        {0, 0, 0, 0, 0, 0},
        {0, 0, 0, 0, 0, 1}
    };

    cout &lt;&lt; &quot;Maximum number of applicants that can get job is &quot;
            &lt;&lt; maxBPM(bpGraph);

    return 0;
} 
</cpp>
  <py>class MBM: 
    def __init__(self, graph): 
        self.graph = graph  
        self.ppl = len(graph) 
        self.jobs = len(graph[0]) 
    def bpm(self, u, matchR, seen): 
        for v in range(self.jobs): 
            if self.graph[u][v] and seen[v] == False: 
                seen[v] = True 
                if matchR[v] == -1 or self.bpm(matchR[v], matchR, seen): 
                    matchR[v] = u 
                    return True
        return False

    def maxBPM(self): 
        matchR = [-1] * self.jobs 
        result = 0 
        for i in range(self.ppl): 
            seen = [False] * self.jobs 
            if self.bpm(i, matchR, seen): 
                result += 1
        return result 
  
  
bpGraph = [[0, 1, 1, 0, 0, 0], 
    [1, 0, 0, 1, 0, 0], 
    [0, 0, 1, 0, 0, 0], 
    [0, 0, 1, 1, 0, 0], 
    [0, 0, 0, 0, 0, 0], 
    [0, 0, 0, 0, 0, 1]] 
  
g = MBM(bpGraph) 
  
print (&quot;Maximum number of applicants that can get job is %d &quot; % g.maxBPM()) 
</py>
  <orden>8</orden>
  <suborden>41</suborden>
  <fecha_creacion>2020-12-06 19:51:48</fecha_creacion>
  <fecha_modificacion>2022-03-08 12:28:52</fecha_modificacion>
</row>
<row>
  <ID>238</ID>
  <supergrupo>Grafos</supergrupo>
  <tema>Lazy Propagation</tema>
  <texto>Consideremos el siguiente problema para comprender los árboles de segmentos.
Tenemos una matriz arr [0. . . n-1]. Deberíamos poder
1 Encuentre la suma de los elementos del índice la r donde 0 &lt;= l &lt;= r &lt;= n-1
2 Cambie el valor de un elemento especificado de la matriz a un nuevo valor x. Necesitamos hacer arr [i] = x donde 0 &lt;= i &lt;= n-1.
Una solución simple es ejecutar un ciclo de la ry calcular la suma de elementos en el rango dado. Para actualizar un valor, simplemente haga arr [i] = x. La primera operación toma O (n) tiempo y la segunda operación toma O (1) tiempo.
Otra solución es crear otra matriz y almacenar la suma desde el principio hasta la i en el índice i en esta matriz. La suma de un rango dado ahora se puede calcular en O (1) tiempo, pero la operación de actualización toma O (n) tiempo ahora. Esto funciona bien si el número de operaciones de consulta es grande y muy pocas actualizaciones.

¿Qué pasa si el número de consultas y actualizaciones es igual? ¿Podemos realizar ambas operaciones en tiempo O (log n) una vez dada la matriz? Podemos usar un árbol de segmentos para realizar ambas operaciones en tiempo O (Logn).
Representación de árboles de segmentos
1. Los nodos hoja son los elementos de la matriz de entrada.
2. Cada nodo interno representa alguna fusión de los nodos hoja. La combinación puede ser diferente para diferentes problemas. Para este problema, la fusión es la suma de hojas debajo de un nodo.
Se utiliza una representación de matriz de árbol para representar árboles de segmento. Para cada nodo en el índice i, el hijo izquierdo está en el índice 2 * i + 1, el hijo derecho en 2 * i + 2 y el padre está en.
 
¿Cómo se ve el árbol de segmentos anterior en la memoria?
Al igual que Heap, el árbol de segmentos también se representa como una matriz. La diferencia aquí es que no es un árbol binario completo. Es más bien un árbol binario completo (cada nodo tiene 0 o 2 hijos) y todos los niveles están llenos excepto posiblemente el último nivel. A diferencia de Heap, el último nivel puede tener espacios entre los nodos. A continuación se muestran los valores en la matriz de árbol de segmentos para el diagrama anterior.

A continuación se muestra la representación en memoria del árbol de segmentos para la matriz de entrada {1, 3, 5, 7, 9, 11}
st [] = {36, 9, 27, 4, 5, 16, 11, 1, 3, DUMMY, DUMMY, 7, 9, DUMMY, DUMMY}

Los valores ficticios nunca se acceden y no tienen uso. Este es un desperdicio de espacio debido a la simple representación de una matriz. Podemos optimizar este desperdicio usando algunas implementaciones inteligentes, pero el código para suma y actualización se vuelve más complejo.
Construcción del árbol de segmentos a partir de una matriz dada
Comenzamos con un segmento arr [0. . . n-1]. y cada vez que dividimos el segmento actual en dos mitades (si aún no se ha convertido en un segmento de longitud 1), y luego llamamos al mismo procedimiento en ambas mitades, y para cada segmento, almacenamos la suma en el nodo correspondiente.
Todos los niveles del árbol de segmentos construido se llenarán por completo excepto el último nivel. Además, el árbol será un árbol binario completo porque siempre dividimos los segmentos en dos mitades en cada nivel. Dado que el árbol construido es siempre un árbol binario completo con n hojas, habrá n-1 nodos internos. Entonces, el número total de nodos será 2 * n - 1. Tenga en cuenta que esto no incluye los nodos ficticios.

¿Cuál es el tamaño total de la matriz que representa el árbol de segmentos?
Si n es una potencia de 2, entonces no hay nodos ficticios. Entonces, el tamaño del árbol de segmentos es 2n-1 (n nodos hoja y n-1) nodos internos. Si n no es una potencia de 2, entonces el tamaño del árbol será 2 * x - 1 donde x es la potencia más pequeña de 2 mayor que n. Por ejemplo, cuando n = 10, el tamaño de la matriz que representa el árbol de segmentos es 2 * 16-1 = 31.
Una explicación alternativa para el tamaño se basa en la altura. La altura del árbol de segmentos será. Dado que el árbol se representa mediante una matriz y la relación entre los índices padre e hijo debe mantenerse, el tamaño de la memoria asignada para el árbol de segmentos será.
Consulta de la suma del rango dado
Una vez que se construye el árbol, cómo obtener la suma utilizando el árbol de segmentos construido. El siguiente es el algoritmo para obtener la suma de elementos.
int getSum (nodo, l, r)
{
   si el rango del nodo está dentro de lyr
        valor de retorno en el nodo
   de lo contrario, si el rango del nodo está completamente fuera de lyr
        volver 0
   más
    return getSum (hijo izquierdo del nodo, l, r) +
           getSum (hijo derecho del nodo, l, r)
}
Actualizar un valor
Al igual que la construcción de árboles y las operaciones de consulta, la actualización también se puede realizar de forma recursiva. Se nos da un índice que debe actualizarse. Sea diff el valor a agregar. Comenzamos desde la raíz del árbol de segmentos y agregamos diff a todos los nodos que han dado índice en su rango. Si un nodo no tiene un índice determinado en su rango, no realizamos ningún cambio en ese nodo.

Propagación diferida: una optimización para agilizar las actualizaciones de rango
Cuando hay muchas actualizaciones y se realizan actualizaciones en un rango, podemos posponer algunas actualizaciones (evitar llamadas recursivas en la actualización) y hacer esas actualizaciones solo cuando sea necesario.
Recuerde que un nodo en el árbol de segmentos almacena o representa el resultado de una consulta para un rango de índices. Y si el rango de este nodo se encuentra dentro del rango de la operación de actualización, entonces todos los descendientes del nodo también deben actualizarse. Por ejemplo, considere el nodo con el valor 27 en el diagrama anterior, este nodo almacena la suma de los valores en los índices de 3 a 5. Si nuestra consulta de actualización es para el rango 2 a 5, entonces necesitamos actualizar este nodo y todos los descendientes de este nodo. Con la propagación diferida, actualizamos solo el nodo con valor 27 y posponemos las actualizaciones a sus hijos almacenando esta información de actualización en nodos separados llamados nodos o valores diferidos. Creamos una matriz lazy [] que representa el nodo perezoso. El tamaño de lazy [] es el mismo que el de la matriz que representa el árbol de segmentos, que es el árbol [] en el código siguiente.
La idea es inicializar todos los elementos de lazy [] como 0. Un valor 0 en lazy [i] indica que no hay actualizaciones pendientes en el nodo i en el árbol de segmentos. Un valor distinto de cero de lazy [i] significa que esta cantidad debe agregarse al nodo i en el árbol de segmentos antes de realizar cualquier consulta al nodo.

A continuación se muestra el método de actualización modificado.
// Para actualizar el árbol de segmentos para cambiar la matriz
// valores en los índices de matriz de nosotros a ue.
updateRange (nosotros, ue)
1) Si el nodo del árbol del segmento actual tiene algún pendiente
   actualizar, luego primero agregue esa actualización pendiente a
   nodo actual.
2) Si el rango del nodo actual se encuentra completamente en
   actualizar el rango de consultas.
.... a) Actualizar el nodo actual
.... b) Posponga las actualizaciones para los niños estableciendo
       valor perezoso para los nodos secundarios.
3) Si el rango del nodo actual se superpone con la actualización
   rango, siga el mismo enfoque que el anterior simple
   actualizar.
... a) Recurrir para niños izquierdos y derechos.
... b) Actualizar el nodo actual usando los resultados de left
      y llamadas correctas.

¿También hay algún cambio en la función de consulta?
Dado que hemos cambiado la actualización para posponer sus operaciones, puede haber problemas si se realiza una consulta a un nodo que aún no se ha actualizado. Por lo tanto, también debemos actualizar nuestro método de consulta, que es getSumUtil en la publicación anterior. GetSumUtil () ahora primero verifica si hay una actualización pendiente y si la hay, luego actualiza el nodo. Una vez que se asegura de que se realiza la actualización pendiente, funciona igual que el getSumUtil () anterior.
</texto>
  <complejidad_tiempo>null</complejidad_tiempo>
  <java>// Programa Java para demostrar la propagación diferida en el árbol de segmentos

public class LazyPropagation {

    static final int MAX = 1000;         // Tamaño máximo del árbol
    static int tree[] = new int[MAX]; // Para almacenar el árbol de segmentos
    static int lazy[] = new int[MAX]; // Para almacenar actualizaciones pendientes

    /*  si -&gt; índice del nodo actual en el árbol de 
        segmentos ss y se -&gt; Índices inicial y final de 
        los elementos para los que los nodos actuales almacenan la suma.
        us y eu -&gt; índices de inicio y finalización de la consulta 
        de actualización
        ue -&gt; índice final de la consulta de actualización
        diff -&gt; que necesitamos agregar en el rango us to ue */
    static void updateRangeUtil(int si, int ss, int se, int us,
            int ue, int diff) {
        // Si el valor diferido es distinto de cero para el nodo 
        // actual del árbol de segmentos, hay algunas actualizaciones 
        // pendientes. Por lo tanto, debemos asegurarnos de que las 
        // actualizaciones pendientes se realicen antes de realizar 
        // nuevas actualizaciones. Porque este valor puede ser 
        // utilizado por los padres después de llamadas recursivas 
        // (ver la última línea de esta función)
        if (lazy[si] != 0) {
            // Realice actualizaciones pendientes utilizando el 
            // valor almacenado en nodos perezosos
            tree[si] += (se - ss + 1) * lazy[si];
            // comprobando si no es un nodo hoja porque si 
            // es un nodo hoja entonces no podemos ir más lejos
            if (ss != se) {
                // Podemos posponer la actualización de los niños, 
                // no necesitamos sus nuevos valores ahora. Dado que 
                // aún no estamos actualizando los hijos de si,
                // necesitamos establecer banderas perezosas para los hijos
                lazy[si * 2 + 1] += lazy[si];
                lazy[si * 2 + 2] += lazy[si];
            }

            // Establezca el valor diferido para el nodo actual en 0, ya que se ha actualizado
            lazy[si] = 0;
        }

        // fuera de rango
        if (ss &gt; se || ss &gt; ue || se &lt; us) {
            return;
        }

        // El segmento actual está completamente dentro del rango
        if (ss &gt;= us &amp;&amp; se &lt;= ue) {
            // Agregar la diferencia al nodo actual
            tree[si] += (se - ss + 1) * diff;
            // misma lógica para verificar el nodo hoja o no
            if (ss != se) {
                // Aquí es donde almacenamos los valores en los nodos 
                // perezosos, en lugar de actualizar el árbol de segmentos 
                // en sí. Dado que no necesitamos estos valores actualizados 
                // ahora posponemos las actualizaciones almacenando 
                // los valores en lazy []
                lazy[si * 2 + 1] += diff;
                lazy[si * 2 + 2] += diff;
            }
            return;
        }

        // Si no está completamente en sonó, pero se superpone, repita para los niños,
        int mid = (ss + se) / 2;
        updateRangeUtil(si * 2 + 1, ss, mid, us, ue, diff);
        updateRangeUtil(si * 2 + 2, mid + 1, se, us, ue, diff);

        // Y use el resultado de las llamadas de los niños para actualizar este nodo
        tree[si] = tree[si * 2 + 1] + tree[si * 2 + 2];
    }

    // Función para actualizar un rango de valores en el árbol de segmentos
    /* us y eu -&gt; índices de inicio y finalización de la consulta de actualización
        ue -&gt; índice final de la consulta de actualización
        diff -&gt; que necesitamos agregar en el rango us to ue */
    static void updateRange(int n, int us, int ue, int diff) {
        updateRangeUtil(0, 0, n - 1, us, ue, diff);
    }

    /* Una función recursiva para obtener la suma de valores en un rango dado
       de la matriz. Los siguientes son parámetros para esta función.
       si -&gt; Índice del nodo actual en el árbol de segmentos. Inicialmente 
             se pasa 0 ya que la raíz siempre está en el &#39;índice 0
       ss &amp; se -&gt; Índices de inicio y finalización del segmento 
                  representado por el nodo actual, es decir, árbol [si]
       qs &amp; qe -&gt; Índices de inicio y finalización del rango de consulta */
    static int getSumUtil(int ss, int se, int qs, int qe, int si) {
        // Si se establece el indicador diferido para el nodo actual del 
        // árbol de segmentos, hay algunas actualizaciones pendientes. 
        // Por lo tanto, debemos asegurarnos de que las actualizaciones 
        // pendientes se realicen antes de procesar la consulta 
        // de suma secundaria.
        if (lazy[si] != 0) {
            // Realice actualizaciones pendientes en este nodo. Tenga en 
            // cuenta que este nodo representa la suma de elementos en 
            // arr [ss..se] y todos estos elementos deben 
            // aumentarse mediante lazy [si]
            tree[si] += (se - ss + 1) * lazy[si];

            // comprobando si no es un nodo hoja porque si es un 
            // nodo hoja entonces no podemos ir más lejos
            if (ss != se) {
                // Dado que todavía no estamos actualizando el sistema 
                // operativo de los niños, debemos establecer 
                // valores perezosos para los niños.
                lazy[si * 2 + 1] += lazy[si];
                lazy[si * 2 + 2] += lazy[si];
            }

            // anule el valor diferido para el nodo actual, 
            // ya que se ha actualizado
            lazy[si] = 0;
        }

        // Fuera de rango
        if (ss &gt; se || ss &gt; qe || se &lt; qs) {
            return 0;
        }

        // En este punto, seguro que se realizan las actualizaciones 
        // diferidas pendientes para el nodo actual. Entonces podemos 
        // devolver el valor (igual que para la consulta en nuestra 
        // publicación anterior) si este segmento se encuentra en el rango
        if (ss &gt;= qs &amp;&amp; se &lt;= qe) {
            return tree[si];
        }
        // Si una parte de este segmento se superpone con el rango dado
        int mid = (ss + se) / 2;
        return getSumUtil(ss, mid, qs, qe, 2 * si + 1)
                + getSumUtil(mid + 1, se, qs, qe, 2 * si + 2);
    }

    // Devuelve la suma de los elementos en el rango desde el índice qs 
    // (inicio de la consulta) hasta qe (final de la consulta). 
    // Utiliza principalmente getSumUtil ()
    static int getSum(int n, int qs, int qe) {
        // Compruebe si hay valores de entrada erróneos
        if (qs &lt; 0 || qe &gt; n - 1 || qs &gt; qe) {
            System.out.println(&quot;Invalid Input&quot;);
            return -1;
        }

        return getSumUtil(0, n - 1, qs, qe, 0);
    }

    /* Una función recursiva que construye el árbol de segmentos para 
       la matriz [ss..se]. si es el índice del nodo actual en el 
       árbol de segmentos st. */
    static void constructSTUtil(int arr[], int ss, int se, int si) {
        // fuera de rango ya que ss nunca puede ser mayor que se
        if (ss &gt; se) {
            return;
        }
        /* Si hay un elemento en la matriz, guárdelo en
        nodo actual del árbol de segmentos y retorno */
        if (ss == se) {
            tree[si] = arr[ss];
            return;
        }

        /* Si hay más de un elemento, repita para los 
        subárboles izquierdo y derecho y almacene la 
        suma de valores en este nodo */
        int mid = (ss + se) / 2;
        constructSTUtil(arr, ss, mid, si * 2 + 1);
        constructSTUtil(arr, mid + 1, se, si * 2 + 2);

        tree[si] = tree[si * 2 + 1] + tree[si * 2 + 2];
    }

    /* Función para construir un árbol de segmentos a partir de una matriz 
    dada. Esta función asigna memoria para el árbol de segmentos 
    y llama a constructSTUtil () para llenar la memoria asignada */
    static void constructST(int arr[], int n) {
        // Llenar la memoria asignada st
        constructSTUtil(arr, 0, n - 1, 0);
    }

    public static void main(String args[]) {
        int arr[] = {1, 3, 5, 7, 9, 11};
        int n = arr.length;

        // Construir un árbol de segmentos a partir de una matriz dada
        constructST(arr, n);

        // Imprimir la suma de valores en la matriz desde el índice 1 al 3
        System.out.println(&quot;Sum of values in given range = &quot;
                + getSum(n, 1, 3));

        // Agregue 10 a todos los nodos en los índices del 1 al 5.
        updateRange(n, 1, 5, 10);

        // Encontrar la suma después de actualizar el valor
        System.out.println(&quot;Updated sum of values in given range = &quot;
                + getSum(n, 1, 3));
    }
}
</java>
  <cpp>#include &lt;stdio.h&gt; 
#include &lt;math.h&gt; 
#define MAX 1000 

int tree[MAX] = {0};
int lazy[MAX] = {0};

void updateRangeUtil(int si, int ss, int se, int us,
        int ue, int diff) {

    if (lazy[si] != 0) {
        tree[si] += (se - ss + 1) * lazy[si];
        if (ss != se) {
            lazy[si * 2 + 1] += lazy[si];
            lazy[si * 2 + 2] += lazy[si];
        }
        lazy[si] = 0;
    }

    if (ss &gt; se || ss &gt; ue || se &lt; us)
        return;

    if (ss &gt;= us &amp;&amp; se &lt;= ue) {
        tree[si] += (se - ss + 1) * diff;
        if (ss != se) {
            lazy[si * 2 + 1] += diff;
            lazy[si * 2 + 2] += diff;
        }
        return;
    }

    int mid = (ss + se) / 2;
    updateRangeUtil(si * 2 + 1, ss, mid, us, ue, diff);
    updateRangeUtil(si * 2 + 2, mid + 1, se, us, ue, diff);
    tree[si] = tree[si * 2 + 1] + tree[si * 2 + 2];
}

void updateRange(int n, int us, int ue, int diff) {
    updateRangeUtil(0, 0, n - 1, us, ue, diff);
}

int getSumUtil(int ss, int se, int qs, int qe, int si) {

    if (lazy[si] != 0) {
        tree[si] += (se - ss + 1) * lazy[si];
        if (ss != se) {
            lazy[si * 2 + 1] += lazy[si];
            lazy[si * 2 + 2] += lazy[si];
        }
        lazy[si] = 0;
    }

    if (ss &gt; se || ss &gt; qe || se &lt; qs)
        return 0;

    if (ss &gt;= qs &amp;&amp; se &lt;= qe)
        return tree[si];

    int mid = (ss + se) / 2;
    return getSumUtil(ss, mid, qs, qe, 2 * si + 1) +
            getSumUtil(mid + 1, se, qs, qe, 2 * si + 2);
}

int getSum(int n, int qs, int qe) {

    if (qs &lt; 0 || qe &gt; n - 1 || qs &gt; qe) {
        printf(&quot;Invalid Input&quot;);
        return -1;
    }

    return getSumUtil(0, n - 1, qs, qe, 0);
}

void constructSTUtil(int arr[], int ss, int se, int si) {
    if (ss &gt; se)
        return;
    if (ss == se) {
        tree[si] = arr[ss];
        return;
    }
    int mid = (ss + se) / 2;
    constructSTUtil(arr, ss, mid, si * 2 + 1);
    constructSTUtil(arr, mid + 1, se, si * 2 + 2);

    tree[si] = tree[si * 2 + 1] + tree[si * 2 + 2];
}

void constructST(int arr[], int n) {
    constructSTUtil(arr, 0, n - 1, 0);
}

int main() {
    int arr[] = {1, 3, 5, 7, 9, 11};
    int n = sizeof (arr) / sizeof (arr[0]);
    constructST(arr, n);
    printf(&quot;Sum of values in given range = %d\n&quot;,
            getSum(n, 1, 3));
    updateRange(n, 1, 5, 10);
    printf(&quot;Updated sum of values in given range = %d\n&quot;,
            getSum(n, 1, 3));

    return 0;
}
</cpp>
  <py>MAX = 1000
tree = [0] * MAX; 
lazy = [0] * MAX;


def updateRangeUtil(si, ss, se, us, ue, diff):  
    if (lazy[si] != 0): 
        tree[si] += (se - ss + 1) * lazy[si]; 
        if (ss != se): 
            lazy[si * 2 + 1] += lazy[si]; 
            lazy[si * 2 + 2] += lazy[si]; 
        lazy[si] = 0; 
    if (ss &gt; se or ss &gt; ue or se &lt; us): 
        return; 
    if (ss &gt;= us and se &lt;= ue): 
        tree[si] += (se - ss + 1) * diff; 
        if (ss != se): 
            lazy[si * 2 + 1] += diff; 
            lazy[si * 2 + 2] += diff; 
        return; 
    mid = (ss + se) // 2; 
    updateRangeUtil(si * 2 + 1, ss, 
                    mid, us, ue, diff); 
    updateRangeUtil(si * 2 + 2, mid + 1, 
                    se, us, ue, diff); 
    tree[si] = tree[si * 2 + 1] + \ tree[si * 2 + 2]; 

def updateRange(n, us, ue, diff): 
    updateRangeUtil(0, 0, n - 1, us, ue, diff); 

def getSumUtil(ss, se, qs, qe, si): 
    if (lazy[si] != 0): 
        tree[si] += (se - ss + 1) * lazy[si]; 
        if (ss != se): 
            lazy[si * 2 + 1] += lazy[si]; 
            lazy[si * 2 + 2] += lazy[si]; 
        lazy[si] = 0; 
    if (ss &gt; se or ss &gt; qe or se &lt; qs): 
        return 0; 
    if (ss &gt;= qs and se &lt;= qe): 
        return tree[si]; 
    mid = (ss + se) // 2; 
    return (getSumUtil(ss, mid, qs, qe, 2 * si + 1) +
            getSumUtil(mid + 1, se, qs, qe, 2 * si + 2)); 
def getSum(n, qs, qe): 
    if (qs &lt; 0 or qe &gt; n - 1 or qs &gt; qe): 
        print(&quot;Invalid Input&quot;); 
        return -1; 

    return getSumUtil(0, n - 1, qs, qe, 0); 

def constructSTUtil(arr, ss, se, si): 
    if (ss &gt; se): 
        return; 
    if (ss == se): 
        
        tree[si] = arr[ss]; 
        return; 
    mid = (ss + se) // 2; 
    constructSTUtil(arr, ss, mid, si * 2 + 1); 
    constructSTUtil(arr, mid + 1, se, si * 2 + 2); 

    tree[si] = tree[si * 2 + 1] + tree[si * 2 + 2]; 

def constructST(arr, n): 
    constructSTUtil(arr, 0, n - 1, 0); 

arr = [1, 3, 5, 7, 9, 11]; 
n = len(arr); 
constructST(arr, n); 
print(&quot;Sum of values in given range =&quot;, getSum(n, 1, 3)); 
updateRange(n, 1, 5, 10); 
print(&quot;Updated sum of values in given range =&quot;, getSum(n, 1, 3)); 
</py>
  <orden>8</orden>
  <suborden>42</suborden>
  <fecha_creacion>2020-12-06 19:51:48</fecha_creacion>
  <fecha_modificacion>2022-03-08 12:28:52</fecha_modificacion>
</row>
<row>
  <ID>239</ID>
  <supergrupo>Grafos</supergrupo>
  <tema>Componentes biconectados </tema>
  <texto>Un componente biconectado es un subgrafo biconectado máximo.
Un grafo no dirigido se llama Biconnectado si hay dos rutas de vértice disjunto entre dos vértices cualesquiera. En un gráfico biconectado, hay un ciclo simple a través de dos vértices cualesquiera.
Por convención, dos nodos conectados por una arista forman un gráfico biconectado, pero esto no verifica las propiedades anteriores. Para un gráfico con más de dos vértices, las propiedades anteriores deben estar ahí para que esté Biconectado.
O en otras palabras:
Se dice que un gráfico está biconectado si:
1) Está conectado, es decir, es posible llegar a cada vértice desde cualquier otro vértice, por un camino simple.
2) Incluso después de eliminar cualquier vértice, el gráfico permanece conectado.
A continuación se muestran algunos ejemplos. 

Ilustración 7 25 Ejemplo de componente biconectado I
 



 
Ilustración 7 26 Ejemplo de componente biconectado II
 
 
Ilustración 7 27 Ejemplo de componente no biconectado I
 
 
Ilustración 7 28 Ejemplo de componente biconectado II
 
 
Ilustración 7 29 Ejemplo de componente biconectado III
 
Un gráfico conectado está Biconectado si está conectado y no tiene ningún punto de articulación. Principalmente necesitamos verificar dos cosas en un gráfico.
1) El gráfico está conectado.
2) No hay punto de articulación en el gráfico.
Partimos de cualquier vértice y hacemos un recorrido DFS. En el recorrido DFS, comprobamos si hay algún punto de articulación. Si no encontramos ningún punto de articulación, entonces el gráfico está Biconectado. Finalmente, debemos verificar si todos los vértices fueron accesibles en DFS o no. Si no todos los vértices fueran accesibles, entonces el gráfico ni siquiera está conectado.

Ilustración 7 30 Grafo con parte conexa y desconexa
 
En el gráfico anterior, los siguientes son los componentes biconectados:
• 4–2 3–4 3–1 2–3 1–2
• 8–9
• 8–5 7–8 5–7
• 6–0 5–6 1–5 0–1
• 10-11
El algoritmo se basa en el disco y los valores bajos que se describen en el artículo Componentes fuertemente conectados.

La idea es almacenar las aristas visitadas en una pila mientras DFS en un gráfico y seguir buscando puntos de articulación (resaltados en la figura anterior). Tan pronto como se encuentre un punto de articulación u, todos las aristas visitadas mientras DFS desde el nodo u en adelante formarán un componente biconectado. Cuando DFS se completa para un componente conectado, todas las aristas presentes en la pila formarán un componente biconectado.
Si no hay un punto de articulación en el gráfico, entonces el gráfico está biconectado y, por lo tanto, habrá un componente biconectado que es el gráfico en sí.
</texto>
  <complejidad_tiempo>null</complejidad_tiempo>
  <java>// Un programa Java para encontrar componentes biconectados 
// en un gráfico no dirigido dado

import java.util.*;

public class BiconnectedComponents {

    // Esta clase representa un gráfico dirigido utilizando 
    // la representación de lista de adyacencia.
    static class Graph {

        private int V, E; // No. de vértices y aristas respectivamente
        private LinkedList&lt;Integer&gt; adj[]; // Lista de adyacencia
        // El recuento es el número de componentes biconectados. 
        // el tiempo se usa para encontrar tiempos de descubrimiento
        static int count = 0, time = 0;

        class Edge {

            int u;
            int v;

            Edge(int u, int v) {
                this.u = u;
                this.v = v;
            }
        };

        Graph(int v) {
            V = v;
            E = 0;
            adj = new LinkedList[v];
            for (int i = 0; i &lt; v; ++i) {
                adj[i] = new LinkedList();
            }
        }

        // Función para agregar una arista al gráfico
        void addEdge(int v, int w) {
            adj[v].add(w);
            E++;
        }

        // Una función recursiva que encuentra e imprime fuertemente conectados
        // componentes que utilizan DFS transversal
        // u -&gt; El vértice a visitar a continuación
        // disc[] -&gt; Almacena los tiempos de descubrimiento de los vértices visitados
        // low[] - &gt;&gt; vértice visitado más temprano (el vértice con mínimo
        // tiempo de descubrimiento) que se puede alcanzar desde el subárbol
        // arraigado con el vértice actual
        // * st - &gt;&gt; Para almacenar los bordes visitados
        void BCCUtil(int u, int disc[], int low[], LinkedList&lt;Edge&gt; st,
                int parent[]) {

            // Inicializar el tiempo de descubrimiento y el valor bajo
            disc[u] = low[u] = ++time;
            int children = 0;

            // Pasa por todos los vértices adyacentes a este
            Iterator&lt;Integer&gt; it = adj[u].iterator();
            while (it.hasNext()) {
                int v = it.next(); // v es actual adyacente a &#39;u&#39;

                // Si aún no se ha visitado v, recurra para el
                if (disc[v] == -1) {
                    children++;
                    parent[v] = u;
                    // almacenar el borde en la pila
                    st.add(new Edge(u, v));
                    BCCUtil(v, disc, low, st, parent);
                    // Compruebe si el subárbol arraigado con &#39;v&#39; tiene 
                    // una conexión con uno de los antepasados de &#39;u&#39;
                    // Caso 1: según el artículo sobre componentes 
                    //fuertemente conectados
                    if (low[u] &gt; low[v]) {
                        low[u] = low[v];
                    }

                    // Si u es un punto de articulación, 
                    // saque todos los bordes de la pila hasta u - v
                    if ((disc[u] == 1 &amp;&amp; children &gt; 1)
                            || (disc[u] &gt; 1 &amp;&amp; low[v] &gt;= disc[u])) {
                        while (st.getLast().u != u
                                || st.getLast().v != v) {
                            System.out.print(st.getLast().u
                                    + &quot;--&quot; + st.getLast().v + &quot; &quot;);
                            st.removeLast();
                        }
                        System.out.println(st.getLast().u + &quot;--&quot;
                                + st.getLast().v + &quot; &quot;);
                        st.removeLast();

                        count++;
                    }
                } // Actualice el valor bajo de &#39;u&#39; solo si &#39;v&#39; todavía 
                // está en la pila
                // (es decir, es un borde posterior, no un borde transversal).
                // Caso 2: según el artículo sobre componentes
                // fuertemente conectados
                else if (v != parent[u] &amp;&amp; disc[v] &lt; disc[u]) {
                    if (low[u] &gt; disc[v]) {
                        low[u] = disc[v];
                    }

                    st.add(new Edge(u, v));
                }
            }
        }

        // La función para hacer un recorrido DFS. Utiliza BCCUtil ()
        void BCC() {
            int disc[] = new int[V];
            int low[] = new int[V];
            int parent[] = new int[V];
            LinkedList&lt;Edge&gt; st = new LinkedList&lt;Edge&gt;();

            // Inicializar matrices de discos y matrices bajas y principales
            for (int i = 0; i &lt; V; i++) {
                disc[i] = -1;
                low[i] = -1;
                parent[i] = -1;
            }

            for (int i = 0; i &lt; V; i++) {
                if (disc[i] == -1) {
                    BCCUtil(i, disc, low, st, parent);
                }
                int j = 0;
                // Si la pila no está vacía, saque todos los bordes de la pila
                while (st.size() &gt; 0) {
                    j = 1;
                    System.out.print(st.getLast().u + &quot;--&quot;
                            + st.getLast().v + &quot; &quot;);
                    st.removeLast();
                }
                if (j == 1) {
                    System.out.println();
                    count++;
                }
            }
        }
    }

    public static void main(String args[]) {
        Graph g = new Graph(12);
        g.addEdge(0, 1);
        g.addEdge(1, 0);
        g.addEdge(1, 2);
        g.addEdge(2, 1);
        g.addEdge(1, 3);
        g.addEdge(3, 1);
        g.addEdge(2, 3);
        g.addEdge(3, 2);
        g.addEdge(2, 4);
        g.addEdge(4, 2);
        g.addEdge(3, 4);
        g.addEdge(4, 3);
        g.addEdge(1, 5);
        g.addEdge(5, 1);
        g.addEdge(0, 6);
        g.addEdge(6, 0);
        g.addEdge(5, 6);
        g.addEdge(6, 5);
        g.addEdge(5, 7);
        g.addEdge(7, 5);
        g.addEdge(5, 8);
        g.addEdge(8, 5);
        g.addEdge(7, 8);
        g.addEdge(8, 7);
        g.addEdge(8, 9);
        g.addEdge(9, 8);
        g.addEdge(10, 11);
        g.addEdge(11, 10);
        g.BCC();
        System.out.println(&quot;Above are &quot; + g.count + &quot; biconnected components in graph&quot;);
    }
}
</java>
  <cpp>#include &lt;iostream&gt; 
#include &lt;list&gt; 
#include &lt;stack&gt; 
#define NIL -1 
using namespace std;
int count = 0;

class Edge {
public:
    int u;
    int v;
    Edge(int u, int v);
};

Edge::Edge(int u, int v) {
    this-&gt;u = u;
    this-&gt;v = v;
}

class Graph {
    int V;
    int E;
    list&lt;int&gt;* adj;
    void BCCUtil(int u, int disc[], int low[],
            list&lt;Edge&gt;* st, int parent[]);

public:
    Graph(int V);
    void addEdge(int v, int w);
    void BCC();
};

Graph::Graph(int V) {
    this-&gt;V = V;
    this-&gt;E = 0;
    adj = new list&lt;int&gt;[V];
}

void Graph::addEdge(int v, int w) {
    adj[v].push_back(w);
    E++;
}

void Graph::BCCUtil(int u, int disc[], int low[], list&lt;Edge&gt;* st,
        int parent[]) {
    static int time = 0;
    disc[u] = low[u] = ++time;
    int children = 0;
    list&lt;int&gt;::iterator i;
    for (i = adj[u].begin(); i != adj[u].end(); ++i) {
        int v = *i;
        if (disc[v] == -1) {
            children++;
            parent[v] = u;
            st-&gt;push_back(Edge(u, v));
            BCCUtil(v, disc, low, st, parent);
            low[u] = min(low[u], low[v]);
            if ((disc[u] == 1 &amp;&amp; children &gt; 1) || (disc[u] &gt; 1 &amp;&amp; low[v] &gt;= disc[u])) {
                while (st-&gt;back().u != u || st-&gt;back().v != v) {
                    cout &lt;&lt; st-&gt;back().u &lt;&lt; &quot;--&quot; &lt;&lt; st-&gt;back().v &lt;&lt; &quot; &quot;;
                    st-&gt;pop_back();
                }
                cout &lt;&lt; st-&gt;back().u &lt;&lt; &quot;--&quot; &lt;&lt; st-&gt;back().v;
                st-&gt;pop_back();
                cout &lt;&lt; endl;
                count++;
            }
        } else if (v != parent[u]) {
            low[u] = min(low[u], disc[v]);
            if (disc[v] &lt; disc[u]) {
                st-&gt;push_back(Edge(u, v));
            }
        }
    }
}

void Graph::BCC() {
    int* disc = new int[V];
    int* low = new int[V];
    int* parent = new int[V];
    list&lt;Edge&gt;* st = new list&lt;Edge&gt;[E];
    for (int i = 0; i &lt; V; i++) {
        disc[i] = NIL;
        low[i] = NIL;
        parent[i] = NIL;
    }

    for (int i = 0; i &lt; V; i++) {
        if (disc[i] == NIL)
            BCCUtil(i, disc, low, st, parent);

        int j = 0;
        while (st-&gt;size() &gt; 0) {
            j = 1;
            cout &lt;&lt; st-&gt;back().u &lt;&lt; &quot;--&quot; &lt;&lt; st-&gt;back().v &lt;&lt; &quot; &quot;;
            st-&gt;pop_back();
        }
        if (j == 1) {
            cout &lt;&lt; endl;
            count++;
        }
    }
}

int main() {
    Graph g(12);
    g.addEdge(0, 1);
    g.addEdge(1, 0);
    g.addEdge(1, 2);
    g.addEdge(2, 1);
    g.addEdge(1, 3);
    g.addEdge(3, 1);
    g.addEdge(2, 3);
    g.addEdge(3, 2);
    g.addEdge(2, 4);
    g.addEdge(4, 2);
    g.addEdge(3, 4);
    g.addEdge(4, 3);
    g.addEdge(1, 5);
    g.addEdge(5, 1);
    g.addEdge(0, 6);
    g.addEdge(6, 0);
    g.addEdge(5, 6);
    g.addEdge(6, 5);
    g.addEdge(5, 7);
    g.addEdge(7, 5);
    g.addEdge(5, 8);
    g.addEdge(8, 5);
    g.addEdge(7, 8);
    g.addEdge(8, 7);
    g.addEdge(8, 9);
    g.addEdge(9, 8);
    g.addEdge(10, 11);
    g.addEdge(11, 10);
    g.BCC();
    cout &lt;&lt; &quot;Above are &quot; &lt;&lt; count &lt;&lt; &quot; biconnected components in graph&quot;;
    return 0;
}
</cpp>
  <py>from collections import defaultdict
 
class Graph: 

    def __init__(self, vertices): 
        self.V = vertices 
        self.graph = defaultdict(list) 
        self.Time = 0
        self.count = 0

    def addEdge(self, u, v): 
        self.graph[u].append(v) 
        self.graph[v].append(u) 

    def BCCUtil(self, u, parent, low, disc, st): 
        children = 0
        disc[u] = self.Time 
        low[u] = self.Time 
        self.Time += 1
        for v in self.graph[u]: 
            if disc[v] == -1: 
                parent[v] = u 
                children += 1
                st.append((u, v)) 
                self.BCCUtil(v, parent, low, disc, st) 
                low[u] = min(low[u], low[v]) 
                if parent[u] == -1 and children &gt; 1 or parent[u] != -1 and low[v] &gt;= disc[u]: 
                    self.count += 1 
                    w = -1
                    while w != (u, v): 
                        w = st.pop() 
                        print w, 
                    print&quot;&quot; 
                        
            elif v != parent[u] and low[u] &gt; disc[v]: 
                low[u] = min(low [u], disc[v]) 
                st.append((u, v)) 

    def BCC(self): 
        disc = [-1] * (self.V) 
        low = [-1] * (self.V) 
        parent = [-1] * (self.V) 
        st = [] 
        for i in range(self.V): 
            if disc[i] == -1: 
                self.BCCUtil(i, parent, low, disc, st) 
            if st: 
                self.count = self.count + 1
                while st: 
                    w = st.pop() 
                    print w, 
                print &quot;&quot; 

g = Graph(12) 
g.addEdge(0, 1) 
g.addEdge(1, 2) 
g.addEdge(1, 3) 
g.addEdge(2, 3) 
g.addEdge(2, 4) 
g.addEdge(3, 4) 
g.addEdge(1, 5) 
g.addEdge(0, 6) 
g.addEdge(5, 6) 
g.addEdge(5, 7) 
g.addEdge(5, 8) 
g.addEdge(7, 8) 
g.addEdge(8, 9) 
g.addEdge(10, 11) 

g.BCC(); 
print (&quot;Above are % d biconnected components in graph&quot; % (g.count)); 

</py>
  <orden>8</orden>
  <suborden>43</suborden>
  <fecha_creacion>2020-12-06 19:51:48</fecha_creacion>
  <fecha_modificacion>2022-03-08 12:28:52</fecha_modificacion>
</row>
<row>
  <ID>240</ID>
  <supergrupo>Estructuras</supergrupo>
  <tema>Vector circular</tema>
  <texto>Range Minimum Query (RMQ)</texto>
  <complejidad_tiempo>null</complejidad_tiempo>
  <java>// Programa Java para demostrar el uso de una array circular utilizando 
// espacio de memoria adicional

public class CircularArray {

    // función para imprimir una lista circular a partir del índice ind.
    public static void print(char a[], int n,
            int ind) {
        // imprimir desde el índice ind-ésimo hasta el índice (n + i) ésimo.
        for (int i = ind; i &lt; n + ind; i++) {
            System.out.print(a[(i % n)] + &quot; &quot;);
        }
    }

    public static void main(String argc[]) {
        char[] a = new char[]{&#39;A&#39;, &#39;B&#39;, &#39;C&#39;,
            &#39;D&#39;, &#39;E&#39;, &#39;F&#39;};
        int n = 6;
        print(a, n, 3);
    }
}
</java>
  <cpp>#include &lt;bits/stdc++.h&gt; 
using namespace std;

void print(char a[], int n, int ind) {

    for (int i = ind; i &lt; n + ind; i++)
        cout &lt;&lt; a[(i % n)] &lt;&lt; &quot; &quot;;
}

int main() {
    char a[] = {&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;, &#39;E&#39;, &#39;F&#39;};
    int n = sizeof (a) / sizeof (a[0]);
    print(a, n, 3);
    return 0;
}
</cpp>
  <py>def prints(a, n, ind): 
        i = ind 
        while i &lt; n + ind : 
                print(a[(i % n)], end = &quot; &quot;) 
                i = i + 1
a = [&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;, &#39;E&#39;, &#39;F&#39;] 
n = len(a); 
prints(a, n, 3); 
</py>
  <orden>1</orden>
  <suborden>1</suborden>
  <fecha_creacion>2020-12-06 19:51:49</fecha_creacion>
  <fecha_modificacion>2022-03-08 14:26:59</fecha_modificacion>
</row>
<row>
  <ID>241</ID>
  <supergrupo>Estructuras</supergrupo>
  <tema>Árbol de Fenwick</tema>
  <texto>Consideremos el siguiente problema para entender el árbol indexado binario.
Tenemos una matriz arr [0. . . n-1]. Nos gustaría
1 Calcule la suma de los primeros i elementos.
2 Modifique el valor de un elemento especificado de la matriz arr [i] = x donde 0 &lt;= i &lt;= n-1.
Una solución simple es ejecutar un ciclo de 0 a i-1 y calcular la suma de los elementos. Para actualizar un valor, simplemente haga arr [i] = x. La primera operación toma O (n) tiempo y la segunda operación toma O (1) tiempo. Otra solución simple es crear una matriz adicional y almacenar la suma de los primeros elementos i-ésimo en el índice i-ésimo en esta nueva matriz. La suma de un rango dado ahora se puede calcular en O (1) tiempo, pero la operación de actualización toma O (n) tiempo ahora. Esto funciona bien si hay una gran cantidad de operaciones de consulta pero muy pocas operaciones de actualización.
¿Podríamos realizar las operaciones de consulta y actualización en tiempo O (log n)?
Una solución eficaz es utilizar Segment Tree que realiza ambas operaciones en tiempo O (Logn).
Una solución alternativa es Binary Indexed Tree, que también logra una complejidad de tiempo O (Logn) para ambas operaciones. En comparación con el árbol de segmentos, el árbol indexado binario requiere menos espacio y es más fácil de implementar.

Representación
El árbol indexado binario se representa como una matriz. Deje que la matriz sea BITree []. Cada nodo del árbol indexado binario almacena la suma de algunos elementos de la matriz de entrada. El tamaño del árbol indexado binario es igual al tamaño de la matriz de entrada, denotado como n. En el siguiente código, usamos un tamaño de n + 1 para facilitar la implementación.
Construcción
Inicializamos todos los valores en BITree [] como 0. Luego llamamos update () para todos los índices, la operación update () se analiza a continuación.
Operaciones
getSum (x): Devuelve la suma de la submatriz arr [0,…, x]
// Devuelve la suma del subarreglo arr [0,…, x] usando BITree [0..n], que se construye a partir de arr [0..n-1]
1) Inicialice la suma de salida como 0, el índice actual como x + 1.
2) Haga lo siguiente mientras el índice actual sea mayor que 0.
… A) Agregue BITree [índice] a la suma
… B) Vaya al padre de BITree [índice]. El padre se puede obtener eliminando
el último bit establecido del índice actual, es decir, index = index - (index &amp; (-index))
3) Devolución de la suma.

El diagrama anterior proporciona un ejemplo de cómo funciona getSum (). Aquí hay algunas observaciones importantes.
BITree [0] es un nodo ficticio.
BITree [y] es el padre de BITree [x], si y solo si se puede obtener y eliminando el último bit establecido de la representación binaria de x, es decir y = x - (x &amp; (-x)).
El nodo hijo BITree [x] del nodo BITree [y] almacena la suma de los elementos entre y (inclusive) yx (exclusivo): arr [y,…, x).

update (x, val): actualiza el árbol indexado binario (BIT) realizando arr [index] + = val
// Tenga en cuenta que la operación de actualización (x, val) no cambiará arr []. Solo realiza cambios en BITree []
1) Inicialice el índice actual como x + 1.
2) Haga lo siguiente mientras el índice actual sea menor o igual que n.
… A) Agregue el valor a BITree [índice]
… B) Vaya al padre de BITree [índice]. El padre se puede obtener incrementando el último bit establecido del índice actual, es decir, índice = índice + (índice &amp; (-índice))
 
La función de actualización necesita asegurarse de que se actualicen todos los nodos BITree que contienen arr [i] dentro de sus rangos. Pasamos por encima de dichos nodos en BITree agregando repetidamente el número decimal correspondiente al último bit establecido del índice actual.

¿Cómo funciona el árbol indexado binario?
La idea se basa en el hecho de que todos los enteros positivos se pueden representar como la suma de potencias de 2. Por ejemplo, 19 se puede representar como 16 + 2 + 1. Cada nodo del BITree almacena la suma de n elementos donde n es un potencia de 2. Por ejemplo, en el primer diagrama anterior (el diagrama para getSum ()), la suma de los primeros 12 elementos se puede obtener mediante la suma de los últimos 4 elementos (de 9 a 12) más la suma de 8 elementos (de 1 a 8). El número de bits establecidos en la representación binaria de un número n es O (Logn). Por lo tanto, recorremos como máximo los nodos O (Logn) en las operaciones getSum () y update (). La complejidad temporal de la construcción es O (nLogn), ya que llama a update () para todos los n elementos.
</texto>
  <complejidad_tiempo>null</complejidad_tiempo>
  <java>//Estructura de datos que permite procesar 
//consultas por rangos y actualizaciones 
//individuales sobre un arreglo.

public class FenwickTree {

    // Tamaño máximo del árbol
    final static int MAX = 1000;
    static int BITree[] = new int[MAX];

    /* n -&gt; No. de elementos presentes en el array de entrada.
        BITree [0..n] -&gt; array que representa el árbol indexado binario.
        arr [0..n-1] -&gt; array de entrada para la que se evalúa la suma 
        de prefijo. */
    // Devuelve la suma de arr [0..index]. Esta función asume que el array está 
    // preprocesado y las sumas parciales de los elementos del array 
    // se almacenan en BITree [].
    static int getSum(int index) {
        int sum = 0; // Inicializar resultado
        // el índice en BITree [] es 1 más que el índice en arr []
        index = index + 1;
        // Antepasados transversales de BITree [índice]
        while (index &gt; 0) {
            // Agregar el elemento actual de BITree a la suma
            sum += BITree[index];
            // Mover el índice al nodo principal en la vista getSum
            index -= index &amp; (-index);
        }
        return sum;
    }

    // Actualiza un nodo en Binary Index Tree (BITree) en un índice 
    // dado en BITree. El valor dado &#39;val&#39; se agrega a BITree [i] y 
    // todos sus ancestros en tree. 
    public static void updateBIT(int n, int index,
            int val) {
        // el índice en BITree [] es 1 más que el índice en arr []
        index = index + 1;
        // Atraviesa a todos los antepasados y agrega &#39;val&#39;
        while (index &lt;= n) {
            // Agregue &#39;val&#39; al nodo actual del árbol
            BITree[index] += val;
            // Actualizar el índice al del padre en la vista de actualización
            index += index &amp; (-index);
        }
    }

    /* Función para construir el árbol de fenwick a partir de un array dada.*/
    static void constructBITree(int arr[], int n) {
        // Inicializar BITree [] como 0
        for (int i = 1; i &lt;= n; i++) {
            BITree[i] = 0;
        }
        // Almacene el valor actual en BITree [] usando update ()
        for (int i = 0; i &lt; n; i++) {
            updateBIT(n, i, arr[i]);
        }
    }

    public static void main(String args[]) {
        int freq[] = {2, 1, 1, 3, 2, 3,
            4, 5, 6, 7, 8, 9};
        int n = freq.length;
        // Construye el árbol fenwick a partir de una matriz dada
        constructBITree(freq, n);
        System.out.println(&quot;Sum of elements in arr[0..5]&quot;
                + &quot; is &quot; + getSum(5));
        freq[3] += 6;
        // Actualizar BIT para el cambio anterior en arr []
        updateBIT(n, 3, 6);
        // Encontrar la suma después de actualizar el valor
        System.out.println(&quot;Sum of elements in arr[0..5]&quot;
                + &quot; after update is &quot; + getSum(5));
    }
}
</java>
  <cpp>#include &lt;bits/stdc++.h&gt; 
#include &lt;cstdlib&gt;
using namespace std;
const int MAX = 1000;
int BITree[MAX];

int getSum(int index) {
    int sum = 0;
    index = index + 1;
    while (index &gt; 0) {
        sum += BITree[index];
        index -= index &amp; (-index);
    }
    return sum;
}

void updateBIT(int n, int index, int val) {
    index = index + 1;
    while (index &lt;= n) {
        BITree[index] += val;
        index += index &amp; (-index);
    }
}

void constructBITree(int arr[], int n) {
    for (int i = 1; i &lt;= n; i++) {
        BITree[i] = 0;
    }
    for (int i = 0; i &lt; n; i++) {
        updateBIT(n, i, arr[i]);
    }
}

int main() {
    int freq[] = {2, 1, 1, 3, 2, 3, 4, 5, 6, 7, 8, 9};
    int n = sizeof (freq) / sizeof (freq[0]);
    constructBITree(freq, n);
    cout &lt;&lt; &quot;Sum of elements in arr[0..5] is &quot; &lt;&lt; getSum(5) &lt;&lt; endl;
    freq[3] += 6;
    updateBIT(n, 3, 6);
    cout &lt;&lt; &quot;Sum of elements in arr[0..5] after update is &quot; &lt;&lt; getSum(5)
            &lt;&lt; endl;
}

</cpp>
  <py>BITree = [0 for x in range (1000)]
def getSum(index):
    sum = 0
    index = index + 1
    while (index &gt; 0):
        sum += BITree[index]
        index -= index &amp; (-index)
    return sum

def updateBIT(n, index, val):
    index = index + 1
    while (index &lt;= n):
        BITree[index] += val
        index += index &amp; (-index)

def constructBITree(arr, n):
    for i in range (1, n + 1):
        BITree[i] = 0
    for i in range (n):
        updateBIT(n, i, arr[i])

freq = [2, 1, 1, 3, 2, 3, 4, 5, 6, 7, 8, 9]
n = len(freq)
constructBITree(freq, n);
print(&quot;Sum of elements in arr[0..5] is &quot; + str(getSum(5)))
freq[3] += 6
updateBIT(n, 3, 6);
print(&quot;Sum of elements in arr[0..5] after update is &quot; + str(getSum(5)))
</py>
  <orden>1</orden>
  <suborden>2</suborden>
  <fecha_creacion>2020-12-06 19:51:49</fecha_creacion>
  <fecha_modificacion>2022-03-08 14:26:59</fecha_modificacion>
</row>
<row>
  <ID>242</ID>
  <supergrupo>Estructuras</supergrupo>
  <tema>Range Minimum Query (RMQ)</tema>
  <texto>Consideremos el siguiente problema para comprender los árboles de segmentos.
Tenemos una matriz arr [0. . . n-1]. Deberíamos poder
1 Encuentre la suma de los elementos del índice la r donde 0 &lt;= l &lt;= r &lt;= n-1
2 Cambie el valor de un elemento especificado de la matriz a un nuevo valor x. Necesitamos hacer arr [i] = x donde 0 &lt;= i &lt;= n-1.

Una solución simple es ejecutar un ciclo de la ry calcular la suma de elementos en el rango dado. Para actualizar un valor, simplemente haga arr [i] = x. La primera operación toma O (n) tiempo y la segunda operación toma O (1) tiempo.
Otra solución es crear otra matriz y almacenar la suma desde el principio hasta la i en el índice i en esta matriz. La suma de un rango dado ahora se puede calcular en O (1) tiempo, pero la operación de actualización toma O (n) tiempo ahora. Esto funciona bien si el número de operaciones de consulta es grande y muy pocas actualizaciones.

¿Qué pasa si el número de consultas y actualizaciones es igual? ¿Podemos realizar ambas operaciones en tiempo O (log n) una vez dada la matriz? Podemos usar un árbol de segmentos para realizar ambas operaciones en tiempo O (Logn).
Representación de árboles de segmentos
1. Los nodos hoja son los elementos de la matriz de entrada.
2. Cada nodo interno representa alguna fusión de los nodos hoja. La combinación puede ser diferente para diferentes problemas. Para este problema, la fusión es la suma de hojas debajo de un nodo.
 
¿Cómo se ve el árbol de segmentos anterior en la memoria?
Al igual que Heap, el árbol de segmentos también se representa como una matriz. La diferencia aquí es que no es un árbol binario completo. Es más bien un árbol binario completo (cada nodo tiene 0 o 2 hijos) y todos los niveles están llenos excepto posiblemente el último nivel. A diferencia de Heap, el último nivel puede tener espacios entre los nodos. A continuación se muestran los valores en la matriz de árbol de segmentos para el diagrama anterior.

A continuación se muestra la representación en memoria del árbol de segmentos para la matriz de entrada {1, 3, 5, 7, 9, 11}

st [] = {36, 9, 27, 4, 5, 16, 11, 1, 3, DUMMY, DUMMY, 7, 9, DUMMY, DUMMY}

Los valores ficticios nunca se acceden y no tienen uso. Este es un desperdicio de espacio debido a la simple representación de una matriz. Podemos optimizar este desperdicio usando algunas implementaciones inteligentes, pero el código para suma y actualización se vuelve más complejo.
Construcción del árbol de segmentos a partir de una matriz dada
Comenzamos con un segmento arr [0. . . n-1]. y cada vez que dividimos el segmento actual en dos mitades (si aún no se ha convertido en un segmento de longitud 1), y luego llamamos al mismo procedimiento en ambas mitades, y para cada segmento, almacenamos la suma en el nodo correspondiente.
Todos los niveles del árbol de segmentos construido se llenarán por completo excepto el último nivel. Además, el árbol será un árbol binario completo porque siempre dividimos los segmentos en dos mitades en cada nivel. Dado que el árbol construido es siempre un árbol binario completo con n hojas, habrá n-1 nodos internos. Entonces, el número total de nodos será 2 * n - 1. Tenga en cuenta que esto no incluye los nodos ficticios.

¿Cuál es el tamaño total de la matriz que representa el árbol de segmentos?
Si n es una potencia de 2, entonces no hay nodos ficticios. Entonces, el tamaño del árbol de segmentos es 2n-1 (n nodos hoja y n-1) nodos internos. Si n no es una potencia de 2, entonces el tamaño del árbol será 2 * x - 1 donde x es la potencia más pequeña de 2 mayor que n. Por ejemplo, cuando n = 10, el tamaño de la matriz que representa el árbol de segmentos es 2 * 16-1 = 31.
Una explicación alternativa para el tamaño se basa en la altura. La altura del árbol de segmentos será  . Dado que el árbol se representa mediante una matriz y la relación entre los índices padre e hijo debe mantenerse, el tamaño de la memoria asignada para el árbol de segmentos será  
. 
Consulta de la suma del rango dado
Una vez que se construye el árbol, cómo obtener la suma utilizando el árbol de segmentos construido. El siguiente es el algoritmo para obtener la suma de elementos.
int getSum (nodo, l, r)
{
   si el rango del nodo está dentro de lyr
        valor de retorno en el nodo
   de lo contrario, si el rango del nodo está completamente fuera de lyr
        volver 0
   más
    return getSum (hijo izquierdo del nodo, l, r) +
           getSum (hijo derecho del nodo, l, r)
}

Actualizar un valor
Al igual que la construcción de árboles y las operaciones de consulta, la actualización también se puede realizar de forma recursiva. Se nos da un índice que debe actualizarse. Sea diff el valor a agregar. Comenzamos desde la raíz del árbol de segmentos y agregamos diff a todos los nodos que han dado índice en su rango. Si un nodo no tiene un índice determinado en su rango, no realizamos ningún cambio en ese nodo.
Implementación:
A continuación se muestra la implementación del árbol de segmentos. El programa implementa la construcción de un árbol de segmentos para cualquier arreglo. También implementa operaciones de consulta y actualización.

Tenemos una matriz arr [0. . . n-1]. Deberíamos poder encontrar de manera eficiente el valor mínimo desde el índice qs (inicio de la consulta) hasta qe (final de la consulta) donde 0 &lt;= qs &lt;= qe &lt;= n-1.

Una solución simple es ejecutar un ciclo de qs a qe y encontrar el elemento mínimo en un rango dado. Esta solución lleva O (n) tiempo en el peor de los casos.
Otra solución es crear una matriz 2D donde una entrada [i, j] almacena el valor mínimo en el rango arr [i..j]. Ahora se puede calcular el mínimo de un rango dado en O (1) tiempo, pero el preprocesamiento toma O (n ^ 2) tiempo. Además, este enfoque necesita O (n ^ 2) espacio adicional que puede volverse enorme para matrices de entrada grandes.

El árbol de segmentos se puede utilizar para realizar preprocesamiento y consultas en un tiempo moderado. Con el árbol de segmentos, el tiempo de preprocesamiento es O (n) y el tiempo para la consulta mínima de rango es O (Logn). El espacio adicional requerido es O (n) para almacenar el árbol de segmentos.

Representación de árboles de segmentos
1. Los nodos hoja son los elementos de la matriz de entrada.
2. Cada nodo interno representa el mínimo de todas las hojas debajo de él.
 
Construcción del árbol de segmentos a partir de una matriz dada
Comenzamos con un segmento arr [0. . . n-1]. y cada vez que dividimos el segmento actual en dos mitades (si aún no se ha convertido en un segmento de longitud 1), y luego llamamos al mismo procedimiento en ambas mitades, y para cada segmento, almacenamos el valor mínimo en un árbol de segmentos nodo.
Todos los niveles del árbol de segmentos construido se llenarán por completo excepto el último nivel. Además, el árbol será un árbol binario completo porque siempre dividimos los segmentos en dos mitades en cada nivel. Dado que el árbol construido es siempre un árbol binario completo con n hojas, habrá n-1 nodos internos. Entonces, el número total de nodos será 2 * n - 1.
La altura del árbol de segmentos será. Dado que el árbol se representa mediante una matriz y la relación entre los índices padre e hijo debe mantenerse, el tamaño de la memoria asignada para el árbol de segmentos será  .

Consultar el valor mínimo del rango dado
Una vez que se construye el árbol, cómo hacer una consulta de rango mínimo usando el árbol de segmento construido. A continuación se muestra el algoritmo para obtener el mínimo.
// qs -&gt; índice de inicio de consulta, qe -&gt; índice de fin de consulta
int RMQ (nodo, qs, qe)
{
    si el rango del nodo está dentro de qs y qe
         valor de retorno en el nodo
    de lo contrario, si el rango del nodo está completamente fuera de qs y qe
         volver INFINITO
    más
     return min (RMQ (hijo izquierdo del nodo, qs, qe), RMQ (hijo derecho del nodo, qs, qe))
}</texto>
  <complejidad_tiempo>null</complejidad_tiempo>
  <java>// Programa Java para implementar árbol de segmentos iterativos.

public class RangeMinimumQuery {

    static void construct_segment_tree(int[] segtree,
            int[] a, int n) {

        // asignar valores a las hojas del árbol de segmentos
        for (int i = 0; i &lt; n; i++) {
            segtree[n + i] = a[i];
        }

        // asignar valores a los nodos internos para calcular el mínimo en un rango dado
        for (int i = n - 1; i &gt;= 1; i--) {
            segtree[i] = Math.min(segtree[2 * i], segtree[2 * i + 1]);
        }
    }

    static void update(int[] segtree, int pos, int value, int n) {

        // cambie el índice al nodo hoja primero
        pos += n;
        // actualizar el valor en el nodo hoja en el índice exacto
        segtree[pos] = value;
        while (pos &gt; 1) {
            // subir un nivel a la vez en el árbol
            pos &gt;&gt;= 1;
            // actualizar los valores en los nodos en el siguiente nivel superior
            segtree[pos] = Math.min(segtree[2 * pos],
                    segtree[2 * pos + 1]);
        }
    }

    static int range_query(int[] segtree, int left,
            int right, int n) {

        /* 
        Básicamente, los índices izquierdo y derecho se moverán
         hacia derecha e izquierda respectivamente y con
         cada cada siguiente nivel superior y calcular el
         mínimo en cada altura.
         */
        // cambie el índice al nodo hoja primero
        left += n;
        right += n;
        // inicializar mínimo a un valor muy alto
        int mi = (int) 1e9;

        while (left &lt; right) {

            // si se deja el índice en impar
            if ((left &amp; 1) == 1) {
                mi = Math.min(mi, segtree[left]);

                // hacer par índice izquierdo
                left++;
            }

            // si el índice correcto es impar
            if ((right &amp; 1) == 1) {

                // hacer par índice derecho
                right--;

                mi = Math.min(mi, segtree[right]);
            }

            // pasar al siguiente nivel superior
            left /= 2;
            right /= 2;
        }
        return mi;
    }

    public static void main(String[] args) {
        int[] a = {2, 6, 10, 4, 7, 28, 9, 11, 6, 33};
        int n = a.length;

        /*  
         Construya el árbol de segmentos asignando
          los valores a los nodos internos
         */
        int[] segtree = new int[2 * n];
        construct_segment_tree(segtree, a, n);

        // calcular el mínimo en el rango de izquierda a derecha
        int left = 0, right = 5;
        System.out.printf(&quot;Minimum in range %d to %d is %d\n&quot;,
                left, right, range_query(segtree,
                        left, right + 1, n));

        // actualizar el valor del índice 3 a 1
        int index = 3, value = 1;

        // a[3] = 1;  
        // Contenido del array : {2, 6, 10, 1, 7, 28, 9, 11, 6, 33} 
        update(segtree, index, value, n); // actualización de puntos

        // calcular el mínimo en el rango de izquierda a derecha 
        left = 2;
        right = 6;
        System.out.printf(&quot;Minimum in range %d to %d is %d\n&quot;,
                left, right, range_query(segtree,
                        left, right + 1, n));
    }
}
</java>
  <cpp>#include &lt;bits/stdc++.h&gt; 
#define ll long long 

using namespace std;

void construct_segment_tree(vector&lt;int&gt;&amp; segtree,
        vector&lt;int&gt; &amp;a, int n) {
    for (int i = 0; i &lt; n; i++)
        segtree[n + i] = a[i];
    for (int i = n - 1; i &gt;= 1; i--)
        segtree[i] = min(segtree[2 * i],
            segtree[2 * i + 1]);
}

void update(vector&lt;int&gt;&amp; segtree, int pos, int value,
        int n) {
    pos += n;
    segtree[pos] = value;
    while (pos &gt; 1) {
        pos &gt;&gt;= 1;
        segtree[pos] = min(segtree[2 * pos],
                segtree[2 * pos + 1]);
    }
}

int range_query(vector&lt;int&gt;&amp; segtree, int left, int
        right, int n) {
    left += n;
    right += n;
    int mi = (int) 1e9;

    while (left &lt; right) {
        if (left &amp; 1) {
            mi = min(mi, segtree[left]);
            left++;
        }
        if (right &amp; 1) {
            right--;
            mi = min(mi, segtree[right]);
        }
        left /= 2;
        right /= 2;
    }
    return mi;
}

int main() {
    vector&lt;int&gt; a = {2, 6, 10, 4, 7, 28, 9, 11, 6, 33};
    int n = a.size();
    vector&lt;int&gt; segtree(2 * n);
    construct_segment_tree(segtree, a, n);
    int left = 0, right = 5;
    cout &lt;&lt; &quot;Minimum in range &quot; &lt;&lt; left &lt;&lt; &quot; to &quot;
            &lt;&lt; right &lt;&lt; &quot; is &quot; &lt;&lt; range_query(segtree, left,
            right + 1, n) &lt;&lt; &quot;\n&quot;;

    int index = 3, value = 1;
    update(segtree, index, value, n);
    left = 2, right = 6;
    cout &lt;&lt; &quot;Minimum in range &quot; &lt;&lt; left &lt;&lt; &quot; to &quot;
            &lt;&lt; right &lt;&lt; &quot; is &quot; &lt;&lt; range_query(segtree,
            left, right + 1, n) &lt;&lt; &quot;\n&quot;;

    return 0;
} 
</cpp>
  <py>def construct_segment_tree(segtree, a, n):  
    for i in range(n):  
        segtree[n + i] = a[i];  
    for i in range(n - 1, 0, -1):  
        segtree[i] = min(segtree[2 * i], 
                         segtree[2 * i + 1])  
                          
def range_query(segtree, left, right, n): 
    left += n  
    right += n 
    mi = 1e9 
    while (left &lt; right): 
        if (left &amp; 1): 
            mi = min(mi, segtree[left]) 
            left = left + 1
        if (right &amp; 1): 
            right -= 1
            mi = min(mi, segtree[right]) 
        left = left // 2
        right = right // 2
    return mi 
  
def update(segtree, pos, value, n): 
    pos += n  
    segtree[pos] = value  
    while (pos &gt; 1):  
        pos &gt;&gt;= 1;  
        segtree[pos] = min(segtree[2 * pos], 
                           segtree[2 * pos + 1])  
a = [2, 6, 10, 4, 7, 28, 9, 11, 6, 33] 
n = len(a)  
segtree = [0 for i in range(2 * n)]  
construct_segment_tree(segtree, a, n); 
left = 0
right = 5 
print (&quot;Minimum in range&quot;, left, &quot;to&quot;, right, &quot;is&quot;, 
       range_query(segtree, left, right + 1, n)) 
 
index = 3 
value = 1
update(segtree, index, value, n); 
left = 2
right = 6 
print(&quot;Minimum in range&quot;, left, &quot;to&quot;, right, &quot;is&quot;, 
      range_query(segtree, left, right + 1, n)) 
</py>
  <orden>1</orden>
  <suborden>3</suborden>
  <fecha_creacion>2020-12-06 19:51:49</fecha_creacion>
  <fecha_modificacion>2022-03-08 14:26:59</fecha_modificacion>
</row>
<row>
  <ID>243</ID>
  <supergrupo>Estructuras</supergrupo>
  <tema>Sparse Table</tema>
  <texto>El concepto de tabla dispersa se utiliza para consultas rápidas sobre un conjunto de datos estáticos (los elementos no cambian). Realiza un preprocesamiento para que las consultas se puedan responder de manera eficiente.
 
Problema de ejemplo 1: consulta de rango mínimo

Tenemos una array arr [0. . . n-1]. Necesitamos encontrar de manera eficiente el valor mínimo desde el índice L (inicio de la consulta) hasta R (final de la consulta) donde 0 &lt;= L &lt;= R &lt;= n-1. Considere una situación en la que hay muchas consultas de rango.
Ejemplo:
Entrada: arr [] = {7, 2, 3, 0, 5, 10, 3, 12, 18};
        consulta [] = [0, 4], [4, 7], [7, 8]

Salida: el mínimo de [0, 4] es 0
        El mínimo de [4, 7] es 3
        El mínimo de [7, 8] es 12
La idea es precalcular el mínimo de todos los subarreglos de tamaño 2j donde j varía de 0 a Log n. Hacemos una búsqueda de tabla [i] [j] tal que la búsqueda [i] [j] contiene un rango mínimo a partir de i y de tamaño 2j. Por ejemplo, la búsqueda [0] [3] contiene un mínimo de rango [0, 7] (comenzando con 0 y de tamaño 23)
¿Cómo llenar esta tabla de búsqueda o escasa?
La idea es simple, complete de forma ascendente utilizando valores previamente calculados. Calculamos rangos con una potencia actual de 2 utilizando valores de menor potencia de dos. Por ejemplo, para encontrar un mínimo de rango [0, 7] (el tamaño del rango es una potencia de 3), podemos usar el mínimo de los siguientes dos.
a) Mínimo de rango [0, 3] (el tamaño del rango es una potencia de 2)
b) Mínimo de rango [4, 7] (el tamaño del rango es una potencia de 2)
Basado en el ejemplo anterior, a continuación se muestra la fórmula,
// El mínimo de subarreglos de un solo elemento es el mismo
// como único elemento.
buscar [i] [0] = arr [i]

// Si buscar [0] [2] &lt;= buscar [4] [2],
// luego buscar [0] [3] = buscar [0] [2]
Si búsqueda [i] [j-1] &lt;= búsqueda [i + 2j-1] [j-1]
   buscar [i] [j] = buscar [i] [j-1]

// Si buscar [0] [2]&gt; buscar [4] [2],
// luego buscar [0] [3] = buscar [4] [2]
Más
   buscar [i] [j] = buscar [i + 2j-1] [j-1]

 
Para cualquier rango arbitrario [l, R], necesitamos usar rangos que estén en potencias de 2. La idea es usar la potencia más cercana de 2. Siempre necesitamos hacer como máximo una comparación (compare el mínimo de dos rangos que son potencias de 2). Un rango comienza con L y termina con &quot;L + potencia más cercana de 2&quot;. El otro rango termina en R y comienza con “R - misma potencia más cercana de 2 + 1”. Por ejemplo, si el rango dado es (2, 10), comparamos el mínimo de dos rangos (2, 9) y (3, 10).
Basado en el ejemplo anterior, a continuación se muestra la fórmula,


// Para (2, 10), j = piso (Log2 (10-2 + 1)) = 3
j = floor (Log (R-L + 1))

// Si lookup [2] [3] &lt;= lookup [3] [3],
// luego min (2, 10) = lookup [2] [3]
Si búsqueda [L] [j] &lt;= búsqueda [R- (int) pow (2, j) +1] [j]
   min (L, R) = buscar [L] [j]

// Si lookup [2] [3]&gt; arr [lookup [3] [3],
// luego min (2, 10) = lookup [3] [3]
Más
   min (L, R) = búsqueda [R- (int) pow (2, j) +1] [j]
Dado que solo hacemos una comparación, la complejidad de tiempo de la consulta es O (1).
Problema de ejemplo 2: Consulta GCD de rango

Tenemos una array arr [0. . . n-1]. Necesitamos encontrar el máximo común divisor en el rango L y R donde 0 &lt;= L &lt;= R &lt;= n-1. Considere una situación en la que hay muchas querys de rango
Ejemplos:
Entrada: arr [] = {2, 3, 5, 4, 6, 8}
        querys [] = {(0, 2), (3, 5), (2, 3)}
Salida: 1
         2
         1
Usamos las siguientes propiedades de GCD:
• La función GCD es asociativa [GCD (a, b, c) = GCD (GCD (a, b), c) = GCD (a, GCD (b, c))], podemos calcular GCD de un rango usando GCD de subrangos.
• Si tomamos GCD de un rango superpuesto más de una vez, entonces no cambia la respuesta. Por ejemplo, GCD (a, b, c) = GCD (GCD (a, b), GCD (b, c)). Por lo tanto, como problema de consulta de rango mínimo, necesitamos hacer solo una comparación para encontrar GCD del rango dado.
Construimos una tabla dispersa usando la misma lógica que arriba. Después de construir la tabla dispersa, podemos encontrar todos los MCD rompiendo el rango dado en potencias de 2 y agregando el MCD de cada pieza a la respuesta actual.
</texto>
  <complejidad_tiempo>null</complejidad_tiempo>
  <java>// Programa Java para realizar consultas de rango mínimo en O (1) 
// tiempo con O (n * n) espacio extra y O (n * n) tiempo de preprocesamiento.

public class SpaseTableSquareRootDecomposition {

    static int MAX = 500;
    // lookup [i] [j] va a almacenar el índice de valor mínimo en arr [i..j]
    static int[][] lookup = new int[MAX][MAX];

    // Estructura para representar un rango de consulta 
    static class Query {

        int L, R;

        public Query(int L, int R) {
            this.L = L;
            this.R = R;
        }
    };

    // Llena la búsqueda de matriz de búsqueda [n] [n] para todos 
    // los valores posibles de los rangos de consulta
    static void preprocess(int arr[], int n) {
        // Inicialice la búsqueda [] [] para los intervalos con longitud 1
        for (int i = 0; i &lt; n; i++) {
            lookup[i][i] = i;
        }

        // Complete el resto de las entradas de abajo hacia arriba
        for (int i = 0; i &lt; n; i++) {
            for (int j = i + 1; j &lt; n; j++) // Para encontrar un mínimo de [0,4],
            // comparamos el mínimo de arr [lookup [0] [3]] con arr [4].
            {
                if (arr[lookup[i][j - 1]] &lt; arr[j]) {
                    lookup[i][j] = lookup[i][j - 1];
                } else {
                    lookup[i][j] = j;
                }
            }
        }
    }

    // Imprime un mínimo de m rangos de consulta dados en arr [0..n-1]
    static void RMQ(int arr[], int n,
            Query q[], int m) {
        // Llenar la tabla de búsqueda para todas las consultas de entrada posibles
        preprocess(arr, n);

        // Calcula una por una la suma de todas las consultas
        for (int i = 0; i &lt; m; i++) {
            // Límites izquierdo y derecho del rango actual
            int L = q[i].L, R = q[i].R;

            // Imprimir la suma del rango de consulta actual
            System.out.println(&quot;Minimum of [&quot; + L
                    + &quot;, &quot; + R + &quot;] is &quot;
                    + arr[lookup[L][R]]);
        }
    }

    public static void main(String[] args) {
        int a[] = {7, 2, 3, 0, 5, 10, 3, 12, 18};
        int n = a.length;
        Query q[] = {new Query(0, 4),
            new Query(4, 7),
            new Query(7, 8)};
        int m = q.length;
        RMQ(a, n, q, m);
    }
}
</java>
  <cpp>#include&lt;bits/stdc++.h&gt; 
using namespace std;
#define MAX 500 

int lookup[MAX][MAX];

struct Query {
    int L, R;
};

void preprocess(int arr[], int n) {
    for (int i = 0; i &lt; n; i++)
        lookup[i][0] = i;

    for (int j = 1; (1 &lt;&lt; j) &lt;= n; j++) {
        for (int i = 0; (i + (1 &lt;&lt; j) - 1) &lt; n; i++) {
            if (arr[lookup[i][j - 1]] &lt; arr[lookup[i + (1 &lt;&lt; (j - 1))][j - 1]])
                lookup[i][j] = lookup[i][j - 1];
            else
                lookup[i][j] = lookup[i + (1 &lt;&lt; (j - 1))][j - 1];
        }
    }
}

int query(int arr[], int L, int R) {
    int j = (int) log2(R - L + 1);
    if (arr[lookup[L][j]] &lt;= arr[lookup[R - (1 &lt;&lt; j) + 1][j]])
        return arr[lookup[L][j]];

    else return arr[lookup[R - (1 &lt;&lt; j) + 1][j]];
}

void RMQ(int arr[], int n, Query q[], int m) {
    preprocess(arr, n);
    for (int i = 0; i &lt; m; i++) {
        int L = q[i].L, R = q[i].R;
        cout &lt;&lt; &quot;Minimum of [&quot; &lt;&lt; L &lt;&lt; &quot;, &quot;
                &lt;&lt; R &lt;&lt; &quot;] is &quot; &lt;&lt; query(arr, L, R) &lt;&lt; endl;
    }
}

int main() {
    int a[] = {7, 2, 3, 0, 5, 10, 3, 12, 18};
    int n = sizeof (a) / sizeof (a[0]);
    Query q[] = {
        {0, 4},
        {4, 7},
        {7, 8}
    };
    int m = sizeof (q) / sizeof (q[0]);
    RMQ(a, n, q, m);
    return 0;
}
</cpp>
  <py>from math import log2
 
MAX = 500
lookup = [[0 for i in range(500)] 
    for j in range(500)] 


class Query: 
    def __init__(self, l, r): 
        self.L = l 
        self.R = r 

def preprocess(arr: list, n: int): 
    global lookup 
    for i in range(n): 
        lookup[i][0] = i 
    j = 1
    while (1 &lt;&lt; j) &lt;= n: 
        i = 0
        while i + (1 &lt;&lt; j) - 1 &lt; n: 
            if (arr[lookup[i][j - 1]] &lt; 
                arr[lookup[i + (1 &lt;&lt; (j - 1))][j - 1]]): 
                lookup[i][j] = lookup[i][j - 1] 
            else: 
                lookup[i][j] = lookup[i +
                    (1 &lt;&lt; (j - 1))][j - 1] 

            i += 1
        j += 1

def query(arr: list, L: int, R: int): 
    global lookup 
    j = int(log2(R - L + 1)) 
    if (arr[lookup[L][j]] &lt;=
        arr[lookup[R - (1 &lt;&lt; j) + 1][j]]): 
        return arr[lookup[L][j]] 
    else: 
        return arr[lookup[R - (1 &lt;&lt; j) + 1][j]] 
def RMQ(arr: list, n: int, q: list, m: int): 
    preprocess(arr, n) 
    for i in range(m): 
        L = q[i].L 
        R = q[i].R 
        print(&quot;Minimum of [%d, %d] is %d&quot; %
              (L, R, query(arr, L, R))) 


a = [7, 2, 3, 0, 5, 10, 3, 12, 18] 
n = len(a) 
q = [Query(0, 4), Query(4, 7), 
    Query(7, 8)] 
m = len(q) 
RMQ(a, n, q, m) 
</py>
  <orden>1</orden>
  <suborden>4</suborden>
  <fecha_creacion>2020-12-06 19:51:50</fecha_creacion>
  <fecha_modificacion>2022-03-08 14:28:36</fecha_modificacion>
</row>
<row>
  <ID>244</ID>
  <supergrupo>Estructuras</supergrupo>
  <tema>Heap Sort</tema>
  <texto>La clasificación de montón es una técnica de clasificación basada en comparación basada en la estructura de datos de montón binario. Es similar al ordenamiento por selección donde primero encontramos el elemento máximo y colocamos el elemento máximo al final. Repetimos el mismo proceso para el resto de elementos.

¿Qué es el montón binario?
Primero definamos un árbol binario completo. Un árbol binario completo es un árbol binario en el que cada nivel, excepto posiblemente el último, está completamente lleno y todos los nodos están lo más a la izquierda posible.
Un montón binario es un árbol binario completo donde los elementos se almacenan en un orden especial de modo que el valor en un nodo principal es mayor (o menor) que los valores en sus dos nodos secundarios. El primero se llama max heap y el último se llama min-heap. El montón se puede representar mediante un árbol o matriz binaria.

¿Por qué la representación basada en matrices para Binary Heap?
Dado que un montón binario es un árbol binario completo, se puede representar fácilmente como una matriz y la representación basada en matriz es eficiente en el espacio. Si el nodo padre se almacena en el índice I, el hijo de la izquierda se puede calcular por 2 * I + 1 y el hijo de la derecha por 2 * I + 2 (asumiendo que la indexación comienza en 0).

Algoritmo de clasificación de montón para clasificar en orden creciente:
1. Cree un montón máximo a partir de los datos de entrada.
2. En este punto, el elemento más grande se almacena en la raíz del montón. Reemplácelo con el último elemento del montón y luego reduzca el tamaño del montón en 1. Finalmente, apile la raíz del árbol.
3. Repita el paso 2 mientras el tamaño del montón sea mayor que 1.
¿Cómo construir el montón?
El procedimiento Heapify se puede aplicar a un nodo solo si sus nodos secundarios están heapified. Por tanto, la heapificación debe realizarse en orden ascendente.
Entendamos con la ayuda de un ejemplo:

Datos de entrada: 4, 10, 3, 5, 1
         4 (0)
        / \
     10 (1) 3 (2)
    / \
 5 (3) 1 (4)

Los números entre paréntesis representan los índices de la matriz.
representación de datos.

Aplicar el procedimiento de heapify al índice 1:
         4 (0)
        / \
    10 (1) 3 (2)
    / \
5 (3) 1 (4)

Aplicando el procedimiento de heapify al índice 0:
        10 (0)
        / \
     5 (1) 3 (2)
    / \
 4 (3) 1 (4)
El procedimiento de heapify se llama a sí mismo de forma recursiva para construir el montón
 de arriba hacia abajo.
Notas:
La ordenación de pila es un algoritmo in situ.
Su implementación típica no es estable, pero puede estabilizarse

Aplicaciones de HeapSort
1. Ordene una matriz casi ordenada (o ordenada por K)
2. k elementos más grandes (o más pequeños) en una matriz
El algoritmo de ordenación de pila tiene usos limitados porque Quicksort y Mergesort son mejores en la práctica. Sin embargo, la estructura de datos de Heap en sí se utiliza enormemente. Instantáneas:
</texto>
  <complejidad_tiempo>null</complejidad_tiempo>
  <java>// Programa Java para la implementación de Heap Sort

public class HeapSort {

    public void sort(int arr[]) {
        int n = arr.length;

        // Construir montón (reorganizar la matriz)
        for (int i = n / 2 - 1; i &gt;= 0; i--) {
            heapify(arr, n, i);
        }

        // Uno por uno extrae un elemento del montón
        for (int i = n - 1; i &gt; 0; i--) {
            // Mover la raíz actual al final
            int temp = arr[0];
            arr[0] = arr[i];
            arr[i] = temp;
            // llamar a max heapify en el montón reducido
            heapify(arr, i, 0);
        }
    }

    // Para apilar un subárbol enraizado con el nodo i, 
    // que es un índice en arr []. n es el tamaño del montón
    void heapify(int arr[], int n, int i) {
        int largest = i; // Inicializar más grande como raíz
        int l = 2 * i + 1; // left = 2*i + 1 
        int r = 2 * i + 2; // right = 2*i + 2 

        // Si el niño izquierdo es más grande que la raíz
        if (l &lt; n &amp;&amp; arr[l] &gt; arr[largest]) {
            largest = l;
        }

        // Si el niño derecho es más grande que el más grande hasta ahora 
        if (r &lt; n &amp;&amp; arr[r] &gt; arr[largest]) {
            largest = r;
        }

        // Si el más grande no es raíz
        if (largest != i) {
            int swap = arr[i];
            arr[i] = arr[largest];
            arr[largest] = swap;

            // Apila de forma recursiva el subárbol afectado
            heapify(arr, n, largest);
        }
    }

    /* Una función de utilidad para imprimir una matriz de tamaño n */
    static void printArray(int arr[]) {
        int n = arr.length;
        for (int i = 0; i &lt; n; ++i) {
            System.out.print(arr[i] + &quot; &quot;);
        }
        System.out.println();
    }

    public static void main(String args[]) {
        int arr[] = {12, 11, 13, 5, 6, 7};
        int n = arr.length;

        HeapSort ob = new HeapSort();
        ob.sort(arr);

        System.out.println(&quot;Sorted array is&quot;);
        printArray(arr);
    }
}
</java>
  <cpp>#include &lt;iostream&gt; 

using namespace std;

void heapify(int arr[], int n, int i) {
    int largest = i;
    int l = 2 * i + 1;
    int r = 2 * i + 2;
    if (l &lt; n &amp;&amp; arr[l] &gt; arr[largest])
        largest = l;
    if (r &lt; n &amp;&amp; arr[r] &gt; arr[largest])
        largest = r;
    if (largest != i) {
        swap(arr[i], arr[largest]);
        heapify(arr, n, largest);
    }
}

void heapSort(int arr[], int n) {
    for (int i = n / 2 - 1; i &gt;= 0; i--)
        heapify(arr, n, i);

    for (int i = n - 1; i &gt; 0; i--) {
        swap(arr[0], arr[i]);
        heapify(arr, i, 0);
    }
}

void printArray(int arr[], int n) {
    for (int i = 0; i &lt; n; ++i)
        cout &lt;&lt; arr[i] &lt;&lt; &quot; &quot;;
    cout &lt;&lt; &quot;\n&quot;;
}

int main() {
    int arr[] = {12, 11, 13, 5, 6, 7};
    int n = sizeof (arr) / sizeof (arr[0]);

    heapSort(arr, n);

    cout &lt;&lt; &quot;Sorted array is \n&quot;;
    printArray(arr, n);
}
</cpp>
  <py>def heapify(arr, n, i): 
    largest = i 
    l = 2 * i + 1        
    r = 2 * i + 2        
    if l &lt; n and arr[i] &lt; arr[l]: 
        largest = l 
    if r &lt; n and arr[largest] &lt; arr[r]: 
        largest = r 
    if largest != i: 
        arr[i], arr[largest] = arr[largest], arr[i] # swap . 
        heapify(arr, n, largest) 

def heapSort(arr): 
    n = len(arr)  
    for i in range(n // 2 - 1, -1, -1): 
        heapify(arr, n, i) 
    for i in range(n-1, 0, -1): 
        arr[i], arr[0] = arr[0], arr[i] # swap 
        heapify(arr, i, 0) 

arr = [12, 11, 13, 5, 6, 7] 
heapSort(arr) 
n = len(arr) 
print (&quot;Sorted array is&quot;) 
for i in range(n): 
    print (&quot;%d&quot; % arr[i]), 
</py>
  <orden>1</orden>
  <suborden>5</suborden>
  <fecha_creacion>2020-12-06 19:51:50</fecha_creacion>
  <fecha_modificacion>2022-03-08 14:28:36</fecha_modificacion>
</row>
<row>
  <ID>245</ID>
  <supergrupo>Estructuras</supergrupo>
  <tema>QuickSelect</tema>
  <texto>null</texto>
  <complejidad_tiempo>null</complejidad_tiempo>
  <java>import java.util.*;

class QuickSelect {

    static int Partition(int A[], int l, int r) {
        int p = A[l]; // p es el pivote
        int m = l; // S1 y S2 están vacíos
        int temp;
        for (int k = l + 1; k &lt;= r; ++k) { // explorar una región desconocida
            if (A[k] &lt; p) { // caso 2
                m++;
                temp = A[k];
                A[k] = A[m];
                A[m] = temp;
            } // observe que no hacemos nada en el caso 1: a [k]&gt; = p
        }
        temp = A[l];
        A[l] = A[m];
        A[m] = temp; // intercambiar pivote con una [m]
        return m; // retorno de índice de pivote
    }

    static int RandPartition(int[] A, int l, int r) {
        Random rnd = new Random();
        int p = l + rnd.nextInt(r - l + 1); // seleccionar un pivote aleatorio
        int temp = A[l];
        A[l] = A[p];
        A[p] = temp;   // intercambiar A [p] con A [l]
        return Partition(A, l, r);
    }

    static int QuickSelect(int[] A, int l, int r, int k) {
        if (l == r) {
            return A[l];
        }
        int q = RandPartition(A, l, r);
        if (q + 1 == k) {
            return A[q];
        } else if (q + 1 &gt; k) {
            return QuickSelect(A, l, q - 1, k);
        } else {
            return QuickSelect(A, q + 1, r, k);
        }
    }

    public static void main(String[] args) {
        int[] A = new int[]{2, 8, 7, 1, 5, 4, 6, 3}; // permutación de [1..8]

        System.out.println(QuickSelect(A, 0, 7, 8)); // la salida debe ser 8
        System.out.println(QuickSelect(A, 0, 7, 7)); // la salida debe ser 7
        System.out.println(QuickSelect(A, 0, 7, 6)); // la salida debe ser 6
        System.out.println(QuickSelect(A, 0, 7, 5)); // la salida debe ser 5
        System.out.println(QuickSelect(A, 0, 7, 4)); // la salida debe ser 4
        System.out.println(QuickSelect(A, 0, 7, 3)); // la salida debe ser 3
        System.out.println(QuickSelect(A, 0, 7, 2)); // la salida debe ser 2
        System.out.println(QuickSelect(A, 0, 7, 1)); // la salida debe ser 1
    }
}
</java>
  <cpp>#include &lt;bits/stdc++.h&gt;
using namespace std;

int Partition(int A[], int l, int r) {
    int p = A[l]; // p es el pivote
    int m = l; // S1 y S2 están vacíos
    for (int k = l + 1; k &lt;= r; ++k) { // explorar una región desconocida
        if (A[k] &lt; p) { // case 2
            ++m;
            swap(A[k], A[m]);
        } // observe que no hacemos nada en el caso 1: a [k]&gt; = p
    }
    swap(A[l], A[m]); // intercambiar pivote con una [m]
    return m; // retorno de índice de pivote
}

int RandPartition(int A[], int l, int r) {
    int p = l + rand() % (r - l + 1); // seleccionar un pivote aleatorio
    swap(A[l], A[p]); // intercambiar A [p] con A [l]
    return Partition(A, l, r);
}

int QuickSelect(int A[], int l, int r, int k) { // esperado O (n)
    if (l == r) return A[l];
    int q = RandPartition(A, l, r); // O(n)
    if (q + 1 == k)
        return A[q];
    else if (q + 1 &gt; k)
        return QuickSelect(A, l, q - 1, k);
    else
        return QuickSelect(A, q + 1, r, k);
}

int main() {
    int A[] = {2, 8, 7, 1, 5, 4, 6, 3}; // permutación de [1..8]

    printf(&quot;%d\n&quot;, QuickSelect(A, 0, 7, 8)); // la salida debe ser 8
    printf(&quot;%d\n&quot;, QuickSelect(A, 0, 7, 7)); // la salida debe ser 7
    printf(&quot;%d\n&quot;, QuickSelect(A, 0, 7, 6)); // la salida debe ser 6
    printf(&quot;%d\n&quot;, QuickSelect(A, 0, 7, 5)); // la salida debe ser 5
    printf(&quot;%d\n&quot;, QuickSelect(A, 0, 7, 4)); // la salida debe ser 4
    printf(&quot;%d\n&quot;, QuickSelect(A, 0, 7, 3)); // la salida debe ser 3
    printf(&quot;%d\n&quot;, QuickSelect(A, 0, 7, 2)); // la salida debe ser 2
    printf(&quot;%d\n&quot;, QuickSelect(A, 0, 7, 1)); // la salida debe ser 1
    return 0;
}
</cpp>
  <py>import random

def swap(A, i, j): 
    A[i], A[j] = A[j], A[i] 
    return A

def Partition(A, l, r):
    p = A[l] # p es el pivote
    m = l   # S1 y S2 están vacíos
    for k in range(l + 1, r + 1):  # explorar una región desconocida
        if A[k] &lt; p:   # caso 2
            m += 1
            swap(A, k, m)
        # observe que no hacemos nada en el caso 1: a [k]&gt; = p
    swap(A, l, m)  # intercambiar pivote con una [m]
    return m # retorno de índice de pivote

def RandPartition(A, l, r):
    p = random.randint(l, r)# seleccionar un pivote aleatorio
    swap(A, l, p)  # intercambiar A [p] con A [l]
    return Partition(A, l, r)

def QuickSelect(A, l, r, k):# esperado O (n)
    if l == r:
        return A[l]
    q = RandPartition(A, l, r) # O(n)
    if q + 1 == k:
        return A[q]
    elif q + 1 &gt; k:
        return QuickSelect(A, l, q-1, k)
    else:
        return QuickSelect(A, q + 1, r, k)

def main():
    A = [2, 8, 7, 1, 5, 4, 6, 3] # permutación de [1..8]

    print(&quot;{}&quot;.format(QuickSelect(A, 0, 7, 8)))  # la salida debe ser 8
    print(&quot;{}&quot;.format(QuickSelect(A, 0, 7, 7)))  # la salida debe ser 7
    print(&quot;{}&quot;.format(QuickSelect(A, 0, 7, 6)))  # la salida debe ser 6
    print(&quot;{}&quot;.format(QuickSelect(A, 0, 7, 5)))  # la salida debe ser 5
    print(&quot;{}&quot;.format(QuickSelect(A, 0, 7, 4)))  # la salida debe ser 4
    print(&quot;{}&quot;.format(QuickSelect(A, 0, 7, 3)))  # la salida debe ser 3
    print(&quot;{}&quot;.format(QuickSelect(A, 0, 7, 2)))  # la salida debe ser 2
    print(&quot;{}&quot;.format(QuickSelect(A, 0, 7, 1)))  # la salida debe ser 1

main()
</py>
  <orden>1</orden>
  <suborden>6</suborden>
  <fecha_creacion>2020-12-06 19:51:50</fecha_creacion>
  <fecha_modificacion>2020-12-06 21:01:17</fecha_modificacion>
</row>
<row>
  <ID>246</ID>
  <supergrupo>Formateos</supergrupo>
  <tema>Formatear fechas y horas</tema>
  <texto>null</texto>
  <complejidad_tiempo>No aplica</complejidad_tiempo>
  <java>JAVA
import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.Date;

public class DateFormatter {

    public static void main(String args[]) throws ParseException {
        // Formateo según el patrón dado en el argumento
        SimpleDateFormat ft = new SimpleDateFormat(&quot;dd-MM-yyyy&quot;);
        String str = ft.format(new Date());
        System.out.println(&quot;Formatted Date : &quot; + str);

        // parseando una cadena determinada
        str = &quot;02/18/1995&quot;;
        ft = new SimpleDateFormat(&quot;MM/dd/yyyy&quot;);
        Date date = ft.parse(str);

        // esto imprimirá la fecha según la cadena parseada
        System.out.println(&quot;Parsed Date : &quot; + date);
    }
}
</java>
  <cpp>null</cpp>
  <py>null</py>
  <orden>10</orden>
  <suborden>1</suborden>
  <fecha_creacion>2020-12-06 19:51:51</fecha_creacion>
  <fecha_modificacion>2020-12-06 20:33:40</fecha_modificacion>
</row>
<row>
  <ID>247</ID>
  <supergrupo>Formateos</supergrupo>
  <tema>Formatear números decimales y enteros</tema>
  <texto>null</texto>
  <complejidad_tiempo>No aplica</complejidad_tiempo>
  <java>// Programa Java para demostrar el funcionamiento de DecimalFormat

import java.text.DecimalFormat;

public class JavaDecimalFormatter {

    public static void main(String args[]) {
        double num = 123.4567;

        // imprime solo la parte numérica de un número flotante
        DecimalFormat ft = new DecimalFormat(&quot;####&quot;);
        System.out.println(&quot;Without fraction part: num = &quot; + ft.format(num));

        // esto lo imprimirá hasta 2 lugares decimales
        ft = new DecimalFormat(&quot;#.##&quot;);
        System.out.println(&quot;Formatted to Give precison: num = &quot; + ft.format(num));

        // agrega automáticamente cero a la parte más a la derecha del decimal 
        // en lugar de #, usamos el dígito 0
        ft = new DecimalFormat(&quot;#.000000&quot;);
        System.out.println(&quot;appended zeroes to right: num = &quot; + ft.format(num));

        // agrega automáticamente cero al extremo izquierdo del número decimal 
        // en lugar de #, usamos el dígito 0
        ft = new DecimalFormat(&quot;00000.00&quot;);
        System.out.println(&quot;formatting Numeric part : num = &quot; + ft.format(num));

        // formatear dinero en dólares
        double income = 23456.789;
        ft = new DecimalFormat(&quot;$###,###.##&quot;);
        System.out.println(&quot;your Formatted Dream Income : &quot; + ft.format(income));
    }
}
</java>
  <cpp>null</cpp>
  <py>null</py>
  <orden>10</orden>
  <suborden>2</suborden>
  <fecha_creacion>2020-12-06 19:51:51</fecha_creacion>
  <fecha_modificacion>2020-12-06 20:33:41</fecha_modificacion>
</row>
<row>
  <ID>248</ID>
  <supergrupo>Generadores</supergrupo>
  <tema>Números aleatorios</tema>
  <texto>null</texto>
  <complejidad_tiempo>No aplica</complejidad_tiempo>
  <java>// Un programa Java para generar casos de prueba para números aleatorios

import java.io.*;
import java.util.Random;

public class TestCasesGeneratingRandomNumbers {

    // el número de ejecuciones de los datos de prueba generados
    static int requiredNumbers = 5;
    // rango mínimo de números aleatorios
    static int lowerBound = 0;
    // rango máximo de números aleatorios
    static int upperBound = 1000;

    static void randomNumbers() {
        Random random = new Random();
        for (int i = 0; i &lt; requiredNumbers; i++) {
            int a = random.nextInt(upperBound - lowerBound)
                    + lowerBound;
            System.out.println(a);
        }
    }

    public static void main(String[] args) throws IOException {
        randomNumbers();
    }
}
</java>
  <cpp>#include &lt;cstdlib&gt;
#include &lt;bits/stdc++.h&gt; 
using namespace std;

static int requiredNumbers = 5;
static int lowerBound = 0;
static int upperBound = 1000;

void randomNumbers() {
    for (int i = 0; i &lt; requiredNumbers; i++) {
        int a = (rand()) % upperBound;
        cout &lt;&lt; a &lt;&lt; &quot; &quot;;
    }
}

int main() {
    randomNumbers();
}
</cpp>
  <py>import random as r
requiredNumbers = 5
lowerBound = 0
upperBound = 1000

def randomNumbers():
    for i in range (requiredNumbers):
        a = r.randint(lowerBound, upperBound)
        print(a)
randomNumbers()
</py>
  <orden>11</orden>
  <suborden>0</suborden>
  <fecha_creacion>2020-12-06 19:51:51</fecha_creacion>
  <fecha_modificacion>2020-12-06 20:34:17</fecha_modificacion>
</row>
<row>
  <ID>249</ID>
  <supergrupo>Generadores</supergrupo>
  <tema>Vectores numéricos aleatorios</tema>
  <texto>null</texto>
  <complejidad_tiempo>No aplica</complejidad_tiempo>
  <java>// Un programa Java para generar casos de prueba para 
// matrices llenas de números aleatorios

import java.io.*;
import java.util.Random;

public class TestCasesGeneratingRandomArrays {

    static int RUN = 5;
    // rango mínimo de números aleatorios
    static int lowerBound = 0;
    // rango máximo de números aleatorios
    static int upperBound = 1000;
    // tamaño mínimo de la matriz reqd
    static int minSize = 10;
    // tamaño máximo de la matriz reqd
    static int maxSize = 20;

    static void randomArray() {
        Random random = new Random();
        for (int i = 0; i &lt; RUN; i++) {
            int size = random.nextInt(maxSize - minSize)
                    + minSize;
            int[] array = new int[size];

            System.out.println(size);

            for (int j = 0; j &lt; size; j++) {
                int a = random.nextInt(upperBound - lowerBound)
                        + lowerBound;
                System.out.print(a + &quot; &quot;);
            }
            System.out.println();
        }
    }

    public static void main(String[] args) throws IOException {
        randomArray();
    }
}
</java>
  <cpp>#include &lt;cstdlib&gt;
#include &lt;bits/stdc++.h&gt; 
using namespace std;

int RUN = 5;
int lowerBound = 0;
int upperBound = 1000;
int minSize = 10;
int maxSize = 20;

void randomArray() {
    for (int i = 0; i &lt; RUN; i++) {
        int size = maxSize - (rand() % minSize);
        int array[size];
        cout &lt;&lt; size &lt;&lt; endl;
        for (int j = 0; j &lt; size; j++) {
            int a = upperBound - (rand() % upperBound);
            cout &lt;&lt; a &lt;&lt; &quot; &quot;;
        }
        cout &lt;&lt; endl;
    }
}

int main() {
    randomArray();
}
</cpp>
  <py>import random as r
RUN = 5;
lowerBound = 0;
upperBound = 1000;
minSize = 10;
maxSize = 20;
def randomArray():
    for i in range (RUN):
        size = r.randint(minSize, maxSize)
        array = [0 for j in range(size)]
        print(size)
        str1 = &quot;&quot;
        for j in range (size):
            a = r.randint(lowerBound, upperBound)
            str1 += str(a) + &quot; &quot; 
        print(str1)
randomArray()        
</py>
  <orden>11</orden>
  <suborden>1</suborden>
  <fecha_creacion>2020-12-06 19:51:52</fecha_creacion>
  <fecha_modificacion>2020-12-06 20:34:18</fecha_modificacion>
</row>
<row>
  <ID>250</ID>
  <supergrupo>Generadores</supergrupo>
  <tema>Matrices numéricas aleatorias</tema>
  <texto>null</texto>
  <complejidad_tiempo>No aplica</complejidad_tiempo>
  <java>// Un programa Java para generar casos de prueba para 
// matrices llenas de números aleatorios

import java.io.IOException;
import java.util.Random;

public class TestCasesGeneratingRandomMatrix {

    // el número de ejecuciones de los datos de prueba generados
    static int RUN = 5;
    // rango mínimo de números aleatorios
    static int lowerBound = 0;
    // rango máximo de números aleatorios
    static int upperBound = 1000;
    // tamaño máximo de columna 
    static int maxColomn = 10;
    // tamaño mínimo de columna
    static int minColomn = 1;
    // tamaño mínimo de fila
    static int minRow = 1;
    // tamaño máximo de fila
    static int maxRow = 10;

    static void randomArray() {
        Random random = new Random();

        for (int i = 0; i &lt; RUN; i++) {
            int row = random.nextInt(maxRow - minRow)
                    + minRow;
            int colomn = random.nextInt(maxColomn - minColomn)
                    + minColomn;

            int[][] matrix = new int[row][colomn];

            System.out.println(row + &quot; &quot; + colomn);

            for (int j = 0; j &lt; row; j++) {
                for (int k = 0; k &lt; colomn; k++) {
                    int a = random.nextInt(upperBound - lowerBound)
                            + lowerBound;
                    System.out.print(a + &quot; &quot;);
                }
                System.out.println();
            }
            System.out.println();
        }
    }

    public static void main(String[] args) throws IOException {
        randomArray();
    }
}
</java>
  <cpp>#include &lt;cstdlib&gt;
#include &lt;bits/stdc++.h&gt; 
using namespace std;

int RUN = 5;
int lowerBound = 0;
int upperBound = 1000;
int maxColumn = 10;
int minColumn = 1;
int minRow = 1;
int maxRow = 10;

void randomMatrix() {
    for (int i = 0; i &lt; RUN; i++) {
        int row = maxRow - (rand() % maxRow) - minRow;
        int column = maxColumn - (rand() % maxColumn) - minColumn;
        int matrix[row][column];
        cout &lt;&lt; row &lt;&lt; &quot; &quot; &lt;&lt; column &lt;&lt; endl;
        for (int j = 0; j &lt; row; j++) {
            for (int k = 0; k &lt; column; k++) {
                int a = upperBound - (rand() % upperBound);
                cout &lt;&lt; a &lt;&lt; &quot; &quot;;
            }
            cout &lt;&lt; endl;
        }
        cout &lt;&lt; endl;
    }
}

int main() {
    randomMatrix();
}
</cpp>
  <py>import random as r
RUN = 5;
lowerBound = 0
upperBound = 1000
maxColumn = 10
minColumn = 1
minRow = 1
maxRow = 10
def randomMatrix():
    for _ in range (RUN):
        row = r.randint(minRow,maxRow)
        column = r.randint(minColumn,maxColumn)
        matrix=[[0 for x in range(row)]for y in range (column)];
        print(str(row) + &quot; &quot; + str(column))
        str1=&quot;&quot;
        for i in range (row):
            for j in range (column):
                a = r.randint(lowerBound,upperBound)
                str1+=str(a)+&quot; &quot; 
            print(str1)
            str1=&quot;&quot;
randomMatrix()
</py>
  <orden>11</orden>
  <suborden>2</suborden>
  <fecha_creacion>2020-12-06 19:51:52</fecha_creacion>
  <fecha_modificacion>2020-12-06 20:34:18</fecha_modificacion>
</row>
<row>
  <ID>251</ID>
  <supergrupo>Generadores</supergrupo>
  <tema>Vectores numéricos ordenados aleatorios</tema>
  <texto>null</texto>
  <complejidad_tiempo>No aplica</complejidad_tiempo>
  <java>// Programa para generar casos de prueba para arrays llenos de números aleatorios

import java.util.Arrays;
import java.util.Random;

public class TestCasesRandomSortedArray {

    // Define el número de corridas para los datos de prueba generados.
    static int RUN = 5;
    // Define el rango de los datos de prueba generados
    static int MAX = 100000;
    // Define el número máximo de elementos de la matriz
    static int MAXNUM = 100;

    static void randSortedArray() {
        Random r = new Random();
        int NUM; // Número de elementos de la matriz
        for (int i = 1; i &lt;= RUN; i++) {
            NUM = 1 + r.nextInt(MAXNUM);
            int[] arr = new int[NUM];
            // Primero imprima el número de elementos de la matriz
            System.out.printf(&quot;%d\n&quot;, NUM);
            for (int j = 0; j &lt; NUM; j++) {
                arr[j] = r.nextInt(MAX);
            }
            // Ordenar la arrya aleatoria generada
            Arrays.sort(arr);
            // Imprime la array aleatoria ordenada
            for (int j = 0; j &lt; NUM; j++) {
                System.out.printf(&quot;%d &quot;, arr[j]);
            }
            System.out.printf(&quot;\n&quot;);
        }
    }

    public static void main(String[] args) {
        randSortedArray();
    }
}
</java>
  <cpp>#include&lt;bits/stdc++.h&gt; 
using namespace std;

#define RUN 5 
#define MAX 100000 
#define MAXNUM 100 

void randSortedArray() {
    srand(time(NULL));
    int NUM; 
    for (int i = 1; i &lt;= RUN; i++) {
        NUM = 1 + rand() % MAXNUM;
        int arr[NUM];
        printf(&quot;%d\n&quot;, NUM);
        for (int j = 0; j &lt; NUM; j++)
            arr[j] = rand() % MAX;
        sort(arr, arr + NUM);
        for (int j = 0; j &lt; NUM; j++)
            printf(&quot;%d &quot;, arr[j]);

        printf(&quot;\n&quot;);
    }
}

int main() {
    randSortedArray();
}
</cpp>
  <py>import random as r
RUN =5
MAX=100000
MAXNUM=100

def randSortedArray():
    for i in range(RUN):
        NUM=1+r.randint(0,MAXNUM)
        arr=[]
        print(NUM)
        for j in range(NUM):
            arr.append(r.randint(0,MAX))
        arr.sort()
        print(arr)
        
randSortedArray()
</py>
  <orden>11</orden>
  <suborden>3</suborden>
  <fecha_creacion>2020-12-06 19:51:52</fecha_creacion>
  <fecha_modificacion>2020-12-06 20:34:19</fecha_modificacion>
</row>
<row>
  <ID>252</ID>
  <supergrupo>Generadores</supergrupo>
  <tema>Caracteres aleatorios</tema>
  <texto>null</texto>
  <complejidad_tiempo>No aplica</complejidad_tiempo>
  <java>// Programa para generar casos de prueba para caracteres aleatorios

import java.util.Random;

public class TestCasesRandomChars {

    // Definir el número de corridas para los datos de prueba generados.
    static int RUN = 5;
    // Defina el rango de los datos de prueba generados Aquí es de &#39;a&#39; a &#39;z&#39; 
    static int MAX = 25;

    static void randomChars() {
        Random r = new Random();
        for (int i = 1; i &lt;= RUN; i++) {
            System.out.printf(&quot;%c\n&quot;, (char) (&#39;a&#39; + r.nextInt(25)));
        }
    }

    public static void main(String[] args) {
        randomChars();
    }
}
</java>
  <cpp>#include&lt;bits/stdc++.h&gt; 
using namespace std;

#define RUN 5 
#define MAX 25 

void randomChars() {
    srand(time(NULL));
    for (int i = 1; i &lt;= RUN; i++)
        printf(&quot;%c\n&quot;, &#39;a&#39; + rand() % MAX);
}

int main() {
    randomChars();
}
</cpp>
  <py>import random as r
RUN=5
MAX=25

def randomChars():
    for i in range(RUN):
        print(chr(ord(&#39;a&#39;)+r.randint(0,MAX)))
        
randomChars()
</py>
  <orden>11</orden>
  <suborden>4</suborden>
  <fecha_creacion>2020-12-06 19:51:53</fecha_creacion>
  <fecha_modificacion>2020-12-06 20:34:20</fecha_modificacion>
</row>
<row>
  <ID>253</ID>
  <supergrupo>Generadores</supergrupo>
  <tema>Cadenas de caracteres aleatorias</tema>
  <texto>null</texto>
  <complejidad_tiempo>No aplica</complejidad_tiempo>
  <java>// Programa para generar casos de prueba para cadenas aleatorias

import java.util.Random;
public class TestCasesRandomStrings {

    // Definir el número de corridas para los datos de prueba generados.
    static int RUN = 5;
    // Definir el rango de los datos de prueba generados
    // Aquí está de &#39;a&#39; a la &#39;z&#39;
    static int MAX = 25;
    // Definir la longitud máxima de la cuerda
    static int MAXLEN = 100;

    static void randString() {
        //Para valores aleatorios cada vez
        Random r = new Random();
        int LEN; // tamaño de la cadena
        for (int i = 1; i &lt;= RUN; i++) {
            LEN = 1 + r.nextInt(MAXLEN);
            // Primero imprime la longitud de la cadena
            System.out.printf(&quot;%d\n&quot;, LEN);
            // Luego imprime los caracteres de la cadena
            for (int j = 1; j &lt;= LEN; j++) {
                System.out.printf(&quot;%c&quot;, (char)(&#39;a&#39; + r.nextInt(MAX)));
            }
            System.out.printf(&quot;\n&quot;);
        }
    }

    public static void main(String[] args) {
        randString();
    }

}
</java>
  <cpp>#include&lt;bits/stdc++.h&gt; 
using namespace std;

#define RUN 5
#define MAX 25 
#define MAXLEN 100 

void randString() {
    srand(time(NULL));
    int LEN; 
    for (int i = 1; i &lt;= RUN; i++) {
        LEN = 1 + rand() % MAXLEN;
        printf(&quot;%d\n&quot;, LEN);
        for (int j = 1; j &lt;= LEN; j++)
            printf(&quot;%c&quot;, &#39;a&#39; + rand() % MAX);
        printf(&quot;\n&quot;);
    }
}

int main() {
    randString();
}
</cpp>
  <py>import random as r
RUN=5
MAX=25
MAXLEN=100
def randString():
    for i in range(RUN):
        LEN=1+r.randint(0,MAXLEN)
        print(LEN)
        STR=&quot;&quot;
        for j in range(LEN):
            STR+=chr(ord(&#39;a&#39;) + r.randint(0,MAX))
        print(STR)
        
randString()
</py>
  <orden>11</orden>
  <suborden>5</suborden>
  <fecha_creacion>2020-12-06 19:51:53</fecha_creacion>
  <fecha_modificacion>2020-12-06 20:34:20</fecha_modificacion>
</row>
<row>
  <ID>254</ID>
  <supergrupo>Generadores</supergrupo>
  <tema>Vectores de cadenas de caracteres aleatorias</tema>
  <texto>null</texto>
  <complejidad_tiempo>No aplica</complejidad_tiempo>
  <java>// Un programa java para generar casos de prueba para cadenas aleatorias

import java.util.Random;
public class TestCasesRandomArrayStrings {

    // Define el número de corridas para los datos de prueba generados.
    static int RUN = 1000;
    // Define el rango de los datos de prueba generados Aquí es de &#39;a&#39; a &#39;z&#39;
    static int MAX = 25;
    // Definie el rango de número de cadenas en la matriz.
    static int MAXNUM = 20;
    // Define la longitud máxima de la cadena
    static int MAXLEN = 20;

    static void randomStrArr() {
        Random r = new Random();
        int NUM; // Número de cadenas en la matriz
        int LEN; // Longitud de la cadena
        for (int i = 1; i &lt;= RUN; i++) {
            NUM = 1 + r.nextInt(MAXNUM);
            System.out.printf(&quot;%d\n&quot;, NUM);
            for (int k = 1; k &lt;= NUM; k++) {
                LEN = 1 + r.nextInt(MAXLEN);;
                // Luego imprime los caracteres de la cadena
                for (int j = 1; j &lt;= LEN; j++) {
                    System.out.printf(&quot;%c&quot;, &#39;a&#39; + r.nextInt(MAX));
                }
                System.out.printf(&quot; &quot;);
            }
            System.out.printf(&quot;\n&quot;);
        }
    }

    public static void main(String[] args) {
        randomStrArr();
    }
}
</java>
  <cpp>#include&lt;bits/stdc++.h&gt; 
using namespace std;


#define RUN 1000 
#define MAX 25 
#define MAXNUM 20
#define MAXLEN 20 

void randomStrArr() {
    srand(time(NULL));
    int NUM; 
    int LEN;
    for (int i = 1; i &lt;= RUN; i++) {
        NUM = 1 + rand() % MAXNUM;
        printf(&quot;%d\n&quot;, NUM);

        for (int k = 1; k &lt;= NUM; k++) {
            LEN = 1 + rand() % MAXLEN;
            for (int j = 1; j &lt;= LEN; j++)
                printf(&quot;%c&quot;, &#39;a&#39; + rand() % MAX);

            printf(&quot; &quot;);
        }
        printf(&quot;\n&quot;);
    }
}

int main() {
    randomStrArr();
    return (0);
}
</cpp>
  <py>import random as r
RUN = 1000 
MAX = 25 
MAXNUM = 20
MAXLEN =  20 
def randomStrArr():
    for i in range (1,RUN+1):
        NUM = r.randint(1,MAXNUM)
        print(NUM)
        for k in range (1,NUM):
            LEN = r.randint(1,MAXLEN)
            str1=&quot;&quot;
            for J in range (1,LEN):
                str1+=chr(ord(&#39;a&#39;)+r.randint(0,MAX))+&quot;&quot;;
            print (str1)
            str1=&quot;&quot;

randomStrArr()
</py>
  <orden>11</orden>
  <suborden>6</suborden>
  <fecha_creacion>2020-12-06 19:51:53</fecha_creacion>
  <fecha_modificacion>2020-12-06 20:34:21</fecha_modificacion>
</row>
<row>
  <ID>255</ID>
  <supergrupo>Generadores</supergrupo>
  <tema>Palíndromos aleatorios</tema>
  <texto>null</texto>
  <complejidad_tiempo>No aplica</complejidad_tiempo>
  <java>import java.util.LinkedList;
import java.util.Random;

public class TestCasesRandomPalindromes {

    static int RUN = 5;
    static int MAX = 25;
    static int MAXLEN = 50;

    static void randPalindrome() {
        Random r = new Random();
        // Un recipiente para almacenar los palíndromos. 
        LinkedList&lt;Character&gt; container = new LinkedList&lt;&gt;();
        int LEN; // Longitud de la cadena
        for (int i = 1; i &lt;= RUN; i++) {
            LEN = 1 + r.nextInt(MAXLEN);
            // Primero imprime la longitud de la cadena
            System.out.printf(&quot;%d\n&quot;, LEN);
            // Si es un palíndromo de longitud impar
            if (LEN % 2 == 1) {
                container.addLast((char) (&#39;a&#39; + r.nextInt(MAX)));
            }
            // Luego imprime los caracteres de la cadena palindrómica
            for (int j = 1; j &lt;= LEN / 2; j++) {
                char ch = (char) (&#39;a&#39; + r.nextInt(MAX));
                container.addLast(ch);
                container.addFirst(ch);
            }
            for (Character c : container) {
                System.out.printf(&quot;%c&quot;, c);
            }
            container.clear();
            System.out.printf(&quot;\n&quot;);
        }
    }

    public static void main(String[] args) {
        randPalindrome();
    }

}
</java>
  <cpp>#include&lt;bits/stdc++.h&gt; 
using namespace std;

#define RUN 5 
#define MAX 25 
#define MAXLEN 50 

void randPalindrome(){
    srand(time(NULL));
    deque&lt;char&gt; container;
    deque&lt;char&gt;::iterator it;
    int LEN; 
    for (int i = 1; i &lt;= RUN; i++) {
        LEN = 1 + rand() % MAXLEN;
        printf(&quot;%d\n&quot;, LEN);
        if (LEN % 2)
            container.push_back(&#39;a&#39; + rand() % MAX);

        for (int j = 1; j &lt;= LEN / 2; j++) {
            char ch = &#39;a&#39; + rand() % MAX;
            container.push_back(ch);
            container.push_front(ch);
        }
        for (it = container.begin(); it != container.end(); ++it)
            printf(&quot;%c&quot;, *it);

        container.clear();
        printf(&quot;\n&quot;);
    } 
}

int main() {
    randPalindrome();
}
</cpp>
  <py>import random as r

RUN=5
MAX=25
MAXLEN=25
def randPalindrome():
    container=[]
    for i in range(RUN):
        LEN=1+r.randint(0,MAXLEN)
        print(LEN)
        if LEN%2==1:
            container.append(chr(ord(&#39;a&#39;)+r.randint(0,MAX)))
        for j in range (1,LEN/2+1):
            ch=chr(ord(&#39;a&#39;)+r.randint(0,MAX))
            container.append(ch)
            container.insert(0,ch)
        palin=str(container)
        palin=palin.replace(&quot;[&quot;, &quot;&quot;)
        palin=palin.replace(&quot;]&quot;, &quot;&quot;)
        palin=palin.replace(&quot;&#39;&quot;, &quot;&quot;)
        palin=palin.replace(&quot;,&quot;, &quot;&quot;)
        palin=palin.replace(&quot; &quot;, &quot;&quot;)
        print(palin)
        
randPalindrome()
</py>
  <orden>11</orden>
  <suborden>7</suborden>
  <fecha_creacion>2020-12-06 19:51:54</fecha_creacion>
  <fecha_modificacion>2020-12-06 20:34:22</fecha_modificacion>
</row>
<row>
  <ID>256</ID>
  <supergrupo>Generadores</supergrupo>
  <tema>Grafos no ponderados aleatorios</tema>
  <texto>null</texto>
  <complejidad_tiempo>No aplica</complejidad_tiempo>
  <java>// Program to generate test cases for an unweighted directed graph 

import java.util.HashSet;
import java.util.Random;
import java.util.Set;

public class TestCasesUnweightedDirectedGraph {

    // Definir el número de corridas para los datos de prueba generados. 
    static int RUN = 5;
    // Definir el número máximo de vértices del grafo.
    static int MAX_VERTICES = 20;
    // Definir el número máximo de aristas
    static int MAX_EDGES = 20;

    static class Pair {

        int first, second;

        public Pair(int first, int second) {
            this.first = first;
            this.second = second;
        }

    }

    static int getIndex(Set&lt;Pair&gt; set, Pair value) {
        int result = 0;
        for (Object entry : set) {
            if (entry.equals(value)) {
                return result;
            }
            result++;
        }
        return set.size() + 1;
    }

    public static void main(String[] args) {
        Set&lt;Pair&gt; container = new HashSet&lt;&gt;();
        //Para valores aleatorios cada vez
        Random r = new Random();

        int VERTICES; // Número de vértices
        int NUMEDGE; // Número de bordes

        for (int i = 1; i &lt;= RUN; i++) {
            VERTICES = 1 + r.nextInt(MAX_VERTICES);
            // Definir el número máximo de aristas del grafo Dado que el grafo 
            // más denso puede tener N * (N-1) / 2 aristas donde 
            // N = número de vértices en el gráfico
            NUMEDGE = 1 + r.nextInt(MAX_EDGES);
            while (NUMEDGE &gt; VERTICES * (VERTICES - 1) / 2) {
                NUMEDGE = 1 + r.nextInt(MAX_EDGES);
            }
            // Primero imprime el número de vértices y aristas
            System.out.printf(&quot;%d %d\n&quot;, VERTICES, NUMEDGE);
            // Luego imprima los bordes del formulario (a b) 
            // donde &#39;a&#39; está conectado a &#39;b&#39;
            for (int j = 1; j &lt;= NUMEDGE; j++) {
                int a = 1 + r.nextInt(VERTICES);
                int b = 1 + r.nextInt(VERTICES);
                Pair p = new Pair(a, b);
                // Busca una ventaja &quot;nueva&quot; aleatoria cada vez
                // Nota: en un árbol, el borde (a, b) es el mismo que el borde (b, a)
                while (getIndex(container, p) != container.size() + 1) {
                    a = 1 + r.nextInt(VERTICES);
                    b = 1 + r.nextInt(VERTICES);
                    p = new Pair(a, b);
                }
                container.add(p);
            }
            for (Pair p : container) {
                System.out.printf(&quot;%d %d\n&quot;, p.first - 1, p.second - 1);
            }
            container.clear();
            System.out.printf(&quot;\n&quot;);
        }

    }
}
</java>
  <cpp>#include&lt;bits/stdc++.h&gt; 
using namespace std;

#define RUN 5 
#define MAX_VERTICES 20 
#define MAX_EDGES 20 

int main() {
    set&lt;pair&lt;int, int&gt;&gt; container;
    srand(time(NULL));
    int VERTICES;
    int NUMEDGE;
    for (int i = 1; i &lt;= RUN; i++) {
        VERTICES = 1 + rand() % MAX_VERTICES;
        NUMEDGE = 1 + rand() % MAX_EDGES;
        while (NUMEDGE &gt; VERTICES * (VERTICES - 1) / 2)
            NUMEDGE = 1 + rand() % MAX_EDGES;
        printf(&quot;%d %d\n&quot;, VERTICES, NUMEDGE);
        for (int j = 1; j &lt;= NUMEDGE; j++) {
            int a = 1 + rand() % VERTICES;
            int b = 1 + rand() % VERTICES;
            pair&lt;int, int&gt; p = make_pair(a, b);
            while (container.find(p) != container.end()) {
                a = 1 + rand() % VERTICES;
                b = 1 + rand() % VERTICES;
                p = make_pair(a, b);
            }
            container.insert(p);
        }
        for (pair&lt;int, int&gt; p : container) {
            printf(&quot;%d %d\n&quot;, p.first - 1, p.second - 1);
        }
        container.clear();
        printf(&quot;\n&quot;);
    }
    return (0);
}
</cpp>
  <py>import random as r
RUN = 5
MAX_VERTICES = 20
MAX_EDGES = 20
class Pair:
    def __init__(self, first, second):
        self.first = first
        self.second = second
        
def getIndex(setin, value):
    result = 0;
    for entry in setin:
        if (entry == value):
            return result
        result += 1;
    return len(setin) + 1;
    
container = {}
for i in range (RUN):
    VERTICES = 1 + r.randint(0, MAX_VERTICES)
    NUMEDGE = 1 + r.randint(0, MAX_EDGES)
    while (NUMEDGE &gt; VERTICES * (VERTICES - 1) / 2):
        NUMEDGE = 1 + r.randint(0, MAX_EDGES)
    print(str(VERTICES) + &quot; &quot; + str(NUMEDGE)) 
    for j in range (NUMEDGE):
        a = 1 + r.randint(0, VERTICES);
        b = 1 + r.randint(0, VERTICES);
        p = Pair(a, b)
        while (getIndex(container, p) != len(container) + 1):
            a = 1 + r.randint(0, VERTICES)
            b = 1 + r.randint(0, VERTICES)
            p = Pair()
            p.first = a
            p.second = b
        container[j] = p
    for p in container:
        print(str(container[p].first) + &quot; &quot; + str(container[p].second))
    container.clear();
    print(&quot;&quot;)
</py>
  <orden>11</orden>
  <suborden>8</suborden>
  <fecha_creacion>2020-12-06 19:51:54</fecha_creacion>
  <fecha_modificacion>2020-12-06 20:34:22</fecha_modificacion>
</row>
<row>
  <ID>257</ID>
  <supergrupo>Generadores</supergrupo>
  <tema>Grafos ponderados aleatorios</tema>
  <texto>null</texto>
  <complejidad_tiempo>No aplica</complejidad_tiempo>
  <java>// Programa para generar casos de prueba para un gráfico dirigido no ponderado 

import java.util.HashSet;
import java.util.Random;
import java.util.Set;

public class TestCasesWeightedDirectedGraph {

    // Definir el número de corridas para los datos de prueba generados.
    static int RUN = 5;
    // Definir el número máximo de vértices del gráfico.
    static int MAX_VERTICES = 20;
    // Definir el número máximo de aristas
    static int MAX_EDGES = 20;
    static int MAXWEIGHT = 200;

    static class Pair {

        int first, second;

        public Pair(int first, int second) {
            this.first = first;
            this.second = second;
        }

    }

    static int getIndex(Set&lt;Pair&gt; set, Pair value) {
        int result = 0;
        for (Object entry : set) {
            if (entry.equals(value)) {
                return result;
            }
            result++;
        }
        return set.size() + 1;
    }

    public static void main(String[] args) {
        Set&lt;Pair&gt; container = new HashSet&lt;&gt;();
        //Para valores aleatorios cada vez
        Random r = new Random();

        int VERTICES; // Número de vértices
        int NUMEDGE; // Número de caminos

        for (int i = 1; i &lt;= RUN; i++) {
            VERTICES = 1 + r.nextInt(MAX_VERTICES);
            // Definir el número máximo de aristas del grafo Dado que el grafo 
            // más denso puede tener N * (N-1) / 2 aristas donde 
            // N = número de vértices en el grafo
            NUMEDGE = 1 + r.nextInt(MAX_EDGES);
            while (NUMEDGE &gt; VERTICES * (VERTICES - 1) / 2) {
                NUMEDGE = 1 + r.nextInt(MAX_EDGES);
            }
            // Primero imprime el número de vértices y aristas
            System.out.printf(&quot;%d %d\n&quot;, VERTICES, NUMEDGE);
            // Luego imprima los bordes del formulario (a b) donde &#39;a&#39; está conectado a &#39;b&#39;
            for (int j = 1; j &lt;= NUMEDGE; j++) {
                int a = 1 + r.nextInt(VERTICES);
                int b = 1 + r.nextInt(VERTICES);
                Pair p = new Pair(a, b);
                // Busque una ventaja &quot;nueva&quot; aleatoria cada vez
                // Nota: en un árbol, el borde (a, b) es el mismo que el borde (b, a)
                while (getIndex(container, p) != container.size() + 1) {
                    a = 1 + r.nextInt(VERTICES);
                    b = 1 + r.nextInt(VERTICES);
                    p = new Pair(a, b);
                }
                container.add(p);
            }
            for (Pair p : container) {
                int wt = 1 + r.nextInt(MAXWEIGHT);
                System.out.printf(&quot;%d %d %d\n&quot;, p.first - 1, p.second - 1, wt);
            }
            container.clear();
            System.out.printf(&quot;\n&quot;);
        }

    }
}
</java>
  <cpp>#include&lt;bits/stdc++.h&gt; 
using namespace std;

#define RUN 5 
#define MAX_VERTICES 20 
#define MAX_EDGES 20 
#define MAXWEIGHT 200 

int main() {
    set&lt;pair&lt;int, int&gt;&gt; container;
    srand(time(NULL));
    int VERTICES;
    int NUMEDGE;
    for (int i = 1; i &lt;= RUN; i++) {
        VERTICES = 1 + rand() % MAX_VERTICES;
        NUMEDGE = 1 + rand() % MAX_EDGES;
        while (NUMEDGE &gt; VERTICES * (VERTICES - 1) / 2)
            NUMEDGE = 1 + rand() % MAX_EDGES;
        printf(&quot;%d %d\n&quot;, VERTICES, NUMEDGE);
        for (int j = 1; j &lt;= NUMEDGE; j++) {
            int a = 1 + rand() % VERTICES;
            int b = 1 + rand() % VERTICES;
            pair&lt;int, int&gt; p = make_pair(a, b);
            while (container.find(p) != container.end()) {
                a = 1 + rand() % VERTICES;
                b = 1 + rand() % VERTICES;
                p = make_pair(a, b);
            }
            container.insert(p);
        }

        for (pair&lt;int, int&gt; p : container) {
            int wt = 1 + rand() % MAXWEIGHT;
            printf(&quot;%d %d %d\n&quot;, p.first - 1, p.second - 1, wt);
        }
        container.clear();
        printf(&quot;\n&quot;);
    }
    return (0);
}
</cpp>
  <py>import random as r
RUN = 5
MAX_VERTICES = 20
MAX_EDGES = 20
MAXWEIGHT = 200
class Pair:
    def __init__(self, first, second):
        self.first = first
        self.second = second
        
def getIndex(setin, value):
    result = 0;
    for entry in setin:
        if (entry == value):
            return result
        result += 1;
    return len(setin) + 1;
    
container = {}
for i in range (RUN):
    VERTICES = 1 + r.randint(0, MAX_VERTICES)
    NUMEDGE = 1 + r.randint(0, MAX_EDGES)
    while (NUMEDGE &gt; VERTICES * (VERTICES - 1) / 2):
        NUMEDGE = 1 + r.randint(0, MAX_EDGES)
    print(str(VERTICES) + &quot; &quot; + str(NUMEDGE)) 
    for j in range (NUMEDGE):
        a = 1 + r.randint(0, VERTICES);
        b = 1 + r.randint(0, VERTICES);
        p = Pair(a, b)
        while (getIndex(container, p) != len(container) + 1):
            a = 1 + r.randint(0, VERTICES)
            b = 1 + r.randint(0, VERTICES)
            p = Pair()
            p.first = a
            p.second = b
        container[j] = p
    for p in container:
        wt = 1 + r.randint(0, MAXWEIGHT);
        print(str(container[p].first) + &quot; &quot; + str(container[p].second) + &quot; &quot; + str(wt))
    container.clear();
    print(&quot;&quot;)
</py>
  <orden>11</orden>
  <suborden>9</suborden>
  <fecha_creacion>2020-12-06 19:51:54</fecha_creacion>
  <fecha_modificacion>2020-12-06 20:34:23</fecha_modificacion>
</row>
<row>
  <ID>258</ID>
  <supergrupo>Teoria</supergrupo>
  <tema>Reglas básicas</tema>
  <texto>Durante las competencias, dependiendo de la modalidad de la misma, existen ciertas reglas que se deben cumplir para mantener la igualdad entre los competidores y evitar cualquier tipo de trampas.
Competencias presenciales:
• Durante las competencias está prohibido el uso de elementos electrónicos tales como celulares, dispositivos de almacenamiento extraíbles, reproductores de música, auriculares, entre otros. De ser encontrado con alguno de estos, el participante será retirado del recinto y perderá el derecho a continuar en la competencia por intento de fraude.
• El ingreso a páginas web distintas a la plataforma oficial de la competencia será penalizado con la descalificación inmediata de la competencia.
• El consumo de bebidas y alimentos dentro de las aulas no está permitido.
• Durante la competencia los equipos no podrán hablar ni intercambiar material entre ellos. De ser sorprendidos por primera vez incumpliendo esta normal, se les hará una advertencia pero si ya es la segunda vez serán descalificados  de la competencia. 
• La copia de código de fuentes externas como páginas  web o redes sociales se  considera plagio.
• Está  permitido el uso de material como libros de texto, códigos impresos, textos matemáticos, diccionarios, entre otros.
• Cada equipo tendrá a su disposición una sola máquina durante la competencia.
• En la competencia los equipos serán conformados por máximo tres competidores. 
Competencias virtuales:
• Durante la competencia los equipos no podrán hablar ni intercambiar material entre ellos. De ser sorprendidos por primera vez incumpliendo esta normal, se les hará una advertencia pero si ya es la segunda vez serán descalificados  de la competencia. 
• En la competencia los equipos serán conformados por máximo tres competidores. 
• La copia de código de fuentes externas como páginas  web o redes sociales se  considera plagio.
• No se admite cualquier tipo de ataques informáticos que intenten vulnerar la integridad de los sistemas usados en las competencias.

Durante la mayoría de las competencias, la forma de entrada y salida de información de cada ejercicio se realiza por medio de la consola (STDIN/STDOUT), aunque algunas competencias si utilizan entornos gráficos y entornos web (Uva Online Judge, 2012).
2.2) ¿Qué es la programación competitiva?
Dentro de las iniciativas en el área de las ciencias de la computación, un tema que año con año cobra más auge es la programación competitiva; el cual se evidencia en torneos en los cuales varios grupos de personas intentan resolver un problema a través de código y algoritmos.
El trabajo en equipo, pensamiento crítico y actuar bajo presión, además de otras actividades, son desarrolladas e impulsadas a través de estas competencias. Se trata de un deporte mental en el que participan e impulsan compañías multinacionales de software como Google, IBM y Facebook.
El desarrollo de las habilidades de programación de algoritmos se potencia a través de la colaboración, es por ello que colegios y universidades de todo el mundo buscan que los alumnos participen en este tipo de torneos.
A su vez, el impulso de talento es crucial para actividades cada vez más demandantes y demandadas, como es la programación. De ahí que empresas de gran relevancia nacional e internacional este interesadas en egresados de carreras relacionadas.
</texto>
  <complejidad_tiempo>null</complejidad_tiempo>
  <java>null</java>
  <cpp>null</cpp>
  <py>null</py>
  <orden>0</orden>
  <suborden>99</suborden>
  <fecha_creacion>2020-12-06 20:56:39</fecha_creacion>
  <fecha_modificacion>2020-12-06 20:59:24</fecha_modificacion>
</row>
<row>
  <ID>259</ID>
  <supergrupo>Teoria</supergrupo>
  <tema>¿Qué es la programación competitiva?</tema>
  <texto>Dentro de las iniciativas en el área de las ciencias de la computación, un tema que año con año cobra más auge es la programación competitiva; el cual se evidencia en torneos en los cuales varios grupos de personas intentan resolver un problema a través de código y algoritmos.
El trabajo en equipo, pensamiento crítico y actuar bajo presión, además de otras actividades, son desarrolladas e impulsadas a través de estas competencias. Se trata de un deporte mental en el que participan e impulsan compañías multinacionales de software como Google, IBM y Facebook.
El desarrollo de las habilidades de programación de algoritmos se potencia a través de la colaboración, es por ello que colegios y universidades de todo el mundo buscan que los alumnos participen en este tipo de torneos.
A su vez, el impulso de talento es crucial para actividades cada vez más demandantes y demandadas, como es la programación. De ahí que empresas de gran relevancia nacional e internacional este interesadas en egresados de carreras relacionadas.
</texto>
  <complejidad_tiempo>null</complejidad_tiempo>
  <java>null</java>
  <cpp>null</cpp>
  <py>null</py>
  <orden>0</orden>
  <suborden>99</suborden>
  <fecha_creacion>2020-12-06 20:56:39</fecha_creacion>
  <fecha_modificacion>2020-12-06 20:59:24</fecha_modificacion>
</row>
<row>
  <ID>260</ID>
  <supergrupo>Teoria</supergrupo>
  <tema>¿Qué es un problema de programación competitiva?</tema>
  <texto>Un problema de programación competitiva es un pequeño ejercicio de programación que puede abordar cualquier tema de la vida cotidiana, ciencias puras como la matemática o la física, un juego de mesa como el ajedrez o un rompecabezas.
Utilizando la programación se pueden resolver estos ejercicios y buscar una solución óptima al mismo utilizando matemática, algoritmos matemáticos especializados o incluso lógica básica.
</texto>
  <complejidad_tiempo>null</complejidad_tiempo>
  <java>null</java>
  <cpp>null</cpp>
  <py>null</py>
  <orden>0</orden>
  <suborden>99</suborden>
  <fecha_creacion>2020-12-06 20:56:40</fecha_creacion>
  <fecha_modificacion>2020-12-06 20:59:24</fecha_modificacion>
</row>
<row>
  <ID>261</ID>
  <supergrupo>Teoria</supergrupo>
  <tema>Estructura de un problema de programación competitiva</tema>
  <texto>Un problema se encuentra conformado de 4 partes principales:
1. Título: Contiene el nombre del problema, comúnmente da una vaga aproximación al tema del problema
2. Descripción: Contiene toda la información del problema, puede ser una historia, un evento, algo que le pasando a alguien y quiere que usted lo ayude a resolverlo. Puede contener algunas pistas de cómo resolver el ejercicio, variables que se pueden usar y de qué tipo pueden ser.
3. Variables y restricciones: muestra el o los tipos de datos que entraran y el o los tipos de datos que deben salir, además del tamaño que puede tener la entrada.
4. Ejemplo de entrada y salida: Muestra uno de todos los posibles casos de prueba que pueden evaluarse en el ejercicio, tener en cuenta que los ejemplos en los textos de ejercicio nunca serán los únicos, se debe usar la parte de variables para calcular cual será el caso más fácil, un caso intermedio y el caso más difícil.
</texto>
  <complejidad_tiempo>null</complejidad_tiempo>
  <java>null</java>
  <cpp>null</cpp>
  <py>null</py>
  <orden>0</orden>
  <suborden>99</suborden>
  <fecha_creacion>2020-12-06 20:56:40</fecha_creacion>
  <fecha_modificacion>2020-12-06 20:59:24</fecha_modificacion>
</row>
<row>
  <ID>262</ID>
  <supergrupo>Teoria</supergrupo>
  <tema>Como abordar un problema</tema>
  <texto>Comúnmente todos los ejercicios tienen dos o más formas de ser solucionados, utilizando diversos tipos de algoritmos o metodologías matemáticas de resolución de problemas, a continuación nombraremos algunas de las formas existentes para abordar un problema:
- Fórmulas matemáticas
- Fuerza bruta
- Aproximaciones de raíces 
- Procesamiento de Strings 
- Búsqueda de patrones
- Uso de estructuras de datos especializadas
- Algoritmos prediseñados modificados
- Enfoque geométrico
- Algoritmos ingenuos
- Uso de estructuras geometrías avanzadas
- Búsquedas 
- Ordenamientos
Al leer toda la información de nuestro ejercicio, su deber como es identificar cual es la metodología más adecuada para la resolución de estos ejercicios, podemos apoyarnos de material previamente consultado. Entre cada metodología de resolución varia el uso de memoria, tiempo de ejecución y forma de entrada de la información a procesar, por lo que conocer los puntos fuertes y débiles de cada uno es crucial. 
Por lo general las metodologías matemáticas son las más rápidas pero también suelen ser las más complicadas de implementar, ya que se basan en la búsqueda de sistemas de ecuaciones o el uso de teoremas matemáticos que son complicados y abstractos de entender, las metodologías de fuerza bruta son las más lentas pero las más seguras a la hora de encontrar una solución a un problema debido a que usan gran cantidad de recursos para asegurarse de dar con la respuesta, además de obtener las demás respuestas posibles a un problema cuando sus variables cambian. 
Los desarrolladores y estudiantes resuelven muchas preguntas de codificación de estructuras de datos y algoritmos, pero la mayoría de ellos no comprende la importancia de esto. Muchos de ellos también tienen la opinión de que las estructuras de datos y los algoritmos solo ayudan en las entrevistas y después de eso, no hay uso de todas esas cosas complicadas en los trabajos diarios.
Es importante estar contento con aprender un nuevo lenguaje o framework y crear algunas aplicaciones con eso, pero una vez que ingrese a la industria del mundo real, se dará cuenta de que su trabajo no es solo escribir el código y hacer que las cosas funcionen. Su verdadero trabajo es escribir la cantidad correcta de buen código, lo que significa que debe ser eficiente y robusto, y aquí viene el papel de las estructuras de datos y los algoritmos. Las estructuras de datos y los algoritmos no solo ayudan a obtener la lógica de su programa, sino que también ayudan a escribir el código eficiente para su software. Ya sea que hablemos sobre la complejidad del tiempo o la administración de la memoria, la refactorización del código o la reutilización del código, comprenderá su valor en cada parte de su aplicación.
En proyectos del mundo real, su cerebro debería ser capaz de escribir una solución rápida y eficiente para desafíos complicados, y solo puede hacerlo cuando haya practicado mucha programación. Comprenda que el lenguaje y los frameworks son solo herramientas, no le enseñarán habilidades para resolver problemas. Se desarrolla habilidad para resolver problemas cuando se practica mucha programación.
Cada desarrollador tiene sus propios trucos y siguen su propio patrón para resolver problemas de codificación, pero cuando se trata de nuevos desarrolladores, siempre tienen dudas sobre dónde comenzar. Muchos de ellos entienden los problemas, la lógica y los conceptos básicos de la sintaxis, también entienden los códigos de otras personas y pueden seguirlos, pero cuando se trata de resolver las preguntas por su cuenta, se atascan. No entienden cómo convertir sus pensamientos en código a pesar de que entienden la sintaxis o la lógica. Estos son algunos pasos simples que lo ayudarán a abordar una pregunta de codificación dentro de una competencia o dentro de una entrevista de trabajo.
Comprender y analizar el problema
No importa si ha visto el ejercicio que está realizando en el pasado o no, lea la pregunta varias veces y comprenda por completo. Ahora, piense en la pregunta y analícela cuidadosamente. A veces leemos algunas líneas y asumimos el resto de las cosas por nuestra cuenta, pero un ligero cambio en su pregunta puede cambiar muchas cosas en su código, así que tenga cuidado al respecto. Ahora tome un papel y escriba todo. ¿Qué se proporciona (entrada) y qué necesita averiguar (salida)? 
Mientras se debe realizar las siguientes preguntas...
1. ¿Entendió el problema completamente?
2. ¿Sería capaz de explicar esta pregunta a otra persona?
3. ¿Qué y cuántas entradas se requieren?
4. ¿Cuál sería la salida para esas entradas?
5. ¿Necesita separar algunos módulos o partes del problema?
6. ¿Tiene suficiente información para resolver esa pregunta? De lo contrario, lea nuevamente la pregunta.
Por ejemplo: si se le da un vector y necesita devolver el vector que contiene solo números pares, primero analice el problema cuidadosamente. Mientras analiza el problema, debe hacerse algunas preguntas antes de saltar a la solución.
1. ¿Cómo identificar un número par? Divida ese número entre 2 y vea si su residuo es 0.
2. ¿Qué debo pasar a esta función? Un vector
3. ¿Qué contendrá ese vector? Uno o más números
4. ¿Cuáles son los tipos de datos de los elementos en el vector? Números
5. ¿Cuál es el objetivo final? El objetivo es devolver el vector de números pares. Si no hay números pares, devuelve un vector vacío.
Revise los datos de muestra y los ejemplos a fondo
Cuando intente comprender el problema, tome algunas entradas de muestra e intente analizar la salida. Tomar algunas entradas de muestra lo ayudará a comprender el problema de una mejor manera. También obtendrá la claridad de cuántos casos puede manejar su código y cuáles pueden ser la salida o el rango de salida posibles. 
• Considere algunas entradas o datos simples y analice la salida.
• Considere algunos aportes complejos y más grandes e identifique cuál será el resultado y cuántos casos debe tomar para resolver el problema.
• Considere también los casos extremos. Analice cuál sería la salida si no hay entrada o si proporciona alguna entrada no válida.

Romper el problema
Cuando vea un problema de programación que es complejo o grande, en lugar de tener miedo y confundirse acerca de cómo resolver esa pregunta, divida el problema en fragmentos más pequeños y luego intente resolver cada parte del problema. A continuación se detallan algunos pasos que debe seguir para resolver las complejas preguntas de codificación:
• Haga un diagrama de flujo para el problema en cuestión.
• Divida el problema en subproblemas o fragmentos más pequeños.
• Resuelva los subproblemas. Haga funciones independientes para cada subproblema.
• Conecte las soluciones de cada subproblema llamándolos en el orden requerido o según sea necesario.
• Donde sea necesario, use clases y objetos 
Escribir pseudocódigo
Antes de saltar a la solución, siempre es bueno escribir un pseudocódigo para su problema. Básicamente, el pseudocódigo define la estructura de su código y le ayudará a escribir cada línea de código que necesite para resolver el problema. Leer el pseudocódigo da una idea clara de lo que su código debe hacer. Muchas personas o programadores experimentados omiten este paso, pero cuando escribe pseudocódigo, el proceso de escribir el código final se vuelve más fácil para usted. Al final, solo tendrá que traducir cada línea de pseudocódigo en código real. Así que escriba cada paso y lógica en su pseudocódigo. 
Reemplazar pseudocódigo con código real
Una vez que haya escrito el pseudocódigo, es hora de traducirlo al código real. Reemplace cada línea de su pseudocódigo en código real en el idioma en el que está trabajando. Si ha dividido su problema en subproblemas, anote el código de cada subproblema. Mientras escribe el código, tenga en cuenta tres cosas:
• El punto donde comenzó
• ¿Dónde está ahora mismo?
• ¿Cuál es su destino (resultado final)?
No olvide probar su código con conjuntos de datos de muestra (paso 2) para verificar si la salida real es igual a la salida esperada. Una vez que haya terminado con la codificación, puede deshacerse del pseudocódigo

Cuando se encuentre dentro de una entrevista de trabajo, escriba el código, vaya diciéndole al entrevistador cómo está abordando el problema.
• Dígale al entrevistador cómo está tratando de comenzar.
• Cuéntele al entrevistador acerca de su enfoque para resolver el problema.
• Discuta con el entrevistador sobre la parte más difícil que enfrenta en su problema.
• Informe al entrevistador sobre el enfoque para resolver cada subproblema para obtener el resultado final.
• Discuta los datos de la muestra o los casos de prueba con el entrevistador.
• Discuta sobre la mejor solución con el entrevistador.
Simplifique y Optimice su Código
Intenta siempre mejorar su código. Mire hacia atrás, analícelo una vez más e intente encontrar una solución mejor o alternativa. Se ha mencionado anteriormente que siempre debe intentar escribir la cantidad correcta de código correcto, así que siempre busque la solución alternativa que sea más eficiente que la anterior. Escribir la solución correcta a su problema no es lo último que debe hacer. Explore el problema completamente con todas las soluciones posibles y luego escriba la solución más eficiente u optimizada para su código. Entonces, una vez que haya terminado de escribir la solución para su código, hay algunas preguntas que debe hacerse.
• ¿Se ejecuta este código para cada entrada posible, incluidos los casos límite?
• ¿Existe una solución alternativa para el mismo problema?
• ¿Es eficiente el código? ¿Puede ser más eficiente o se puede mejorar el rendimiento?
• ¿De qué otra forma puede hacer que el código sea más legible?
• ¿Hay más pasos o funciones adicionales que pueda realizar?
</texto>
  <complejidad_tiempo>null</complejidad_tiempo>
  <java>null</java>
  <cpp>null</cpp>
  <py>null</py>
  <orden>0</orden>
  <suborden>99</suborden>
  <fecha_creacion>2020-12-06 20:56:40</fecha_creacion>
  <fecha_modificacion>2020-12-06 20:59:24</fecha_modificacion>
</row>
<row>
  <ID>263</ID>
  <supergrupo>Teoria</supergrupo>
  <tema>Casos de prueba y tipos de casos de prueba</tema>
  <texto>null</texto>
  <complejidad_tiempo>null</complejidad_tiempo>
  <java>null</java>
  <cpp>null</cpp>
  <py>null</py>
  <orden>0</orden>
  <suborden>99</suborden>
  <fecha_creacion>2020-12-06 20:56:40</fecha_creacion>
  <fecha_modificacion>2020-12-06 20:59:24</fecha_modificacion>
</row>
<row>
  <ID>264</ID>
  <supergrupo>Teoria</supergrupo>
  <tema>10 pasos para resolver cualquier problema</tema>
  <texto>1. Lea el problema completamente al menos dos o tres veces (o la cantidad de veces que sean que te hagan sentir cómodo)
2. Identifique el tema al que pertenece el problema. ¿Es un problema de ordenamiento o coincidencia de patrones? ¿Puede usar la teoría de grafos? ¿Está relacionado con la teoría de números? etc.
3. Intente resolver el problema manualmente considerando 3 o 4 sets de datos de prueba.
4. Luego concéntrese en optimizar los pasos manuales. Intente hacerlo lo más simple posible.
5. Escriba el pseudocódigo y comentarios, además del código de cada paso. Una cosa que puede hacer es verificar después de escribir cada función. Use un buen IDE con un depurador, si es posible. No es necesario pensar mucho en la sintaxis. Solo concéntrese en la lógica y los pasos. 
6. Reemplace los comentarios o pseudocódigo con código real. Siempre verifique si los valores y el código se comportan como se esperaba antes de pasar a la nueva línea de pseudocódigo.
7. Luego optimice el código real.
8. Cuide también las condiciones de restricción de cada variable.
9. Obtenga comentarios de sus compañeros de equipo, profesores y otros desarrolladores y, si es posible, haga su pregunta en StackOverflow. Intente aprender de las pautas de los demás y de lo que están manejando esos problemas. Un problema puede resolverse de varias maneras. Por lo tanto, no se decepcione si no puede pensar como un experto. Debe atenerse al problema y gradualmente será mejor y más rápido para resolver problemas como los demás.
10. Practique, practique y practique.
</texto>
  <complejidad_tiempo>null</complejidad_tiempo>
  <java>null</java>
  <cpp>null</cpp>
  <py>null</py>
  <orden>0</orden>
  <suborden>99</suborden>
  <fecha_creacion>2020-12-06 20:56:41</fecha_creacion>
  <fecha_modificacion>2020-12-06 20:59:24</fecha_modificacion>
</row>
<row>
  <ID>265</ID>
  <supergrupo>Teoria</supergrupo>
  <tema>Resultados y veredictos de los jueces en línea</tema>
  <texto>Luego de enviar su programa al juez en línea, se compilará y ejecutará en ese sistema, y el juez automático lo probará con algunas entradas y salidas, o quizás con una herramienta de juez específica. Pasados unos segundos o minutos, recibirá una de estas respuestas:
In Queue (QU): El juez está ocupado y no puede atender su presentación. Será juzgado lo antes posible.
Accepted o Correct (AC): ¡OK! ¡Su programa es correcto! Produjo la respuesta correcta en un tiempo razonable y dentro del límite de uso de memoria. ¡Felicidades!
Presentation Error (PE): las salidas de su programa son correctas pero no se presentan de la manera correcta. Buscar espacios, justificar, saltos de línea...
Wrong Answer (WA): No se alcanzó la solución correcta para las entradas. Las entradas y salidas que usan los jueces en línea para probar los programas no son públicas, por lo que tendrá que detectar el error por usted mismo. 
Compile Error (CE): El compilador no pudo compilar su programa. Los mensajes de salida del compilador se le informan para que solucione el problema.
Runtime Error (RE): Su programa falló durante la ejecución (error de segmentación, excepción de punto flotante, mal lectura de datos, desbordamiento de variables… entre otros). La causa exacta no se informa al usuario para evitar el plagio. Asegúrese de que su programa devuelva un código 0 (Ejecución correcta) al shell. Si está utilizando Java, siga todas las especificaciones de envío.
Time Limit Exceeded (TLE): Su programa intentó ejecutarse durante demasiado tiempo; este error no le permite saber si su programa alcanzaría la solución correcta al problema o no.
Memory Limit Exceeded (MLE): Su programa intentó usar más memoria de la que permite el juez.
Output Limit Exceeded (OL): Su programa intentó escribir demasiada información. Esto suele ocurrir si entra en un bucle infinito.
Submission Error o Submit Failed (SE): El envío no se realizó correctamente. Esto se debe a algún error durante el proceso de envío o corrupción de datos.
Restricted Function (RF): Su programa está intentando utilizar una función que se  considera perjudicial para el sistema del juez en línea. Si obtiene este veredicto, probablemente sepa por qué... (Está haciendo trampa o intentando hacer daño al juez).
Can&#39;t Be Judged (CJ): El juez no tiene entradas y salidas de prueba para el problema seleccionado. Al elegir un problema, asegúrese de que el juez pueda juzgarlo.
</texto>
  <complejidad_tiempo>null</complejidad_tiempo>
  <java>null</java>
  <cpp>null</cpp>
  <py>null</py>
  <orden>0</orden>
  <suborden>99</suborden>
  <fecha_creacion>2020-12-06 20:56:41</fecha_creacion>
  <fecha_modificacion>2020-12-06 20:59:24</fecha_modificacion>
</row>
<row>
  <ID>266</ID>
  <supergrupo>Teoria</supergrupo>
  <tema>Diferencias generales de los lenguajes</tema>
  <texto>Debido a la metodología de ejecución de los diferentes lenguajes de programación, la cantidad de librerías, utilidades estándar de cada lenguaje y su dificultad al entender la sintaxis de las líneas de código, se evidencia que cada lenguaje tiene pros y contras en su utilización al momento de resolver ejercicios de programación competitiva, hay que recordar que Java es un lenguaje que utiliza una máquina virtual para su ejecución y que Python es un lenguaje interpretado, estas dos generan que ambos lenguajes sean ligeramente más lentos al ejecutarse.
Otra idea a tener en cuenta es el hecho de que Python no tiene problemas de desbordamiento de variables, debido a que todos los objetos que se crean dentro del código se les asigna memoria de forma dinámica y automática, lo que le permite realizar cálculos con números muy grandes, pero sacrificando rendimiento.
Java contiene una gran cantidad de librerías estándar para uso dentro de la programación competitiva, lo que le permite reducir líneas de código y agregar funcionalidades que optimicen diversas operaciones dentro de la ejecución del código.
Teniendo estas ideas en cuenta se puede realizar la siguiente comparación:
Velocidad de ejecución
PYTHON&lt;JAVA&lt;C++
Cantidad de librerías 
JAVA&gt;PYTHON&gt;C++
Dificultad de código
PYTHON&lt;JAVA&lt;C++
Nota: estas conclusiones solo aplican cuando los lenguajes se utilizan en ejercicios de programación competitiva.

Python es más lento en tiempo de ejecución que Java, y Java es más lento que C++, por lo que C++ es el lenguaje más rápido.  Java tiene muchas más librerías estándar que Python, y Python tiene muchas más librerías que C++, permitiendo que Java sea el lenguaje más polivalente, por último la dificultad de la sintaxis de Python es mucho menor a la de Java, y la dificultad de Java es mayor a la de C++, permitiendo que Python sea el lenguaje más sencillo de comprender al ser leído.
Un buen programador competitivo tiene conocimiento de estos tres lenguajes de programación de tal manera que al abordar un ejercicio pueda el decidir cuál de los tres lenguajes es el más adecuado para darle solución al mismo. 
</texto>
  <complejidad_tiempo>null</complejidad_tiempo>
  <java>null</java>
  <cpp>null</cpp>
  <py>null</py>
  <orden>0</orden>
  <suborden>99</suborden>
  <fecha_creacion>2020-12-06 20:56:41</fecha_creacion>
  <fecha_modificacion>2020-12-06 20:59:24</fecha_modificacion>
</row>
<row>
  <ID>267</ID>
  <supergrupo>Teoria</supergrupo>
  <tema>Consejos y trucos para programadores competitivos</tema>
  <texto>¿Qué lenguaje usar? Esta es una pregunta frecuente frente a en qué idioma se debe preferir ser eficiente en la programación competitiva. Es algo de lo que uno no debería preocuparse, ya que lo que importa es la lógica, no el lenguaje. La mayoría de los lenguajes son más o menos iguales, pero hasta ahora el lenguaje más utilizado es C ++, a continuación se presenta un resumen de las ventajas y desventajas de cada lenguaje.
Python
• Simple y fácil: Python es simple, fácil de escribir (se necesita escribir menos) y tiene una gran colección de módulos con casi todas las funciones que pueda imaginar.
• Tipos de datos: generalmente se prefiere Python, ya que no tiene ningún límite superior en la memoria de los enteros. Además, no es necesario especificar qué tipo de datos es y cosas como esta hacen que sea más fácil de codificar, pero al mismo tiempo dificultan la compilación (en referencia al tiempo necesario para la compilación).
• Lento en la ejecución: los programas de Python son generalmente más lentos en comparación con Java. Python está prácticamente descartado en el inicio debido a su alto tiempo de ejecución.
• Python no está permitido en todas partes: Python no está permitido en concursos en varios portales de programación competitivos populares en línea.
Ahora nos quedamos principalmente con Java, C, C ++, ahora aquí se hace difícil comparar y depende principalmente del usuario, aquí se presentan los puntos buenos y malos de cada uno de ellos.
Java
• STL vs contenedores: STL en C ++ está muy bien diseñado, mientras que algunas personas aman Java Containers más que nada. Hay pocas situaciones en las que STL no tiene una solución directa. Por ejemplo, priority_queue en STL no admite la operación de tecla de disminución que se requiere para las implementaciones del algoritmo de ruta más corto de Dijkstra y el algoritmo de Prim
• El manejo de excepciones en Java es incomparable: el código Java proporciona un manejo de excepciones más fuerte en comparación con C ++. Por ejemplo, es más fácil rastrear una excepción ArrayIndexOutOfBound o una falla de segmentación en Java. C ++ / C puede darle respuestas incorrectas, pero Java es seguramente confiable en este contexto.
• El límite de tiempo excede: es posible que obtenga TLE debido a que Java es un poco más lento en el lado del límite de tiempo
• Grandes enteros y expresiones regulares: Java tiene algunas pocas ventajas con respecto a los concursos de programación. Biginteger, Expresiones regulares y biblioteca de geometría son algunas de ellas.
C++ y C 
• La velocidad de C ++ es comparable a C: muchos programas de C también son programas de C ++ válidos, y dichos programas de C se ejecutan a una velocidad idéntica cuando se compilan
• C ++ no fuerza la programación orientada a objetos: el lenguaje C ++ contiene algunas extensiones de lenguaje que facilitan la programación orientada a objetos y C ++ no fuerza el diseño orientado a objetos en ninguna parte, simplemente lo permite.

• Una biblioteca estándar más grande: C ++ permite el uso completo de la biblioteca estándar C, así como C ++ incluye sus propias bibliotecas, incluida la Biblioteca de plantillas estándar. El STL contiene una serie de plantillas útiles, como la rutina de ordenamiento anterior. Incluye útiles estructuras de datos comunes como listas, mapas, conjuntos, etc. Al igual que la rutina de ordenamiento, las otras rutinas STL y estructuras de datos están &quot;adaptadas&quot; a las necesidades específicas que tiene el programador; todo lo que el programador tiene que hacer es completar los tipos.
Por ejemplo, si necesitamos implementar Binary Search para un problema, tendremos que escribir nuestra propia función, mientras que en C ++ Binary Search, la rutina STL se define como
• binary_search (startaddress, endaddress, valuetofind)
C ++ vs Java
• Los códigos Java son más largos, un programador necesita escribir más cuando programa en Java
• Java es detallado: en C ++, Entrada Salida es más simple simplemente escribiendo scanf / printf. En Java,  a veces se necesita la clase BufferedReader, tediosa de programar.
• C ++ STL vs Java Containers: a la mayoría de los programadores les resulta más fácil usar STL.
• C ++ es más popular: ya sea el año de origen o la comodidad de uso, pero C ++ destaca a Java en términos de cantidad de usuarios que usan el lenguaje.
• C ++ ahorra tiempo: es un hecho bien conocido que Java es más lento que C ++. Generalmente necesitamos compilar y ejecutar programas muchas veces para probarlos. Lleva relativamente menos tiempo en C ++. 
En resumen, C ++ es hasta la fecha el lenguaje más preferido seguido de Java cuando se trata de concursos de programación, pero siempre debe elegir un idioma con el que se sienta cómodo. Tener confianza en cualquier idioma es lo más importante. Nunca elija un idioma que haya &quot;aprendido&quot; recientemente o con el cual tenga poca experiencia, ya que será difícil expresarse en ese idioma.
</texto>
  <complejidad_tiempo>null</complejidad_tiempo>
  <java>null</java>
  <cpp>null</cpp>
  <py>null</py>
  <orden>0</orden>
  <suborden>99</suborden>
  <fecha_creacion>2020-12-06 20:56:42</fecha_creacion>
  <fecha_modificacion>2020-12-06 20:59:24</fecha_modificacion>
</row>
<row>
  <ID>268</ID>
  <supergrupo>Teoria</supergrupo>
  <tema>¿Cómo llegar a ser un maestro en programación competitiva?</tema>
  <texto>Las competencias de programación a nivel internacional son desarrolladas para medir la capacidad de los estudiantes de programación de las distintas universidades y entes estudiantiles, entre ellas se permite utilizar todo tipo de medios escritos en los cuales basarse para el desarrollo de diferentes soluciones a problemas de la vida real que requieren un algoritmo eficiente.
Grandes empresas de desarrollo como Google, Microsoft, IBM entre otras utilizan estas competencias como principal medio de reclutamiento de personal, por lo que se hace evidente la necesidad de participación en ellas.
Hay muchas personas para quienes la programación es como un sueño embrujado. La programación no es más que un arte de hablar con las máquinas y decirles qué hacer, cuándo hacerlo y por qué hacerlo. La mayoría de los estudiantes escuchan esta palabra en el colegio. Para muchos de ellos, la programación comienza con &quot;C&quot; y termina en &quot;C&quot;. 
La programación competitiva es una forma avanzada de programación que se ocupa de problemas del mundo real. Aquí vemos nuestro código gobernando el mundo. Pero escribir dicho código requiere destreza con pasión.
Se tiene claro que un código es básicamente nuestra lógica detrás de cualquier problema en lenguaje de alto nivel. Pero la lógica por sí sola no es suficiente para escribir un código perfecto. Requiere una comprensión más profunda de términos técnicos como complejidad, sintaxis y el arte de crear grandes soluciones a través de los códigos más cortos posibles. Todo esto solo se puede lograr a través de la práctica. Pero si la práctica se fusiona con una buena guía, se puede llegar al dominio. Este objetivo se puede lograr a través de los siguientes pasos: 
1. Obtenga una comprensión profunda
En primer lugar, estudie todos los conceptos del lenguaje de programación profundamente. Siempre use libros estándar. Hoy en día, hay muchas plataformas en línea disponibles donde los competidores de todo el mundo comparten sus conocimientos e intentan facilitar los conceptos.
2. Seguir un enfoque jerárquico
Intente comenzar a codificar utilizando problemas más simples. Antes de escribir directamente el código, primero haga un diagrama de flujo de la lógica que se está utilizando. Esto aumentará la cantidad de códigos correctos que no solo agudizarán tus habilidades sino que también aumentarán tu confianza.
3. Implementación en la vida real
Una vez que se acostumbre a los códigos y la programación básica, intente crear códigos que resuelvan tus problemas de la vida diaria. Estos pueden incluir la libreta de calificaciones de cualquier estudiante, el sistema de reserva de boletos, el sistema de administración de la biblioteca, etc. De esta manera obtendrá confianza.
4. Simplificar el código
Ahora el siguiente paso es acortar el código. Suponga que crea un código simple para el sistema de administración de una biblioteca. Ahora intente abreviarlo de tal manera que la misma tarea se pueda lograr de una manera mucho más simple y más corta. Primero puede ver el problema y crear su propio código. Ahora vea la solución óptima para aprender cómo se puede reducir. Esta es la fase más importante y la transición de la programación básica a la programación competitiva.
5. No se rinda, láncese a los leones
Ahora comience a participar en competencias de codificación. Las competiciones pueden ser en su escuela, en línea o a nivel nacional. Aquí encontrara personas igual que usted compitiendo y retándose unos con otros. Aquí, debe escribir la solución óptima y eso también en el menor tiempo posible. Obviamente, dado que es una competencia, es la supervivencia del más apto. Un entorno competitivo amistoso hace que la tasa de aprendizaje sea más rápida e implica aprender mediante un mecanismo divertido. Además de esto, también obtendrá una calificación de acuerdo con sus presentaciones exitosas del código y las competiciones que gane, lo que mejora su perfil profesional.
6. Comience a difundir su conocimiento
Una vez que se convierta en un maratonista, no se guarde los conocimientos. Extiéndalos. Compártalos con sus estudiantes o aprendices, sus compañeros y a través del mundo. Su conocimiento aumenta más si lo comparte con otros.
</texto>
  <complejidad_tiempo>null</complejidad_tiempo>
  <java>null</java>
  <cpp>null</cpp>
  <py>null</py>
  <orden>0</orden>
  <suborden>99</suborden>
  <fecha_creacion>2020-12-06 20:56:42</fecha_creacion>
  <fecha_modificacion>2020-12-06 20:59:24</fecha_modificacion>
</row>
<row>
  <ID>269</ID>
  <supergrupo>Teoria</supergrupo>
  <tema>Operadores matemáticos, lógicos y comparativos</tema>
  <texto>¿Qué es un operador lógico?
Los operadores lógicos, utilizados en Informática, lógica proposicional y álgebra booleana, entre otras disciplinas, nos proporcionan un resultado a partir de que se cumpla o no una cierta condición, producen un resultado booleano, y sus operandos son también valores lógicos o asimilables a ellos (los valores numéricos son asimilados a verdadero o falso según su valor sea cero o distinto de cero). Esto genera una serie de valores que, en los casos más sencillos, pueden ser parametrizados con los valores numéricos 0 y 1. La combinación de dos o más operadores lógicos conforma una función lógica.
Los operadores lógicos son tres, dos de ellos son binarios, el último (negación) es unario. Tienen una doble posibilidad de representación depende el lenguaje: 
- &quot;Y&quot; lógico -&gt; &amp;&amp; -&gt; AND
- &quot;O&quot; lógico -&gt; || -&gt; OR
- Negación lógica  -&gt; ! -&gt; NOT
Las expresiones conectadas con los operadores &amp;&amp; y || se evalúan de izquierda a derecha, y la evaluación se detiene tan pronto como el resultado verdadero o falso es conocido.
¿Qué es una operación matemática?
Una operación matemática es un proceso mediante el cual se logra la transformación de una o más cantidades en otra cantidad llamada resultado.
Toda operación matemática tiene unos valores de entrada, y presenta una regla de definición que señala el tipo de proceso que se debe realizar para llegar al resultado.
Junto con los valores de entrada se coloca un símbolo que se denomina operador matemático.
Hay operaciones matemáticas que nos son muy conocidas, cuyos operadores también lo son: por ejemplo, el + que señala una suma, la rayita   ?  que indica una resta, y los operadores de multiplicación *, división / y residuo %.
¿Qué es un operador comparativo?
Los operadores de comparación comparan dos expresiones y devuelven un valor booleano que representa la relación de sus valores. Existen operadores para comparar valores numéricos, operadores para comparar cadenas y operadores para comparar objetos.
</texto>
  <complejidad_tiempo>null</complejidad_tiempo>
  <java>null</java>
  <cpp>null</cpp>
  <py>null</py>
  <orden>0</orden>
  <suborden>99</suborden>
  <fecha_creacion>2020-12-06 20:56:42</fecha_creacion>
  <fecha_modificacion>2020-12-06 20:59:24</fecha_modificacion>
</row>
<row>
  <ID>270</ID>
  <supergrupo>Teoria</supergrupo>
  <tema>Tipos de variables básicas</tema>
  <texto>En programación, las variables son espacios reservados en la memoria que, como su nombre indica, pueden cambiar de contenido a lo largo de la ejecución de un programa. Una variable corresponde a un área reservada en la memoria principal del ordenador.
Por buenas prácticas, el identificador de la variable (Nombre de la variable) debe ser mnemotécnico, es decir que debe reflejar el uso dentro del programa de la misma.
El tipo de dato informático es un atributo de una parte de los datos que indica al ordenador (y al programador) algo sobre la clase de datos sobre los que se va a procesar. Esto incluye imponer restricciones en los datos, como qué valores pueden tomar y qué operaciones se pueden realizar. Tipos de datos comunes son: enteros, cadenas alfanuméricas, fechas, horas, colores, coches o cualquier cosa que se nos ocurra. Por ejemplo, el tipo &quot;int&quot; representa un conjunto de enteros. Éste es un concepto propio de la informática, más específicamente de los lenguajes de programación, aunque también se encuentra relacionado con nociones similares de las matemáticas y la lógica.
Debido a que las variables contienen o apuntan a valores de tipos determinados, las operaciones sobre las mismas y el dominio de sus propios valores están determinadas por el tipo de datos en cuestión.
Tipo de dato lógico:
El tipo de dato lógico o booleano es en computación aquel que puede representar valores de lógica binaria, esto es 2 valores, que normalmente representan falso o verdadero. Se utiliza normalmente en la programación, estadística, electrónica, matemáticas (álgebra booleana) y otras.
Tipo de dato entero:
El tipo de dato entero en computación se usa para representar un subconjunto finito de los números enteros. El mayor número que se puede representar depende del tamaño del espacio usado por el dato y la posibilidad (o no) de representar números negativos. Los tipos de dato entero disponibles y su tamaño dependen del lenguaje de programación usado así como la arquitectura en cuestión.
Tipo de dato carácter:
En terminología informática y de telecomunicaciones, un carácter es un símbolo que representa cada carácter de un lenguaje natural. Un ejemplo de carácter es una letra, un número o un signo de puntuación.
Cadena de caracteres:
En programación, una cadena de caracteres o frase (string en inglés) es una secuencia ordenada de longitud arbitraria (aunque finita) de elementos que pertenecen a un cierto alfabeto. En general, una cadena de caracteres es una sucesión de caracteres (letras, números u otros signos o símbolos).
Desde el punto de vista de la programación, si no se ponen restricciones al alfabeto, una cadena podrá estar formada por cualquier combinación finita de todo el juego de caracteres disponibles (las letras de la &#39;a&#39; a la &#39;z&#39; y de la &#39;A&#39; a la &#39;Z&#39;, los números del &#39;0&#39; al &#39;9&#39;, el espacio en blanco &#39; &#39;, símbolos diversos &#39;!&#39;, &#39;@&#39;, &#39;%&#39;, entre otros). Un caso especial de cadena es la que contiene cero caracteres, a esta cadena se le llama cadena vacía.
</texto>
  <complejidad_tiempo>null</complejidad_tiempo>
  <java>null</java>
  <cpp>null</cpp>
  <py>null</py>
  <orden>0</orden>
  <suborden>99</suborden>
  <fecha_creacion>2020-12-06 20:56:43</fecha_creacion>
  <fecha_modificacion>2020-12-06 20:59:24</fecha_modificacion>
</row>
<row>
  <ID>271</ID>
  <supergrupo>Teoria</supergrupo>
  <tema>Lectura e impresión</tema>
  <texto>Las lecturas e impresiones de nuestros ejercicios de programación competitiva, sus algoritmos base y sus modificaciones se realizan por la consola (STDIN, STDOUT), por lo que por lo general la programación de entornos gráficos para nuestros códigos no es válida, los siguientes códigos muestran ejemplos de cómo se realizan las entradas y salidas de diferentes tipos de variables.</texto>
  <complejidad_tiempo>Ejemplo de entrada
6555
73653736353
463553
345543234
a
holamundo
101
</complejidad_tiempo>
  <java>import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.Scanner;

public class LecturaEscritura {
    //Variables Globales
    static int numeroentero;
    static long numeroenterolargo;
    static float numerodecimal;
    static double numerodecimallargo;
    static char caracter;
    static String cadena;
    static byte bits;

    public static void main(String[] args) throws IOException {
        System.out.println(&quot;Lectura\n&quot;);
        lecturaLenta();
        lecturaRapida();
        System.out.println(&quot;&quot;);
        System.out.println(&quot;Impresión \n&quot;);
        impresionNormal();
        impresionConFormato();
    }

    static void lecturaLenta() {
        //Objeto lector
        Scanner sc = new Scanner(System.in);
        //Lectura con tipo especificado
        numeroentero = sc.nextInt();
        numeroenterolargo = sc.nextLong();
        numerodecimal = sc.nextFloat();
        numerodecimallargo = sc.nextDouble();
        caracter = sc.next().charAt(0);
        cadena = sc.next();
        bits = sc.nextByte();
    }
    static void lecturaRapida() throws IOException {
        //Objeto lector
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        //Lectura como cadena y conversión a tipo
        numeroentero = Integer.parseInt(br.readLine());
        numeroenterolargo = Long.parseLong(br.readLine());
        numerodecimal = Float.parseFloat(br.readLine());
        numerodecimallargo = Double.parseDouble(br.readLine());
        caracter = br.readLine().charAt(0);
        cadena = br.readLine();
        bits = Byte.parseByte(br.readLine());
    }

    static void impresionNormal() {
        System.out.println(numeroentero);
        System.out.println(numeroenterolargo);
        System.out.println(numerodecimal);
        System.out.println(numerodecimallargo);
        System.out.println(caracter);
        System.out.println(cadena);
        System.out.println(bits);
    }

    static void impresionConFormato() {
        //Se especifica el tipo de dato o la forma en que se imprimira
        System.out.printf(&quot;%d \n&quot;, numeroentero);
        System.out.printf(&quot;%d \n&quot;, numeroenterolargo);
        System.out.printf(&quot;%f \n&quot;, numerodecimal);
        System.out.printf(&quot;%e \n&quot;, numerodecimal);
        System.out.printf(&quot;%f \n&quot;, numerodecimallargo);
        System.out.printf(&quot;%e \n&quot;, numerodecimallargo);
        System.out.printf(&quot;%s \n&quot;, caracter);
        System.out.printf(&quot;%s \n&quot;, cadena);
        System.out.printf(&quot;%s \n&quot;, bits);
    }
}
</java>
  <cpp>//Unicas 2 librerias que se usan en c++ (Contienen todas)
#include&lt;bits/stdc++.h&gt;
#include&lt;cstdlib&gt;
using namespace std;
//variables globales
int numeroentero;
long numeroenterolargo;
float numerodecimal;
double numerodecimallargo;
char caracter;
string cadena;

void lecturaLenta() {
        //Lectura con tipo especificado
        cin&gt;&gt;numeroentero;
        cin&gt;&gt;numeroenterolargo;
        cin&gt;&gt;numerodecimal;
        cin&gt;&gt;numerodecimallargo;
        cin&gt;&gt;caracter;
        cin&gt;&gt;cadena;
}
void lecturaRapida() {
        //Lectura como cadena y conversión a tipo (En c++ &amp; es necesario)
        scanf(&quot;%d&quot;,&amp;numeroentero);
        scanf(&quot;%lld&quot;,&amp;numeroenterolargo);
        scanf(&quot;%f&quot;,&amp;numerodecimal);
        scanf(&quot;%lf&quot;,&amp;numerodecimallargo);
        scanf(&quot;%s&quot;,&amp;caracter);
        scanf(&quot;%s&quot;,cadena.c_str());
}
void impresionNormal() {
        cout&lt;&lt;numeroentero&lt;&lt;endl;
        cout&lt;&lt;numeroenterolargo&lt;&lt;endl;
        cout&lt;&lt;numerodecimal&lt;&lt;endl;
        cout&lt;&lt;numerodecimallargo&lt;&lt;endl;
        cout&lt;&lt;caracter&lt;&lt;endl;
        cout&lt;&lt;cadena&lt;&lt;endl;
}
 void impresionConFormato() {
        //Se especifica el tipo de dato o la forma en que se imprimira
        printf(&quot;%d \n&quot;,numeroentero);
        printf(&quot;%lld \n&quot;,numeroenterolargo);
        printf(&quot;%f \n&quot;,numerodecimal);
        printf(&quot;%e \n&quot;,numerodecimal);
        printf(&quot;%lf \n&quot;,numerodecimallargo);
        printf(&quot;%e \n&quot;,numerodecimallargo);
        printf(&quot;%c \n&quot;,caracter);
        printf(&quot;%s \n&quot;,cadena.c_str());
}
        
int main (int argc, char *argv[]) {
        cout&lt;&lt;&quot;Lectura\n&quot;&lt;&lt;endl;
        lecturaLenta();
        cout&lt;&lt;&quot;Impresión \n&quot;&lt;&lt;endl;
        impresionNormal();
        cout&lt;&lt;endl;
        cout&lt;&lt;&quot;Lectura\n&quot;&lt;&lt;endl;
        lecturaRapida();
        cout&lt;&lt;&quot;Impresión \n&quot;&lt;&lt;endl;
        impresionConFormato();
        return 0;
}     
</cpp>
  <py>#Los comentarios en Python se usa el # (Numeral)
#variables globales
#la identación define el orden
numeroentero = int(0)
numeroenterolargo = int(0)
numerodecimal = float(0)
numerodecimallargo = float(0)
caracter = &#39;&#39;
cadena = &quot;&quot;
print(&quot;Lectura&quot;)
#Lectura con tipo especificado
numeroentero = int(input())
numeroenterolargo = int(input())
numerodecimal = float(input())
numerodecimallargo = float(input())
caracter = input()
cadena = str(input())
print(&quot;Impresión&quot;)
print(numeroentero)
print(numeroenterolargo)
print(numerodecimal)
print(numerodecimallargo)
print(caracter)
print(cadena)
print(&quot;Impresión formateada&quot;)
#Se especifica el tipo de dato o la forma en que se imprimira
#obligatorio usar el % 
print(&quot;%d&quot; % numeroentero)
print(&quot;%d&quot; % numeroenterolargo)
print(&quot;%f&quot; % numerodecimal)
print(&quot;%e&quot; % numerodecimal)
print(&quot;%f&quot; % numerodecimallargo)
print(&quot;%e&quot; % numerodecimallargo)
print(&quot;%c&quot; % caracter)
print(&quot;%s&quot; % cadena)
</py>
  <orden>0</orden>
  <suborden>99</suborden>
  <fecha_creacion>2020-12-06 20:56:43</fecha_creacion>
  <fecha_modificacion>2020-12-06 20:59:24</fecha_modificacion>
</row>
<row>
  <ID>272</ID>
  <supergrupo>Teoria</supergrupo>
  <tema>Condicionales y ciclos</tema>
  <texto>Un condicional, como su nombre lo indica, es una condición para discernir entre una opción u otra, y en el proceso mental normalmente se manifiesta con un “Si”; por ejemplo: Si va a llover, coja el paraguas. Sintácticamente, IF es la palabra reservada para desencadenar el poder de los condicionales en el código. ELSE expresa “en el caso contrario”. Siguiendo con el ejemplo anterior de la lluvia: if va a llover coja el paraguas else coja el vestido de baño.

Un bucle o ciclo, en programación, es una secuencia que ejecuta repetidas veces un trozo de código, hasta que la condición asignada a dicho bucle deja de cumplirse. Los tres bucles más utilizados en programación son el bucle while, el bucle for y el bucle do-while.
</texto>
  <complejidad_tiempo>Ejemplo de entrada
5
</complejidad_tiempo>
  <java>import java.util.Scanner;

public class CondicionalesCiclos {

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        //Lectura 
        int numero = sc.nextInt();
        //Estructura de un condicional
        //Dentro el parentesis va la condicion a revisar
        //Si se cumple se realiza las siguientes lineas
        //En caso contrario pasa al else 
        //y se realiza las lineas siguientes del else
        if (numero % 2 == 0) {
            System.out.println(&quot;Es par&quot;);
        } else {
            System.out.println(&quot;Es impar&quot;);
        }
        System.out.println(&quot;&quot;);
        System.out.println(&quot;Ciclo for &quot;);
        // variable iteradora, condicion , acumulador
        for (int i = 0; i &lt; 10; i++) {
            System.out.println(i);
        }
        System.out.println(&quot;Ciclo while&quot;);
        //Variable, condicion, al final acumulador
        int acumulador = 0;
        while (acumulador &lt; 10) {
            System.out.println(acumulador);
            acumulador++;

        }
        System.out.println(&quot;Ciclo do while&quot;);
        //Haga hasta que una condición se cumpla
        acumulador = 0;
        do {
            System.out.println(acumulador);
            acumulador++;
        } while (acumulador &lt; 10);
        System.out.println(&quot;Ciclo for each&quot;);
        //Iterar entre todos los elementos que tenga una estructura
        //Sin importar el tamaño 
        int numeros[] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 0};
        for (int o : numeros) {
            System.out.println(o);
        }

    }

}
</java>
  <cpp>#include&lt;bits/stdc++.h&gt;
#include&lt;cstdlib&gt;
using namespace std;

int main(int argc, char *argv[]) {
    int número;
    cin&gt;&gt;número;
    //Estructura de un condicional
    //Dentro el parentesis va la condicion a revisar
    //Si se cumple se realiza las siguientes lineas
    //En caso contrario pasa al else 
    //y se realiza las lineas siguientes del else
    if (número % 2 == 0) {
        cout &lt;&lt; &quot;Es par&quot; &lt;&lt; endl;
    } else {
        cout &lt;&lt; &quot;Es impar&quot; &lt;&lt; endl;
    }
    cout &lt;&lt; endl;
    cout &lt;&lt; &quot;Ciclo for &quot; &lt;&lt; endl;
    // variable iteradora, condicion , acumulador
    for (int i = 0; i &lt; 10; i++) {
        cout &lt;&lt; i &lt;&lt; endl;
    }
    cout &lt;&lt; &quot;Ciclo while&quot; &lt;&lt; endl;
    //Variable, condicion, al final acumulador
    int acumulador = 0;
    while (acumulador &lt; 10) {
        cout &lt;&lt; acumulador &lt;&lt; endl;
        acumulador++;
    }
    cout &lt;&lt; &quot;Ciclo do while&quot; &lt;&lt; endl;
    //Haga hasta que una condición se cumpla
    acumulador = 0;
    do {
        cout &lt;&lt; acumulador &lt;&lt; endl;
        acumulador++;
    } while (acumulador &lt; 10);
    cout &lt;&lt; &quot;Ciclo for each&quot; &lt;&lt; endl;
    //Iterar entre todos los elementos que tenga una estructura
    //Sin importar el tamaño 
    int números[] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 0};
    for (int o : números) {
        cout &lt;&lt; o &lt;&lt; endl;
    }
    return 0;
}
</cpp>
  <py>numero = 0;
numero = int(input())
#Estructura de un condicional
#Dentro el parentesis va la condicion a revisar
#Si se cumple se realiza las siguientes lineas
#En caso contrario pasa al else 
#y se realiza las lineas siguientes del else
if (numero % 2 == 0):
    print(&quot;Es par&quot;)
else: 
    print(&quot;Es impar&quot;)
print(&quot;Ciclo for &quot;)
#variable iteradora, rango inicio,final
for i in range (0, 10):
    print(i)
print(&quot;Ciclo while&quot;)
#Variable, condicion, al final acumulador
acumulador = 0;
while (acumulador &lt; 10):
    print(acumulador)
    acumulador = acumulador + 1;
print(&quot;Ciclo for each&quot;)
#Iterar entre todos los elementos que tenga una estructura
#Sin importar el tamaño 
numeros = [1, 2, 3, 4, 5, 6, 7, 8, 9, 0]
for o in numeros:
    print(o)
</py>
  <orden>0</orden>
  <suborden>99</suborden>
  <fecha_creacion>2020-12-06 20:56:43</fecha_creacion>
  <fecha_modificacion>2020-12-06 20:59:24</fecha_modificacion>
</row>
<row>
  <ID>273</ID>
  <supergrupo>Teoria</supergrupo>
  <tema>Conversiones, parseos, y casteos de variables</tema>
  <texto>El casting consiste en la conversión de tipos de datos similares (compatibles) entre sí, generalmente a través de la herencia.
Por otra parte, el parsing consiste en analizar el formato de una sentencia de texto, y obtener información si el formato es correcto.
</texto>
  <complejidad_tiempo>null</complejidad_tiempo>
  <java>import java.math.BigDecimal;
import java.math.BigInteger;

public class Main {

    public static void main(String[] args) {
        int enteropequenio = 5;
        long enterogrande = 100L;
        float decimalpequenio = 3.4f;
        double decimalgrande = 3.4;
        String cadena = &quot;125&quot;;
        char numerosolitario = &#39;7&#39;;
        boolean booleano = true;
        // conversión a string
        System.out.println(&quot;------------A String----------&quot;);
        System.out.println(Integer.toString(enteropequenio));
        System.out.println(Long.toString(enterogrande));
        System.out.println(Float.toString(decimalpequenio));
        System.out.println(Double.toString(decimalgrande));
        System.out.println(Character.toString(numerosolitario));
        System.out.println(Boolean.toString(booleano));
        // parseo de string a entero
        System.out.println(&quot;------------A números----------&quot;);
        int basedeentrada = 10;
        System.out.println(Integer.parseInt(cadena, basedeentrada));
        System.out.println(Long.parseLong(cadena, basedeentrada));
        System.out.println(Float.parseFloat(cadena));
        System.out.println(Double.parseDouble(cadena));
        System.out.println(Character.valueOf(cadena.charAt(0)));
        System.out.println(Boolean.parseBoolean(&quot;true&quot;));
        // casteo a entero
        System.out.println(&quot;------------A int----------&quot;);
        System.out.println((int) enterogrande);
        System.out.println((int) decimalpequenio);
        System.out.println((int) decimalgrande);
        System.out.println((int) numerosolitario);
        System.out.println((int) (booleano ? 1 : 0));
        //casteo a long
        System.out.println(&quot;------------A long----------&quot;);
        System.out.println((long) enteropequenio);
        System.out.println((long) decimalpequenio);
        System.out.println((long) decimalgrande);
        System.out.println((long) numerosolitario);
        System.out.println((long) (booleano ? 1 : 0));
        // casteo a float
        System.out.println(&quot;------------A float----------&quot;);
        System.out.println((float) enteropequenio);
        System.out.println((float) enterogrande);
        System.out.println((float) decimalgrande);
        System.out.println((float) numerosolitario);
        System.out.println((float) (booleano ? 1 : 0));
        // casteo a double
        System.out.println(&quot;------------A double----------&quot;);
        System.out.println((double) enteropequenio);
        System.out.println((double) enterogrande);
        System.out.println((double) decimalpequenio);
        System.out.println((double) numerosolitario);
        System.out.println((double) (booleano ? 1 : 0));
        // casteo a char 
        System.out.println(&quot;------------A char----------&quot;);
        System.out.println((char) enteropequenio);
        System.out.println((char) enterogrande);
        System.out.println((char) decimalpequenio);
        System.out.println((char) numerosolitario);
        System.out.println((char) (booleano ? 1 : 0));
        //biginteger y big decimal (SOLO JAVA)
        System.out.println(&quot;------------bigdecimal y big integer----------&quot;);
        BigInteger numeroenorme = new BigInteger(cadena);
        //mientras quepa en la variable
        int cambio = numeroenorme.intValue();
        BigDecimal decimalenorme = new BigDecimal(cadena);
        //mientras quepa en la variable
        double cambio2 = decimalenorme.doubleValue();
        System.out.println(cambio);
        System.out.println(cambio2);
    }
}
</java>
  <cpp>#include&lt;bits/stdc++.h&gt;
using namespace std;
typedef long long int ll;

int main() {
    int enteropequenio = 5;
    ll enterogrande = 100LL;
    float decimalpequenio = 3.4f;
    double decimalgrande = 3.4;
    string cadena = &quot;125&quot;;
    char numerosolitario = &#39;7&#39;;
    bool booleano = true;
    string cast;
    // conversión a string
    printf(&quot;------------A String----------\n&quot;);
    cast.push_back(numerosolitario);
    printf(&quot;%s\n&quot;, to_string(enteropequenio).c_str());
    printf(&quot;%s\n&quot;, to_string(enterogrande).c_str());
    printf(&quot;%s\n&quot;, to_string(decimalpequenio).c_str());
    printf(&quot;%s\n&quot;, to_string(decimalgrande).c_str());
    printf(&quot;%s\n&quot;, cast.c_str());
    printf(&quot;%s\n&quot;, to_string(booleano).c_str());
    printf(&quot;------------A Numero----------\n&quot;);
    printf(&quot;%d\n&quot;, stoi(cadena));
    printf(&quot;%lld\n&quot;, stoll(cadena));
    printf(&quot;%f\n&quot;, stof(cadena));
    printf(&quot;%f\n&quot;, stof(cadena));
    printf(&quot;%c\n&quot;, (cadena[0]));
    printf(&quot;%d\n&quot;, stoi(to_string(booleano).c_str()));
    printf(&quot;------------A int----------\n&quot;);
    printf(&quot;%d\n&quot;, (int) enterogrande);
    printf(&quot;%d\n&quot;, (int) decimalpequenio);
    printf(&quot;%d\n&quot;, (int) decimalgrande);
    printf(&quot;%d\n&quot;, (int) numerosolitario);
    printf(&quot;%d\n&quot;, (int) (booleano ? 1 : 0));
    printf(&quot;------------A Long----------\n&quot;);
    printf(&quot;%lld\n&quot;, (ll) enteropequenio);
    printf(&quot;%lld\n&quot;, (ll) decimalpequenio);
    printf(&quot;%lld\n&quot;, (ll) decimalgrande);
    printf(&quot;%lld\n&quot;, (ll) numerosolitario);
    printf(&quot;%lld\n&quot;, (ll) (booleano ? 1 : 0));
    printf(&quot;------------A Float----------\n&quot;);
    printf(&quot;%f\n&quot;, (float) enteropequenio);
    printf(&quot;%f\n&quot;, (float) enteropequenio);
    printf(&quot;%f\n&quot;, (float) decimalgrande);
    printf(&quot;%f\n&quot;, (float) numerosolitario);
    printf(&quot;%f\n&quot;, (float) (booleano ? 1 : 0));
    // casteo a char
    printf(&quot;------------A char----------\n&quot;);
    printf(&quot;%c\n&quot;, (char) enteropequenio);
    printf(&quot;%c\n&quot;, (char) enterogrande);
    printf(&quot;%c\n&quot;, (char) decimalpequenio);
    printf(&quot;%c\n&quot;, (char) numerosolitario);
    printf(&quot;%c\n&quot;, (char) (booleano ? 1 : 0));
}
</cpp>
  <py>entero = 5
decimal = 3.4
cadena = &#39;125&#39;
numsolitario = &#39;7&#39;
booleano = True


# Conversion a Cadena
print(&#39;-------------- A String -------------&#39;)
print(str(entero))
print(str(decimal))
print(str(numsolitario))
print(str(booleano))

# Conversion Cadena a Numero
print(&#39;---------- Cadena a Numero ----------&#39;)
print(int(cadena))
print(int(cadena[0]))
print(float(cadena))
print(bool(booleano))

# Conversion a Entero
print(&#39;--------------- A Int ---------------&#39;)
print(int(decimal))
print(ord(numsolitario))
print(int(booleano))

# Conversion a Decimal
print(&#39;-------------- A Float --------------&#39;)
print(float(entero))
print(float(cadena))
print(float(numsolitario))
print(float(booleano))

# Conversion a Caracter
print(&#39;-------------- A Char ---------------&#39;)
print(chr(65))
print(chr(100))
</py>
  <orden>0</orden>
  <suborden>99</suborden>
  <fecha_creacion>2020-12-06 20:56:44</fecha_creacion>
  <fecha_modificacion>2020-12-06 20:59:24</fecha_modificacion>
</row>
<row>
  <ID>274</ID>
  <supergrupo>Teoria</supergrupo>
  <tema>String Matching y expresiones regulares</tema>
  <texto>Una expresión regular, o expresión racional, es una secuencia de caracteres que conforma un patrón de búsqueda. También son conocidas como regex por su contracción de las palabras inglesas regular expression. Son principalmente utilizadas para la búsqueda de patrones de cadenas de caracteres u operaciones de sustituciones.
Lógicos: 
• x|y: x o y
• xy: x seguido de y
• (): Agrupación 
Intervalos de caracteres:
• [abc]: Cualquiera de los caracteres entre corchetes. Pueden especificarse rangos, por ejemplo ([a-d] que equivale a [abcd]).
• [^abc]: Cualquier carácter que no esté entre los corchetes.
• [a-zA-Z]: a a la z o A a la Z (Rango).
• [a-z&amp;&amp;[def]]: d,e, o f (Intersección)
• [a-b&amp;&amp;[^bc]]: (Substracción)
Intervalos de caracteres predefinidos:
• .: Cualquier carácter individual, salvo el de salto de línea
• \d: Cualquier carácter de digito, equivalente a [0-9]
• \D: Cualquier carácter que no sea del digito, equivalente a [^0-9]
• \s: Cualquier carácter individual de espacio en blanco (Espacios, tabulaciones, saltos de página o saltos de línea)
• \S: Cualquier carácter individual que no sea un espacio en blanco
• \w: Cualquier carácter alfanumérico
• \W: Cualquier carácter que no sea alfanumérico
</texto>
  <complejidad_tiempo>null</complejidad_tiempo>
  <java>null</java>
  <cpp>null</cpp>
  <py>null</py>
  <orden>0</orden>
  <suborden>99</suborden>
  <fecha_creacion>2020-12-06 20:56:44</fecha_creacion>
  <fecha_modificacion>2020-12-06 20:59:24</fecha_modificacion>
</row>
<row>
  <ID>275</ID>
  <supergrupo>Teoria</supergrupo>
  <tema>Lectura especializada y alta velocidad de procesamiento</tema>
  <texto>Existen ejercicios dentro de programación competitiva en los cuales la cantidad de entradas es tan grande que usar los medios convencionales de lectura el algoritmo no es lo suficientemente rápido, retornando un Time Limit Exceeded (Tiempo límite excedido), es decir la solución no se encuentra lo suficientemente optimizada o no es lo suficientemente rápida, en este capítulo presentamos nuevas formas de lectura y procesamiento de entradas que pueden ayudarnos a resolver este problema.</texto>
  <complejidad_tiempo>null</complejidad_tiempo>
  <java>JAVA Fast Reader
// FastReader (Lectura rapida con tokenizer)
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.StringTokenizer;

public class Main {

    static class FastReader {

        BufferedReader br;
        StringTokenizer st;

        public FastReader() {
            br = new BufferedReader(new InputStreamReader(System.in));
        }

        String next() {
            while (st == null || !st.hasMoreElements()) {
                try {
                    st = new StringTokenizer(br.readLine());
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
            return st.nextToken();
        }

        int nextInt() {
            return Integer.parseInt(next());
        }

        long nextLong() {
            return Long.parseLong(next());
        }

        double nextDouble() {
            return Double.parseDouble(next());
        }

        String nextLine() {
            String str = &quot;&quot;;
            try {
                str = br.readLine();
            } catch (IOException e) {
                e.printStackTrace();
            }
            return str;
        }
    }

    public static void main(String[] args) {
        FastReader s = new FastReader();
        int n = s.nextInt();
        int k = s.nextInt();
        int count = 0;
        while (n-- &gt; 0) {
            int x = s.nextInt();
            if (x % k == 0) {
                count++;
            }
        }
        System.out.println(count);
    }
}
JAVA UltraReader
(Puede fallar en algunos juzgadores)
// UltraReader (Lectura ultra rapida usando streams y buffers)

import java.io.DataInputStream;
import java.io.FileInputStream;
import java.io.IOException;

public class Main {

    static class UltraReader {

        final private int BUFFER_SIZE = 1 &lt;&lt; 16;
        private DataInputStream din;
        private byte[] buffer;
        private int bufferPointer, bytesRead;

        public UltraReader() {
            din = new DataInputStream(System.in);
            buffer = new byte[BUFFER_SIZE];
            bufferPointer = bytesRead = 0;
        }

        public UltraReader(String file_name) throws IOException {
            din = new DataInputStream(new FileInputStream(file_name));
            buffer = new byte[BUFFER_SIZE];
            bufferPointer = bytesRead = 0;
        }

        public String readLine() throws IOException {
            byte[] buf = new byte[64]; // line length 
            int cnt = 0, c;
            while ((c = read()) != -1) {
                if (c == &#39;\n&#39;) {
                    break;
                }
                buf[cnt++] = (byte) c;
            }
            return new String(buf, 0, cnt);
        }

        public int nextInt() throws IOException {
            int ret = 0;
            byte c = read();
            while (c &lt;= &#39; &#39;) {
                c = read();
            }
            boolean neg = (c == &#39;-&#39;);
            if (neg) {
                c = read();
            }
            do {
                ret = ret * 10 + c - &#39;0&#39;;
            } while ((c = read()) &gt;= &#39;0&#39; &amp;&amp; c &lt;= &#39;9&#39;);

            if (neg) {
                return -ret;
            }
            return ret;
        }

        public long nextLong() throws IOException {
            long ret = 0;
            byte c = read();
            while (c &lt;= &#39; &#39;) {
                c = read();
            }
            boolean neg = (c == &#39;-&#39;);
            if (neg) {
                c = read();
            }
            do {
                ret = ret * 10 + c - &#39;0&#39;;
            } while ((c = read()) &gt;= &#39;0&#39; &amp;&amp; c &lt;= &#39;9&#39;);
            if (neg) {
                return -ret;
            }
            return ret;
        }

        public double nextDouble() throws IOException {
            double ret = 0, div = 1;
            byte c = read();
            while (c &lt;= &#39; &#39;) {
                c = read();
            }
            boolean neg = (c == &#39;-&#39;);
            if (neg) {
                c = read();
            }

            do {
                ret = ret * 10 + c - &#39;0&#39;;
            } while ((c = read()) &gt;= &#39;0&#39; &amp;&amp; c &lt;= &#39;9&#39;);

            if (c == &#39;.&#39;) {
                while ((c = read()) &gt;= &#39;0&#39; &amp;&amp; c &lt;= &#39;9&#39;) {
                    ret += (c - &#39;0&#39;) / (div *= 10);
                }
            }

            if (neg) {
                return -ret;
            }
            return ret;
        }

        private void fillBuffer() throws IOException {
            bytesRead = din.read(buffer, bufferPointer = 0, BUFFER_SIZE);
            if (bytesRead == -1) {
                buffer[0] = -1;
            }
        }

        private byte read() throws IOException {
            if (bufferPointer == bytesRead) {
                fillBuffer();
            }
            return buffer[bufferPointer++];
        }

        public void close() throws IOException {
            if (din == null) {
                return;
            }
            din.close();
        }
    }

    public static void main(String[] args) throws IOException {
        UltraReader s = new UltraReader();
        int n = s.nextInt();
        int k = s.nextInt();
        int count = 0;
        while (n-- &gt; 0) {
            int x = s.nextInt();
            if (x % k == 0) {
                count++;
            }
        }
        System.out.println(count);
    }
}
</java>
  <cpp>C++ cin optimizado
#include &lt;bits/stdc++.h&gt; 
using namespace std; 
  
int main() 
{ 
    // Se agregan las dos lineas de abajo permitiendo que CIN tenga la
    //velocidad de SCANF
    ios_base::sync_with_stdio(false); 
    cin.tie(NULL);     
    int n, k, t; 
    int cnt = 0; 
    cin &gt;&gt; n &gt;&gt; k; 
    for (int i=0; i&lt;n; i++) 
    { 
        cin &gt;&gt; t; 
        if (t % k == 0) 
            cnt++; 
    } 
    cout &lt;&lt; cnt &lt;&lt; &quot;\n&quot;; 
    return 0; 
} 
C++ INT FastScan
//Lectura rapida de numeros enteros (Solo valido para int)
#include &lt;bits/stdc++.h&gt; 
using namespace std;

void fastscan(int &amp;number) {
    //Variable para indicar el signo del número
    bool negative = false;
    register int c;
    number = 0;
    // Extraer el caracter actual de buffer
    c = getchar();
    if (c == &#39;-&#39;) {
        // El numero es negativo
        negative = true;
        //Extraer el siguiente caracter del buffer
        c = getchar();
    }
    //se sigue extrayendo caracteres si son enteros
    // es decir su valor de ASCII esta entre &#39;0&#39;(48) y &#39;9&#39; (57)  
    for (; (c &gt; 47 &amp;&amp; c &lt; 58); c = getchar())
        number = number * 10 + c - 48;
    //si la entrada escaneada tiene signo negativo
    //se niega el valor del numero 
    if (negative)
        number *= -1;
}

int main() {
    int number;
    fastscan(number);
    cout &lt;&lt; number &lt;&lt; &quot;\n&quot;;
    return 0;
} 
</cpp>
  <py>PYTHON FastInOut
# Se importa los modulos de lectura y escritura estandar 
from sys import stdin
from sys import stdout
# Entrada de toda la linea
n = stdin.readline() 
# Llenando una lista por medio de entrada de toda la linea
arr = [int(x) for x in stdin.readline().split()] 
#Inicializamos variable
summation = 0
# Calcular sum
for x in arr: 
    summation += x 
# imprimir respuesta a través de write, 
# el método write escribe solo strings
# por lo que necesitamos convertir cualquier 
# dato en string para usarlo
stdout.write(str(summation)) 
PYTHON números en una sola línea
#Lectura de multiples numeros que estan en una misma linea
import sys 
def get_ints(): return map(int, sys.stdin.readline().strip().split()) 
a,b,c,d = get_ints() 

</py>
  <orden>0</orden>
  <suborden>99</suborden>
  <fecha_creacion>2020-12-06 20:56:44</fecha_creacion>
  <fecha_modificacion>2020-12-06 20:59:24</fecha_modificacion>
</row>
<row>
  <ID>276</ID>
  <supergrupo>Teoria</supergrupo>
  <tema>Importancia de las pruebas en la programación competitiva</tema>
  <texto>Aunque la práctica es la única forma de garantizar un mayor rendimiento en los concursos de programación, tener algunos trucos bajo la manga garantiza la optimización y una depuración rápida.
Muchas veces al resolver problemas, enfrentamos problemas como el Tiempo límite excedido (Time limit Exceeded), la solución incorrecta (Wrong answer), el error de tiempo de ejecución (Runtime Error) y el límite de memoria excedido (Memory limit exceded) porque después de diseñar el algoritmo no probamos la eficiencia, la corrección, la complejidad del tiempo y la ejecución del algoritmo en un gran conjunto de entradas para fines de prueba.
Aquí es donde las pruebas de estrés vienen al rescate. La prueba de esfuerzo es la forma común de encontrar el error en un algoritmo.
Las pruebas de esfuerzo ayudan a encontrar un algoritmo eficiente y a corregir los problemas que puedan presentar los algoritmos, pero también ven por qué ciertos enfoques no funcionan. En particular, es fácil esbozar soluciones codiciosas intuitivas a cualquier problema, pero tales soluciones a menudo no funcionan en la realidad.
• Busque el caso más sencillo del ejercicio y pruébelo
• Busque un caso intermedio y pruébelo
• Busque el caso más grande (Según las restricciones del ejercicio) y pruébelo.
• Compruebe si los resultados son los correctos, en caso de que no, realice una depuración paso a paso para verificar en que línea de código ha fallado el algoritmo.
• Si luego de estos pasos no logra resolver el problema, pruebe otro enfoque desde el principio
• No se desespere si no logra encontrar el error, la paciencia permite mejor flujo de ideas.
</texto>
  <complejidad_tiempo>null</complejidad_tiempo>
  <java>null</java>
  <cpp>null</cpp>
  <py>null</py>
  <orden>0</orden>
  <suborden>99</suborden>
  <fecha_creacion>2020-12-06 20:56:45</fecha_creacion>
  <fecha_modificacion>2020-12-06 20:59:24</fecha_modificacion>
</row>
<row>
  <ID>277</ID>
  <supergrupo>Teoria</supergrupo>
  <tema>Ejercicios iniciales </tema>
  <texto>Aquí podremos encontrar ejercicios de programación competitiva de nivel básico, realícelos con el fin de familiarizarse con ellos, puede usar traductor para entenderlos, pero procure realizarlos por mérito propio, luego de varios intentos, puede investigar la solución de los mismos en su buscador de confianza.
Para buscar la página de los ejercicios de CodeChef, utilice el siguiente link y cambie los “???” por el alias del ejercicio:

 
https://www.codechef.com/problems/???
 
1. FLOW002 
2. FLOW006 
3. START01 
4. FLOW001 
5. INTEST 
</texto>
  <complejidad_tiempo>null</complejidad_tiempo>
  <java>null</java>
  <cpp>null</cpp>
  <py>null</py>
  <orden>0</orden>
  <suborden>99</suborden>
  <fecha_creacion>2020-12-06 20:56:45</fecha_creacion>
  <fecha_modificacion>2020-12-06 20:59:24</fecha_modificacion>
</row>
<row>
  <ID>278</ID>
  <supergrupo>Estructuras</supergrupo>
  <tema>Estructuras de datos básicas</tema>
  <texto>Una estructura de datos es una colección de valores, la relación que existe entre estos valores y las operaciones que podemos hacer sobre ellos se refieren a cómo los datos están organizados y cómo se pueden administrar. Una estructura de datos describe el formato en que los valores van a ser almacenados, cómo van a ser accedidos y modificados, pudiendo así existir una gran cantidad de estructuras de datos.
Lo habitual es que un vector tenga una cantidad fija de memoria asignada, aunque dependiendo del tipo de vector y del lenguaje de programación un vector podría tener una cantidad variable de datos. En este caso, se les denomina vectores dinámicos, en oposición, a los vectores con una cantidad fija de memoria asignada se los denomina vectores estáticos. El uso de vectores dinámicos requiere realizar una apropiada gestión de memoria dinámica. Un uso incorrecto de los vectores dinámicos, o mejor dicho, una mala gestión de la memoria dinámica, puede conducir a una fuga de memoria. Al utilizar vectores dinámicos siempre habrá que liberar la memoria utilizada cuando ésta ya no se vaya a seguir utilizando.
Lenguajes más modernos y de más alto nivel, cuentan con un mecanismo denominado recolector de basura que permiten que el programa decida si debe liberar el espacio basándose en si se va a utilizar en el futuro o no un determinado objeto.

Vector tamaño fijo (Array):
 

Se le denomina vector o arreglo (en inglés Array) a una zona de almacenamiento contiguo que contiene una serie de elementos del mismo tipo, los elementos de la matriz. Desde el punto de vista lógico una matriz se puede ver como un conjunto de elementos ordenados en fila.
Estas estructuras de datos son adecuadas para situaciones en las que el acceso a los datos se realice de forma aleatoria e impredecible. Por el contrario, si los elementos pueden estar ordenados y se va a utilizar acceso secuencial sería más adecuado utilizar una lista, ya que esta estructura puede cambiar de tamaño fácilmente durante la ejecución de un programa.

Vector tamaño dinámico o lista (ArrayList):
En programación, un arreglo dinámico o Array dinámico, es un Array de elementos que crece o mengua dinámicamente conforme los elementos se agregan o se eliminan. Se suministra como librerías estándar en muchos lenguajes modernos de programación.

Vector sin repetición (Set):
Es una colección desordenada de objetos en la que no se pueden almacenar valores duplicados. 

Matriz (Matrix):
 

Es una tabla bidimensional de números consistentes en cantidades abstractas con las que se pueden realizar diferentes operaciones, como por ejemplo la suma, multiplicación y descomposición de las mismas de varias formas, lo que también las hace un concepto clave en el campo del álgebra lineal. Las matrices se utilizan para describir sistema de ecuaciones lineales, realizar un seguimiento de los coeficientes de una aplicación lineal y registrar los datos que dependen de varios parámetros.

Diccionario o mapa (HashMap, TreeMap o Map):
Los mapas son contenedores asociativos que almacenan elementos de forma mapeada. Cada elemento tiene un valor clave y un valor asignado. No hay dos valores asignados que puedan tener los mismos valores clave.

Pila (Stack):
 

Es una lista ordenada o estructura de datos que permite almacenar y recuperar datos, el modo de acceso a sus elementos es de tipo LIFO (del inglés Last In, First Out, «último en entrar, primero en salir»). Esta estructura se aplica en multitud de problemas en el área de informática debido a su simplicidad y capacidad de dar respuesta a numerosos procesos.

Cola (Queue):
 
Ilustración 7 4 Ejemplo de cola
Es una estructura de datos, caracterizada por ser una secuencia de elementos en la que la operación de inserción push se realiza por un extremo y la operación de extracción pop por el otro. También se le llama estructura FIFO (del inglés First In First Out), debido a que el primer elemento en entrar será también el primero en salir.
</texto>
  <complejidad_tiempo>null</complejidad_tiempo>
  <java>import java.util.*;

public class Main {

    public static Random r = new Random();
    public static int i, j;
    public static void main(String args[]) {
        Scanner sc = new Scanner(System.in);
        System.out.println(&quot;Inserte cantidad de datos&quot;);
        int n = sc.nextInt();
        System.out.println(&quot;Que estructura quiere utilizar? (Los números son aleatorios&quot;);
        System.out.println(&quot;1) Vector fijo &quot;);
        System.out.println(&quot;2) Vector dinámico&quot;);
        System.out.println(&quot;3) Vector sin repetición&quot;);
        System.out.println(&quot;4) Matriz&quot;);
        System.out.println(&quot;5) Diccionario&quot;);
        System.out.println(&quot;6) Pila&quot;);
        System.out.println(&quot;7) Cola&quot;);
        int aux = sc.nextInt();
        switch (aux) {
            case 1:
                vectorfijo(n);
                break;
            case 2:
                vectordinamico(n);
                break;
            case 3:
                vectorsinrepeticion(n);
                break;
            case 4:
                matriz(n);
                break;
            case 5:
                Diccionario(n);
                break;
            case 6:
                pila(n);
                break;
            case 7:
                cola(n);
                break;
        }
    }
    public static void vectordinamico(int n) {
        ArrayList&lt;Integer&gt; arreglo = new ArrayList&lt;&gt;();
        for (i = 0; i &lt; n; i++) {
            arreglo.add(r.nextInt());
        }
        for (i = 0; i &lt; n; i++) {
            System.out.println(arreglo.get(i));
        }
    }
    public static void vectorfijo(int n) {
        int[] números = new int[n];
        for (i = 0; i &lt; n; i++) {
            números[i] = r.nextInt();
        }
        for (i = 0; i &lt; n; i++) {
            System.out.println(números[i]);
        }
    }
    public static void matriz(int n) {
        int[][] matrix = new int[n][n];
        for (i = 0; i &lt; n; i++) {
            for (j = 0; j &lt; n; j++) {
                matrix[i][j] = r.nextInt(50);
            }
        }
        for (i = 0; i &lt; n; i++) {
            for (j = 0; j &lt; n; j++) {
                System.out.print(matrix[i][j] + &quot; &quot;);
            }
            System.out.println(&quot;&quot;);
        }
    }
    public static void vectorsinrepeticion(int n) {
        HashSet&lt;Integer&gt; sinrep = new HashSet&lt;&gt;();
        for (i = 0; i &lt; n; i++) {
            sinrep.add(r.nextInt(50));
        }
        Iterator it = sinrep.iterator();
        while (it.hasNext()) {
            System.out.println(it.next());
        }
    }
    public static void Diccionario(int n) {
 TreeMap&lt;String, String&gt; dicc = new TreeMap&lt;&gt;();
        dicc.put(&quot;Programar&quot;, &quot;Utilizacion de codigo para ejecutar un programa&quot;);
        dicc.put(&quot;Futbol&quot;, &quot;Deporte con una pelota y arcos&quot;);
        dicc.put(&quot;helado&quot;, &quot;crema helada&quot;);
        dicc.put(&quot;Sargento mayor Johnson&quot;, &quot;Practicar con palos y piedras&quot;);
        for (String concepto : dicc.keySet()) {
            String key = concepto;
            String value = dicc.get(concepto);
            System.out.println(key + &quot;-&gt;&quot; + value);
        }
    }
    public static void pila(int n) {
        Stack&lt;Integer&gt; mipila = new Stack&lt;&gt;();
        for (i = 0; i &lt; n; i++) {
            mipila.push(r.nextInt(50));
        }
        while (!mipila.isEmpty()) {
            System.out.println(mipila.pop());
        }
    }
    public static void cola(int n) {
        Queue&lt;Integer&gt; micola = new LinkedList&lt;&gt;();
        for (i = 0; i &lt; n; i++) {
            micola.offer(r.nextInt(50));
        }
        while (!micola.isEmpty()) {
            System.out.println(micola.poll());
        }
    }
}
</java>
  <cpp>#include&lt;bits/stdc++.h&gt;
#include&lt;cstdlib&gt;
using namespace std;
int i, j;
void vectordinamico(int n) {
    vector&lt;int&gt; arreglo;
    for (i = 0; i &lt; n; i++) {
        arreglo.push_back(rand() % 100);
    }
    for (i = 0; i &lt; n; i++) {
        cout &lt;&lt; arreglo.at(i) &lt;&lt; endl;
    }

}

void vectorfijo(int n) {
    int números[n];
    for (i = 0; i &lt; n; i++) {
        números[i] = rand() % 100;
    }
    for (i = 0; i &lt; n; i++) {
        cout &lt;&lt; números[i] &lt;&lt; endl;
    }
}

void matriz(int n) {
    int matrix [n][n];
    for (i = 0; i &lt; n; i++) {
        for (j = 0; j &lt; n; j++) {
            matrix[i][j] = rand() % 100;
        }
    }
    for (i = 0; i &lt; n; i++) {
        for (j = 0; j &lt; n; j++) {
            cout &lt;&lt; matrix[i][j] &lt;&lt; &quot; &quot;;
        }
        cout &lt;&lt; endl;
    }
}

void vectorsinrepeticion(int n) {
    set&lt;int&gt; sinrep;
    for (i = 0; i &lt; n; i++) {
        sinrep.insert(rand() % 100);
    }
    for (auto itr = sinrep.begin(); itr != sinrep.end(); ++itr) {
        cout &lt;&lt; *itr &lt;&lt; endl;
    }
}

void Diccionario(int n) {
      map &lt;string, int&gt; mapa;
    int cantidad;
    cin&gt;&gt;cantidad;
    for (int i = 0; i &lt; cantidad; i++) {
        string dato1;
        int dato2;
        cin &gt;&gt; dato1&gt;&gt;dato2;
        mapa.insert(type_pair(dato1, dato2));
    }
    cout &lt;&lt; endl;
    for (type_pair j : mapa) {
        cout &lt;&lt; j.first &lt;&lt; &quot; &quot; &lt;&lt; j.second &lt;&lt; endl;
    }
}

void pila(int n) {
    stack&lt;int&gt; mipila;

    for (i = 0; i &lt; n; i++) {
        mipila.push(rand() % 100);
    }
    while (!mipila.empty()) {
        cout &lt;&lt; mipila.top() &lt;&lt; endl;
        mipila.pop();
    }
}

void cola(int n) {
    queue&lt;int&gt; micola;
    for (i = 0; i &lt; n; i++) {
        micola.push(rand() % 100);
    }
    while (!micola.empty()) {
        cout &lt;&lt; micola.front() &lt;&lt; endl;
        micola.pop();
    }
}

int main(int argc, char *argv[]) {
    cout &lt;&lt; &quot;Inserte cantidad de datos&quot; &lt;&lt; endl;
    int n;
    cin&gt;&gt;n;
    cout &lt;&lt; &quot;Que estructura quiere utilizar? (Los números son aleatorios&quot; &lt;&lt; endl;
    cout &lt;&lt; &quot;1) Vector fijo &quot; &lt;&lt; endl;
    cout &lt;&lt; &quot;2) Vector dinamico&quot; &lt;&lt; endl;
    cout &lt;&lt; &quot;3) Vector sin repeticion&quot; &lt;&lt; endl;
    cout &lt;&lt; &quot;4) Matriz&quot; &lt;&lt; endl;
    cout &lt;&lt; &quot;5) Diccionario&quot; &lt;&lt; endl;
    cout &lt;&lt; &quot;6) Pila&quot; &lt;&lt; endl;
    cout &lt;&lt; &quot;7) Cola&quot; &lt;&lt; endl;
    int aux;
    cin&gt;&gt;aux;
    switch (aux) {
        case 1:
            vectorfijo(n);
            break;
        case 2:
            vectordinamico(n);
            break;
        case 3:
            vectorsinrepeticion(n);
            break;
        case 4:
            matriz(n);
            break;
        case 5:
            Diccionario(n);
            break;
        case 6:
            pila(n);
            break;
        case 7:
            cola(n);
            break;
    }
    return 0;
}
</cpp>
  <py>from collections import deque
import random
def vector(n):
    arreglo = []
    for i in (0, n):
        arreglo.append(random.randint(0, 100))
        
    for i in (arreglo):
        print(i)

def matriz(n):
    matrix = []
    for i in range(n):
        row = []
        for j in range(n):
            row.append(random.randint(0, 100))
        matrix.append(row)
    for i in range(n):
        for j in range(n):
            print(matrix[i][j]+&quot; &quot;)
        print()    

def vectorsinrepeticion(n):
    sinrep = {0}
    for i in range(n):
        sinrep.add(random.randint(0, 100))
    sinrep.remove(0)    
    for i in sinrep:
        print(i)

def Diccionario(n):
    dicc = {}
       dicc[&#39;Programar&#39;] = &#39;Utilizacion de codigo para ejecutar un programa
dicc[&#39;Futbol&#39;] = &#39;Deporte con una pelota y arcos&#39;

for concepto, definicion in dicc.items():
    print(f&#39;{concepto} -&gt; {definicion}&#39;)
        
def pila(n):
    mipila = []
    for i in range(n):
        mipila.append(random.randint(0, 100))
    while(len(mipila) != 0):
        print(mipila.pop())

def cola(n): 
    micola = deque([])
    for i in range(n):
        micola.append(random.randint(0, 100))

    while(len(micola) != 0):
        print(micola.popleft())
print(&quot;Inserte cantidad de datos&quot;)
n = int(input())
#No existe switch en python
print(&quot;Vector&quot;)
vector(n)
print(&quot;Vector sin repetición&quot;)
vectorsinrepeticion(n)
print(&quot;Diccionario&quot;)
Diccionario(n)
print(&quot;Pila&quot;)
pila(n)
print(&quot;Cola&quot;)
cola(n);
print(&quot;Matriz&quot;)
matriz(n)
</py>
  <orden>1</orden>
  <suborden>0</suborden>
  <fecha_creacion>2020-12-06 20:56:45</fecha_creacion>
  <fecha_modificacion>2020-12-06 21:01:13</fecha_modificacion>
</row>
</data>
