[
  {
    "ID": 258,
    "supergrupo": "Teoria",
    "tema": "Reglas básicas",
    "texto": "Durante las competencias, dependiendo de la modalidad de la misma, existen ciertas reglas que se deben cumplir para mantener la igualdad entre los competidores y evitar cualquier tipo de trampas.\nCompetencias presenciales:\n• Durante las competencias está prohibido el uso de elementos electrónicos tales como celulares, dispositivos de almacenamiento extraíbles, reproductores de música, auriculares, entre otros. De ser encontrado con alguno de estos, el participante será retirado del recinto y perderá el derecho a continuar en la competencia por intento de fraude.\n• El ingreso a páginas web distintas a la plataforma oficial de la competencia será penalizado con la descalificación inmediata de la competencia.\n• El consumo de bebidas y alimentos dentro de las aulas no está permitido.\n• Durante la competencia los equipos no podrán hablar ni intercambiar material entre ellos. De ser sorprendidos por primera vez incumpliendo esta normal, se les hará una advertencia pero si ya es la segunda vez serán descalificados  de la competencia. \n• La copia de código de fuentes externas como páginas  web o redes sociales se  considera plagio.\n• Está  permitido el uso de material como libros de texto, códigos impresos, textos matemáticos, diccionarios, entre otros.\n• Cada equipo tendrá a su disposición una sola máquina durante la competencia.\n• En la competencia los equipos serán conformados por máximo tres competidores. \nCompetencias virtuales:\n• Durante la competencia los equipos no podrán hablar ni intercambiar material entre ellos. De ser sorprendidos por primera vez incumpliendo esta normal, se les hará una advertencia pero si ya es la segunda vez serán descalificados  de la competencia. \n• En la competencia los equipos serán conformados por máximo tres competidores. \n• La copia de código de fuentes externas como páginas  web o redes sociales se  considera plagio.\n• No se admite cualquier tipo de ataques informáticos que intenten vulnerar la integridad de los sistemas usados en las competencias.\n\nDurante la mayoría de las competencias, la forma de entrada y salida de información de cada ejercicio se realiza por medio de la consola (STDIN/STDOUT), aunque algunas competencias si utilizan entornos gráficos y entornos web (Uva Online Judge, 2012).\n2.2) ¿Qué es la programación competitiva?\nDentro de las iniciativas en el área de las ciencias de la computación, un tema que año con año cobra más auge es la programación competitiva; el cual se evidencia en torneos en los cuales varios grupos de personas intentan resolver un problema a través de código y algoritmos.\nEl trabajo en equipo, pensamiento crítico y actuar bajo presión, además de otras actividades, son desarrolladas e impulsadas a través de estas competencias. Se trata de un deporte mental en el que participan e impulsan compañías multinacionales de software como Google, IBM y Facebook.\nEl desarrollo de las habilidades de programación de algoritmos se potencia a través de la colaboración, es por ello que colegios y universidades de todo el mundo buscan que los alumnos participen en este tipo de torneos.\nA su vez, el impulso de talento es crucial para actividades cada vez más demandantes y demandadas, como es la programación. De ahí que empresas de gran relevancia nacional e internacional este interesadas en egresados de carreras relacionadas.\n",
    "complejidad_tiempo": null,
    "java": null,
    "cpp": null,
    "py": null,
    "orden": 0,
    "suborden": 99,
    "fecha_creacion": "2020-12-06 20:56:39",
    "fecha_modificacion": "2020-12-06 20:59:24"
  },
  {
    "ID": 259,
    "supergrupo": "Teoria",
    "tema": "¿Qué es la programación competitiva?",
    "texto": "Dentro de las iniciativas en el área de las ciencias de la computación, un tema que año con año cobra más auge es la programación competitiva; el cual se evidencia en torneos en los cuales varios grupos de personas intentan resolver un problema a través de código y algoritmos.\nEl trabajo en equipo, pensamiento crítico y actuar bajo presión, además de otras actividades, son desarrolladas e impulsadas a través de estas competencias. Se trata de un deporte mental en el que participan e impulsan compañías multinacionales de software como Google, IBM y Facebook.\nEl desarrollo de las habilidades de programación de algoritmos se potencia a través de la colaboración, es por ello que colegios y universidades de todo el mundo buscan que los alumnos participen en este tipo de torneos.\nA su vez, el impulso de talento es crucial para actividades cada vez más demandantes y demandadas, como es la programación. De ahí que empresas de gran relevancia nacional e internacional este interesadas en egresados de carreras relacionadas.\n",
    "complejidad_tiempo": null,
    "java": null,
    "cpp": null,
    "py": null,
    "orden": 0,
    "suborden": 99,
    "fecha_creacion": "2020-12-06 20:56:39",
    "fecha_modificacion": "2020-12-06 20:59:24"
  },
  {
    "ID": 260,
    "supergrupo": "Teoria",
    "tema": "¿Qué es un problema de programación competitiva?",
    "texto": "Un problema de programación competitiva es un pequeño ejercicio de programación que puede abordar cualquier tema de la vida cotidiana, ciencias puras como la matemática o la física, un juego de mesa como el ajedrez o un rompecabezas.\nUtilizando la programación se pueden resolver estos ejercicios y buscar una solución óptima al mismo utilizando matemática, algoritmos matemáticos especializados o incluso lógica básica.\n",
    "complejidad_tiempo": null,
    "java": null,
    "cpp": null,
    "py": null,
    "orden": 0,
    "suborden": 99,
    "fecha_creacion": "2020-12-06 20:56:40",
    "fecha_modificacion": "2020-12-06 20:59:24"
  },
  {
    "ID": 261,
    "supergrupo": "Teoria",
    "tema": "Estructura de un problema de programación competitiva",
    "texto": "Un problema se encuentra conformado de 4 partes principales:\n1. Título: Contiene el nombre del problema, comúnmente da una vaga aproximación al tema del problema\n2. Descripción: Contiene toda la información del problema, puede ser una historia, un evento, algo que le pasando a alguien y quiere que usted lo ayude a resolverlo. Puede contener algunas pistas de cómo resolver el ejercicio, variables que se pueden usar y de qué tipo pueden ser.\n3. Variables y restricciones: muestra el o los tipos de datos que entraran y el o los tipos de datos que deben salir, además del tamaño que puede tener la entrada.\n4. Ejemplo de entrada y salida: Muestra uno de todos los posibles casos de prueba que pueden evaluarse en el ejercicio, tener en cuenta que los ejemplos en los textos de ejercicio nunca serán los únicos, se debe usar la parte de variables para calcular cual será el caso más fácil, un caso intermedio y el caso más difícil.\n",
    "complejidad_tiempo": null,
    "java": null,
    "cpp": null,
    "py": null,
    "orden": 0,
    "suborden": 99,
    "fecha_creacion": "2020-12-06 20:56:40",
    "fecha_modificacion": "2020-12-06 20:59:24"
  },
  {
    "ID": 262,
    "supergrupo": "Teoria",
    "tema": "Como abordar un problema",
    "texto": "Comúnmente todos los ejercicios tienen dos o más formas de ser solucionados, utilizando diversos tipos de algoritmos o metodologías matemáticas de resolución de problemas, a continuación nombraremos algunas de las formas existentes para abordar un problema:\n- Fórmulas matemáticas\n- Fuerza bruta\n- Aproximaciones de raíces \n- Procesamiento de Strings \n- Búsqueda de patrones\n- Uso de estructuras de datos especializadas\n- Algoritmos prediseñados modificados\n- Enfoque geométrico\n- Algoritmos ingenuos\n- Uso de estructuras geometrías avanzadas\n- Búsquedas \n- Ordenamientos\nAl leer toda la información de nuestro ejercicio, su deber como es identificar cual es la metodología más adecuada para la resolución de estos ejercicios, podemos apoyarnos de material previamente consultado. Entre cada metodología de resolución varia el uso de memoria, tiempo de ejecución y forma de entrada de la información a procesar, por lo que conocer los puntos fuertes y débiles de cada uno es crucial. \nPor lo general las metodologías matemáticas son las más rápidas pero también suelen ser las más complicadas de implementar, ya que se basan en la búsqueda de sistemas de ecuaciones o el uso de teoremas matemáticos que son complicados y abstractos de entender, las metodologías de fuerza bruta son las más lentas pero las más seguras a la hora de encontrar una solución a un problema debido a que usan gran cantidad de recursos para asegurarse de dar con la respuesta, además de obtener las demás respuestas posibles a un problema cuando sus variables cambian. \nLos desarrolladores y estudiantes resuelven muchas preguntas de codificación de estructuras de datos y algoritmos, pero la mayoría de ellos no comprende la importancia de esto. Muchos de ellos también tienen la opinión de que las estructuras de datos y los algoritmos solo ayudan en las entrevistas y después de eso, no hay uso de todas esas cosas complicadas en los trabajos diarios.\nEs importante estar contento con aprender un nuevo lenguaje o framework y crear algunas aplicaciones con eso, pero una vez que ingrese a la industria del mundo real, se dará cuenta de que su trabajo no es solo escribir el código y hacer que las cosas funcionen. Su verdadero trabajo es escribir la cantidad correcta de buen código, lo que significa que debe ser eficiente y robusto, y aquí viene el papel de las estructuras de datos y los algoritmos. Las estructuras de datos y los algoritmos no solo ayudan a obtener la lógica de su programa, sino que también ayudan a escribir el código eficiente para su software. Ya sea que hablemos sobre la complejidad del tiempo o la administración de la memoria, la refactorización del código o la reutilización del código, comprenderá su valor en cada parte de su aplicación.\nEn proyectos del mundo real, su cerebro debería ser capaz de escribir una solución rápida y eficiente para desafíos complicados, y solo puede hacerlo cuando haya practicado mucha programación. Comprenda que el lenguaje y los frameworks son solo herramientas, no le enseñarán habilidades para resolver problemas. Se desarrolla habilidad para resolver problemas cuando se practica mucha programación.\nCada desarrollador tiene sus propios trucos y siguen su propio patrón para resolver problemas de codificación, pero cuando se trata de nuevos desarrolladores, siempre tienen dudas sobre dónde comenzar. Muchos de ellos entienden los problemas, la lógica y los conceptos básicos de la sintaxis, también entienden los códigos de otras personas y pueden seguirlos, pero cuando se trata de resolver las preguntas por su cuenta, se atascan. No entienden cómo convertir sus pensamientos en código a pesar de que entienden la sintaxis o la lógica. Estos son algunos pasos simples que lo ayudarán a abordar una pregunta de codificación dentro de una competencia o dentro de una entrevista de trabajo.\nComprender y analizar el problema\nNo importa si ha visto el ejercicio que está realizando en el pasado o no, lea la pregunta varias veces y comprenda por completo. Ahora, piense en la pregunta y analícela cuidadosamente. A veces leemos algunas líneas y asumimos el resto de las cosas por nuestra cuenta, pero un ligero cambio en su pregunta puede cambiar muchas cosas en su código, así que tenga cuidado al respecto. Ahora tome un papel y escriba todo. ¿Qué se proporciona (entrada) y qué necesita averiguar (salida)? \nMientras se debe realizar las siguientes preguntas...\n1. ¿Entendió el problema completamente?\n2. ¿Sería capaz de explicar esta pregunta a otra persona?\n3. ¿Qué y cuántas entradas se requieren?\n4. ¿Cuál sería la salida para esas entradas?\n5. ¿Necesita separar algunos módulos o partes del problema?\n6. ¿Tiene suficiente información para resolver esa pregunta? De lo contrario, lea nuevamente la pregunta.\nPor ejemplo: si se le da un vector y necesita devolver el vector que contiene solo números pares, primero analice el problema cuidadosamente. Mientras analiza el problema, debe hacerse algunas preguntas antes de saltar a la solución.\n1. ¿Cómo identificar un número par? Divida ese número entre 2 y vea si su residuo es 0.\n2. ¿Qué debo pasar a esta función? Un vector\n3. ¿Qué contendrá ese vector? Uno o más números\n4. ¿Cuáles son los tipos de datos de los elementos en el vector? Números\n5. ¿Cuál es el objetivo final? El objetivo es devolver el vector de números pares. Si no hay números pares, devuelve un vector vacío.\nRevise los datos de muestra y los ejemplos a fondo\nCuando intente comprender el problema, tome algunas entradas de muestra e intente analizar la salida. Tomar algunas entradas de muestra lo ayudará a comprender el problema de una mejor manera. También obtendrá la claridad de cuántos casos puede manejar su código y cuáles pueden ser la salida o el rango de salida posibles. \n• Considere algunas entradas o datos simples y analice la salida.\n• Considere algunos aportes complejos y más grandes e identifique cuál será el resultado y cuántos casos debe tomar para resolver el problema.\n• Considere también los casos extremos. Analice cuál sería la salida si no hay entrada o si proporciona alguna entrada no válida.\n\nRomper el problema\nCuando vea un problema de programación que es complejo o grande, en lugar de tener miedo y confundirse acerca de cómo resolver esa pregunta, divida el problema en fragmentos más pequeños y luego intente resolver cada parte del problema. A continuación se detallan algunos pasos que debe seguir para resolver las complejas preguntas de codificación:\n• Haga un diagrama de flujo para el problema en cuestión.\n• Divida el problema en subproblemas o fragmentos más pequeños.\n• Resuelva los subproblemas. Haga funciones independientes para cada subproblema.\n• Conecte las soluciones de cada subproblema llamándolos en el orden requerido o según sea necesario.\n• Donde sea necesario, use clases y objetos \nEscribir pseudocódigo\nAntes de saltar a la solución, siempre es bueno escribir un pseudocódigo para su problema. Básicamente, el pseudocódigo define la estructura de su código y le ayudará a escribir cada línea de código que necesite para resolver el problema. Leer el pseudocódigo da una idea clara de lo que su código debe hacer. Muchas personas o programadores experimentados omiten este paso, pero cuando escribe pseudocódigo, el proceso de escribir el código final se vuelve más fácil para usted. Al final, solo tendrá que traducir cada línea de pseudocódigo en código real. Así que escriba cada paso y lógica en su pseudocódigo. \nReemplazar pseudocódigo con código real\nUna vez que haya escrito el pseudocódigo, es hora de traducirlo al código real. Reemplace cada línea de su pseudocódigo en código real en el idioma en el que está trabajando. Si ha dividido su problema en subproblemas, anote el código de cada subproblema. Mientras escribe el código, tenga en cuenta tres cosas:\n• El punto donde comenzó\n• ¿Dónde está ahora mismo?\n• ¿Cuál es su destino (resultado final)?\nNo olvide probar su código con conjuntos de datos de muestra (paso 2) para verificar si la salida real es igual a la salida esperada. Una vez que haya terminado con la codificación, puede deshacerse del pseudocódigo\n\nCuando se encuentre dentro de una entrevista de trabajo, escriba el código, vaya diciéndole al entrevistador cómo está abordando el problema.\n• Dígale al entrevistador cómo está tratando de comenzar.\n• Cuéntele al entrevistador acerca de su enfoque para resolver el problema.\n• Discuta con el entrevistador sobre la parte más difícil que enfrenta en su problema.\n• Informe al entrevistador sobre el enfoque para resolver cada subproblema para obtener el resultado final.\n• Discuta los datos de la muestra o los casos de prueba con el entrevistador.\n• Discuta sobre la mejor solución con el entrevistador.\nSimplifique y Optimice su Código\nIntenta siempre mejorar su código. Mire hacia atrás, analícelo una vez más e intente encontrar una solución mejor o alternativa. Se ha mencionado anteriormente que siempre debe intentar escribir la cantidad correcta de código correcto, así que siempre busque la solución alternativa que sea más eficiente que la anterior. Escribir la solución correcta a su problema no es lo último que debe hacer. Explore el problema completamente con todas las soluciones posibles y luego escriba la solución más eficiente u optimizada para su código. Entonces, una vez que haya terminado de escribir la solución para su código, hay algunas preguntas que debe hacerse.\n• ¿Se ejecuta este código para cada entrada posible, incluidos los casos límite?\n• ¿Existe una solución alternativa para el mismo problema?\n• ¿Es eficiente el código? ¿Puede ser más eficiente o se puede mejorar el rendimiento?\n• ¿De qué otra forma puede hacer que el código sea más legible?\n• ¿Hay más pasos o funciones adicionales que pueda realizar?\n",
    "complejidad_tiempo": null,
    "java": null,
    "cpp": null,
    "py": null,
    "orden": 0,
    "suborden": 99,
    "fecha_creacion": "2020-12-06 20:56:40",
    "fecha_modificacion": "2020-12-06 20:59:24"
  },
  {
    "ID": 263,
    "supergrupo": "Teoria",
    "tema": "Casos de prueba y tipos de casos de prueba",
    "texto": null,
    "complejidad_tiempo": null,
    "java": null,
    "cpp": null,
    "py": null,
    "orden": 0,
    "suborden": 99,
    "fecha_creacion": "2020-12-06 20:56:40",
    "fecha_modificacion": "2020-12-06 20:59:24"
  },
  {
    "ID": 264,
    "supergrupo": "Teoria",
    "tema": "10 pasos para resolver cualquier problema",
    "texto": "1. Lea el problema completamente al menos dos o tres veces (o la cantidad de veces que sean que te hagan sentir cómodo)\n2. Identifique el tema al que pertenece el problema. ¿Es un problema de ordenamiento o coincidencia de patrones? ¿Puede usar la teoría de grafos? ¿Está relacionado con la teoría de números? etc.\n3. Intente resolver el problema manualmente considerando 3 o 4 sets de datos de prueba.\n4. Luego concéntrese en optimizar los pasos manuales. Intente hacerlo lo más simple posible.\n5. Escriba el pseudocódigo y comentarios, además del código de cada paso. Una cosa que puede hacer es verificar después de escribir cada función. Use un buen IDE con un depurador, si es posible. No es necesario pensar mucho en la sintaxis. Solo concéntrese en la lógica y los pasos. \n6. Reemplace los comentarios o pseudocódigo con código real. Siempre verifique si los valores y el código se comportan como se esperaba antes de pasar a la nueva línea de pseudocódigo.\n7. Luego optimice el código real.\n8. Cuide también las condiciones de restricción de cada variable.\n9. Obtenga comentarios de sus compañeros de equipo, profesores y otros desarrolladores y, si es posible, haga su pregunta en StackOverflow. Intente aprender de las pautas de los demás y de lo que están manejando esos problemas. Un problema puede resolverse de varias maneras. Por lo tanto, no se decepcione si no puede pensar como un experto. Debe atenerse al problema y gradualmente será mejor y más rápido para resolver problemas como los demás.\n10. Practique, practique y practique.\n",
    "complejidad_tiempo": null,
    "java": null,
    "cpp": null,
    "py": null,
    "orden": 0,
    "suborden": 99,
    "fecha_creacion": "2020-12-06 20:56:41",
    "fecha_modificacion": "2020-12-06 20:59:24"
  },
  {
    "ID": 265,
    "supergrupo": "Teoria",
    "tema": "Resultados y veredictos de los jueces en línea",
    "texto": "Luego de enviar su programa al juez en línea, se compilará y ejecutará en ese sistema, y el juez automático lo probará con algunas entradas y salidas, o quizás con una herramienta de juez específica. Pasados unos segundos o minutos, recibirá una de estas respuestas:\nIn Queue (QU): El juez está ocupado y no puede atender su presentación. Será juzgado lo antes posible.\nAccepted o Correct (AC): ¡OK! ¡Su programa es correcto! Produjo la respuesta correcta en un tiempo razonable y dentro del límite de uso de memoria. ¡Felicidades!\nPresentation Error (PE): las salidas de su programa son correctas pero no se presentan de la manera correcta. Buscar espacios, justificar, saltos de línea...\nWrong Answer (WA): No se alcanzó la solución correcta para las entradas. Las entradas y salidas que usan los jueces en línea para probar los programas no son públicas, por lo que tendrá que detectar el error por usted mismo. \nCompile Error (CE): El compilador no pudo compilar su programa. Los mensajes de salida del compilador se le informan para que solucione el problema.\nRuntime Error (RE): Su programa falló durante la ejecución (error de segmentación, excepción de punto flotante, mal lectura de datos, desbordamiento de variables… entre otros). La causa exacta no se informa al usuario para evitar el plagio. Asegúrese de que su programa devuelva un código 0 (Ejecución correcta) al shell. Si está utilizando Java, siga todas las especificaciones de envío.\nTime Limit Exceeded (TLE): Su programa intentó ejecutarse durante demasiado tiempo; este error no le permite saber si su programa alcanzaría la solución correcta al problema o no.\nMemory Limit Exceeded (MLE): Su programa intentó usar más memoria de la que permite el juez.\nOutput Limit Exceeded (OL): Su programa intentó escribir demasiada información. Esto suele ocurrir si entra en un bucle infinito.\nSubmission Error o Submit Failed (SE): El envío no se realizó correctamente. Esto se debe a algún error durante el proceso de envío o corrupción de datos.\nRestricted Function (RF): Su programa está intentando utilizar una función que se  considera perjudicial para el sistema del juez en línea. Si obtiene este veredicto, probablemente sepa por qué... (Está haciendo trampa o intentando hacer daño al juez).\nCan't Be Judged (CJ): El juez no tiene entradas y salidas de prueba para el problema seleccionado. Al elegir un problema, asegúrese de que el juez pueda juzgarlo.\n",
    "complejidad_tiempo": null,
    "java": null,
    "cpp": null,
    "py": null,
    "orden": 0,
    "suborden": 99,
    "fecha_creacion": "2020-12-06 20:56:41",
    "fecha_modificacion": "2020-12-06 20:59:24"
  },
  {
    "ID": 266,
    "supergrupo": "Teoria",
    "tema": "Diferencias generales de los lenguajes",
    "texto": "Debido a la metodología de ejecución de los diferentes lenguajes de programación, la cantidad de librerías, utilidades estándar de cada lenguaje y su dificultad al entender la sintaxis de las líneas de código, se evidencia que cada lenguaje tiene pros y contras en su utilización al momento de resolver ejercicios de programación competitiva, hay que recordar que Java es un lenguaje que utiliza una máquina virtual para su ejecución y que Python es un lenguaje interpretado, estas dos generan que ambos lenguajes sean ligeramente más lentos al ejecutarse.\nOtra idea a tener en cuenta es el hecho de que Python no tiene problemas de desbordamiento de variables, debido a que todos los objetos que se crean dentro del código se les asigna memoria de forma dinámica y automática, lo que le permite realizar cálculos con números muy grandes, pero sacrificando rendimiento.\nJava contiene una gran cantidad de librerías estándar para uso dentro de la programación competitiva, lo que le permite reducir líneas de código y agregar funcionalidades que optimicen diversas operaciones dentro de la ejecución del código.\nTeniendo estas ideas en cuenta se puede realizar la siguiente comparación:\nVelocidad de ejecución\nPYTHON<JAVA<C++\nCantidad de librerías \nJAVA>PYTHON>C++\nDificultad de código\nPYTHON<JAVA<C++\nNota: estas conclusiones solo aplican cuando los lenguajes se utilizan en ejercicios de programación competitiva.\n\nPython es más lento en tiempo de ejecución que Java, y Java es más lento que C++, por lo que C++ es el lenguaje más rápido.  Java tiene muchas más librerías estándar que Python, y Python tiene muchas más librerías que C++, permitiendo que Java sea el lenguaje más polivalente, por último la dificultad de la sintaxis de Python es mucho menor a la de Java, y la dificultad de Java es mayor a la de C++, permitiendo que Python sea el lenguaje más sencillo de comprender al ser leído.\nUn buen programador competitivo tiene conocimiento de estos tres lenguajes de programación de tal manera que al abordar un ejercicio pueda el decidir cuál de los tres lenguajes es el más adecuado para darle solución al mismo. \n",
    "complejidad_tiempo": null,
    "java": null,
    "cpp": null,
    "py": null,
    "orden": 0,
    "suborden": 99,
    "fecha_creacion": "2020-12-06 20:56:41",
    "fecha_modificacion": "2020-12-06 20:59:24"
  },
  {
    "ID": 267,
    "supergrupo": "Teoria",
    "tema": "Consejos y trucos para programadores competitivos",
    "texto": "¿Qué lenguaje usar? Esta es una pregunta frecuente frente a en qué idioma se debe preferir ser eficiente en la programación competitiva. Es algo de lo que uno no debería preocuparse, ya que lo que importa es la lógica, no el lenguaje. La mayoría de los lenguajes son más o menos iguales, pero hasta ahora el lenguaje más utilizado es C ++, a continuación se presenta un resumen de las ventajas y desventajas de cada lenguaje.\nPython\n• Simple y fácil: Python es simple, fácil de escribir (se necesita escribir menos) y tiene una gran colección de módulos con casi todas las funciones que pueda imaginar.\n• Tipos de datos: generalmente se prefiere Python, ya que no tiene ningún límite superior en la memoria de los enteros. Además, no es necesario especificar qué tipo de datos es y cosas como esta hacen que sea más fácil de codificar, pero al mismo tiempo dificultan la compilación (en referencia al tiempo necesario para la compilación).\n• Lento en la ejecución: los programas de Python son generalmente más lentos en comparación con Java. Python está prácticamente descartado en el inicio debido a su alto tiempo de ejecución.\n• Python no está permitido en todas partes: Python no está permitido en concursos en varios portales de programación competitivos populares en línea.\nAhora nos quedamos principalmente con Java, C, C ++, ahora aquí se hace difícil comparar y depende principalmente del usuario, aquí se presentan los puntos buenos y malos de cada uno de ellos.\nJava\n• STL vs contenedores: STL en C ++ está muy bien diseñado, mientras que algunas personas aman Java Containers más que nada. Hay pocas situaciones en las que STL no tiene una solución directa. Por ejemplo, priority_queue en STL no admite la operación de tecla de disminución que se requiere para las implementaciones del algoritmo de ruta más corto de Dijkstra y el algoritmo de Prim\n• El manejo de excepciones en Java es incomparable: el código Java proporciona un manejo de excepciones más fuerte en comparación con C ++. Por ejemplo, es más fácil rastrear una excepción ArrayIndexOutOfBound o una falla de segmentación en Java. C ++ / C puede darle respuestas incorrectas, pero Java es seguramente confiable en este contexto.\n• El límite de tiempo excede: es posible que obtenga TLE debido a que Java es un poco más lento en el lado del límite de tiempo\n• Grandes enteros y expresiones regulares: Java tiene algunas pocas ventajas con respecto a los concursos de programación. Biginteger, Expresiones regulares y biblioteca de geometría son algunas de ellas.\nC++ y C \n• La velocidad de C ++ es comparable a C: muchos programas de C también son programas de C ++ válidos, y dichos programas de C se ejecutan a una velocidad idéntica cuando se compilan\n• C ++ no fuerza la programación orientada a objetos: el lenguaje C ++ contiene algunas extensiones de lenguaje que facilitan la programación orientada a objetos y C ++ no fuerza el diseño orientado a objetos en ninguna parte, simplemente lo permite.\n\n• Una biblioteca estándar más grande: C ++ permite el uso completo de la biblioteca estándar C, así como C ++ incluye sus propias bibliotecas, incluida la Biblioteca de plantillas estándar. El STL contiene una serie de plantillas útiles, como la rutina de ordenamiento anterior. Incluye útiles estructuras de datos comunes como listas, mapas, conjuntos, etc. Al igual que la rutina de ordenamiento, las otras rutinas STL y estructuras de datos están \"adaptadas\" a las necesidades específicas que tiene el programador; todo lo que el programador tiene que hacer es completar los tipos.\nPor ejemplo, si necesitamos implementar Binary Search para un problema, tendremos que escribir nuestra propia función, mientras que en C ++ Binary Search, la rutina STL se define como\n• binary_search (startaddress, endaddress, valuetofind)\nC ++ vs Java\n• Los códigos Java son más largos, un programador necesita escribir más cuando programa en Java\n• Java es detallado: en C ++, Entrada Salida es más simple simplemente escribiendo scanf / printf. En Java,  a veces se necesita la clase BufferedReader, tediosa de programar.\n• C ++ STL vs Java Containers: a la mayoría de los programadores les resulta más fácil usar STL.\n• C ++ es más popular: ya sea el año de origen o la comodidad de uso, pero C ++ destaca a Java en términos de cantidad de usuarios que usan el lenguaje.\n• C ++ ahorra tiempo: es un hecho bien conocido que Java es más lento que C ++. Generalmente necesitamos compilar y ejecutar programas muchas veces para probarlos. Lleva relativamente menos tiempo en C ++. \nEn resumen, C ++ es hasta la fecha el lenguaje más preferido seguido de Java cuando se trata de concursos de programación, pero siempre debe elegir un idioma con el que se sienta cómodo. Tener confianza en cualquier idioma es lo más importante. Nunca elija un idioma que haya \"aprendido\" recientemente o con el cual tenga poca experiencia, ya que será difícil expresarse en ese idioma.\n",
    "complejidad_tiempo": null,
    "java": null,
    "cpp": null,
    "py": null,
    "orden": 0,
    "suborden": 99,
    "fecha_creacion": "2020-12-06 20:56:42",
    "fecha_modificacion": "2020-12-06 20:59:24"
  },
  {
    "ID": 268,
    "supergrupo": "Teoria",
    "tema": "¿Cómo llegar a ser un maestro en programación competitiva?",
    "texto": "Las competencias de programación a nivel internacional son desarrolladas para medir la capacidad de los estudiantes de programación de las distintas universidades y entes estudiantiles, entre ellas se permite utilizar todo tipo de medios escritos en los cuales basarse para el desarrollo de diferentes soluciones a problemas de la vida real que requieren un algoritmo eficiente.\nGrandes empresas de desarrollo como Google, Microsoft, IBM entre otras utilizan estas competencias como principal medio de reclutamiento de personal, por lo que se hace evidente la necesidad de participación en ellas.\nHay muchas personas para quienes la programación es como un sueño embrujado. La programación no es más que un arte de hablar con las máquinas y decirles qué hacer, cuándo hacerlo y por qué hacerlo. La mayoría de los estudiantes escuchan esta palabra en el colegio. Para muchos de ellos, la programación comienza con \"C\" y termina en \"C\". \nLa programación competitiva es una forma avanzada de programación que se ocupa de problemas del mundo real. Aquí vemos nuestro código gobernando el mundo. Pero escribir dicho código requiere destreza con pasión.\nSe tiene claro que un código es básicamente nuestra lógica detrás de cualquier problema en lenguaje de alto nivel. Pero la lógica por sí sola no es suficiente para escribir un código perfecto. Requiere una comprensión más profunda de términos técnicos como complejidad, sintaxis y el arte de crear grandes soluciones a través de los códigos más cortos posibles. Todo esto solo se puede lograr a través de la práctica. Pero si la práctica se fusiona con una buena guía, se puede llegar al dominio. Este objetivo se puede lograr a través de los siguientes pasos: \n1. Obtenga una comprensión profunda\nEn primer lugar, estudie todos los conceptos del lenguaje de programación profundamente. Siempre use libros estándar. Hoy en día, hay muchas plataformas en línea disponibles donde los competidores de todo el mundo comparten sus conocimientos e intentan facilitar los conceptos.\n2. Seguir un enfoque jerárquico\nIntente comenzar a codificar utilizando problemas más simples. Antes de escribir directamente el código, primero haga un diagrama de flujo de la lógica que se está utilizando. Esto aumentará la cantidad de códigos correctos que no solo agudizarán tus habilidades sino que también aumentarán tu confianza.\n3. Implementación en la vida real\nUna vez que se acostumbre a los códigos y la programación básica, intente crear códigos que resuelvan tus problemas de la vida diaria. Estos pueden incluir la libreta de calificaciones de cualquier estudiante, el sistema de reserva de boletos, el sistema de administración de la biblioteca, etc. De esta manera obtendrá confianza.\n4. Simplificar el código\nAhora el siguiente paso es acortar el código. Suponga que crea un código simple para el sistema de administración de una biblioteca. Ahora intente abreviarlo de tal manera que la misma tarea se pueda lograr de una manera mucho más simple y más corta. Primero puede ver el problema y crear su propio código. Ahora vea la solución óptima para aprender cómo se puede reducir. Esta es la fase más importante y la transición de la programación básica a la programación competitiva.\n5. No se rinda, láncese a los leones\nAhora comience a participar en competencias de codificación. Las competiciones pueden ser en su escuela, en línea o a nivel nacional. Aquí encontrara personas igual que usted compitiendo y retándose unos con otros. Aquí, debe escribir la solución óptima y eso también en el menor tiempo posible. Obviamente, dado que es una competencia, es la supervivencia del más apto. Un entorno competitivo amistoso hace que la tasa de aprendizaje sea más rápida e implica aprender mediante un mecanismo divertido. Además de esto, también obtendrá una calificación de acuerdo con sus presentaciones exitosas del código y las competiciones que gane, lo que mejora su perfil profesional.\n6. Comience a difundir su conocimiento\nUna vez que se convierta en un maratonista, no se guarde los conocimientos. Extiéndalos. Compártalos con sus estudiantes o aprendices, sus compañeros y a través del mundo. Su conocimiento aumenta más si lo comparte con otros.\n",
    "complejidad_tiempo": null,
    "java": null,
    "cpp": null,
    "py": null,
    "orden": 0,
    "suborden": 99,
    "fecha_creacion": "2020-12-06 20:56:42",
    "fecha_modificacion": "2020-12-06 20:59:24"
  },
  {
    "ID": 269,
    "supergrupo": "Teoria",
    "tema": "Operadores matemáticos, lógicos y comparativos",
    "texto": "¿Qué es un operador lógico?\nLos operadores lógicos, utilizados en Informática, lógica proposicional y álgebra booleana, entre otras disciplinas, nos proporcionan un resultado a partir de que se cumpla o no una cierta condición, producen un resultado booleano, y sus operandos son también valores lógicos o asimilables a ellos (los valores numéricos son asimilados a verdadero o falso según su valor sea cero o distinto de cero). Esto genera una serie de valores que, en los casos más sencillos, pueden ser parametrizados con los valores numéricos 0 y 1. La combinación de dos o más operadores lógicos conforma una función lógica.\nLos operadores lógicos son tres, dos de ellos son binarios, el último (negación) es unario. Tienen una doble posibilidad de representación depende el lenguaje: \n- \"Y\" lógico -> && -> AND\n- \"O\" lógico -> || -> OR\n- Negación lógica  -> ! -> NOT\nLas expresiones conectadas con los operadores && y || se evalúan de izquierda a derecha, y la evaluación se detiene tan pronto como el resultado verdadero o falso es conocido.\n¿Qué es una operación matemática?\nUna operación matemática es un proceso mediante el cual se logra la transformación de una o más cantidades en otra cantidad llamada resultado.\nToda operación matemática tiene unos valores de entrada, y presenta una regla de definición que señala el tipo de proceso que se debe realizar para llegar al resultado.\nJunto con los valores de entrada se coloca un símbolo que se denomina operador matemático.\nHay operaciones matemáticas que nos son muy conocidas, cuyos operadores también lo son: por ejemplo, el + que señala una suma, la rayita   ?  que indica una resta, y los operadores de multiplicación *, división / y residuo %.\n¿Qué es un operador comparativo?\nLos operadores de comparación comparan dos expresiones y devuelven un valor booleano que representa la relación de sus valores. Existen operadores para comparar valores numéricos, operadores para comparar cadenas y operadores para comparar objetos.\n",
    "complejidad_tiempo": null,
    "java": null,
    "cpp": null,
    "py": null,
    "orden": 0,
    "suborden": 99,
    "fecha_creacion": "2020-12-06 20:56:42",
    "fecha_modificacion": "2020-12-06 20:59:24"
  },
  {
    "ID": 270,
    "supergrupo": "Teoria",
    "tema": "Tipos de variables básicas",
    "texto": "En programación, las variables son espacios reservados en la memoria que, como su nombre indica, pueden cambiar de contenido a lo largo de la ejecución de un programa. Una variable corresponde a un área reservada en la memoria principal del ordenador.\nPor buenas prácticas, el identificador de la variable (Nombre de la variable) debe ser mnemotécnico, es decir que debe reflejar el uso dentro del programa de la misma.\nEl tipo de dato informático es un atributo de una parte de los datos que indica al ordenador (y al programador) algo sobre la clase de datos sobre los que se va a procesar. Esto incluye imponer restricciones en los datos, como qué valores pueden tomar y qué operaciones se pueden realizar. Tipos de datos comunes son: enteros, cadenas alfanuméricas, fechas, horas, colores, coches o cualquier cosa que se nos ocurra. Por ejemplo, el tipo \"int\" representa un conjunto de enteros. Éste es un concepto propio de la informática, más específicamente de los lenguajes de programación, aunque también se encuentra relacionado con nociones similares de las matemáticas y la lógica.\nDebido a que las variables contienen o apuntan a valores de tipos determinados, las operaciones sobre las mismas y el dominio de sus propios valores están determinadas por el tipo de datos en cuestión.\nTipo de dato lógico:\nEl tipo de dato lógico o booleano es en computación aquel que puede representar valores de lógica binaria, esto es 2 valores, que normalmente representan falso o verdadero. Se utiliza normalmente en la programación, estadística, electrónica, matemáticas (álgebra booleana) y otras.\nTipo de dato entero:\nEl tipo de dato entero en computación se usa para representar un subconjunto finito de los números enteros. El mayor número que se puede representar depende del tamaño del espacio usado por el dato y la posibilidad (o no) de representar números negativos. Los tipos de dato entero disponibles y su tamaño dependen del lenguaje de programación usado así como la arquitectura en cuestión.\nTipo de dato carácter:\nEn terminología informática y de telecomunicaciones, un carácter es un símbolo que representa cada carácter de un lenguaje natural. Un ejemplo de carácter es una letra, un número o un signo de puntuación.\nCadena de caracteres:\nEn programación, una cadena de caracteres o frase (string en inglés) es una secuencia ordenada de longitud arbitraria (aunque finita) de elementos que pertenecen a un cierto alfabeto. En general, una cadena de caracteres es una sucesión de caracteres (letras, números u otros signos o símbolos).\nDesde el punto de vista de la programación, si no se ponen restricciones al alfabeto, una cadena podrá estar formada por cualquier combinación finita de todo el juego de caracteres disponibles (las letras de la 'a' a la 'z' y de la 'A' a la 'Z', los números del '0' al '9', el espacio en blanco ' ', símbolos diversos '!', '@', '%', entre otros). Un caso especial de cadena es la que contiene cero caracteres, a esta cadena se le llama cadena vacía.\n",
    "complejidad_tiempo": null,
    "java": null,
    "cpp": null,
    "py": null,
    "orden": 0,
    "suborden": 99,
    "fecha_creacion": "2020-12-06 20:56:43",
    "fecha_modificacion": "2020-12-06 20:59:24"
  },
  {
    "ID": 271,
    "supergrupo": "Teoria",
    "tema": "Lectura e impresión",
    "texto": "Las lecturas e impresiones de nuestros ejercicios de programación competitiva, sus algoritmos base y sus modificaciones se realizan por la consola (STDIN, STDOUT), por lo que por lo general la programación de entornos gráficos para nuestros códigos no es válida, los siguientes códigos muestran ejemplos de cómo se realizan las entradas y salidas de diferentes tipos de variables.",
    "complejidad_tiempo": "Ejemplo de entrada\n6555\n73653736353\n463553\n345543234\na\nholamundo\n101\n",
    "java": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.Scanner;\n\npublic class LecturaEscritura {\n    //Variables Globales\n    static int numeroentero;\n    static long numeroenterolargo;\n    static float numerodecimal;\n    static double numerodecimallargo;\n    static char caracter;\n    static String cadena;\n    static byte bits;\n\n    public static void main(String[] args) throws IOException {\n        System.out.println(\"Lectura\\n\");\n        lecturaLenta();\n        lecturaRapida();\n        System.out.println(\"\");\n        System.out.println(\"Impresión \\n\");\n        impresionNormal();\n        impresionConFormato();\n    }\n\n    static void lecturaLenta() {\n        //Objeto lector\n        Scanner sc = new Scanner(System.in);\n        //Lectura con tipo especificado\n        numeroentero = sc.nextInt();\n        numeroenterolargo = sc.nextLong();\n        numerodecimal = sc.nextFloat();\n        numerodecimallargo = sc.nextDouble();\n        caracter = sc.next().charAt(0);\n        cadena = sc.next();\n        bits = sc.nextByte();\n    }\n    static void lecturaRapida() throws IOException {\n        //Objeto lector\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        //Lectura como cadena y conversión a tipo\n        numeroentero = Integer.parseInt(br.readLine());\n        numeroenterolargo = Long.parseLong(br.readLine());\n        numerodecimal = Float.parseFloat(br.readLine());\n        numerodecimallargo = Double.parseDouble(br.readLine());\n        caracter = br.readLine().charAt(0);\n        cadena = br.readLine();\n        bits = Byte.parseByte(br.readLine());\n    }\n\n    static void impresionNormal() {\n        System.out.println(numeroentero);\n        System.out.println(numeroenterolargo);\n        System.out.println(numerodecimal);\n        System.out.println(numerodecimallargo);\n        System.out.println(caracter);\n        System.out.println(cadena);\n        System.out.println(bits);\n    }\n\n    static void impresionConFormato() {\n        //Se especifica el tipo de dato o la forma en que se imprimira\n        System.out.printf(\"%d \\n\", numeroentero);\n        System.out.printf(\"%d \\n\", numeroenterolargo);\n        System.out.printf(\"%f \\n\", numerodecimal);\n        System.out.printf(\"%e \\n\", numerodecimal);\n        System.out.printf(\"%f \\n\", numerodecimallargo);\n        System.out.printf(\"%e \\n\", numerodecimallargo);\n        System.out.printf(\"%s \\n\", caracter);\n        System.out.printf(\"%s \\n\", cadena);\n        System.out.printf(\"%s \\n\", bits);\n    }\n}\n",
    "cpp": "//Unicas 2 librerias que se usan en c++ (Contienen todas)\n#include<bits/stdc++.h>\n#include<cstdlib>\nusing namespace std;\n//variables globales\nint numeroentero;\nlong numeroenterolargo;\nfloat numerodecimal;\ndouble numerodecimallargo;\nchar caracter;\nstring cadena;\n\nvoid lecturaLenta() {\n        //Lectura con tipo especificado\n        cin>>numeroentero;\n        cin>>numeroenterolargo;\n        cin>>numerodecimal;\n        cin>>numerodecimallargo;\n        cin>>caracter;\n        cin>>cadena;\n}\nvoid lecturaRapida() {\n        //Lectura como cadena y conversión a tipo (En c++ & es necesario)\n        scanf(\"%d\",&numeroentero);\n        scanf(\"%lld\",&numeroenterolargo);\n        scanf(\"%f\",&numerodecimal);\n        scanf(\"%lf\",&numerodecimallargo);\n        scanf(\"%s\",&caracter);\n        scanf(\"%s\",cadena.c_str());\n}\nvoid impresionNormal() {\n        cout<<numeroentero<<endl;\n        cout<<numeroenterolargo<<endl;\n        cout<<numerodecimal<<endl;\n        cout<<numerodecimallargo<<endl;\n        cout<<caracter<<endl;\n        cout<<cadena<<endl;\n}\n void impresionConFormato() {\n        //Se especifica el tipo de dato o la forma en que se imprimira\n        printf(\"%d \\n\",numeroentero);\n        printf(\"%lld \\n\",numeroenterolargo);\n        printf(\"%f \\n\",numerodecimal);\n        printf(\"%e \\n\",numerodecimal);\n        printf(\"%lf \\n\",numerodecimallargo);\n        printf(\"%e \\n\",numerodecimallargo);\n        printf(\"%c \\n\",caracter);\n        printf(\"%s \\n\",cadena.c_str());\n}\n        \nint main (int argc, char *argv[]) {\n        cout<<\"Lectura\\n\"<<endl;\n        lecturaLenta();\n        cout<<\"Impresión \\n\"<<endl;\n        impresionNormal();\n        cout<<endl;\n        cout<<\"Lectura\\n\"<<endl;\n        lecturaRapida();\n        cout<<\"Impresión \\n\"<<endl;\n        impresionConFormato();\n        return 0;\n}     \n",
    "py": "#Los comentarios en Python se usa el # (Numeral)\n#variables globales\n#la identación define el orden\nnumeroentero = int(0)\nnumeroenterolargo = int(0)\nnumerodecimal = float(0)\nnumerodecimallargo = float(0)\ncaracter = ''\ncadena = \"\"\nprint(\"Lectura\")\n#Lectura con tipo especificado\nnumeroentero = int(input())\nnumeroenterolargo = int(input())\nnumerodecimal = float(input())\nnumerodecimallargo = float(input())\ncaracter = input()\ncadena = str(input())\nprint(\"Impresión\")\nprint(numeroentero)\nprint(numeroenterolargo)\nprint(numerodecimal)\nprint(numerodecimallargo)\nprint(caracter)\nprint(cadena)\nprint(\"Impresión formateada\")\n#Se especifica el tipo de dato o la forma en que se imprimira\n#obligatorio usar el % \nprint(\"%d\" % numeroentero)\nprint(\"%d\" % numeroenterolargo)\nprint(\"%f\" % numerodecimal)\nprint(\"%e\" % numerodecimal)\nprint(\"%f\" % numerodecimallargo)\nprint(\"%e\" % numerodecimallargo)\nprint(\"%c\" % caracter)\nprint(\"%s\" % cadena)\n",
    "orden": 0,
    "suborden": 99,
    "fecha_creacion": "2020-12-06 20:56:43",
    "fecha_modificacion": "2020-12-06 20:59:24"
  },
  {
    "ID": 272,
    "supergrupo": "Teoria",
    "tema": "Condicionales y ciclos",
    "texto": "Un condicional, como su nombre lo indica, es una condición para discernir entre una opción u otra, y en el proceso mental normalmente se manifiesta con un “Si”; por ejemplo: Si va a llover, coja el paraguas. Sintácticamente, IF es la palabra reservada para desencadenar el poder de los condicionales en el código. ELSE expresa “en el caso contrario”. Siguiendo con el ejemplo anterior de la lluvia: if va a llover coja el paraguas else coja el vestido de baño.\n\nUn bucle o ciclo, en programación, es una secuencia que ejecuta repetidas veces un trozo de código, hasta que la condición asignada a dicho bucle deja de cumplirse. Los tres bucles más utilizados en programación son el bucle while, el bucle for y el bucle do-while.\n",
    "complejidad_tiempo": "Ejemplo de entrada\n5\n",
    "java": "import java.util.Scanner;\n\npublic class CondicionalesCiclos {\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        //Lectura \n        int numero = sc.nextInt();\n        //Estructura de un condicional\n        //Dentro el parentesis va la condicion a revisar\n        //Si se cumple se realiza las siguientes lineas\n        //En caso contrario pasa al else \n        //y se realiza las lineas siguientes del else\n        if (numero % 2 == 0) {\n            System.out.println(\"Es par\");\n        } else {\n            System.out.println(\"Es impar\");\n        }\n        System.out.println(\"\");\n        System.out.println(\"Ciclo for \");\n        // variable iteradora, condicion , acumulador\n        for (int i = 0; i < 10; i++) {\n            System.out.println(i);\n        }\n        System.out.println(\"Ciclo while\");\n        //Variable, condicion, al final acumulador\n        int acumulador = 0;\n        while (acumulador < 10) {\n            System.out.println(acumulador);\n            acumulador++;\n\n        }\n        System.out.println(\"Ciclo do while\");\n        //Haga hasta que una condición se cumpla\n        acumulador = 0;\n        do {\n            System.out.println(acumulador);\n            acumulador++;\n        } while (acumulador < 10);\n        System.out.println(\"Ciclo for each\");\n        //Iterar entre todos los elementos que tenga una estructura\n        //Sin importar el tamaño \n        int numeros[] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 0};\n        for (int o : numeros) {\n            System.out.println(o);\n        }\n\n    }\n\n}\n",
    "cpp": "#include<bits/stdc++.h>\n#include<cstdlib>\nusing namespace std;\n\nint main(int argc, char *argv[]) {\n    int número;\n    cin>>número;\n    //Estructura de un condicional\n    //Dentro el parentesis va la condicion a revisar\n    //Si se cumple se realiza las siguientes lineas\n    //En caso contrario pasa al else \n    //y se realiza las lineas siguientes del else\n    if (número % 2 == 0) {\n        cout << \"Es par\" << endl;\n    } else {\n        cout << \"Es impar\" << endl;\n    }\n    cout << endl;\n    cout << \"Ciclo for \" << endl;\n    // variable iteradora, condicion , acumulador\n    for (int i = 0; i < 10; i++) {\n        cout << i << endl;\n    }\n    cout << \"Ciclo while\" << endl;\n    //Variable, condicion, al final acumulador\n    int acumulador = 0;\n    while (acumulador < 10) {\n        cout << acumulador << endl;\n        acumulador++;\n    }\n    cout << \"Ciclo do while\" << endl;\n    //Haga hasta que una condición se cumpla\n    acumulador = 0;\n    do {\n        cout << acumulador << endl;\n        acumulador++;\n    } while (acumulador < 10);\n    cout << \"Ciclo for each\" << endl;\n    //Iterar entre todos los elementos que tenga una estructura\n    //Sin importar el tamaño \n    int números[] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 0};\n    for (int o : números) {\n        cout << o << endl;\n    }\n    return 0;\n}\n",
    "py": "numero = 0;\nnumero = int(input())\n#Estructura de un condicional\n#Dentro el parentesis va la condicion a revisar\n#Si se cumple se realiza las siguientes lineas\n#En caso contrario pasa al else \n#y se realiza las lineas siguientes del else\nif (numero % 2 == 0):\n    print(\"Es par\")\nelse: \n    print(\"Es impar\")\nprint(\"Ciclo for \")\n#variable iteradora, rango inicio,final\nfor i in range (0, 10):\n    print(i)\nprint(\"Ciclo while\")\n#Variable, condicion, al final acumulador\nacumulador = 0;\nwhile (acumulador < 10):\n    print(acumulador)\n    acumulador = acumulador + 1;\nprint(\"Ciclo for each\")\n#Iterar entre todos los elementos que tenga una estructura\n#Sin importar el tamaño \nnumeros = [1, 2, 3, 4, 5, 6, 7, 8, 9, 0]\nfor o in numeros:\n    print(o)\n",
    "orden": 0,
    "suborden": 99,
    "fecha_creacion": "2020-12-06 20:56:43",
    "fecha_modificacion": "2020-12-06 20:59:24"
  },
  {
    "ID": 273,
    "supergrupo": "Teoria",
    "tema": "Conversiones, parseos, y casteos de variables",
    "texto": "El casting consiste en la conversión de tipos de datos similares (compatibles) entre sí, generalmente a través de la herencia.\nPor otra parte, el parsing consiste en analizar el formato de una sentencia de texto, y obtener información si el formato es correcto.\n",
    "complejidad_tiempo": null,
    "java": "import java.math.BigDecimal;\nimport java.math.BigInteger;\n\npublic class Main {\n\n    public static void main(String[] args) {\n        int enteropequenio = 5;\n        long enterogrande = 100L;\n        float decimalpequenio = 3.4f;\n        double decimalgrande = 3.4;\n        String cadena = \"125\";\n        char numerosolitario = '7';\n        boolean booleano = true;\n        // conversión a string\n        System.out.println(\"------------A String----------\");\n        System.out.println(Integer.toString(enteropequenio));\n        System.out.println(Long.toString(enterogrande));\n        System.out.println(Float.toString(decimalpequenio));\n        System.out.println(Double.toString(decimalgrande));\n        System.out.println(Character.toString(numerosolitario));\n        System.out.println(Boolean.toString(booleano));\n        // parseo de string a entero\n        System.out.println(\"------------A números----------\");\n        int basedeentrada = 10;\n        System.out.println(Integer.parseInt(cadena, basedeentrada));\n        System.out.println(Long.parseLong(cadena, basedeentrada));\n        System.out.println(Float.parseFloat(cadena));\n        System.out.println(Double.parseDouble(cadena));\n        System.out.println(Character.valueOf(cadena.charAt(0)));\n        System.out.println(Boolean.parseBoolean(\"true\"));\n        // casteo a entero\n        System.out.println(\"------------A int----------\");\n        System.out.println((int) enterogrande);\n        System.out.println((int) decimalpequenio);\n        System.out.println((int) decimalgrande);\n        System.out.println((int) numerosolitario);\n        System.out.println((int) (booleano ? 1 : 0));\n        //casteo a long\n        System.out.println(\"------------A long----------\");\n        System.out.println((long) enteropequenio);\n        System.out.println((long) decimalpequenio);\n        System.out.println((long) decimalgrande);\n        System.out.println((long) numerosolitario);\n        System.out.println((long) (booleano ? 1 : 0));\n        // casteo a float\n        System.out.println(\"------------A float----------\");\n        System.out.println((float) enteropequenio);\n        System.out.println((float) enterogrande);\n        System.out.println((float) decimalgrande);\n        System.out.println((float) numerosolitario);\n        System.out.println((float) (booleano ? 1 : 0));\n        // casteo a double\n        System.out.println(\"------------A double----------\");\n        System.out.println((double) enteropequenio);\n        System.out.println((double) enterogrande);\n        System.out.println((double) decimalpequenio);\n        System.out.println((double) numerosolitario);\n        System.out.println((double) (booleano ? 1 : 0));\n        // casteo a char \n        System.out.println(\"------------A char----------\");\n        System.out.println((char) enteropequenio);\n        System.out.println((char) enterogrande);\n        System.out.println((char) decimalpequenio);\n        System.out.println((char) numerosolitario);\n        System.out.println((char) (booleano ? 1 : 0));\n        //biginteger y big decimal (SOLO JAVA)\n        System.out.println(\"------------bigdecimal y big integer----------\");\n        BigInteger numeroenorme = new BigInteger(cadena);\n        //mientras quepa en la variable\n        int cambio = numeroenorme.intValue();\n        BigDecimal decimalenorme = new BigDecimal(cadena);\n        //mientras quepa en la variable\n        double cambio2 = decimalenorme.doubleValue();\n        System.out.println(cambio);\n        System.out.println(cambio2);\n    }\n}\n",
    "cpp": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long int ll;\n\nint main() {\n    int enteropequenio = 5;\n    ll enterogrande = 100LL;\n    float decimalpequenio = 3.4f;\n    double decimalgrande = 3.4;\n    string cadena = \"125\";\n    char numerosolitario = '7';\n    bool booleano = true;\n    string cast;\n    // conversión a string\n    printf(\"------------A String----------\\n\");\n    cast.push_back(numerosolitario);\n    printf(\"%s\\n\", to_string(enteropequenio).c_str());\n    printf(\"%s\\n\", to_string(enterogrande).c_str());\n    printf(\"%s\\n\", to_string(decimalpequenio).c_str());\n    printf(\"%s\\n\", to_string(decimalgrande).c_str());\n    printf(\"%s\\n\", cast.c_str());\n    printf(\"%s\\n\", to_string(booleano).c_str());\n    printf(\"------------A Numero----------\\n\");\n    printf(\"%d\\n\", stoi(cadena));\n    printf(\"%lld\\n\", stoll(cadena));\n    printf(\"%f\\n\", stof(cadena));\n    printf(\"%f\\n\", stof(cadena));\n    printf(\"%c\\n\", (cadena[0]));\n    printf(\"%d\\n\", stoi(to_string(booleano).c_str()));\n    printf(\"------------A int----------\\n\");\n    printf(\"%d\\n\", (int) enterogrande);\n    printf(\"%d\\n\", (int) decimalpequenio);\n    printf(\"%d\\n\", (int) decimalgrande);\n    printf(\"%d\\n\", (int) numerosolitario);\n    printf(\"%d\\n\", (int) (booleano ? 1 : 0));\n    printf(\"------------A Long----------\\n\");\n    printf(\"%lld\\n\", (ll) enteropequenio);\n    printf(\"%lld\\n\", (ll) decimalpequenio);\n    printf(\"%lld\\n\", (ll) decimalgrande);\n    printf(\"%lld\\n\", (ll) numerosolitario);\n    printf(\"%lld\\n\", (ll) (booleano ? 1 : 0));\n    printf(\"------------A Float----------\\n\");\n    printf(\"%f\\n\", (float) enteropequenio);\n    printf(\"%f\\n\", (float) enteropequenio);\n    printf(\"%f\\n\", (float) decimalgrande);\n    printf(\"%f\\n\", (float) numerosolitario);\n    printf(\"%f\\n\", (float) (booleano ? 1 : 0));\n    // casteo a char\n    printf(\"------------A char----------\\n\");\n    printf(\"%c\\n\", (char) enteropequenio);\n    printf(\"%c\\n\", (char) enterogrande);\n    printf(\"%c\\n\", (char) decimalpequenio);\n    printf(\"%c\\n\", (char) numerosolitario);\n    printf(\"%c\\n\", (char) (booleano ? 1 : 0));\n}\n",
    "py": "entero = 5\ndecimal = 3.4\ncadena = '125'\nnumsolitario = '7'\nbooleano = True\n\n\n# Conversion a Cadena\nprint('-------------- A String -------------')\nprint(str(entero))\nprint(str(decimal))\nprint(str(numsolitario))\nprint(str(booleano))\n\n# Conversion Cadena a Numero\nprint('---------- Cadena a Numero ----------')\nprint(int(cadena))\nprint(int(cadena[0]))\nprint(float(cadena))\nprint(bool(booleano))\n\n# Conversion a Entero\nprint('--------------- A Int ---------------')\nprint(int(decimal))\nprint(ord(numsolitario))\nprint(int(booleano))\n\n# Conversion a Decimal\nprint('-------------- A Float --------------')\nprint(float(entero))\nprint(float(cadena))\nprint(float(numsolitario))\nprint(float(booleano))\n\n# Conversion a Caracter\nprint('-------------- A Char ---------------')\nprint(chr(65))\nprint(chr(100))\n",
    "orden": 0,
    "suborden": 99,
    "fecha_creacion": "2020-12-06 20:56:44",
    "fecha_modificacion": "2020-12-06 20:59:24"
  },
  {
    "ID": 274,
    "supergrupo": "Teoria",
    "tema": "String Matching y expresiones regulares",
    "texto": "Una expresión regular, o expresión racional, es una secuencia de caracteres que conforma un patrón de búsqueda. También son conocidas como regex por su contracción de las palabras inglesas regular expression. Son principalmente utilizadas para la búsqueda de patrones de cadenas de caracteres u operaciones de sustituciones.\nLógicos: \n• x|y: x o y\n• xy: x seguido de y\n• (): Agrupación \nIntervalos de caracteres:\n• [abc]: Cualquiera de los caracteres entre corchetes. Pueden especificarse rangos, por ejemplo ([a-d] que equivale a [abcd]).\n• [^abc]: Cualquier carácter que no esté entre los corchetes.\n• [a-zA-Z]: a a la z o A a la Z (Rango).\n• [a-z&&[def]]: d,e, o f (Intersección)\n• [a-b&&[^bc]]: (Substracción)\nIntervalos de caracteres predefinidos:\n• .: Cualquier carácter individual, salvo el de salto de línea\n• \\d: Cualquier carácter de digito, equivalente a [0-9]\n• \\D: Cualquier carácter que no sea del digito, equivalente a [^0-9]\n• \\s: Cualquier carácter individual de espacio en blanco (Espacios, tabulaciones, saltos de página o saltos de línea)\n• \\S: Cualquier carácter individual que no sea un espacio en blanco\n• \\w: Cualquier carácter alfanumérico\n• \\W: Cualquier carácter que no sea alfanumérico\n",
    "complejidad_tiempo": null,
    "java": null,
    "cpp": null,
    "py": null,
    "orden": 0,
    "suborden": 99,
    "fecha_creacion": "2020-12-06 20:56:44",
    "fecha_modificacion": "2020-12-06 20:59:24"
  },
  {
    "ID": 275,
    "supergrupo": "Teoria",
    "tema": "Lectura especializada y alta velocidad de procesamiento",
    "texto": "Existen ejercicios dentro de programación competitiva en los cuales la cantidad de entradas es tan grande que usar los medios convencionales de lectura el algoritmo no es lo suficientemente rápido, retornando un Time Limit Exceeded (Tiempo límite excedido), es decir la solución no se encuentra lo suficientemente optimizada o no es lo suficientemente rápida, en este capítulo presentamos nuevas formas de lectura y procesamiento de entradas que pueden ayudarnos a resolver este problema.",
    "complejidad_tiempo": null,
    "java": "JAVA Fast Reader\n// FastReader (Lectura rapida con tokenizer)\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.StringTokenizer;\n\npublic class Main {\n\n    static class FastReader {\n\n        BufferedReader br;\n        StringTokenizer st;\n\n        public FastReader() {\n            br = new BufferedReader(new InputStreamReader(System.in));\n        }\n\n        String next() {\n            while (st == null || !st.hasMoreElements()) {\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n\n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        double nextDouble() {\n            return Double.parseDouble(next());\n        }\n\n        String nextLine() {\n            String str = \"\";\n            try {\n                str = br.readLine();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            return str;\n        }\n    }\n\n    public static void main(String[] args) {\n        FastReader s = new FastReader();\n        int n = s.nextInt();\n        int k = s.nextInt();\n        int count = 0;\n        while (n-- > 0) {\n            int x = s.nextInt();\n            if (x % k == 0) {\n                count++;\n            }\n        }\n        System.out.println(count);\n    }\n}\nJAVA UltraReader\n(Puede fallar en algunos juzgadores)\n// UltraReader (Lectura ultra rapida usando streams y buffers)\n\nimport java.io.DataInputStream;\nimport java.io.FileInputStream;\nimport java.io.IOException;\n\npublic class Main {\n\n    static class UltraReader {\n\n        final private int BUFFER_SIZE = 1 << 16;\n        private DataInputStream din;\n        private byte[] buffer;\n        private int bufferPointer, bytesRead;\n\n        public UltraReader() {\n            din = new DataInputStream(System.in);\n            buffer = new byte[BUFFER_SIZE];\n            bufferPointer = bytesRead = 0;\n        }\n\n        public UltraReader(String file_name) throws IOException {\n            din = new DataInputStream(new FileInputStream(file_name));\n            buffer = new byte[BUFFER_SIZE];\n            bufferPointer = bytesRead = 0;\n        }\n\n        public String readLine() throws IOException {\n            byte[] buf = new byte[64]; // line length \n            int cnt = 0, c;\n            while ((c = read()) != -1) {\n                if (c == '\\n') {\n                    break;\n                }\n                buf[cnt++] = (byte) c;\n            }\n            return new String(buf, 0, cnt);\n        }\n\n        public int nextInt() throws IOException {\n            int ret = 0;\n            byte c = read();\n            while (c <= ' ') {\n                c = read();\n            }\n            boolean neg = (c == '-');\n            if (neg) {\n                c = read();\n            }\n            do {\n                ret = ret * 10 + c - '0';\n            } while ((c = read()) >= '0' && c <= '9');\n\n            if (neg) {\n                return -ret;\n            }\n            return ret;\n        }\n\n        public long nextLong() throws IOException {\n            long ret = 0;\n            byte c = read();\n            while (c <= ' ') {\n                c = read();\n            }\n            boolean neg = (c == '-');\n            if (neg) {\n                c = read();\n            }\n            do {\n                ret = ret * 10 + c - '0';\n            } while ((c = read()) >= '0' && c <= '9');\n            if (neg) {\n                return -ret;\n            }\n            return ret;\n        }\n\n        public double nextDouble() throws IOException {\n            double ret = 0, div = 1;\n            byte c = read();\n            while (c <= ' ') {\n                c = read();\n            }\n            boolean neg = (c == '-');\n            if (neg) {\n                c = read();\n            }\n\n            do {\n                ret = ret * 10 + c - '0';\n            } while ((c = read()) >= '0' && c <= '9');\n\n            if (c == '.') {\n                while ((c = read()) >= '0' && c <= '9') {\n                    ret += (c - '0') / (div *= 10);\n                }\n            }\n\n            if (neg) {\n                return -ret;\n            }\n            return ret;\n        }\n\n        private void fillBuffer() throws IOException {\n            bytesRead = din.read(buffer, bufferPointer = 0, BUFFER_SIZE);\n            if (bytesRead == -1) {\n                buffer[0] = -1;\n            }\n        }\n\n        private byte read() throws IOException {\n            if (bufferPointer == bytesRead) {\n                fillBuffer();\n            }\n            return buffer[bufferPointer++];\n        }\n\n        public void close() throws IOException {\n            if (din == null) {\n                return;\n            }\n            din.close();\n        }\n    }\n\n    public static void main(String[] args) throws IOException {\n        UltraReader s = new UltraReader();\n        int n = s.nextInt();\n        int k = s.nextInt();\n        int count = 0;\n        while (n-- > 0) {\n            int x = s.nextInt();\n            if (x % k == 0) {\n                count++;\n            }\n        }\n        System.out.println(count);\n    }\n}\n",
    "cpp": "C++ cin optimizado\n#include <bits/stdc++.h> \nusing namespace std; \n  \nint main() \n{ \n    // Se agregan las dos lineas de abajo permitiendo que CIN tenga la\n    //velocidad de SCANF\n    ios_base::sync_with_stdio(false); \n    cin.tie(NULL);     \n    int n, k, t; \n    int cnt = 0; \n    cin >> n >> k; \n    for (int i=0; i<n; i++) \n    { \n        cin >> t; \n        if (t % k == 0) \n            cnt++; \n    } \n    cout << cnt << \"\\n\"; \n    return 0; \n} \nC++ INT FastScan\n//Lectura rapida de numeros enteros (Solo valido para int)\n#include <bits/stdc++.h> \nusing namespace std;\n\nvoid fastscan(int &number) {\n    //Variable para indicar el signo del número\n    bool negative = false;\n    register int c;\n    number = 0;\n    // Extraer el caracter actual de buffer\n    c = getchar();\n    if (c == '-') {\n        // El numero es negativo\n        negative = true;\n        //Extraer el siguiente caracter del buffer\n        c = getchar();\n    }\n    //se sigue extrayendo caracteres si son enteros\n    // es decir su valor de ASCII esta entre '0'(48) y '9' (57)  \n    for (; (c > 47 && c < 58); c = getchar())\n        number = number * 10 + c - 48;\n    //si la entrada escaneada tiene signo negativo\n    //se niega el valor del numero \n    if (negative)\n        number *= -1;\n}\n\nint main() {\n    int number;\n    fastscan(number);\n    cout << number << \"\\n\";\n    return 0;\n} \n",
    "py": "PYTHON FastInOut\n# Se importa los modulos de lectura y escritura estandar \nfrom sys import stdin\nfrom sys import stdout\n# Entrada de toda la linea\nn = stdin.readline() \n# Llenando una lista por medio de entrada de toda la linea\narr = [int(x) for x in stdin.readline().split()] \n#Inicializamos variable\nsummation = 0\n# Calcular sum\nfor x in arr: \n    summation += x \n# imprimir respuesta a través de write, \n# el método write escribe solo strings\n# por lo que necesitamos convertir cualquier \n# dato en string para usarlo\nstdout.write(str(summation)) \nPYTHON números en una sola línea\n#Lectura de multiples numeros que estan en una misma linea\nimport sys \ndef get_ints(): return map(int, sys.stdin.readline().strip().split()) \na,b,c,d = get_ints() \n\n",
    "orden": 0,
    "suborden": 99,
    "fecha_creacion": "2020-12-06 20:56:44",
    "fecha_modificacion": "2020-12-06 20:59:24"
  },
  {
    "ID": 276,
    "supergrupo": "Teoria",
    "tema": "Importancia de las pruebas en la programación competitiva",
    "texto": "Aunque la práctica es la única forma de garantizar un mayor rendimiento en los concursos de programación, tener algunos trucos bajo la manga garantiza la optimización y una depuración rápida.\nMuchas veces al resolver problemas, enfrentamos problemas como el Tiempo límite excedido (Time limit Exceeded), la solución incorrecta (Wrong answer), el error de tiempo de ejecución (Runtime Error) y el límite de memoria excedido (Memory limit exceded) porque después de diseñar el algoritmo no probamos la eficiencia, la corrección, la complejidad del tiempo y la ejecución del algoritmo en un gran conjunto de entradas para fines de prueba.\nAquí es donde las pruebas de estrés vienen al rescate. La prueba de esfuerzo es la forma común de encontrar el error en un algoritmo.\nLas pruebas de esfuerzo ayudan a encontrar un algoritmo eficiente y a corregir los problemas que puedan presentar los algoritmos, pero también ven por qué ciertos enfoques no funcionan. En particular, es fácil esbozar soluciones codiciosas intuitivas a cualquier problema, pero tales soluciones a menudo no funcionan en la realidad.\n• Busque el caso más sencillo del ejercicio y pruébelo\n• Busque un caso intermedio y pruébelo\n• Busque el caso más grande (Según las restricciones del ejercicio) y pruébelo.\n• Compruebe si los resultados son los correctos, en caso de que no, realice una depuración paso a paso para verificar en que línea de código ha fallado el algoritmo.\n• Si luego de estos pasos no logra resolver el problema, pruebe otro enfoque desde el principio\n• No se desespere si no logra encontrar el error, la paciencia permite mejor flujo de ideas.\n",
    "complejidad_tiempo": null,
    "java": null,
    "cpp": null,
    "py": null,
    "orden": 0,
    "suborden": 99,
    "fecha_creacion": "2020-12-06 20:56:45",
    "fecha_modificacion": "2020-12-06 20:59:24"
  },
  {
    "ID": 277,
    "supergrupo": "Teoria",
    "tema": "Ejercicios iniciales ",
    "texto": "Aquí podremos encontrar ejercicios de programación competitiva de nivel básico, realícelos con el fin de familiarizarse con ellos, puede usar traductor para entenderlos, pero procure realizarlos por mérito propio, luego de varios intentos, puede investigar la solución de los mismos en su buscador de confianza.\nPara buscar la página de los ejercicios de CodeChef, utilice el siguiente link y cambie los “???” por el alias del ejercicio:\n\n \nhttps://www.codechef.com/problems/???\n \n1. FLOW002 \n2. FLOW006 \n3. START01 \n4. FLOW001 \n5. INTEST \n",
    "complejidad_tiempo": null,
    "java": null,
    "cpp": null,
    "py": null,
    "orden": 0,
    "suborden": 99,
    "fecha_creacion": "2020-12-06 20:56:45",
    "fecha_modificacion": "2020-12-06 20:59:24"
  },
  {
    "ID": 1,
    "supergrupo": "Búsquedas",
    "tema": "Binary Search",
    "texto": "<div style=\"text-align: justify;\"><span style=\"font-size: 10pt;\">La búsqueda binaria, también conocida como búsqueda de intervalo medio o búsqueda logarítmica, es un algoritmo de búsqueda que encuentra la posición de un valor en un arreglo ordenado. Compara el valor con el elemento en el medio del arreglo, si no son iguales, la mitad en la cual el valor no puede estar es eliminada y la búsqueda sigue en la mitad restante hasta que el valor se encuentre.&nbsp;</span></div><div style=\"text-align: justify;\"><span style=\"font-size: 10pt;\"><br></span></div><div style=\"text-align: justify;\"><span style=\"font-size: 10pt;\">La búsqueda binaria es computada en el peor de los casos en un tiempo logarítmico, realizando  O (log n)  comparaciones, donde n es el número de elementos del arreglo y log es el logaritmo.</span></div>",
    "complejidad_tiempo": "Mejor caso :    O(1)            Peor caso :      O(log n)             Promedio: O(log n)",
    "java": "// Implementación Java de una búsqueda binaria recursiva \n\npublic class BinarySearch {\n    /*Retorna el indice de x si se encuentra presente\n    en arr[1,2,....r]*, si no retorna -1*/\n    static int binarySearch(int arr[], int l, int r, int x) {\n        if (r >= l) {\n            int mid = l + (r - l) / 2;\n            /*Si el elemento esta presente en el medio*/\n            if (arr[mid] == x) {\n                return mid;\n            }\n            /*Si el elemento es más pequeño que la mitad\n            entonces solo puede estar presente en el \n            subarreglo izquierdo*/\n            if (arr[mid] > x) {\n                return binarySearch(arr, l, mid - 1, x);\n            }\n            //Si no el elemento solo pued estar presente \n            //en el subarreglo derecho \n            return binarySearch(arr, mid + 1, r, x);\n        }\n        //Si llegamos aqui, el elemento no esta presente\n        //en el arreglo\n        return -1;\n    }\n\n    public static void main(String args[]) {\n        int arr[] = {2, 3, 4, 10, 40};\n        int n = arr.length;\n        int x = 10;\n        int result = binarySearch(arr, 0, n - 1, x);\n        if (result == -1) {\n            System.out.println(\"Elemento no presente\");\n        } else {\n            System.out.println(\"Element encontrado en la posición \" + result);\n        }\n    }\n}\n",
    "cpp": "#include <bits/stdc++.h>\n#include <cstdlib>\n\nint binarysearch(int arr[], int l, int r, int x) {\n    if (r >= l) {\n        int mid = l + (r - 1) / 2;\n        if (arr[mid] == x) {\n            return mid;\n        }\n        if (arr[mid] > x) {\n            return binarysearch(arr, l, mid - 1, x);\n        } else {\n            return binarysearch(arr, mid + 1, r, x);\n        }\n    }\n    return -1;\n}\n\nint main() {\n    int arr[] = {2, 3, 4, 5, 6};\n    int n = sizeof (arr) / sizeof (arr[0]);\n    int x = 5;\n    int resultado = binarysearch(arr, 0, n - 1, x);\n    if (resultado == -1) {\n        printf(\"elemento no presente\");\n    } else {\n        printf(\"elemento encontrado en el indice: %d\", resultado);\n    }\n    return 0;\n}\n",
    "py": "def BinarySearch(arr, inicio, fin, numerobuscado):\n    if(fin >= inicio):\n        medio = int(inicio + (fin-1) / 2)\n        if(arr[medio] == numerobuscado):\n            return medio\n        if(arr[medio] > numerobuscado):\n            return BinarySearch(arr, inicio, medio-1, numerobuscado)\n        else:\n            return BinarySearch(arr, medio + 1, fin, numerobuscado)\n    return -1\n\narr = [1, 2, 3, 4, 5, 6]\ntam = len(arr)\nnumerobuscado = 5\nresultado = int (BinarySearch(arr, 0, tam-1, numerobuscado))\nif(resultado == -1):\n    print(\"Elemento no encontrado\")\nelse:\n    print(\"Elemento encontrado en la posicion\", resultado)\n",
    "orden": 2,
    "suborden": 0,
    "fecha_creacion": "2020-12-02 17:30:29",
    "fecha_modificacion": "2020-12-06 22:47:01"
  },
  {
    "ID": 2,
    "supergrupo": "Búsquedas",
    "tema": "Exponential Search",
    "texto": "<div style=\"text-align: justify;\"><span style=\"font-size: 10pt;\">El nombre de este algoritmo de búsqueda puede ser engañoso, ya que funciona en tiempo O (Log n).&nbsp;</span></div><div style=\"text-align: justify; font-weight: normal;\">El nombre proviene de la forma en que busca un elemento. La búsqueda binaria exponencial es particularmente útil para búsquedas ilimitadas, donde el tamaño del vector es infinito.&nbsp;</div><div style=\"text-align: justify; \"><span style=\"font-weight: bold;\"><br></span></div><div style=\"text-align: justify; \"><span style=\"font-weight: bold;\">La búsqueda exponencial implica dos pasos:&nbsp;</span></div><div style=\"text-align: justify; font-weight: normal;\"><br></div><div style=\"text-align: justify; font-weight: normal;\"><span style=\"white-space:pre\">\t</span>1)  Encuentra el rango donde el elemento está presente&nbsp;</div><div style=\"text-align: justify; font-weight: normal;\"><span style=\"white-space:pre\">\t</span>2)  Hacer una búsqueda binaria en el rango encontrado arriba.&nbsp;</div><div style=\"text-align: justify; font-weight: normal;\"><br></div><div style=\"text-align: justify; font-weight: normal;\">La idea es comenzar con el tamaño del subarreglo 1, comparar su último elemento con x, luego probar el tamaño 2, luego el 4 y así sucesivamente hasta que el último elemento de un subconjunto no sea mayor que el tamaño del vector.\r\nUna vez que encontramos un índice i (después de duplicar repetidamente i), sabemos que el elemento debe estar presente entre i / 2 - i, i / 2 porque se encontró un valor mayor en la iteración anterior.&nbsp;</div><div style=\"text-align: justify; font-weight: normal;\"><br></div><div style=\"text-align: justify; \"><span style=\"font-weight: bold;\">Podemos tener en cuenta que:&nbsp;</span></div><div style=\"text-align: justify; font-weight: normal;\"><br></div><div style=\"text-align: justify; font-weight: normal;\"><span style=\"white-space:pre\">\t</span>- La búsqueda binaria exponencial es particularmente útil para búsquedas ilimitadas, donde el tamaño del vector es infinito.&nbsp;</div><div style=\"text-align: justify; font-weight: normal;\"><span style=\"white-space:pre\">\t</span>- Funciona mejor que la Búsqueda binaria para vectores limitados, y también cuando el elemento a buscar está más cerca del primer elemento.\r\n</div>",
    "complejidad_tiempo": "Mejor caso :    O(1)            Peor caso :      O(log n)             Promedio: O(log n)             ",
    "java": "//Programa Java para encontrar un elemento\n//x en un array ordenado usando Exponential Search\n\nimport java.util.Arrays;\n\npublic class ExponentialSearch {\n\n    /* Retorna posición de la primerra ocurrencia \n    de x en un arreglo*/\n    static int exponentialSearch(int arr[],int n, int x) {\n        // Si z esta presente en la primera localización en si misma\n        if (arr[0] == x) {\n            return 0;\n        }\n        /*Encuentra ranfo para la busqueda binaria\n        por repetidos dobles*/\n        int i = 1;\n        while (i < n && arr[i] <= x) {\n            i = i * 2;\n        }\n        //llama la busqueda binaria para el rango encontrado \n        return Arrays.binarySearch(arr, i / 2,\n                Math.min(i, n), x);\n    }\n\n    public static void main(String args[]) {\n        int arr[] = {2, 3, 4, 10, 40};\n        int x = 10;\n        int result = exponentialSearch(arr, arr.length, x);\n        System.out.println((result < 0)\n                ? \"El elemento no esta presente en el array\"\n                : \"Elemento encontrado en : \"\n                + result);\n    }\n}\n",
    "cpp": "#include <bits/stdc++.h>\n#include <cstdlib>\nusing namespace std;\n\nint binarySearch(int arr[], int l, int r, int x) {\n    if (r >= l) {\n        int mid = l + (r - l) / 2;\n        if (arr[mid] == x) {\n            return mid;\n        }\n        if (arr[mid] > x) {\n            return binarySearch(arr, l, mid - 1, x);\n        } else {\n            return binarySearch(arr, mid + 1, r, x);\n        }\n    }\n\n    return -1;\n}\n\nint exponentialSearch(int arr[], int n, int x) {\n    if (arr[0] == x) {\n        return 0;\n    }\n    int i = 1;\n    while (i < n && arr[i] <= x) {\n        i = i * 2;\n    }\n    return binarySearch(arr, i / 2, min(i, n), x);\n}\n\nint main(int argc, char const *argv[]) {\n    int arr[] = {1, 2, 3, 4, 5};\n    int n = sizeof (arr) / sizeof (arr[0]);\n    int x = 5;\n    int result = exponentialSearch(arr, n, x);\n    if (result < 0) {\n        cout << \"El resultado no esta presente en el Array\" << endl;\n    } else {\n        cout << \"Elemento encontrado en el indice \" << result << endl;\n    }\n\n    return 0;\n}\n",
    "py": "def BinarySearch(arr, inicio, fin, numerobuscado):\n    if(fin>inicio):\n        medio = int((inicio+(fin-1))/2)\n        if(arr[medio] == numerobuscado):\n            return medio\n        if(arr[medio] > numerobuscado):\n            return BinarySearch(arr,inicio,medio-1,numerobuscado)\n        else:\n            return BinarySearch(arr,medio+1,fin,numerobuscado)\n    return -1\n\ndef exponentialSearch(arr,tam,buscado):\n    if(arr[0] == buscado):\n        return 0\n    i = int(1)\n    while (i<tam and arr[i]<=buscado):\n        i = i*2\n    return BinarySearch(arr,i//2,min(i,tam),buscado)\n\nlista = [1,2,3,4,5,6]\nbuscado = int(9)\nresultado = int(exponentialSearch(lista, len(lista), buscado))\nif(resultado < 0):\n    print (\"El elemento no se encuentra dentro del arreglo\")\nelse:\n    print(\"El elemento esta en la posicion:\",resultado)",
    "orden": 2,
    "suborden": 1,
    "fecha_creacion": "2020-12-02 17:30:29",
    "fecha_modificacion": "2020-12-07 02:20:34"
  },
  {
    "ID": 3,
    "supergrupo": "Búsquedas",
    "tema": "Array Max/Min Search",
    "texto": "Tenemos un Array en donde queremos buscar el valor más pequeño y el valor más grande del mismo de forma eficiente haciendo la menor cantidad de comparaciones, para resolver este problema podemos emplear la siguiente aproximación.",
    "complejidad_tiempo": "Mejor caso :    O(n)            Peor caso :      O(n)             Promedio: O(n)             ",
    "java": "/* Programa Java que busca el máximo y el mínimo\nen un array*/\npublic class ArrayMaxMinSearch {\n    /*Clase Pair es usada para retornar\n    dos valores de getMinMax()*/\n    static class Pair {\n        int min;\n        int max;\n    }\n\n    static Pair getMinMax(int arr[], int n) {\n        Pair minmax = new Pair();\n        int i;\n        /*Si es el unico elemento, lo retorna como min y max*/\n        if (n == 1) {\n            minmax.max = arr[0];\n            minmax.min = arr[0];\n            return minmax;\n        }\n        /*Si hay más de un elemento, \n        entones inicializa min y más*/\n        if (arr[0] > arr[1]) {\n            minmax.max = arr[0];\n            minmax.min = arr[1];\n        } else {\n            minmax.max = arr[1];\n            minmax.min = arr[0];\n        }\n        for (i = 2; i < n; i++) {\n            if (arr[i] > minmax.max) {\n                minmax.max = arr[i];\n            } else if (arr[i] < minmax.min) {\n                minmax.min = arr[i];\n            }\n        }\n        return minmax;\n    }\n\n    public static void main(String args[]) {\n        int arr[] = {1000, 11, 445, 1, 330, 3000};\n        int arr_size = 6;\n        Pair minmax = getMinMax(arr, arr_size);\n        System.out.printf(\"\\nEl minimo elemento es %d\", minmax.min);\n        System.out.printf(\"\\nEl maximo elemento es %d\", minmax.max);\n    }\n\n}\n",
    "cpp": "#include <bits/stdc++.h>\n#include <cstdlib>\nusing namespace std;\n\nstruct pairMaxMin {\n    int min;\n    int max;\n};\n\nstatic pairMaxMin getMinMax(int arr[], int n) {\n    pairMaxMin minmax;\n    int i;\n\n    if (n == 1) {\n        minmax.max = arr[0];\n        minmax.min = arr[0];\n        return minmax;\n    }\n    if (arr[0] > arr[1]) {\n        minmax.max = arr[0];\n        minmax.min = arr[1];\n    } else {\n        minmax.max = arr[1];\n        minmax.min = arr[0];\n    }\n    for (i = 2; i < n; i++) {\n        if (arr[i] > minmax.max) {\n            minmax.max = arr[i];\n        } else if (arr[i] < minmax.min) {\n            minmax.min = arr[i];\n        }\n    }\n\n    return minmax;\n}\n\nint main(int argc, char** argv) {\n    int arr[] = {12, 3, 4, 345, 65, 43};\n    int len = sizeof (arr) / sizeof (arr[0]);\n    pairMaxMin minmax = getMinMax(arr, len);\n    printf(\"el minimo elemento es %d\\n\", minmax.min);\n    printf(\"el maximo elemento es %d\\n\", minmax.max);\n    return 0;\n}\n",
    "py": "class Pair:\n    max,min = int(),int()\n\ndef  getmaxmin(lista,n):\n    maxmin = Pair()\n    i = int()\n    if n==1:\n        maxmin.max = lista[0]\n        maxmin.max = lista[0]\n        return maxmin\n    if lista[0]>lista[1]:\n        maxmin.max = lista[0]\n        maxmin.min = lista[1]\n    else:\n        maxmin.max = lista[1]\n        maxmin.min = lista[0]\n    for i in range(2,n):\n        if lista[i]>maxmin.max:\n            maxmin.max = lista[i]\n        elif lista[i]<maxmin.min:\n            maxmin.min = lista[i]\n    return maxmin\n\nlista = [1, 422, 789, 2333, 2444]\nn = len(lista)\nresultado = getmaxmin(lista,n)\nprint(\"El minimo es \",resultado.min)\nprint(\"El maximo es \",resultado.max)\n",
    "orden": 2,
    "suborden": 2,
    "fecha_creacion": "2020-12-02 17:30:29",
    "fecha_modificacion": "2020-12-06 20:04:14"
  },
  {
    "ID": 4,
    "supergrupo": "Búsquedas",
    "tema": "Fibonacci Search",
    "texto": "<div style=\"text-align: justify;\"><span style=\"font-size: 10pt;\">La búsqueda de Fibonacci es una técnica basada en la comparación que utiliza los números de Fibonacci para buscar un elemento en un array ordenado.&nbsp;</span></div><div style=\"text-align: justify; \"><span style=\"font-weight: bold;\">Similitudes con la búsqueda binaria:&nbsp;</span></div><div style=\"text-align: justify; font-weight: normal;\"><span style=\"white-space:pre\">\t</span>- Trabaja con arrays ordenados.</div><div style=\"text-align: justify; font-weight: normal;\"><span style=\"white-space:pre\">\t</span>- Es un algoritmo de dividir y conquistar.</div><div style=\"text-align: justify; font-weight: normal;\"><span style=\"white-space:pre\">\t</span>- Tiene una complejidad de registro y tiempo.&nbsp;</div><div style=\"text-align: justify; \"><span style=\"font-weight: bold;\"><br></span></div><div style=\"text-align: justify; \"><span style=\"font-weight: bold;\">Diferencias con la búsqueda binaria:&nbsp;</span></div><div style=\"text-align: justify; font-weight: normal;\"><span style=\"white-space:pre\">\t</span>- La búsqueda de Fibonacci divide un array dado en partes desiguales&nbsp;</div><div style=\"text-align: justify; font-weight: normal;\"><span style=\"white-space:pre\">\t</span>- La búsqueda binaria usa el operador de división para dividir el rango.&nbsp;</div><div style=\"text-align: justify; font-weight: normal;\"><br></div><div style=\"text-align: justify; \"><span style=\"font-weight: bold;\">Puntos importantes:</span></div><div style=\"text-align: justify; font-weight: normal;\"><span style=\"white-space:pre\">\t</span>- La búsqueda de Fibonacci no usa /, pero usa + y -. El operador de la división puede ser costoso en algunas CPU.&nbsp;</div><div style=\"text-align: justify; font-weight: normal;\"><span style=\"white-space:pre\">\t</span>- La búsqueda de Fibonacci examina elementos relativamente más cercanos en pasos subsiguientes. Por lo tanto, cuando el vector de entrada es grande y no cabe en la memoria caché de la <span style=\"white-space:pre\">\t</span>&nbsp; CPU o incluso en la RAM, la búsqueda de Fibonacci puede ser útil.&nbsp;</div><div style=\"text-align: justify; font-weight: normal;\"><span style=\"white-space:pre\">\t</span>- La idea es encontrar primero el número de Fibonacci más pequeño que sea mayor o igual a la longitud del vector dado.\r\n</div>",
    "complejidad_tiempo": null,
    "java": "// Programa Java para Fibonacci Search  \npublic class FibonacciSearch {\n\n    //Función de utilidad para biscar el minimo\n    //de dos elementos\n    public static int min(int x, int y) {\n        return (x <= y) ? x : y;\n    }\n\n    /* Regresa el indice de x si esta presente, si no retorna -1*/\n    public static int fibonacciSearch(int arr[],\n            int x, int n) {\n        /* Inicializa los números fibonacci*/\n        int fibMMm2 = 0; // (m-2)esimo número fibonacci. \n        int fibMMm1 = 1; // (m-1)esimo número fibonacci. \n        int fibM = fibMMm2 + fibMMm1; // mesimo fibonacci.\n        /* FibM va a ser almacenado como el más pequeño\n        fibonacci más grande o igual a n*/\n        while (fibM < n) {\n            fibMMm2 = fibMMm1;\n            fibMMm1 = fibM;\n            fibM = fibMMm2 + fibMMm1;\n        }\n        // Marca el rango eliminado del frente\n        int offset = -1;\n        /* Si bien hay elementos a inspeccionar.\n        Tenga en cuenta que comparamos arr [fibMm2] con x.\n        Cuando fibM se convierte en 1, fibMm2 se convierte en 0 */\n        while (fibM > 1) {\n            //Revisa si fibMm2 es una ubicación valida\n            int i = min(offset + fibMMm2, n - 1);\n            /*Si x es más grande que el valor\n            en el indice fibMm2, fuera del subarray\n            desde offset a i*/\n            if (arr[i] < x) {\n                fibM = fibMMm1;\n                fibMMm1 = fibMMm2;\n                fibMMm2 = fibM - fibMMm1;\n                offset = i;\n            } \n            /*Si x es más grande que el valor en indice \n            fibMm2, corta el subarreglo despues de i+1*/ \n           else if (arr[i] > x) {\n                fibM = fibMMm2;\n                fibMMm1 = fibMMm1 - fibMMm2;\n                fibMMm2 = fibM - fibMMm1;\n            } /* Elemento encontrado, retorna indice*/ \n     else {\n                return i;\n            }\n        }\n        /* Comparando el ultimo elemento con x*/\n        if (fibMMm1 == 1 && arr[offset + 1] == x) {\n            return offset + 1;\n        }\n        /*Elemento no encontrado, retorna -1*/\n        return -1;\n    }\n\n    public static void main(String[] args) {\n        int arr[] = {10, 22, 35, 40, 45, 50,\n            80, 82, 85, 90, 100};\n        int n = 11;\n        int x = 85;\n        System.out.println(\"Found at index: \"\n                + fibonacciSearch(arr, x, n));\n    }\n}\n",
    "cpp": "#include <bits/stdc++.h>\n#include <cstdlib>\nusing namespace std;\n\nstatic int fibonacciSearch(int arr[], int x, int n) {\n    int fibMMm2 = 0;\n    int fibMMm1 = 1;\n    int fibM = fibMMm2 + fibMMm1;\n    while (fibM < n) {\n        fibMMm2 = fibMMm1;\n        fibMMm1 = fibM;\n        fibM = fibMMm2 + fibMMm1;\n    }\n    int offset = -1;\n    while (fibM > 1) {\n        int i = std::min(offset + fibMMm2, n - 1);\n        if (arr[i] < x) {\n            fibM = fibMMm1;\n            fibMMm1 = fibMMm2;\n            fibMMm2 = fibM - fibMMm1;\n            offset = i;\n        } else if (arr[i] > x) {\n            fibM = fibMMm2;\n            fibMMm1 -= fibMMm2;\n            fibMMm2 = fibM - fibMMm1;\n        } else {\n            return i;\n        }\n    }\n    if (fibM == 1 && arr[offset + 1] == x) {\n        return offset + 1;\n    }\n    return -1;\n}\n\nint main(int argc, char** argv) {\n    //\n    int arr[] = {10, 22, 35, 40, 45, 50, 80, 82, 85, 90, 100};\n    int n = sizeof (arr) / sizeof (arr[0]);\n    int x = 85;\n    printf(\"Encontrado en la posicion %d\", fibonacciSearch(arr, x, n));\n    return 0;\n}\n",
    "py": "def menor(x, y):\n    return min(x, y)\n\ndef FibonacciSearch(lista, x, n):\n    if x > lista[n-1]:\n        return -1\n    Fm2 = int(0)\n    Fm1 = int(1)\n    Fms = int(Fm2 + Fm1)\n    while Fms < n:\n        Fm2 = Fm1\n        Fm1 = Fms\n        Fms = int(Fm2 + Fm1)\n    offset = int(-1)\n    while Fms > 1:\n        i = int(menor(offset + Fm2, n - 1))\n        if lista[i] < x:\n            Fms = Fm1\n            Fm1 = Fm2\n            Fm2 = Fms - Fm1\n            offset = i\n        elif lista[i] > x:\n            Fms = Fm2\n            Fm1 = Fm1 - Fm2\n            Fm2 = Fms - Fm1\n        else:\n            return i\n\n    if Fm1 == 1 and lista[offset + 1] == x:\n        return offset + 1\n    else:\n        return -1\n\n\nlista = [10, 22, 33, 45, 89, 99, 100]\nn = int(len(lista))\nx = int(input())\nif FibonacciSearch(lista, x, n) != -1:\n    print(\"Encontrado en la poscion \", FibonacciSearch(lista, x, n))\nelse:\n    print(\"No encontrado\")\n",
    "orden": 2,
    "suborden": 3,
    "fecha_creacion": "2020-12-02 17:30:29",
    "fecha_modificacion": "2020-12-07 02:20:50"
  },
  {
    "ID": 5,
    "supergrupo": "Búsquedas",
    "tema": "Jump Search",
    "texto": "<div style=\"text-align: justify;\"><span style=\"font-size: 10pt;\">Al igual que Binary Search, Jump Search es un algoritmo de búsqueda para vectores ordenados.&nbsp;</span></div><div style=\"text-align: justify; font-weight: normal;\">La idea básica es verificar menos elementos (que la búsqueda lineal) saltando hacia delante con pasos fijos u salteando algunos elementos en lugar de buscar todos los elementos.\r\nEn el peor de los casos, tenemos que realizar saltos de n / m y, si el último valor verificado es mayor que el elemento a buscar, realizamos comparaciones de m-1 más para la búsqueda lineal.&nbsp;</div><div style=\"text-align: justify; font-weight: normal;\"><br></div><div style=\"text-align: justify; font-weight: normal;\">Por lo tanto, el número total de comparaciones en el peor de los casos será ((n / m) + m-1). El valor de la función ((n / m) + m-1) será mínimo cuando m = ?n. Por lo tanto, el mejor tamaño de paso es m = ?n.</div><div style=\"text-align: justify; font-weight: normal;\"><br></div><div style=\"text-align: justify; \"><span style=\"font-weight: bold;\">Puntos importantes:&nbsp;\r\n</span></div><div style=\"text-align: justify; font-weight: normal;\"><br></div><div style=\"text-align: justify; font-weight: normal;\"><span style=\"white-space:pre\">\t</span>- Trabaja solo arreglos ordenados.&nbsp;</div><div style=\"text-align: justify; font-weight: normal;\"><span style=\"white-space:pre\">\t</span>- El tamaño óptimo de un bloque a saltar es (? n).&nbsp;</div><div style=\"text-align: justify; font-weight: normal;\"><br></div><div style=\"text-align: justify; font-weight: normal;\">Esto hace que la complejidad del tiempo de Jump Search O (? n).&nbsp;</div><div style=\"text-align: justify; font-weight: normal;\"><br></div><div style=\"text-align: justify; font-weight: normal;\">- La complejidad temporal de la búsqueda por salto es entre la búsqueda lineal ((O (n)) y la búsqueda binaria (O (Log n)).&nbsp;</div><div style=\"text-align: justify; font-weight: normal;\">- La búsqueda binaria es mejor que la búsqueda por salto, pero la búsqueda por salto tiene la ventaja de que retrocedemos solo una vez (la búsqueda binaria puede requerir saltos O (Log n), considere una situación en la que el elemento a buscar es el elemento más pequeño o más pequeño que el más pequeño). Entonces, en un sistema donde el salto hacia atrás es costoso, usamos Jump Search.\r\n</div>",
    "complejidad_tiempo": "Mejor caso :    O(? n)            Peor caso :      O(? n)             Promedio: O(? n)             ",
    "java": "public class JumpSearch {\n\n    public static int jumpSearch(int[] arr, int x) {\n        int n = arr.length;\n        //Buscando el tamaño del bloque que sera\n        //saltado\n        int step = (int) Math.floor(Math.sqrt(n));\n        /* Buscando el bloque donde el elemento\n        esta presente (Si esta presente)*/\n        int prev = 0;\n        while (arr[Math.min(step, n) - 1] < x) {\n            prev = step;\n            step += (int) Math.floor(Math.sqrt(n));\n            if (prev >= n) {\n                return -1;\n            }\n        }\n        /*Realizando una busqueda linear para x en \n        el bloque empezando con prev*/\n        while (arr[prev] < x) {\n            prev++;\n            /*Si nosotros alcanzamos el siguiente bloque\n            o el fin del array el elemento no esta presente*/\n            if (prev == Math.min(step, n)) {\n                return -1;\n            }\n        }\n        // Si el elemento fue encontrado\n        if (arr[prev] == x) {\n            return prev;\n        }\n        return -1;\n    }\n\n    public static void main(String[] args) {\n        int arr[] = {0, 1, 1, 2, 3, 5, 8, 13, 21,\n            34, 55, 89, 144, 233, 377, 610};\n        int x = 55;\n        //Encontrar el indice de 'x' usando Jump Search\n        int index = jumpSearch(arr, x);\n        // Imprime el indice donde x fue encontrado\n        System.out.println(\"\\nNúmero \" + x\n                + \" esta en el indice \" + index);\n    }\n}\n",
    "cpp": "#include <bits/stdc++.h>\n#include <cstdlib>\nusing namespace std;\n\nstatic int jumpSearch(int arr[], int x, int n) {\n    int step = int(std::floor(std::sqrt(n)));\n    int prev = 0;\n    while (arr[std::min(step, n) - 1] < x) {\n        prev = step;\n        step += int(std::floor(std::sqrt(n)));\n        if (prev >= n) {\n            return -1;\n        }\n    }\n    while (arr[prev] < x) {\n        prev++;\n        if (prev == std::min(step, n)) {\n            return -1;\n        }\n    }\n    if (arr[prev] == x) {\n        return prev;\n    }\n    return -1;\n\n}\n\nint main(int argc, char const *argv[]) {\n    int arr[] = {1, 2, 3, 4, 5};\n    int n = sizeof (arr) / sizeof (arr[0]);\n    int x = 5;\n    int result = jumpSearch(arr, x, n);\n    if (result < 0) {\n        cout << \"El elemento no esta presente en el Array\" << endl;\n    } else {\n        cout << \"Elemento encontrado en el indice \" << result << endl;\n    }\n\n    return 0;\n}\n",
    "py": "import math\n\ndef jumpSearch(lista, x):\n    tamanio = len(lista)\n    salto = int(math.floor(math.sqrt(tamanio)))\n    previo = int(0)\n    while(lista[min(salto, tamanio)-1] < x):\n        previo = salto\n        salto = salto + int(math.floor(math.sqrt(tamanio)))\n        if(previo >= tamanio):\n            return -1\n    while(lista[previo] < x):\n        previo = previo + 1\n        if(previo == min(salto, tamanio)):\n            return -1\n    if(lista[previo] == x):\n        return previo\n    return -1\n\nlista = [0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144]\nnumeroabuscar = int(input())\nresultado = jumpSearch(lista, numeroabuscar)\nif(resultado == -1):\n    print('No encontrado')\nelse:\n    print('Encontrado en el indice ', resultado)\n",
    "orden": 2,
    "suborden": 4,
    "fecha_creacion": "2020-12-02 17:30:29",
    "fecha_modificacion": "2020-12-07 02:20:57"
  },
  {
    "ID": 6,
    "supergrupo": "Búsquedas",
    "tema": "Minimum Absolute Sum Pair",
    "texto": "<div style=\"text-align: justify;\"><span style=\"font-size: 10pt;\">Teniendo un vector de números, se buscan dos elementos cuya suma es la más cercana a cero.&nbsp;</span></div><div style=\"text-align: justify;\">Para cada elemento de dicho vector encuentre la suma con cada otro elemento del mismo vector y compare las sumas.&nbsp;</div><div style=\"text-align: justify;\"><br></div><div style=\"text-align: justify;\">Por último, devolver la suma mínima encontrada.</div>",
    "complejidad_tiempo": "Mejor caso :    O(n2)            Peor caso :      O(n2)             Promedio: O(n2",
    "java": "//Programa JAVA que busque el par de números\n//que sumados de la minima suma absoluta\n\npublic class MinAbsSumPair {\n//función que busca el par \n\n    static void minAbsSumPair(int arr[], int arr_size) {\n        int l, r, min_sum, sum, min_l, min_r;\n        /*El array debe tener al menos 2 elementos*/\n        if (arr_size < 2) {\n            System.out.println(\"Invalid Input\");\n            return;\n        }\n        /* Inicialización de los valores*/\n        min_l = 0;\n        min_r = 1;\n        min_sum = arr[0] + arr[1];\n        for (l = 0; l < arr_size - 1; l++) {\n            for (r = l + 1; r < arr_size; r++) {\n                sum = arr[l] + arr[r];\n                if (Math.abs(min_sum) > Math.abs(sum)) {\n                    min_sum = sum;\n                    min_l = l;\n                    min_r = r;\n                }\n            }\n        }\n        System.out.println(\" Los dos elementos los cuales \"\n                + \"tienen la suma minima son \"\n                + arr[min_l] + \" y \" + arr[min_r]);\n    }\n\n    public static void main(String[] args) {\n        int arr[] = {1, 60, -10, 70, -80, 85};\n        minAbsSumPair(arr, 6);\n    }\n}\n",
    "cpp": "#include <bits/stdc++.h>\n#include <cstdlib>\nusing namespace std;\n\nvoid minAbsSumPair(int arr[], int n) {\n    int l, r, min_sum, sum, min_l, min_r;\n    if (n < 2) {\n        printf(\"Entrada no valida\");\n    }\n    min_l = 0;\n    min_r = 1;\n    min_sum = arr[0] + arr[1];\n    for (l = 0; l < n - 1; ++l) {\n        for (r = l + 1; r < n; ++r) {\n            sum = arr[l] + arr[r];\n            if (std::abs(min_sum) > std::abs(sum)) {\n                min_sum = sum;\n                min_l = l;\n                min_r = r;\n            }\n        }\n    }\n    printf(\"Los numero que tienen la minima suma son %d %d\", arr[min_l], arr[min_r]);\n}\n\nint main(int argc, char const *argv[]) {\n    int arr[] = {1, -2, -10, 70, -80, 85};\n    int n = sizeof (arr) / sizeof (arr[0]);\n    minAbsSumPair(arr, n);\n    return 0;\n}\n",
    "py": "def minAbsSumPair(arr,n):\n    l,r,min_sum,sum,min_l,min_r = int(),int(),int(),int(),int(),int()\n    if n<2:\n        print(\"Array no tiene suficientes valores\")\n        return\n    min_l = int(0)\n    min_r = int (1)\n    min_sum = arr[0]+arr[1]\n    for l in range(n-1):\n        for r in range(l+1,n):\n            sum = arr[l]+arr[r]\n            if abs(min_sum)>abs(sum):\n                min_sum=sum\n                min_l=l\n                min_r=r\n    print(f\"la minima suma es: {arr[min_l]} y {arr[min_r]}\")\n\narr = [1,60,-10,70,-80,85]\nminAbsSumPair(arr,len(arr))\n",
    "orden": 2,
    "suborden": 5,
    "fecha_creacion": "2020-12-02 17:30:29",
    "fecha_modificacion": "2020-12-06 20:04:16"
  },
  {
    "ID": 7,
    "supergrupo": "Búsquedas",
    "tema": "Missing Number Search",
    "texto": "<div style=\"text-align: justify;\"><span style=\"font-size: 10pt;\">Se le da una lista de n-1 enteros y estos enteros están en el rango de 1 a n. No hay duplicados en la lista pero nos falta uno de los enteros en la lista.\r\nLos pasos para resolver este problema son los siguientes:\r\n1) XOR todos los elementos del array, que el resultado de XOR sea X1.\r\n2) XOR todos los números del 1 al n, sea XOR sea X2.\r\n3) XOR de X1 y X2 da el número que falta, es decir el resultado.</span></div>",
    "complejidad_tiempo": "Mejor caso :    O(n)            Peor caso :      O(n)             Promedio: O(n)             ",
    "java": "public class MissingNo {\n\n    public static void main(String[] args) {\n        int[] arr = {1,2,3,5,6,7,8};\n        int missed = getMissingNo(arr, arr.length);\n        System.out.println(\"el numero que falta es: \"+ missed);\n    }\n\n    static int getMissingNo(int a[], int n) {\n        int x1 = a[0];\n        int x2 = 1;\n        for (int i = 1; i < n; i++) {\n            x1 ^= a[i];\n        }\n        for (int i = 2; i <= n + 1; i++) {\n            x2 ^= i;\n        }\n        return x1 ^ x2;\n    }\n\n}\n",
    "cpp": "#include <bits/stdc++.h>\n#include <cstdlib>\nusing namespace std;\n\nstatic int MissingNoSearch(int arr[], int n) {\n    int x1 = arr[0];\n    int x2 = 1;\n    for (int i = 1; i < n; ++i) {\n        x1 = x1^arr[i];\n    }\n    for (int i = 2; i <= n + 1; ++i) {\n        x2 = x2^i;\n    }\n    return (x1^x2);\n}\n\nint main(int argc, char const *argv[]) {\n    int arr[] = {1, 3, 4, 5, 6, 7};\n    int n = sizeof (arr) / sizeof (arr[0]);\n    printf(\"El numero faltante es : %d\", MissingNoSearch(arr, n));\n    return 0;\n}\n",
    "py": "def getMissingNo(a,n):\n    x1 = a[0]\n    x2 = int(1)\n    for i in range(1,n):\n        x1^=a[i]\n    for i in range(2,n+2):\n        x2^=i\n    return x1^x2\n\nlista = [1,2,3,4,5,7,8]\nmissed = getMissingNo(lista,len(lista))\nprint(\"Numero perdido: \"+ str(missed))\n",
    "orden": 2,
    "suborden": 6,
    "fecha_creacion": "2020-12-02 17:30:29",
    "fecha_modificacion": "2020-12-07 02:21:15"
  },
  {
    "ID": 8,
    "supergrupo": "Búsquedas",
    "tema": "Difference Pair Search",
    "texto": "<div style=\"text-align: justify;\"><span style=\"font-size: 10pt;\">Dado un vector sin orden y un número n, busque si existe un par de elementos en el vector cuya diferencia es n.&nbsp;</span></div><div style=\"text-align: justify;\">El método más simple es ejecutar dos bucles, el bucle externo selecciona el primer elemento (elemento más pequeño) y el bucle interno busca el elemento seleccionado por el bucle externo más n.&nbsp;<span style=\"font-size: 10pt;\">La complejidad del tiempo de este método es O (n ^ 2).&nbsp;\r\n</span></div><div style=\"text-align: justify;\"><span style=\"font-size: 10pt;\"><br></span></div><div style=\"text-align: justify;\"><span style=\"font-size: 10pt;\">Podemos usar el ordenamiento y la búsqueda binaria para mejorar la complejidad del tiempo a O (nLogn). El primer paso es ordenar el array en orden ascendente. Una vez que el array esté ordenado, recorra el array de izquierda a derecha y, para cada elemento arr [i], la búsqueda binaria de arr [i] + n en arr [i + 1...n-1].&nbsp;</span></div><div style=\"text-align: justify;\"><span style=\"font-size: 10pt;\"><br></span></div><div style=\"text-align: justify;\"><span style=\"font-size: 10pt;\">Si se encuentra el elemento, devuelva el par.\r\nTanto el primer como el segundo paso toman O (nLogn). Así que la complejidad global es O (nLogn).\r\n\r\nEl segundo paso del algoritmo anterior se puede mejorar a O (n). El primer paso sigue siendo el mismo.&nbsp;</span></div><div style=\"text-align: justify;\"><span style=\"font-size: 10pt;\"><br></span></div><div style=\"text-align: justify;\"><span style=\"font-size: 10pt;\">La idea para el segundo paso es tomar dos variables de índice i y j, inicializarlas como 0 y 1 respectivamente. Ahora ejecuta un bucle lineal. Si arr [j] - arr [i] es más pequeño que n, debemos buscar un arr mayor [j], así que aumente j. Si arr [j] - arr [i] es mayor que n, debemos buscar un arr mayor [i], entonces incremente i.</span></div>",
    "complejidad_tiempo": "Mejor caso :    O(nLog(n))            Peor caso :      O(nLog(n))             Promedio: O(nLog(n))  ",
    "java": "// Programa Java para buscar un par\n// Dada una diferencia\n\npublic class PairDifferenceSearch {\n    //La función asume que el array esta ordenado\n    static boolean findPair(int arr[], int n) {\n        int size = arr.length;\n        // Inicializa la posición de dos elementos\n        int i = 0, j = 1;\n        // Busca por el par\n        while (i < size && j < size) {\n            if (i != j && arr[j] - arr[i] == n) {\n                System.out.print(\"Par Encontrado: \"\n                        + \"( \" + arr[i] + \", \" + arr[j] + \" )\");\n                return true;\n            } else if (arr[j] - arr[i] < n) {\n                j++;\n            } else {\n                i++;\n            }\n        }\n        //No encuentra el par\n        System.out.print(\"No hay tal par\");\n        return false;\n    }\n\n    public static void main(String[] args) {\n        int arr[] = {1, 8, 30, 40, 100};\n        int n = 60;\n        findPair(arr, n);\n    }\n}\n",
    "cpp": "#include <bits/stdc++.h>\n#include <cstdlib>\nusing namespace std;\n\nstatic bool findPair(int arr[], int n, int size) {\n    int i = 0, j = 1;\n    while (i < size && j < size) {\n        if (i != j && arr[j] - arr[i] == n) {\n            printf(\"par encontrado (%d %d)\", arr[i], arr[j]);\n            return true;\n        } else if (arr[j] - arr[i] < n) {\n            j++;\n        } else {\n            i++;\n        }\n    }\n    printf(\"no hay par que de el numero\");\n    return false;\n}\n\nint main(int argc, char const *argv[]) {\n    int arr[] = {1, 8, 30, 40, 100};\n    int n = 7;\n    int size = sizeof (arr) / sizeof (arr[0]);\n    findPair(arr, n, size);\n    return 0;\n}\n",
    "py": "def FindPair(arr,x):\n    size = len(arr)\n    i,j = 0,1\n    while i<size and j<size:\n        if i != j and arr[j] - arr[i] == x:\n            print(f\"par encontrado en: ({arr[i]} - {arr[j]})\")\n            return True\n        elif arr[j]-arr[i]<x:\n            j+=1\n        else:\n            i+=1\n    print(\"No existe el par que cumpla la suma de n\")\n    return False\n\narr = [1,8,30,40,100]\nx = int(60)\nFindPair(arr,x)\n",
    "orden": 2,
    "suborden": 7,
    "fecha_creacion": "2020-12-02 17:30:29",
    "fecha_modificacion": "2020-12-06 20:04:17"
  },
  {
    "ID": 9,
    "supergrupo": "Búsquedas",
    "tema": "Ternary Search",
    "texto": "<div style=\"text-align: justify;\"><span style=\"font-size: 10pt;\">La búsqueda ternaria es un algoritmo de dividir y conquistar que se puede usar para encontrar un elemento en un array. Es similar a la búsqueda binaria donde dividimos el array en dos partes pero en este algoritmo dividimos el array dado en tres partes y determinamos cuál tiene la clave (elemento buscado).&nbsp;</span></div><div style=\"text-align: justify;\">Podemos dividir el array en tres partes tomando mid1 y mid2, que se pueden calcular como se muestra a continuación.\r\nmid1 = l + (r-l) / 3\r\nmid2 = r - (r-l) / 3\r\nInicialmente, l y r serán iguales a 0 y n-1 respectivamente, donde n es la longitud de la matriz.&nbsp;</div><div style=\"text-align: justify;\"><br></div><div style=\"text-align: justify;\">El array debe ordenarse para realizar una búsqueda ternaria en ella.\r\n</div>",
    "complejidad_tiempo": "Mejor caso :    O(nLog(n))            Peor caso :      O(nLog(n))             Promedio: O(nLog(n))             ",
    "java": "//Programa Java para ilustrar \n//recursivamente la aproximación\n//de una búsqueda ternaria\n\npublic class TernarySearch {\n    //Función que realiza la busqueda ternaria\n    static int ternarySearch(int l, int r, int key, int ar[]) {\n        if (r >= l) {\n            //encontrar el mid1 y mid 2\n            int mid1 = l + (r - l) / 3;\n            int mid2 = r - (r - l) / 3;\n            //Verificar si la key esta presente en algun medio\n            if (ar[mid1] == key) {\n                return mid1;\n            }\n            if (ar[mid2] == key) {\n                return mid2;\n            }\n            /*Desde que la key no este presente en el mid\n            verifica en cada region si esta presente\n            luego repite la operación de busqueda\n            en esa región*/\n            if (key < ar[mid1]) {\n                //La key yace entre 1 y mid1\n                return ternarySearch(l, mid1 - 1, key, ar);\n            } else if (key > ar[mid2]) {\n                //La key yace entre mid2 y r\n                return ternarySearch(mid2 + 1, r, key, ar);\n            } else {\n                //La key  yace entre mid 1 y mid 2\n                return ternarySearch(mid1 + 1, mid2 - 1, key, ar);\n            }\n        }\n        // key no encontrada\n        return -1;\n    }\n\n    public static void main(String args[]) {\n        int l, r, p, key;\n        //Cree el array y ordenelo si no lo está\n        int ar[] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};\n        // Indice inicial\n        l = 0;\n        // Tamaño del arreglo \n        r = 9;\n        // Buscando por el 5\n        // key que va a ser buscada en el array\n        key = 5;\n        // Busca usando Ternary Search\n        p = ternarySearch(l, r, key, ar);\n        // Imprime el resultado\n        System.out.println(\"Indice de \" + key + \" es \" + p);\n        // Buscando por el 50\n        // Key a ser buscada en el array\n        key = 50;\n        // Buscar usando Ternary Search\n        p = ternarySearch(l, r, key, ar);\n        // Imprime el resultado \n        System.out.println(\"Index of \" + key + \" is \" + p);\n    }\n}\n",
    "cpp": "#include <bits/stdc++.h>\n#include <cstdlib>\nusing namespace std;\n\nstatic int ternarySearch(int left, int r, int key, int arr[]) {\n    if (r >= left) {\n        int mid1 = left + (r - left) / 3;\n        int mid2 = r - (r - left) / 3;\n        if (arr[mid1] == key) {\n            return mid1;\n        }\n        if (arr[mid2] == key) {\n            return mid2;\n        }\n        if (key < arr[mid1]) {\n            return ternarySearch(left, mid1 - 1, key, arr);\n        } else if (key > arr[mid2]) {\n            return ternarySearch(mid2 + 1, r, key, arr);\n        } else {\n            return ternarySearch(mid1 + 1, mid2 - 1, key, arr);\n        }\n\n    }\n    return -1;\n}\n\nint main() {\n    int arr[] = {1, 2, 3, 4, 5, 6, 7, 8, 9};\n    int n = sizeof (arr) / sizeof (arr[0]);\n    int l = 0;\n    int r = 9;\n    int x = 5;\n    int result = ternarySearch(l, r, x, arr);\n    if (result < 0) {\n        printf(\"el numero %d no se encuentra en el array\\n\", x);\n    } else {\n        printf(\"indice encontrado en la posicion %d\\n\", result);\n    }\n    return 0;\n}\n",
    "py": "def TernarySearch(l,r,key,arr):\n    if r >= l:\n        mid1 = l+(r-l)//3\n        mid2 = r-(r-l)//3\n        if arr[mid1]==key:\n            return mid1\n        if arr[mid2] == key:\n            return mid2\n        if key<arr[mid1]:\n            return TernarySearch(l,mid1-1,key,arr)\n        elif key>arr[mid2]:\n            return TernarySearch(mid2+1,r,key,arr)\n        else:\n            return TernarySearch(mid1+1,mid2-1,key,arr)\n\n    return -1\n\nl,r,resultado,key = int(),int(),int(),int()\narr = [1,2,3,4,5,6,7,8,9,10]\nl = int(0)\nr = len(arr)-1\nkey = 7\nresultado=TernarySearch(l,r,key,arr)\nif resultado==-1:\n    print(\"No existe el dato en el arreglo\")\nelse:\n    print(\"Encontrado en el indice: \"+str(resultado))\n",
    "orden": 2,
    "suborden": 8,
    "fecha_creacion": "2020-12-02 17:30:29",
    "fecha_modificacion": "2020-12-07 02:21:35"
  },
  {
    "ID": 10,
    "supergrupo": "Ordenamientos",
    "tema": "Bubble Sort",
    "texto": "<div style=\"text-align: justify;\"><span style=\"font-size: 10pt;\">Ordenamiento burbuja es el algoritmo de ordenamiento más simple que existe, funciona intercambiando repetidamente los elementos adyacentes si están en orden incorrecto.\r\nSi existen demasiadas recursiones puede llegar a ser demasiado demorado o resultar en un error en tiempo de ejecución.</span></div>",
    "complejidad_tiempo": "Mejor caso :    O(n)            Peor caso :      O(n2)             Promedio: O(n2)",
    "java": "\n//Programa java que realiza Bubble Sort Recursivo\n\nimport java.util.Arrays;\n\npublic class RecursiveBubbleSort {\n\n    static void bubbleSort(int arr[], int n) {\n        // Caso base\n        if (n == 1) {\n            return;\n        }\n        //Un paso de Bubble Sort, luego de este\n        //paso, el elemento más largo es movido\n        //  hasta el final\n        for (int i = 0; i < n - 1; i++) {\n            if (arr[i] > arr[i + 1]) {   //intercambia arr[i], arr[i+1] \n                int temp = arr[i];\n                arr[i] = arr[i + 1];\n                arr[i + 1] = temp;\n            }\n        }\n        bubbleSort(arr, n - 1);\n    }\n\n    public static void main(String[] args) {\n        int arr[] = {64, 34, 25, 12, 22, 11, 90};\n        bubbleSort(arr, arr.length);\n        System.out.println(\"Array ordenado : \");\n        System.out.println(Arrays.toString(arr));\n    }\n}\n",
    "cpp": "#include <bits/stdc++.h>\n#include <cstdlib>\nusing namespace std;\ntypedef long long int ll;\n\nvoid bubble_sort(int arr[], int len) {\n    if (len == 1) {\n        return;\n    }\n    for (int j = 0; j < len; j++) {\n        for (int i = 0; i < len - 1; i++) {\n            if (arr[i] > arr[i + 1]) {\n                int temp = arr[i];\n                arr[i] = arr[i + 1];\n                arr[i + 1] = temp;\n            }\n        }\n    }\n}\n\nint main() {\n    int arr[] = {9, 7, 6, 4, 3, 2, 1, 7, 8, 43, 43, 4, 54, 54, 3, 234, 1, 23};\n    int len = sizeof (arr) / sizeof (arr[0]);\n    bubble_sort(arr, len);\n    for (int i = 0; i < len; ++i) {\n        printf(\"%d \", arr[i]);\n    }\n    return 0;\n}\n",
    "py": "def BubbleSort(arr, n):\n    if n == 1:\n        return\n    for i in range(n-1):\n        if arr[i] > arr[i + 1]:\n            temp = arr[i]\n            arr[i] = arr[i + 1]\n            arr[i + 1] = temp\n    BubbleSort(arr, n-1)\narr = [4,5,8,9,10,2]\nBubbleSort(arr, len(arr))\nprint(arr)\n",
    "orden": 3,
    "suborden": 0,
    "fecha_creacion": "2020-12-02 17:30:29",
    "fecha_modificacion": "2020-12-07 02:21:44"
  },
  {
    "ID": 11,
    "supergrupo": "Ordenamientos",
    "tema": "Merge Sort",
    "texto": "<div style=\"text-align: justify;\"><span style=\"font-size: 10pt;\">Al igual que Quick Sort, Merge Sort es un algoritmo de Dividir y Conquistar.&nbsp;</span></div><div style=\"text-align: justify;\">Divide el arreglo de entrada en dos mitades, se llama a sí misma para las dos mitades y luego combina las dos mitades clasificadas. La función merge () se usa para fusionar dos mitades.\r\n\r\nEl merge (arr, l, m, r) es un proceso clave que asume que arr [l...m] y arr [m + 1...r] están ordenados y combina los dos subarreglos ordenados en uno solo.&nbsp;\r\n</div><div style=\"text-align: justify;\"><br></div><div style=\"text-align: justify;\">Merge Sort es útil para ordenar listas enlazadas en tiempo O (nLogn). En el caso de listas enlazadas, el caso es diferente principalmente debido a la diferencia en la asignación de memoria de los arrays y las listas enlazadas. A diferencia de los arrays, los nodos de listas enlazadas pueden no estar adyacentes en la memoria. A diferencia del array, en la lista enlazada, podemos insertar elementos en el medio en O (1) espacio adicional y O (1) tiempo.&nbsp;<span style=\"font-size: 10pt;\">Por lo tanto, la operación de fusión de merge sort se puede implementar sin espacio adicional para las listas vinculadas.\r\n\r\nEn arrays, podemos hacer acceso aleatorio ya que los elementos son continuos en la memoria.</span></div>",
    "complejidad_tiempo": "Mejor caso :    O(nlog(n))            Peor caso :      O(nlog(n))             Promedio: O(nlog(n))",
    "java": "/*Programa java para Merge Sort*/\npublic class MergeSort {\n\n    /*Une dos subarrays de arr[]\n    Primer subarray es arr[1...m]\n    Segundo subarray es arr[m+1..r]*/\n    static void merge(int arr[], int l, int m, int r) {\n        //Encuentra tamaños de dos subarrays a ser unidos\n        int n1 = m - l + 1;\n        int n2 = r - m;\n        /* Crear arrays temporales */\n        int L[] = new int[n1];\n        int R[] = new int[n2];\n        /*Copia datos en los arrays temporales*/\n        for (int i = 0; i < n1; ++i) {\n            L[i] = arr[l + i];\n        }\n        for (int j = 0; j < n2; ++j) {\n            R[j] = arr[m + 1 + j];\n        }\n        /*Une los arreglos temporales*/\n        // Indices iniciales del los dos subarrays\n        int i = 0, j = 0;\n        //indice inicial de array unido\n        int k = l;\n        while (i < n1 && j < n2) {\n            if (L[i] <= R[j]) {\n                arr[k] = L[i];\n                i++;\n            } else {\n                arr[k] = R[j];\n                j++;\n            }\n            k++;\n        }\n        /*Copia los elementos restanes de L[] si hay*/\n        while (i < n1) {\n            arr[k] = L[i];\n            i++;\n            k++;\n        }\n        //Copia los elementos restanes de R[] si hay\n        while (j < n2) {\n            arr[k] = R[j];\n            j++;\n            k++;\n        }\n    }\n\n    static void sort(int arr[], int l, int r) {\n        if (l < r) {\n            //Encuentra el punto medio\n            int m = (l + r) / 2;\n            // Ordena los dos subarrays\n            sort(arr, l, m);\n            sort(arr, m + 1, r);\n            // Une los subarrays\n            merge(arr, l, m, r);\n        }\n    }\n\n    //Imprimir array\n    static void printArray(int arr[]) {\n        int n = arr.length;\n        for (int i = 0; i < n; ++i) {\n            System.out.print(arr[i] + \" \");\n        }\n        System.out.println();\n    }\n\n    public static void main(String args[]) {\n        int arr[] = {12, 11, 13, 5, 6, 7};\n        System.out.println(\"Array dado\");\n        printArray(arr);\n        sort(arr, 0, arr.length - 1);\n        System.out.println(\"\\nArray ordenado\");\n        printArray(arr);\n    }\n}\n",
    "cpp": "#include <bits/stdc++.h>\n#include <cstdlib>\nusing namespace std;\n\nvoid merge(int arr[], int l, int m, int r) {\n    int n1 = m - l + 1;\n    int n2 = r - m;\n    int L[n1];\n    int R[n2];\n    for (int i = 0; i < n1; ++i) {\n        L[i] = arr[l + i];\n        for (int j = 0; j < n2; j++) {\n            R[j] = arr[m + 1 + j];\n        }\n    }\n    int i = 0, j = 0;\n    int k = l;\n    while (i < n1 && j < n2) {\n        if (L[i] <= R[j]) {\n            arr[k] = L[i];\n            i++;\n        } else {\n            arr[k] = R[j];\n            j++;\n        }\n        k++;\n    }\n    while (i < n1) {\n        arr[k] = L[i];\n        i++;\n        k++;\n    }\n    while (j < n2) {\n        arr[k] = R[j];\n        j++;\n        k++;\n    }\n}\n\nvoid printArray(int arr[], int n) {\n    for (int i = 0; i < n; i++) {\n        printf(\"%d \", arr[i]);\n    }\n    cout << \"\\n\";\n}\n\nvoid sort(int arr[], int l, int r) {\n    if (l < r) {\n        int m = (l + r) / 2;\n        sort(arr, l, m);\n        sort(arr, m + 1, r);\n        merge(arr, l, m, r);\n    }\n}\n\nint main() {\n \n    /*\n    int arr[]={3,41,1,34,41,2,4,0};\n    int n=sizeof(arr)/sizeof(arr[0]);\n    sort(arr,0,n-1);\n    printArray(arr,n);\n     */\n    //Mediante lectura\n    string str;\n    getline(cin, str);\n    string intermediate;\n    vector<int> vec;\n    stringstream check1(str);\n    while (getline(check1, intermediate, ' ')) {\n        vec.push_back(atoi(intermediate.c_str()));\n    }\n    int arr[vec.size()];\n    for (int i = 0; i < vec.size(); ++i) {\n        arr[i] = vec[i];\n    }\n    sort(arr, 0, vec.size() - 1);\n    printArray(arr, vec.size());\n    return 0;\n}\n",
    "py": "def merge(arr, left, mid, right):\n    n1 = mid - left + 1\n    n2 = right - mid\n    L, R = [], []\n    for i in range(n1):\n        L.append(arr[left + i])\n    for i in range(n2):\n        R.append(arr[mid + 1 + i])\n    i, j = int(0), int(0)\n    k = left\n    while i < n1 and j < n2:\n        if L[i] <= R[j]:\n            arr[k] = L[i]\n            i += 1\n        else:\n            arr[k] = R[j]\n            j += 1\n        k += 1\n    while i < n1:\n        arr[k] = L[i]\n        i += 1\n        k += 1\n    while j < n2:\n        arr[k] = R[j]\n        j += 1\n        k += 1\n        \ndef mergeSort(arr, left, right):\n    if left < right:\n        m = (left + right) // 2\n        mergeSort(arr, left, m)\n        mergeSort(arr, m + 1, right)\n        merge(arr, left, m, right)\n        \narr = [int(x) for x in input().split()]\nmergeSort(arr, 0, len(arr)-1)\nprint(arr)\n",
    "orden": 3,
    "suborden": 1,
    "fecha_creacion": "2020-12-02 17:30:29",
    "fecha_modificacion": "2020-12-06 20:05:43"
  },
  {
    "ID": 12,
    "supergrupo": "Ordenamientos",
    "tema": "Binary Insertion Sort",
    "texto": "<div style=\"text-align: justify;\"><span style=\"font-size: 10pt;\">Podemos usar la búsqueda binaria para reducir el número de comparaciones en el ordenamiento de inserción normal. El ordenamiento de inserción binaria utiliza la búsqueda binaria para encontrar la ubicación adecuada para insertar el elemento seleccionado en cada iteración.&nbsp;</span></div><div style=\"text-align: justify;\">En el ordenamiento de inserción normal, se necesitan comparaciones O(n) (en la iteración n) en el peor de los casos. Podemos reducirlo a O (log n) mediante la búsqueda binaria.\r\nEl algoritmo en su conjunto aún tiene un tiempo de ejecución en el peor de los casos de O (n^2) debido a la serie de intercambios necesarios para cada inserción.\r\n</div>",
    "complejidad_tiempo": "Mejor caso :    O(n)            Peor caso :      O(n2)             Promedio: O(n2)",
    "java": "// Programa java implementando\n// Binary Insertion Sort\n\nimport java.util.Arrays;\n\npublic class BinaryInsertionSort {\n\n    public static void main(String[] args) {\n        int[] arr = {37, 23, 0, 17, 12, 72, 31,\n            46, 100, 88, 54};\n        sort(arr);\n        for (int i = 0; i < arr.length; i++) {\n            System.out.print(arr[i] + \" \");\n        }\n    }\n\n    static void sort(int array[]) {\n        for (int i = 1; i < array.length; i++) {\n            int x = array[i];\n            // Encontrar ubicación para insertar usando\n            // Binary Search\n            int j = Math.abs(Arrays.binarySearch(array, 0, i, x) + 1);\n            System.arraycopy(array, j, array, j + 1, i - j);\n            // Colocar elemento en su correcta localización\n            array[j] = x;\n        }\n    }\n}\n",
    "cpp": "#include <iostream>\n\nusing namespace std;\n\nint binarySearch(int arr[], int i, int low, int high) {\n    if (high <= low) {\n        return (i > arr[low]) ? (low + 1) : low;\n    }\n    int mid = (low + high) / 2;\n    if (i == arr[mid]) {\n        return mid + 1;\n    }\n    if (i > arr[mid]) {\n        return binarySearch(arr, i, mid + 1, high);\n    }\n    return binarySearch(arr, i, low, mid - 1);\n}\n\nvoid insertionSort(int arr[], int n) {\n    int i, loc, j, selected;\n    for (i = 1; i < n; ++i) {\n        j = i - 1;\n        selected = arr[i];\n        loc = binarySearch(arr, selected, 0, j);\n        while (j >= loc) {\n            arr[j + 1] = arr[j];\n            j--;\n        }\n        arr[j + 1] = selected;\n    }\n}\n\nint main() {\n    int arr[] = {-63, 8, -7, -15, -19, 17, 19, 110};\n    int n = sizeof (arr) / sizeof (arr[0]);\n    insertionSort(arr, n);\n    cout << \"Arreglo ordenado:\" << endl;\n    for (int i = 0; i < n; i++) {\n        if (i == n - 1) {\n            cout << arr[i] << endl;\n            break;\n        }\n        cout << arr[i] << \" \";\n    }\n    return 0;\n}\n",
    "py": "def partition(arr, low, high):\n    pivot = arr[high]\n    i = low - 1\n    for j in range(low, high):\n        if(arr[j] < pivot):\n            i = i + 1\n            temp = arr[i]\n            arr[i] = arr[j]\n            arr[j] = temp\n    temp = arr[i + 1]\n    arr[i + 1] = arr[high]\n    arr[high] = temp\n    return i + 1\n\n\ndef quickSort(arr, low, high):\n    if(low < high):\n        pivot = partition(arr, low, high)\n        quickSort(arr, low, pivot-1)\n        quickSort(arr, pivot + 1, high)\n\n\nlista = [int(x) for x in input().split()]\nquickSort(lista, 0, len(lista)-1)\nprint(*lista)",
    "orden": 3,
    "suborden": 2,
    "fecha_creacion": "2020-12-02 17:30:29",
    "fecha_modificacion": "2020-12-06 20:05:44"
  },
  {
    "ID": 13,
    "supergrupo": "Ordenamientos",
    "tema": "Quick Sort",
    "texto": "Quick Sort es un algoritmo de Dividir y Conquistar. Selecciona un elemento como pivote y divide el array dado alrededor del pivote seleccionado.&nbsp;<div style=\"font-weight: normal;\"><br></div><div style=\"\"><span style=\"font-weight: bold;\">Hay muchas versiones diferentes de quick Sort que seleccionan pivote de diferentes maneras.\r\n&nbsp;</span></div><div style=\"font-weight: normal;\"><span style=\"white-space:pre\">\t</span>- Elije siempre el primer elemento como pivote.&nbsp;</div><div style=\"font-weight: normal;\"><span style=\"white-space:pre\">\t</span>- Siempre elije el último elemento como pivote.&nbsp;</div><div style=\"font-weight: normal;\"><span style=\"white-space:pre\">\t</span>- Elige un elemento aleatorio como pivote.&nbsp;</div><div style=\"font-weight: normal;\"><span style=\"white-space:pre\">\t</span>- Elije la mediana como pivote.&nbsp;</div><div style=\"font-weight: normal;\"><br></div><div style=\"font-weight: normal;\">El proceso clave en quick Sort es partition (). El destino de las particiones es, dada un array y un elemento x del array como pivote, coloca x en su posición correcta en el array ordenado y coloca todos los elementos más pequeños (más pequeños que x) antes de x, y coloca todos los elementos mayores (mayores que x) después de X. Todo esto debe hacerse en tiempo lineal.\r\n</div>",
    "complejidad_tiempo": "Mejor caso :    O(nlog(n))            Peor caso :      O(n2)             Promedio: O(nlog(n))",
    "java": "// Programa java para la implementación de QuickSort\n\npublic class QuickSort {\n\n    /* Esta función toma el ultimo elemento como\n    pivote, coloca el pivote en la posición correcta\n    en el array ordenado, y coloca todos los más \n    pequeñps (Más pequeños que el pivote) a la izquierda\n    del pivote, y todos los más grandes a la derecha del\n    pivote*/\n    static int partition(int arr[], int low, int high) {\n        int pivot = arr[high];\n        int i = (low - 1); // Indice del elemento más pequeño\n        for (int j = low; j < high; j++) {\n            /*Si el actual elemento es más pequeño\n            p igual que el pivote*/\n            if (arr[j] <= pivot) {\n                i++;\n                //intercambia arr[i] y arr[j] \n                int temp = arr[i];\n                arr[i] = arr[j];\n                arr[j] = temp;\n            }\n        }\n        // Intercambia arr[i+1] y arr[high] (o pivote) \n        int temp = arr[i + 1];\n        arr[i + 1] = arr[high];\n        arr[high] = temp;\n\n        return i + 1;\n    }\n\n    /*arr[] --> Array que sera ordenado, \n      low  --> indice inicial, \n      high  --> indice final */\n    static void sort(int arr[], int low, int high) {\n        if (low < high) {\n            /* pi esta particionando indices, arr[pi] is  \n              now at right place */\n            int pi = partition(arr, low, high);\n            // Recursivamente ordena elementos antes de \n            // la partición y despues de la partición\n            sort(arr, low, pi - 1);\n            sort(arr, pi + 1, high);\n        }\n    }\n    /* Imprimir array */\n    static void printArray(int arr[]) {\n        int n = arr.length;\n        for (int i = 0; i < n; ++i) {\n            System.out.print(arr[i] + \" \");\n        }\n        System.out.println();\n    }\n\n    public static void main(String args[]) {\n        int arr[] = {10, 7, 8, 9, 1, 5};\n        int n = arr.length;\n        sort(arr, 0, n - 1);\n        System.out.println(\"Array ordenado\");\n        printArray(arr);\n    }\n}\n",
    "cpp": "#include <bits/stdc++.h>\n#include <cstdlib>\nusing namespace std;\n\nint partition(int arr[], int low, int high) {\n    int pivot = arr[high];\n    int i = (low - 1);\n\n    for (int j = low; j <= high - 1; j++) {\n        if (arr[j] <= pivot) {\n            i++;\n            int temp = arr[i];\n            arr[i] = arr[j];\n            arr[j] = temp;\n        }\n    }\n    int temp = arr[i + 1];\n    arr[i + 1] = arr[high];\n    arr[high] = temp;\n    return (i + 1);\n}\n\nvoid quickSort(int arr[], int low, int high) {\n    if (low < high) {\n\n        int pi = partition(arr, low, high);\n\n        quickSort(arr, low, pi - 1);\n        quickSort(arr, pi + 1, high);\n    }\n}\n\nvoid print(int arr[], int n) {\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d \", arr[i]);\n    }\n    cout << \"\\n\";\n}\n\nint main(int argc, char const *argv[]) {\n    int arr[] = {9, 8, 7, 6, 5, 4, 3, 2, 1, 0};\n    int n = sizeof (arr) / sizeof (arr[0]);\n    quickSort(arr, 0, n - 1);\n    print(arr, n);\n    return 0;\n}\n",
    "py": "def Partition(arr, low, high):\n    pivot = arr[high]\n    i = low-1\n    for j in range(low, high):\n        if arr[j] <= pivot:\n            i += 1\n            temp = arr[i]\n            arr[i] = arr[j]\n            arr[j] = temp\n    temp = arr[i + 1]\n    arr[i + 1] = arr[high]\n    arr[high] = temp\n    return i + 1\n\ndef QuickSort(arr, low, high):\n    if low < high:\n        pivot = Partition(arr, low, high)\n        QuickSort(arr, low, pivot-1)\n        QuickSort(arr, pivot + 1, high)\narr = [int(x) for x in input().split()]\nQuickSort(arr, 0, len(arr)-1)\nprint(arr)\n",
    "orden": 3,
    "suborden": 3,
    "fecha_creacion": "2020-12-02 17:30:29",
    "fecha_modificacion": "2020-12-07 01:55:14"
  },
  {
    "ID": 14,
    "supergrupo": "Ordenamientos",
    "tema": "Radix Sort",
    "texto": "Radix sort es un algoritmo de ordenamiento que clasifica los números según las posiciones de sus dígitos.&nbsp;<span style=\"font-size: 10pt;\">Básicamente, utiliza el valor posicional de los dígitos en un número.&nbsp;</span><div><span style=\"font-size: 10pt;\"><br></span></div><div><span style=\"font-size: 10pt;\">A diferencia de la mayoría de los otros algoritmos de ordenamiento, como Merge Sort, Insertion Sort y burbuja, no compara los números.\r\n\r\nRadix sort utiliza un algoritmo de ordenamiento estable como subrutina para ordenar los dígitos. Aquí hemos usado una variación de conteo como una subrutina que usa la raíz para ordenar los dígitos en cada posición.&nbsp;</span></div><div><span style=\"font-size: 10pt;\"><br></span></div><div><span style=\"font-size: 10pt;\">El ordenamiento radix es un algoritmo de ordenamiento estable y funciona bien en la práctica.\r\n\r\nLa clasificación por radix funciona clasificando los dígitos del dígito menos significativo al dígito más significativo. \r\n\r\nSi tenemos bits log2n para cada dígito, el tiempo de ejecución de Radix parece ser mejor que Quick Sort para una amplia gama de números de entrada. Los factores constantes ocultos en la notación asintótica son mayores para Radix Sort y Quick-Sort usa cachés de hardware de manera más efectiva.</span></div>",
    "complejidad_tiempo": "Mejor caso :    O(dígitos*n)            Peor caso :     O(dígitos*n)             Promedio: O(dígitos*n)",
    "java": "//Implementación java de Radix Sort\n\nimport java.util.*;\n\npublic class RadixSort {\n\n    // Una función de utilidad que obtiene\n    //El maximo valor en arr[] \n    static int getMax(int arr[], int n) {\n        int mx = arr[0];\n        for (int i = 1; i < n; i++) {\n            if (arr[i] > mx) {\n                mx = arr[i];\n            }\n        }\n        return mx;\n    }\n\n    /*Una función que realiza conteo de ordenamiento en \n    arr[] de acuerdo al digito\n    representado como exp*/\n    static void countSort(int arr[], int n, int exp) {\n        int output[] = new int[n]; // Array de salida\n        int i;\n        int count[] = new int[10];\n        Arrays.fill(count, 0);\n        // Almacena el conteo de las ocurrencias en count[]\n        for (i = 0; i < n; i++) {\n            count[(arr[i] / exp) % 10]++;\n        }\n        // cambia count[i] de tal manera que ahora\n        //contenga la actual posicion de este digito en\n        //output[]\n        for (i = 1; i < 10; i++) {\n            count[i] += count[i - 1];\n        }\n        //Contruye el array de salida\n        for (i = n - 1; i >= 0; i--) {\n            output[count[(arr[i] / exp) % 10] - 1] = arr[i];\n            count[(arr[i] / exp) % 10]--;\n        }\n        // copia el array de salida a arr[], ahora arr[] \n        // contiene los números ordenados de acuerdo al digito\n        //actual \n        for (i = 0; i < n; i++) {\n            arr[i] = output[i];\n        }\n    }\n\n    static void radixsort(int arr[], int n) {\n        // Encuentra el maximo número para conocer el número \n        // de digitos\n        int m = getMax(arr, n);\n        for (int exp = 1; m / exp > 0; exp *= 10) {\n            countSort(arr, n, exp);\n        }\n    }\n\n    //Imprimir el array\n    static void print(int arr[], int n) {\n        for (int i = 0; i < n; i++) {\n            System.out.print(arr[i] + \" \");\n        }\n    }\n\n    public static void main(String[] args) {\n        int arr[] = {170, 45, 75, 90, 802, 24, 2, 66};\n        int n = arr.length;\n        radixsort(arr, n);\n        print(arr, n);\n    }\n}\n",
    "cpp": "#include <bits/stdc++.h>\n#include <cstdlib>\nusing namespace std;\n\nint getMax(int arr[], int n) {\n    int mx = arr[0];\n    for (int i = 1; i < n; ++i) {\n        if (arr[i] > mx) {\n            mx = arr[i];\n        }\n    }\n    return mx;\n}\n\nvoid countSort(int arr[], int n, int exp) {\n    int output[n];\n    int count[10];\n    memset(count, 0, sizeof (count));\n    for (int i = 0; i < n; ++i) {\n        count[(arr[i] / exp) % 10]++;\n    }\n    for (int i = 0; i < 10; ++i) {\n        count[i] += count[i - 1];\n    }\n    for (int i = n - 1; i >= 0; --i) {\n        output[count[(arr[i] / exp) % 10] - 1] = arr[i];\n        count[(arr[i] / exp) % 10]--;\n    }\n    for (int i = 0; i < n; ++i) {\n        arr[i] = output[i];\n    }\n}\n\nvoid radixSort(int arr[], int n) {\n    int m = getMax(arr, n);\n    for (int exp = 1; m / exp > 0; exp *= 10) {\n        countSort(arr, n, exp);\n    }\n}\n\nvoid printArray(int arr[], int n) {\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d \", arr[i]);\n    }\n    cout << \"\\n\";\n}\n\nint main(int argc, char const *argv[]) {\n    int arr[] = {9, 78, 6, 5, 32, 1, 1, 4, 5, 45};\n    int n = sizeof (arr) / sizeof (arr[0]);\n    radixSort(arr, n);\n    printArray(arr, n);\n    return 0;\n}\n",
    "py": "# Solo con Numeros Positivos\n\ndef getMax(arr, n):\n    maxim = arr[0]\n    for i in range(1, n):\n        if(arr[i] > maxim):\n            maxim = arr[i]\n    return maxim\n\n\ndef countSort(arr, n, exp):\n    output = [0 for x in range(n)]\n    count = [0 for x in range(10)]\n    i = 0\n    for i in range(0, n):\n        count[(arr[i] // exp) % 10] += 1\n    for i in range(1, 10):\n        count[i] += count[i-1]\n    for i in range(n-1, -1, -1):\n        output[count[(arr[i] // exp) % 10]-1] = arr[i]\n        count[(arr[i] // exp) % 10] -= 1\n    for i in range(0, n):\n        arr[i] = output[i]\n\n\ndef radixSort(arr, n):\n    m = getMax(arr, n)\n    exp = 1\n    while m // exp > 0:\n        countSort(arr, n, exp)\n        exp *= 10\n\n\nlista = [int(x) for x in input().split()]\nradixSort(lista, len(lista))\nprint(*lista)\n",
    "orden": 3,
    "suborden": 4,
    "fecha_creacion": "2020-12-02 17:30:29",
    "fecha_modificacion": "2020-12-07 01:56:47"
  },
  {
    "ID": 15,
    "supergrupo": "Ordenamientos",
    "tema": "Shell Sort",
    "texto": "Shell Sort es principalmente una variación de Insertion Sort.&nbsp;<div><br></div><div>En el ordenamiento por inserción, movemos los elementos solo una posición adelante. Cuando un elemento tiene que moverse mucho más adelante, hay muchos movimientos involucrados. La idea de shell Sort es permitir el intercambio de elementos lejanos. En shell Sort, hacemos el array para un gran valor de h. Continuamos reduciendo el valor de h hasta que se convierte en 1. Se dice que un array está ordenado por h si todas las sublistas de cada elemento h están ordenadas.&nbsp;</div><div><br></div><div>&nbsp;La complejidad de tiempo de la implementación de shell Sort es O (n^2). En la implementación la brecha se reduce a la mitad en cada iteración.\r\n</div>",
    "complejidad_tiempo": "Mejor caso :    O(nlog(n))            Peor caso :     O(n2)             Promedio: O(nlog(n))",
    "java": "// Implementación java de ShellSort\n\npublic class ShellSort {\n\n    /*Imprimir el array */\n    static void printArray(int arr[]) {\n        int n = arr.length;\n        for (int i = 0; i < n; ++i) {\n            System.out.print(arr[i] + \" \");\n        }\n        System.out.println();\n    }\n    //Función ordenadora Shell Sort\n    static void sort(int arr[]) {\n        int n = arr.length;\n        //Inicia con un gran salto, luego reduce el salto\n        for (int gap = n / 2; gap > 0; gap /= 2) {   \n     //Realiza un insertion sort con salto\n            // Los primeros elementros del sato a[0..gap-1]\n            // estan ya en un orden de salto que sigue agregando\n            //un elemento más hasta que el array entero este ordenado\n            for (int i = gap; i < n; i += 1) {\n                //Agrega a[i] a los elementos que estan en el ordenamiento\n                // con salto\n                int temp = arr[i];\n                int j;\n                for (j = i; j >= gap && arr[j - gap] > temp; j -= gap) {\n                    arr[j] = arr[j - gap];\n                }\n                arr[j] = temp;\n            }\n        }\n        \n    }\n\n    public static void main(String args[]) {\n        int arr[] = {12, 34, 54, 2, 3};\n        System.out.println(\"Array antes de ordenar\");\n        printArray(arr);\n        sort(arr);\n        System.out.println(\"Array despues de ordenar\");\n        printArray(arr);\n    }\n}\n",
    "cpp": "#include <bits/stdc++.h>\n#include <cstdlib>\ntypedef long long int ll;\nusing namespace std;\n\nvoid printArray(vector <int> myvec, int n) {\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d \", myvec[i]);\n    }\n}\n\nint sort(vector <int> myvec, int n) {\n    for (int gap = n / 2; gap > 0; gap /= 2) {\n        for (int i = gap; i < n; i += 1) {\n            int temp = myvec[i];\n            int j;\n            for (j = i; j >= gap && myvec[j - gap] > temp; j -= gap) {\n                myvec[j] = myvec[j - gap];\n            }\n            myvec[j] = temp;\n        }\n    }\n    printArray(myvec, n);\n    return 0;\n}\n\nint main(int argc, char** argv) {\n    int arr[] = {3, 4, 1, 3, 54, 6, 6, 4, 3, 2, 3, 1, 21};\n    int n = sizeof (arr) / sizeof (arr[0]);\n    vector<int> myvec;\n    myvec.insert(myvec.begin(), arr, arr + n);\n    sort(myvec, n);\n    return 0;\n}\n",
    "py": "def ShellSort(arr):\n    n = len(arr)\n    grap = n // 2\n    while grap > 0:\n        i = grap\n        while i < n:\n            temp = arr[i]\n            j = i\n            while j >= grap and arr[j-grap] > temp:\n                arr[j] = arr[j-grap]\n                j -= grap\n            arr[j] = temp\n            i += 1\n        grap //= 2\n        \narr = [12, 56, 89, 47, 89, 23]\nShellSort(arr)\nprint(*arr)\n",
    "orden": 3,
    "suborden": 5,
    "fecha_creacion": "2020-12-02 17:30:29",
    "fecha_modificacion": "2020-12-07 01:57:07"
  },
  {
    "ID": 16,
    "supergrupo": "Ordenamientos",
    "tema": "Tim Sort",
    "texto": "<p class=\"MsoNormalCxSpFirst\" style=\"margin:0cm;margin-bottom:.0001pt;mso-add-space:\r\nauto\">TimSort es un algoritmo de ordenamiento basado en Insertion Sort y Merge\r\nSort.<o:p></o:p></p>\r\n\r\n<p class=\"MsoNormalCxSpLast\" style=\"margin:0cm;margin-bottom:.0001pt;mso-add-space:\r\nauto\"><o:p>&nbsp;</o:p></p>\r\n\r\n<p class=\"MsoListParagraphCxSpFirst\" style=\"margin-top:0cm;margin-right:0cm;\r\nmargin-bottom:0cm;margin-left:36.0pt;margin-bottom:.0001pt;mso-add-space:auto;\r\ntext-indent:-18.0pt;mso-list:l0 level1 lfo1\"><!--[if !supportLists]--><span style=\"mso-ascii-font-family:Calibri;mso-fareast-font-family:Calibri;\r\nmso-hansi-font-family:Calibri;mso-bidi-font-family:Calibri\"><span style=\"mso-list:Ignore\">-<span style=\"font:7.0pt &quot;Times New Roman&quot;\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\r\n</span></span></span>Es un algoritmo de ordenamiento estable\r\nfunciona en tiempo O (n Log n)<o:p></o:p></p>\r\n\r\n<p class=\"MsoListParagraphCxSpMiddle\" style=\"margin-top:0cm;margin-right:0cm;\r\nmargin-bottom:0cm;margin-left:36.0pt;margin-bottom:.0001pt;mso-add-space:auto;\r\ntext-indent:-18.0pt;mso-list:l0 level1 lfo1\"><!--[if !supportLists]--><span style=\"mso-ascii-font-family:Calibri;mso-fareast-font-family:Calibri;\r\nmso-hansi-font-family:Calibri;mso-bidi-font-family:Calibri\"><span style=\"mso-list:Ignore\">-<span style=\"font:7.0pt &quot;Times New Roman&quot;\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\r\n</span></span></span><!--[endif]-->Se utiliza en Arrays.sort () de Java, así como\r\nen Python sorted() y C++ sort()<o:p></o:p></p>\r\n\r\n<p class=\"MsoListParagraphCxSpLast\" style=\"margin-top:0cm;margin-right:0cm;\r\nmargin-bottom:0cm;margin-left:36.0pt;margin-bottom:.0001pt;mso-add-space:auto;\r\ntext-indent:-18.0pt;mso-list:l0 level1 lfo1\"><!--[if !supportLists]--><span style=\"mso-ascii-font-family:Calibri;mso-fareast-font-family:Calibri;\r\nmso-hansi-font-family:Calibri;mso-bidi-font-family:Calibri\"><span style=\"mso-list:Ignore\">-<span style=\"font:7.0pt &quot;Times New Roman&quot;\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\r\n</span></span></span><!--[endif]-->Primero clasifica las piezas pequeñas utilizando\r\nel ordenamiento de Inserción, luego fusiona las piezas utilizando ordenamiento\r\npor fusión (Merge Sort).<o:p></o:p></p>\r\n\r\n<p class=\"MsoNormal\" style=\"margin:0cm;margin-bottom:.0001pt\"><o:p>&nbsp;</o:p></p>\r\n\r\n<p class=\"MsoNormalCxSpMiddle\" style=\"margin:0cm;margin-bottom:.0001pt;\r\nmso-add-space:auto\">Dividimos el array en bloques conocidos como Run. Ordenamos\r\nesas ejecuciones utilizando el ordenamiento por inserción una por una y luego\r\nlas combinamos utilizando la función de combinación utilizada en Merge Sort. Si\r\nel tamaño del array es menor que run, entonces el array se clasifica\r\nsimplemente utilizando el ordenamiento de inserción.<o:p></o:p></p>\r\n\r\n<p class=\"MsoNormalCxSpMiddle\" style=\"margin:0cm;margin-bottom:.0001pt;\r\nmso-add-space:auto\"><o:p>&nbsp;</o:p></p>\r\n\r\n<p class=\"MsoNormalCxSpMiddle\" style=\"margin:0cm;margin-bottom:.0001pt;\r\nmso-add-space:auto\">El tamaño de run puede variar de 32 a 64, dependiendo del\r\ntamaño del array. Tenga en cuenta que la función de combinación funciona bien\r\ncuando los arreglos secundarios de tamaño son potencias de 2. La idea se basa\r\nen el hecho de que el ordenamiento por inserción funciona bien para arreglos\r\npequeños.<o:p></o:p></p>",
    "complejidad_tiempo": "Mejor caso :    O(n)            Peor caso :     O(nlog(n))             Promedio: O(nlog(n))",
    "java": "// Programa Java que realiza TimSort\n\npublic class TimSort {\n\n    static int RUN = 32;\n    // esta función ordena el arreglo \n    //desde el índice izquierdo hasta\n    //a la derecha el índice que es de tamaño más alto RUN \n    public static void insertionSort(int[] arr, int left, int right) {\n        for (int i = left + 1; i <= right; i++) {\n            int temp = arr[i];\n            int j = i - 1;\n            while (arr[j] > temp && j >= left) {\n                arr[j + 1] = arr[j];\n                j--;\n  if (j < 0) {\n                    break;\n                }\n\n            }\n            arr[j + 1] = temp;\n        }\n    }\n\n    public static void merge(int[] arr, int l, int m, int r) {\n        //Array original esta separado en dos partes\n        // array derecho e izquierdo \n        int len1 = m - l + 1, len2 = r - m;\n        int[] left = new int[len1];\n        int[] right = new int[len2];\n        for (int x = 0; x < len1; x++) {\n            left[x] = arr[l + x];\n        }\n        for (int x = 0; x < len2; x++) {\n            right[x] = arr[m + 1 + x];\n        }\n        int i = 0;\n        int j = 0;\n        int k = l;\n        // despues de comparar, \n        // after comparing,unimos los dos array  \n        // en un subarray más largo\n        while (i < len1 && j < len2) {\n            if (left[i] <= right[j]) {\n                arr[k] = left[i];\n                i++;\n            } else {\n                arr[k] = right[j];\n                j++;\n            }\n            k++;\n        }\n        //Copia los elementos restates de la izquiera, si hay\n        while (i < len1) {\n            arr[k] = left[i];\n            k++;\n            i++;\n        }\n        // Copia los elementos restates de la derecha, si hay\n        while (j < len2) {\n            arr[k] = right[j];\n            k++;\n            j++;\n        }\n    }\n\n    public static void timSort(int[] arr, int n) {\n        //Ordena individualmente los subarrays de \n        //tamaño RUN\n        for (int i = 0; i < n; i += RUN) {\n            insertionSort(arr, i, Math.min((i + 31), (n - 1)));\n        }\n        //Comienza a unir de tamaño run, luego\n        //podra unir de tamaño 64, 128, 256 y asi...\n        for (int size = RUN; size < n; size = 2 * size) {\n            // Toma un punto inicial del subarray izquierdo\n            // nosotros vamos a unir arr[left..left+size-1] y\n            //arr[left+size, left+2*size-1], luego de cada union\n            // nosotros incrementamos izquiera en  2*size  \n            for (int left = 0; left < n; left += 2 * size) {\n                //Encontramos punto de finalizacion de\n                // el subarray izquierdo, mid+1\n                // mid+1 es el punto inicial del \n                //subarray derecho  \n                int mid = Math.min((left + size - 1), (n - 1));\n                int right = Math.min((left + 2 * size - 1), (n - 1));\n                // une sub array arr[left.....mid] y  \n                // arr[mid+1....right]  \n                merge(arr, left, mid, right);\n            }\n        }\n    }\n\n    // Imprimir el array\n    public static void printArray(int[] arr, int n) {\n        for (int i = 0; i < n; i++) {\n            System.out.print(arr[i] + \" \");\n        }\n        System.out.print(\"\\n\");\n    }\n\n    public static void main(String[] args) {\n        int[] arr = {5, 21, 7, 23, 19};\n        int n = arr.length;\n        System.out.print(\"El array dado es\\n\");\n        printArray(arr, n);\n        timSort(arr, n);\n        System.out.print(\"Array ordenado\\n\");\n        printArray(arr, n);\n    }\n}\n",
    "cpp": "#include <bits/stdc++.h>\n#include <cstdlib>\n#define MAX 256\ntypedef long long int ll;\nusing namespace std;\nint RUN = 32;\n\nvoid printArray(int arr[], int n) {\n    for (int i = 0; i < n; i++) {\n        printf(\"%d \", arr[i]);\n    }\n}\n\nvoid insertionSort(int arr[], int left, int rigth) {\n    for (int i = left + 1; i <= rigth; ++i) {\n        int temp = arr[i];\n        int j = i - 1;\n        while (arr[j] > temp && j >= left) {\n            arr[j + 1] = arr[j];\n            j--;\n        }\n        arr[j + 1] = temp;\n    }\n}\n\nvoid merge(int arr[], int l, int m, int r) {\n    int len1 = m - l + 1, len2 = r - m;\n    int left[len1];\n    int rigth[len2];\n    for (int x = 0; x < len1; ++x) {\n        left[x] = arr[l + x];\n    }\n    for (int x = 0; x < len2; ++x) {\n        rigth[x] = arr[m + 1 + x];\n    }\n    int i = 0, j = 0, k = l;\n    while (i < len1 && j < len2) {\n        if (left[i] <= rigth[j]) {\n            arr[k] = left[i];\n            i++;\n        } else {\n            arr[k] = rigth[j];\n            j++;\n        }\n        k++;\n    }\n    while (i < len1) {\n        arr[k] = left[i];\n        k++;\n        i++;\n    }\n    while (j < len2) {\n        arr[k] = rigth[j];\n        k++;\n        j++;\n    }\n}\n\nvoid timSort(int arr[], int n) {\n    for (int i = 0; i < n; i += RUN) {\n        insertionSort(arr, i, std::min((i + 31), (n - 1)));\n    }\n    for (int size = RUN; size < n; size = 2 * size) {\n        for (int left = 0; left < n; left += 2 * size) {\n            int mid = std::min((left + size - 1), (n - 1));\n            int rigth = std::min((left + 2 * size - 1), (n - 1));\n            merge(arr, left, mid, rigth);\n        }\n    }\n    printArray(arr, n);\n}\n\nint main(int argc, char** argv) {\n    int arr[] = {3, 4, 5, 6, 3, 1, 1, 23, 5, 546, 34, 3, 2, 2};\n    int len = sizeof (arr) / sizeof (arr[0]);\n    timSort(arr, len);\n    return 0;\n}\n",
    "py": "from sys import stdout\nwr = stdout.write\n\nRUN = 32\ndef insertionSort(arr, left, right):\n    for i in range(left + 1, right + 1):\n        temp = arr[i]\n        j = i - 1\n        while j >= left and arr[j] > temp:\n            arr[j + 1] = arr[j]\n            j -= 1\n        arr[j + 1] = temp\n\n\ndef merge(arr, l, m, r):\n    len1 = m - l + 1\n    len2 = r - m\n    left = [0 for x in range(len1)]\n    right = [0 for x in range(len2)]\n    for i in range(len1):\n        left[x] = arr[l + x]\n    for i in range(len2):\n        right[x] = arr[m + 1 + x]\n    i = 0\n    j = 0\n    k = l\n    while i < len1 and j < len2:\n        if left[i] <= right[i]:\n            arr[k] = left[i]\n            i += 1\n        else:\n            arr[k] = right[j]\n            j += 1\n        k += 1\n    while i < len1:\n        arr[k] = left[i]\n        k += 1\n        i += 1\n    while j < len2:\n        arr[k] = right[j]\n        k += 1\n        j += 1\n\n\ndef timSort(arr, n):\n    i = 0\n    while i < n:\n        insertionSort(arr, i, min((i + 31), (n - 1)))\n        i += RUN\n    size = RUN\n    while size < n:\n        left = 0\n        while left < 2:\n                        mid = min ((left + size - 1), (n - 1))\n            right = min((left + 2 * size - 1), (n - 1))\n            merge(arr, left, mid, right)\n            left += 2 * size\n        size = 2 * size\n\n\ndef printArray(arr, n):\n    for i in range(n):\n        wr(f'{arr[i]} ')\n    wr('\\n')\n\narr = [int(x) for x in input().split()]\nn = len(arr)\ntimSort(arr, n)\nprintArray(arr, n)\n",
    "orden": 3,
    "suborden": 6,
    "fecha_creacion": "2020-12-04 20:09:36",
    "fecha_modificacion": "2020-12-07 01:58:30"
  },
  {
    "ID": 17,
    "supergrupo": "Ordenamientos",
    "tema": "Tree Sort",
    "texto": "<div style=\"text-align: justify;\"><span style=\"font-size: 10pt;\">Ordenamiento árbol es un algoritmo de clasificación que se basa en la estructura de datos del Binary Search Tree (Árbol de búsqueda binaria).&nbsp;</span></div><div style=\"text-align: justify;\"><span style=\"font-size: 10pt;\"><br></span></div><div style=\"text-align: justify; font-weight: normal;\">Primero crea un árbol de búsqueda binario a partir de los elementos de la lista de entrada o un array luego realiza un recorrido inorden en el árbol de búsqueda binario creado para obtener los elementos ordenados.&nbsp;</div><div style=\"text-align: justify; font-weight: normal;\"><br></div><div style=\"text-align: justify; \"><span style=\"font-weight: bold;\">Para recorrer un árbol binario no vacío en inorden, hay que realizar las siguientes operaciones recursivamente en cada nodo:&nbsp;</span></div><div style=\"text-align: justify; font-weight: normal;\"><span style=\"white-space:pre\">\t</span>1. Atraviese el sub-árbol o nodo izquierdo&nbsp;</div><div style=\"text-align: justify; font-weight: normal;\"><span style=\"white-space:pre\">\t</span>2. Visite la raiz&nbsp;</div><div style=\"text-align: justify; font-weight: normal;\"><span style=\"white-space:pre\">\t</span>3. Atraviese el sub-árbol o nodo derecho\r\n</div>",
    "complejidad_tiempo": "Mejor caso :    O(nlog(n))            Peor caso :     O(n2)             Promedio: O(nlog(n))",
    "java": "//Código java que implementa Tree Sort \n\npublic class TreeSort {\n    \n    //Clase conteniendo hijo izquierdo\n    //y derecho del nodo actual, y \n    // el valor del nodo (Key)\n    static class Node {\n        int key;\n        Node left, right;\n        public Node(int item) {\n            key = item;\n            left = right = null;\n        }\n    }\n    // Raiz del arbol de busqueda\n    //binaria\n    static Node root;\n    static void init() {\n        root = null;\n    }\n    static void insert(int key) {\n        root = insertRec(root, key);\n    }\n\n    /*Una función recursiva que inserta \n    nuevos valores al arbol de busqueda binaria*/\n    static Node insertRec(Node root, int key) {\n        /*Si el arbol esta vacio\n        Retorne un nuevo nodo*/\n        if (root == null) {\n            root = new Node(key);\n            return root;\n        }\n        /*De otra forma, baja por el arbol*/\n        if (key < root.key) {\n            root.left = insertRec(root.left, key);\n        } else if (key > root.key) {\n            root.right = insertRec(root.right, key);\n        }\n        /*Retorna la raiz*/\n        return root;\n    }\n\n    /*Una función que realiza recorrido\n    inorden atraves del arbol*/\n    static void inorderRec(Node root) {\n        if (root != null) {\n            inorderRec(root.left);\n            System.out.print(root.key + \" \");\n            inorderRec(root.right);\n        }\n    }\n\n    static void treeins(int arr[]) {\n        for (int i = 0; i < arr.length; i++) {\n            insert(arr[i]);\n        }\n    }\n\n    public static void main(String[] args) {\n        int arr[] = {5, 4, 7, 2, 11};\n        treeins(arr);\n        inorderRec(root);\n    }\n}\n",
    "cpp": "#include <bits/stdc++.h>\n#include <cstdlib>\nusing namespace std;\n\nstruct Node {\n    int key;\n    struct Node *left, *right;\n};\n\nstruct Node *newNode(int item) {\n    struct Node *temp = new Node;\n    temp->key = item;\n    temp->left = temp->right = NULL;\n    return temp;\n}\n\nvoid storeSorted(Node *root, int arr[], int &i) {\n    if (root != NULL) {\n        storeSorted(root->left, arr, i);\n        arr[i++] = root->key;\n        storeSorted(root->right, arr, i);\n    }\n}\n\nNode* insert(Node* node, int key) {\n    if (node == NULL) {\n        return newNode(key);\n    }\n    if (key < node->key) {\n        node->left = insert(node->left, key);\n    } else if (key > node->key) {\n        node->right = insert(node->right, key);\n    }\n    return node;\n}\n\nvoid printArray(int arr[], int n) {\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d \", arr[i]);\n    }\n}\n\nvoid treeSort(int arr[], int n) {\n    struct Node *root = NULL;\n\n    root = insert(root, arr[0]);\n    for (int i = 1; i < n; i++)\n        root = insert(root, arr[i]);\n\n    int i = 0;\n    storeSorted(root, arr, i);\n    printArray(arr, n);\n}\n \nint main() {\n    /*\n    int arr[]={2,3,5,1,32,4,50};\n    int n = sizeof(arr)/sizeof(arr[0]);\n    treeSort(arr,n);\n     */\n    string str;\n    getline(cin, str);\n    string intermediate;\n    vector<int> vec;\n    stringstream check1(str);\n    while (getline(check1, intermediate, ' ')) {\n        vec.push_back(atoi(intermediate.c_str()));\n    }\n    int arr[vec.size()];\n    for (int i = 0; i < vec.size(); ++i) {\n        arr[i] = vec[i];\n    }\n    treeSort(arr, vec.size());\n    return 0;\n}\n",
    "py": "from sys import stdin\nfrom sys import stdout\nrl = stdin.readline\nwr = stdout.write\n\n\nclass Hoja:\n\n    def __init__(self, item=None):\n        self.key = item\n        self.right = None\n        self.left = None\n        \nroot = Hoja()\n\ndef init():\n    global root\n    root = None\n\ndef insert(key):\n    global root\n    root = insertRec(root, key)\n\ndef insertRec(raiz, key):\n   \n    if raiz == None:\n        raiz = Hoja(key)\n        return raiz\n\n    if key < raiz.key:\n        raiz.left = insertRec(raiz.left, key)\n    elif key >= raiz.key:\n        raiz.right = insertRec(raiz.right, key)\n\n    return raiz\n\ndef inOrder(actual):\n    if actual != None:\n        inOrder(actual.left)\n        wr(f'{actual.key} ')\n        inOrder(actual.right)\n\n       \ndef insertInTree(arr):\n    for i in range(len(arr)):\n        insert(arr[i])\n\narr = list(map(int, rl().split()))\ninit()\ninsertInTree(arr)\ninOrder(root)\nwr('\\n')\n",
    "orden": 3,
    "suborden": 7,
    "fecha_creacion": "2020-12-04 20:09:36",
    "fecha_modificacion": "2020-12-06 20:05:47"
  },
  {
    "ID": 18,
    "supergrupo": "Ordenamientos",
    "tema": "Bitonic Sort",
    "texto": "Bitonic Sort es un algoritmo clásico para ordenamiento.\r\nEl ordenamiento bitónico hace comparaciones O (n Log 2n).\r\nEl número de comparaciones realizadas por Bitonic Sort son más que los algoritmos de clasificación populares como Merge Sort [hace O (nLogn) comparaciones], pero Bitonic es mejor para la implementación en paralelo porque siempre comparamos elementos en una secuencia predefinida y la secuencia de comparación no. Depende de los datos. Por lo tanto, es adecuado para la implementación en hardware y array de procesado paralelo&nbsp;<div><br></div><div>Para entender el ordenamiento bitónico, primero debemos entender qué es la secuencia bitónica y cómo hacer una secuencia dada bitónica.\r\nUna secuencia es bitónica si primero aumenta, luego disminuye. En otras palabras, una matriz arr [0...n-i] es bitonica si existe un índice i donde&nbsp;</div><div><br></div><div style=\"text-align: center;\">0 &lt;= i &lt;= n-1 tal que\r\nx0 &lt;= x1 ... .. &lt;= xi y xi&gt; = xi + 1 ... ..&gt; = xn-1&nbsp;</div><div><br></div><div>Para formar una secuencia ordenada de longitud n a partir de dos secuencias ordenadas de longitud n / 2, se requieren comparaciones de log (n) (por ejemplo: log (8) = 3 cuando el tamaño de la secuencia. Por lo tanto, el número de comparaciones T (n) de la clasificación completa está dada por:\r\nT (n) = log (n) + T (n / 2) la solución de esta ecuación de recurrencia es&nbsp;</div><div><br></div><div style=\"text-align: center;\">T (n) = log (n) + log (n) -1 + log (n) -2 +… + 1 = log (n) · (log (n) +1) / 2&nbsp;</div><div>&nbsp;</div><div>Cada etapa de la red de ordenamiento consiste en n / 2 comparaciones. Por lo tanto un total de O (n log2n) comparaciones.\r\n</div>",
    "complejidad_tiempo": "Mejor caso :    O(log2(n))            Peor caso :     O(log2(n))             Promedio: O(log2(n))",
    "java": "/* Programa java para Bitonic Sort*/\n/* Nota: Este programa solo funciona si el tamaño\nde la entrada es una potencia de 2*/\npublic class BitonicSort {\n\n    /* El parámetro dir indica la dirección de ordenamiento,\n       ASCENDIENDO o DESCENDIENDO; si (a [i]> a [j]) está de acuerdo\n       con la dirección, entonces a[i] y a[j] son\n        intercambiados*/\n    static void compAndSwap(int a[], int i, int j, int dir) {\n        if ((a[i] > a[j] && dir == 1)\n                || (a[i] < a[j] && dir == 0)) {\n            // intercambiando elementos\n            int temp = a[i];\n            a[i] = a[j];\n            a[j] = temp;\n        }\n    }\n\n    static void bitonicMerge(int a[], int low, int cnt, int dir) {\n        if (cnt > 1) {\n            int k = cnt / 2;\n            for (int i = low; i < low + k; i++) {\n                compAndSwap(a, i, i + k, dir);\n            }\n            bitonicMerge(a, low, k, dir);\n            bitonicMerge(a, low + k, k, dir);\n        }\n    }\n\n    static void bitonicSort(int a[], int low, int cnt, int dir) {\n        if (cnt > 1) {\n            int k = cnt / 2;\n            // Ordena en orden ascendente, dir es 1 \n            bitonicSort(a, low, k, 1);\n            // ordena en orden descendente, dir es 0\n            bitonicSort(a, low + k, k, 0);\n            // une toda la secuencia en orden ascendente\n            bitonicMerge(a, low, cnt, dir);\n        }\n    }\n\n    static void sort(int a[], int N, int up) {\n        bitonicSort(a, 0, N, up);\n    }\n\n    /*Imprimir array */\n    static void printArray(int arr[]) {\n        int n = arr.length;\n        for (int i = 0; i < n; ++i) {\n            System.out.print(arr[i] + \" \");\n        }\n        System.out.println();\n    }\n\n    public static void main(String args[]) {\n        int a[] = {3, 7, 4, 8, 6, 2, 1, 5};\n        int up = 1;\n        sort(a, a.length, up);\n        System.out.println(\"\\nArray ordenado\");\n        printArray(a);\n    }\n} \n",
    "cpp": "#include <iostream>\n\nusing namespace std;\n\nvoid compAndSwap(int arr[], int i, int j, int dir) {\n    if ((arr[i] > arr[j] && dir == 1) || (arr[i] < arr[j] && dir == 0)) {\n        swap(arr[i], arr[j]);\n    }\n}\n\nvoid bitonicMerge(int arr[], int low, int cnt, int dir) {\n    if (cnt > 1) {\n        int k = cnt / 2;\n        for (int i = low; i < low + k; i++) {\n            compAndSwap(arr, i, i + k, dir);\n        }\n        bitonicMerge(arr, low, k, dir);\n        bitonicMerge(arr, low + k, k, dir);\n    }\n}\n\nvoid bitonicSort(int arr[], int low, int cnt, int dir) {\n    if (cnt > 1) {\n        int k = cnt / 2;\n        bitonicSort(arr, low, k, 1);\n        bitonicSort(arr, low + k, k, 0);\n        bitonicMerge(arr, low, cnt, dir);\n    }\n}\n\nvoid sorted(int arr[], int N, int up) {\n    bitonicSort(arr, 0, N, up);\n}\n\nvoid printArray(int arr[], int n) {\n    for (int i = 0; i < n; ++i) {\n        if (i == n - 1) {\n            cout << arr[i] << endl;\n            break;\n        }\n        cout << arr[i] << \" \";\n    }\n}\n\nint main() {\n    int arr[] = {-5, -6, -1, -4, 8, 100, -90, -15, 35};\n    int up = 1;\n    int tam = sizeof (arr) / sizeof (arr[0]);\n    sorted(arr, tam, up);\n    cout << \"Array ordenado\" << endl;\n    printArray(arr, tam);\n    return 0;\n}\n",
    "py": "from sys import stdin, stdout\nrl = stdin.readline\nwr = stdout.write\n\ndef compAndSwap(arr, i, j, direc):\n    if (arr[i] > arr[j] and direc == 1) or (arr[i] < arr[j] and direc == 0):\n        arr[i], arr[j] = arr[j], arr[i]\n\ndef bitonicMerge(arr, low, cnt, direc):\n    if cnt > 1:\n        k = cnt // 2\n        for i in range(low, low+k):\n            compAndSwap(arr, i, i+k, direc)\n\n        bitonicMerge(arr, low, k, direc)\n        bitonicMerge(arr, low+k, k, direc)\n\n\ndef bitonicSort(arr, low, cnt, direc):\n\n    if cnt > 1:\n        k = cnt // 2\n        bitonicSort(arr, low, k, 1)\n        bitonicSort(arr, low+k, k, 0)\n        bitonicMerge(arr, low, cnt, direc)\n\n\ndef sortB(arr, n, up):\n    bitonicSort(arr, 0, n, up)\n\n\ndef printArray(arr):\n    for i in arr:\n        wr(f'{i} ')\n    wr('\\n')\n\n\narr = list(map(int, rl().split()))\nup = 1  # 0 = Mayor a Menor\nprintArray(arr)\nsortB(arr, len(arr), up)\nprintArray(arr)\n",
    "orden": 3,
    "suborden": 8,
    "fecha_creacion": "2020-12-04 20:09:36",
    "fecha_modificacion": "2020-12-07 02:01:08"
  },
  {
    "ID": 19,
    "supergrupo": "Ordenamientos",
    "tema": "Cocktail Sort",
    "texto": "Cocktail Sort es una variación de Bubble Sort.&nbsp;<div><br></div><div>El algoritmo de ordenamiento de burbuja siempre atraviesa elementos de la izquierda y mueve el elemento más grande a su posición correcta en la primera iteración y el segundo más grande en la segunda iteración, y así sucesivamente. El ordenamiento de cóctel atraviesa un vector dado en ambas direcciones alternativamente.&nbsp;</div><div><br></div><div>Las complejidades de tiempo son iguales, pero Cocktail se desempeña mejor que Bubble Sort. Por lo general, el cóctel es menos de dos veces más rápido que el tipo burbuja. Considere el ejemplo (2, 3, 4, 5, 1). La clasificación de burbuja requiere cuatro recorridos de matriz para este ejemplo, mientras que la clasificación de cóctel requiere solo dos recorridos.\r\n</div>",
    "complejidad_tiempo": "Mejor caso :    O(n)            Peor caso :     O(n2)             Promedio: O(n2)",
    "java": "// Programa java implementando Cocktail sort\n\npublic class CocktailSort {\n\n    static void cocktailSort(int a[]) {\n        boolean swapped = true;\n        int start = 0;\n        int end = a.length;\n        while (swapped == true) {\n            // Resetea la bandera intercambiada al entrar\n            // en el ciclo, porque puede ser true de la\n            // anterior iteración\n            swapped = false;\n            // Ciclo del fondo a encima igual\n            // que bubble sort\n            for (int i = start; i < end - 1; ++i) {\n                if (a[i] > a[i + 1]) {\n                    int temp = a[i];\n                    a[i] = a[i + 1];\n                    a[i + 1] = temp;\n                    swapped = true;\n                }\n            }\n            // Si nada fue movido, array esta ordenado\n            if (swapped == false) {\n                break;\n            }\n            // de otra forma, resetea la bandera intercambiada\n            // de tal forma que pueda ser usada en el \n            //siguiente proceso\n            swapped = false;\n            // Mueve el punto final atras en uno, porque\n            // el item al final esta en la derecha completa\n            end = end - 1;\n            // from top to bottom, doing the \n            // same comparison as in the previous stage \n            for (int i = end - 1; i >= start; i--) {\n                if (a[i] > a[i + 1]) {\n                    int temp = a[i];\n                    a[i] = a[i + 1];\n                    a[i + 1] = temp;\n                    swapped = true;\n                }\n            }\n            // Incrementa el punto inicial, por que\n            // la ultima fase pudo haber movido el siguiente\n            // más pequeño número en la derecha completa\n            start = start + 1;\n        }\n    }\n    /* Imprime el array*/\n    static void printArray(int a[]) {\n        int n = a.length;\n        for (int i = 0; i < n; i++) {\n            System.out.print(a[i] + \" \");\n        }\n        System.out.println();\n    }\n    public static void main(String[] args) {\n        int a[] = {5, 1, 4, 2, 8, 0, 2};\n        cocktailSort(a);\n        System.out.println(\"Arreglo ordenado\");\n        printArray(a);\n    }\n}\n",
    "cpp": "#include <iostream>\n\nusing namespace std;\n\nvoid cocktailSort(int arr[], int n) {\n    bool swapped = true;\n    int start = 0;\n    int ended = n;\n    while (swapped == true) {\n        swapped = false;\n        for (int i = start; i < ended - 1; ++i) {\n            if (arr[i] > arr[i + 1]) {\n                int temp = arr[i];\n                arr[i] = arr[i + 1];\n                arr[i + 1] = temp;\n                swapped = true;\n            }\n        }\n        if (swapped == false) {\n            break;\n        }\n        swapped = false;\n        ended = ended - 1;\n        for (int i = ended - 1; i >= start; i--) {\n            if (arr[i] > arr[i + 1]) {\n                int temp = arr[i];\n                arr[i] = arr[i + 1];\n                arr[i + 1] = temp;\n                swapped = true;\n            }\n        }\n        start += 1;\n    }\n}\n\nvoid printArray(int arr[], int n) {\n    for (int i = 0; i < n; i++) {\n        if (i == n - 1) {\n            cout << arr[i] << endl;\n            break;\n        }\n        cout << arr[i] << \" \";\n    }\n}\n\nint main() {\n    int arr[] = {-5, -90, 5, 9, 7, -15, 8, 2, -8, 0, 1, 32, -35};\n    int tam = sizeof (arr) / sizeof (arr[0]);\n    cocktailSort(arr, tam);\n    cout << \"Arreglo ordenado\" << endl;\n    printArray(arr, tam);\n    return 0;\n}\n",
    "py": "from sys import stdin, stdout\nrl = stdin.readline\nwr = stdout.write\n\ndef cocktailSort(arr):\n    swapped = True\n    start = 0\n    end = len(arr)\n    while swapped:  # Sort Izq a Der\n        swapped = False\n        for i in range(start, end-1):\n            if arr[i] > arr[i+1]:  # Cambiar < o >\n                arr[i], arr[i+1] = arr[i+1], arr[i]\n                swapped = True\n        if not swapped:\n            break\n\n    swapped = False\n    end -= 1\n    for i in range(end-1, start-1, -1):  # Sort Der a Izq\n        if arr[i] > arr[i+1]:  # Cambiar < o >\n            arr[i], arr[i+1] = arr[i+1], arr[i]\n            swapped = True\n\n    start += 1\n\n\ndef printArray(arr):\n    for i in arr:\n        wr(f'{i} ')\n    wr('\\n')\n\n\narr = list(map(int, rl().split()))\nprintArray(arr)\ncocktailSort(arr)\nprintArray(arr)\n",
    "orden": 3,
    "suborden": 9,
    "fecha_creacion": "2020-12-04 20:09:36",
    "fecha_modificacion": "2020-12-07 02:04:41"
  },
  {
    "ID": 20,
    "supergrupo": "Ordenamientos",
    "tema": "Comb Sort",
    "texto": "Comb Sort es principalmente una mejora sobre Bubble Sort. El ordenamiento de burbuja siempre compara valores adyacentes. Así que todas las inversiones se eliminan una por una. Comb Sort mejora en Bubble Sort usando un espacio de tamaño mayor que 1. El espacio comienza con un gran valor y se reduce en un factor de 1.3 en cada iteración hasta que alcanza el valor 1.&nbsp;<div><br></div><div>Por lo tanto, Comb Sort funciona mejor que Bubble Sort.\r\nAunque funciona mejor que Bubble Sort en promedio, el peor de los casos sigue siendo O (n^2).\r\n</div>",
    "complejidad_tiempo": "Mejor caso :    O(nlog(n))            Peor caso :     O(n2)             Promedio: O(n2/2incrementos)",
    "java": "// Programa java implementando Comb Sort\n\npublic class CombSort {\n\n    // Para buscar espacio entre elementos\n    static int getNextGap(int gap) {\n        gap = (gap * 10) / 13;\n        if (gap < 1) {\n            return 1;\n        }\n        return gap;\n    }\n\n    static void sort(int arr[]) {\n        int n = arr.length;\n        // Inicializa espacio\n        int gap = n;\n        boolean swapped = true;\n        /*Mantiene ejecutando mientras gap es más que 1 y la \n        ultima iteración causa un intercambio*/\n        while (gap != 1 || swapped == true) {\n            gap = getNextGap(gap);\n            /*Inicializa swapped como falso, aso \n            podemos verificar si el intercambio paso\n            o no*/\n            swapped = false;\n            //Compara todos los elementos con el espacio actual \n            for (int i = 0; i < n - gap; i++) {\n                if (arr[i] > arr[i + gap]) {\n                    //Intercambia arr[i] y arr[i+gap]\n                    int temp = arr[i];\n                    arr[i] = arr[i + gap];\n                    arr[i + gap] = temp;\n                    // Se intercambió\n                    swapped = true;\n                }\n            }\n        }\n    }\n\n    public static void main(String args[]) {\n        int arr[] = {8, 4, 1, 56, 3, -44, 23, -6, 28, 0};\n        sort(arr);\n        System.out.println(\"Array ordenado\");\n        for (int i = 0; i < arr.length; ++i) {\n            System.out.print(arr[i] + \" \");\n        }\n    }\n}\n",
    "cpp": "#include <iostream>\n\nusing namespace std;\n\nint getNextGap(int gap) {\n    gap = (gap * 10) / 13;\n    if (gap < 1) {\n        return 1;\n    }\n    return gap;\n}\n\nvoid sorted(int arr[], int n) {\n    int gap = n;\n    bool swapped = true;\n    while (gap != 1 || swapped == true) {\n        gap = getNextGap(gap);\n        swapped = false;\n        for (int i = 0; i < n - gap; i++) {\n            if (arr[i] > arr[i + gap]) {\n                int temp = arr[i];\n                arr[i] = arr[i + gap];\n                arr[i + gap] = temp;\n                swapped = true;\n            }\n        }\n    }\n}\n\nint main() {\n    int arr[] = {8, 4, 1, 56, 3, -44, 23, -6, 28, 0, -10};\n    int tam = sizeof (arr) / sizeof (arr[0]);\n    sorted(arr, tam);\n    cout << \"Array ordenado\" << endl;\n    for (int i = 0; i < tam; i++) {\n        if (i == tam - 1) {\n            cout << arr[i] << endl;\n            break;\n        }\n        cout << arr[i] << \" \";\n    }\n    return 0;\n}\n\n",
    "py": "from sys import stdin,stdout\nrl = stdin.readline\nwr = stdout.write\n\ndef getNextGap(gap):\n    gap = (gap * 10) // 13\n    if gap < 1:\n        return 1\n    return gap\n\ndef combSort(arr, n):\n\n    gap = n\n    swapped = True\n    \n    while gap != 1 or swapped:\n        gap = getNextGap(gap)\n        swapped = False\n        for i in range(n-gap):\n            if arr[i] > arr[i+gap]:\n                arr[i], arr[i+gap] = arr[i+gap], arr[i]\n                swapped = True\n\narr = list(map(int, rl().split()))\ncombSort(arr, len(arr))\nprint(*arr)\n",
    "orden": 3,
    "suborden": 10,
    "fecha_creacion": "2020-12-04 20:09:36",
    "fecha_modificacion": "2020-12-07 02:07:11"
  },
  {
    "ID": 21,
    "supergrupo": "Ordenamientos",
    "tema": "Counting Sort",
    "texto": "El ordenamiento por conteo es una técnica de ordenamiento basada en claves entre un rango específico. Funciona contando el número de objetos que tienen valores clave distintos (un tipo de hashing). Luego, hacer algo de aritmética para calcular la posición de cada objeto en la secuencia de salida.\r\n&nbsp;<div><br></div><div>1. El ordenamiento de conteo es eficiente si el rango de datos de entrada no es significativamente mayor que el número de objetos a clasificar. &nbsp;</div><div>2. No es una comparación basada en la clasificación. La complejidad del tiempo de ejecución es O (n) con espacio proporcional al rango de datos.&nbsp;</div><div>3. A menudo se usa como una sub-rutina para otro algoritmo de clasificación como la clasificación por radix.&nbsp;</div><div>4. EL ordenamiento de conteo usa un hashing parcial para contar la ocurrencia del objeto de datos en O (1).&nbsp;</div><div style=\"text-align: justify;\">5. El ordenamiento de conteo también se puede extender para que funcione con entradas negativas.\r\n</div>",
    "complejidad_tiempo": "Mejor caso :    O(n+k)            Peor caso :     O(n+k)             Promedio: O(n+k)",
    "java": "// Implementación java de Counting Sort\n\npublic class CountingSort {\n\n    static void sort(char arr[]) {\n        int n = arr.length;\n        // El array de caracteres que sera el array \n        // ordenado de salida\n        char output[] = new char[n];\n        // Crea un array de conteo para almacenar \n        // conteo individual de caracteres e inicializar\n        // array de conteo en 0\n        int count[] = new int[256];\n        for (int i = 0; i < 256; ++i) {\n            count[i] = 0;\n        }\n        // Almacena el conteo de cada caracter\n        for (int i = 0; i < n; ++i) {\n            ++count[arr[i]];\n        }\n        // Cambian count[i] de forma que ahora contenga la \n        //posición actual de este caracter en el array de saliday \n        for (int i = 1; i <= 255; ++i) {\n            count[i] += count[i - 1];\n        }\n        // Construye el array de caracteres de salida\n        // Para hacerlo estable lo hacemos en orden inverso\n        for (int i = n - 1; i >= 0; i--) {\n            output[count[arr[i]] - 1] = arr[i];\n            --count[arr[i]];\n        }\n        //Copia el array de salida a arr, asi arr ahora\n        // contiene los caracteres ordenados \n        for (int i = 0; i < n; ++i) {\n            arr[i] = output[i];\n        }\n    }\n\n    public static void main(String args[]) {\n        char arr[] = {'g', 'e', 'e', 'k', 's', 'f', 'o',\n            'r', 'g', 'e', 'e', 'k', 's'};\n        sort(arr);\n        System.out.print(\"array de caracteres ordenado: \");\n        for (int i = 0; i < arr.length; ++i) {\n            System.out.print(arr[i]);\n        }\n    }\n}\n",
    "cpp": "#include <iostream>\n#include <string.h>\n\nusing namespace std;\n\nvoid sorted(char arr[], int n) {\n    char output[n];\n    int counting[256];\n    memset(counting, 0, sizeof (counting));\n    for (int i = 0; i < n; i++) {\n        ++counting[arr[i]];\n    }\n    for (int i = 1; i <= 255; ++i) {\n        counting[i] += counting[i - 1];\n    }\n    for (int i = n - 1; i >= 0; i--) {\n        output[counting[arr[i]] - 1] = arr[i];\n        --counting[arr[i]];\n    }\n    for (int i = 0; i < n; ++i) {\n        arr[i] = output[i];\n    }\n}\n\nint main() {\n    string entrada = \"alkjslkjkdjaskjdkasjddf\";\n    char arr[entrada.size()];\n    strcpy(arr, entrada.c_str());\n    int tam = sizeof (arr) / sizeof (arr[0]);\n    sorted(arr, tam);\n    cout << \"Array de caracteres ordenado: \" << endl;\n    for (int i = 0; i < tam; i++) {\n        if (i == tam - 1) {\n            cout << arr[i] << endl;\n            break;\n        }\n        cout << arr[i] << \" \";\n    }\n    return 0;\n}\n",
    "py": "from sys import stdin, stdout\nrl = stdin.readline\nwl = stdout.write\n\n\ndef countSort(arr, n):\n\n    output = [''] * n\n    count = [0] * 256\n\n    for i in arr:\n        count[ord(i)] += 1\n\n    for i in range(1, 256):\n        count[i] += count[i-1]\n\n    for i in range(n-1, -1, -1):\n        output[count[ord(arr[i])]-1] = arr[i]\n        count[ord(arr[i])] -= 1\n\n    for i in range(n):\n        arr[i] = output[i]\n\n\narr = list(map(str, rl().split()))\ncountSort(arr, len(arr))\nprint(*arr)\n",
    "orden": 3,
    "suborden": 11,
    "fecha_creacion": "2020-12-04 20:09:36",
    "fecha_modificacion": "2020-12-07 02:09:54"
  },
  {
    "ID": 22,
    "supergrupo": "Ordenamientos",
    "tema": "Cycle Sort",
    "texto": "<div style=\"text-align: justify;\"><span style=\"font-size: 10pt;\">El ordenamiento por ciclos es un algoritmo de ordenamiento en el lugar, un ordenamiento de comparación que es teóricamente óptima en términos del número total de escrituras en el array original.&nbsp;\r\n</span></div><div style=\"text-align: justify;\"><span style=\"font-size: 10pt;\"><br></span></div><div style=\"text-align: justify;\"><span style=\"font-size: 10pt;\">Es óptimo en términos de cantidad de escrituras de memoria. Minimiza el número de escrituras de memoria para ordenar (cada valor se escribe cero veces, si ya está en su posición correcta, o se escribe una vez en su posición correcta).</span></div>",
    "complejidad_tiempo": "Mejor caso :    O(n2)            Peor caso :     O(n2)             Promedio: O(n2)",
    "java": "//Programa java implementando Cycle sort\n\npublic class CycleSort {\n\n    public static void cycleSort(int arr[], int n) {   \n  //Contador de escrituras en memoria\n        int writes = 0;\n        //Pasar poe los elementros del array\n        //y ponerlos en el lugar correcto \n        for (int cycle_start = 0; cycle_start <= n - 2; cycle_start++) {\n            // Inicializa item como punto inicial\n            int item = arr[cycle_start];\n            // Encuentra posicion donde nosotros pondremos el item\n            // Basicamente contamos todos los elementos más pequeños\n            //a la derecha del item\n            int pos = cycle_start;\n            for (int i = cycle_start + 1; i < n; i++) {\n                if (arr[i] < item) {\n                    pos++;\n                }\n            }\n            //Si item esta ya en la posicion correcta\n            if (pos == cycle_start) {\n                continue;\n            }\n            //Ignorar todos los elementos duplicados\n            while (item == arr[pos]) {\n                pos += 1;\n            }\n            //Ponemos el item en su posición correcta\n            if (pos != cycle_start) {\n                int temp = item;\n                item = arr[pos];\n                arr[pos] = temp;\n                writes++;\n            }\n            //Rota el resto del ciclo\n            while (pos != cycle_start) {\n                pos = cycle_start;\n                // Encuentra posicion donde poner el elemento \n                for (int i = cycle_start + 1; i < n; i++) {\n                    if (arr[i] < item) {\n                        pos += 1;\n                    }\n                }\n                //Ignora todos los duplicados\n                while (item == arr[pos]) {\n                    pos += 1;\n                }\n                // Ponemos el item en su posición correcta\n                if (item != arr[pos]) {\n                    int temp = item;\n                    item = arr[pos];\n                    arr[pos] = temp;\n                    writes++;\n                }\n            }\n        }\n    }\n\n    public static void main(String[] args) {\n        int arr[] = {1, 8, 3, 9, 10, 10, 2, 4};\n        int n = arr.length;\n        cycleSort(arr, n);\n        System.out.println(\"Luego de ordenar : \");\n        for (int i = 0; i < n; i++) {\n            System.out.print(arr[i] + \" \");\n        }\n    }\n}\n",
    "cpp": "#include <iostream>\n\nusing namespace std;\n\nvoid cycleSort(int arr[], int n) {\n    int writes = 0;\n    for (int cycle_start = 0; cycle_start <= n - 2; cycle_start++) {\n        int item = arr[cycle_start];\n        int pos = cycle_start;\n        for (int i = cycle_start + 1; i < n; i++) {\n            if (arr[i] < item) {\n                pos++;\n            }\n        }\n        if (pos == cycle_start) {\n            continue;\n        }\n        while (item == arr[pos]) {\n            pos += 1;\n        }\n        if (pos != cycle_start) {\n            int temp = item;\n            item = arr[pos];\n            arr[pos] = temp;\n            writes++;\n        }\n        while (pos != cycle_start) {\n            pos = cycle_start;\n            for (int i = cycle_start + 1; i < n; i++) {\n                if (arr[i] < item) {\n                    pos += 1;\n                }\n            }\n            while (item == arr[pos]) {\n                pos += 1;\n            }\n            if (item != arr[pos]) {\n                int temp = item;\n                item = arr[pos];\n                arr[pos] = temp;\n                writes++;\n            }\n        }\n    }\n}\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cout.tie(NULL);\n    int arr[] = {1, 8, 3, 9, 10, -10, -5, -4, -8, -90, 90, 80};\n    int n = sizeof (arr) / sizeof (arr[0]);\n    cycleSort(arr, n);\n    cout << \"Luego de ordenar:\" << endl;\n    for (int i = 0; i < n; i++) {\n        if (i == n - 1) {\n            cout << arr[i] << endl;\n            break;\n        }\n        cout << arr[i] << \" \";\n    }\n    return 0;\n}\n",
    "py": "from sys import stdin, stdout\nrl = stdin.readline\nwr = stdout.write\n\n\ndef cycleSort(arr, n):\n\n    writes = 0\n    for cyclestart in range(n-2):\n        item = arr[cyclestart]\n        pos = cyclestart\n\n        for i in range(cyclestart+1, n):\n            if arr[i] < item:\n                pos += 1\n\n        if pos == cyclestart:\n            continue\n\n        while item == arr[pos]:\n            pos += 1\n\n        if pos != cyclestart:\n            item, arr[pos] = arr[pos], item\n            writes += 1\n\n        while pos != cyclestart:\n            pos = cyclestart\n            for i in range(cyclestart+1, n):\n                if arr[i] < item:\n                    pos += 1\n            while item == arr[pos]:\n                pos += 1\n            if item != arr[pos]:\n                item, arr[pos] = arr[pos], item\n                writes += 1\n\n\narr = list(map(int, rl().split()))\ncycleSort(arr, len(arr))\nprint(*arr)\n",
    "orden": 3,
    "suborden": 12,
    "fecha_creacion": "2020-12-04 20:09:36",
    "fecha_modificacion": "2020-12-07 02:10:17"
  },
  {
    "ID": 23,
    "supergrupo": "Ordenamientos",
    "tema": "3 Way Merge Sort",
    "texto": "Merge sort envuelve separación recursiva del array en dos partes, ordenamiento y finalmente unión de las mismas. Una variante de merge sort es llamado merge sort de tres vías donde en vez de separar el array en dos partes se separa en tres. Merge sort recursivamente rompe los arrays en arrays de tamaño medio, Merge de tres vías hace lo mismo en arrays de tamaño de un tercio.\nComplejidad de tiempo: En caso de Merge Sort se tiene la ecuación T(n) = 2T(n/2) + O(n). Igualmente en caso de Merge de tres vías se tiene la ecuación(n) = 3T(n/3) + O(n) por lo que la aproximación más cercana de su complejidad es: O(n log 3n).\n",
    "complejidad_tiempo": "Mejor caso :    O(nlog3n)            Peor caso :     O(nlog3n)             Promedio: O(nlog3n)",
    "java": "//Programa java que realiza Merge Sort de tres vias\n\npublic class MergeSort3Way {\n\n    public static void mergeSort3Way(Integer[] gArray) {   \n        //Si el arrat tiene tamaño 0, retorna null\n        if (gArray == null) {\n            return;\n        }\n        //Creando duplicado del array dado\n        Integer[] fArray = new Integer[gArray.length];\n        //Copiando elementos del array dado al\n        //array duplicado\n        System.arraycopy(gArray, 0, fArray, 0, fArray.length);\n        mergeSort3WayRec(fArray, 0, gArray.length, gArray);\n        //Copiando elementos del array duplicado al\n        //array dado\n        System.arraycopy(fArray, 0, gArray, 0, fArray.length);\n    }\n\n    /*Realizando el algoritmo Merge Sort en el array\n    dado para los valores en el rando de los indices \n    [low,high], low es el menor y high es el mayor\n    Exclusivo*/\n    public static void mergeSort3WayRec(Integer[] gArray,\n            int low, int high, Integer[] destArray) {\n        //Si el array tiene tamaño 1 no haga nada\n        if (high - low < 2) {\n            return;\n        }\n        // Separando el array en tres partes\n        int mid1 = low + ((high - low) / 3);\n        int mid2 = low + 2 * ((high - low) / 3) + 1;\n        // Ordenando las tres partes recursivamente\n        mergeSort3WayRec(destArray, low, mid1, gArray);\n        mergeSort3WayRec(destArray, mid1, mid2, gArray);\n        mergeSort3WayRec(destArray, mid2, high, gArray);\n        // Uniendo las tres partes\n        merge(destArray, low, mid1, mid2, high, gArray);\n    }\n\n    /*Une los rangos ordenados (low, mid1),(mid1,mid2)\n    y (mid2, high), mid 1 es el primer indice punto \n    medio en todo el rando para unir mid2 es segundo*/\n    public static void merge(Integer[] gArray, int low,\n            int mid1, int mid2, int high,\n            Integer[] destArray) {\n        int i = low, j = mid1, k = mid2, l = low;\n        // escoje el más pequeño de los más pequeños en los\n        //tres rangos\n        while ((i < mid1) && (j < mid2) && (k < high)) {\n            if (gArray[i].compareTo(gArray[j]) < 0) {\n                if (gArray[i].compareTo(gArray[k]) < 0) {\n                    destArray[l++] = gArray[i++];\n                } else {\n                    destArray[l++] = gArray[k++];\n                }\n            } else {\n                if (gArray[j].compareTo(gArray[k]) < 0) {\n                    destArray[l++] = gArray[j++];\n                } else {\n                    destArray[l++] = gArray[k++];\n                }\n            }\n        }\n        while ((i < mid1) && (j < mid2)) {\n            if (gArray[i].compareTo(gArray[j]) < 0) {\n                destArray[l++] = gArray[i++];\n            } else {\n                destArray[l++] = gArray[j++];\n            }\n        }\n        while ((j < mid2) && (k < high)) {\n            if (gArray[j].compareTo(gArray[k]) < 0) {\n                destArray[l++] = gArray[j++];\n            } else {\n                destArray[l++] = gArray[k++];\n            }\n        }\n        while ((i < mid1) && (k < high)) {\n            if (gArray[i].compareTo(gArray[k]) < 0) {\n                destArray[l++] = gArray[i++];\n            } else {\n                destArray[l++] = gArray[k++];\n            }\n        }\n        while (i < mid1) {\n            destArray[l++] = gArray[i++];\n        }\n        while (j < mid2) {\n            destArray[l++] = gArray[j++];\n        }\n        while (k < high) {\n            destArray[l++] = gArray[k++];\n        }\n    }\n\n    public static void main(String args[]) {\n        Integer[] data = new Integer[]{45, -2, -45, 78,\n            30, -42, 10, 19, 73, 93};\n        mergeSort3Way(data);\n        System.out.println(\"Despues de merge sort de 3 vias: \");\n        for (int i = 0; i < data.length; i++) {\n            System.out.print(data[i] + \" \");\n        }\n    }\n}\n",
    "cpp": "#include<bits/stdc++.h>\n#include<cstdlib>\nusing namespace std;\n\nvoid mergeArr(int gArray[], int low, int mid1, int mid2, int high, int arrdest[]) {\n    int i = low, j = mid1, k = mid2, l = low;\n    while ((i < mid1) && (j < mid2) && (k < high)) {\n        if (gArray[i] < gArray[j]) {\n            if (gArray[i] < gArray[k]) {\n                arrdest[l++] = gArray[i++];\n            } else {\n                arrdest[l++] = gArray[k++];\n            }\n        } else {\n            if (gArray[j] < gArray[k]) {\n                arrdest[l++] = gArray[j++];\n            } else {\n                arrdest[l++] = gArray[k++];\n            }\n        }\n    }\n    while ((i < mid1) && (j < mid2)) {\n        if (gArray[i] < gArray[j]) {\n            arrdest[l++] = gArray[i++];\n        } else {\n            arrdest[l++] = gArray[j++];\n        }\n    }\n    while ((j < mid2) && (k < high)) {\n        if (gArray[j] < gArray[k]) {\n            arrdest[l++] = gArray[j++];\n        } else {\n            arrdest[l++] = gArray[k++];\n        }\n    }\n    while ((i < mid1) && (k < high)) {\n        if (gArray[i] < gArray[k]) {\n            arrdest[l++] = gArray[i++];\n        } else {\n            arrdest[l++] = gArray[k++];\n        }\n    }\n    while (i < mid1) {\n        arrdest[l++] = gArray[i++];\n    }\n    while (j < mid2) {\n        arrdest[l++] = gArray[j++];\n    }\n    while (k < high) {\n        arrdest[l++] = gArray[k++];\n    }\n}\n\nvoid mergeSort3wayRec(int arr[], int low, int high, int arrdest[]) {\n    if (high - low < 2) {\n        return;\n    }\n    int mid1 = low + ((high - low) / 3);\n    int mid2 = low + 2 * ((high - low) / 3) + 1;\n    mergeSort3wayRec(arrdest, low, mid1, arr);\n    mergeSort3wayRec(arrdest, mid1, mid2, arr);\n    mergeSort3wayRec(arrdest, mid2, high, arr);\n\n    mergeArr(arrdest, low, mid1, mid2, high, arr);\n}\n\nvoid mergeSort3way(int arr[], int n) {\n    if (n == 0) {\n        return;\n    }\n    int farr[n];\n    for (int i = 0; i < n; i++) {\n        farr[i] = arr[i];\n    }\n    mergeSort3wayRec(farr, 0, n, arr);\n    for (int i = 0; i < n; i++) {\n        arr[i] = farr[i];\n    }\n}\n\nvoid printArr(int arr[], int n) {\n    for (int i = 0; i < n; i++) {\n        cout << arr[i] << \" \";\n    }\n    cout << endl;\n}\n\nint main() {\n    int arr[] = {1, 3, 54, 255, 2, 5, 3, 1, 5, 7, 4, 299, 3, 54, 64, 73};\n    int N = sizeof (arr) / sizeof (arr[0]);\n    mergeSort3way(arr, N);\n    cout << \"arreglo ordenados\" << endl;\n    printArr(arr, N);\n} \n",
    "py": null,
    "orden": 3,
    "suborden": 13,
    "fecha_creacion": "2020-12-04 20:09:36",
    "fecha_modificacion": "2020-12-06 20:05:51"
  },
  {
    "ID": 24,
    "supergrupo": "Ordenamientos",
    "tema": "Pigeon Hole Sort",
    "texto": "Ordenamiento nido de Paloma es un algoritmo de ordenamiento que es adecuado para ordenar listas de elementos donde el número de elementos y el número de valores de los mismos son aproximadamente lo mismo.\r\nEste requiere un tiempo de  O(n + Rango) donde n es el número de elementos en el array de entrada y Rango es el número de posibles valores en el array. Este algoritmo es similar a Counting sort, pero difiere en la forma en que mueve los datos, dos veces.\r\n",
    "complejidad_tiempo": "Mejor caso :    O(N+n)            Peor caso :     O(N+n)             Promedio: O(N+n)\nN=rango \n",
    "java": "/*Programa java que implementa Pigeonhole Sort*/\nimport java.util.*;\n\npublic class PigeonholeSort {\n\n    static void pigeonhole_sort(int arr[],int n) {\n        int min = arr[0];\n        int max = arr[0];\n        int range, i, j, index;\n        for (int a = 0; a < n; a++) {\n            if (arr[a] > max) {\n                max = arr[a];\n            }\n            if (arr[a] < min) {\n                min = arr[a];\n            }\n        }\n        range = max - min + 1;\n        int[] phole = new int[range];\n        Arrays.fill(phole, 0);\n        for (i = 0; i < n; i++) {\n            phole[arr[i] - min]++;\n        }\n        index = 0;\n        for (j = 0; j < range; j++) {\n            while (phole[j]-- > 0) {\n                arr[index++] = j + min;\n            }\n        }\n    }\n\n    public static void main(String[] args) {\n        int[] arr = {8, 3, 2, 7, 4, 6, 8};\n        System.out.print(\"Array ordenado : \");\n        pigeonhole_sort(arr, arr.length);\n        for (int i = 0; i < arr.length; i++) {\n            System.out.print(arr[i] + \" \");\n        }\n    }\n}\n",
    "cpp": "#include <iostream>\n#include <string.h>\n#include <vector>\n\nusing namespace std;\n\nvoid pigeonHoleSort(int arr[], int n) {\n    int minim = arr[0];\n    int maxim = arr[0];\n    int range, i;\n    for (int a = 0; a < n; a++) {\n        if (arr[a] > maxim) {\n            maxim = arr[a];\n        }\n        if (arr[a] < minim) {\n            minim = arr[a];\n        }\n    }\n    range = maxim - minim + 1;\n\n    //Crear un arreglo de vectores de tamamio range.\n    //Cada vector representa un agujero que estara\n    //para contener los elementos que coincidentes\n    vector<int> pHole[range];\n    memset(pHole, 0, range);\n\n    //Atravesar el arreglo de entrada y colocar cada elemento\n    //en su respectivo agujero\n    for (i = 0; i < n; i++) {\n        pHole[arr[i] - minim].push_back(arr[i]);\n    }\n\n    //Recorrer todos los agujeros uno a uno.\n    //Para cada agujero, se toma sus elementos y se\n    //colocan en el arreglo dado.\n    int index = 0;\n    for (i = 0; i < range; i++) {\n        for (int k : pHole[i]) {\n            arr[index++] = k;\n        }\n    }\n}\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cout.tie(NULL);\n    int arr[] = {-8, 4, -5, 8, -6, 90, 70, -95, -100, 105, 97, -1000};\n    cout << \"Arreglo ordenado:\" << endl;\n    int n = sizeof (arr) / sizeof (arr[0]);\n    pigeonHoleSort(arr, n);\n    for (int i = 0; i < n; i++) {\n        if (i == n - 1) {\n            cout << arr[i] << endl;\n            break;\n        }\n        cout << arr[i] << \" \";\n    }\n    return 0;\n}\n",
    "py": "from sys import stdin\nfrom sys import stdout\n\nin_, out = stdin.readline, stdout.write\n\ndef gen(arr): yield from arr\n\ndatos_int = lambda: list(map(int, in_().strip().split()))\n\n\ndef pigeonSort(arr, n):\n    mn = arr[0]\n    mx = arr[0]\n    for k in range(n):\n        if arr[k] > mx:\n            mx = arr[k]\n        if arr[k] < mn:\n            mn = arr[k]\n    range_ = mx - mn + 1\n    phole = [0] * range_\n    for i in range(n):\n        phole[arr[i] - mn] += 1\n    index = 0\n    for j in range(range_):\n        while phole[j]:\n            arr[index] = j + mn\n            index += 1\n            phole[j] -= 1\n\nlista = datos_int()\nn = len(lista)\npigeonSort(lista, n)\nfor i in gen(lista):\n    out(f\"{i} \")\nprint()\n",
    "orden": 3,
    "suborden": 14,
    "fecha_creacion": "2020-12-04 20:09:36",
    "fecha_modificacion": "2020-12-07 02:10:52"
  },
  {
    "ID": 25,
    "supergrupo": "Strings",
    "tema": "Algoritmo de Knuth-Morris-Pratt ",
    "texto": "<div style=\"font-weight: normal; text-align: justify;\"><span style=\"font-size: 10pt;\">Dado un texto txt[0…n-1] y un patrón pat[0...m-1] busque todas las ocurrencias de pat en txt e imprímalas, asuma que n es mayor que m.&nbsp;</span></div><div style=\"font-weight: normal; text-align: justify;\"><span style=\"font-size: 10pt;\"><br></span></div><div style=\"font-weight: normal; text-align: justify;\">El algoritmo KMP usa la propiedad de degeneración (Usar los subpatrones que se puedan crear a partir del patrón) del patrón y mejora el peor caso de complejidad de O(n). La idea básica detrás de KMP es: Cuando detectemos una no coincidencia (luego de algunas coincidencias), ya sabemos algunos de los caracteres en el texto de la siguiente ventana. Tomamos ventaja de esta información para evadir coincidencias de caracteres que sabemos que de todas maneras coincidirán.&nbsp;</div><div style=\"font-weight: normal; text-align: justify;\"><br></div><div style=\"text-align: justify;\"><span style=\"font-weight: bold;\">Revisión del preprocesado:</span>\r\nKMP preprocesa pat[] y construye un lps[] auxiliar de tamaño m (El mismo tamaño que el patrón) el cual es usado para saltar caracteres mientras se coteja.\r\nEl nombre lps indica el prefijo propio más largo el cual es también sufijo. Un prefijo propio es un prefijo  con todo el string no permitido. Por ejemplo, prefijos de “ABC” son “”,”A”,”AB” Y “ABC”, prefijos propios son “”, “A” y “AB”. Sufijos del string son “”, “C”,”BC” y “ABC”.\r\nBuscamos por lps en subpatrones. Más claramente nos enfocamos en los subsring de patrones que son prefijos y sufijos. Por cada subpatron pat[0...i] donde i=0 hasta m-1, lps[i] almacena la longitud del máximo prefijo propio coincidente el cual también es sufijo del subpatron pat[0...i].\r\nAlgoritmo de búsqueda:\r\nA diferencia de los algoritmos ingenuos, donde deslizamos el patrón uno por uno y comparamos todos los caracteres en cada movimientos, usamos un valor de lps[] para decidir los nuevos caracteres que serán cotejados, la idea es no cotejar un carácter que sabemos que va a aparecer.&nbsp;</div><div style=\"text-align: justify;\"><span style=\"font-weight: bold;\"><br></span></div><div style=\"text-align: justify;\"><span style=\"font-weight: bold;\">¿Cómo usamos lps [] para decidir las siguientes posiciones o número de caracteres que serán saltadas?&nbsp;</span></div><div style=\"text-align: justify;\"><span style=\"font-size: 10pt;\"><br></span></div><div style=\"text-align: justify;\"><span style=\"font-size: 10pt;\">Comenzamos la comparación de pat [j] con j=0 con los caracteres de la actual ventana de texto. Seguimos cotejando caracteres de txt[i] y pat [j] y seguimos incrementando i y j mientras pat[j] y txt [i] sigan coincidiendo.\r\nCuando vemos una no coincidencia, sabemos que los caracteres pat[0…j-1] coinciden con txt[i-j…..i-1] (Nótese que j inicia en 0 e incrementa solo cuando hay una coincidencia). También sabemos que lps[j-1] está contando los caracteres de pat[o…j-1] que son prefijo propio y sufijo.\r\nDe estos puntos podemos concluir que nosotros no necesitaremos cotejar estos lps[j-1] caracteres con txt porque sabemos que de todas formas esos caracteres coincidirán.</span></div>",
    "complejidad_tiempo": "Mejor caso :    On)            Peor caso :     O(n+m)             Promedio: O(m+n)",
    "java": "/* Programa java implementando el algoritmo \nde busqueda KMP*/\npublic class KMPStringMatching {\n\n    static void KMPSearch(String pat, String txt) {\n        int M = pat.length();\n        int N = txt.length();\n        // Crea lps[] el cual podra mantener el\n        // más largo prefijo sufijo para patrón\n        int lps[] = new int[M];\n        int j = 0; // indice de pat[] \n        // Preprocesa el patrón (Calcula lps[]) \n        computeLPSArray(pat, M, lps);\n        int i = 0; // indice para txt[] \n        while (i < N) {\n            if (pat.charAt(j) == txt.charAt(i)) {\n                j++;\n                i++;\n            }\n            if (j == M) {\n                System.out.println(\"Encontrado patrón \"\n                        + \"en indice \" + (i - j));\n                j = lps[j - 1];\n            } // no coincide luego de j veces\n            else if (i < N && pat.charAt(j) != txt.charAt(i)) {\n                /*No coincide lps[0..lps[j-1]] caracteres\n                ellos coincidiran de todos modos*/\n                if (j != 0) {\n                    j = lps[j - 1];\n                } else {\n                    i = i + 1;\n                }\n            }\n        }\n    }\n\n    static void computeLPSArray(String pat, int M, int lps[]) {\n        // Longitus del anterior prefijo sufijo más largo\n        int len = 0;\n        int i = 1;\n        lps[0] = 0; // lps[0] es siempre 0\n        // el ciclo calcula lps[i] para i = 1 hasta M-1 \n        while (i < M) {\n            if (pat.charAt(i) == pat.charAt(len)) {\n                len++;\n                lps[i] = len;\n                i++;\n            } else // (pat[i] != pat[len])  \n            {\n                // Esto es dificl, considere el ejemplo\n                // AAACAAAA y i = 7. la idea es similar\n                // el paso de busqueda\n                if (len != 0) {\n                    len = lps[len - 1];\n                    // Tambien, note que no incrementamos \n                    //i aqui\n                } else {\n                    // if (len == 0) \n                    lps[i] = len;\n                    i++;\n                }\n            }\n        }\n    }\n\n    public static void main(String args[]) {\n        String txt = \"ABABDABACDABABCABAB\";\n        String pat = \"ABABCABAB\";\n        KMPSearch(pat, txt);\n    }\n}\n",
    "cpp": "#include<bits/stdc++.h>\n#include<cstdlib>\nusing namespace std;\n\nvoid computeLPSArray(string pat, int M, int lps[]) {\n    int len = 0;\n    int i = 1;\n    lps[0] = 0;\n    while (i < M) {\n        if (pat[i] == pat[len]) {\n            len++;\n            lps[i] = len;\n            i++;\n        } else {\n            if (len != 0) {\n                len = lps[len - 1];\n            } else {\n                lps[i] = len;\n                i++;\n            }\n        }\n    }\n}\n\nvoid KMPsearch(string pat, string txt) {\n    int M = pat.size();\n    int N = txt.size();\n    int lps[M];\n    int j = 0;\n    computeLPSArray(pat, M, lps);\n    int i = 0;\n    while (i < N) {\n        if (pat[j] == txt[i]) {\n            j++;\n            i++;\n        }\n        if (j == M) {\n            cout << \"Patron encontrado en el indice \" << (i - j) << endl;\n            j = lps[j - 1];\n        } else if (i < N && pat[j] != txt[i]) {\n            if (j != 0) {\n                j = lps[j - 1];\n            } else {\n                i++;\n            }\n        }\n    }\n}\n\nint main() {\n    string txt = \"lalalalalala\";\n    string pat = \"lal;\n    KMPsearch(pat, txt);\n}\n",
    "py": "def KMPsearch(pat, txt):\n    M = len(pat)\n    N = len(txt)\n    lps = [None for x in range(M)]\n    j = 0\n    computeLPSArray(pat, M, lps)\n    i = 0\n    while i < N:\n        if pat[j] == txt[i]:\n            i += 1\n            j += 1\n        if j == M:\n            print(\"Encontrado patrÃ³n (\", pat, \") en el indice \", (i - j), \"-\", ((i - j) + M - 1))\n            j = lps[j - 1]\n        elif i < N and pat[j] != txt[i]:\n            if j != 0:\n                j = lps[j-1]\n            else:\n                i += 1\n\ndef computeLPSArray(pat, M, lps):\n    leng = 0\n    i = 1\n    lps[0] = 0\n    while i < M:\n        if pat[i] == pat[leng]:\n            leng += 1\n            lps[i] = leng\n            i += 1\n        else:\n            if leng != 0:\n                leng = lps[leng-1]\n            else:\n                lps[i] = leng\n                i += 1\n\ndef variasBúsquedas(arr, txt):\n    for i in range(len(arr)):\n        KMPsearch(arr[i], txt)\n\ntxt = \"lalalalalalalalalalala\"\narr = [\"la\", \"lal\", \"lala\"]\nvariasBúsquedas(arr, txt)\n",
    "orden": 5,
    "suborden": 99,
    "fecha_creacion": "2020-12-04 20:09:36",
    "fecha_modificacion": "2020-12-07 02:13:00"
  },
  {
    "ID": 26,
    "supergrupo": "Strings",
    "tema": "Algoritmo de Rabin-Karp ",
    "texto": "<div style=\"font-weight: normal; text-align: justify;\"><span style=\"font-size: 10pt;\">Dado un texto txt[0...n-1] y un patrón pat[0...m-1] busque todas las ocurrencias de pat en txt e imprímalas, asuma que n es mayor que m.&nbsp;</span></div><div style=\"font-weight: normal; text-align: justify;\"><span style=\"font-size: 10pt;\"><br></span></div><div style=\"font-weight: normal; text-align: justify;\"><span style=\"font-size: 10pt;\">Como los algoritmos ingenuos, Rabin-Karp también desliza el patrón uno por uno, pero a diferencia de este, RK coteja el valor hash del patrón con el valor hash del actual substring de texto y su los valores hash coinciden entonces solo empieza a cotejar caracteres individuales, entonces RK necesita calcular los valores hash de los siguientes strings.&nbsp;</span></div><div style=\"font-weight: normal; text-align: justify;\"><span style=\"font-size: 10pt;\"><br></span></div><div style=\"font-weight: normal; text-align: justify;\"><span style=\"font-size: 10pt;\">1) El string patrón&nbsp;</span></div><div style=\"font-weight: normal; text-align: justify;\"><span style=\"font-size: 10pt;\">2) Todos los substrings del texto de tamaño m.&nbsp;</span></div><div style=\"font-weight: normal; text-align: justify;\"><span style=\"font-size: 10pt;\"><br></span></div><div style=\"font-weight: normal; text-align: justify;\"><span style=\"font-size: 10pt;\">Desde que necesitamos calcular eficientemente los valores hash de todos los substrings de tamaño m del texto, debemos tener una función hash la cual tenga la siguiente propiedad.\r\nEl hash del siguiente cambio debe ser eficientemente calculable desde el hash actual y el siguiente carácter en el texto o podemos decir hashtxt[s+1….. s+m])= rehash (txt[s+m], hash(txt[s….s+m-1]) y rehash debe ser una operación O(1).&nbsp;</span></div><div style=\"font-weight: normal; text-align: justify;\"><span style=\"font-size: 10pt;\"><br></span></div><div style=\"font-weight: normal; text-align: justify;\"><span style=\"font-size: 10pt;\">La función hash sugerida por Rabin y Karp calcula un valor entero, el valor entero para  un string es un valor número de un string, por ejemplo el número si todos los posibles caracteres son de 1 a 10, el valor número de “122” seria 122. El número de posibles caracteres es mayor que 10 (256 en general) y la longitud el patrón puede ser larga. Entonces los valores numéricos no pueden ser prácticamente almacenados como un entero. Sin embargo el valor número es calculado usando matemática modular para asegurar que los valores hash pueden ser almacenados en una variable entra (puede caber en palabras de memoria).&nbsp;</span></div><div style=\"font-weight: normal; text-align: justify;\"><span style=\"font-size: 10pt;\"><br></span></div><div style=\"font-weight: normal; text-align: justify;\"><span style=\"font-size: 10pt;\">Para hacer rehashing, necesitamos tomar el más significante digito y añadirlo nuestro nuevo digito significante para el valor hash, el rehashing se realiza con la siguiente formula\r\n- hash( txt[s+1 .. s+m] ) = ( d ( hash( txt[s .. s+m-1]) – txt[s]*h ) + txt[s + m] ) mod q\r\n- hash( txt[s .. s+m-1] ) :  Valor hash en cambio s.\r\n- hash( txt[s+1 .. s+m] ) : Valor has en nuevo cambio ( cambio s+1)\r\n- d:Número de caracteres en el alfabeto\r\n- q: Un número primo\r\n- h: d^(m-1)\r\nEsto es matemática simple, calculamos el valor decimal de la actual ventana desde la ventana anterior.\r\nPor ejemplo el tamaño del patrón es 3 y el string es “23456”\r\nSe calcula el valor de la primera ventana el cual es 234 (String ventana es “234”).&nbsp;</span></div><div style=\"font-weight: normal; text-align: justify;\"><span style=\"font-size: 10pt;\"><br></span></div><div style=\"text-align: justify;\"><span style=\"font-size: 10pt; font-weight: bold;\">¿Cómo puedes calcular el valor de la siguiente ventana “345”?&nbsp;</span></div><div style=\"font-weight: normal; text-align: justify;\"><span style=\"font-size: 10pt;\"><br></span></div><div style=\"font-weight: normal; text-align: justify;\"><span style=\"font-size: 10pt;\">se puede hacer (234 – 2*100)*10 + 5 y obtener 345.\r\nEl promedio y mejor tiempo de ejecución en un caso de RK es de O(n+m) pero su peor caso es O(nm). El peor caso de Rabin-Karp ocurre cuando todos los caracteres del patrón y el texto tienen los mismos valores hash de todos los substrings de txt, por ejemplo pat[]=”AAA”  y txt[]=”AAAAAAA”.</span></div>",
    "complejidad_tiempo": "Mejor caso :    O(m+n)            Peor caso :     O(n*m)             Promedio: O(n*m)",
    "java": "/*Implementación java del algoritmo de \nRabin Karp*/\npublic class RabinKarp {   \n// d es elnúmero de caracteres en el alfabeto de entrada\n\n    public final static int d = 256;\n\n    /* pat -> patrón \n        txt -> texto\n        q -> Un número primo\n     */\n    static void search(String pat, String txt, int q) {\n        int M = pat.length();\n        int N = txt.length();\n        int i, j;\n        int p = 0; // valor hash  del patrón\n        int t = 0; // valor hash  del txt \n        int h = 1;\n        // el valor de h debe ser \"pow(d, M-1)%q\"\n        for (i = 0; i < M - 1; i++) {\n            h = (h * d) % q;\n        }\n        /*Calcula el valor hash del patron y primera \n        ventana de texto*/\n        for (i = 0; i < M; i++) {\n            p = (d * p + pat.charAt(i)) % q;\n            t = (d * t + txt.charAt(i)) % q;\n        }\n        //Desliza el patrón por encima del texto uno por uno\n        for (i = 0; i <= N - M; i++) {\n            /*Verifica los valores hash de la actual ventana de text\n            y patrón. Si el valor hash coincide entonces solo revisa \n            los caratceres uno por uno*/\n            if (p == t) {\n                /*Revisa por caracteres uno por uno*/\n                for (j = 0; j < M; j++) {\n                    if (txt.charAt(i + j) != pat.charAt(j)) {\n                        break;\n                    }\n                }\n                // Si p==t y pat[0...M-1] = txt[i, i+1, ...i+M-1] \n                if (j == M) {\n                    System.out.println(\"Patron encontrado en el indice \" + i);\n                }\n            }\n            // Calcula el valor hash de la siguiente ventana de texto\n            // Remueve el digito lider, y final\n            if (i < N - M) {\n                t = (d * (t - txt.charAt(i) * h) + txt.charAt(i + M)) % q;\n                /*Nosotros obtendremos un valor negativo de t\n                convirtiendolo a positivo*/\n                if (t < 0) {\n                    t = (t + q);\n                }\n            }\n        }\n    }\n\n    public static void main(String[] args) {\n        String txt = \"EQUIPO ARTEMIS\";\n        String pat = \"ARTE\";\n        int q = 101; // un número primo\n        search(pat, txt, q);\n    }\n}\n",
    "cpp": "using namespace std;\n#include<bits/stdc++.h>\n#include<cstdlib>\n#define FAST ios_base::sync_with_stdio(false);cin.tie(NULL);cout.tie(0);cout<<setprecision(25);\nint d = 256;\n\nvoid rabinKarp(string pat, string txt, int q) {\n    int M = pat.size();\n    int N = txt.size();\n    int i, j; //indices\n    int p = 0;\n    int t = 0;\n    int h = 1; //tamanio del hash\n    for (i = 0; i < M - 1; i++) {\n        h = (h * d) % q;\n    }\n    for (i = 0; i < M; i++) {\n        p = (d * p + pat[i]) % q;\n        t = (d * i + txt[i]) % q;\n    }\n    for (i = 0; i <= N - M; i++) {\n        if (p == t) {\n            for (j = 0; j < M; j++) {\n                if (txt[i + j] != pat[j]) {\n                    break;\n                }\n            }\n            if (j == M) {\n                cout << \"Patron encontrado en el indice \" << i << \" \" << (i + M - 1) << endl;\n            }\n        }\n        if (i < N - M) {\n            t = (d * (t - txt[i] * h) + txt[i + M]) % q;\n            if (t < 0) {\n                t = (t + q);\n            }\n        }\n    }\n}\n\nint main() {\n    FAST\n    string txt = \"anita lava la tina\";\n    string pat = \"la\";\n    rabinKarp(pat, txt, d);\n}\n",
    "py": "from sys import stdin\nfrom sys import stdout\nd = 256\n\n\ndef rabinKarp(pat, txt, q):\n    M = len(pat)\n    N = len(txt)\n    i, j, p, t, h = int(0), int(0), int(0), int(0), int(1)\n    for i in range(M-1):\n        h = (h * d) % q\n    for i in range(M):\n        p = (d * p + ord(pat[i])) % q\n        t = (d * t + ord(txt[i])) % q\n    for i in range(N-M + 1):\n        if p == t:\n            for j in range(M):\n                if txt[i + j] != pat[j]:\n                    break\n            j += 1\n            if j == M:\n                stdout.write(f'Patron en {str(i)} - {str(i+M-1)}\\n')\n        if i < N-M:\n            t = (d * (t-ord(txt[i]) * h) + ord(txt[i + M])) % q\n            if t < 0:\n                t = t + q\n\n\ntxt = 'Anita lava la tina'\npat = 'la'\nrabinKarp(pat, txt, d)\n\n",
    "orden": 5,
    "suborden": 99,
    "fecha_creacion": "2020-12-04 20:09:36",
    "fecha_modificacion": "2020-12-07 02:14:48"
  },
  {
    "ID": 27,
    "supergrupo": "Strings",
    "tema": "Algoritmo de Boyer-Moore ",
    "texto": "<div style=\"font-weight: normal; text-align: justify;\"><span style=\"font-size: 10pt;\">Cuando realizamos una búsqueda de un string en Notepad, Word, buscador o una base de datos, los algoritmos de búsquedas de patrones son usados para buscar los resultados.&nbsp;</span></div><div style=\"font-weight: normal; text-align: justify;\"><span style=\"font-size: 10pt;\"><br></span></div><div style=\"font-weight: normal; text-align: justify;\"><span style=\"font-size: 10pt;\">Un enunciado de este problema podría ser:\r\nDado un texto txt[0…n-1] y un patrón pat[0...m-1] busque una función que imprima todas las ocurrencias de pat en txt, se asume que n es mayor que m.&nbsp;</span></div><div style=\"font-weight: normal; text-align: justify;\"><span style=\"font-size: 10pt;\"><br></span></div><div style=\"font-weight: normal; text-align: justify;\"><span style=\"font-size: 10pt;\">Como KMP y Boyer Moore también preprocesa el patrón, Boyer Moore es la combinación de las siguientes dos aproximaciones:\r\n1) Heurística de caracteres malos\r\n2) Heurística de buenos sufijos\r\nAmbas de las dos heurísticas de arriba pueden también ser usadas independientemente para buscar un patrón en un texto. Primero entendamos como estas dos aproximaciones trabajan juntos en Boyer Moore. Si tomamos un vistazo a cualquier algoritmo ingenuo, desliza el patrón sobre el texto carácter por carácter. KMP hace preprocesado sobre el patrón de tal forma que el patrón puede ser cambiado más de una vez.&nbsp;</span></div><div style=\"font-weight: normal; text-align: justify;\"><span style=\"font-size: 10pt;\"><br></span></div><div style=\"font-weight: normal; text-align: justify;\"><span style=\"font-size: 10pt;\">El algoritmo de Boyer Moore hace preprocesado por la misma razón. Este procesa el patrón y crea arrays diferentes para cada heurística. En cada paso desliza el patrón por el máximo de deslices sugeridos por las dos heurísticas, entonces usa la mejor de las dos heurísticas en cada paso.\r\nA diferencia de los anteriores algoritmos de búsqueda de patrones, Boyer Moore comienza el cotejamiento desde el último carácter del patrón.&nbsp;</span></div><div style=\"font-weight: normal; text-align: justify;\"><span style=\"font-size: 10pt;\"><br></span></div><div style=\"text-align: justify;\"><span style=\"font-size: 10pt; font-weight: bold;\">Heurística de caracteres malos&nbsp;</span></div><div style=\"font-weight: normal; text-align: justify;\"><span style=\"font-size: 10pt;\">La idea de esta heurística es simple. El carácter del texto que no coincida con el carácter actual del patrón es llamado un carácter malo. Con esta no coincidencia nosotros movemos el patrón hasta:&nbsp;</span></div><div style=\"font-weight: normal; text-align: justify;\"><span style=\"font-size: 10pt;\"><br></span></div><div style=\"font-weight: normal; text-align: justify;\"><span style=\"font-size: 10pt;\"><span style=\"white-space:pre\">\t</span>1) La no coincidencia se convierta en un cotejamiento positivo.&nbsp;</span></div><div style=\"font-weight: normal; text-align: justify;\"><span style=\"font-size: 10pt;\"><span style=\"white-space:pre\">\t</span>2) Patrón P se mueve después del carácter no coincidente.&nbsp;</span></div><div style=\"font-weight: normal; text-align: justify;\"><span style=\"font-size: 10pt;\"><br></span></div><div style=\"font-weight: normal; text-align: justify;\"><span style=\"font-size: 10pt;\">Caso 1: No coincidencia se convierte en una coincidencia\r\nBuscamos la posición de la última ocurrencia del carácter no coincidente en el patrón y si el carácter no coincidente existe en el patrón, entones movemos el patrón de tal manera que quede alineado con el carácter no coincidente en el texto T.&nbsp;</span></div><div style=\"font-weight: normal; text-align: justify;\"><span style=\"font-size: 10pt;\"><br></span></div><div style=\"font-weight: normal; text-align: justify;\"><span style=\"font-size: 10pt;\">Caso 2: El patrón se mueve pasado el carácter no coincidente\r\nNosotros buscamos la posición de la última ocurrencia del carácter no coincidente en el patrón y si el carácter no existe deberíamos mover el patrón pasado ese carácter.</span></div>",
    "complejidad_tiempo": "Mejor caso :    O(n)            Peor caso :     O(3n)             Promedio: O(n)",
    "java": "/*Programa java para heuristica de malos caracteres\nusando el algoritmo de Boyer Moore*/\n\npublic class BoyerMoore {\n\n    static int NO_OF_CHARS = 256;\n    //Una función de utilidad para obtener el maximo de\n    //dos enteros\n    static int max(int a, int b) {\n        return (a > b) ? a : b;\n    }\n    //El preprocesado del algoritmo\n    static void badCharHeuristic(char[] str, int size, int badchar[]) {\n        int i;\n        // Inicializa todas las ocurrencias en  -1 \n        for (i = 0; i < NO_OF_CHARS; i++) {\n            badchar[i] = -1;\n        }\n        /*Llena el actual valor de la ultima ocurrencia\n        de un caracter*/\n        for (i = 0; i < size; i++) {\n            badchar[(int) str[i]] = i;\n        }\n    }\n\n    /* Una función de busqueda de patrón que usa \n     la heuristica de mal caracter*/\n    static void search(char txt[], char pat[]) {\n        int m = pat.length;\n        int n = txt.length;\n        int badchar[] = new int[NO_OF_CHARS];\n        /* Llena el arreglo de malos caracteres llamando\n        la función de preprocesado para el patrón dado*/\n        badCharHeuristic(pat, m, badchar);\n        int s = 0;  // s  es cambiado del patron con respecto al texto  \n        while (s <= (n - m)) {\n            int j = m - 1;\n            /* Mantiene reduciento el indice j para el patrón\n            mientras los caracteres del patrón y el texto \n            estan coincidiendo en s*/\n            while (j >= 0 && pat[j] == txt[s + j]) {\n                j--;\n            }\n            /*Si el patrón esta presente en el actual\n            cambio, entonces el indice j se convertira en -1\n            luego del ciclo de arriba*/\n            if (j < 0) {\n                System.out.println(\"Patrón encontrado en cambio = \" + s);\n                s += (s + m < n) ? m - badchar[txt[s + m]] : 1;\n            } else {\n                s += max(1, j - badchar[txt[s + j]]);\n            }\n        }\n    }\n    public static void main(String[] args) {\n        char txt[] = \"ABAAABCDABCABC\".toCharArray();\n        char pat[] = \"ABC\".toCharArray();\n        search(txt, pat);\n    }\n}\n",
    "cpp": "#include<bits/stdc++.h>\n#include<cstdlib>\nusing namespace std;\nconst int NO_OF_CHARS = 256;\n\nint MAX(int a, int b) {\n    return a > b ? a : b;\n}\n\nvoid badCharHeuristic(char str[], int siz, int badchar[]) {\n    int i;\n    memset(badchar, -1, sizeof badchar);\n    for (i = 0; i < siz; i++) {\n        badchar[(int) str[i]] = i;\n    }\n}\n\nvoid boyerMoore(char txt[], char pat[]) {\n    int m = strlen(pat);\n    int n = strlen(txt);\n    int badchar[NO_OF_CHARS];\n    badCharHeuristic(pat, m, badchar);\n    int s = 0;\n    while (s <= (n - m)) {\n        int j = m - 1;\n        while (j <= 0 && pat[j] == txt[s + j]) {\n            j--;\n        }\n        if (j > 0) {\n            cout << \"Patron encontrado encontrado en salto \" << s << endl;\n            s += (s + m < m) ? badchar[txt[s + m]] : 1;\n        } else {\n            s += MAX(1, j - badchar[txt[s + j]]);\n        }\n    }\n}\n\nint main() {\n    char txt[] = \"lalalalalalalala\";\n    char pat[] = \"lala\";\n    boyerMoore(txt, pat);\n}\n",
    "py": "\nfrom sys import stdout\nwr = stdout.write\n\nNO_OF_CHARS = 256\n\ndef badChar(string, size, badchar):\n    for i in range(size):\n        badchar[ord(string[i])] = i\n\n\ndef BMsearch(txt, pat):\n\n    M = len(pat)\n    N = len(txt)\n    badchar = [0] * NO_OF_CHARS\n    badChar(pat, M, badchar)\n    s = 0\n\n    while s <= N-M:\n        j = M-1\n        while j >= 0 and pat[j] == txt[s+j]:\n            j -= 1\n        if j < 0:\n            wr(f'\"{\"\".join(txt[s:s+M])}\" encontrado en el indice ({s} - {s+M-1})\\n')\n            s += M - badchar[ord(txt[s+M])] if s + M < N else 1\n        else:\n            s += max(1, j - badchar[ord(txt[s+j])])\n\n\ntxt = 'anitalavalatina'\npat = 'al'\nBMsearch(txt, pat)\n",
    "orden": 5,
    "suborden": 0,
    "fecha_creacion": "2020-12-04 20:09:36",
    "fecha_modificacion": "2020-12-07 02:17:36"
  },
  {
    "ID": 28,
    "supergrupo": "Strings",
    "tema": "Patrón en anagramas",
    "texto": "Dado un texto txt [0...n-1] y un patrón pat [0...m-11], use una función que imprima todas las ocurrencias de pat [] y sus permutaciones (o anagramas) en txt [], se asume que n es menor que m.&nbsp;<div style=\"font-weight: normal;\"><br></div><div style=\"font-weight: normal;\">La complejidad de tiempo esperada es de O(n).\r\nEste problema es ligeramente diferente a la búsqueda de patrones estándar, aquí necesitamos buscar por anagramas también. Por lo tanto no podemos aplicar directamente la búsqueda de patrones estándar de algoritmos como KMP, Rabin Karp o Boyer Moore.\r\nPodemos conseguir una complejidad de tiempo de O(n) asumiendo que el tamaño del alfabeto está arreglado en los 256 caracteres ASCII.&nbsp;</div><div style=\"font-weight: normal;\"><br></div><div style=\"\"><span style=\"font-weight: bold;\">La idea es usar dos arrays de conteo:&nbsp;</span></div><div style=\"font-weight: normal;\"><span style=\"white-space:pre\">\t</span>1) El primer array de conteo almacena la frecuencia de los caracteres en el patrón.&nbsp;</div><div style=\"font-weight: normal;\"><span style=\"white-space:pre\">\t</span>2) El Segundo array de conteo almacena la frecuencia en la actual ventana de texto.&nbsp;</div><div style=\"font-weight: normal;\"><br></div><div style=\"font-weight: normal;\">Una cosa importante a tener en cuenta es, la complejidad de tiempo de comparar dos arrays de conteo es O(1) como el número de elementos en ellos.&nbsp;</div><div style=\"font-weight: normal;\"><br></div><div style=\"\"><span style=\"font-weight: bold;\">Estos son los pasos de este algoritmo:&nbsp;</span></div><div style=\"font-weight: normal;\"><span style=\"white-space:pre\">\t</span>1) Almacena conteos de frecuencia del patrón en el primer array de conteo countP []. También almacena conteo de frecuencias de la primera ventana de texto en el array countTW[].&nbsp;</div><div style=\"font-weight: normal;\"><span style=\"font-size: 10pt;\"><span style=\"white-space:pre\">\t</span>2) Ahora ejecuta un ciclo de i=M hasta N-1 haciendo lo siguiente en cada ciclo:&nbsp;</span></div><div style=\"font-weight: normal;\"><span style=\"font-size: 10pt;\"><span style=\"white-space:pre\">\t\t</span>a) Si los dos arrays de conteo son idénticos, hemos encontrado una ocurrencia.&nbsp;</span></div><div style=\"font-weight: normal;\"><span style=\"font-size: 10pt;\"><span style=\"white-space:pre\">\t\t</span>b) Incrementa el conteo del actual carácter del texto en countTW[]\r\nc) Decrementa conteo del primer carácter en la ventana anterior en countWT[]\r\n3) La última ventana no es revisada por&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; este ciclo, se revisa explícitamente</span></div>",
    "complejidad_tiempo": "Mejor caso :    O(n)            Peor caso :     O(n)             Promedio: O(n)",
    "java": "// Programa java que busca todos los anagramás\n// de un patrón en un texto \n\npublic class AnagramsPattern {\n\n    static final int MAX = 256;\n    // Esta función retorna true si los contenidos\n    // de arr1[] y arr2[] son iguales, de otra forma es falso\n\n    static boolean compare(char arr1[], char arr2[]) {\n        for (int i = 0; i < MAX; i++) {\n            if (arr1[i] != arr2[i]) {\n                return false;\n            }\n        }\n        return true;\n    }\n    // Esta función busca todas las permutaciones de \n    // pat[] en txt[]\n\n    static void search(String pat, String txt) {\n        int M = pat.length();\n        int N = txt.length();\n        // countP[]:  Almacena el conteo de todos\n        // los caracteres del patrón\n        // countTW[]: Almacena el conteo de los caracteres\n        // la ventana de texto\n        char[] countP = new char[MAX];\n        char[] countTW = new char[MAX];\n        for (int i = 0; i < M; i++) {\n            (countP[pat.charAt(i)])++;\n            (countTW[txt.charAt(i)])++;\n        }\n        //Atravesar atravez de los caracteres restantes de patrón\n        for (int i = M; i < N; i++) {   //Compara conteos de la ventana actual\n            // de texto con los conteos de pattern[]\n            if (compare(countP, countTW)) {\n                System.out.println(\"Encontrado en indice \"\n                        + (i - M));\n            }\n            // Agreca el actual caracter a la ventana actual\n            (countTW[txt.charAt(i)])++;\n            // Remueve el primer caracter de la anterior ventana\n            countTW[txt.charAt(i - M)]--;\n        }\n        // Revisa por la ultima ventana en el texto\n        if (compare(countP, countTW)) {\n            System.out.println(\"Encontrado en indice \"\n                    + (N - M));\n        }\n    }\n\n    public static void main(String args[]) {\n        String txt = \"BACDGABCDA\";\n        String pat = \"ABCD\";\n        search(pat, txt);\n    }\n}\n",
    "cpp": "#include <iostream>\n#include <string.h>\n\nusing namespace std;\n\nconst int MAX = 256;\n\nbool compare(char arr1[], char arr2[]){\n    for(int i = 0; i < MAX; i++){\n        if(arr1[i] != arr2[i]){\n            return false;\n        }\n    }\n    return true;\n}\n\nvoid anagramsSearch(string pat, string txt){\n    int M = pat.size();\n    int N = txt.size();\n    char countP[MAX];\n    char countTX[MAX];\n    memset(countP,0 , MAX);\n    memset(countTX, 0, MAX);\n    for(int i = 0; i < M; i++){\n        countP[pat[i]]++;\n        countTX[txt[i]]++;\n    }\n    for(int i = M; i < N; i++){\n        if(compare(countP, countTX)){\n            cout << \"Encontrado en el indice \"<<(i - M)<<\" Anagrama: \"<<txt.substr(i - M, M)<<endl;\n        }\n        countTX[txt[i]]++;\n        countTX[txt[i - M]]--;\n    }\n    if(compare(countP, countTX)){\n        cout<<\"Encontrado en el indice \"<<(N - M) <<\" Anagrama: \"<< txt.substr(N - M, N) << endl;\n    }\n}\n\nint main()\n{\n    string txt = \"anitalavalatinaanilegustviajarnitatani\";\n    string pat = \"anita\";\n    anagramsSearch(pat, txt);\n    return 0;\n}\n",
    "py": "from sys import stdout\nwr = stdout.write\n\nMAX = 256\n\ndef anagramsSearch(pat, txt):\n\n    M = len(pat)\n    N = len(txt)\n    countP = [0] * MAX\n    countTW = [0] * MAX\n\n    for i in range(M):\n        countP[ord(pat[i])] += 1\n        countTW[ord(txt[i])] += 1\n    for i in range(M, N):\n        if countP == countTW:\n            wr(f'\"{txt[i-M:i]}\" encontrado en el indice ({i-M} - {i-1})\\n')\n        countTW[ord(txt[i])] += 1\n        countTW[ord(txt[i-M])] -= 1\n    if countP == countTW:\n        wr(f'\"{txt[N-M:N]}\" encontrado en el indice ({N-M} - {N-1})\\n')\n\n\ntxt = 'BACDGABCDAABDCDBA'\npat = 'ABDC'\nanagramsSearch(pat, txt)\n",
    "orden": 5,
    "suborden": 1,
    "fecha_creacion": "2020-12-04 20:09:36",
    "fecha_modificacion": "2020-12-07 02:18:52"
  },
  {
    "ID": 29,
    "supergrupo": "Strings",
    "tema": "Wildcard",
    "texto": "Dado un texto y un patrón de wildcards, se debe implementar un algoritmo que encuentre si el patrón wildcard concuerda con el texto, el cotejamiento debe cubrir todo el texto.&nbsp;<div style=\"font-weight: normal;\"><br></div><div style=\"font-weight: normal;\">El patrón wildcard puede incluir los caracteres ‘?’ y ‘*’:\r\n‘?’ – Coteja cualquier carácter solitario.\r\n‘*’ – Coteja cualquier secuencia de caracteres (Incluyendo una secuencia vacía).\r\nCada ocurrencia de ‘?’ en el patrón wildcard puede ser reemplazado con cualquier otro carácter y cada ocurrencia de ‘*’ con una secuencia de caracteres tales que el patrón de wildcard se convierta en idéntico al string de entrada luego del reemplazo.&nbsp;</div><div style=\"font-weight: normal;\"><br></div><div style=\"font-weight: normal;\">Consideremos cualquier carácter en el patrón.&nbsp;</div><div style=\"font-weight: normal;\"><br></div><div style=\"\"><span style=\"font-weight: bold;\">Caso 1: El carácter es ‘*’&nbsp;</span></div><div style=\"font-weight: normal;\"><br></div><div style=\"font-weight: normal;\">Aquí dos cosas pueden pasar:\r\n- Podemos ignorar el carácter ‘*’ y movernos al siguiente carácter del patrón.\r\n- El carácter ‘*’ coincide con uno o más caracteres en el texto, aquí podemos movernos al carácter siguiente en el string.&nbsp;</div><div style=\"font-weight: normal;\"><br></div><div style=\"\"><span style=\"font-weight: bold;\">Caso 2: El carácter es ‘?’:&nbsp;</span></div><div style=\"font-weight: normal;\"><br></div><div style=\"font-weight: normal;\">Podemos ignorar el actual carácter en el texto y movernos al siguiente carácter en el patrón y texto.&nbsp;</div><div style=\"font-weight: normal;\"><br></div><div style=\"\"><span style=\"font-weight: bold;\">Caso 3: El carácter no es un carácter wildcard&nbsp;</span></div><div style=\"font-weight: normal;\"><br></div><div style=\"font-weight: normal;\">Si el carácter actual en el texto coincide con el actual carácter en el patrón, podemos movernos al siguiente carácter en el patrón y el texto, si no concuerdan, el patrón wildcard y el texto.</div>",
    "complejidad_tiempo": "Mejor caso :    O(n*m)            Peor caso :     O(n*m)             Promedio: O(n*m)",
    "java": "//Programa java que implementa el cotejamiento\n// de patrones con Wildcard\n\nimport java.util.Arrays;\n\npublic class WildcardPattern {\n    //Función que coteja str con el patron wildcard\n\n    static boolean strmatch(String str, String pattern,\n            int n, int m) {\n        // Patron vacio colo puede coincidir \n        // con string vacio\n        if (m == 0) {\n            return (n == 0);\n        }\n        // Tabla de busqueda para almacenar resultados\n        // de subproblemás\n        boolean[][] lookup = new boolean[n + 1][m + 1];\n        //Inicializa la tabla en falso\n        for (int i = 0; i < n + 1; i++) {\n            Arrays.fill(lookup[i], false);\n        }\n        lookup[0][0] = true;\n        //Solo '*' puede coincidri con string vacio\n        for (int j = 1; j <= m; j++) {\n            if (pattern.charAt(j - 1) == '*') {\n                lookup[0][j] = lookup[0][j - 1];\n            }\n        }\n        // Llena la tabla \n        for (int i = 1; i <= n; i++) {\n            for (int j = 1; j <= m; j++) {\n                /*Dos casos que podemos ver de '*'\n                a) Ignoramos '*' y pasamos al siguiente\n                caracter en el patrón\n                b) '*' coincide con un iesimo\n                caracter en una entrada*/\n\n                if (pattern.charAt(j - 1) == '*') {\n                    lookup[i][j] = lookup[i][j - 1]\n                            || lookup[i - 1][j];\n                } /*Actuales caracteres son considerados \n                como coincidentes en dos casos\n                a) actual caracter de patron es '?'\n                b) caracteres actuales coinciden*/ \n                else if (pattern.charAt(j - 1) == '?'\n                        || str.charAt(i - 1) == pattern.charAt(j - 1)) {\n                    lookup[i][j] = lookup[i - 1][j - 1];\n                } // Si el caracter no coincide\n                else {\n                    lookup[i][j] = false;\n                }\n            }\n        }\n        return lookup[n][m];\n    }\n\n    public static void main(String args[]) {\n        String str = \"baaabab\";\n        String pattern = \"*****ba*****ab\";\n        //Casos de prueba \n        // String pattern = \"ba*****ab\";\n        // String pattern = \"ba*ab\";\n        // String pattern = \"a*ab\";\n        // String pattern = \"a*****ab\";\n        // String pattern = \"*a*****ab\";\n        // String pattern = \"ba*ab****\";\n        // String pattern = \"****\";\n        // String pattern = \"*\";\n        // String pattern = \"aa?ab\";\n        // String pattern = \"b*b\";\n        // String pattern = \"a*a\";\n        // String pattern = \"baaabab\";\n        // String pattern = \"?baaabab\";\n        // String pattern = \"*baaaba*\"; \n\n        if (strmatch(str, pattern, str.length(),\n                pattern.length())) {\n            System.out.println(\"Si\");\n        } else {\n            System.out.println(\"No\");\n        }\n    }\n}\n",
    "cpp": "using namespace std;\n#include<bits/stdc++.h>\n#include<cstdlib>\n#define FAST ios_base::sync_with_stdio(false);cin.tie(NULL);cout.tie(0);\n#define Afill(x,y) memset(x,y,sizeof x)\nbool strMatch(string str,string pat,int n,int m){\n    if(m==0){\n        return n==0;\n    }\n    bool lookup[n+1][m+1];\n    for(int i=0;i<n+1;i++){\n        Afill(lookup[i],false);\n    }\n    lookup[0][0]=true;\n    for(int j=1;j<=m;j++){\n        if(pat[j-1]=='*'){\n            lookup[0][j]=lookup[0][j-1];\n        }\n    }\n    for(int i=1;i<=n;i++){\n        for(int j=1;j<=m;j++){\n            if(pat[j-1]=='*'){\n                lookup[i][j]=lookup[i][j-1]||lookup[i-1][j];\n            }else if(pat[j-1]=='?' || str[i-1]==pat[j-1]){\n                lookup[i][j]=lookup[i-1][j-1];\n            }else{\n                lookup[i][j]=false;\n            }\n        }\n    }\n    return lookup[n][m];\n}\nint main() {\n    FAST\n    string str=\"baaaaababa\";\n    string pat=\"ba*******?\";\n    if(strMatch(str,pat,str.size(),pat.size())){\n        cout<<\"Si\"<<endl;\n    }else{\n        cout<<\"No\"<<endl;\n    }\n}\n",
    "py": "from sys import stdin, stdout\nrl = stdin.readline\nwr = stdout.write\n\n\ndef wildCardStrMatch(strn, pat, n, m):\n\n    if m == 0:\n        return n == 0\n\n    lookup = [[False for x in range(m+1)] for x in range(n+1)]\n    lookup[0][0] = True\n\n    for i in range(1, m+1):\n        if pat[i-1] == '*':\n            lookup[0][i] = lookup[0][i-1]\n\n    for i in range(1, n+1):\n        for j in range(1, m+1):\n            if pat[j-1] == '*':\n                lookup[i][j] = lookup[i][j-1] or lookup[i-1][j]\n            elif pat[j-1] == '?' or strn[i-1] == pat[j-1]:\n                lookup[i][j] = lookup[i-1][j-1]\n            else:\n                lookup[i][j] = False\n\n    return lookup[n][m]\n\n\ntxt = 'anitalavalatina'\npat = '?nit?lava*'\n\nif wildCardStrMatch(txt, pat, len(txt), len(pat)):\n    wr('Iguales\\n')\nelse:\n    wr('Diferentes\\n')\n",
    "orden": 5,
    "suborden": 2,
    "fecha_creacion": "2020-12-04 20:09:36",
    "fecha_modificacion": "2020-12-07 02:19:43"
  },
  {
    "ID": 30,
    "supergrupo": "Strings",
    "tema": "Algoritmo de Manacher",
    "texto": "<div style=\"text-align: justify;\"><span style=\"font-size: 10pt;\">Dado un string, encuentre el substring más largo que sea palíndromo.&nbsp;</span></div><div style=\"text-align: justify;\">Si el string dado es “abaaba” la salida deberá ser “abaaba”&nbsp;</div><div style=\"text-align: justify;\"><br></div><div style=\"text-align: justify;\">Vamos a considerar el string “abababa”.\r\nAquí el centro del string es el 4to carácter con índice 3, si cotejamos más caracteres en la izquierda y derecha del centro todos los caracteres coinciden y el string es palíndromo.\r\nConsidere el string “abaaba” de tamaño par. Este string es palíndromo alrededor de la posición entre el 3er y 4to carácter.&nbsp;</div><div style=\"text-align: justify;\"><br></div><div style=\"text-align: justify;\">Para encontrar el substring más largo palíndromo de un string de tamaño N, una vía es tomar cada posible 2*N+1 centros (las N posiciones de caracteres, N-1 entre dos caracteres y dos posiciones en los fines de derecha e izquierda), haga que el carácter coincida en ambas direcciones en cada 2*N+1 centros y siga rastreando por LPS (Longest palindromic string).&nbsp;</div><div style=\"text-align: justify;\"><br></div><div style=\"text-align: justify;\">Si el string dado es “abababa” la salida debe ser “abababa”&nbsp;</div><div style=\"text-align: justify;\"><span style=\"font-size: 10pt;\"><br></span></div><div style=\"text-align: justify;\"><span style=\"font-size: 10pt;\">Si el string dado es “abcbabcbabcba” la salida debe ser “abcbabcba”</span></div>",
    "complejidad_tiempo": "Mejor caso :    O(n)            Peor caso :     O(n)             Promedio: O(n)",
    "java": "// Programa java implementando el algoritmo de Manacher\n// LPS: longest palindrome string\n\npublic class ManacherAlgorithm {\n\n    static char text[];\n\n    public static void main(String[] args) {\n        text = \"babcbabcbaccba\".toCharArray();\n        findLongestPalindromicString();\n        text = \"abaaba\".toCharArray();\n        findLongestPalindromicString();\n        text = \"abababa\".toCharArray();\n        findLongestPalindromicString();\n        text = \"abcbabcbabcba\".toCharArray();\n        findLongestPalindromicString();\n        text = \"caba\".toCharArray();\n        findLongestPalindromicString();\n        text = \"abacdfgdcaba\".toCharArray();\n        findLongestPalindromicString();\n        text = \"abacdfgdcabba\".toCharArray();\n        findLongestPalindromicString();\n        text = \"abacdedcaba\".toCharArray();\n        findLongestPalindromicString();\n    }\n\n    static int min(int a, int b) {\n        int res = a;\n        if (b < a) {\n            res = b;\n        }\n        return res;\n    }\n\n    static void findLongestPalindromicString() {\n        int N = text.length;\n        if (N == 0) {\n            return;\n        }\n        N = 2 * N + 1; //Conteo de posición\n        int L[] = new int[N]; //LPS tamaño de array\n        L[0] = 0;\n        L[1] = 1;\n        int C = 1; //Posición central\n        int R = 2; //posición Centro derecho\n        int i = 0; //Posición actual derecho\n        int iMirror; //Posición actual izquierda\n        int maxLPSLength = 0;\n        int maxLPSCenterPosition = 0;\n        int start = -1;\n        int end = -1;\n        int diff = -1;\n        //Descomentar para imprimir tamaño del arreglo LPS\n        //printf(\"%d %d \", L[0], L[1]); \n        for (i = 2; i < N; i++) {\n            iMirror = 2 * C - i;\n            L[i] = 0;\n            diff = R - i;\n            if (diff > 0) {\n                L[i] = min(L[iMirror], diff);\n            }\n            /*Intente expandir palíndromo centrado en currentRightPosition i\n            Aquí para posiciones impares, comparamos caracteres y\n            si coinciden, aumente la longitud de LPS en UNO\n            Si la posición es igual, solo incrementamos LPS en UNO sin*/\n            try {\n                while (((i + L[i]) < N && (i - L[i]) > 0)\n                        && (((i + L[i] + 1) % 2 == 0)\n                        || (text[(i + L[i] + 1) / 2] == text[(i - L[i] - 1) / 2]))) {\n                    L[i]++;\n                }\n            } catch (Exception e) {\n            }\n            //Comparación de cualquier caracter\n            if (L[i] > maxLPSLength) {\n                maxLPSLength = L[i];\n                maxLPSCenterPosition = i;\n            }\n            if (i + L[i] > R) {\n                C = i;\n                R = i + L[i];\n            }\n            //Descomentar para imprimir tamaño del arreglo LPS\n            //printf(\"%d \", L[i]); \n        }\n        start = (maxLPSCenterPosition - maxLPSLength) / 2;\n        end = start + maxLPSLength - 1;\n        System.out.println(\"LPS del string es \" + String.copyValueOf(text) + \": \");\n        for (i = start; i <= end; i++) {\n            System.out.printf(\"%c\", text[i]);\n        }\n        System.out.println(\"\");\n    }\n}\n",
    "cpp": "using namespace std;\n#include<bits/stdc++.h>\n#include<cstdlib>\n#define FAST ios_base::sync_with_stdio(false);cin.tie(NULL);\n#define string_valueof(x) puts(x);\n\nvoid findLPS(char text[], int N) {\n    if (N == 0) {\n        return;\n    } \n    N = 2 * N + 1;\n    int L[N];\n    L[0] = 0;\n    L[1] = 1;\n    int C = 1;\n    int R = 2;\n    int i_mirror;\n    int max_LPS_len = 0;\n    int max_LPS_centerPos = 0;\n    int start = -1, endLPS = -1, diff = -1;\n    for (int i = 2; i < N; i++) {\n        i_mirror = 2 * C - i;\n        L[i] = 0;\n        diff = R - i;\n        if (diff > 0) {\n            L[i] = std::min(L[i_mirror], diff);\n        }\n        try {\n            while (((i + L[i]) < N and (i - L[i]) > 0) and (((i + L[i] + 1) % 2 == 0) || text[(i + L[i] + 1) / 2] == text[(i - L[i] - 1) / 2])) {\n                L[i]++;\n            }\n        } catch (exception& e) {\n        }\n        if (L[i] > max_LPS_len) {\n            max_LPS_len = L[i];\n            max_LPS_centerPos = i;\n        }\n        if (i + L[i] > R) {\n            C = i;\n            R = i + L[i];\n        }\n    }\n    start = (max_LPS_centerPos - max_LPS_len) / 2;\n    endLPS = start + max_LPS_len - 1;\n    cout << \"LPS del string es \";\n    string_valueof(text);\n    cout << \" : \";\n    for (int j = start; j <= endLPS; j++) {\n        cout << text[j];\n    }\n    cout << endl;\n    /*\n    cout<<\"inicio : \"<<start<<\"    -    final : \"<<endLPS<<endl;\n    for(int j=0;j<N;j++){\n        cout<<L[j]<<\" \";\n    }\n     */\n}\n\nint main() {\n    FAST;\n    char text[1000];\n    gets(text);\n    int N = strlen(text);\n    findLPS(text, N);\n}\n",
    "py": "from sys import stdin, stdout\nrl = stdin.readline\nwr = stdout.write\n\n\ndef findLPS():\n\n    N = len(text)\n    if N == 0:\n        return\n\n    N = 2 * N + 1\n    L = [0] * N\n    L[0] = 0\n    L[1] = 1\n    C, R = 1, 2\n    iMirror = maxLPSlen = maxLPScenterPos = 0\n    start = end = diff = -1\n\n    for i in range(2, N):\n        iMirror = 2 * C - i\n        L[i] = 0\n        diff = R - i\n        if diff > 0:\n            L[i] = min(L[iMirror], diff)\n        try:\n            while ((i + L[i]) < N and (i - L[i]) > 0) and (((i + L[i] + 1) % 2 == 0) or (text[(i + L[i] + 1) // 2] == text[(i - L[i] - 1) // 2])):\n                L[i] += 1\n        except:\n            pass\n\n        if L[i] > maxLPSlen:\n            maxLPSlen = L[i]\n            maxLPScenterPos = i\n\n        if i + L[i] > R:\n            C = i\n            R = i + L[i]\n\n    start = (maxLPScenterPos - maxLPSlen) // 2\n    end = start + maxLPSlen - 1\n\n    wr(f'LPS del string {\"\".join(text)}:\\n')\n    for i in range(start, end+1):\n        wr(f'{text[i]}')\n    wr('\\n')\n\n\ntext = [x for x in 'OABAABAOBO']\nfindLPS()\n",
    "orden": 5,
    "suborden": 3,
    "fecha_creacion": "2020-12-04 20:09:36",
    "fecha_modificacion": "2020-12-07 02:20:21"
  },
  {
    "ID": 31,
    "supergrupo": "Strings",
    "tema": "Algoritmo de Aho-Corasick ",
    "texto": "<div style=\"font-size: 13.3333px; text-align: justify;\"><span style=\"font-size: 10pt;\">Dada una entrada de texto y un array de k palabras, arr[], encontrar todas las ocurrencias de todas las palabras en el texto de entrada.&nbsp;</span></div><div style=\"font-size: 13.3333px; text-align: justify;\"><span style=\"font-size: 10pt;\"><br></span></div><div style=\"font-size: 13.3333px; text-align: justify;\"><span style=\"font-size: 10pt;\">Sea n la longitud del texto y m sea el número total de caracteres en todas las palabras, por ejemplo: m = length (arr [0]) + length (arr [1]) +… + length (arr [k-1]).&nbsp;</span></div><div style=\"font-size: 13.3333px; text-align: justify;\"><span style=\"font-size: 10pt;\"><br></span></div><div style=\"font-size: 13.3333px; text-align: justify;\"><span style=\"font-size: 10pt;\">Si usamos un algoritmo de tiempo linear como KMP, entonces necesitaremos una búsqueda uno por uno de todas las palabras en text[]. Esto nos da un total de complejidad de tiempo de O(n + length(word[0]) + O(n + length(word[1]) + O(n + length(word[2]) + … O(n + length(word[k-1]). Esta complejidad de tiempo puede ser escrita como O(n*k + m). Aho-corasick encuentra todas las palabras en tiempo O(n+m+z) donde z es el número total de ocurrencias de las palabras en el texto, este algoritmo forma las bases del comando original de Unix fgrep.&nbsp;</span></div><div style=\"font-size: 13.3333px; text-align: justify;\"><span style=\"font-size: 10pt;\"><br></span></div><div style=\"font-size: 13.3333px; text-align: justify;\"><span style=\"font-size: 10pt; font-weight: bold;\">Este algoritmo tiene dos pasos principales:&nbsp;</span></div><div style=\"font-size: 13.3333px; text-align: justify;\"><span style=\"font-size: 10pt;\"><span style=\"white-space: pre;\">\t</span>- Preprocesado: Construye un automaton de todas las palabras en arr[].&nbsp;</span></div><div style=\"font-size: 13.3333px; text-align: justify;\"><span style=\"font-size: 10pt;\"><span style=\"white-space: pre;\">\t</span>- Cotejamiento: Atraviesa el texto dado sobre el automaton formado para encontrar las palabras a cotejar.&nbsp;</span></div><div style=\"font-size: 13.3333px; text-align: justify;\"><span style=\"font-size: 10pt;\"><br></span></div><div style=\"font-size: 13.3333px; text-align: justify;\"><span style=\"font-size: 10pt;\">Por un estado s, los índices de todas las palabras terminados en s son almacenadas. Estos índices son almacenados en un map de BitWise (Haciendo OR a lo valores. Esto también computa usando búsqueda primera en anchura con fallo. Construimos un autómata para este conjunto de cadenas. Ahora procesaremos el texto letra por letra, haciendo la transición durante los diferentes estados. Inicialmente estamos en la raíz del trie. Si estamos en cualquier momento en el estado v, y la siguiente letra es c, entonces hacemos la transición al siguiente estado con go (v, c), aumentando así la longitud de la subcadena de coincidencia actual en 1, o disminuyéndola siguiendo Un enlace de sufijo.</span></div><div style=\"font-size: 13.3333px; text-align: justify;\"><span style=\"font-size: 10pt; font-weight: bold;\"><br></span></div><div style=\"font-size: 13.3333px; text-align: justify;\"><span style=\"font-size: 10pt; font-weight: bold;\">¿Cómo podemos encontrar un estado v, si hay coincidencias con cadenas para el conjunto?&nbsp;</span></div><div style=\"font-size: 13.3333px; text-align: justify;\"><span style=\"font-size: 10pt;\"><br></span></div><div style=\"font-size: 13.3333px; text-align: justify;\"><span style=\"font-size: 10pt;\">Primero, está claro que si nos paramos en un vértice de la hoja, entonces la cadena correspondiente al vértice termina en esta posición en el texto. Sin embargo, este no es el único caso posible de lograr una coincidencia: si podemos alcanzar uno o más vértices de hojas moviéndonos a lo largo de los enlaces de sufijo, entonces también habrá una coincidencia correspondiente a cada vértice de hoja encontrado.&nbsp;</span></div><div style=\"font-size: 13.3333px; text-align: justify;\"><span style=\"font-size: 10pt;\"><br></span></div><div style=\"font-size: 13.3333px; text-align: justify;\"><span style=\"font-size: 10pt;\">Un ejemplo simple que demuestra esta situación puede ser crear usando el conjunto de cadenas {dabce, abc, bc} y el texto dabc. Por lo tanto, si almacenamos en cada vértice de la hoja el índice de la cadena correspondiente (o la lista de índices si aparecen cadenas duplicadas en el conjunto), entonces podemos encontrar en O (n) tiempo los índices de todas las cadenas que coinciden con la actual estado, simplemente siguiendo los enlaces de sufijo desde el vértice actual hasta la raíz. Sin embargo, esta no es la solución más eficiente, ya que nos da una complejidad O (n len) en total. Sin embargo, esto se puede optimizar calculando y almacenando el vértice de la hoja más cercano al que se puede acceder mediante enlaces de sufijo (esto a veces se denomina enlace de salida). Este valor lo podemos calcular perezosamente en tiempo lineal. Por lo tanto, para cada vértice podemos avanzar en tiempo O (1) al siguiente vértice marcado en la ruta de enlace del sufijo, es decir, a la siguiente coincidencia. Por lo tanto, para cada partido pasamos O (1) tiempo, y por lo tanto alcanzamos la complejidad O (len + ans). Si solo desea contar las ocurrencias y no encontrar los índices, puede calcular el número de vértices marcados en la ruta de enlace del sufijo para cada vértice v.&nbsp;</span></div><div style=\"font-size: 13.3333px; text-align: justify;\"><span style=\"font-size: 10pt;\"><br></span></div><div style=\"font-size: 13.3333px; text-align: justify;\"><span style=\"font-size: 10pt;\"><br></span></div><div style=\"font-size: 13.3333px; text-align: justify;\"><span style=\"font-size: 10pt;\">Esto se puede calcular en O (n) en total. Por lo tanto, podemos resumir todas las coincidencias en O (len).&nbsp;</span></div><div style=\"font-size: 13.3333px; text-align: justify;\"><span style=\"font-size: 10pt;\"><br></span></div><div style=\"font-size: 13.3333px; text-align: justify;\"><span style=\"font-size: 10pt; font-weight: bold;\">Utilidades de este algoritmo:&nbsp;</span></div><div style=\"font-size: 13.3333px; text-align: justify;\"><span style=\"font-size: 10pt;\">1) Encontrar la cadena lexicográfica más pequeña de una longitud dada que no coincide con ninguna cadena dada Se da un conjunto de cuerdas y una longitud L. Tenemos que encontrar una cadena de longitud L, que no contiene ninguna de las cadenas, y derivar la cadena lexicográfica más pequeña de tales cadenas. Podemos construir el autómata para el conjunto de cadenas. Recordemos que los vértices desde los cuales podemos alcanzar el vértice de una hoja son los estados, en los cuales tenemos una coincidencia con una cadena del conjunto. Como en esta tarea debemos evitar las coincidencias, no se nos permite ingresar a dichos estados. Por otro lado, podemos ingresar todos los demás vértices. Por lo tanto, eliminamos todos los vértices \"malos\" de la máquina, y en el gráfico restante del autómata encontramos la ruta lexicográfica más pequeña de longitud L. Esta tarea se puede resolver en O (L), por ejemplo, mediante la búsqueda en profundidad. &nbsp;</span></div><div style=\"font-size: 13.3333px; text-align: justify;\"><span style=\"font-size: 10pt;\"><br></span></div><div style=\"font-size: 13.3333px; text-align: justify;\"><span style=\"font-size: 10pt;\">2) Encontrar la cadena más corta que contiene todas las cadenas dadas Aquí usamos las mismas ideas. Para cada vértice almacenamos una máscara que denota las cadenas que coinciden en este estado. Entonces el problema puede reformularse de la siguiente manera: inicialmente estando en el estado (v = raíz, máscara = 0), queremos llegar al estado (v, máscara = 2n - 1), donde n es el número de cadenas en el conjunto . Cuando hacemos la transición de un estado a otro usando una letra, actualizamos la máscara en consecuencia. Al ejecutar una búsqueda de respiración primero podemos encontrar una ruta al estado (v, máscara = 2n - 1) con la longitud más pequeña. 3) Encontrar la cadena lexicográfica más pequeña de longitud L que contiene k cadenas Como en el problema anterior, calculamos para cada vértice el número de coincidencias que le corresponden (es decir, el número de vértices marcados a los que se puede acceder mediante enlaces de sufijo). Reformulamos el problema: el estado actual está determinado por un triple de números (v, len, cnt), y queremos llegar desde el estado (raíz, 0, 0) al estado (v, L, k), donde v puede ser cualquier vértice Por lo tanto, podemos encontrar dicha ruta utilizando la búsqueda en profundidad primero (y si la búsqueda mira los bordes en su orden natural, entonces la ruta encontrada será automáticamente la más pequeña lexicográfica).</span></div>",
    "complejidad_tiempo": "Mejor caso :    O(n + m + ocurrencias) Peor caso : O(n + m + ocurrencias)   \n Promedio: O(n + m + ocurrencias)         \n",
    "java": "import java.util.Arrays;\nimport java.util.LinkedList;\nimport java.util.Queue;\n\n//Programa JAVA implementando Aho Corasick\n//para matching de strings\npublic class Main {\n\n    //Maximo numero de estados en la maquina de cotejamiento\n    //debe ser igual a la suma del tamaño de todas las palablas clave\n    static final int MAXS = 500;\n    //numero maximo de caracteres en el alfabeto de entrada\n    static final int MAXC = 26;\n    //La funcion Output esta implementada usando out[]\n    // bit i de esta mascara es uno si la palabra en el \n    // indice i aparece cuando la maquina entra en este estado\n    static int out[] = new int[MAXS];\n    //función de fallo \n    static int f[] = new int[MAXS];\n    //implementación de las tries\n    static int g[][] = new int[MAXS][MAXC];\n\n    // Construye la maquina de cotejado\n    /* \"out[state] & (1 << i)\" es > 0 si encontramos la\n    palabra de word[i] en el texto\n    arr-> vector de palabras, el incide de cada palabla clave\n    es importante */\n    // retorna el numero de estados que la maquina tiene construidos\n    // los estados estan numerados desde 0 hasta el valor de retorno - 1\n    static int buildMatchingMachine(String arr[], int k) {\n        //Inicializar todos los valores de out en 0. \n        Arrays.fill(out, 0);\n        // Inicializar todos los valores de g en -1.\n        for (int i = 0; i < MAXS; i++) {\n            Arrays.fill(g[i], -1);\n        }\n        // Inicialmente tenemos 0 estados \n        int states = 1;\n        //Esto es lo mismo que construir un Trie para arr[] \n        for (int i = 0; i < k; ++i) {\n            String word = arr[i];\n            int currentState = 0;\n            // Insertar todos los caracteres de la palabra actual\n            // en arr[]\n            for (int j = 0; j < word.length(); ++j) {\n                int ch = word.charAt(j) - 'a';\n                // crea un nuevo nodo (estado) si un nodo\n                // para ch no existe\n                if (g[currentState][ch] == -1) {\n                    g[currentState][ch] = states++;\n                }\n                currentState = g[currentState][ch];\n            }\n            // agrega la palabra actual a la función de salida\n            out[currentState] |= (1 << i);\n        }\n        // para todos los caracteres que no tengan un camino desde\n        // la raiz (El estado 0) en el trie, agregar un camino\n        // hacia el estado 0 mismo\n        for (int ch = 0; ch < MAXC; ++ch) {\n            if (g[0][ch] == -1) {\n                g[0][ch] = 0;\n            }\n        }\n        //Inicializamos los valores en la funcion de fallo\n        Arrays.fill(f, -1);\n        // Se usa BFS y una cola para calcular los fallos\n        Queue<Integer> q = new LinkedList<>();\n        // Se itera por lo que se encuentre\n        for (int ch = 0; ch < MAXC; ++ch) {\n            // Todos los nodos de profundidad 1 tienen una funcion de fallo\n            // como 0.\n            if (g[0][ch] != 0) {\n                f[g[0][ch]] = 0;\n                q.offer((g[0][ch]));\n            }\n        }\n        while (!q.isEmpty()) {\n            // Tomamos el nodo o estado del frente de la cola\n            int state = q.poll();\n            // Se busca la funcion de fallo de todos los caracteres del estado\n            // removido para cuales funcion g no esta definido\n            for (int ch = 0; ch < MAXC; ++ch) {\n                if (g[state][ch] != -1) {\n                    //Encontrar el valor de la funcion de fallo\n                    int failure = f[state];\n                    // encuentra el nodo mas profundo con el sufijo\n                    // apropiado del string desde el nodo raiz al estado actual\n                    while (g[failure][ch] == -1) {\n                        failure = f[failure];\n                    }\n                    failure = g[failure][ch];\n                    f[g[state][ch]] = failure;\n                    //Junta los valores de salida\n                    out[g[state][ch]] |= out[failure];\n                    //Inserta el nodo del siguiente nivel del trie\n                    q.offer(g[state][ch]);\n                }\n            }\n        }\n\n        return states;\n    }\n    // currentState - El estado actual de la maquina \n    //                 entre 0 y el total de estados -1  \n    // nextInput - El siguiente caracter que entra en la maquina. \n\n    static int findNextState(int currentState, char nextInput) {\n        int answer = currentState;\n        int ch = nextInput - 'a';\n        // Si g no esta definido, use la funcion de fallo \n        while (g[answer][ch] == -1) {\n            answer = f[answer];\n        }\n        return g[answer][ch];\n    }\n\n    //Función que busca las ocurrencias en el texto\n    static void searchWords(String arr[], int k, String text) {\n        // Preprocesar patrones\n        // Construir los tries como una maquina de estado finito\n        buildMatchingMachine(arr, k);\n        // Inicializar los estados\n        int currentState = 0;\n        //Atravesamos el texto buscando las ocurrencias\n        for (int i = 0; i < text.length(); ++i) {\n            currentState = findNextState(currentState, text.charAt(i));\n            // Si no se encuentra cotejado, pasa al siguiente estado\n            if (out[currentState] == 0) {\n                continue;\n            }\n            // cotejado encontrado, imprimir todas las palabras de \n            // arr[] que se encontraron \n            for (int j = 0; j < k; ++j) {\n                int aux = (out[currentState] & (1 << j));\n                if (aux > 0) {\n                    System.out.println(\"La palabra \" + arr[j] + \" aparece de \"\n                            + (i - arr[j].length() + 1) + \" a \" + i);\n                }\n            }\n        }\n    }\n\n    public static void main(String[] args) {\n        String arr[] = {\"he\", \"she\", \"hers\", \"his\"};\n        String text = \"ahishers\";\n        int k = arr.length;\n        searchWords(arr, k, text);\n    }\n}\n",
    "cpp": "using namespace std;\n#include <bits/stdc++.h> \n\nconst int MAXS = 500;\nconst int MAXC = 26;\nint out[MAXS];\nint f[MAXS];\nint g[MAXS][MAXC];\n\nint buildMatchingMachine(string arr[], int k) {\n    memset(out, 0, sizeof out);\n    memset(g, -1, sizeof g);\n    int states = 1;\n    for (int i = 0; i < k; ++i) {\n        const string &word = arr[i];\n        int currentState = 0;\n        for (int j = 0; j < word.size(); ++j) {\n            int ch = word[j] - 'a';\n            if (g[currentState][ch] == -1)\n                g[currentState][ch] = states++;\n            currentState = g[currentState][ch];\n        }\n        out[currentState] |= (1 << i);\n    }\n    for (int ch = 0; ch < MAXC; ++ch)\n        if (g[0][ch] == -1)\n            g[0][ch] = 0;\n    memset(f, -1, sizeof f);\n    queue<int> q;\n    for (int ch = 0; ch < MAXC; ++ch) {\n        if (g[0][ch] != 0) {\n            f[g[0][ch]] = 0;\n            q.push(g[0][ch]);\n        }\n    }\n\n    while (q.size()) {\n        int state = q.front();\n        q.pop();\n        for (int ch = 0; ch <= MAXC; ++ch) {\n            if (g[state][ch] != -1) {\n                int failure = f[state];\n                while (g[failure][ch] == -1)\n                    failure = f[failure];\n                failure = g[failure][ch];\n                f[g[state][ch]] = failure;\n                out[g[state][ch]] |= out[failure];\n                q.push(g[state][ch]);\n            }\n        }\n    }\n    return states;\n}\n\nint findNextState(int currentState, char nextInput) {\n    int answer = currentState;\n    int ch = nextInput - 'a';\n    while (g[answer][ch] == -1)\n        answer = f[answer];\n    return g[answer][ch];\n}\n\nvoid searchWords(string arr[], int k, string text) {\n    buildMatchingMachine(arr, k);\n    int currentState = 0;\n    for (int i = 0; i < text.size(); ++i) {\n        currentState = findNextState(currentState, text[i]);\n        if (out[currentState] == 0)\n            continue;\n        for (int j = 0; j < k; ++j) {\n            int aux = out[currentState] & (1 << j);\n            if (aux) {\n                cout << \"Word \" << arr[j] << \" appears from \"\n                        << i - arr[j].size() + 1 << \" to \" << i << endl;\n            }\n        }\n    }\n}\n\nint main() {\n    string arr[] = {\"he\", \"she\", \"hers\", \"his\"};\n    string text = \"ahishers\";\n    int k = sizeof (arr) / sizeof (arr[0]);\n\n    searchWords(arr, k, text);\n\n    return 0;\n} \n",
    "py": "from collections import deque\nMAXS = 500\nMAXC = 26\nout = []\nf = []\ng = []\n\ndef buildMatchingMachine(arr, k):\n    global MAXS\n    global MAXC\n    global out\n    global g\n    global f\n    out = [0 for x in range(MAXS)]\n    g = [[-1 for y in range(MAXC)] for x in range(MAXS)]\n    states = 1\n    for i in range(k):\n        word = arr[i]\n        currentState = 0\n        for j in range(len(word)):\n            ch = ord(word[j]) - ord('a')\n            if g[currentState][ch] == -1:\n                states = states + 1\n                g[currentState][ch] = states\n            currentState = g[currentState][ch]\n        out[currentState] |= (1 << i)\n    for ch in range(MAXC):\n        if g[0][ch] == -1:\n            g[0][ch] = 0\n    f = [-1 for x in range(MAXS)]\n    q = deque()\n    for ch in range(MAXC):\n        if g[0][ch] != 0:\n            f[g[0][ch]] = 0\n            q.append((g[0][ch]))\n    while not len(q) == 0:\n        state = q.pop()\n        for ch in range(MAXC):\n            if g[state][ch] != -1:\n                failure = f[state]\n                while g[failure][ch] == -1:\n                    failure = f[failure]\n                failure = g[failure][ch]\n                f[g[state][ch]] = failure\n                out[g[state][ch]] |= out[failure]\n                q.append(g[state][ch])\n    return states\n\ndef findNextState(currentState, nextInput):\n    global MAXS\n    global MAXC\n    global out\n    global g\n    global f\n    answer = currentState\n    ch = int(ord(nextInput) - ord('a'))\n    while g[answer][ch] == -1:\n        answer = f[answer]\n    return g[answer][ch]\n\ndef searchWords(arr, k, text):\n    global MAXS\n    global MAXC\n    global out\n    global g\n    global f\n    buildMatchingMachine(arr, k)\n    currentState = 0\n    for i in range(len(text)):\n        currentState = findNextState(currentState, text[i])\n        if out[currentState] == 0:\n            continue\n        for j in range(k):\n            aux = (out[currentState] & (1 << j))\n            if aux > 0:\n                print(\"la palabra \", arr[j], \" aparece de \", ((i - len(arr[j])) + 1), \" a \", i)\n\n\narr = [\"he\", \"she\", \"hers\", \"his\"]\ntext = \"ahishers\"\nk = len(arr)\nsearchWords(arr, k, text)\n",
    "orden": 5,
    "suborden": 4,
    "fecha_creacion": "2020-12-04 20:09:36",
    "fecha_modificacion": "2020-12-07 02:36:10"
  },
  {
    "ID": 32,
    "supergrupo": "Strings",
    "tema": "Finite Automata",
    "texto": "<div style=\"text-align: justify;\"><span style=\"font-size: 10pt;\">Dado un texto txt[0...n-1] y un patrón pat[0...m-1], busque todas las ocurrencias de pat en txt e imprímalas, asuma que n es mayor que m.&nbsp;</span></div><div style=\"text-align: justify;\"><span style=\"font-size: 10pt;\"><br></span></div><div style=\"text-align: justify;\"><span style=\"font-size: 10pt;\">En el algoritmo basado en Finite autómata, nosotros preprocesamos el patrón y construimos un array de dos dimensiones que represente un autómata finito. Construcción del FA es la parte complicada de este algoritmo. Una vez el FA este construido, la búsqueda es simple, En la búsqueda nosotros simplemente necesitamos iniciar desde el primer estado del autómata y el primer carácter del texto. En cada paso, consideramos el siguiente carácter del texto, miramos por el siguiente estado en el FA construido y nos movemos a un nuevo estado. Si alcanzamos el estado final, entonces el patrón fue encontrado en el texto.</span></div>",
    "complejidad_tiempo": "Mejor caso :    O(n)        Peor caso : O(n)       Promedio: O(n)         ",
    "java": "// Programa java para el algoritmo\n// Finite Automata de busqueda de patrones\n\npublic class FiniteAutomata {\n\n    static int NO_OF_CHARS = 256;\n\n    static int getNextState(char[] pat, int M,\n            int state, int x) {\n        // Si el caracter c es el mismo como el \n        // siguiente en patrón, simplemente incrementa\n        // state\n        if (state < M && x == pat[state]) {\n            return state + 1;\n        }\n        // ns almacena el resultado el cual es \n        // el siguiente state\n        int ns, i;\n        /* ns finalmente contiene el prefijo más largo\n        el cual tambien es sufijo en \"pat[0..state-1]c\"\n        Empieza desde el valor más largo posible \n        y se detiene cuando se encuentra un prefijo el cual\n        es tambien sufijo*/\n        for (ns = state; ns > 0; ns--) {\n            if (pat[ns - 1] == x) {\n                for (i = 0; i < ns - 1; i++) {\n                    if (pat[i] != pat[state - ns + 1 + i]) {\n                        break;\n                    }\n                }\n                if (i == ns - 1) {\n                    return ns;\n                }\n            }\n        }\n        return 0;\n    }\n\n    /*Esta función construye la tabla TF la cual\n    representa Finite Automata del patrón dado*/\n    static void computeTF(char[] pat, int M, int TF[][]) {\n        int state, x;\n        for (state = 0; state <= M; ++state) {\n            for (x = 0; x < NO_OF_CHARS; ++x) {\n                TF[state][x] = getNextState(pat, M, state, x);\n            }\n        }\n    }\n\n    /* Imprime todas las ocurrencuas de pat en txt*/\n    static void search(char[] pat, char[] txt) {\n        int M = pat.length;\n        int N = txt.length;\n        int[][] TF = new int[M + 1][NO_OF_CHARS];\n        computeTF(pat, M, TF);\n        // Procesa txt sobre FA.\n        int i, state = 0;\n        for (i = 0; i < N; i++) {\n            state = TF[state][txt[i]];\n            if (state == M) {\n                System.out.println(\"Patrón encontrado \"\n                        + \"en indice \" + (i - M + 1));\n            }\n        }\n    }\n\n    public static void main(String[] args) {\n        char[] txt = \"AABAACAADAABAAABAA\".toCharArray();\n        char[] pat = \"AABA\".toCharArray();\n        search(pat, txt);\n    }\n}\n",
    "cpp": "#include <cstdlib>\n#include <bits/stdc++.h>\nusing namespace std;\n#define NO_OF_CHARS 256\n\nint getNextState(char pat[], int M, int state, int x) {\n    if (state < M && x == pat[state]) {\n        return state + 1;\n    }\n    int ns, i;\n    for (ns = state; ns > 0; ns--) {\n        if (pat[ns - 1] == x) {\n            for (i = 0; i < ns - 1; i++) {\n                if (pat[i] != pat[state - ns + 1 + i]) {\n                    break;\n                }\n            }\n            if (i == ns - 1) {\n                return ns;\n            }\n        }\n    }\n    return 0;\n}\n\nvoid computeTF(char pat[], int M, int TF[NO_OF_CHARS][NO_OF_CHARS]) {\n    int state, x;\n    for (state = 0; state <= M; state++) {\n        for (x = 0; x < NO_OF_CHARS; x++) {\n            TF[state][x] = getNextState(pat, M, state, x);\n        }\n    }\n}\n\nvoid finiteAutomata(char pat[], char txt[]) {\n    int M = strlen(pat);\n    int N = strlen(txt);\n    int TF[M + 1][NO_OF_CHARS];\n    computeTF(pat, M, TF);\n    int i, state = 0;\n    for (i = 0; i < N; i++) {\n        state = TF[state][txt[i]];\n        if (state == M) {\n            cout << \"Patron encontrado en indice \" << i - M + 1 << \" - \" << i << endl;\n        }\n    }\n}\n\nint main(int argc, char const *argv[]) {\n    char pat[] = {\"looloolo\"};\n    char txt[] = {\"olo\"};\n    finiteAutomata(txt, pat);\n    return 0;\n}\n",
    "py": "from sys import stdin\nfrom sys import stdout\nrl = stdin.readline\nwr = stdout.write\n\nNO_OF_CHARS = 256\n\n\ndef getNextState(pat, M, state, x):\n\n    if state < M and x == ord(pat[state]):\n        return state + 1\n\n    i = 0\n    for ns in range(state, 0, -1):\n        if ord(pat[ns-1]) == x:\n            for i in range(ns-1):\n                if pat[i] != pat[state-ns + 1 + i]:\n                    break\n                i += 1\n            if i == ns - 1:\n                return ns\n\n    return 0\n\n\ndef computeTF(pat, M, TF):\n    for state in range(M + 1):\n        for x in range(NO_OF_CHARS):\n            TF[state][x] = getNextState(pat, M, state, x)\n\n\ndef finiteAutomataSearch(pat, txt):\n\n    M = len(pat)\n    N = len(txt)\n    TF = [[0 for x in range(NO_OF_CHARS)] for x in range(M + 1)]\n    computeTF(pat, M, TF)\n    state = 0\n    for i in range(N):\n        state = TF[state][ord(txt[i])]\n        if state == M:\n            wr(f'\"{\"\".join(pat)}\" encontrado en indices ({i-M+1} - {i})\\n')\n\n\ntxt = 'AABAACAADAABAABA'\npat = 'AABA'\nfiniteAutomataSearch(pat, txt)\n",
    "orden": 5,
    "suborden": 5,
    "fecha_creacion": "2020-12-04 20:09:36",
    "fecha_modificacion": "2020-12-07 02:37:59"
  },
  {
    "ID": 33,
    "supergrupo": "Matemática",
    "tema": "GCD/LCM",
    "texto": "<div style=\"text-align: justify;\"><span style=\"font-size: 10pt;\">El máximo común divisor (MCD o GCD) de dos o más números naturales o enteros (no números con decimales) es el número más grande que les divide.\r\nEl mínimo común múltiplo (MCM o LCM) de dos números a y b es el número más pequeño que es múltiplo de a y múltiplo de b.</span></div>",
    "complejidad_tiempo": "Mejor caso :    O(log(n))        Peor caso : O(log(n))       Promedio: O(log(n))         ",
    "java": "//Programa java que realiza\n//Maximo comun divisor y minimo comun multiplo\n\npublic class GCDLCM {\n\n    public static void main(String[] args) {\n        int a = 8, b = 12;\n        System.out.println(\"GCD de a y b es :\" + gcd(a, b));\n        System.out.println(\"LCM de a y b es :\" + lcm(a, b));\n    }\n    //Maximo Comun Divisor\n    public static int gcd(int a, int b) {\n        return b == 0 ? a : gcd(b, a % b);\n    }\n    //Minimo Comun Multiplo\n    public static int lcm(int a, int b) {\n        return a * (b / gcd(a, b));\n    }\n}\n",
    "cpp": "#include<bits/stdc++.h>\n#include<cstdlib>\n//---------------//\nusing namespace std;\n\nint GCD(int a, int b) {\n    return b == 0 ? a : GCD(b, a % b);\n}\n\nint LCM(int a, int b) {\n    return a * (b / GCD(a, b));\n}\n\nint main() {\n    int a = 8;\n    int b = 12;\n    cout << \"GCD de a y b es: \" << GCD(a, b) << endl;\n    cout << \"LCM de a y b es: \" << LCM(a, b) << endl;\n}\n",
    "py": "from sys import stdout\n\ndef GCD(a, b):\n    return a if b == 0 else GCD(b, a % b)\n\ndef LCM(a, b):\n    return a * (b // GCD(a, b))\n\ndef main():\n    a = int(8)\n    b = int(12)\n    stdout.write(f\"GCD de a y b es : {GCD(a,b)}\\n\")\n    stdout.write(f\"LCM de a y b es : {LCM(a,b)}\\n\")\n\nmain()\n",
    "orden": 6,
    "suborden": 0,
    "fecha_creacion": "2020-12-04 22:01:06",
    "fecha_modificacion": "2020-12-07 02:42:29"
  },
  {
    "ID": 34,
    "supergrupo": "Matemática",
    "tema": "Multiple GCD",
    "texto": "<div style=\"text-align: justify;\"><span style=\"font-size: 10pt;\">Dado un array de números, encontrar GCD del array de elementos.\r\nEl GCD de tres o más números es igual que el producto de los factores primos comunes de todos los números, pero puede también ser calculado tomando repetidamente el GCD de los pares de números.</span></div>",
    "complejidad_tiempo": "Mejor caso :    O(nlog(n))        Peor caso : O(nlog(n))       Promedio: O(nlog(n))",
    "java": "// Programa java que encuentra\n// el maximo comun divisor de 2 o más \n//números\n\npublic class GCDMultiple {\n    // Funcion que retorna gcd de a y b\n    static int gcd(int a, int b) {\n        if (a == 0) {\n            return b;\n        }\n        return gcd(b % a, a);\n    }\n    // Función que encuentra gcd de un arreglo de números\n    static int findGCD(int arr[], int n) {\n        int result = arr[0];\n        for (int i = 1; i < n; i++) {\n            result = gcd(arr[i], result);\n        }\n\n        return result;\n    }\n    public static void main(String[] args) {\n        int arr[] = {2, 4, 6, 8, 16};\n        int n = arr.length;\n        System.out.println(findGCD(arr, n));\n    }\n} \n",
    "cpp": null,
    "py": null,
    "orden": 6,
    "suborden": 1,
    "fecha_creacion": "2020-12-04 22:01:06",
    "fecha_modificacion": "2020-12-07 02:42:37"
  },
  {
    "ID": 35,
    "supergrupo": "Matemática",
    "tema": "GCD de números flotantes",
    "texto": "<div style=\"font-family: Arial, Verdana; font-size: 10pt; font-style: normal; font-variant-ligatures: normal; font-variant-caps: normal; font-weight: normal; text-align: justify;\"><span style=\"font-size: 10pt;\">Una aproximación simple para realizar GCD a números flotantes es:&nbsp;</span></div><div style=\"font-family: Arial, Verdana; font-size: 10pt; font-style: normal; font-variant-ligatures: normal; font-variant-caps: normal; font-weight: normal; text-align: justify;\">- a=1.20&nbsp;</div><div style=\"font-family: Arial, Verdana; font-size: 10pt; font-style: normal; font-variant-ligatures: normal; font-variant-caps: normal; font-weight: normal; text-align: justify;\">- b=22.5&nbsp;</div><div style=\"\"><div style=\"text-align: justify;\"><span style=\"font-family: Arial, Verdana; font-size: 13.3333px;\"><br></span></div><div style=\"text-align: justify; font-family: Arial, Verdana; font-size: 10pt; font-style: normal; font-variant-ligatures: normal; font-variant-caps: normal; font-weight: normal;\">Expresando cada uno de los números sin decimales como el producto de los primos obtenemos:\r\n- 120=2^3*3*5\r\n- 2250=2*3^2*5^3\r\nGCD de 120 y 2250 = 2*3*5=30\r\nPor lo tanto, el GCD de 1.20 y 22.5=0.30 (Tomando 2 dígitos decimales).\r\nPodemos hacer esto usando el algoritmo de Euclides, Este algoritmo indica si el número más pequeño es restado del número más largo, el GCD de dos números no cambia.\r\n</div></div>",
    "complejidad_tiempo": "Mejor caso :    O(log(n))        Peor caso : O(log(n))       Promedio: O(log(n))         ",
    "java": "// Programa java que encuentra el GCD de dos\n// números flotantes\n\npublic class FloatGCD {\n    // Funcion recursiva que retorna gcd de a y b  \n    static double gcd(double a, double b) {\n        if (a < b) {\n            return gcd(b, a);\n        }\n        // Caso base\n        if (Math.abs(b) < 0.001) {\n            return a;\n        } else {\n            return (gcd(b, a - Math.floor(a / b) * b));\n        }\n    }\n\n    public static void main(String args[]) {\n        double a = 1.20, b = 22.5;\n        System.out.printf(\"%.1f\", gcd(a, b));\n    }\n}\n",
    "cpp": "include<bits/stdc++.h>\n#include<cstdlib>\n//---------------//\nusing namespace std;\n\ndouble GCD(double a, double b) {\n    if (a < b) {\n        return GCD(b, a);\n    }\n    if (std::fabs(b) < 0.001) {\n        return a;\n    } else {\n        return (GCD(b, a - (std::floor(a / b) * b)));\n    }\n}\n\nint main() {\n    double a = 1.20, b = 22.5;\n    printf(\"%.2f\\n\", (GCD(a, b)));\n} \n\n",
    "py": null,
    "orden": 6,
    "suborden": 2,
    "fecha_creacion": "2020-12-04 22:01:06",
    "fecha_modificacion": "2020-12-07 02:43:07"
  },
  {
    "ID": 36,
    "supergrupo": "Matemática",
    "tema": "LCM en un vector",
    "texto": "<div style=\"font-weight: normal; text-align: justify;\"><span style=\"font-size: 10pt;\">Dado un array de n números, encontrar el LCM de ellos.&nbsp;\r\n</span></div><div style=\"font-weight: normal; text-align: justify;\"><span style=\"font-size: 10pt;\"><br></span></div><div style=\"font-weight: normal; text-align: justify;\"><span style=\"font-size: 10pt;\">La idea es extender nuestra relación de más de dos números, se tiene un array arr[] que contiene n elementos de los cuales se necesita calcular su LCM.&nbsp;</span></div><div style=\"font-weight: normal; text-align: justify;\"><span style=\"font-size: 10pt;\"><br></span></div><div style=\"text-align: justify;\"><span style=\"font-size: 10pt; font-weight: bold;\">Los pasos principales del algoritmo son:&nbsp;</span></div><div style=\"font-weight: normal; text-align: justify;\"><span style=\"font-size: 10pt;\">1) Inicializa ans = arr[0]&nbsp;</span></div><div style=\"font-weight: normal; text-align: justify;\"><span style=\"font-size: 10pt;\">2) Iterar sobre todos los elementos del array, por ejemplo desde i=1 a i= n-1, en la iesima iteración ans= LCM(arr[0],arr[1],……., arr[i-1]). Esto puede ser fácilmente hecho como LCM(arr[0], arr[1], …., arr[i]) = LCM(ans, arr[i]). Entonces en la iesima iteración tenemos que hacer ans = LCM(ans, arr[i]) = ans x arr[i] / gcd(ans, arr[i])</span></div>",
    "complejidad_tiempo": "Mejor caso :    O(nlog(n))        Peor caso : O(nlog(n))       Promedio: O(nlog(n))         ",
    "java": "// Programa java que calcula el minimo común multiplo\n// de n elementos\n\npublic class Lcmofarrayelements {\n\n    public static long lcm_of_array_elements(int[] element_array) {\n        long lcm_of_array_elements = 1;\n        int divisor = 2;\n        while (true) {\n            int counter = 0;\n            boolean divisible = false;\n            for (int i = 0; i < element_array.length; i++) {\n\n                // lcm_of_array_elements (n1, n2, ... 0) = 0. \n                // Para cada número negativo lo convertimos\n                // En positivo y calculamos lcm_of_array_elements. \n                if (element_array[i] == 0) {\n                    return 0;\n                } else if (element_array[i] < 0) {\n                    element_array[i] = element_array[i] * (-1);\n                }\n                if (element_array[i] == 1) {\n                    counter++;\n                }\n                /* Divide element_array por diviser si completa\n                división */\n                if (element_array[i] % divisor == 0) {\n                    divisible = true;\n                    element_array[i] = element_array[i] / divisor;\n                }\n            }\n            /*Si el divisor es capaz de dividir completamente cualquier número.\n            de la matriz multiplicar con lcm_of_array_elements\n            y almacenar en lcm_of_array_elements y continuar\n            al mismo divisor para encontrar el siguiente factor.\n            si no incrementar divisor*/\n\n            if (divisible) {\n                lcm_of_array_elements = lcm_of_array_elements * divisor;\n            } else {\n                divisor++;\n            }\n            //Verifica si todo element_Array es 1 indicando\n            // encontramos todos los factores y terminamos el ciclo\n            if (counter == element_array.length) {\n                return lcm_of_array_elements;\n            }\n        }\n    }\n\n    public static void main(String[] args) {\n        int[] element_array = {2, 7, 3, 9, 4};\n        System.out.println(lcm_of_array_elements(element_array));\n    }\n}\n",
    "cpp": "#include<bits/stdc++.h>\n#include<cstdlib>\n//---------------//\nusing namespace std;\n\nlong lcm_array(int arr[], int len) {\n    long lcm = 1;\n    int divisor = 2;\n    while (true) {\n        int counter = 0;\n        bool divisible = false;\n        for (int i = 0; i < len; i++) {\n            if (arr[i] == 0) {\n                return 0;\n            } else if (arr[i] < 0) {\n                arr[i] = arr[i]*(-1);\n            }\n            if (arr[i] == 1) {\n                counter++;\n            }\n            if (arr[i] % divisor == 0) {\n                divisible = true;\n                arr[i] = arr[i] / divisor;\n            }\n        }\n        if (divisible) {\n            lcm = lcm*divisor;\n        } else {\n            divisor++;\n        }\n        if (counter == len) {\n            return lcm;\n        }\n    }\n}\n\nint main() {\n    int arr[] = {2, 7, 3, 9, 4};\n    int len = sizeof arr / sizeof arr[0];\n    cout << lcm_array(arr, len);\n} \n",
    "py": null,
    "orden": 6,
    "suborden": 3,
    "fecha_creacion": "2020-12-04 22:01:06",
    "fecha_modificacion": "2020-12-07 02:43:55"
  },
  {
    "ID": 37,
    "supergrupo": "Matemática",
    "tema": "Test de primalidad",
    "texto": "<div style=\"text-align: justify;\"><span style=\"font-size: 10pt;\">Un número primo es un número natural mayor que 1 que tiene únicamente dos divisores distintos: él mismo y el 1. Por el contrario, los números compuestos son los números naturales que tienen algún divisor natural aparte de sí mismos y del 1, y, por lo tanto, pueden factorizarse. El número 1, por convenio, no se considera ni primo ni compuesto.&nbsp;</span></div><div style=\"text-align: justify;\"><span style=\"font-size: 10pt;\"><br></span></div><div style=\"text-align: justify;\"><span style=\"font-size: 10pt;\">La propiedad de ser número primo se denomina primalidad. El estudio de los números primos es una parte importante de la teoría de números, rama de las matemáticas que trata las propiedades, básicamente aritméticas, de los números enteros.\r\nEl teorema fundamental de la aritmética establece que todo número natural tiene una representación única como producto de factores primos, salvo el orden. Un mismo factor primo puede aparecer varias veces. El 1 se representa entonces como un producto vacío.</span></div>",
    "complejidad_tiempo": "Mejor caso :    O(vn)        Peor caso : O(vn)       Promedio: O(vn)",
    "java": "//Programa java que verifica si un número\n// es primo o no\n\npublic class PrimalityTest {\n\n    public static void main(String[] args) {\n        boolean isprime = false;\n        int n = 5;\n        if (isPrime(n)) {\n            System.out.println(\"Es primo\");\n        } else {\n            System.out.println(\"No es primo\");\n        }\n    }\n\n    //Prueba de primalidad\n    public static boolean isPrime(int x) {\n        if (x < 2) {\n            return false;\n        }\n        if (x == 2) {\n            return true;\n        }\n        if (x % 2 == 0) {\n            return false;\n        }\n        for (int i = 2; i * i <= x; i++) {\n            if (x % i == 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\n",
    "cpp": "#include<bits/stdc++.h>\n#include<cstdlib>\n//---------------//\nusing namespace std;\n\nbool isPrime(int x) {\n    if (x < 2) {\n        return false;\n    }\n    if (x == 2) {\n        return true;\n    }\n    for (int i = 2; i * i <= x; i++) {\n        if (x % i == 0) {\n            return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    int n = 25;\n    if (isPrime(n)) {\n        cout << n << \" es primo\" << endl;\n    } else {\n        cout << n << \" no es primo\" << endl;\n    }\n}\n",
    "py": "from sys import stdout\n\ndef isPrime(x):\n    if (x % 2 == 0 and x > 2) or x < 2:\n        return False\n    if x == 2:\n        return True\n    i = 3\n    while i * i <= x:\n        if x % i == 0:\n            return False\n        i += 1\n    return True\n\ndef main():\n    n = int(13)\n    if isPrime(n):\n        stdout.write(\"es primo\")\n    else:\n        stdout.write(\"no es primo\")\n\nmain()\n",
    "orden": 6,
    "suborden": 4,
    "fecha_creacion": "2020-12-04 22:01:06",
    "fecha_modificacion": "2020-12-07 02:44:15"
  },
  {
    "ID": 38,
    "supergrupo": "Matemática",
    "tema": "Factores primos",
    "texto": "<div style=\"text-align: justify;\"><span style=\"font-size: 10pt;\">Los factores primos de un número entero son los números primos divisores exactos de ese número entero.&nbsp;</span></div><div style=\"text-align: justify;\"><span style=\"font-size: 10pt;\"><br></span></div><div style=\"text-align: justify;\">El proceso de búsqueda de esos divisores se denomina factorización de enteros, o factorización en números primos.\r\nDeterminar el número de factores primos de un número es un ejemplo de problema matemático frecuentemente empleado para asegurar la seguridad de los sistemas criptográficos: se cree que este problema requiere un tiempo superior al tiempo polinómico en el número de dígitos implicados; de hecho, es relativamente sencillo construir un problema que precisaría más tiempo que la Edad del Universo si se intentase calcular con los ordenadores actuales utilizando algoritmos actuales.\r\n</div>",
    "complejidad_tiempo": "Mejor caso :    O(vn)        Peor caso : O(vn)       Promedio: O(vn)         ",
    "java": "//Programa que descompone un número n\n// en sus factores primos\n\npublic class PrimeFactors {\n\n    public static void main(String[] args) {\n        primeFactors(12);\n    }\n    //Descomposicion en factores primos\n    public static void primeFactors(int N) {\n        for (long p = 2; p * p <= N; ++p) {\n            while (N % p == 0) {\n                System.out.println(p);\n                N /= p;\n            }\n        }\n        if (N > 1) {\n            System.out.println(N);\n        }\n    }\n}\n",
    "cpp": "#include<bits/stdc++.h>\n#include<cstdlib>\n//---------------//\nusing namespace std;\ntypedef long long int ll;\n\nvoid primeFactors(ll n) {\n    for (ll p = 2; p * p <= n; p++) {\n        while (n % p == 0) {\n            cout << p << \" \";\n            n /= p;\n        }\n    }\n    if (n > 1) {\n        cout << n << endl;\n    }\n}\n\nint main() {\n    ll n = 20;\n    primeFactors(n);\n}",
    "py": "from sys import stdout\n\ndef PrimeFactors(n):\n    i = int(2)\n    while i**2 <= n:\n        while n % i == 0:\n            stdout.write(str(i)+\"\\n\")\n            n //= i\n        i+=1\n    if n>1:\n        stdout.write(str(n))\n\ndef main():\n    PrimeFactors(20)\n\nmain()",
    "orden": 6,
    "suborden": 5,
    "fecha_creacion": "2020-12-04 22:01:06",
    "fecha_modificacion": "2020-12-07 02:44:34"
  },
  {
    "ID": 39,
    "supergrupo": "Matemática",
    "tema": "Divisibilidad de un número",
    "texto": "<div style=\"text-align: justify;\"><span style=\"font-size: 10pt;\">Los criterios de divisibilidad son reglas que sirven para saber si un número es divisible por otro sin necesidad de realizar la división, a continuación se presentan los criterios de divisibilidad para los números mas conocidos.</span></div>",
    "complejidad_tiempo": "Mejor caso :    O(n)        Peor caso : O(n)       Promedio: O(n)         ",
    "java": "//Programa que verifica la divisibilidad de un \n// número entre los números 1 a 12\n\npublic class DivisibilityBySmallNumbers {\n\n    public static void main(String[] args) {\n        boolean[] res = divisility(12);\n        for (int i = 0; i < res.length; i++) {\n            System.out.println(i + \" : \" + res[i]);\n        }\n    }\n\n    static public boolean[] divisility(int num) {\n        String M = String.valueOf(num);\n        int n = M.length();\n        boolean[] isMultipleOf = new boolean[13];\n        int sum = 0;\n        for (char c : M.toCharArray()) {\n            sum += c - '0';\n        }\n        int lastDigit = M.charAt(n - 1) - '0';\n        //Divisibilidad entre 1\n        isMultipleOf[1] = true;\n        //Divisibilidad entre 2\n        isMultipleOf[2] = lastDigit % 2 == 0;\n        //Divisibilidad entre 3\n        isMultipleOf[3] = sum % 3 == 0;\n        //Divisibilidad entre 4\n        if (n > 1) {\n            isMultipleOf[4] = Integer.parseInt(M.substring(n - 2, n)) % 4 == 0;\n        } else {\n            isMultipleOf[4] = lastDigit % 4 == 0;\n        }\n        //Divisibilidad entre 5\n        isMultipleOf[5] = lastDigit == 0 || lastDigit == 5;\n        //Divisibilidad entre 6\n        isMultipleOf[6] = isMultipleOf[2] && isMultipleOf[3];\n        int altSum = 0;\n        int[] pattern = {1, 3, 2, -1, -3, -2};\n        int j = 0;\n        for (int i = n - 1; i >= 0; i--) {\n            altSum += pattern[j] * (M.charAt(i) - '0');\n            j = (j + 1) % 6;\n        }\n        //Divisibilidad entre 7\n        isMultipleOf[7] = Math.abs(altSum) % 7 == 0;\n        //Divisibilidad entre 8\n        if (n > 2) {\n            isMultipleOf[8] = Integer.parseInt(M.substring(n - 3, n)) % 8 == 0;\n        } else {\n            isMultipleOf[8] = Integer.parseInt(M) % 8 == 0;\n        }\n        //Divisibilidad entre 9\n        isMultipleOf[9] = sum % 9 == 0;\n        //Divisibilidad entre 10\n        isMultipleOf[10] = lastDigit == 0;\n        altSum = 0;\n        int s = 1;\n        for (int i = n - 1; i >= 0; i--) {\n            altSum += s * (M.charAt(i) - '0');\n            s = -s;\n        }\n        //Divisibilidad entre 11\n        isMultipleOf[11] = Math.abs(altSum) % 11 == 0;\n        //Divisibilidad entre 12\n        isMultipleOf[12] = isMultipleOf[3] && isMultipleOf[4];\n        return isMultipleOf;\n    }\n}\n",
    "cpp": "#include<bits/stdc++.h>\n#include<cstdlib>\n//---------------//\nusing namespace std;\n\nvoid print(bool arr[]) {\n    for (int i = 0; i < 13; i++) {\n        cout << i << \": \" << arr[i] << endl;\n    }\n}\n\nvoid divisibility(int num) {\n    stringstream ss;\n    ss << num;\n    string M;\n    ss>>M;\n    int n = M.size();\n    bool isMultipleof[13];\n    memset(isMultipleof, false, sizeof isMultipleof);\n    int sum = 0;\n    for (int i = 0; i < n; i++) {\n        sum += (M[i] - '0');\n    }\n    int lastDigit = M[n - 1] - '0';\n    isMultipleof[0] = false;\n    isMultipleof[1] = true;\n    isMultipleof[2] = lastDigit % 2 == 0;\n    isMultipleof[3] = sum % 3 == 0;\n    if (n > 1) {\n        isMultipleof[4] = stoi(M.substr(n - 2, n)) % 4 == 0;\n    } else {\n        isMultipleof[4] = lastDigit % 4 == 0;\n    }\n    isMultipleof[5] = lastDigit == 0 || lastDigit == 5;\n    isMultipleof[6] = isMultipleof[2] && isMultipleof[3];\n    int altsum = 0;\n    int pattern[] = {1, 3, 2, -1, -3, -2};\n    int j = 0;\n    for (int i = n - 1; i>-0; i--) {\n        altsum += pattern[j]*(M[i] - '0');\n        j = (j + 1) % 6;\n    }\n    isMultipleof[7] = std::abs(altsum) % 7 == 0;\n    if (n > 2) {\n        isMultipleof[8] = stoi(M.substr(n - 3, n)) % 8 == 0;\n    } else {\n        isMultipleof[8] = stoi(M) % 8 == 0;\n    }\n    isMultipleof[9] = sum % 8 == 0;\n    isMultipleof[10] - lastDigit == 0;\n    altsum = 0;\n    int s = 1;\n    for (int i = n - 1; i >= 0; i--) {\n        altsum += s * (M[i] - '0');\n        s = -s;\n    }\n    isMultipleof[11] = std::abs(altsum) % 11 == 0;\n    isMultipleof[12] = isMultipleof[2] && isMultipleof[4];\n    print(isMultipleof);\n}\n\nint main() {\n    divisibility(33);\n}\n",
    "py": "from sys import stdout\n\n\ndef divisibility(num):\n    M = str(num)\n    n = len(M)\n    isMultipleOf = [False for x in range(13)]\n    suma = 0\n    for c in M:\n        suma += ord(c) - ord(\"0\")\n\n    lastDigit = ord(M[n - 1]) - ord(\"0\")\n    isMultipleOf[1] = True\n    isMultipleOf[2] = lastDigit % 2 == 0\n    isMultipleOf[3] = suma % 3 == 0\n\n    if n > 1:\n        isMultipleOf[4] = int(M[n - 2:n]) % 4 == 0\n    else:\n        isMultipleOf[4] = lastDigit % 4 == 0\n\n    isMultipleOf[5] = lastDigit == 0 or lastDigit == 5\n    isMultipleOf[6] = isMultipleOf[2] and isMultipleOf[3]\n\n    altsum = 0\n    pattern = [1, 3, 2, -1, -3, -2]\n    j = 0\n    for i in range(n - 1, -1, -1):\n        altsum = pattern[j] * (ord(M[i]) - ord(\"0\"))\n        j = (j + 1) % 6\n    isMultipleOf[7] = abs(altsum) % 7 == 0\n    if n > 2:\n        isMultipleOf[8] = int(M[n - 3:n]) % 8 == 0\n    else:\n        isMultipleOf[8] = int(M) % 8 == 0\n\n    isMultipleOf[9] = suma % 8 == 0\n    isMultipleOf[10] = lastDigit == 0\n    altsum = 0\n    s = 1\n    for i in range(n-1, -1, -1):\n        altsum += s * (ord(M[i]) - ord(\"0\"))\n        s = -s\n\n    isMultipleOf[11] = abs(altsum) % 11 == 0\n    isMultipleOf[12] = isMultipleOf[4] and isMultipleOf[13]\n    return isMultipleOf\n\n\nres = divisibility(123)\nfor i in range(len(res)):\n    stdout.write(f\"{i} : {res[i]}\\n\")\n",
    "orden": 6,
    "suborden": 6,
    "fecha_creacion": "2020-12-04 22:01:06",
    "fecha_modificacion": "2020-12-07 02:44:50"
  },
  {
    "ID": 40,
    "supergrupo": "Matemática",
    "tema": "Numero de divisores",
    "texto": "<div style=\"text-align: justify;\"><span style=\"font-size: 10pt;\">Los divisores de un número son aquellos valores que dividen al número en partes exactas. Así, dado un número a, si la división a/b es exacta (el resto es cero), entonces se dice que b es divisor de a. También se puede decir que a es divisible por b o que a es un múltiplo de b.&nbsp;</span></div><div style=\"text-align: justify;\"><span style=\"font-size: 10pt;\"><br></span></div><div style=\"text-align: justify;\">Esto resulta útil, por ejemplo, a la hora de agrupar una cantidad de objetos en partes iguales sin que nos sobre ninguno.\r\nLógicamente, el 1 siempre es divisor de cualquier número, porque siempre podemos hacer paquetes individuales y no nos sobrará ninguno. De igual forma, todo número es divisible por sí mismo, lo que equivaldría a hacer un único paquete.\r\n</div>",
    "complejidad_tiempo": "Mejor caso :    O(vn)        Peor caso : O(vn)       Promedio: O(vn)         ",
    "java": "//Programa java que cuenta el número\n// de divisores de x\n\npublic class NumberOfDivisors {\n\n    public static void main(String[] args) {\n        System.out.println(divisors(56));\n    }\n\n    //Todos los divisores de un número\n    public static int divisors(int x) {\n        int nDiv = 1;\n        for (int p = 2; p * p <= x; ++p) {\n            int cnt = 0;\n            while (x % p == 0) {\n                ++cnt; \n                x /= p;\n            }\n            nDiv *= cnt + 1;\n        }\n        if (x > 1) {\n            nDiv *= 2;\n        }\n        return nDiv;\n    }\n}\n",
    "cpp": "#include<bits/stdc++.h>\n#include<cstdlib>\n//---------------//\nusing namespace std;\n\nint divisors(int x) {\n    int nDiv = 1;\n    for (int i = 2; i * i <= x; i++) {\n        int cnt = 0;\n        while (x % i == 0) {\n            ++cnt;\n            x /= i;\n        }\n        nDiv *= cnt + 1;\n    }\n    if (x > 1) {\n        nDiv *= 2;\n    }\n    return nDiv;\n}\n\nint main() {\n    cout << divisors(10);\n}\n",
    "py": "from sys import stdout\n\n\ndef divisors(x):\n    nDiv = 1\n    i = 2\n    while i ** 2 <= x:\n        cnt = 0\n        while x % i == 0:\n            cnt += 1\n            x //= i\n        nDiv *= cnt + 1\n        i += 1\n    if x > 1:\n        nDiv *= 2\n    return nDiv\n\nstdout.write(str(divisors(10)))\n",
    "orden": 6,
    "suborden": 7,
    "fecha_creacion": "2020-12-04 22:01:06",
    "fecha_modificacion": "2020-12-07 02:45:29"
  },
  {
    "ID": 41,
    "supergrupo": "Matemática",
    "tema": "Criba de Eratóstenes",
    "texto": "Criba de Eratóstenes es un algoritmo que permite hallar todos los números primos menores que un número natural dado n. Se forma una tabla con todos los números naturales comprendidos entre 2 y n, y se van tachando los números que no son primos de la siguiente manera: \nComenzando por el 2, se tachan todos sus múltiplos; comenzando de nuevo, cuando se encuentra un número entero que no ha sido tachado, ese número es declarado primo, y se procede a tachar todos sus múltiplos, así sucesivamente. El proceso termina cuando el cuadrado del siguiente número confirmado como primo es mayor que n.\n",
    "complejidad_tiempo": "Mejor caso :    O(nlog(log(n)))     Peor caso : O(nlog(log(n)))       Promedio: O(nlog(log(n)))         ",
    "java": "//Programa java que encuentra todos los números \n//primos bajo N\n\nimport java.util.Arrays;\n\npublic class PrimeNumbers {\n\n    public static void main(String[] args) {\n        boolean[] res = sieveEratostenes(100);\n        for (int i = 0; i < res.length; i++) {\n            System.out.println(i + \" : \" + res[i]);\n        }\n    }\n\n    //Criba de Eratostenes (Todos los primos bajo un número)\n    public static boolean[] sieveEratostenes(int N) {\n        boolean[] prime = new boolean[N + 1];\n        Arrays.fill(prime, true);\n        prime[0] = prime[1] = false;\n        for (int p = 2; p * p <= N; p++) {\n            if (prime[p]) {\n                for (int i = p * p; i <= N; i += p) {\n                    prime[i] = false;\n                }\n            }\n        }\n        return prime;\n    }\n}\n",
    "cpp": "#include <bits/stdc++.h>\n#define FAST ios_base::sync_with_stdio(false);cin.tie(NULL);\nusing namespace std;\n\nvoid print(bool arr[], int n) {\n    for (int i = 0; i <= n; i++) {\n        cout << i << \": \" << arr[i] << endl;\n    }\n}\n\nvoid sieveErathostenes(int N) {\n    bool prime[N + 1];\n    memset(prime, true, sizeof prime);\n    prime[0] = prime[1] = false;\n    for (int p = 2; p * p <= N; p++) {\n        if (prime[p]) {\n            for (int i = p * p; i <= N; i += p) {\n                prime[i] = false;\n            }\n        }\n    }\n    print(prime, N);\n}\n\nint main() {\n    FAST;\n    sieveErathostenes(1000);\n    return 0;\n}\n",
    "py": "from sys import stdout\n\n\ndef sieveErathostenes(n):\n    prime = [True for x in range(n + 1)]\n    prime[0] = False\n    prime[1] = False\n    p = 2\n    while p ** 2 <= n:\n        if prime[p]:\n            i = p ** 2\n            while i <= n:\n                prime[i] = False\n                i += p\n        p += 1\n    return prime\n\nres = sieveErathostenes(100)\n\nfor i in range(len(res)):\n    stdout.write(str(i) + \" \" + str(res[i])+ \"\\n\")\n\n",
    "orden": 6,
    "suborden": 8,
    "fecha_creacion": "2020-12-04 22:01:06",
    "fecha_modificacion": "2020-12-06 20:23:02"
  },
  {
    "ID": 42,
    "supergrupo": "Matemática",
    "tema": "Criba de Eratóstenes O(n)",
    "texto": "La clásica criba de Eratóstenes toma O(Nlog (logN))  para encontrar todos los números primos  menores a N, este código es una versión modificada de esta criba que tiene una complejidad de tiempo de O(N).",
    "complejidad_tiempo": "Mejor caso :    O(n)        Peor caso : O(n)       Promedio: O(n)         ",
    "java": "/*Programa java que genera todos los números primos\nmenores a N en O(N) Eratostenes Optimizado*/\nimport java.util.ArrayList;\n\npublic class SieveofEratosthenesOptimizated {\n\n    static final int MAX_SIZE = 1000001;\n    // isPrime[] : isPrime[i] es true si el número es primo  \n    // prime[] : Almacena todos los números primos menores a N \n    // SPF[] Almacena los factores primos más pequeños de un número \n    // [Por ejemplo : factor primo más pequeño que '8' y '16' es  \n    //  '2' entonces nosotros ponemos SPF[8]=2 , SPF[16]=2 ] \n    static ArrayList<Boolean> isprime = new ArrayList<>(MAX_SIZE);\n    static ArrayList<Integer> prime = new ArrayList<>();\n    static ArrayList<Integer> SPF = new ArrayList<>(MAX_SIZE);\n    // Metodo que genera todos los factores primos menores de N\n\n    static void manipulated_seive(int N) {   // 0 y 1 no son primos\n        isprime.set(0, false);\n        isprime.set(1, false);\n\n        // llena el resto de las entradas\n        for (int i = 2; i < N; i++) {\n            // si isPrime[i] == True entonces i es  \n            // número primo\n            if (isprime.get(i)) {\n                // pone i dentro de prime[]  \n                prime.add(i);\n                // un número primo es su propio factor primo\n                // más pequeño\n                SPF.set(i, i);\n            }\n            /*Eliminar todos los múltiplos de i * prime [j] que son\n            no primos haciendo isPrime [i * prime [j]] = false\n            y ponga el factor primo más pequeño de i * Prime [j] como prime [j]\n            [Por ejemplo: dejemos i = 5, j = 0, prime[j] = 2 [i * prime [j] =           10]\n            por lo que el factor primo más pequeño de '10' es '2' que es prime          [j]]\n            este bucle se ejecuta solo una vez para el número que no es primo*/\n\n            for (int j = 0;\n                    j < prime.size()\n                    && i * prime.get(j) < N && prime.get(j) <= SPF.get(i);\n                    j++) {\n                isprime.set(i * prime.get(j), false);\n                // Pone el factor primo más pequeño de i*prime[j] \n                SPF.set(i * prime.get(j), prime.get(j));\n            }\n        }\n    }\n\n    public static void main(String args[]) {\n        int N = 13; //Debe ser menor que  MAX_SIZE        \n        // inicializando isprime y SPF\n        for (int i = 0; i < MAX_SIZE; i++) {\n            isprime.add(true);\n            SPF.add(2);\n        }\n        manipulated_seive(N);\n        //Imprima todos los números primos menores que n \n        for (int i = 0; i < prime.size() && prime.get(i) <= N; i++) {\n            System.out.print(prime.get(i) + \" \");\n        }\n    }\n}\n",
    "cpp": "#include <bits/stdc++.h>\n#define FAST ios_base::sync_with_stdio(false);cin.tie(NULL);\n#define MAX_SIZE 1000001\nusing namespace std;\ntypedef long long int ll;\nvector<int>prime;\n\nvoid manipule(ll N) {\n    bool arr[N + 1];\n    ll SPF[N + 1];\n    memset(arr, true, sizeof arr);\n    memset(SPF, 2, sizeof SPF);\n    arr[0] = false;\n    arr[1] = false;\n    for (ll i = 2; i < N; i++) {\n        if (arr[i]) {\n            prime.push_back(i);\n            SPF[i] = i;\n        }\n        for (ll j = 0; j < prime.size() && i * prime[j] < N && prime[j] <= SPF[i]; j++) {\n            arr[i * prime[j]] = false;\n            SPF[i * prime[j]] = prime[j];\n        }\n    }\n    for (ll i = 0; i < prime.size(); i++) {\n        cout << prime[i] << \" \";\n    }\n}\n\nint main() {\n    manipule(1000);\n}\n",
    "py": "from sys import stdin\nfrom sys import stdout\n\nwr = stdout.write\n\nMAX_SIZE = 1000001\n\nisprime = [True for x in range(MAX_SIZE)]\n\nprime = []\n\nSPF = [int for x in range(MAX_SIZE)]\n\ndef manipuledSieve(N):\n    global isprime\n    global prime\n    global SPF\n    isprime[0] = False\n    isprime[1] = False\n    for i in range(2, N):\n        if isprime[i]:\n            prime.append(i)\n            SPF[i] = i\n        j = 0\n        while j < len(prime) and i * prime[j] < N and prime[j] <= SPF[i]:\n            isprime[i * prime[j]] = False\n            SPF[i * prime[j]] = prime[j]\n            j += 1\n\nN = 100\nfor i in range(MAX_SIZE):\n    # isprime.append(True)\n    SPF.append(2)\nmanipuledSieve(N)\nfor i in range(len(prime)):\n    wr(f\"{prime[i]}  \")\n\nwr(\"\\n\")\n\nfor i in range(2, N):\n    wr(f\"{i} : {SPF[i]} \\n\")\n",
    "orden": 6,
    "suborden": 9,
    "fecha_creacion": "2020-12-04 22:01:06",
    "fecha_modificacion": "2020-12-06 20:23:03"
  },
  {
    "ID": 43,
    "supergrupo": "Matemática",
    "tema": "Ultimo digito de un Fibonacci",
    "texto": "La sucesión o serie de Fibonacci es una sucesión infinita de números naturales: 0 1 1 2 3 58 21 34 55 89....\nLa sucesión comienza con los números 0 y 1, y a partir de estos, cada término es la suma de los dos anteriores.\nLos números de esta sucesión pueden llegar a ser muy grandes y calcular su último digito se hace complicado en máquinas.\nUsando fib, multiply y power se puede calcular de forma optimizada un numero de Fibonacci, pero hay que tener en cuenta de no desbordar la variable o el resultado podría no ser correcto.\n",
    "complejidad_tiempo": "O(1)        Peor caso : O(1)       Promedio: O(1)         ",
    "java": "// Programa java que encuentra el ultimo digito \n// de un nesimo número fibonacci\n\npublic class FibonacciLastDigit {\n    //Funcion que retona el nesimo\n    // Número de fibonacci\n    static long fib(long n) {\n        long F[][] = new long[][]{{1, 1}, {1, 0}};\n        if (n == 0) {\n            return 0;\n        }\n        power(F, n - 1);\n        return F[0][0];\n    }\n    //Función que multiplica dos\n    // matrices y almacera el resultado en la primera\n    static void multiply(long F[][], long M[][]) {\n        long x = F[0][0] * M[0][0]\n                + F[0][1] * M[1][0];\n        long y = F[0][0] * M[0][1]\n                + F[0][1] * M[1][1];\n        long z = F[1][0] * M[0][0]\n                + F[1][1] * M[1][0];\n        long w = F[1][0] * M[0][1]\n                + F[1][1] * M[1][1];\n        F[0][0] = x;\n        F[0][1] = y;\n        F[1][0] = z;\n        F[1][1] = w;\n    }\n\n    static void power(long F[][], long n) {\n        if (n == 0 || n == 1) {\n            return;\n        }\n        long M[][] = new long[][]{{1, 1}, {1, 0}};\n        power(F, n / 2);\n        multiply(F, F);\n        if (n % 2 != 0) {\n            multiply(F, M);\n        }\n    }\n    // Retorna el ultimo digito \n    // nesimo número fibonacci\n    public static long findLastDigit(long n) {\n        return (fib(n) % 10);\n    }\n    public static void main(String[] args) {\n        int n;\n        n = 1;\n        System.out.println(findLastDigit(n));\n        n = 61;\n        System.out.println(findLastDigit(n));\n        n = 7;\n        System.out.println(findLastDigit(n));\n        n = 67;\n        System.out.println(findLastDigit(n));\n    }\n}\n",
    "cpp": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long int ll;\n\nvoid multiply(ll F[][2], ll M[][2]) {\n    ll x = F[0][0] * M[0][0] + F[0][1] * M[1][0];\n    ll y = F[0][0] * M[0][1] + F[0][1] * M[1][1];\n    ll z = F[1][0] * M[0][0] + F[1][1] * M[1][0];\n    ll w = F[1][0] * M[0][1] + F[1][1] * M[1][1];\n    F[0][0] = x;\n    F[0][1] = y;\n    F[1][0] = z;\n    F[1][1] = w;\n}\n\nvoid power(ll F[][2], ll n) {\n    if (n == 0 || n == 1) {\n        return;\n    }\n    ll M[][2] = {\n        {1, 1},\n        {1, 0}};\n    power(F, n / 2);\n    multiply(F, F);\n    if (n % 2 != 0) {\n        multiply(F, M);\n    }\n}\n\nll fib(ll n) {\n    ll F [][2] = {\n        {1, 1},\n        {1, 0}};\n    if (n == 0) {\n        return 0;\n    }\n    power(F, n - 1);\n    return F[0][0];\n}\n\nll findLastDigit(ll n) {\n    return (fib(n) % 10);\n}\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n    cout << fib(83) << \" : \" << findLastDigit(83);\n    return 0;\n}\n",
    "py": "from sys import stdout\nwr = stdout.write\n\n\ndef multiply(F, M):\n    x = F[0][0] * M[0][0] + F[0][1] * M[1][0]\n    y = F[0][0] * M[0][1] + F[0][1] * M[1][1]\n    z = F[1][0] * M[0][0] + F[1][1] * M[1][0]\n    w = F[1][0] * M[0][1] + F[1][1] * M[1][1]\n    F[0][0] = x\n    F[0][1] = y\n    F[1][0] = z\n    F[1][1] = w\n\n\ndef power(F, n):\n    if n == 0 or n == 1:\n        return\n    M = [[1, 1], [1, 0]]\n    power(F, n // 2)\n    multiply(F, F)\n    if n % 2 != 0:\n        multiply(F, M)\n\ndef fib(n):\n    F = [[1, 1], [1, 0]]\n    if n == 0:\n        return 0\n    power(F, n - 1)\n    return F[0][0]\n\ndef findLastDigit(n):\n    return fib(n) % 10\n\nwr(f'{fib(20)} : {findLastDigit(20)}')\n",
    "orden": 6,
    "suborden": 10,
    "fecha_creacion": "2020-12-04 22:01:06",
    "fecha_modificacion": "2020-12-06 20:23:04"
  },
  {
    "ID": 44,
    "supergrupo": "Matemática",
    "tema": "Fibonacci largos",
    "texto": "Ciertos ejercicios demandar realizar el cálculo de números de la secuencia de Fibonacci los cuales son demasiado grandes,  para ciertos lenguajes el tamaño de las variables es un impedimento para realizar esta acción por lo que se debe usar librerías que permitan realizar operaciones con números increíblemente grandes, pero hay que tener en cuenta que entre más grande el numero, el tiempo de ejecución va a ser mayor.",
    "complejidad_tiempo": "Mejor caso :    O(n)        Peor caso : O(n)       Promedio: O(n)         ",
    "java": "//Porgrama java que busca el nesimo número\n// de fibonacci cuando n puede ser muy largo\n\nimport java.math.*;\n\npublic class LongFibonacci {\n\n    static BigInteger fib(int n) {\n        BigInteger a = BigInteger.valueOf(0);\n        BigInteger b = BigInteger.valueOf(1);\n        BigInteger c = BigInteger.valueOf(1);\n        for (int j = 2; j <= n; j++) {\n            c = a.add(b);\n            a = b;\n            b = c;\n        }\n        return (a);\n    }\n\n    public static void main(String[] args) {\n        int n = 1000;\n        System.out.println(\"Fibonacci de  \" + n\n                + \" termino\" + \" \" + \"es\" + \" \" + fib(n));\n    }\n} \n",
    "cpp": null,
    "py": null,
    "orden": 6,
    "suborden": 11,
    "fecha_creacion": "2020-12-04 22:01:06",
    "fecha_modificacion": "2020-12-06 20:23:04"
  },
  {
    "ID": 45,
    "supergrupo": "Matemática",
    "tema": "Test de numero de Fibonacci",
    "texto": "Teniendo cualquier número entero n, se necesita verificar si este hace parte de la secuencia de los números de Fibonacci de forma optimizada.",
    "complejidad_tiempo": "Mejor caso :    O(log(n))        Peor caso : O(log(n))       Promedio: O(log(n))         ",
    "java": "// Programa que verifica si x es número fibonacci\n\npublic class IsFiboNumber {   \n    // Función que retorna si x es cuadrado perfecto\n    static boolean isPerfectSquare(int x) {\n        int s = (int) Math.sqrt(x);\n        return (s * s == x);\n    }\n    //Función que verifica si es número fibonacci\n    static boolean isFibonacci(int n) {   \n        // N es fibinacci si uno de 5*n*n+4 o or 5*n*n - 4\n        // o ambos son cuadrados perfectos\n        return isPerfectSquare(5 * n * n + 4)\n                || isPerfectSquare(5 * n * n - 4);\n    }\n\n    public static void main(String[] args) {\n        for (int i = 1; i <= 10; i++) {\n            System.out.println(isFibonacci(i) ? i + \" Es un número de fibonacci\"\n                    : i + \" No es un número de fibonacci\");\n        }\n    }\n}\n",
    "cpp": "#include<bits/stdc++.h>\n#include<cstdlib>\nusing namespace std;\n\nbool isPerfectSquare(int x) {\n    int s = (int) sqrt(x);\n    return (s * s == x);\n}\n\nbool isFibonacci(int n) {\n    return isPerfectSquare(5 * n * n + 4) || isPerfectSquare(5 * n * n - 4);\n}\n\nint main() {\n    for (int i = 0; i < 10; i++) {\n        isFibonacci(i) ? cout << i << \"Es Fibonacci\" << endl : cout << i << \"No es fibonacci\" << endl;\n    }\n} \n",
    "py": null,
    "orden": 6,
    "suborden": 12,
    "fecha_creacion": "2020-12-04 22:01:06",
    "fecha_modificacion": "2020-12-06 20:23:05"
  },
  {
    "ID": 46,
    "supergrupo": "Matemática",
    "tema": "Fibonacci Golden Ratio\n",
    "texto": "Existen diferentes métodos para encontrar el enésimo número de Fibonacci, una simple manera de encontrarlo es usando el ratio dorado.\nGolden ratio (Ratio dorado):\nf=(1+v5)/2=1.6180339887….\nGolden ratio nos puede dar una respuesta incorrecta.\nPodemos obtener la respuesta correcta si redondeamos hacia arriba el resultado de cada punto.\nEste método puede calcular los primeros 34 números de Fibonacci correctamente, luego de esto puede haber diferencia con el valor correcto.\n",
    "complejidad_tiempo": "Mejor caso :    O(vn)        Peor caso : O(vn)       Promedio: O(vn)         ",
    "java": "// Programa java que encuentra el \n// nesimo número fibonacci\n\npublic class FiboGoldenRatio {   //Valor aproximado del golden ratio\n    // Approximate value of golden ratio \n    static double PHI = 1.6180339;\n    // Números fibonacci hasta 5\n    static int f[] = {0, 1, 1, 2, 3, 5};\n    // Función que encuentra nesimo\n    // número fibonacci\n    static int fib(int n) {   // Números fibonacci menores a 6\n        if (n < 6) {\n            return f[n];\n        }\n        // Si no comience conteo desde el quinto\n        int t = 5;\n        int fn = 5;\n        while (t < n) {\n            fn = (int) Math.round(fn * PHI);\n            t++;\n        }\n        return fn;\n    }\n\n    public static void main(String[] args) {\n        int n = 9;\n        System.out.println(n + \" número fibonacci= \"\n                + fib(n));\n    }\n}\n",
    "cpp": "#include<bits/stdc++.h>\n#include<cstdlib>\nusing namespace std;\nconst double phi = 1.6180339;\nint f[] = {0, 1, 1, 2, 3, 5};\n\nint fib(int n) {\n    if (n < 6) {\n        return f[n];\n    }\n    int t = 5;\n    int fn = 5;\n    while (t < n) {\n        fn = (int) round(fn * phi);\n        t++;\n    }\n    return fn;\n}\n\nint main() {\n    for (int i = 0; i < 10; i++) {\n        cout << fib(i) << endl;\n    }\n} \n",
    "py": null,
    "orden": 6,
    "suborden": 13,
    "fecha_creacion": "2020-12-04 22:01:06",
    "fecha_modificacion": "2020-12-06 20:23:05"
  },
  {
    "ID": 47,
    "supergrupo": "Matemática",
    "tema": "Permutaciones",
    "texto": "Una permutación es la variación del orden o posición de los elementos de un conjunto ordenado o una tupla, hay dos tipos de permutaciones:\nSe permite repetir: una cerradura de combinación de tres numeros, podría ser \"333\".\nSin repetición: Los tres primeros puestos en una carrera. No puedes quedar primero y segundo a la vez.\n\n Permutaciones con repetición\nSon las más fáciles de calcular. Si tiene n cosas para elegir y elige r de ellas, las permutaciones posibles son:\n n × n × ... (r veces) = nr\n(Porque hay n posibilidades para la primera elección, luego hay n posibilidades para la segunda elección, y así.)\nPor ejemplo en un candado de combinacion de 3 numeros, hay 10 números para elegir (0,1,...,9) y se elige 3 de ellos:\n 10 × 10 × ... (3 veces) = 10^3 = 1000 permutaciones\n\nAsí que la fórmula es simplemente:\n n*r\ndonde n es el número de cosas que puede elegir, y elige r de ellas, dentro de estas permutaciones se puede repetir y el orden importa.\n\n2. Permutaciones sin repetición\nEn este caso, se reduce el número de opciones en cada paso.\n¿cómo se puede ordenar 16 bolas de billar?\nDespués de elegir por ejemplo la \"14\" no puede elegirla otra vez, así que la primera elección tiene 16 posibilidades, y la siguiente elección tiene 15 posibilidades, después 14, 13, hasta 1 Y el total de permutaciones sería:\n 16 × 15 × 14 × 13 ... = 20.922.789.888.000\nPero a lo mejor no quiere elegirlas todas, sólo 3 de ellas, así que sería solamente:\n 16 × 15 × 14 = 3360\nEs decir, hay 3.360 maneras diferentes de elegir 3 bolas de billar de entre 16.\nLa función factorial “!” significa que se multiplican números descendentes, varios ejemplos de factoriales son:\n 4! = 4 × 3 × 2 × 1 = 24\n 7! = 7 × 6 × 5 × 4 × 3 × 2 × 1 = 5040\n 1! = 1\n 16! = 20.922.789.888.000\nPero si sólo quiere elegir 3, tiene que dejar de multiplicar después de 14. \n¿Cómo se puede escribir esto? Se divide entre 13!...\n 16x15x14x13….. /13x12x11…. \n 16! / 13! = 16 × 15 × 14\nLa fórmula se escribe:\n n!/(n-r)!\ndonde n es el número de cosas que puede elegir, y elige r de ellas, dentro de este tipo e permutaciones no se puede repetir y  el orden importa.\n",
    "complejidad_tiempo": "Mejor caso :    O(ecuación aplicable)        Peor caso : O(ecuación aplicable)      \n Promedio: O(ecuación aplicable)         \n",
    "java": "//Programa java que imprime todas las permutaciones\n// con o sin repetición, r modifica el tamaño de las permutaciones\nimport java.util.Arrays;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.Set;\n\npublic class Permutations {\n\n    static Set<String> permutations;\n    static Set<String> result = new HashSet<>();\n    static int cont = 0;\n\n    static void permWithRepUtil(String str, char[] data,\n            int last, int index) {\n        int length = str.length();\n        for (int i = 0; i < length; i++) {\n            data[index] = str.charAt(i);\n            if (index == last) {\n                System.out.println(new String(data));\n                cont++;\n            } else {\n                permWithRepUtil(str, data, last,\n                        index + 1);\n            }\n        }\n    }\n\n    static void permWithRep(String str) {\n        int length = str.length();\n        char[] data = new char[length + 1];\n        char[] temp = str.toCharArray();\n        Arrays.sort(temp);\n        str = new String(temp);\n        permWithRepUtil(str, data, length - 1, 0);\n    }\n\n    static void shuffle(char c) {\n        if (permutations.isEmpty()) {\n            permutations.add(String.valueOf(c));\n        } else {\n            Iterator<String> it = permutations.iterator();\n            for (int i = 0; i < permutations.size(); i++) {\n                String temp1;\n                while (it.hasNext()) {\n                    temp1 = it.next();\n                    for (int k = 0; k < temp1.length() + 1; k++) {\n                        StringBuilder sb = new StringBuilder(temp1);\n                        sb.insert(k, c);\n                        result.add(sb.toString());\n                    }\n                }\n            }\n            permutations = result;\n            result = new HashSet<>();\n        }\n    }\n\n    static Set<String> permutation(String string) {\n        permutations = new HashSet<>();\n        int n = string.length();\n        for (int i = n - 1; i >= 0; i--) {\n            shuffle(string.charAt(i));\n        }\n        Set<String> aux = new HashSet<>();\n        Iterator<String> it = permutations.iterator();\n        while (it.hasNext()) {\n            String aux2 = it.next();\n            //Entre mas aumente r, mas pequeñas seran las permutations\n            int r = 0;\n            aux.add(aux2.substring(0, aux2.length() - 0));\n        }\n        return aux;\n\n    }\n\n    public static void main(String[] args) {\n        String entrada = \"1234\";\n        Set<String> res = permutation(entrada);\n        System.out.println(\"Hay en total \" + res.size() + \" permutations sin repetición de \" + entrada);\n        Iterator<String> it = res.iterator();\n        while (it.hasNext()) {\n            System.out.println(it.next());\n        }\n        String entrada2 = \"ABC\";\n permWithRep(entrada2);\n        System.out.println(\"Hay en total \" + cont + \" permutations con repetición de \" + entrada2);\n        \n    }\n}\n",
    "cpp": "#include <iostream>\n#include <set>\n#include <string.h>\n#include <algorithm>\n\nusing namespace std;\n\nint cont1 = 0;\nint cont2 = 0;\n\nvoid permWithOutRepetition(string str) {\n    char ayuda[str.size()];\n    strcpy(ayuda, str.c_str());\n    do {\n        ++cont1;\n        cout << ayuda << endl;\n    } while (next_permutation(ayuda, ayuda + str.size()));\n}\n\nvoid permWithRepUtil(string str, char data [], int last, int index) {\n    int length = str.size();\n    for (int i = 0; i < length; i++) {\n        data[index] = str[i];\n        if (index == last) {\n            cont2++;\n            string ayuda = data;\n            cout << ayuda << endl;\n        } else {\n            permWithRepUtil(str, data, last, index + 1);\n        }\n    }\n}\n\nvoid permWithRep(string str) {\n    int length = str.size();\n    char data[length + 1];\n    char temp[length];\n    strcpy(temp, str.c_str());\n    sort(temp, temp + length);\n    str = temp;\n    permWithRepUtil(str, data, length - 1, 0);\n}\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cout.tie(NULL);\n    cin.tie(NULL);\n    string entrada = \"Terry\";\n    permWithOutRepetition(entrada);\n    cout << \"Hay en total \" << cont1 << \" permutaciones sin repeticion de \" << entrada << endl;\n    cout << \"\\n\\n\" << endl;\n    permWithRep(entrada);\n    cout << \"Hay en total \" << cont2 << \" permutaciones con repeticion de \" << entrada << endl;\n} \n",
    "py": null,
    "orden": 6,
    "suborden": 14,
    "fecha_creacion": "2020-12-04 22:01:06",
    "fecha_modificacion": "2020-12-06 20:23:06"
  },
  {
    "ID": 48,
    "supergrupo": "Matemática",
    "tema": "Combinatorias",
    "texto": "La Combinatoria es la parte de las Matemáticas que estudia las diversas formas de realizar agrupaciones con los elementos de un conjunto, formándolas y calculando su número.\nExisten distintas formas de realizar estas agrupaciones, según se repitan los elementos o no, según se puedan tomar todos los elementos de que disponemos o no y si influye o no el orden de colocación de los elementos.\nEl orden NO es importante. La notación para las combinaciones es C(n,r) que es la cantidad de combinaciones de “n” elementos seleccionados, “r” a la vez. Es igual a la cantidad de permutaciones de “n” elementos tomados “r” a la vez dividido por “r” factorial. \n- P(n,r)/r!.\n\nEjemplo: Si se seleccionan cinco cartas de un grupo de nueve, ¿cuantas combinaciones de cinco cartas habría?\nLa cantidad de combinaciones posibles sería:\n-  P(9,5)/5! = (9*8*7*6*5)/(5*4*3*2*1) = 126 combinaciones posibles.\n",
    "complejidad_tiempo": "Mejor caso :    O(ecuación aplicable)        Peor caso : O(ecuación aplicable)      \n Promedio: O(ecuación aplicable)         \n",
    "java": "//Programa java que imprime todas las combinaciones con o sin repetición\n// de tamaño r en un arreglo de tamaño n\n\npublic class Combinations {\n\n    static void combinationUtil(int arr[], int data[], int start,\n            int end, int index, int r) {\n        if (index == r) {\n            for (int j = 0; j < r; j++) {\n                System.out.print(data[j] + \" \");\n            }\n            System.out.println(\"\");\n            return;\n        }\n\n        for (int i = start; i <= end && end - i + 1 >= r - index; i++) {\n            data[index] = arr[i];\n            combinationUtil(arr, data, i + 1, end, index + 1, r);\n        }\n    }\n\n    static void combination(int arr[], int n, int r) {\n        int data[] = new int[r];\n        combinationUtil(arr, data, 0, n - 1, 0, r);\n    }\n\n    static void CombinationRepetitionUtil(int chosen[], int arr[],\n            int index, int r, int start, int end) {\n        if (index == r) {\n            for (int i = 0; i < r; i++) {\n                System.out.printf(\"%d \", arr[chosen[i]]);\n            }\n            System.out.printf(\"\\n\");\n            return;\n        }\n        for (int i = start; i < end; i++) {\n            chosen[index] = i;\n            CombinationRepetitionUtil(chosen, arr, index + 1,\n                    r, i, end);\n        }\n        \n    }\n\n    static void CombinationRepetition(int arr[], int n, int r) {\n        int chosen[] = new int[r + 1];\n        CombinationRepetitionUtil(chosen, arr, 0, r, 0, n - 1);\n    }\n\n    public static void main(String[] args) {\n        //Sin repetición\n        int arr[] = {1, 2, 3, 4, 5};\n        int r = 3;\n        int n = arr.length;\n        combination(arr, n, r);\n        //Con repetición\n        int arr2[] = {1, 2, 3, 4};\n        int n2 = arr.length;\n        int r2 = 2;\n        CombinationRepetition(arr2, n2, r2);\n\n    }\n}\n",
    "cpp": "#include <cstdlib>\n#include <bits/stdc++.h>\nusing namespace std;\n\nvoid combinationUtil(int arr[], int data[], int start, int end, int index, int r) {\n    if (index == r) {\n        for (int j = 0; j < r; j++) {\n            cout << data[j] << \" \";\n        }\n        cout << endl;\n        return;\n    }\n    for (int i = start; i <= end && end - i + 1 >= r - index; i++) {\n        data[index] = arr[i];\n        combinationUtil(arr, data, i + 1, end, index + 1, r);\n    }\n}\n\nvoid combination(int arr[], int n, int r) {\n    int data[r];\n    combinationUtil(arr, data, 0, n - 1, 0, r);\n}\n\nvoid combinationRepetitionUtil(int chosen[], int arr[], int index, int r, int start, int end) {\n    if (index == r) {\n        for (int i = 0; i < r; i++) {\n            cout << arr[chosen[i]] << \" \";\n        }\n        cout << endl;\n        return;\n    }\n    for (int i = start; i < end; i++) {\n        chosen[index] = i;\n        combinationRepetitionUtil(chosen, arr, index + 1, r, i, end);\n    }\n    return;\n}\n\nvoid combinationRepetition(int arr[], int n, int r) {\n    int chosen[r + 1];\n    combinationRepetitionUtil(chosen, arr, 0, r, 0, n - 1);\n}\n\nint main(int argc, char const *argv[]) {\n    cout << \"Sin Repeticion\" << endl;\n    int arr[] = {1, 2, 3, 4, 5};\n    int r = 3;\n    int n = sizeof (arr) / sizeof (arr[0]);\n    combination(arr, n, r);\n    cout << \"Con Repeticion\" << endl;\n    int arr2[] = {1, 2, 3, 4};\n    int n2 = sizeof (arr2) / sizeof (arr2[0]);\n    int r2 = 2;\n    combinationRepetition(arr2, n2, r2);\n    return 0;\n}\n",
    "py": "from sys import stdout\nwr = stdout.write\n\ncont1 = 0\ncont2 = 0\n\ndef combUtil(arr, data, start, end, index, r):\n    global cont1\n    if index == r:\n        for j in range(r):\n            wr(f'{data[j]} ')\n        wr('\\n')\n        cont1 += 1\n        return\n    i = start\n    while i <= end and end - i + 1 >= r - index:\n        data[index] = arr[i]\n        combUtil(arr, data, i+1, end, index+1, r)\n        i += 1\n\ndef combinationRepetitionUtil(chosen, arr, index, r, start, end):\n    global cont2\n    if index == r:\n        for i in range(r):\n            wr(f'{arr[chosen[i]]} ')\n        wr('\\n')\n        cont2 += 1\n        return\n    for i in range(start, end):\n        chosen[index] = i\n        combinationRepetitionUtil(chosen, arr, index+1, r, i, end)\n    return\n\ndef printComb(arr, n, r):\n    data = [0 for x in range(r)]\n    combUtil(arr, data, 0, n-1, 0, r)\n\ndef combinationRepetition(arr, n, r):\n    chosen = [0 for x in range(r+1)]\n    combinationRepetitionUtil(chosen, arr, 0, r, 0, n-1)\n\narrint1 = [1, 2, 3, 4, 5]\nr1 = 3\nn1 = len(arrint1)\nprintComb(arrint1, n1, r1)\nwr(f'Hay {str(cont1)} Combinaciones Sin Repetición\\n')\n\narrint2 = [1, 2, 3, 4, 5]\nr2 = 2\nn2 = len(arrint2)\ncombinationRepetition(arrint2, n2, r2)\nwr(f'Hay {str(cont2)} Combinaciones Con Repetición')\n",
    "orden": 6,
    "suborden": 15,
    "fecha_creacion": "2020-12-04 22:01:06",
    "fecha_modificacion": "2020-12-06 20:23:07"
  },
  {
    "ID": 49,
    "supergrupo": "Matemática",
    "tema": "Combinatorias compuestas",
    "texto": "Teniendo la teoría anterior clara, se puede modificar el algoritmo de tal forma que calcule las composiciones compuestas tal y como deseemos.",
    "complejidad_tiempo": "Mejor caso :    O(ecuación aplicable)        Peor caso : O(ecuación aplicable)      \n Promedio: O(ecuación aplicable)         \n",
    "java": "//Programa java que imprime todas\n//las combinaciones que pueden componer un número dado\n\npublic class CombinationsCompose {\n    //Función imprime todas las combinaciones de números 1, 2, ...MAX_POINT\n    // que su suma resulte  n\n    // i es usado en recursion para mantener revisión del indice\n    // en arr[] donde el siguiente elemento sera añadido\n    // Valor inicial de i debe ser pasado como 0\n\n    static void printCompositions(int arr[], int n, int i) {\n        int MAX_POINT = 3;\n        if (n == 0) {\n            printArray(arr, i);\n        } else if (n > 0) {\n            for (int k = 1; k <= MAX_POINT; k++) {\n                arr[i] = k;\n                printCompositions(arr, n - k, i + 1);\n            }\n        }\n    }\n\n    // Imprime array\n    static void printArray(int arr[], int m) {\n        for (int i = 0; i < m; i++) {\n            System.out.print(arr[i] + \" \");\n        }\n        System.out.println();\n    }\n\n    public static void main(String[] args) {\n        int n = 5;\n        int size = 100;\n        int[] arr = new int[size];\n        System.out.println(\"Diferentes composiciones formadas por \"\n                + \"1, 2 y 3 de \" + n + \" son \");\n        printCompositions(arr, n, 0);\n    }\n}\n",
    "cpp": "#include<bits/stdc++.h>\n#include<cstdlib>\nusing namespace std;\n\nvoid printArr(int arr[], int n) {\n    for (int i = 0; i < n; i++) {\n        cout << arr[i] << \" \";\n    }\n    cout << endl;\n}\n\nvoid printCompositions(int arr[], int n, int i) {\n    int MAX_POINT = 3;\n    if (n == 0) {\n        printArr(arr, i);\n    } else if (n > 0) {\n        for (int k = 1; k <= MAX_POINT; k++) {\n            arr[i] = k;\n            printCompositions(arr, n - k, i + 1);\n        }\n    }\n}\n\nint main() {\n    int n = 5;\n    int len = 100;\n    int arr[len];\n    printCompositions(arr, n, 0);\n    return 0;\n} \n",
    "py": null,
    "orden": 6,
    "suborden": 16,
    "fecha_creacion": "2020-12-04 22:01:06",
    "fecha_modificacion": "2020-12-06 20:23:07"
  },
  {
    "ID": 50,
    "supergrupo": "Matemática",
    "tema": "Subsets de un Set (Conjuntos)",
    "texto": "Un conjunto (set) es una colección de elementos con características similares considerada en sí misma como un objeto. Los elementos de un conjunto, pueden ser las siguientes: personas, números, colores, letras, figuras, etc.\nSe dice que un elemento (o miembro) pertenece al conjunto si está definido como incluido de algún modo dentro de él.\n",
    "complejidad_tiempo": "Mejor caso :    O(n2n)        Peor caso : O(n2n)      Promedio: O(n2n)         ",
    "java": "//Programa java que imprime todos los subconjuntos de \n//un conjunto\n\npublic class Allsets {\n\n    static void printSubsets(char set[]) {\n        int n = set.length;\n        // Ejecuta un ciclo imprimiendo todos\n        //  los subconjuntos 2^n uno por uno\n        for (int i = 0; i < (1 << n); i++) {\n            System.out.print(\"{ \");\n            //Imprime el subconjunto actual\n            for (int j = 0; j < n; j++) // (1<<j) es un número con jesimo bit 1\n            {\n                if ((i & (1 << j)) > 0) {\n                    System.out.print(set[j] + \" \");\n                }\n            }\n            System.out.println(\"}\");\n        }\n    }\n\n    public static void main(String[] args) {\n        char set[] = {'a', 'b', 'c'};\n        printSubsets(set);\n    }\n}\n",
    "cpp": "#include<bits/stdc++.h>\n#include<cstdlib>\nusing namespace std;\n\nvoid printSubset(char sets[], int n) {\n    for (int i = 0; i < (1 << n); i++) {\n        cout << \"{\";\n        for (int j = 0; j < n; j++) {\n            if ((i & (1 << j))) {\n                cout << sets[j] << \" \";\n            }\n        }\n        cout << \"}\" << endl;\n    }\n}\n\nint main() {\n    char conjunto[] = {'a', 'b', 'c'};\n    int n = sizeof conjunto / sizeof conjunto[0];\n    printSubset(conjunto, n);\n}\n",
    "py": "from sys import stdout\nwr = stdout.write\n\n\ndef printSubsets(sset):\n    n = len(sset)\n    for i in range(1 << n):\n        wr('{ ')\n        for j in range(n):\n            if (i & (1 << j)) > 0:\n                wr(f'{sset[j]} ')\n        wr('}\\n')\n        \n        \nconjunto = ['a', 'b', 'c']\nprintSubsets(conjunto)\n",
    "orden": 6,
    "suborden": 17,
    "fecha_creacion": "2020-12-04 22:01:06",
    "fecha_modificacion": "2020-12-06 20:23:08"
  },
  {
    "ID": 51,
    "supergrupo": "Matemática",
    "tema": "Coeficientes binomiales",
    "texto": "Los coeficientes binomiales, números combinatorios o combinaciones son números estudiados en combinatoria que corresponden al número de formas en que se puede extraer subconjuntos a partir de un conjunto dado.",
    "complejidad_tiempo": "Mejor caso :    O(n+k)        Peor caso : O(n+k)      Promedio: O(n+k)         ",
    "java": "// Programa java que  calcula el valor\n// de coeficientes binomiales\n\npublic class BinomialCoefficients {\n    // Retorna el valor del coeficiente binomial\n    // C(n, k)  \n    static int binomialCoeff(int n, int k) {\n        // Casos base\n        if (k == 0 || k == n) {\n            return 1;\n        }\n        // Recursión\n        return binomialCoeff(n - 1, k - 1)\n                + binomialCoeff(n - 1, k);\n    }\n\n    public static void main(String[] args) {\n        int n = 5, k = 2;\n        System.out.printf(\"Valor de C(%d, %d) is %d \",\n                n, k, binomialCoeff(n, k));\n    }\n}\n",
    "cpp": "#include<bits/stdc++.h>\n#include<cstdlib>\nusing namespace std;\n\nint BinomialCoeff(int n, int k) {\n    if (k == 0 || k == n) {\n        return 1;\n    }\n    return BinomialCoeff(n - 1, k - 1) + BinomialCoeff(n - 1, k);\n}\n\nint main() {\n    int n = 5, k = 2;\n    printf(\"valor de C(%d, %d) is %d\", n, k, BinomialCoeff(n, k));\n} \n",
    "py": null,
    "orden": 6,
    "suborden": 18,
    "fecha_creacion": "2020-12-04 22:01:06",
    "fecha_modificacion": "2020-12-06 20:23:09"
  },
  {
    "ID": 52,
    "supergrupo": "Matemática",
    "tema": "Torres de Hanoi",
    "texto": "Las Torres de Hanói son un rompecabezas o juego matemático inventado en 1883 por el matemático francés Édouard Lucas. Este juego de mesa individual consiste en un número de discos perforados de radio creciente que se apilan insertándose en uno de los tres postes fijados a un tablero. El objetivo del juego es trasladar la pila a otro de los postes siguiendo ciertas reglas, como que no se puede colocar un disco más grande encima de un disco más pequeño. El problema es muy conocido en la ciencia de la computación y aparece en muchos libros de texto como introducción a la teoría de algoritmos.\nLa fórmula para encontrar el número de movimientos necesarios para transferir n discos desde un poste a otro es: 2n – 1.\n",
    "complejidad_tiempo": "Mejor caso :    O(2n)        Peor caso : O(2n)      Promedio: O(2n)         ",
    "java": "//Programa java que calcula los movimientos\n// necesarios para completar las torres de Hanoi\n// Sin importar el número de discos n\n\npublic class HanoiTowels {\n\n    public static void main(String[] args) {\n        //Número de discos\n        int n;\n        n = 8;\n        hanoi(n, \"Primera torre\", \"Segunda torre\", \"Tercera torre\");\n    }\n    static int paso = 1;\n    //Función recursiva de busqueda\n    static void hanoi(int n, String from, String temp, String to) {\n        if (n == 0) {\n            return;\n        }\n        hanoi(n - 1, from, to, temp);\n        System.out.println(paso + \": Mover disco \" + n + \n                \" de \" + from + \" a \" + to);\n        paso++;\n        hanoi(n - 1, temp, from, to);\n    }\n}\n",
    "cpp": "#include<bits/stdc++.h>\n#include<cstdlib>\nusing namespace std;\nint paso = 1;\n\nvoid hanoi(int n, string from, string temp, string to) {\n    if (n == 0) {\n        return;\n    }\n    hanoi(n - 1, from, to, temp);\n    cout << paso << \" mover disco \" << n << \" de \" << from << \" a \" << to << endl;\n    paso++;\n    hanoi(n - 1, temp, from, to);\n}\n\nint main() {\n    int n = 8;\n    hanoi(n, \"Primer Torre\", \"Segunda Torre\", \"Tercer Torre\");\n    return 0;\n} \n",
    "py": null,
    "orden": 6,
    "suborden": 19,
    "fecha_creacion": "2020-12-04 22:01:06",
    "fecha_modificacion": "2020-12-06 20:23:09"
  },
  {
    "ID": 53,
    "supergrupo": "Matemática",
    "tema": "AX+BY=N",
    "texto": "Dado a, b y n. Encuentre x y y  que satisfaga ax+by=n, imprima cualquiera de los x y y que cumplan la ecuación.\nPodemos verificar si alguna solución existe o no usando ecuaciones lineales de Diofanes, pero ahí se necesita encontrar para esta ecuación, entonces se puede simplemente iterar por todos los posibles valores de 0 a n sin exceder n para esta ecuación. Entonces resolviendo esta ecuación con lápiz y papel obtenemos y=(n-ax)/b y similarmente obtenemos el otro número con x=(n-by)/a, si ninguno de los valores satisface la ecuación, al final imprime “Sin solución”.\n",
    "complejidad_tiempo": "Mejor caso :    O(n)        Peor caso : O(n)      Promedio: O(n)         ",
    "java": "//Programa que calcula la solución de\n// ax + by = n \n\npublic class AXplusBYequalsN {\n\n    static void solution(int a, int b, int n) {\n        //A traves de todos los posibles valores\n        for (int i = 0; i * a <= n; i++) {\n            //Verifica si se satisface la ecuación\n            if ((n - (i * a)) % b == 0) {\n                System.out.println(\"x = \" + i\n                        + \", y = \"\n                        + (n - (i * a)) / b);\n                return;\n            }\n        }\n        System.out.println(\"Sin solución\");\n    }\n\n    public static void main(String[] args) {\n        int a = 2, b = 3, n = 7;\n        solution(a, b, n);\n    }\n}\n",
    "cpp": "#include <iostream>\n\nusing namespace std;\n\nvoid solution(int a, int b, int n) {\n    for (int i = 0; i * a <= n; i++) {\n        if ((n - (i * a)) % b == 0) {\n            cout << \"x: \" << i << \", y: \" << ((n - (i * a)) / b) << endl;\n            return;\n        }\n    }\n    cout << \"No hay solucion\" << endl;\n}\n\nint main() {\n    int a = 2, b = 3, n = 16;\n    solution(a, b, n);\n    return 0;\n}\n",
    "py": "from sys import stdout\n\ndef solution(a, b, n):\n    i = 0\n    while i * a <= n:\n        if (n - (i * a)) % b == 0:\n            stdout.write(f\"x = {i} y = {(n-(i*a))/b}\")\n            return\n        i += 1\n    stdout.write(\"No tiene soluciÃ³n \\n\")\n\na, b, n = 2, 3, 7\nsolution(a, b, n)\n\n",
    "orden": 6,
    "suborden": 20,
    "fecha_creacion": "2020-12-04 22:01:06",
    "fecha_modificacion": "2020-12-06 20:23:10"
  },
  {
    "ID": 54,
    "supergrupo": "Matemática",
    "tema": "A%X=B",
    "texto": "Dados dos números a y b, encontrar todos los x que permitan a%x=b.\nExisten tres casos:\n- Si  a es menor que b entonces no habrá respuesta.\n- Si a es igual que b entonces todos los números más grandes que a, habrá infinitas soluciones.\n- Si a es mayor que b, supone que x es una respuesta a nuestra ecuación. Entonces x divide (a-b) también desde a%x=b entonces b es menor que x\n",
    "complejidad_tiempo": "Mejor caso :    O(n)        Peor caso : O(n)      Promedio: O(n)         ",
    "java": "/* Programa java que encuentra x tal que\na % x es igual  b.*/\npublic class AmodXequalB {\n\n    static void modularEquation(int a, int b) {\n        // Si a es menos que b, entonces no hay solución\n        if (a < b) {\n            System.out.println(\"No solution possible \");\n            return;\n        }\n        /*Si a es igual a b, entonces cada número \n        más grande que a sera la solución, entonces\n        es infinito*/\n        if (a == b) {\n            System.out.println(\"Infinite Solution possible \");\n            return;\n        }\n        /*todo el número resultante debe ser mayor\n        que b y (a-b) deben ser divisibles\n        por número resultante\n        variable count almacena el número de\n        valores posibles*/\n        int count = 0;\n        int n = a - b;\n        int y = (int) Math.sqrt(a - b);\n        for (int i = 1; i <= y; ++i) {\n            if (n % i == 0) {\n                /*Revisando por ambos divisor y \n                cociente cual divide (a-b) completamente\n                y mayor que b*/\n                if (n / i > b) {\n                    count++;\n                }\n                if (i > b) {\n                    count++;\n                }\n            }\n        }\n        /* Aqui y es añadido dos veces en la\n        ultima iteracón entonces y deberia ser decrementado\n        para obtener la solución correcta*/\n        if (y * y == n && y > b) {\n            count--;\n        }\n        System.out.println(count);\n    }\n\n    public static void main(String[] args) {\n        int a = 21, b = 5;\n        modularEquation(a, b);\n    }\n}\n",
    "cpp": "#include<bits/stdc++.h>\n#include<cstdlib>\nusing namespace std;\n\nvoid modEquation(int a, int b) {\n    if (a < b) {\n        cout << \"no hay solucion\" << endl;\n        return;\n    }\n    if (a == b) {\n        cout << \"infinitas soluciones\" << endl;\n        return;\n    }\n    int cont = 0;\n    int n = a - b;\n    int y = std::sqrt(a - b);\n\n    for (int i = 1; i <= y; i++) {\n        if (n % i == 0) {\n            if (n / i > b) {\n                cont++;\n                cout << (n / i) << \" \";\n            }\n            if (i > b) {\n                cont++;\n                cout << i << \" \";\n            }\n        }\n    }\n    cout << endl;\n    if (y * y == n && y > b) {\n        cont--;\n    }\n    cout << cont << endl;\n}\n\nint main() {\n    //a%x=b;\n    int a = 21, b = 5;\n    modEquation(a, b);\n}\n",
    "py": "import math\nfrom sys import stdout\nwr = stdout.write\n\n\ndef modEquation(a, b):\n    if a < b:\n        wr(f'No hay Solucion')\n        return\n    if a == b:\n        wr(f'Infinitas Soluciones')\n    cont = 0\n    n = a - b\n    y = int(math.sqrt(a-b))\n    for i in range(1, y + 1):\n        if n % i == 0:\n            if n // i > b:\n                cont += 1\n                wr(f'{n//i}\\n')\n            if i > b:\n                cont += 1\n                wr(f'{i}\\n')\n    if y * y == n and y > b:\n        cont -= 1\n    wr(f'{cont}')\n\n\na = 21\nb = 5\nmodEquation(a, b)\n",
    "orden": 6,
    "suborden": 22,
    "fecha_creacion": "2020-12-04 22:01:06",
    "fecha_modificacion": "2020-12-06 20:23:10"
  },
  {
    "ID": 55,
    "supergrupo": "Matemática",
    "tema": "E pow X",
    "texto": "El valor de la función exponencial e^x puede ser expresado usando la siguiente serie de Taylor:\n- e^x = 1 + x/1! + x^2/2! + x^3/3! + ...... \n¿Cómo calcular eficientemente la suma de la serie de arriba? Puede ser escrita de la siguiente forma:\n- e^x = 1 + (x/1) (1 + (x/2) (1 + (x/3) (........)))\n",
    "complejidad_tiempo": "Mejor caso :    O(n)        Peor caso : O(n)      Promedio: O(n)         ",
    "java": "// Programa eficiente que calcula e elevado x\n\npublic class EpowX {\n    // Función que retorna aproximado de e^x\n    // Usando suma de los primeros n terminos\n    // de la serie de Taylor \n    static float exponential(int n, float x) {\n        float sum = 1;\n        for (int i = n - 1; i > 0; --i) {\n            sum = 1 + x * sum / i;\n        }\n        return sum;\n    }\n\n    public static void main(String[] args) {\n        int n = 10;\n        float x = 1;\n        System.out.println(\"e^x = \" + exponential(n, x));\n    }\n}\n",
    "cpp": "#include <iostream>\n#include <iomanip>\n\nusing namespace std;\n\ndouble exp(int n, double x) {\n    double sum = 1;\n    for (int i = n - 1; i > 0; i--) {\n        sum = 1 + x * sum / i;\n    }\n    return sum;\n}\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cout.tie(NULL);\n    int n = 10;\n    double x = 2;\n    cout << \"exp: \" << setprecision(25) << exp(n, x) << endl;\n    cout << \"exp: \" << setprecision(25) << exp(n + 10, x) << endl;\n    return 0;\n}\n",
    "py": "from sys import stdout\nwr = stdout.write\n\ndef exp(n, x):\n    suma = 1\n    for i in range(n-1, 0, -1):\n        suma = 1 + x * suma / i\n    return suma\n\nn = 10\nx = 2\nwr(f'exp = {exp(n,x)}\\n')\nwr(f'exp = {exp(n+10,x)}')\n",
    "orden": 6,
    "suborden": 23,
    "fecha_creacion": "2020-12-04 22:01:06",
    "fecha_modificacion": "2020-12-06 20:23:11"
  },
  {
    "ID": 56,
    "supergrupo": "Matemática",
    "tema": "Factorial",
    "texto": "El factorial de un entero positivo n, el factorial de n o n factorial se define en principio como el producto de todos los números enteros positivos desde 1 (es decir, los números naturales) hasta n.\nLa operación de factorial aparece en muchas áreas de las matemáticas, particularmente en combinatoria y análisis matemático. De manera fundamental la factorial de n representa el número de formas distintas de ordenar n objetos distintos (elementos sin repetición).\n",
    "complejidad_tiempo": "Mejor caso :    O(n)        Peor caso : O(n)      Promedio: O(n)         ",
    "java": "// Programa java que encuentra el \n// factorial de un número\n\npublic class Factorial {\n\n    static int factorial(int n) {\n        if (n == 0) {\n            return 1;\n        }\n        return n * factorial(n - 1);\n    }\n\n    public static void main(String[] args) {\n        int num = 5;\n        System.out.println(\"Factorial de \" + num + \" es \" + factorial(5));\n    }\n}\n",
    "cpp": "#include<bits/stdc++.h>\n#include<cstdlib>\nusing namespace std;\ntypedef long long int ll;\nll factorial(ll n){\n    if(n==0){\n        return 1;\n    }\n    return n*(factorial(n-1));\n}\nint main() {\n    cout<<factorial(10)<<endl;\n}\n",
    "py": "from sys import stdout\nwr = stdout.write\n\ndef factorial(n):\n    if n == 0:\n        return 1\n    return n * factorial(n-1)\n\nres = 5\nwr(f'{factorial(res)}')\n",
    "orden": 6,
    "suborden": 24,
    "fecha_creacion": "2020-12-04 22:01:06",
    "fecha_modificacion": "2020-12-06 20:23:12"
  },
  {
    "ID": 57,
    "supergrupo": "Matemática",
    "tema": "Factorial largo",
    "texto": "Al igual que con otras secuencias numéricas, el cálculo de números grandes puede ser un problema debido a que pueden no caber dentro de una variable en específico, o ser muy lentas al calcularlo, el siguiente código presenta una forma optimizada de calcular factoriales grandes sin sacrificar tanto tiempo de ejecución, aunque para números demasiado grandes puede seguir siendo demasiado lento.",
    "complejidad_tiempo": "Mejor caso :    O(n)        Peor caso : O(n)      Promedio: O(n)         ",
    "java": "// Programa java que calcula factoriales\n// de números enormes\n\npublic class BigFactorial {\n\n    static void factorial(int n) {\n        int res[] = new int[500];\n        res[0] = 1;\n        int res_size = 1;\n        // Aplicamos la formula normal de facotorial\n        // n! = 1 * 2 * 3 * 4...*n \n        for (int x = 2; x <= n; x++) {\n            res_size = multiply(x, res, res_size);\n        }\n\n        System.out.println(\"Factorial del numero dado es \");\n        for (int i = res_size - 1; i >= 0; i--) {\n            System.out.print(res[i]);\n        }\n    }\n\n    static int multiply(int x, int res[], int res_size) {\n        int carry = 0; // inicializar carry\n        // Uno por uno multiplicamos n con \n        //los digitos individuales de res[] \n        for (int i = 0; i < res_size; i++) {\n            int prod = res[i] * x + carry;\n            res[i] = prod % 10; //Almacenar ultimo digito de  \n            // 'prod' en res[] \n            carry = prod / 10; // Poner el resto de carry \n        }\n        //Pone el carry en res e incrementa el tamaño del resultadolt size \n        while (carry != 0) {\n            res[res_size] = carry % 10;\n            carry = carry / 10;\n            res_size++;\n        }\n        return res_size;\n    }\n\n    public static void main(String args[]) {\n        factorial(100);\n    }\n}\n",
    "cpp": "#include <iostream>\n\nusing namespace std;\n\nint multiply(int x, int res[], int res_size) {\n    int carry = 0;\n    for (int i = 0; i < res_size; i++) {\n        int prod = res[i] * x + carry;\n        res[i] = prod % 10;\n        carry = prod / 10;\n    }\n    while (carry != 0) {\n        res[res_size] = carry % 10;\n        carry /= 10;\n        res_size++;\n    }\n    return res_size;\n}\n\nvoid factorial(int n) {\n    int res[10000];\n    res[0] = 1;\n    int res_size = 1;\n    for (int i = 2; i <= n; i++) {\n        res_size = multiply(i, res, res_size);\n    }\n    cout << \"Factorial del numero dado es:\" << endl;\n    for (int i = res_size - 1; i >= 0; i--) {\n        cout << res[i];\n    }\n    cout << endl;\n}\n\nint main() {\n    factorial(100);\n    return 0;\n}\n",
    "py": "from sys import stdout\nwr = stdout.write\n\ndef multilply(x, res, res_size):\n    carry = 0\n    for i in range(res_size):\n        prod = res[i] * x + carry\n        res[i] = prod % 10\n        carry = prod // 10\n    while carry != 0:\n        res[res_size] = carry % 10\n        carry //= 10\n        res_size += 1\n    return res_size\n\ndef factorial(n):\n    res = [0 for x in range(500)]  # Maximo digitos de n\n    res[0] = 1\n    res_size = 1\n    for i in range(2, n + 1):\n        res_size = multilply(i, res, res_size)\n    wr(f'Factorial de {n} es: \\n')\n    for i in range(res_size-1, -1, -1):\n        wr(f'{res[i]}')\n\nfactorial(100)\n",
    "orden": 6,
    "suborden": 25,
    "fecha_creacion": "2020-12-04 22:01:06",
    "fecha_modificacion": "2020-12-06 20:23:12"
  },
  {
    "ID": 58,
    "supergrupo": "Matemática",
    "tema": "Numero de dígitos de un factorial",
    "texto": "Dado un entero n, encuentre el número de dígitos que aparecen en este factorial, donde factorial es definido como, factorial(n) =1*2*3*4……..*n y factorial (0) = 1…………\nUna solución ingenua puede ser calcular n! primero y luego calcular el número de dígitos presentes en el, sin embargo el valor de n! poder ser muy largo. Se vuelve algo complicado de almacenar esta variable (A menos que estés trabajando en Python).\nUna mejor solución puede ser usar las útiles propiedades de los logaritmos para calcular la respuesta.\nSabemos que:\n- log(a*b) = log(a) + log(b)\nPor lo tanto:\n- log ( n!) = log (1*2*3....... * n)     = log (1) + log (2) +........ +log(n)\nAhora, observamos que el valor piso del logaritmo base 10 incrementado 1 de cualquier número da el número de dígitos presentes en ese número.\nEntonces la salida puede ser: floor (log(n!)) + 1.",
    "complejidad_tiempo": "Mejor caso :    O(n)        Peor caso : O(n)      Promedio: O(n)         ",
    "java": "// Programa java que encuentra número de \n// digitos en un factorial\n\npublic class FactorialNumDigits {   // Retorna el número de digtos\n    // en n! \n\n    static int findDigits(int n) {   // Factorial existe solo para n>=0 \n        if (n < 0) {\n            return 0;\n        }\n        // Caso base\n        if (n <= 1) {\n            return 1;\n        }\n        // si no itera atravez de n y calcula el valor\n        double digits = 0;\n        for (int i = 2; i <= n; i++) {\n            digits += Math.log10(i);\n        }\n        return (int) (Math.floor(digits)) + 1;\n    }\n\n    public static void main(String[] args) {\n        System.out.println(findDigits(1));\n        System.out.println(findDigits(5));\n        System.out.println(findDigits(10));\n        System.out.println(findDigits(120));\n    }\n}",
    "cpp": "#include<bits/stdc++.h>\n#include<cstdlib>\nusing namespace std;\n\nint FindDigits(int n) {\n    if (n < 0) {\n        return 0;\n    }\n    if (n == 1) {\n        return 1;\n    }\n    double digits = 0;\n    for (int i = 2; i <= n; i++) {\n        digits += (std::log10(i));\n    }\n    return (int) (std::floor(digits)) + 1;\n}\n\nint main() {\n    cout << FindDigits(1000) << endl;\n    cout << FindDigits(5) << endl;\n    cout << FindDigits(20) << endl;\n    cout << FindDigits(100) << endl;\n}\n",
    "py": "import math\nfrom sys import stdout\nwr = stdout.write\n\ndef findDigits(n):\n    if n < 0:\n        return 0\n    if n <= 1:\n        return 1\n    digits = 0\n    for i in range(2, n+1):\n        digits += math.log10(i)\n    return int(math.floor(digits)+1)\n\nwr(f'{findDigits(1000000)}')\n",
    "orden": 6,
    "suborden": 26,
    "fecha_creacion": "2020-12-04 22:01:06",
    "fecha_modificacion": "2020-12-06 20:23:13"
  },
  {
    "ID": 59,
    "supergrupo": "Matemática",
    "tema": "Numero de dígitos de un factorial optimizado",
    "texto": "Si la solución anterior no es lo suficientemente rápida, podemos usar la fórmula de Kamenetsky para obtener la respuesta.\nSe aproxima al número de dígitos en una factorial con:\n- f(x) =    log10( ((n/e)^n) * sqrt(2*pi*n))\nAdemás podemos fácilmente usar las propiedades de los logaritmos para obtener:\n- f(x) = n* log10(( n/ e)) + log10(2*pi*n)/2 \nEsta solución puede manejar número muy grandes de entrada, que pueden caber en un entero de 32 bits, e incluso más que esto.\n",
    "complejidad_tiempo": "Mejor caso :    O(1)        Peor caso : O(1)      Promedio: O(1)         ",
    "java": "// Programa java que encuentra el número de digitos\n// en un factorial\n\npublic class FactorialNumDigitsOP {\n\n    public static double M_E = 2.71828182845904523536;\n    public static double M_PI = 3.141592654;\n\n    /* Funcion que retorna el número de digitos presente en \n    n! desde que el resultado sea muy largo*/\n    static long findDigits(int n) {\n\n        if (n < 0) {\n            return 0;\n        }\n\n        // caso base\n        if (n <= 1) {\n            return 1;\n        }\n        // Usamos la formula de Kamenestsky para\n        // calcular el número de digitos\n        double x = (n * Math.log10(n / M_E)\n                + Math.log10(2 * M_PI * n)\n                / 2.0);\n\n        return (long) Math.floor(x) + 1;\n    }\n\n    public static void main(String[] args) {\n        System.out.println(findDigits(1));\n        System.out.println(findDigits(50000000));\n        System.out.println(findDigits(1000000000));\n        System.out.println(findDigits(120));\n    }\n}\n",
    "cpp": "#include<bits/stdc++.h>\n#include<cstdlib>\nusing namespace std;\nconst double PI = 3.14159265358979323846;\nconst double E = 2.71828182845904523536;\n\nlong FindDigitsKame(int n) {\n    if (n < 0) {\n        return 0;\n    }\n    if (n <= 1) {\n        return 1;\n    }\n    double x = (n * log10(n / E)) + std::log10(2 * PI * n) / 2.0;\n    return (long) (std::floor(x)) + 1;\n}\n\nint main() {\n    cout << FindDigitsKame(1000000) << endl;\n}\n",
    "py": "import math\nfrom sys import stdout\nwr = stdout.write\n\ndef findDigits(n):\n    if n < 0:\n        return 0\n    if n <= 1:\n        return 1\n    x = (n * math.log10(n / math.e) + math.log10(2 * math.pi * n) / 2)\n    return int(math.floor(x) + 1)\n\nwr(f'{findDigits(10000)}')\n",
    "orden": 6,
    "suborden": 27,
    "fecha_creacion": "2020-12-04 22:01:06",
    "fecha_modificacion": "2020-12-06 20:23:13"
  },
  {
    "ID": 60,
    "supergrupo": "Matemática",
    "tema": "Teorema de Euclides-Euler",
    "texto": "De acuerdo con el teorema de Euclides-Euler, un número perfecto el cual es par, puede ser representado de la forma (2^n - 1)*(2^n / 2))) donde n es un número primo y 2^n – 1 es un número primo de Mersenne. Este es un producto de la potencia de 2 con un primo Mersenne, este teorema establece una conexión entre un número primo de Mersenne y un número par primo perfecto. Un número perfecto es aquél que es igual a la suma de sus divisores, exceptuando él mismo.\nAlgunos ejemplos de números perfectos los cuales satisfacen este teorema son:\n- 6, 28, 496, 8128, 33550336, 8589869056, 137438691328\nExplicación:\n-  6 es un número perfecto par.\nEntonces puede ser escrito de la forma \n- (2^2 - 1) * (2^ (2 - 1)) = 6\nDonde n =2 es un número primo y 2^n -1=3 es un número primo de Mersenne\nToma cada número primo y forma un primo de Mersenne con él. El primo de Mersenne = 2^n – 1 donde n es primo. Ahora se forma el número (2^n – 1)*(2^(n – 1)) y verificamos si es par y perfecto.\n",
    "complejidad_tiempo": "Mejor caso :    O(n)        Peor caso : O(n)      Promedio: O(n)         ",
    "java": "//Programa que verifica el teorema de Euclides Euler\n\nimport java.util.ArrayList;\n\npublic class EuclidEulerTheorem {\n    static ArrayList<Long> power2 = new ArrayList<Long>();\n    \n    public static void main(String[] args) {\n        //Almacenando potencias de 2 para acceder \n        // en tiempo O(1) \n        for (int i = 0; i < 62; i++) {\n            power2.add(0L);\n        }\n\n        for (int i = 0; i <= 60; i++) {\n            power2.set(i, (1L << i));\n        }\n        System.out.println(\"Generando los primeros números que satisfacen \"\n                + \"el teorema de Euclid Euler\\n\");\n        for (long i = 2; i <= 25; i++) {\n            long no = ((power2.get((int) i) - 1L) * (power2.get((int) (i - 1))));\n            if (isperfect(no) && (no % 2 == 0)) {\n                System.out.println(\"(2^\" + i + \" - 1) * (2^(\" + i + \" - 1)) = \" \n                        + no + \"\\n\");\n            }\n        }\n    }\n\n    static boolean isperfect(long n) // Números perfectos\n    {\n        /* Verifica si n es suma perfecta de dividores\n        excepto por el número en si mismo*/\n        long s = -n;\n        for (long i = 1; i * i <= n; i++) {\n            // es i un divisor de n\n            if (n % i == 0) {\n                long factor1 = i, factor2 = n / i;\n                s += factor1 + factor2;\n                // aqui i*i == n\n                if (factor1 == factor2) {\n                    s -= i;\n                }\n            }\n        }\n        return (n == s);\n    }\n\n    boolean isprime(long n) {\n        // Verifica cual número es primo o no\n        for (int i = 2; i * i <= n; i++) {\n            if (n % i == 0) {\n                return false;\n            }\n        }\n        return false;\n    }\n}\n",
    "cpp": "#include<bits/stdc++.h>\n#include<cstdlib>\n//---------------//\nusing namespace std;\ntypedef long long int ll;\nll power2[1000];\n\nbool isPerfect(ll n) {\n    ll s = -n;\n    for (ll i = 1; i * i <= n; i++) {\n        if (n % i == 0) {\n            ll factor1 = i, factor2 = n / i;\n            s += factor1 + factor2;\n            if (factor1 == factor2) {\n                s -= i;\n            }\n        }\n    }\n    return (n == s);\n}\n\nbool isPrime(ll n) {\n    for (ll i = 2; i * i <= n; i++) {\n        if (n % i == 0) {\n            return false;\n        }\n    }\n    return false;\n}\n\nint main() {\n    memset(power2, 0L, sizeof power2);\n    for (int i = 0; i < 62; i++) {\n        power2[i] = 0L;\n    }\n    for (int i = 0; i <= 60; i++) {\n        power2[i] = (1L << i);\n    }\n    cout << \"Generando los primeros numeros que satiscafacen el teorema\" << endl;\n    for (ll i = 2; i <= 25; i++) {\n        ll no = ((power2[(int) i] - 1L) * power2[(int) (i - 1)]);\n        if (isPerfect(no) && (no % 2 == 0)) {\n            cout << \"(2^\" << i << \" -1 * (2^(\" << i << \" -1)) = \" << no << endl;\n        }\n    }\n} \n",
    "py": null,
    "orden": 6,
    "suborden": 28,
    "fecha_creacion": "2020-12-04 22:01:06",
    "fecha_modificacion": "2020-12-06 20:23:14"
  },
  {
    "ID": 61,
    "supergrupo": "Matemática",
    "tema": "Algoritmo Euclidiano",
    "texto": "El MCD de dos números es el número más grande que divide ambos. Una forma simple de encontrar este número es factorizar ambos números y multiplicar los factores comunes.\nEl algoritmo se basa en lo siguiente:\n\n- Si resta el número más pequeño del más grande, MCD (GCD) no cambia, entonces si sigue restando repetidamente el más grande dos, termina con MCD.\n- Ahora en vez de restar, si divide el número más pequeño, el algoritmo termina cuando se encuentra residuo 0.\n",
    "complejidad_tiempo": "Mejor caso :    O(Log min(a, b))  Peor caso : O(Log min(a, b))      Promedio: O(Log min(a, b))         ",
    "java": "//Programa java que demuestra el algoritmo de Euclides  \n\npublic class EuclideanAlgorithm {\n    // Algoritmo de euclides extendido\n    public static int gcd(int a, int b) {\n        if (a == 0) {\n            return b;\n        }\n        return gcd(b % a, a);\n    }\n\n    public static void main(String[] args) {\n        int a = 10, b = 15, g;\n        g = gcd(a, b);\n        System.out.println(\"GCD(\" + a + \" , \" + b + \") = \" + g);\n        a = 35;\n        b = 10;\n        g = gcd(a, b);\n        System.out.println(\"GCD(\" + a + \" , \" + b + \") = \" + g);\n        a = 31;\n        b = 2;\n        g = gcd(a, b);\n        System.out.println(\"GCD(\" + a + \" , \" + b + \") = \" + g);\n    }\n}\n",
    "cpp": "#include<bits/stdc++.h>\n#include<cstdlib>\n//---------------//\nusing namespace std;\n\nint GCD(int a, int b) {\n    if (a == 0) {\n        return b;\n    }\n    return GCD(b % a, a);\n}\n\nint main() {\n    int a = 10;\n    int b = 15;\n    cout << \"GCD\" << \"(\" << a << \",\" << b << \")= \" << GCD(a, b) << endl;\n} \n",
    "py": null,
    "orden": 6,
    "suborden": 29,
    "fecha_creacion": "2020-12-04 22:01:06",
    "fecha_modificacion": "2020-12-06 20:23:15"
  },
  {
    "ID": 62,
    "supergrupo": "Matemática",
    "tema": "Euler Totient",
    "texto": "La función totient de Euler para una entrada n es un conteo de números desde 1 hasta n que son primos relativos con n, por ejemplo, los números cuyo GCD (Máximo común divisor) con n es 1. Se llama primos relativos (coprimos) a cualquier par de números enteros que no tienen ningún divisor en común, excepto el 1.\nEl criptosistema RSA es basado en este teorema.\n",
    "complejidad_tiempo": "Mejor caso :    O(n)  Peor caso : O(n)  Promedio: O(n) ",
    "java": "// Programa simple que calcula el valor \n// de la función  totient Euler\n\npublic class EulerTotient {\n    // Función que retorna gcd de a y b\n    static int gcd(int a, int b) {\n        if (a == 0) {\n            return b;\n        }\n        return gcd(b % a, a);\n    }\n        // Función que evalua función totient de euler\n    static int phi(int n) {\n        int result = 1;\n        for (int i = 2; i < n; i++) {\n            if (gcd(i, n) == 1) {\n                result++;\n            }\n        }\n        return result;\n    }\n\n    public static void main(String[] args) {\n        int n;\n        for (n = 1; n <= 10; n++) {\n            System.out.println(\"phi(\" + n + \") = \" + phi(n));\n        }\n    }\n}\n",
    "cpp": "#include<bits/stdc++.h>\n#include<cstdlib>\nusing namespace std;\nint gcd(int a,int b){\n    if(a==0){\n        return b;\n    }\n    return gcd(b%a,a);\n}\nint phi(int n){\n    int result=1;\n    for(int i=2;i<n;i++ ){\n        if(gcd(i,n)==1){\n            result++;\n        }\n    }\n    return result;\n}\nint main() {\n    for(int i=1;i<=10;i++){\n        printf(\"el phi (%d) = %d\\n\",i,phi(i));\n    }\n}\n",
    "py": "from sys import stdout\nwr = stdout.write\n\ndef gcd(a, b):\n    if a == 0:\n        return b\n    return gcd(b % a, a)\n\ndef phi(n):\n    result = 1\n    for i in range(2, n):\n        if gcd(i, n) == 1:\n            result += 1\n    return result\n\nfor i in range(1, 11):\n    wr(f'Phi ({i}) = {phi(i)}\\n')\n",
    "orden": 6,
    "suborden": 30,
    "fecha_creacion": "2020-12-04 22:01:06",
    "fecha_modificacion": "2020-12-06 20:23:15"
  },
  {
    "ID": 63,
    "supergrupo": "Matemática",
    "tema": "El pequeño teorema de Fermat",
    "texto": "El pequeño teorema de Fermat dice que si p es un número primo, entonces para cualquier entero a, el número de p-a es un entero múltiplo de p.\nAquí p es un número primo:\n- a^p = a (mod p).\nCaso especial: si a no es divisible por p, el pequeño teorema de Fermat es equivalente a la sentencia que un p-1-1 es un entero múltiplo de p.\n- a^p-1 = 1 (mod p)\nO\n- a^p-1 % p = 1  Aquí a no es divisible por p.\nUsos del pequeño teorema de Fermat\nSi sabemos que m es primo, entones se puede también usar el pequeño teorema de Fermat para buscar la inversa:\n- a^m-1 = 1 (mod m)\nSi nosotros multiplicamos ambos saldos con a-1, obtenemos:\n- a^-1 = a m-2 (mod m)\n",
    "complejidad_tiempo": "Mejor caso :    O(n)  Peor caso : O(n)  Promedio: O(n) ",
    "java": "/*Programa de Java para encontrar modular.\n inverso de un módulo bajo m\n utilizando el pequeño teorema de Fermat.\n Este programa funciona solo si m es primo.*/\npublic class FermatLittleTheorem {\n\n    static int __gcd(int a, int b) {\n        if (b == 0) {\n            return a;\n        } else {\n            return __gcd(b, a % b);\n        }\n    }\n    // Computa x^y bajo modulo m\n\n    static int power(int x, int y, int m) {\n        if (y == 0) {\n            return 1;\n        }\n        int p = power(x, y / 2, m) % m;\n        p = (p * p) % m;\n        return (y % 2 == 0) ? p : (x * p) % m;\n    }\n    // Función para encontrar modular\n    // inverso bajo un modulo m\n    // Asumimos m es primo\n\n    static void modInverse(int a, int m) {\n        if (__gcd(a, m) != 1) {\n            System.out.print(\"No existe inverso\");\n        } else {\n            // Si a y m son primos relativos, entonces\n            // modulo inverso es a^(m-2) mod m \n            System.out.print(\"Multiplicación modular inversa es \"\n                    + power(a, m - 2, m));\n        }\n    }\n\n    public static void main(String[] args) {\n        int a = 3, m = 11;\n        modInverse(a, m);\n    }\n} \n",
    "cpp": null,
    "py": null,
    "orden": 6,
    "suborden": 31,
    "fecha_creacion": "2020-12-04 22:01:06",
    "fecha_modificacion": "2020-12-06 20:23:16"
  },
  {
    "ID": 64,
    "supergrupo": "Matemática",
    "tema": "Producto de fracciones",
    "texto": "Dados el numerador y el denominador de N fracciones, la tarea es encontrar el producto de N fracciones e imprimir la respuesta en forma reducida.\nLa idea es encontrar el producto de numeradores en una variable, como new_num, ahora encontrar el producto de los denominadores en otra variable como new_den. \nAhora para encontrar la respuesta en forma reducida, encuentre el GCD de new_num y new_den y dividir el new_num y new_den por el GCD calculado.\nLa solución causa desbordamiento para números grandes, podemos evadir esto si encontramos los factores primos de todos los numeradores y denominadores, una vez hayamos encontrado los factores, podemos cancelar los factores primos comunes.\nCuando se solicita representar la respuesta de la forma {P \\veces {Q} ^ {-1}}. Primero convierta el numerador  y el denominador en forma reducible de P/Q. luego busque el multiplicativo inverso de Q con respecto a un número primo m (Generalmente 10^9 + 7) el cual es dado como pregunta, luego de encontrar el multiplicativo inverso de Q, multiplicarlo con P y tomar el modulo con el número primo m,  el cual nos da nuestra salida requerida.\n",
    "complejidad_tiempo": "Mejor caso :    O(n)  Peor caso : O(n)  Promedio: O(n) ",
    "java": "//Programa java que encuentra el producto\n// de N fracciones en forma reducida\n\npublic class Fractionsproduct {\n    // Función que retorna el gcd de a y b\n    static int gcd(int a, int b) {\n        if (a == 0) {\n            return b;\n        }\n        return gcd(b % a, a);\n    }\n\n    static void productReduce(int n, int num[],\n            int den[]) {\n        int new_num = 1, new_den = 1;\n        //Encontrando el producto de todos los N\n        // numeradores y denominadores\n        for (int i = 0; i < n; i++) {\n            new_num *= num[i];\n            new_den *= den[i];\n        }\n        // Encontrando GCD de nuevo numerados y denominador \n        int GCD = gcd(new_num, new_den);\n        // Convirtiendo en forma reducids\n        new_num /= GCD;\n        new_den /= GCD;\n        System.out.println(new_num + \"/\" + new_den);\n    }\n\n    public static void main(String[] args) {\n        int n = 3;\n        int num[] = {1, 2, 5};\n        int den[] = {2, 1, 6};\n        productReduce(n, num, den);\n    }\n}\n",
    "cpp": "#include<bits/stdc++.h>\n#include<cstdlib>\n//---------------//\nusing namespace std;\nint GCD(int a,int b){\n    if(a==0){\n        return b;\n    }\n    return GCD(b%a,a);\n}\nvoid productReduce(int n,int num[],int den[]){\n    int new_num=1,new_den=1;\n    for(int i=0;i<n;i++){\n        new_num*=num[i];\n        new_den*=den[i];\n    }\n    int gcd = GCD(new_num,new_den);\n    new_num/=gcd;\n    new_den/=gcd;\n    cout<<new_num<<\"/\"<<new_den<<endl;\n}\nint main() {\n    int n=3;\n    int num[]={1,2,5};\n    int den[]={2,1,6};\n    productReduce(n,num,den);\n} \n",
    "py": null,
    "orden": 6,
    "suborden": 32,
    "fecha_creacion": "2020-12-04 22:01:06",
    "fecha_modificacion": "2020-12-06 20:23:17"
  },
  {
    "ID": 65,
    "supergrupo": "Matemática",
    "tema": "Josephus",
    "texto": "En las ciencias de la computación y las matemáticas, el problema Josephus (O permutación Josephus) es un problema teorético el cual su enunciado es el siguiente.\nHay n personas sentadas en círculo, esperando a ser ejecutadas. El conteo empieza en el mismo punto en el círculo y procede alrededor del círculo en dirección horaria, en cada paso un cierto número de personas son saltadas y la siguiente persona es ejecutada. La eliminación se realiza alrededor del circulo (el comienza a ser más pequeño y pequeño mientras la gente es ejecutada y removida), hasta que solo quede una persona, a quien se le dará la libertad. Dado el total de personas n y un número k que indica que k-1 personas serán saltadas y la kesima persona es asesinada en el círculo, la tarea es escoger el lugar en el círculo inicial de tal forma que sea la posición de la última persona que sobreviva.\nPor ejemplo, si n =5 y k = 2, entonces la posición segura es 3.  (1,2,3,4,5 y la posición inicial es 5). Primeramente la persona en la posición 2 es asesinada, luego la persona en la posición 4 es asesinada, luego la persona en la posición 1 es asesinada, finalmente la persona en la posición 5 es asesinada dejando a la persona en la 4 posición viva y con capacidad de disfrutar su libertad.\nSi n=7 y k=3, entonces la posición segura es 4, las personas en las posiciones 3,6,2,7,5,1 son asesinadas en ese orden y la 4 sobrevive. \n",
    "complejidad_tiempo": "Mejor caso :    O(n)  Peor caso : O(n)  Promedio: O(n) ",
    "java": "//Implementación java de dos Algoritmos que realizan la\n// busqueda josephus sabiendo número personas y tamaño\n// de salto\n\npublic class Josephus {\n\n    public static void main(String[] args) {\n        System.out.println(josephus(6, 2));\n        System.out.println(josephusModular(6, 2));\n    }\n    //Busqueda por algoritmo voraz\n    static int josephus(int n, int k) {\n        int d[] = new int[n + 1];\n        d[0] = -1;\n        for (int i = 1; i <= n; i++) {\n            d[i] = i;\n        }\n        int i = n;\n        int a = 0;\n        while (i != 1) {\n            i--;\n            a = next(a, k, d);\n            d[a] = -1;\n            a++;\n        }\n        for (i = 0; d[i] == -1; i++);\n        return d[i];\n    }\n    //Calcule la posición siguiente a caer \n    static int next(int a, int k, int[] d) {\n        int j = a - 1;\n        for (int i = 0; i < k;) {\n            j = (j + 1) % d.length;\n            if (d[j] != -1) {\n                i++;\n            }\n        }\n        return j;\n    }\n    //busqueda por matematica modular\n    static int josephusModular(int n, int k) {\n        int f = 0;\n        for (int i = 1; i <= n; i++) {\n            f = (f + k) % i;\n\n        }\n        return f + 1;\n    }\n}\n",
    "cpp": "#include<bits/stdc++.h>\n#include<cstdlib>\n//---------------//\nusing namespace std;\nint next(int a, int k, int d[], int n){\n    int j = a - 1;\n    for(int i = 0; i < k;){\n        j = (j + 1) % n;\n        if(d[j] != -1){\n            i++;\n        }\n    }\n    cout<<\"next: \"<<j<<endl;\n    return j;\n}\nint josephus(int n, int k){\n    int d[n + 1];\n    d[0] = -1;\n    for(int i = 1; i <= n; i++){\n        d[i] = i;\n    }\n    int indice = n;\n    int a = 0;\n    while(indice != 1){\n        indice--;\n        a = next(a, k, d, n + 1);\n        d[a] = -1;\n        a++;\n    }\n    for(indice = 0; d[indice] == -1; indice++);\n        return d[indice];\n}\nint main(){\n    cout<<josephus(10, 3)<<endl;\n    return 0;\n}\n\n",
    "py": "from sys import stdout\nwr = stdout.write\n\ndef next_(a, k, d):\n    j = a - 1\n    i = 0\n    while i < k:\n        j = (j+1) % len(d)\n        if d[j] != -1:\n            i += 1\n    wr(f'Next = {j}\\n')\n    return j\n\ndef josephus(n, k):\n    d = [-1 for x in range(n+1)]\n    d[0] = -1\n    for i in range(1, n+1):\n        d[i] = i\n    i = n\n    a = 0\n    while i != 1:\n        i -= 1\n        a = next_(a, k, d)\n        d[a] = -1\n        a += 1\n    i = 0\n    while d[i] == -1:\n        i += 1\n    return d[i]\n\ndef josephusModular(n, k):\n    f = 0\n    for i in range(1, n+1):\n        f = (f+k) % i\n    return f + 1\n\nwr(f'{josephusModular(6,2)}\\n')\nwr(f'{josephus(6,2)}')\n",
    "orden": 6,
    "suborden": 33,
    "fecha_creacion": "2020-12-04 22:01:06",
    "fecha_modificacion": "2020-12-06 20:23:17"
  },
  {
    "ID": 66,
    "supergrupo": "Matemática",
    "tema": "Números de la forma Cardinal/Ordinal",
    "texto": "Cuando usamos los números naturales para contar los elementos de un determinado conjunto los llamamos números cardinales.  \nEn muchas ocasiones es necesario dar un orden a las cosas: las posiciones finales de una carrera o los pisos de un edificio son algunos ejemplos.  Cuando se usan los números naturales para este ordenar los llamamos ordinales.\nPara representar los números ordinales se usan los números naturales acompañados por una pequeña letra así: 1°a, 2°o  etc.  Cuando acompañamos el número por la letra a es para femenino, y con la letra o es para masculino.  Así, si queremos decir que Anita es la número uno de la clase decimos que es la primera: 1°a; y si queremos decir que Pablo ocupó el lugar número uno en la carrera decimos que fue el primero: 1°o\n",
    "complejidad_tiempo": "Mejor caso :    O(n)  Peor caso : O(n)  Promedio: O(n) ",
    "java": "//Programa java que convierte números ordinales\n// en números cardinales en ingles\n\npublic class CardinalNumbers {\n\n    public static void main(String[] args) {\n        for (int i = 1; i <= 10; i++) {\n            System.out.println(i + cardinalNumber(i));\n        }\n    }\n\n    static String cardinalNumber(int n) {\n        if (n % 10 == 1 && n % 100 != 11) {\n            return \"st\";\n        }\n        if (n % 10 == 2 && n % 100 != 12) {\n            return \"nd\";\n        }\n        if (n % 10 == 3 && n % 100 != 13) {\n            return \"rd\";\n        }\n        return \"th\";\n    }\n}\n",
    "cpp": "#include<bits/stdc++.h>\n#include<cstdlib>\n//---------------//\nusing namespace std;\nstring cardinalNumber(int n){\n    if(n%10==1 && n%100!=11){\n        return \"st\";\n    }if(n%10==2 && n%100!=12){\n        return \"nt\";\n    }if(n%10==3 && n%100!=13){\n        return \"st\";\n    }\n    return \"th\";\n}\nint main(){\n    for(int i=1;i<=10;i++){\n        cout<<i<<\" : \"<<cardinalNumber(i)<<endl;\n    }\n} \n",
    "py": null,
    "orden": 6,
    "suborden": 34,
    "fecha_creacion": "2020-12-04 22:01:06",
    "fecha_modificacion": "2020-12-06 20:23:18"
  },
  {
    "ID": 67,
    "supergrupo": "Matemática",
    "tema": "12.35) Números Romanos",
    "texto": "La numeración romana es un sistema de numeración que se desarrolló en la Antigua Roma y se utilizó en todo el Imperio romano, manteniéndose con posterioridad a su desaparición y todavía utilizado en algunos ámbitos.\n\nEste sistema emplea algunas letras mayúsculas como símbolos para representar ciertos valores. Los números se escriben como combinaciones de letras. Por ejemplo, el año 2019 se escribe como MMXIX, donde cada M representa 1000 unidades, la X representa 10 unidades más y IX representa 9 unidades más (al ser X, que representa el 10, precedido por I, que representa el 1).\n",
    "complejidad_tiempo": "Mejor caso :    O(n)  Peor caso : O(n)  Promedio: O(n) ",
    "java": "//Implementación java que convierte números decimales\n// a números romanos y viceversa usando matematica modular\n\npublic class RomanNumbers {\n    // Arrays constantes de letras romanas\n    static String unit[] = {\"\", \"I\", \"II\", \"III\", \"IV\", \"V\", \"VI\", \"VII\", \"VIII\", \"IX\"};\n    static String ten[] = {\"\", \"X\", \"XX\", \"XXX\", \"XL\", \"L\", \"LX\", \"LXX\", \"LXXX\", \"XC\"};\n    static String hnd[] = {\"\", \"C\", \"CC\", \"CCC\", \"CD\", \"D\", \"DC\", \"DCC\", \"DCCC\", \"CM\"};\n\n    public static void main(String[] args) {\n        System.out.println(toRoman(122));\n        System.out.println(toDecimal(\"CXXII\"));\n    }\n    //Función que convierte a romano\n\n    static String toRoman(int n) {\n        //Los números romanos no tienen letras\n        //más alla de los miles\n        int a;\n        StringBuilder sb = new StringBuilder();\n        if (n >= 1000) {\n            a = n / 1000;\n            for (int i = 1; i <= a; i++) {\n                sb.append(\"M\");\n            }\n            n %= 1000;\n        }\n        //Letras de las centenas\n        sb.append(hnd[n / 100]);\n        n = n % 100;\n        //Letras de las decenas\n        sb.append(ten[n / 10]);\n        //Letras de las unidades\n        sb.append(unit[n % 10]);\n        return sb.toString();\n    }\n    //Devuelve el valor de cada letra\n\n    static int valor(char ch) {\n        switch (ch) {\n            case 'I':\n                return 1;\n            case 'V':\n                return 5;\n            case 'X':\n                return 10;\n            case 'L':\n                return 50;\n            case 'C':\n                return 100;\n            case 'D':\n                return 500;\n            case 'M':\n                return 1000;\n        }\n        return 0;\n    }\n    //Función que convierte a decimal\n\n    static int toDecimal(String num) {\n        int sum = 0;\n        int last = 0;\n        int next;\n        //Toma cada letra y verifica si esta antes o despues \n        // suma si esta despues, resta si esta antes\n        for (int i = num.length() - 1; i >= 0; i--) {\n            next = valor(num.charAt(i));\n            if (last <= next) {\n                sum += next;\n            } else {\n                sum -= next;\n            }\n            last = next;\n        }\n        return sum;\n    }\n}\n",
    "cpp": "#include<bits/stdc++.h>\n#include<cstdlib>\n//---------------//\nusing namespace std;\nstring unit[]={\"\",\"I\",\"II\",\"III\",\"IV\",\"V\",\"VI\",\"VII\",\"VIII\",\"IX\"};\nstring ten[]={\"\",\"X\",\"XX\",\"XXX\",\"XL\",\"L\",\"LX\",\"LXX\",\"LXXX\",\"XC\"};\nstring hnd[]={\"\",\"C\",\"CC\",\"CCC\",\"CD\",\"D\",\"DC\",\"DCC\",\"DCCC\",\"CM\"};\nint valor(char ch){\n    switch(ch){\n    case 'I':\n        return 1;\n    case 'V':\n        return 5;\n    case 'X':\n        return 10;\n    case 'L':\n        return 50;\n    case 'C':\n        return 100;\n    case 'D':\n        return 500;\n    case 'M':\n        return 1000;\n    }\n    return 0;\n}\nstring toRoman(int n){\n    int a;\n    string sb=\"\";\n    if(n>=1000){\n        a = n/1000;\n        for(int i=1;i<=a;i++){\n            sb+=\"M\";\n        }\n        n%=1000;\n    }\n    sb+=(hnd[n/100]);\n    n%=100;\n    sb+=(ten[n/10]);\n    sb+=(unit[n%10]);\n    return sb;\n}\nint toDecimal(string num){\n    int sum=0;\n    int last=0;\n    int next;\n    for(int i=num.size()-1;i>=0;i--){\n        next=valor(num[i]);\n        if(last<=next){\n            sum+=next;\n        }else{\n            sum-=next;\n        }\n        last=next;\n    }\n    return sum;\n}\nint main(){\n    cout<<toRoman(122)<<endl;\n    cout<<toRoman(1)<<endl;\n    cout<<toRoman(2323)<<endl;\n    cout<<toRoman(343)<<endl;\n\n    cout<<toDecimal(\"CXXII\")<<endl;\n    cout<<toDecimal(\"I\")<<endl;\n    cout<<toDecimal(\"MMCCCXXIII\")<<endl;\n    cout<<toDecimal(\"CCCXLIII\")<<endl;\n} \n",
    "py": null,
    "orden": 6,
    "suborden": 35,
    "fecha_creacion": "2020-12-04 22:01:06",
    "fecha_modificacion": "2020-12-06 20:23:18"
  },
  {
    "ID": 68,
    "supergrupo": "Matemática",
    "tema": "Teorema de Hardy-Ramanujan ",
    "texto": "El teorema de Hardy Ramanujan propone que el número de factores de n debe ser aproximadamente log(log(n)) para la mayoría de números naturales n.\n- 5192 tiene 2 factores primos distintos y log(log(5192)) = 2.1615\n- 51242183 tiene 3 factores primos distintos y log(log(51242183)) = 2.8765\nEste teorema es principalmente usado en algoritmos de aproximación y es prueba líder para conceptos más grandes de teoría de la probabilidad \n",
    "complejidad_tiempo": "Mejor caso :    O(vn)  Peor caso : O(vn)  Promedio: O(vn) ",
    "java": "// Programa java que cuenta todos los \n// factores primos\n\npublic class HardyRamanujanTheorem {\n    // Una función que cuenta factores primos de \n    //un número n\n    static int exactPrimeFactorCount(int n) {\n        int count = 0;\n        if (n % 2 == 0) {\n            count++;\n            while (n % 2 == 0) {\n                n = n / 2;\n            }\n        }\n        // n debe ser impar en este punto, asi \n        //podemos saltar un elemento (i=i+2)\n        for (int i = 3; i <= Math.sqrt(n); i = i + 2) {\n            if (n % i == 0) {\n                count++;\n                while (n % i == 0) {\n                    n = n / i;\n                }\n            }\n        }\n        // Esta condición es para controlar el caso\n        // cuando n es un factor primo más grande que 2\n        if (n > 2) {\n            count++;\n        }\n        return count;\n    }\n\n    public static void main(String[] args) {\n        int n = 51242183;\n        System.out.println(\"El número de diferentes \"\n                + \" factores primos es \"\n                + exactPrimeFactorCount(n));\n        System.out.println(\"El valor de (log(n))\"\n                + \" es \" + Math.log(Math.log(n)));\n    }\n}\n",
    "cpp": "#include<bits/stdc++.h>\n#include<cstdlib>\n//---------------//\nusing namespace std;\nint exactPrimeFactorCount(int n){\n    int cont=0;\n    if(n%2==0){\n        cont++;\n        while(n%2==0){\n            n/=2;\n        }\n    }\n    for(int i=3;i<=(sqrt(n));i+=2){\n        if(n%i==0){\n            cont++;\n            while(n%i==0){\n                n/=i;\n            }\n        }\n    }\n    if(n>2){\n        cont++;\n    }\n    return cont;\n}\nint main(){\n    int n=51242183;\n    cout<<\"El numero de diferentes factores primos es \"<<exactPrimeFactorCount(n)<<endl;\n    cout<<\"EL valor de (log(n)) es \"<<log(log(n))<<endl;\n} \n",
    "py": null,
    "orden": 6,
    "suborden": 36,
    "fecha_creacion": "2020-12-04 22:01:06",
    "fecha_modificacion": "2020-12-06 20:23:19"
  },
  {
    "ID": 69,
    "supergrupo": "Matemática",
    "tema": "Hoax Number",
    "texto": "Dado un número n, verificar si es un número falso o no.\nUn número falso es definido como un número compuesto, cuya suma de dígitos es igual a la suma de dígitos de sus distintos factores primos, 1 no es considerado un número primo, entonces no es incluido en la suma de dígitos de los distintos factores primos.\nLa definición de un número falso está cerca de la de la definición de un número de Smith, algunos de los números falsos son también números de Smith, es aparente que estos números falsos no tienen factores repetidos en su descomposición de primos.\nImplementación\n1) Primero se generan todos los distintos factores primos del número n.\n2) Si el n no es un número primo, encuentre la suma de dígitos de los factores obtenidos en el paso 1\n3) Encuentre la suma de dígitos de n\n4) Verifique si la suma obtenida en  2 y 3 son iguales o no.\n5) Si las sumas son iguales, entonces n es un número falso.\n",
    "complejidad_tiempo": "Mejor caso :    O(vn)  Peor caso : O(vn)  Promedio: O(vn) ",
    "java": "// Programa java que verifica si un número es \n// falso o no\n\nimport java.util.*;\n\npublic class HoaxNumber {\n\n    /*Función que encuentra distintos factores primos\n    dado un número n*/\n    static List<Integer> primeFactors(int n) {\n        List<Integer> res = new ArrayList<>();\n        if (n % 2 == 0) {\n            while (n % 2 == 0) {\n                n = n / 2;\n            }\n            res.add(2);\n        }\n        /*N es impar en este punto\n        desde que ya no sea divisible por 2\n        entonces podemos probar solamente\n        por números impares, mientras sean \n        factores de n*/\n        for (int i = 3; i <= Math.sqrt(n);\n                i = i + 2) {\n            //Verifica si i es factor primo\n            if (n % i == 0) {\n                while (n % i == 0) {\n                    n = n / i;\n                }\n                res.add(i);\n            }\n        }\n        /*Esra condición es para controlar\n        el caso cuando n es un número primo\n        más grande que 2*/\n        if (n > 2) {\n            res.add(n);\n        }\n        return res;\n    }\n\n    /*Función que calcula suma de digitos de distintos\n    factores primos de dado n y la suma de digitos\n    de número n. compara las sumás obtenidas*/\n    static boolean isHoax(int n) {\n        /*Distintos factores primos de n seran almacenados\n        en vector pf*/\n        List<Integer> pf = primeFactors(n);\n        /* Si n es un número primo\n        no puede ser un número falso*/\n        if (pf.get(0) == n) {\n            return false;\n        }\n        /*Encontrando suma de digitos de \n        distintos factores primos de n*/\n        int all_pf_sum = 0;\n        for (int i = 0; i < pf.size(); i++) {\n            // Encontramos la suma de digitos de \n            // el actual factor primo pf[i] \n            int pf_sum;\n            for (pf_sum = 0; pf.get(i) > 0;\n                    pf_sum += pf.get(i) % 10, pf.set(i, pf.get(i) / 10));\n\n            all_pf_sum += pf_sum;\n        }\n        // Encontrando suma de digitos de n\n        int sum_n;\n        for (sum_n = 0; n > 0; sum_n += n % 10, n /= 10);\n        // Comparando las dos sumás calculadas\n        return sum_n == all_pf_sum;\n    }\n\n    public static void main(String args[]) {\n        int n = 84;\n        if (isHoax(n)) {\n            System.out.print(\"Un número falso\\n\");\n        } else {\n            System.out.print(\"No es número falso\\n\");\n        }\n    }\n} \n\n",
    "cpp": null,
    "py": null,
    "orden": 6,
    "suborden": 37,
    "fecha_creacion": "2020-12-04 22:01:06",
    "fecha_modificacion": "2020-12-06 20:23:20"
  },
  {
    "ID": 70,
    "supergrupo": "Matemática",
    "tema": "Potencia más grande que divide un factorial",
    "texto": "Dados dos números, fact y n, encuentre la potencia más grande de n que divide fact! (Factorial de fact).\nLa idea es basada en la fórmula de Legendre la cual encuentra la potencia más grande de un número primo que divide fact!. Encontramos todos los factores primos de n. para cada factor primo encontramos la potencia más grande que divide fact! y finalmente retornamos el mínimo de todas las potencias encontradas.\nSi hay múltiples potencias de un factor primo presentes en n, entonces se divide el conteo para obtener el valor de la máxima potencia de este factor.\n",
    "complejidad_tiempo": "Mejor caso :    O(vn)  Peor caso : O(vn)  Promedio: O(vn) ",
    "java": "/* Programa java que encuentra la potencia más larga de\nun número (La cual puede ser compuesta) que divide \nfactorial*/\npublic class LargestPowDividesFactorial {\n\n    /* For que encuentra la maxima potencia de número primo\n    p que puede dividir un número facorial*/\n    static int findPowerPrime(int fact, int p) {\n        int res = 0;\n        while (fact > 0) {\n            res += fact / p;\n            fact /= p;\n        }\n\n        return res;\n    }\n\n    // Retorna la suma de todos los factores de n\n    static int findPowerComposite(int fact, int n) {\n        // Para almacernar el resultado ( Potencia minima de un \n        // factor primo que divide fact)\n        int res = Integer.MAX_VALUE;\n        // Atravesar atraves de todos los factores\n        // primos de n\n        for (int i = 2; i <= Math.sqrt(n); i++) {\n            // contador para contar la potencia del número primo\n            int count = 0;\n            if (n % i == 0) {\n                count++;\n                n = n / i;\n            }\n            if (count > 0) {\n                // Maxima potencia de i que divide \n                // fact, dividimos por count para \n                // manejar multiples ocurrencias de \n                // un factor primo\n                int curr_pow = findPowerPrime(fact, i) / count;\n                res = Math.min(res, curr_pow);\n            }\n        }\n        // Esta condición es para manejar \n        // el caso cuando n es un número primo mayor \n        // que 2\n        if (n >= 2) {\n            int curr_pow = findPowerPrime(fact, n);\n            res = Math.min(res, curr_pow);\n        }\n        return res;\n    }\n\n    public static void main(String[] args) {\n        int fact = 146, n = 5;\n        System.out.println(findPowerComposite(fact, n));\n    }\n} \n",
    "cpp": null,
    "py": null,
    "orden": 6,
    "suborden": 38,
    "fecha_creacion": "2020-12-04 22:01:06",
    "fecha_modificacion": "2020-12-06 20:23:20"
  },
  {
    "ID": 71,
    "supergrupo": "Matemática",
    "tema": "Exponenciación modular",
    "texto": "Dados tres números x, y y p, calcule (x^y) % p.\nBajo esta propiedad fundamental modular  que es usada para computación eficiente, calcular la potencia usando matemática modular.\n-  (ab) mod p = ( (a mod p) (b mod p) ) mod p \nPor ejemplo  a = 50,  b = 100, p = 13\n- 50  mod 13  = 11\n- 100 mod 13  = 9\n- (50 * 100) mod 13 = ( (50 mod 13) * (100 mod 13) ) mod 13 \n- or (5000) mod 13 = ( 11 * 9 ) mod 13\n- or 8 = 8\n",
    "complejidad_tiempo": "Mejor caso :    O(log n)  Peor caso : O(log n)  Promedio: O(log n) ",
    "java": "// Programa iteratico que calcula \n// potencia modular \n\npublic class ModularExponentiation {\n\n    /* Función iterativa que calcula\n       (x^y)%p in O(log y) */\n    static int power(int x, int y, int p) {\n        // Inicializar resultado\n        int res = 1;\n        // Actualiza x si es más que    \n        // o igual a p \n        x = x % p;\n        while (y > 0) {   //Si y es impar, multiplica x con res\n            if ((y & 1) == 1) {\n                res = (res * x) % p;\n            }\n            // y debe ser par ahora\n            // y = y / 2 \n            y = y >> 1;\n            x = (x * x) % p;\n        }\n        return res;\n    }\n\n    public static void main(String args[]) {\n        int x = 2;\n        int y = 5;\n        int p = 13;\n        System.out.println(\"La potencia es \" + power(x, y, p));\n    }\n} \n",
    "cpp": null,
    "py": null,
    "orden": 6,
    "suborden": 39,
    "fecha_creacion": "2020-12-04 22:01:06",
    "fecha_modificacion": "2020-12-06 20:23:21"
  },
  {
    "ID": 72,
    "supergrupo": "Matemática",
    "tema": "Multiple Euler Totient",
    "texto": "Función Totient de Euler de una entrada n es el conteo de números  en {1,2,3,..., n} que sea primo relativo a n, por ejemplo, los números los cuales su GCD con n es 1. \nEn problemas donde tenemos que llamar a la función totient muchas veces como 10^5 veces, una solución simple puede retornar un TLE (time limit exceded). La idea es usar la criba de Eratóstenes.\nEncuentre todos los factores primos con limite en 10^5 usando la criba de Eratóstenes.\nPara realizar este F(n), se hace lo siguiente.\n1) Inicializa el resultado como n.\n2) Itera a través de todos los primos más pequeños o iguales que la raíz cuadrada de n. Dejamos que el actual número primo sea p, revisamos si p divide n, si lo hace, removemos todas las ocurrencias de p de n dividiéndolo repetidamente por n, también reducimos nuestro resultado por n/p.\n3) Finalmente retornamos nuestro resultado.\n",
    "complejidad_tiempo": "Mejor caso :    O(n2)  Peor caso : O(n2)  Promedio: O(n2) ",
    "java": "// Programa java que eficientemente calcula valores de\n// la formula totient de euler para multiples entradas\n\nimport java.util.*;\n\npublic class MultipleEulerTotient {\n\n    static int MAX = 100001;\n    // Almacena números primos arriba hasta MAX -1\n    static ArrayList<Integer> p = new ArrayList<Integer>();\n    // Encurntra los números primos hasta MAX-1 Y\n    // los almacena en p\n\n    static void sieve() {\n        int[] isPrime = new int[MAX + 1];\n        for (int i = 2; i <= MAX; i++) {\n            // Si prime[i] no es marcado antes\n            if (isPrime[i] == 0) {\n                // Llena el vector para cada nuevo\n                // primo encontrado\n                p.add(i);\n                for (int j = 2; i * j <= MAX; j++) {\n                    isPrime[i * j] = 1;\n                }\n            }\n        }\n    }\n    // Función que encuentra totient de n\n\n    static int phi(int n) {\n        int res = n;\n        // Este ciclo corre sqrt(n / ln(n)) veces\n        for (int i = 0; p.get(i) * p.get(i) <= n; i++) {\n            if (n % p.get(i) == 0) {\n                // resta multiplos de p[i] de r\n                res -= (res / p.get(i));\n                // Remueve todas las ocurrencias de p[i] en n\n                while (n % p.get(i) == 0) {\n                    n /= p.get(i);\n                }\n            }\n        }\n        // cuando n es un factor primo mayor \n        // que sqrt(n) \n        if (n > 1) {\n            res -= (res / n);\n        }\n        return res;\n    }\n\n    public static void main(String[] args) {\n        //Preprocesa todos los primos hasta 10 ^ 5  \n        sieve();\n        System.out.println(phi(11));\n        System.out.println(phi(21));\n        System.out.println(phi(31));\n        System.out.println(phi(41));\n        System.out.println(phi(51));\n        System.out.println(phi(61));\n        System.out.println(phi(91));\n        System.out.println(phi(101));\n    }\n} \n",
    "cpp": null,
    "py": null,
    "orden": 6,
    "suborden": 40,
    "fecha_creacion": "2020-12-04 22:01:06",
    "fecha_modificacion": "2020-12-06 20:23:22"
  },
  {
    "ID": 73,
    "supergrupo": "Matemática",
    "tema": "12.41) Sumatoria de naturales coprimos",
    "texto": "Dado N y M, la tarea es encontrar cuales números de 1 a n pueden ser divididos en dos conjuntos los cuales su diferencia absoluta entre la suma de los dos sets es M y el GCD de la suma de los dos sets es 1.\nDesde que tenemos 1 a N números, sabemos que la suma de todos los números es N*(N+1)/2. Dejamos S1 y S2 de esta manera:\n1) sum(S1) + sum(S2) = N * (N + 1) / 2\n2) sum(S1) – sum(S2) = M\nResolviendo estas dos ecuaciones podemos dar la suma de ambos conjuntos. Si sum(S1) y sum(S2)  son enteros  y ellos son coprimos (Su GCD es 1), entonces ahí existe una forma de separar el número en dos sets. De otra forma no hay forma de separar esos números N.\n",
    "complejidad_tiempo": "Mejor caso :    O(log(n))  Peor caso : O(log(n))  Promedio: O(log(n)) ",
    "java": "/* Código de Java para determinar si los números\n1 a N se puede dividir en dos conjuntos\ntal que la diferencia absoluta entre\nla suma de estos dos conjuntos es M y estos\ndos sumás son co-primos*/\npublic class NaturalCoprimeSum {\n\n    static int GCD(int a, int b) {\n        return b == 0 ? a : GCD(b, a % b);\n    }\n\n    /*función que devuelve valor booleano\n     sobre la base de si es posible\n     dividir 1 a N números en dos conjuntos\n     Que satisfacen las condiciones dadas.*/\n    static boolean isSplittable(int n, int m) {\n        // Inicializando suma total de 1\n        //a n \n        int total_sum = (n * (n + 1)) / 2;\n        /*desde (1) total_sum = sum_s1 + sum_s2 \n        y (2) m = sum_s1 - sum_s2 asumiendo \n        sum_s1> sum_s2. resolviendo estas 2 \n        ecuaciones para obtener sum_s1 y sum_s2*/\n        int sum_s1 = (total_sum + m) / 2;\n        // total_sum = sum_s1 + sum_s2 \n        // y asi \n        int sum_s2 = total_sum - sum_s1;\n        /*Si la suma total es menor que la \n        diferencia absoluta, no hay forma \n        de que podamos dividir n números \n        en dos conjuntos, así que devuelva falso*/\n        if (total_sum < m) {\n            return false;\n        }\n        /*Compruebe si estas dos sumás son\n        enteros y se suman a\n        suma total y también si su\n        La diferencia absoluta es m.*/\n        if (sum_s1 + sum_s2 == total_sum\n                && sum_s1 - sum_s2 == m) // Ahora si las dos sumás son coprimos\n        // Entonces retorna true, si no false\n        {\n            return (GCD(sum_s1, sum_s2) == 1);\n        }\n        /*si dos sumás no suman la suma total\n          o si su diferencia absoluta.\n         no es m, entonces no hay manera de\n         dividir n números, por lo tanto retorna false*/\n        return false;\n    }\n\n    public static void main(String args[]) {\n        int n = 5, m = 7;\n        if (isSplittable(n, m)) {\n            System.out.println(\"Si\");\n        } else {\n            System.out.println(\"No\");\n        }\n\n    }\n} \n\n",
    "cpp": null,
    "py": null,
    "orden": 6,
    "suborden": 41,
    "fecha_creacion": "2020-12-04 22:01:06",
    "fecha_modificacion": "2020-12-06 20:23:22"
  },
  {
    "ID": 74,
    "supergrupo": "Matemática",
    "tema": "Números de Leonardo",
    "texto": "Los números de Leonardo son una secuencia de números con la recurrencia:\n- L(0)=0\n- L(1)=1\n- L(n)=L(n-1)+l(n-2)+1 si n>1\nLos primeros números de Leonardo son 1, 1, 3, 5, 9, 15, 25, 41, 67, 109, 177, 287, 465, 753, 1219, 1973, 3193, 5167, 8361, ···\nComplejidad de tiempo: Exponencial\n",
    "complejidad_tiempo": null,
    "java": "//Pograma java qque busca el nesimo número\n// de Leonardo\n\npublic class LeonardoNumber {\n\n    static int leonardo(int n) {\n        if (n == 0 || n == 1) {\n            return 1;\n        }\n        return (leonardo(n - 1) + leonardo(n - 2) + 1);\n    }\n    public static void main(String args[]) {\n        System.out.println(leonardo(3));\n    }\n} \n",
    "cpp": null,
    "py": null,
    "orden": 6,
    "suborden": 42,
    "fecha_creacion": "2020-12-04 22:01:06",
    "fecha_modificacion": "2020-12-06 20:23:23"
  },
  {
    "ID": 75,
    "supergrupo": "Matemática",
    "tema": "Teorema de Zeckendorf",
    "texto": "El teorema de Zeckendorf indica que cada posible entero puede ser escrito como la suma de distintos números de Fibonacci no vecinos. Dos números Fibonacci son vecinos si uno viene luego del otro en la secuencia (0, 1, 1, 2, 3, 5, ..). Por ejemplo 3 y 5 son vecinos pero 2 y 5 no lo son.\nDado un número, encontrar la representación del número como la suma de números de Fibonacci no consecutivos.\n1) Sea n el número de entrada\n2) Mientras n >= 0\na) Encontrar el Fibonacci más grande que sea menor que n. Dejar que este número sea ‘f’, e imprimir f.\nb) n = n – f\n",
    "complejidad_tiempo": null,
    "java": "/*Programa java para el Teorema de Zeckendorf, \nencuentra la representación de n como suma de \nnúmeros de fibonacci no vecinos*/\npublic class ZeckendorfTheorem {\n\n    public static int nearestSmallerEqFib(int n) {\n        // Casos base\n        if (n == 0 || n == 1) {\n            return n;\n        }\n        //Encuentra el mayor número fibonacci menor que n \n        int f1 = 0, f2 = 1, f3 = 1;\n        while (f3 <= n) {\n            f1 = f2;\n            f2 = f3;\n            f3 = f1 + f2;\n        }\n        return f2;\n    }\n    // Imprime representación de fibonacci  \n\n    public static void printFibRepresntation(int n) {\n        while (n > 0) {\n            // Encuentra el mayor número fibonacci menor \n            // o igual que n \n            int f = nearestSmallerEqFib(n);\n            // Imprime el número fibonacci encontrado\n            System.out.print(f + \" \");\n            // Reduce n \n            n = n - f;\n        }\n    }\n\n    public static void main(String[] args) {\n        int n = 30;\n        System.out.println(\"Representación de fibonacci no vecinos \"\n                + \" de  \" + n + \" es\");\n        printFibRepresntation(n);\n    }\n} \n",
    "cpp": null,
    "py": null,
    "orden": 6,
    "suborden": 43,
    "fecha_creacion": "2020-12-04 22:01:06",
    "fecha_modificacion": "2020-12-06 20:23:23"
  },
  {
    "ID": 76,
    "supergrupo": "Matemática",
    "tema": "Teorema de Rosser ",
    "texto": "El teorema de Rosser dicta que el nesimo número es mayor que el producto de n y el logaritmo natural de n para todos los n mayores a 1.\nMatemáticamente: \nPara n >= 1, si pn es el nesimo número primo, entonces then:\n- pn > n * (ln n)\n Para n = 1, enésimo número primo = 2\n-  2 > 1 * ln(1)\n Para n = 2, enésimo número primo = 3\n- 3 > 2 * ln(2)\n Para n = 3, enésimo número primo = 5\n- 5 > 3 * ln(3)\n   Para n = 4, enésimo número primo = 7\n- 7 > 4 * ln(4)\n   Para n = 5, enésimo número primo = 11\n- 11 > 5 * ln(5)\n   Para n = 6, enésimo número primo = 13\n- 13 > 6 * ln(6)\n",
    "complejidad_tiempo": null,
    "java": "// Programa java que verifica el Teorema de Rosser\n\nimport java.util.*;\n\npublic class RosserTheorem {\n\n    static ArrayList<Integer> prime = new ArrayList<Integer>();\n    // Criba de Eratostenes\n    static void sieve() {\n        int n = 10000;\n        boolean[] isprime = new boolean[n + 2];\n        for (int i = 0; i < n; i++) {\n            isprime[i] = true;\n        }\n        isprime[0] = false;\n        isprime[1] = false;\n        for (int i = 2; i <= n; i++) {\n            if (isprime[i]) {\n                for (int j = i * i; j <= n; j += i) {\n                    isprime[j] = false;\n                }\n            }\n        }\n        //Almacena primos en prime[] \n        for (int i = 0; i <= n; i++) {\n            if (isprime[i]) {\n                prime.add(i);\n            }\n        }\n    }\n\n    // Verifica el TEOREMA DE  ROSSER para todos los números  \n    // Menores a n\n    static void verifyRosser(int n) {\n        System.out.println(\"TEOREMA DE ROSSER: nesimo número primo > n * (ln n)\");\n        for (int i = 0; i < n; i++) {\n            if (prime.get(i) > (i + 1) * Math.log(i + 1)) {\n                System.out.println(\"para n = \" + (i + 1)\n                        + \", nesimo número primo = \"\n                        + prime.get(i) + \"\\n\\t\"\n                        + prime.get(i) + \" > \" + (i + 1)\n                        + \" * ln(\" + (i + 1) + \")\");\n            }\n        }\n    }\n\n    public static void main(String[] args) {\n        sieve();\n        verifyRosser(20);\n    }\n} \n",
    "cpp": null,
    "py": null,
    "orden": 6,
    "suborden": 44,
    "fecha_creacion": "2020-12-04 22:01:06",
    "fecha_modificacion": "2020-12-06 20:23:24"
  },
  {
    "ID": 77,
    "supergrupo": "Matemática",
    "tema": "Números de Smith",
    "texto": "Dado un número n, la tarea encontrar si un número es número de Smith o no, un número de Smith es un número compuesto cuya suma de dígitos es igual a la suma de los dígitos en su factorización prima.\n- n = 4\n- Factorización prima = 2, 2  and 2 + 2 = 4\n- Por lo tanto, 4 es un número de Smith\nLa idea es primero encontrar todos los factores primos por debajo de un límite usando la criba de Sundaram. (Esto es útil para buscar y verificar varios números de Smith). Ahora por cada entrada que será verificada como número de Smith, atravesamos por todos los factores primos en él, y encontramos la suma de los dígitos en cada factor primo. También buscamos la suma de los dígitos en el número dado. Finalmente comparamos las dos sumas, si son lo mismo, retornamos true.\n",
    "complejidad_tiempo": null,
    "java": "// Programa java que verifica si un número es \n// número de Smith o no\n\nimport java.util.ArrayList;\n\npublic class SmithNumber {\n\n    static int MAX = 10000;\n    //Array que almacena todos los primos menores o iguales\n    // a 10^6\n    static ArrayList<Integer> primes = new ArrayList<>();\n    //Función de la criba de Sundaram\n\n    static void sieveSundaram() {\n        /*En general criva de Sundaram, produce primos más pequeños.\n        que (2 * x + 2) para un número dado el número x. Ya que\n         Queremos primos más pequeños que MAX, reducimos MAX a la mitad\n         Esta matriz se usa para separar números del forma\n         i + j + 2ij de otros donde 1 <= i <= j*/\n        boolean marked[] = new boolean[MAX / 2 + 100];\n        //Lógica principal de Sundaram, marcar todos los números\n        // loc cuales no generan número primo haciendo 2*i+1\n        for (int i = 1; i <= (Math.sqrt(MAX) - 1) / 2; i++) {\n            for (int j = (i * (i + 1)) << 1; j <= MAX / 2; j = j + 2 * i + 1) {\n                marked[j] = true;\n            }\n        }\n\n        // 2s es número primo\n        primes.add(2);\n        // Imprime los otros primos, primos restantes son de la \n        //forma 2*i+1 de tal manera que marked[i] es falso\n        for (int i = 1; i <= MAX / 2; i++) {\n            if (marked[i] == false) {\n                primes.add(2 * i + 1);\n            }\n        }\n    }\n    // Retorna true si n es un número de Smith, si no falso \n\n    static boolean isSmith(int n) {\n        int original_no = n;\n        // Encuentra la suma de los digitos de los factores \n        //  primos de n\n        int pDigitSum = 0;\n        for (int i = 0; primes.get(i) <= n / 2; i++) {\n            while (n % primes.get(i) == 0) {   // Si primes[i] es un factor primo\n                // agrega sus digitos a pDigitSum\n                int p = primes.get(i);\n                n = n / p;\n                while (p > 0) {\n                    pDigitSum += (p % 10);\n                    p = p / 10;\n                }\n            }\n        }\n        /*Si n!=! entonces un primo sigue para ser sumado*/\n        if (n != 1 && n != original_no) {\n            while (n > 0) {\n                pDigitSum = pDigitSum + n % 10;\n                n = n / 10;\n            }\n        }\n        // Todos los factores primos sumados \n        // Ahora suma los digitos del número original \n        int sumDigits = 0;\n        while (original_no > 0) {\n            sumDigits = sumDigits + original_no % 10;\n            original_no = original_no / 10;\n        }\n        // Si la suma de los digistos en factores primos \n        // y la suma de digitos en el número original son los mismos\n        // entonces true, si no false\n        return (pDigitSum == sumDigits);\n    }\n\n    public static void main(String[] args) {   //Encuentra todos los números primos antes del limite\n        // estos números son usados para encontrar factores primos\n        sieveSundaram();\n        System.out.println(\"Imprimiento primeros números de Smith\"\n                + \" usando isSmith()\");\n        for (int i = 1; i < 500; i++) {\n            if (isSmith(i)) {\n                System.out.print(i + \" \");\n            }\n        }\n    }\n} \n",
    "cpp": null,
    "py": null,
    "orden": 6,
    "suborden": 45,
    "fecha_creacion": "2020-12-04 22:01:06",
    "fecha_modificacion": "2020-12-06 20:23:25"
  },
  {
    "ID": 78,
    "supergrupo": "Matemática",
    "tema": "Números esfénicos",
    "texto": "Un número escénico es un entero positivo el cual es el producto de exactamente tres primos distintos, los primeros números esfénicos son 30, 42, 66, 70, 78, 102, 105, 110, 114,…\nDado un número n, determine si es un número esfenico o no.\nUn número esfenico puede ser verificado generando los últimos factores primos de los números hasta n.\nLuego podemos simplemente dividir el número por sus factores primos y luego ese número por sus factores primos, y así en Adelante, y luego verificar si el número tiene exactamente 3 factores primos distintos.\nComplejidad de tiempo: O (nlog(n))\n",
    "complejidad_tiempo": null,
    "java": "// Programa JAVA que verifica si un número\n// es esfenico o no\n\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.HashSet;\nimport java.util.Set;\n\npublic class SphenicNumber {\n\n    static final int MAX = 1000;\n    //Crea un vector donde almacenar primos\n    // inicializa todas las entradas en 0\n    static ArrayList<Integer> least_pf = new ArrayList<>(MAX);\n\n    /* Esta función llena valores en least_pf[]\n    de tal modod que el valor de least_pf[] almacene\n    el factor primo más pequeño de i\n    Se encuentra basado en la criba\n    de Eratostenes*/\n    public static void main(String[] args) {\n        for (int i = 0; i < 1001; i++) {\n            least_pf.add(0);\n        }\n        Collections.fill(least_pf, 0);\n        leastPrimeFactor(MAX);\n        for (int i = 1; i < 100; i++) {\n            if (isSphenic(i)) {\n                System.out.println(i + \" \");\n            }\n        }\n\n    }\n    /*Función que verifica si un número es esfenico*/\n    static boolean isSphenic(int n) {\n        /*Almacena tres factores primos de n\n        tenemos al menos 3 elementos en s*/\n        Set<Integer> s = new HashSet<>();\n        // Siga encontrando factores primos hasta que n sea 1\n        while (n > 1) {\n            // Encuenta al menos un factor del actual valor de n\n            int lpf = least_pf.get(n);\n            // Almacenamos actual tamaño de s para verificar si\n            //algun factor primo se repite\n            int init_size = s.size();\n            // Inserta un valor primo al actual valor de n\n            s.add(lpf);\n            // si lpf repite un número o se pasa de 3, retorna falso. \n            if (s.size() == init_size || s.size() > 3) // El mismo primo divide\n            // un número más de una vez\n            {\n                return false;\n            }\n            // dividir n en lpf\n            n /= lpf;\n        }\n        // True si el tamaño es 3\n        return (s.size() == 3);\n    }\n\n    static void leastPrimeFactor(int n) {\n        // un factor primo de 1 es 1\n        least_pf.set(1, 1);\n        // Almacena números primos para todos \n        // los otros números\n        for (int i = 2; i <= n; i++) {\n            // least_pf[i] == 0 significa que i es primo\n            if (least_pf.get(i) == 0) {\n                least_pf.set(i, i);\n                for (int j = 2 * i; j <= n; j += i) {\n                    if (least_pf.get(j) == 0) {\n                        least_pf.set(j, i);\n                    }\n                }\n\n            }\n        }\n    }\n} \n",
    "cpp": null,
    "py": null,
    "orden": 6,
    "suborden": 46,
    "fecha_creacion": "2020-12-04 22:01:06",
    "fecha_modificacion": "2020-12-06 20:23:25"
  },
  {
    "ID": 79,
    "supergrupo": "Matemática",
    "tema": "Identidad de Cassini",
    "texto": "La identidad de Cassini y la identidad de Catalan son relaciones matemáticas ligadas con los números de la sucesión de Fibonacci, afirma que para cada número n-ésimo de la sucesión de Fibonacci, se cumple que:\n- Fn-1 x Fn+1-F^2n=(-1)^n\n",
    "complejidad_tiempo": null,
    "java": "//Programa java que demuestra \n// la identidad de Cassini\n\npublic class CassiniIdentity {\n    // Retorna (-1)^n \n    static int cassini(int n) {\n        return (n & 1) != 0 ? -1 : 1;\n    }\n\n    public static void main(String args[]) {\n        int n = 5;\n        System.out.println(cassini(n));\n    }\n}\n",
    "cpp": "#include<bits/stdc++.h>\n#include<cstdlib>\nusing namespace std;\nint cassini(int n){\n    return (n&1)!=0? -1 : 1;\n}\nint main(){\n    int n=5;\n    printf(\"%d\\n\",cassini(n));\n} \n",
    "py": null,
    "orden": 6,
    "suborden": 47,
    "fecha_creacion": "2020-12-04 22:01:06",
    "fecha_modificacion": "2020-12-06 20:23:26"
  },
  {
    "ID": 80,
    "supergrupo": "Matemática",
    "tema": "Números de Catalan ",
    "texto": "En combinatoria, los números de Catalan forman una secuencia de números naturales que aparece en varios problemas de conteo que habitualmente son recursivos. Obtienen su nombre del matemático belga Eugène Charles Catalan (1814–1894).\nEl n-ésimo número de Catalan se obtiene, aplicando coeficientes binomiales, a partir de la siguiente fórmula:\nCn=  (2n)!/(n+1)!n!\n",
    "complejidad_tiempo": null,
    "java": "//Programa Java que recursivamente encuentra el\n// nesimo número Catalan \n\npublic class CatalanNumber {\n\n    public static int catalan(int n) {\n        int res = 0;\n        // Caso base\n        if (n <= 1) {\n            return 1;\n        }\n        for (int i = 0; i < n; i++) {\n            res += catalan(i) * catalan(n - i - 1);\n        }\n        return res;\n    }\n\n    public static void main(String[] args) {\n        for (int i = 0; i < 10; i++) {\n            System.out.print(catalan(i) + \" \");\n        }\n    }\n} \n",
    "cpp": null,
    "py": null,
    "orden": 6,
    "suborden": 48,
    "fecha_creacion": "2020-12-04 22:01:06",
    "fecha_modificacion": "2020-12-06 20:23:27"
  },
  {
    "ID": 81,
    "supergrupo": "Matemática",
    "tema": "Números de Charmichael",
    "texto": "Un número n es un número de Carmichael si satisface la siguiente condición aritmética modular:\n- pow(b, n-1) MOD n = 1, \nPara todos los b en rango de 1 a n tal que b y n son relativos primos gcd(b, n) = 1 .\nDado un entero positivo n, encontrar si es un número de Carmichael, estos números tienen importancia en el método de Fermat para el test de primalidad.\n",
    "complejidad_tiempo": null,
    "java": "//Programa java que verifica si un número\n// es un número de carmichael\n\npublic class CarmichaelNumbers {\n\n//función que busca el GCD de dos números\n    static int gcd(int a, int b) {\n        if (a < b) {\n            return gcd(b, a);\n        }\n        if (a % b == 0) {\n            return b;\n        }\n        return gcd(b, a % b);\n    }\n    //Función que busca el pow(x,y)\n    // bajo un modulo mod\n    static int power(int x, int y, int mod) {\n        if (y == 0) {\n            return 1;\n        }\n        int temp = power(x, y / 2, mod) % mod;\n        temp = (temp * temp) % mod;\n        if (y % 2 == 1) {\n            temp = (temp * x) % mod;\n        }\n        return temp;\n    }\n\n//Función que verifica si un número es número de charmichael\n    static int isCarmichaelNumber(int n) {\n        for (int b = 2; b < n; b++) {\n            // Si 'b' es primo relativo de n\n            if (gcd(b, n) == 1) // y pow(b, n-1)%n no es 1,\n            // retorne falso\n            {\n                if (power(b, n - 1, n) != 1) {\n                    return 0;\n                }\n            }\n        }\n        return 1;\n    }\n\n    public static void main(String args[]) {\n        System.out.println(isCarmichaelNumber(500));\n        System.out.println(isCarmichaelNumber(561));\n        System.out.println(isCarmichaelNumber(1105));\n    }\n} \n",
    "cpp": null,
    "py": null,
    "orden": 6,
    "suborden": 49,
    "fecha_creacion": "2020-12-04 22:01:06",
    "fecha_modificacion": "2020-12-06 20:23:27"
  },
  {
    "ID": 82,
    "supergrupo": "Matemática",
    "tema": "Secuencia Stern-Brocot",
    "texto": "La secuencia de Stern Brocot es similar la secuencia de Fibonacci, pero es diferente en la forma en que la secuencia es generada.\n1) Primero y segundo elemento de la secuencia es 1 y 1.\n2) Considere el segundo miembro de la secuencia, luego sume el miembro considerado de la secuencia y su predecesor, por ejemplo (1+1=2) ahora 2 es el siguiente elemento de nuestra serie, la secuencia será [1,1,2].\n3) Después de este elemento, nuestro siguiente elemento en la secuencia será considerado el elemento en nuestro segundo paso, ahora la secuencia seria [1,1,2,1].\n4) De nuevo realizamos el paso 2, pero ahora consideramos el elemento 2 (Tercer elemento), entonces nuestro siguiente número de la secuencia será la suma de los números considerados, y su predecesor(2+1=3), la secuencia ahora será [1,1,2,1,3]\n5) Como en el paso 3, el siguiente elemento será considerado, por ejemplo 2, la secuencia será [1,1,2,1,3,2]\n6) El proceso continua, nuestro elemento considerado será 1(Cuarto elemento).\n",
    "complejidad_tiempo": null,
    "java": "// Programa java que imprime   \n// La secuencia de Stern Brocot\n\nimport java.util.*;\n\npublic class SternBrocotSequence {\n\n    static void SternSequenceFunc(ArrayList<Integer> BrocotSequence, int n) {\n        // Ciclo que crea la secuencia\n        for (int i = 1; BrocotSequence.size() < n; i++) {\n            int considered_element = BrocotSequence.get(i);\n            int precedent = BrocotSequence.get(i - 1);\n            //Agregando la suma de los elementos considerados\n            // y son precedentes\n            BrocotSequence.add(considered_element + precedent);\n            //  Agregando siguiente elemento considerado \n            BrocotSequence.add(considered_element);\n        }\n        // Imprimiendo secuencia\n        for (int i = 0; i < 15; ++i) {\n            System.out.print(BrocotSequence.get(i) + \" \");\n        }\n    }\n\n    public static void main(String[] args) {\n        int n = 15;\n        ArrayList<Integer> BrocotSequence = new ArrayList<Integer>();\n        // Agregando primer y segundo valor \n        // A la secuencia\n        BrocotSequence.add(1);\n        BrocotSequence.add(1);\n        SternSequenceFunc(BrocotSequence, n);\n    }\n} \n",
    "cpp": null,
    "py": null,
    "orden": 6,
    "suborden": 50,
    "fecha_creacion": "2020-12-04 22:01:06",
    "fecha_modificacion": "2020-12-06 20:23:28"
  },
  {
    "ID": 83,
    "supergrupo": "Matemática",
    "tema": "Secuencia Sylvester",
    "texto": "El en sistema numérico, La secuencia de Sylvester es una secuencia de enteros la cual cada miembro es un producto de los números previos, más uno, dado un entero positivo N, imprima los primeros N miembros de la secuencia.\nLos números pueden ser muy largos, se usa %10^9 + 7.\nLa idea es correr un ciclo y tomar dos variables, inicializarlos como 1 y 2, uno para almacenar el producto hasta ahora, y el otro para almacenar el número actual el cual es el primer número +1 y por cada paso, multiplicar ambos usando aritmética modular, por ejemplo (a + b)%N = (a%N + b%N)%N  donde N es un número modular.\n",
    "complejidad_tiempo": null,
    "java": "//Implementación java de la secuencia Sylvester  \n\npublic class SylvesterSequence {\n\n    public static void printSequence(int n) {\n        int a = 1; // Para almacenar el producto\n        int ans = 2; // Para almacenar el número actual\n        int N = 1000000007;\n        //Ciclo hasta n\n        for (int i = 1; i <= n; i++) {\n            System.out.print(ans + \" \");\n            ans = ((a % N) * (ans % N)) % N;\n            a = ans;\n            ans = (ans + 1) % N;\n        }\n    }\n\n    public static void main(String[] args) {\n        int n = 6;\n        printSequence(n);\n\n    }\n} \n",
    "cpp": null,
    "py": null,
    "orden": 6,
    "suborden": 51,
    "fecha_creacion": "2020-12-04 22:01:06",
    "fecha_modificacion": "2020-12-06 20:23:28"
  },
  {
    "ID": 84,
    "supergrupo": "Matemática",
    "tema": "Secuencia Aliquot ",
    "texto": "Dado un número n, la tarea es imprimir su secuencia de Aliquot. La secuencia de Aliquot de un número empieza con el mismo, términos restantes de la secuencia son la suma de los divisores propios del término inmediatamente anterior.\n\nPor ejemplo, la secuencia de Aliquot de 10, es 10,8,7,1,0. La secuencia puede repetir. Por ejemplo para 6, tenemos una secuencia infinita de todos los 6, En esos casos              imprimimos el número repetido y paramos.\n- Números los cuales tienen una secuencia de Aliquot repetitiva de longitud 1 son llamados números perfectos. Por ejemplo 6, suma de sus divisores propios es 6.\n- Números  que tienen una secuencia de Aliquot repetitiva de tamaño 2 son llamados números de Amicable. Por ejemplo 220 es un número de Amicable.\n- Números que tienen secuencia de Aliquot repetitiva de tamaño 3 son llamados números sociales\nPodemos generar la secuencia primero imprimiendo el número n y luego calculando los siguientes términos usando la suma de los divisores propios. Cuando computemos el siguiente termino, verificamos si nosotros ya habíamos visto ese término o no, si el término aparece de nuevo tenemos una secuencia repetida, imprimimos el mismo y rompemos el ciclo. \n",
    "complejidad_tiempo": null,
    "java": "//Implementación java de una apoximación\n// de la secuencia Aliquot \n\nimport java.util.*;\n\npublic class AliquotSequence {\n    // Función que calcula suma de \n    // los divisores adecuados\n    static int getSum(int n) {\n        int sum = 0; // 1 es un divisor adecuado\n        for (int i = 1; i <= Math.sqrt(n); i++) {\n            if (n % i == 0) {   // Si divisores son iguales, solo toma uno \n                if (n / i == i) {\n                    sum = sum + i;\n                } else // Si no tome ambos\n                {\n                    sum = sum + i;\n                    sum = sum + (n / i);\n                }\n            }\n        }\n        // Calcula la suma de los divisores adecuados\n        return sum - n;\n    }\n\n    static void printAliquot(int n) {\n        // Imprime el primer termino\n        System.out.printf(\"%d \", n);\n        TreeSet<Integer> s = new TreeSet<>();\n        s.add(n);\n\n        int next = 0;\n        while (n > 0) {   // Calcula siguiente termino desde el anterior\n            n = getSum(n);\n            if (s.contains(n) && n != s.last()) {\n                System.out.print(\"\\nRepeats with \" + n);\n                break;\n            }\n            //Imprimir siguiente termino\n            System.out.print(n + \" \");\n            s.add(n);\n        }\n    }\n\n    public static void main(String[] args) {\n        printAliquot(12);\n    }\n} \n",
    "cpp": null,
    "py": null,
    "orden": 6,
    "suborden": 52,
    "fecha_creacion": "2020-12-04 22:01:06",
    "fecha_modificacion": "2020-12-06 20:23:29"
  },
  {
    "ID": 85,
    "supergrupo": "Matemática",
    "tema": "Secuencia Juggler",
    "texto": "La secuencia de Juggles es una serie de números enteros la cual su primer término comienza con un entero positivo y los términos restantes son generados de los anteriores inmediatos números.\nLa secuencia Juggler comenzando con el número 3: 5, 11, 36, 6, 2, 1\nLa secuencia Juggler comenzando desde el número 9:  9, 27, 140, 11, 36, 6, 2, 1\nDado un número n tenemos que imprimir la secuencia Juggler de este número como el primer número de la secuencia\n- Los términos en la secuencia de Juggler primero crecen hasta un valor pico, y luego empiezan a decrecer.\n- El último término de la secuencia de Juggler es siempre 1.\n",
    "complejidad_tiempo": null,
    "java": "// Implementación java de la secuenca de Juggler\n\npublic class JugglerSequence {\n\n    static void printJuggler(int n) {\n        int a = n;\n        // Imprime el primer termino\n        System.out.print(a + \" \");\n        // Calcula terminos hasta que el ultimo no sea 1\n        while (a != 1) {\n            int b = 0;\n            // Verifica si los previos terminos son pares o impares\n            if (a % 2 == 0) // calcular siguiente termino\n            {\n                b = (int) Math.floor(Math.sqrt(a));\n            } else // para impar anterior, calcular \n            // Siguiente termino\n            {\n                b = (int) Math.floor(Math.sqrt(a)\n                        * Math.sqrt(a) * Math.sqrt(a));\n            }\n            System.out.print(b + \" \");\n            a = b;\n        }\n    }\n\n    public static void main(String[] args) {\n        printJuggler(3);\n        System.out.println();\n        printJuggler(9);\n    }\n} \n",
    "cpp": null,
    "py": null,
    "orden": 6,
    "suborden": 53,
    "fecha_creacion": "2020-12-04 22:01:06",
    "fecha_modificacion": "2020-12-06 20:23:30"
  },
  {
    "ID": 86,
    "supergrupo": "Matemática",
    "tema": "Secuencia Moser de Brujin",
    "texto": "Dado un entero n, imprima los primeros n términos de la secuencia de Moser de Brujin.\nLa secuencia de Moser de Brujin es una secuencia obtenida adicionando las distintas potencias del número 4, por ejemplo 1,4,16,6..\nDebe notarse aquí que cualquier número el cual es la suma de potencias de 4 no distintas no son parte de la secuencia, por ejemplo 8 no es parte de la secuencia debido a que es formado de la suma de no distintas potencias de 4, que son 4 y 4.\nPor lo tanto cualquier número el cual no sea una potencia de 4 y está presente en la secuencia debe ser la suma de distintas potencias de 4.\nPor ejemplo, 21 es parte de la secuencia, incluso a través de que no es una potencia de 4 porque es la suma de distintas potencias de 4, que son 1,4 y 16.\n",
    "complejidad_tiempo": null,
    "java": "// Codigo java que genera los primeros n terminos\n// de la secuencia de  Moser-de Bruijn \n\npublic class MoserdeBruijnSequence {\n\n    public static int gen(int n) {\n        // S(0) = 0 \n        if (n == 0) {\n            return 0;\n        } // S(1) = 1 \n        else if (n == 1) {\n            return 1;\n        } // S(2 * n) = 4 * S(n) \n        else if (n % 2 == 0) {\n            return 4 * gen(n / 2);\n        } // S(2 * n + 1) = 4 * S(n) + 1 \n        else if (n % 2 == 1) {\n            return 4 * gen(n / 2) + 1;\n        }\n        return 0;\n    }\n\n    public static void moserDeBruijn(int n) {\n        for (int i = 0; i < n; i++) {\n            System.out.print(gen(i) + \" \");\n        }\n        System.out.println();\n    }\n\n    public static void main(String args[]) {\n        int n = 15;\n        System.out.println(\"Primeros \" + n\n                + \" terminos de la secuencia de  \"\n                + \"Moser-de Bruijn  : \");\n        moserDeBruijn(n);\n    }\n} \n",
    "cpp": null,
    "py": null,
    "orden": 6,
    "suborden": 54,
    "fecha_creacion": "2020-12-04 22:01:06",
    "fecha_modificacion": "2020-12-06 20:23:30"
  },
  {
    "ID": 87,
    "supergrupo": "Matemática",
    "tema": "Secuencia Newman-Conway",
    "texto": "La secuencia de  Newman-Conway es aquella que genera la siguiente secuencia de enteros:\n1 1 2 2 3 4 4 4 5 6 7 7…\nEn términos matemáticos, la secuencia P(n) de Newman-Conway es definida por la siguiente relación de recurrencia:\n- P(n) = P(P(n - 1)) + P(n - P(n - 1)) with seed values P(1) = 1 and P(2) = 1\nDado un número n, imprima el enésimo número de la secuencia Newman-Conway\nComplejidad de tiempo: O(n)\n",
    "complejidad_tiempo": null,
    "java": "// Programa java que encuentra el nesimo  \n// elemento de la secuencia de  Newman-Conway\n\npublic class NewmanConwaySequence {\n\n    static int sequence(int n) {\n        if (n == 1 || n == 2) {\n            return 1;\n        } else {\n            return sequence(sequence(n - 1))\n                    + sequence(n - sequence(n - 1));\n        }\n    }\n\n    static int sequenceDP(int n) {\n        int f[] = new int[n + 1];\n        int i;\n        f[0] = 0;\n        f[1] = 1;\n        f[2] = 1;\n\n        for (i = 3; i <= n; i++) {\n            f[i] = f[f[i - 1]] + f[i - f[i - 1]];\n        }\n        return f[n];\n    }\n\n    public static void main(String args[]) {\n        int n = 10;\n        System.out.println(sequence(n));\n    }\n} \n",
    "cpp": null,
    "py": null,
    "orden": 6,
    "suborden": 55,
    "fecha_creacion": "2020-12-04 22:01:06",
    "fecha_modificacion": "2020-12-06 20:23:31"
  },
  {
    "ID": 88,
    "supergrupo": "Matemática",
    "tema": "Secuencia Padovan",
    "texto": "La secuencia de Padovan es similar a la secuencia de Fibonacci, con una secuencia recursiva similar cuya fórmula es: \n- P(n) = P(n-2) + P(n-3)\n-  P(0) = P(1) = P(2) = 1 \n",
    "complejidad_tiempo": null,
    "java": "// Programa JAVA que encuentra el enesimo termino\n// de la secuencia de Padovan\n// usando programación dinamica  \n\npublic class PadovanSequence {\n\n    /* Función que calcula el número de Padovan*/\n    static int pad(int n) {   //0,1 y 2 número de la serie es 1\n        int pPrevPrev = 1, pPrev = 1,\n                pCurr = 1, pNext = 1;\n        for (int i = 3; i <= n; i++) {\n            pNext = pPrevPrev + pPrev;\n            pPrevPrev = pPrev;\n            pPrev = pCurr;\n            pCurr = pNext;\n        }\n        return pNext;\n    }\n\n    public static void main(String args[]) {\n        int n = 12;\n        System.out.println(pad(n));\n    }\n} \n\n",
    "cpp": null,
    "py": null,
    "orden": 6,
    "suborden": 56,
    "fecha_creacion": "2020-12-04 22:01:06",
    "fecha_modificacion": "2020-12-06 20:23:32"
  },
  {
    "ID": 89,
    "supergrupo": "Matemática",
    "tema": "Secuencia Recaman",
    "texto": "Dado un entero n, imprima los primeros n elementos de la secuencia de Recaman\nEs básicamente una función con dominio y co dominio como números naturales y 0, su recursividad se define de la siguiente manera.\nEspecíficamente, dejamos a(n) denotar el (n+1)simo termino (0 ya está ahí).\nLa regla dice:\n- a(0) = 0,\n- Si n > 0 y el número no está incluido en la secuencia \n- a(n) = a(n - 1) - n \n- si no\n- a(n) = a(n-1) + n. \nComplejidad de tiempo: O(n^2)\n",
    "complejidad_tiempo": null,
    "java": "// Programa java que imprime el nesimo número\n// de la secuencia de Recaman\n\npublic class RecamanSequence {\n\n    static void recaman(int n) {   \n        //Crea un array que almacenara los terminos\n        int arr[] = new int[n];\n        // Primer termino de la secuencia es siempre 0\n        arr[0] = 0;\n        System.out.print(arr[0] + \" ,\");\n        // Llena terminos restantes usando formula recursiva\n        for (int i = 1; i < n; i++) {\n            int curr = arr[i - 1] - i;\n            int j;\n            for (j = 0; j < i; j++) {   \n   // si arr[i-1] - i es negativo or ya existe \n                if ((arr[j] == curr) || curr < 0) {\n                    curr = arr[i - 1] + i;\n                    break;\n                }\n            }\n            arr[i] = curr;\n            System.out.print(arr[i] + \", \");\n        }\n    }\n\n    public static void main(String[] args) {\n        int n = 17;\n        recaman(n);\n    }\n} \n",
    "cpp": null,
    "py": null,
    "orden": 6,
    "suborden": 57,
    "fecha_creacion": "2020-12-04 22:01:06",
    "fecha_modificacion": "2020-12-06 20:23:32"
  },
  {
    "ID": 90,
    "supergrupo": "Geometría",
    "tema": "Longitud de arco",
    "texto": "Un ángulo se forma cuando dos rayos se encuentran en un punto en un plano, esos rayos forman  los lados del ángulo, y el punto de encuentro es referido como el vértice del ángulo. Hay que tener en cuenta que el plano que forma un ángulo no tiene que ser un plano Euclidiano, ahora en un círculo el largo de un arco es una porción de la circunferencia.\nDado un ángulo y el diámetro de un círculo, podemos calcular el largo de un arco usando la fórmula:\n- ArcLength = ( 2 * pi * radio ) * ( ángulo / 360 )\n- Donde  pi = 22/7,\n- Diámetro = 2 * radio,\n- El ángulo está en grados.\nSi el ángulo es mayor o igual a 360 grados, entonces el largo del arco no puede ser calculado desde que ningún ángulo es posible.\n",
    "complejidad_tiempo": "Mejor caso :    O(1)  Peor caso : O(1)  Promedio: O(1) ",
    "java": "//Programa java que calcula \n//la longitud de un arco \n\npublic class ArcLength {\n\n    static double arcLength(double diameter,\n            double angle) {\n        double pi = 22.0 / 7.0;\n        double arc;\n        if (angle >= 360) {\n            System.out.println(\"Angulo no puede ser fromado\");\n            return 0;\n        } else {\n            arc = (pi * diameter) * (angle / 360.0);\n            return arc;\n        }\n    }\n\n    public static void main(String args[]) {\n        double diameter = 25.0;\n        double angle = 45.0;\n        double arc_len = arcLength(diameter, angle);\n        System.out.println(arc_len);\n    }\n}\n",
    "cpp": "#include<bits/stdc++.h>\n#include<cstdlib>\n#define PI 22/7\n//---------------//\nusing namespace std;\ntypedef long double ld;\nld arcLen(ld diametro,ld angulo){\n    ld arc;\n    if(angulo>=360){\n        cout<<\"el angulo no puede ser formado\"<<endl;\n        return 0;\n    }\n    else{\n        arc=(PI*diametro)*(angulo/360);\n        return arc;\n    }\n}\nld DegToRad(ld d){\n    return ((d * PI )/ 180);\n}\nld RagToDeg(ld r){\n    return ((r * 180 )/ PI);\n}\nint main() {\n    ld d=5000;\n    ld angle=140.5;\n    printf(\"%.5llf\",arcLen(d,angle));\n}\n",
    "py": "from sys import stdin, stdout\nrl = stdin.readline\nwr = stdout.write\n\ndef arclen(diametro, angulo):\n    pi = 22 / 7\n    arc = 0\n    if angulo >= 360:\n        wr(f'Angulo no puede ser formado')\n        return 0\n    else:\n        arc = (pi * diametro) * (angulo / 360)\n        return arc\n\nd = 5000\nangle = 140.5\nwr(f'{arclen(d,angle)}')\n\n",
    "orden": 7,
    "suborden": 0,
    "fecha_creacion": "2020-12-04 23:04:25",
    "fecha_modificacion": "2020-12-06 20:25:37"
  },
  {
    "ID": 91,
    "supergrupo": "Geometría",
    "tema": "Area de un sector circular",
    "texto": "Un sector circular o un sector círculo, es la porción de un disco encerrado por dos radios y un arco, donde el área más pequeña es conocida como el sector menor y el grande como el sector mayor.\n- Sector =(pi*r^2)*(Angulo/360)\nEl área de un sector es similar al cálculo del área de un círculo, solo se le multiplica el área de un círculo con el ángulo del sector.\n",
    "complejidad_tiempo": "Mejor caso :    O(1)  Peor caso : O(1)  Promedio: O(1) ",
    "java": "// Programa java que encuentra el area de un sector circular\n\npublic class AreaCircularSector {\n\n    static void SectorArea(double radius, double angle) {\n        if (angle >= 360) {\n            System.out.println(\"Angle not possible\");\n        } // Calculando el area\n        else {\n            double sector = ((22 * radius * radius) / 7)\n                    * (angle / 360);\n            System.out.println(sector);\n        }\n    }\n\n    public static void main(String[] args) {\n        double radius = 9;\n        double angle = 60;\n        SectorArea(radius, angle);\n    }\n}\n",
    "cpp": "#include<bits/stdc++.h>\n#include<cstdlib>\n#define PI 22/7\n//---------------//\nusing namespace std;\ntypedef long double ld;\nvoid setCir(ld radio,ld angle){\n    if(angle>=360){\n        cout<<\"el angulo no es posible\"<<endl;\n    }else{\n        ld sector=((22*radio*radio)/7)*(angle/360);\n        printf(\"%.8llf\\n\",sector);\n    }\n}\nint main() {\n    ld radio=6;\n    ld angle=22.7;\n    setCir(radio,angle);\n} \n",
    "py": null,
    "orden": 7,
    "suborden": 1,
    "fecha_creacion": "2020-12-04 23:04:26",
    "fecha_modificacion": "2020-12-06 20:25:38"
  },
  {
    "ID": 92,
    "supergrupo": "Geometría",
    "tema": "Circulo circunscrito en un triángulo equilátero",
    "texto": "Dado el largo de los lados de un triángulo equilátero, necesitamos encontrar el área de un circuncirculo del triángulo dado. Todos los lados del triángulo equilátero son de igual largo, y todos los ángulos interiores son de 60 grados.\nLas propiedades de un circuncirculo son las siguientes:\n- El centro del circuncirculo es el punto donde las medianas del triángulo equilátero se intersectan.\n- El circulo circuncirculo de un triángulo equilátero es hecho a través de los tres vértices de un triángulo equilátero.\n- El radio de un circuncirculo de un triángulo equilátero es igual a (a/v3), donde ‘a’ es el largo de los lados del triángulo equilátero\nLa fórmula usada para calcular el área de un círculo circuncirculo es:\n-  (p*a^2)/3\nDonde a es el largo del lado del triángulo dado.\nSabemos que el área de un circulo es p*r^2, donde r es el radio del circulo dado. \nTambién sabemos que el radio de un circuncirculo de un triángulo equilátero = (Lado del triángulo/v3. \nPor lo tanto, área = p*r^2 = p*a^2/3.\n",
    "complejidad_tiempo": "Mejor caso :    O(1)  Peor caso : O(1)  Promedio: O(1) ",
    "java": "// código Java para encontrar el área de\n// un círculo curcunscripto a un triángulo equilátero\n\npublic class CircumscribedCircleOfEquilateral {\n\n    static double PI = 3.14159265;\n    //Función que encuentra el area\n    // del circulo circumscrito\n    public static double area_cicumscribed(double a) {\n        return (a * a * (PI / 3));\n    }\n\n    public static void main(String[] args) {\n        double a = 6.0;\n        System.out.println(\"Area of circumscribed circle is :\"\n                + area_cicumscribed(a));\n    }\n}\n",
    "cpp": "#include<bits/stdc++.h>\n#include<cstdlib>\n#define PI 22/7\n//---------------//\nusing namespace std;\ntypedef long double ld;\nld areaEquilatero(ld lado){\n    return (lado*lado*(PI/3));\n}\nint main() {\n    ld a=6;\n    printf(\"%.8llf\",areaEquilatero(a));\n}\n",
    "py": "from sys import stdin, stdout\nimport math\nrl = stdin.readline\nwr = stdout.write\n\ndef area_circumscribed(a):\n    return (a * a * (math.pi / 3))\n\na = int(rl())\nwr(f'Area de circulo circunscrito: {area_circumscribed(a)}')\n",
    "orden": 7,
    "suborden": 2,
    "fecha_creacion": "2020-12-04 23:04:26",
    "fecha_modificacion": "2020-12-06 20:25:39"
  },
  {
    "ID": 93,
    "supergrupo": "Geometría",
    "tema": "Convex Hull (Envoltorio convexo)",
    "texto": "Se define como la envolvente convexa, envoltura convexa o cápsula convexa de un conjunto de puntos X de dimensión n como la intersección de todos los conjuntos convexos que contienen a X.\nEn el caso particular de puntos en un plano, si no todos los puntos están alineados, entonces su envolvente convexa corresponde a un polígono convexo cuyos vértices son algunos de los puntos del conjunto inicial de puntos.\nUna forma intuitiva de ver la envolvente convexa de un conjunto de puntos en el plano, es imaginar una banda elástica estirada que los encierra a todos. Cuando se libere la banda elástica tomará la forma de la envolvente convexa.\n",
    "complejidad_tiempo": "Mejor caso :    O(nlog(n))  Peor caso : O(n2)  Promedio: O(n*puntostomados) ",
    "java": "// Programa java que halla el casco convexo de un set de puntos\n\nimport java.util.*;\n\npublic class ConvexHull {\n\n    static class Point {\n        int x, y;\n        Point(int x, int y) {\n            this.x = x;\n            this.y = y;\n        }\n    }\n    // Para encontrar la orientación de la tripleta\n    //la función retorna lo siguiente \n    // 0 --> p, q y r son colineares \n    // 1 --> Manecillas de reloj\n    // 2 --> en contra de las manecillas\n    static int orientation(Point p, Point q, Point r) {\n        int val = (q.y - p.y) * (r.x - q.x)\n                - (q.x - p.x) * (r.y - q.y);\n        if (val == 0) {\n            return 0;  // colinear\n        }\n        return (val > 0) ? 1 : 2; // Manecillas\n    }\n    //Imprime el casco convexo del set de puntos\n\n    static void convexHull(Point points[], int n) {\n        //Debe haber al menos 3 puntos\n        if (n < 3) {\n            return;\n        }\n        // Inicializar resultado\n        ArrayList<Point> hull = new ArrayList<>();\n        // Encuentra el punto de más a la izquierda \n        int l = 0;\n        for (int i = 1; i < n; i++) {\n            if (points[i].x < points[l].x) {\n                l = i;\n            }\n        }\n        // Comienza desde el punto más a la izquierda, sigue moviéndose.\n        // en sentido antihorario hasta llegar al punto de inicio\n        // otra vez. Este ciclo corre O (h) veces donde h es\n        // número de puntos en resultado o salida\n        int p = l, q;\n        do {\n            // Agrega el punto actual al resultado\n            hull.add(points[p]);\n            // Buscar un punto 'q' tal que\n            // la orientación (p, x, q) es antihorario\n            // para todos los puntos 'x'. La idea es mantener\n            // pista de los últimos visitados más contra reloj\n            // punto en q. Si algún punto 'i' es más\n            // en sentido contrario a las agujas del reloj que q, luego                         //actualiza q.\n            q = (p + 1) % n;\n            for (int i = 0; i < n; i++) {\n                //Si i es más antihorario que el actual q, actualice q\n                if (orientation(points[p], points[i], points[q])\n                        == 2) {\n                    q = i;\n                }\n            }\n            //Ahora q es el más antihoriario con respecto\n            // a p, ubica p como q para la siguiente iteración\n            // asi q es agregado al casco resultado\n            p = q;\n        } while (p != l);\n        // Mientras no vengamos del primer punto\n        // Imprima resultado\n        for (Point temp : hull) {\n            System.out.println(\"(\" + temp.x + \", \"\n                    + temp.y + \")\");\n        }\n    }\n\n    public static void main(String[] args) {\n        Point points[] = new Point[7];\n        points[0] = new Point(0, 3);\n        points[1] = new Point(2, 3);\n        points[2] = new Point(1, 1);\n        points[3] = new Point(2, 1);\n        points[4] = new Point(3, 0);\n        points[5] = new Point(0, 0);\n        points[6] = new Point(3, 3);\n        int n = points.length;\n        convexHull(points, n);\n    }\n}\n",
    "cpp": "#include<bits/stdc++.h>\n#include<cstdlib>\n#define x first\n#define y second\n//---------------//\nusing namespace std;\ntypedef pair<int, int> point;\n\nint orientation(point p, point q, point r) {\n    int val = (q.y - p.y)*(r.x - q.x)-(q.x - p.x)*(r.y - q.y);\n    if (val == 0) {\n        return 0;\n    }\n    return (val > 0 ? 1 : 2);\n}\n\nvoid convexHull(point po[], int n) {\n    if (n < 3) {\n        return;\n    }\n    vector<point>hull;\n    int l = 0;\n    for (int i = 1; i < n; i++) {\n        if (po[i].x < po[l].x) {\n            l = i;\n        }\n    }\n    int p = l, q;\n    do {\n        hull.push_back(po[p]);\n        q = (p + 1) % n;\n        for (int i = 0; i < n; i++) {\n            if (orientation(po[p], po[i], po[q]) == 2) {\n                q = i;\n            }\n        }\n        p = q;\n    } while (p != l);\n    for (point punto : hull) {\n        printf(\"{%d,%d}\\n\", punto.x, punto.y);\n    }\n}\n\nint main() {\n    point po[7];\n    po[0] = make_pair(0, 3);\n    po[1] = make_pair(2, 3);\n    po[2] = make_pair(1, 1);\n    po[3] = make_pair(2, 1);\n    po[4] = make_pair(3, 0);\n    po[5] = make_pair(0, 0);\n    po[6] = make_pair(3, 3);\n    convexHull(po, 7);\n} \n",
    "py": null,
    "orden": 7,
    "suborden": 3,
    "fecha_creacion": "2020-12-04 23:04:26",
    "fecha_modificacion": "2020-12-06 20:25:39"
  },
  {
    "ID": 94,
    "supergrupo": "Geometría",
    "tema": "Sumatoria de cortes",
    "texto": "Dado el número de cortes, encuentre el máximo número de posibles piezas.\nEste problema no es más que el problema del cartero flojo, y tiene la siguiente formula.\nMáximo número de piezas  = 1 + n*(n+1)/2\n",
    "complejidad_tiempo": "Mejor caso :    O(1)  Peor caso : O(1)  Promedio: O(1) ",
    "java": "//Programa que calcula el maximo número\n// de piezas de pizza dados el número de cortes\n\npublic class CutsSumatory {\n\n    static int findMaximumPieces(int n) {\n        return 1 + n * (n + 1) / 2;\n    }\n\n    public static void main(String arg[]) {\n\nSystem.out.print(findMaximumPieces(3));\n    }\n} \n",
    "cpp": "#include<bits/stdc++.h>\n#include<cstdlib>\n//---------------//\nusing namespace std;\nint findMaxSum(int n){\n    return 1 + n* (n+1) / 2;\n}\nint main() {\n    int a=5;\n    cout<<findMaxSum(a)<<endl;\n} \n",
    "py": null,
    "orden": 7,
    "suborden": 4,
    "fecha_creacion": "2020-12-04 23:04:26",
    "fecha_modificacion": "2020-12-06 20:25:40"
  },
  {
    "ID": 95,
    "supergrupo": "Geometría",
    "tema": "Formula de Heron",
    "texto": "En geometría plana elemental la fórmula de Herón, cuya invención se atribuye al matemático griego Herón de Alejandría, da el área de un triángulo conociendo las longitudes de sus tres lados a, b y c:\nArea=v(s(s-a)(s-b)(s-c))\n",
    "complejidad_tiempo": "Mejor caso :    O(1)  Peor caso : O(1)  Promedio: O(1) ",
    "java": "//Programa Java que calcula el area\n// De un triángulo usando la formula de Herón\n\npublic class HeronFormula {\n\n    public static void main(String[] args) {\n        //Enviar las coordenadas de los vertices\n        System.out.println(heron(1, 0, -1, 0, 0, 2));\n    }\n    //función que usa la formula de Herón\n    static double heron(double x1, double y1, double x2,\n            double y2, double x3, double y3) {\n        double a = Math.sqrt((x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2));\n        double b = Math.sqrt((x1 - x3) * (x1 - x3) + (y1 - y3) * (y1 - y3));\n        double c = Math.sqrt((x3 - x2) * (x3 - x2) + (y3 - y2) * (y3 - y2));\n        double s = (a + b + c) / 2.0;\n        double A = Math.sqrt(s * (s - a) * (s - b) * (s - c));\n        return A;\n    }\n\n}\n",
    "cpp": "#include<bits/stdc++.h>\n#include<cstdlib>\n#define point pair<double,double>\n#define x first\n#define y second\n//---------------//\nusing namespace std;\n\ndouble heron(double x1,double y1,double x2,double y2,double x3,double y3){\n    double a =std::sqrt((x1-x2)*(x1-x2)+(y1-y2)*(y1-y2));\n    double b =std::sqrt((x2-x3)*(x2-x3)+(y2-y3)*(y2-y3));\n    double c =std::sqrt((x3-x1)*(x3-x1)+(y3-y1)*(y3-y1));\n    double s=(a+b+c)/2;\n    return (std::sqrt(s*(s-a)*(s-b)*(s-c)));\n\n}\nint main() {\n    cout<<heron(1,0,-1,0,0,2)<<endl;\n} \n",
    "py": null,
    "orden": 7,
    "suborden": 5,
    "fecha_creacion": "2020-12-04 23:04:27",
    "fecha_modificacion": "2020-12-06 20:25:41"
  },
  {
    "ID": 96,
    "supergrupo": "Geometría",
    "tema": "Area de un hexágono",
    "texto": "Un hexágono es una figura geométrica de 6 lados, en dos dimensiones, el total de la suma de los ángulos internos de cualquier hexágono es 720°. Un hexágono regular tiene 6 simetrías rotacionales, y 6 simetrías reflectivas, todos los ángulos internos son de 120 grados.\nAhí hay principalmente 6 triángulos equiláteros de lado n y el área de un triángulo equilátero es sqrt (3)/4*n*n. Desde el hexágono, hay en total 6 triángulos equiláteros con lado n, el área del hexágono se convierte en (3*sqrt (3)/2) * n * n)\n",
    "complejidad_tiempo": "Mejor caso :    O(1)  Peor caso : O(1)  Promedio: O(1) ",
    "java": "//Programa Java que calcula el area de un Hexagono\n\npublic class HexagonArea {\n\n    public static double hexagonArea(double s) {\n        return ((3 * Math.sqrt(3)\n                * (s * s)) / 2);\n    }\n\n    public static void main(String[] args) {\n        // Largo de un lado\n        double s = 4;\n        System.out.print(\"Area: \"\n                + hexagonArea(s));\n        System.out.println(\"\");\n    }\n}\n",
    "cpp": "#include<bits/stdc++.h>\n#include<cstdlib>\n//---------------//\nusing namespace std;\ndouble hexArea(double s){\n    return (3*sqrt(3)*(s*s))/2;\n}\nint main() {\n    double s=6;\n    printf(\"%.8f\\n\",hexArea(6));\n} \n",
    "py": null,
    "orden": 7,
    "suborden": 6,
    "fecha_creacion": "2020-12-04 23:04:27",
    "fecha_modificacion": "2020-12-06 20:25:41"
  },
  {
    "ID": 97,
    "supergrupo": "Geometría",
    "tema": "Area de un polígono",
    "texto": "Dadas ordenadamente las coordenadas de un polígono, con n vértices, encontrar el área del polígono. Aquí ordenado significa que las coordenadas son dadas en sentido horario o anti horario, desde el primer vértice hasta el último.\n\nPodemos dividir un polígono en triángulos, la fórmula del área es derivada de tomar cada camino AB, y calcular el área del triángulo ABO, con un vértice de origen O, tomando el producto cruz (El cual da el área de un paralelogramo) y dividiendo por 2. Mientras pasemos alrededor del polígono, estos triángulos con área positiva o negativa se sobreponen, y las ares en medio del origen y el polígono pueden ser canceladas y sumadas a 0, mientras solo haya área interna, el triángulo de referencia de mantiene.\n",
    "complejidad_tiempo": "Mejor caso :    O(nlog(n))  Peor caso : O(nlog(n))  Promedio: O(nlog(n)) ",
    "java": "//Programa Java que calcula el area de un poligono\n\nimport java.awt.Point;\nimport java.awt.Polygon;\nimport java.util.Arrays;\n\npublic class AreaOfPolygon {\n\n    public static void main(String[] args) {\n        //Crea el poligono con los puntos dados\n        Polygon p = new Polygon();\n        p.addPoint(0, 2);\n        p.addPoint(2, 2);\n        p.addPoint(2, 0);\n        p.addPoint(0, 0);\n        System.out.println(area(p));\n    }\n    //Por medio de triángulos va calculando el area completa\n    static int signedTriangleArea(Point a, Point b, Point c) {\n        return a.x * b.y - a.y * b.x + a.y * c.x - a.x * c.y + b.x * c.y - c.x * b.y;\n    }\n    static boolean ccw(Point a, Point b, Point c) {\n        return signedTriangleArea(a, b, c) > 0;\n    }\n    // Verifica si los puntos son colineares\n    static boolean collinear(Point a, Point b, Point c) {\n        return signedTriangleArea(a, b, c) == 0;\n    }\n    //Calcula la distancia entre dos puntos\n    static double distance(Point p1, Point p2) {\n        double dx = p1.x - p2.x;\n        double dy = p1.y - p2.y;\n        return Math.sqrt(dx * dx + dy * dy);\n    }\n    //Función que calcula el area de cualquier poligono\n    static double area(Polygon poly) {\n        int N = poly.npoints;\n        int[] x = poly.xpoints;\n        int[] y = poly.ypoints;\n        Point[] p = new Point[N];\n        for (int i = 0; i < N; ++i) {\n            p[i] = new Point(x[i], y[i]);\n        }\n        final Point first;\n        int min = 0;\n        for (int i = 1; i < N; i++) {\n            if (p[i].y < p[min].y) {\n                min = i;\n            } else if (p[i].y == p[min].y) {\n                if (p[i].x < p[min].x) {\n                    min = i;\n                }\n            }\n        }\n        first = p[min];\n        p[min] = p[0];\n        p[0] = first;\n        //Usar expresion lambda en vez de comparator\n        Arrays.sort(p, 1, N, (Point p1, Point p2) -> {\n            if (collinear(first, p1, p2)) {\n                return Double.compare(distance(first, p1), distance(first, p2));\n            }\n            if (ccw(first, p1, p2)) {\n                return -1;\n            } else {\n                return 1; \n            }\n        });\n        double A = 0.0;\n        for (int i = 0; i < N; i++) {\n            int j = (i + 1) % N;\n            A += p[i].x * p[j].y - p[j].x * p[i].y;\n        }\n        return A / 2.0;\n\n    }\n} \n",
    "cpp": null,
    "py": null,
    "orden": 7,
    "suborden": 7,
    "fecha_creacion": "2020-12-04 23:04:27",
    "fecha_modificacion": "2020-12-06 20:25:42"
  },
  {
    "ID": 98,
    "supergrupo": "Geometría",
    "tema": "Intersección de líneas",
    "texto": "Dados puntos A y B, correspondientes a la línea AB y los puntos P y Q, correspondientes a la línea PQ, encuentre el punto de intersección de estas líneas. Los puntos están dados en un plano 2D con sus coordenadas X y Y.\nPrimero que todo, asumimos que tenemos dos puntos (x1,y1,) y (x2,y2). Ahora encontramos la ecuación de la línea formada por esos puntos.\nDejaremos que las líneas dadas sean:\n- a1x + b1y = c1\n- a2x + b2y = c2\nTenemos que ahora resolver estas dos ecuaciones para encontrar el punto de intersección, para resolver esto, multiplicamos a1 por b2 y a2 por b1, esto nos da:\n- a1b2x + b1b2y = c1b2\n- a2b1x + b2b1y = c2b1\nRestando esto obtenemos:\n- (a1b2 – a2b1) x = c1b2 – c2b1\nEsto nos da el valor de x. similarmente podemos encontrar el valor de y, (x,y) nos da el punto de intersección.\nEsto nos da el punto de intersección de dos líneas, pero si nos dan segmentos de línea en vez de líneas, tenemos que revisar el punto que computado yace en ambos segmentos de líneas,\nSi el segmento de línea es especificado por los puntos (x1,y2) y (x2,y2), entonces debemos verificar si (x,y) está en el segmento que tenemos de la siguiente manera:\n- min (x1, x2) <= x <= max (x1, x2)\n- min (y1, y2) <= y <= max (y1, y2)\n",
    "complejidad_tiempo": "Mejor caso :    O(1)  Peor caso : O(1)  Promedio: O(1) ",
    "java": "//Implementación Java que encuentra el punto de\n//interseccion de dos lineas\n\npublic class LineLineIntersection {\n    //Clase usada para almacenar las coordenadas X y la Y    \n    // de un punto respectivo\n    static class Point {\n        double x, y;\n        public Point(double x, double y) {\n            this.x = x;\n            this.y = y;\n        }\n        // Metodo usado para imprimir las cordenadas\n        // X y Y de un punto\n        static void displayPoint(Point p) {\n            System.out.println(\"(\" + p.x + \", \" + p.y + \")\");\n        }\n    }\n\n    static Point lineLineIntersection(Point A, Point B, Point C, Point D) {\n        // Linea AB representada como a1x + b1y=c1\n        double a1 = B.y - A.y;\n        double b1 = A.x - B.x;\n        double c1 = a1 * (A.x) + b1 * (A.y);\n        // Linea CD representada como a2x + b2y=c2\n        double a2 = D.y - C.y;\n        double b2 = C.x - D.x;\n        double c2 = a2 * (C.x) + b2 * (C.y);\n        double determinant = a1 * b2 - a2 * b1;\n        if (determinant == 0) {\n            //Las lineas son pararelas, esto es simplificado\n            //Retornando un par de FLT_MAX\n            return new Point(Double.MAX_VALUE, Double.MAX_VALUE);\n        } else {\n            double x = (b2 * c1 - b1 * c2) / determinant;\n            double y = (a1 * c2 - a2 * c1) / determinant;\n            return new Point(x, y);\n        }\n    }\n\n    public static void main(String args[]) {\n        Point A = new Point(1, 1);\n        Point B = new Point(4, 4);\n        Point C = new Point(1, 8);\n        Point D = new Point(2, 4);\n        Point intersection = lineLineIntersection(A, B, C, D);\n        if (intersection.x == Double.MAX_VALUE\n                && intersection.y == Double.MAX_VALUE) {\n            System.out.println(\"la linea AB y CD son paralelas.\");\n        } else {\n            System.out.print(\"La intersección de las lineas AB \"+ \"y CD es: \");\n            Point.displayPoint(intersection);\n        }\n    }\n} \n",
    "cpp": null,
    "py": null,
    "orden": 7,
    "suborden": 8,
    "fecha_creacion": "2020-12-04 23:04:28",
    "fecha_modificacion": "2020-12-06 20:25:42"
  },
  {
    "ID": 99,
    "supergrupo": "Geometría",
    "tema": "Punto medio de una línea",
    "texto": "Dado dos coordenadas de una línea iniciando en (x1,y1) y terminando en (x2,y2) encontrar el punto medio de una línea.\nEl punto medio de dos puntos (x1,y1) y (x2,y2) es el punto M encontrado con la siguiente fórmula:\n- M = ((x1+x2)/2 , (y1+y2)/2)\n",
    "complejidad_tiempo": "Mejor caso :    O(1)  Peor caso : O(1)  Promedio: O(1) ",
    "java": "//Programa java para buscar\n//el punto medio de una linea\n\npublic class LineMidPoint {\n\n    static void midpoint(int x1, int x2,\n            int y1, int y2) {\n        System.out.print((x1 + x2) / 2\n                + \" , \" + (y1 + y2) / 2);\n    }\n\n    public static void main(String[] args) {\n        int x1 = -1, y1 = 2;\n        int x2 = 3, y2 = -6;\n        midpoint(x1, x2, y1, y2);\n\n    }\n}\n",
    "cpp": "#include <iostream>\n\nusing namespace std;\n\nstring midPoint(int x1, int x2, int y1, int y2){\n    string res1 = std::to_string((x1+x2)>>1);\n    string res2 = std::to_string((y1+y2)>>1);\n    return (res1+\", \"+res2);\n}\n\nint main()\n{\n    ios_base::sync_with_stdio(false);cin.tie(NULL);cout.tie(NULL);\n    int x1, x2; cin>>x1>>x2;\n    int y1, y2; cin>>y1>>y2;\n    cout<<midPoint(x1, x2, y1, y2)<<endl;\n    return 0;\n}\n",
    "py": "from sys import stdin,stdout\n\n# m = ((x1+x2)/2 , (y1+y2)/2)\n\ndef midpoint(x1,y1,x2,y2):\n    res = str(((x1+x2)/2))+\" , \"+str(((y1+y2)/2))\n    return res\n\nx1,y1,x2,y2 = stdin.readline().strip().split()\n\nx1,y1,x2,y2 = int(x1),int(y1),int(x2),int(y2)\n\nmedio = midpoint(x1, y1, x2, y2)\n\nstdout.write(f\"el punto medio es: {medio}\")\n",
    "orden": 7,
    "suborden": 9,
    "fecha_creacion": "2020-12-04 23:04:28",
    "fecha_modificacion": "2020-12-06 20:25:43"
  },
  {
    "ID": 100,
    "supergrupo": "Geometría",
    "tema": "Línea dados dos puntos",
    "texto": "Dados dos puntos P(x1,y1) y Q(x2,y2), encuentre la ecuación de la línea formada por esos dos puntos.\nCualquier línea puede ser representada como:\n- ax + by = c\nDejamos dos puntos que satisfagan la línea dada, entonces tenemos:\n-  ax1 + by1 = c\n- ax2 + by2 = c\nPodemos cambiar los siguientes valores para que la ecuación de mantenga verdadera:\n- a = y2 - y1\n- b = x1 - x2\n- c = ax1 + by1\n",
    "complejidad_tiempo": "Mejor caso :    O(1)  Peor caso : O(1)  Promedio: O(1) ",
    "java": "//Implementación Java para encontrar la linea\n//que pasa atraves de dos puntos\n\npublic class LineThroughTwoPoints {\n\n    public static void main(String[] args) {\n        Pair P = new Pair(3, 2);\n        Pair Q = new Pair(2, 6);\n        lineFromPoints(P, Q);\n    }\n\n    static void lineFromPoints(Pair P, Pair Q) {\n        double a = Q.second - P.second;\n        double b = P.first - Q.first;\n        double c = a * (P.first) + b * (P.second);\n        if (b < 0) {\n            System.out.println(\"La linea que pasa a traves de \"\n                    + \"los puntos P y Q es: \"\n                    + a + \"x \" + b + \"y = \" + c);\n        } else {\n            System.out.println(\"La linea que pasa a traves de l\"\n            + \"os puntos P y Q es: \"\n                    + a + \"x + \" + b + \"y = \" + c);\n        }\n    }\n    /* Este par  es usado para almacenar la X y Y\n    de un punto respectivamente*/\n    static class Pair {\n        int first;\n        int second;\n        public Pair(int first, int second) {\n            this.first = first;\n            this.second = second;\n        }\n    }\n}\n",
    "cpp": "#include<bits/stdc++.h>\n#include<cstdlib>\n#define x first\n#define y second\nusing namespace std;\ntypedef pair<int,int> point;\nvoid lineFromPoints(point P,point Q){\n    double a=Q.y-P.y;\n    double b=P.x-Q.x;\n    double c=a*(P.x)+b*(P.y);\n    if(b < 0){\n        cout<<\"La linea que pasa a traves de los puntos P y Q es:\"<<\"(\"<<a<<\"x) * (\"<<b<<\"y) = \"<<c<<endl;\n    }else{\n        cout << \"La linea que pasa a traves de los punto P y Q es:\"<<a<<\"x + \" << b << \"y = \" << c << endl;\n    }\n}\nint main() {\n    point p=make_pair(3,2);\n    point q=make_pair(2,6);\n    lineFromPoints(p,q);\n} \n",
    "py": null,
    "orden": 7,
    "suborden": 10,
    "fecha_creacion": "2020-12-04 23:04:28",
    "fecha_modificacion": "2020-12-06 20:25:44"
  },
  {
    "ID": 101,
    "supergrupo": "Geometría",
    "tema": "Triángulo de monedas ordenadas",
    "texto": "Tenemos N monedas las cuales necesitamos ordenar en forma de triángulo, por ejemplo la primera fila podrá tener una moneda, la segunda fila dos monedas y así en adelante, necesitamos saber la máxima altura que podemos obtener usando esas N monedas.\nEste problema puede ser resuelto encontrando la relación entre la altura del triángulo y el número de monedas, dejamos como la altura máxima como H, luego la suma total de monedas debe ser menos de N.\n",
    "complejidad_tiempo": "Mejor caso :    O(1)  Peor caso : O(1)  Promedio: O(1) ",
    "java": "// Programa java que encuentra la maxima altura\n// de un triángulo de monedas arregladas\n\npublic class ArrangedCoinTriangle {\n\n    /*Retrorna el la raiz cuadrada de n\n    Note como la función lo realiza*/\n    static float squareRoot(float n) {\n        /*Usamos n como aproximción inicial*/\n        float x = n;\n        float y = 1;\n        // Se decide el nivel de precisión\n        float e = 0.000001f;\n        while (x - y > e) {\n            x = (x + y) / 2;\n            y = n / x;\n        }\n        return x;\n    }\n    //Metodo que encuentra la maxima altura\n    //del arreglo de monedas\n    static int findMaximumHeight(int N) {\n        //Calculando la porción interna\n        //de la raiz cuadrada\n        int n = 1 + 8 * N;\n        int maxH = (int) (-1 + squareRoot(n)) / 2;\n        return maxH;\n    }\n\n    public static void main(String[] args) {\n        int N = 12;\n        System.out.print(findMaximumHeight(N));\n    }\n}\n",
    "cpp": "#include <iostream>\nusing namespace std;\n\nint findMaxH(int);\nfloat squareRoot(float);\n\nint main() {\n    int N = 12;\n    cout << findMaxH(N) << endl;\n}\n\nint findMaxH(int n) {\n    int n1 = 1 + 8 * n;\n    int maxh = (int) (-1 + squareRoot(n1) / 2);\n    return maxh;\n}\n\nfloat squareRoot(float n) {\n    float x = n;\n    float y = 1;\n    float e = 0.0000001f;\n    while (x - y > e) {\n        x = (x + y) / 2;\n        y = n / x;\n    }\n    return x;\n}\n",
    "py": "from sys import stdin\nfrom sys import stdout\n\ndef findMaxH(n):\n    n1 = 1 + 8 * n\n    maxh = int(-1 + squareRoot(n1) / 2)\n    return maxh\n\ndef squareRoot(n):\n    x = n\n    y = 1\n    e = 0.000001\n    while x - y > e:\n        x = (x + y) / 2\n        y = n / x\n    return x\n\nN = 12\nstdout.write(f\"{findMaxH(N)}\")\n",
    "orden": 7,
    "suborden": 11,
    "fecha_creacion": "2020-12-04 23:04:29",
    "fecha_modificacion": "2020-12-06 20:25:44"
  },
  {
    "ID": 102,
    "supergrupo": "Geometría",
    "tema": "Perímetro usando bloques",
    "texto": "Tenemos n bloques de tamaño 1x1, necesitamos encontrar el mínimo perímetro de una matriz hecha de estos bloques.\n\n\nSi hacemos algunos ejemplos usando lápiz y papel, podemos notar que el perímetro se vuelve mínimo cuando la figura formada es más cercana a un cuadrado. La razón de esto es, que queremos el máximo de lados de bloques que miren dentro de la figura, entonces el perímetro de la figura se vuelve mínimo.\nSi el número de bloques es un cuadrado perfecto, entonces el perímetro puede ser simplemente 4*sqrt(n).\nPero si el número de bloques no es una raíz cuadrada perfecta, entonces nosotros calculamos el número de filas y columnas cercanas a la raíz cuadrada, luego de arreglar los bloques en un rectángulo, y tenemos bloques restantes, simplemente podemos agregar 2 al perímetro porque solo 2 lados extra faltarían.\n",
    "complejidad_tiempo": "Mejor caso :    O(1)  Peor caso : O(1)  Promedio: O(1) ",
    "java": "/*Codigo JAVA que permire encontrar el minimo\nperimetro usando n bloques*/\npublic class PerimeterUsingBlocks {\n\n    public static long minPerimeter(int n) {\n        int l = (int) Math.sqrt(n);\n        int sq = l * l;\n        //si n es un cudrado perfeto\n        if (sq == n) {\n            return l * 4;\n        } else {\n            //Número de filas\n            long row = n / l;\n            //Perimetro de la matriz rectangular\n            long perimeter\n                    = 2 * (l + row);\n            // Si hay bloques restantes\n            if (n % l != 0) {\n                perimeter += 2;\n            }\n            return perimeter;\n        }\n    }\n\n    public static void main(String[] args) {\n        int n = 10;\n        System.out.println(minPerimeter(n));\n    }\n}\n",
    "cpp": "#include <iostream>\n#include <cmath>\n\nusing namespace std;\n\nlong minPerimeter(int n) {\n    int x = (int) sqrt(n);\n    int sq = x * x;\n    if (sq == n) {\n        return x << 2;\n    } else {\n        long row = n / x;\n        long perimeter = (x + row) << 1;\n        if (n % x != 0) {\n            perimeter += 2;\n        }\n        return perimeter;\n    }\n}\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n    cout.tie(NULL);\n    int n;\n    cin>>n;\n    cout << minPerimeter(n) << endl;\n    return 0;\n}\n",
    "py": "import math\nfrom collections import namedtuple\nfrom sys import stdin, stdout\nrl = stdin.readline\nwr = stdout.write\n\n\ndef minPerimeter(n):\n    l = int(math.sqrt(n))\n    sq = l * l\n    if sq == n:\n        return l * 4\n    else:\n        row = n // l\n        perimeter = 2 * (l + row)\n        if n % l != 0:\n            perimeter += 2\n        return perimeter\n\n\nn = int(rl())\nwr(f'{minPerimeter(n)}')\n",
    "orden": 7,
    "suborden": 12,
    "fecha_creacion": "2020-12-04 23:04:29",
    "fecha_modificacion": "2020-12-06 20:25:45"
  },
  {
    "ID": 103,
    "supergrupo": "Geometría",
    "tema": "Punto dentro de un triangulo",
    "texto": "Dados tres puntos esquina de un triángulo, y un punto más P, verifique si P yace dentro del triángulo o no.\nDejaremos las coordenadas de las tres esquinas ser (x1, y1), (x2, y2) y (x3, y3), y las coordenadas de P ser (x, y). \n1) Calcular área del triángulo dado, por ejemplo el área del triángulo ACB:  Area A = [ x1(y2 – y3) + x2(y3 – y1) + x3(y1-y2)]/2\n2) Calcular el área del triángulo PAB. Podemos usar la misma fórmula para esto, dejamos esta área ser A1.\n3) Calculamos el área del triángulo PBC, dejamos esta área ser A2.\n4) Calcular el área del triángulo PAC, dejaremos esta área ser A3.\n5) Si P yace dentro del triángulo, entonces A1+A2+A3 debe ser igual a A.\n",
    "complejidad_tiempo": "Mejor caso :    O(1)  Peor caso : O(1)  Promedio: O(1) ",
    "java": "//Codigo Java que verifica cuando un punto\n//yace dentro de un triángulo o no\n\npublic class PointInsideTriangle {\n\n    /* Una función de utilidad que calcula el \n    area del triángulo formado por (x1, y1) (x2, y2) y (x3, y3)*/\n    static double area(int x1, int y1, int x2, int y2,\n            int x3, int y3) {\n        return Math.abs((x1 * (y2 - y3) + x2 * (y3 - y1)\n                + x3 * (y1 - y2)) / 2.0);\n    }\n\n    /* Una función que verifica cu cualquier punto P(x,y)\n    yace dentro de un triángulo formado por (x1, y1), \n    B(x2, y2) and C(x3, y3) */\n    static boolean isInside(int x1, int y1, int x2,\n            int y2, int x3, int y3, int x, int y) {\n        /* Calcula el area del triángulo ABC */\n        double A = area(x1, y1, x2, y2, x3, y3);\n        /* Calcula el area del triángulo PCB */\n        double A1 = area(x, y, x2, y2, x3, y3);\n        /* Calcula el area del triángulo PAC */\n        double A2 = area(x1, y1, x, y, x3, y3);\n        /* Calcula el area del triángulo PAB */\n        double A3 = area(x1, y1, x2, y2, x, y);\n        /* verifica si la suma de A1,A2 y A3 es igual a A*/\n        return (A == A1 + A2 + A3);\n    }\n\n    public static void main(String[] args) {\n        /* Verificamos si el punto P(10,15)\n        yace dentro del triángulo formado por\n        A(0, 0), B(20, 0) and C(10, 30)*/\n        if (isInside(0, 0, 20, 0, 10, 30, 10, 15)) {\n            System.out.println(\"Adentro\");\n        } else {\n            System.out.println(\"Por fuera\");\n        }\n    }\n}\n",
    "cpp": "#include <iostream>\n#include <math.h>\nusing namespace std;\n\n\ndouble area(int x1, int y1, int x2, int y2, int x3, int y3) {\n    return fabs((x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)) / 2.0);\n}\n\nbool isinside(int x1, int y1, int x2, int y2, int x3, int y3, int x, int y) {\n    double A = area(x1, y1, x2, y2, x3, y3);\n    double A1 = area(x1, y1, x2, y2, x, y);\n    double A2 = area(x1, y1, x3, y3, x, y);\n    double A3 = area(x2, y2, x3, y3, x, y);\n    return (A == A1 + A2 + A3);\n}\n\nint main() {\n    int x1 = 0, x2 = 5, x3 = 10, y1 = 0, y2 = 5, y3 = 3, puntox = 5, puntoy = 3;\n    if (isinside(x1, y1, x2, y2, x3, y3, puntox, puntoy)) {\n        cout << \"Esta dentro\" << endl;\n    } else cout << \"Esta fuera\" << endl;\n}\n",
    "py": "from sys import stdin\nfrom sys import stdout\n\ndef Area(x1, y1, x2, y2, x3, y3):\n    return abs((x1 * (y2-y3) + x2 * (y3-y1) + x3 * (y1-y2)) / 2)\n\ndef isInside(x1, y1, x2, y2, x3, y3, x, y):\n    A = Area(x1, y1, x2, y2, x3, y3)\n    A1 = Area(x1, y1, x2, y2, x, y)\n    A2 = Area(x1, y1, x3, y3, x, y)\n    A3 = Area(x2, y2, x3, y3, x, y)\n    return (A == A1 + A2 + A3)\n\nx1, y1, x2, y2, x3, y3, x, y = 0, 0, 5, 5, 10, 3, 5, 3\nif isInside(x1, y1, x2, y2, x3, y3, x, y):\n    stdout.write(f\"el punto ({x},{y}) esta dentro del triangulo\")\nelse:\n    stdout.write(f\"el punto ({x},{y}) no esta dentro del triangulo\")\n",
    "orden": 7,
    "suborden": 13,
    "fecha_creacion": "2020-12-04 23:04:29",
    "fecha_modificacion": "2020-12-06 20:25:46"
  },
  {
    "ID": 104,
    "supergrupo": "Geometría",
    "tema": "Línea dividida en ratios",
    "texto": "Dadas dos coordenadas (x1, y1) y (x2, y2), y m y n, encuentre las coordenadas que dividen la línea juntando (x1, y1) y (x2,y2) en el ratio m:n.\nLa fórmula de la sección nos dice las coordenadas del punto que divide una línea segmento dada en dos partes las cuales tendrán la longitud del ratio m:n.\n-  ((mx2+nx1/m+n),(my2+ny1/m+n))\n",
    "complejidad_tiempo": "Mejor caso :    O(1)  Peor caso : O(1)  Promedio: O(1) ",
    "java": "// Programa java que encuentra el punto que divide una \n//linea dada, dado un ratio\n\npublic class RatioDivideLine {\n    static void section(double x1, double x2,\n            double y1, double y2,\n            double m, double n) {\n        //Aplicando la formula de la sección\n        double x = ((n * x1) + (m * x2))\n                / (m + n);\n        double y = ((n * y1) + (m * y2))\n                / (m + n);\n        // Imprimiendo resultado\n        System.out.println(\"(\" + x + \", \" + y + \")\");\n    }\n\n    public static void main(String[] args) {\n        double x1 = 2, x2 = 4, y1 = 4,\n                y2 = 6, m = 2, n = 3;\n        section(x1, x2, y1, y2, m, n);\n    }\n}\n",
    "cpp": "#include<bits/stdc++.h>\n#include<cstdlib>\n#define x first\n#define y second\nusing namespace std;\ntypedef pair<double,double> point;\nvoid section(point a,point b,point n){\n    double x1 = ((n.y*a.x)+(n.x*a.y))/(n.x+n.y);\n    double y1 = ((n.y*b.x)+(n.x*b.y))/(n.x+n.y);\n    cout<<\"(\"<<x1<<\" , \"<<y1<<\")\"<<endl;\n}\nint main() {\n    point a=make_pair(2,0);\n    point b=make_pair(5,5);\n    point n=make_pair(3,2);\n    section(a,b,n);\n}\n",
    "py": "from sys import stdin\nfrom sys import stdout\nrl = stdin.readline\nwr = stdout.write\n\n\n# Usando coordenadas independientes\ndef section(x1, y1, x2, y2, m, n):\n    x = ((n * x1) + (m * x2)) / (m + n)\n    y = ((n * y1) + (m * y2)) / (m + n)\n    wr(f'({x} , {y})')\n\n\nx1, y1, x2, y2, m, n = rl().strip().split()\nx1, y1, x2, y2, m, n = int(x1), int(y1), int(x2), int(y2), int(m), int(n)\nsection(x1, y1, x2, y2, m, n)\n\n\n# Usando NamedTuple\nPuntos = namedtuple('Puntos', ['x', 'y'])\n\n\ndef sectionNT(P1, P2, m, n):\n    x = ((n * P1.x) + (m * P2.x)) / (m + n)\n    y = ((n * P1.y) + (m * P2.y)) / (m + n)\n    wr(f'({x} , {y})')\n\n\nP1 = Puntos(x1, y1)\nP2 = Puntos(x2, y2)\nsectionNT(P1, P2, m, n)\n",
    "orden": 7,
    "suborden": 14,
    "fecha_creacion": "2020-12-04 23:04:30",
    "fecha_modificacion": "2020-12-06 20:25:46"
  },
  {
    "ID": 105,
    "supergrupo": "Geometría",
    "tema": "Rectángulos en NxM",
    "texto": "Tenemos una matriz N*M, imprima el número de rectángulos en él.\n- Si la matriz es 1x1, entonces habrá 1 rectángulo.\n- Si la matriz es 2x1, entonces habrá  2 +1 = 3 rectángulos\n- Si la matriz es 3x1, entonces habrá 3+2+1=6 rectángulo.\nPodemos decir que para N*1 ahí habrá N+(N+1)+(N-2)… +1=(N)(N+1)/2 rectángulos.\nSi nosotros añadimos una columna más a Nx1, primero tendríamos tantos rectángulos en la segunda columna como en la primera, y luego tendríamos el mismo número de 2xM rectángulos, entonces Nx2=3 (N)(N+1)/2, luego de deducir esto podemos decir que:\n- Para N*M nosotros tendríamos (M)(M+1)/2 (N)(N+1)/2 = M(M+1)(N)(N+1)/4\nEntonces la fórmula para el total de rectángulos es:\n- M(M+1)(N)(N+1)/4\n",
    "complejidad_tiempo": "Mejor caso :    O(1)  Peor caso : O(1)  Promedio: O(1) ",
    "java": "// Codigo Java que cuenta el número\n// de rectangulos en una matriz N*M\n\npublic class RectanglesInNxM {\n\n    public static long rectCount(int n, int m) {\n        return (m * n * (n + 1) * (m + 1)) / 4;\n    }\n\n    public static void main(String[] args) {\n        int n = 5, m = 4;\n        System.out.println(rectCount(n, m));\n    }\n} \n",
    "cpp": null,
    "py": null,
    "orden": 7,
    "suborden": 15,
    "fecha_creacion": "2020-12-04 23:04:30",
    "fecha_modificacion": "2020-12-06 20:25:47"
  },
  {
    "ID": 106,
    "supergrupo": "Geometría",
    "tema": "Cuadrados 2x2 en un triángulo",
    "texto": "Cuál es el máximo número de cuadrados de tamaño 2x2 unidades que pueden caber en un triángulo isósceles de ángulos correctos dada la base en unidades.\nUn lado del cuadrado debe ser paralelo a la base del triángulo.\nDesde que el triángulo es isósceles, la base dada será también igual a la altura. Ahora en la parte diagonal, podríamos siempre necesitar un largo extra de dos unidades en la altura y la base del triángulo para acomodar un triángulo. En la longitud restante de la base, podemos construir largo/2 cuadrados. Desde que cada cuadrado es de dos unidades, lo mismo puede hacerse en el caso de la altura, ahí no hay necesidad de calcular  eso de nuevo.\nEntonces, para cada nivel de la longitud dada, podemos construir “(largo-2)/2” cuadrados. Esto nos da una base de “(largo-2)” encima de él. Continuando con el proceso de obtener el número de cuadrados para toda la disponible “largo/2” altura, podemos calcular los cuadrados.\nPara una forma más eficiente, podemos usar la fórmula de la suma de AP n*(n+1)/2, donde n= largo-2.\n",
    "complejidad_tiempo": "Mejor caso :    O(1)  Peor caso : O(1)  Promedio: O(1) ",
    "java": "// Programa Java que cuenta el número de cuadros2 \n// 2x2 que cabe en un triángulo isoceles\n\npublic class SquaresInTriangle2x2 {\n\n    public static int numberOfSquares(int base) {\n        // Removiendo la parte extra  \n        // que podamos necesitar\n        base = (base - 2);\n        // Desde cada cuadrado que tenga\n        // base de tamaño 2 \n        base = base / 2;\n        return base * (base + 1) / 2;\n    }\n\n    public static void main(String args[]) {\n        int base = 8;\n        System.out.println(numberOfSquares(base));\n    }\n} \n\n",
    "cpp": null,
    "py": null,
    "orden": 7,
    "suborden": 16,
    "fecha_creacion": "2020-12-04 23:04:30",
    "fecha_modificacion": "2020-12-06 20:25:47"
  },
  {
    "ID": 107,
    "supergrupo": "Geometría",
    "tema": "Suma de Manhattan",
    "texto": "Dados n coordenadas enteras, encuentre la suma de la distancia de Manhattan entre todos los pares de coordenadas.\nLa distancia de Manhattan entre dos puntos (x1,y1) y (x2,y2) es:\n- |x1 – x2| + |y1 – y2|\nLa idea es recorrer dos ciclos anidados, por ejemplo cada punto, encontrar la distancia de todos los otros puntos con este.\n",
    "complejidad_tiempo": " O(nlog(n))  Peor caso : O(nlog(n))  Promedio: O(nlog(n)) ",
    "java": "/*Programa Java para encontrar la suma de\nlas distancias de Manhattan entre todos \nlos pares de puntos dados */\n\npublic class SumOfManhattan {\n\n    /*Retorna la suma de la distancia entre todos\n    los pares de puntos*/\n    static int distancesum(int x[], int y[], int n) {\n        int sum = 0;\n        /* Por cada punto, encuentra la distancia \n        al resto de puntos */\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                sum += (Math.abs(x[i] - x[j])\n                        + Math.abs(y[i] - y[j]));\n            }\n        }\n        return sum;\n    }\n\n    public static void main(String[] args) {\n        int x[] = {-1, 1, 3, 2};\n        int y[] = {5, 6, 5, 3};\n        int n = x.length;\n        System.out.println(distancesum(x, y, n));\n    }\n} \n",
    "cpp": null,
    "py": null,
    "orden": 7,
    "suborden": 17,
    "fecha_creacion": "2020-12-04 23:04:31",
    "fecha_modificacion": "2020-12-06 20:25:48"
  },
  {
    "ID": 108,
    "supergrupo": "Geometría",
    "tema": "Tres puntos colineales",
    "texto": "Dados tres puntos, verificar si estos puntos yacen en recta (colineales) o no.\nEjemplo: (1, 1), (1, 4), (1, 5)\nLos tres puntos yacen en una línea recta.\nTres puntos yacen en una línea recta si el área formada por un triángulo de estos tres puntos es cero.\n",
    "complejidad_tiempo": "Mejor caso :    O(1)  Peor caso : O(1)  Promedio: O(1) ",
    "java": "/*Programa en java para verificar si\ntres puntos son colineares\no no usando el area del triángulo*/\npublic class ThreePointsCollinear {\n    //Función que verifica si un punto es colineal o no\n    static void collinear(int x1, int y1, int x2,\n            int y2, int x3, int y3) {\n        /*Calcular el area del triángulo\n        Debemos omitir multiplicaciones con 0.5\n        para evitar calculos flotantes*/\n        int a = x1 * (y2 - y3)\n                + x2 * (y3 - y1)\n                + x3 * (y1 - y2);\n        if (a == 0) {\n            System.out.println(\"Yes\");\n        } else {\n            System.out.println(\"No\");\n        }\n    }\n\n    public static void main(String args[]) {\n        int x1 = 1, x2 = 1, x3 = 1,\n                y1 = 1, y2 = 4, y3 = 5;\n        collinear(x1, y1, x2, y2, x3, y3);\n\n    }\n} \n",
    "cpp": null,
    "py": null,
    "orden": 7,
    "suborden": 18,
    "fecha_creacion": "2020-12-04 23:04:31",
    "fecha_modificacion": "2020-12-06 20:25:49"
  },
  {
    "ID": 109,
    "supergrupo": "Geometría",
    "tema": "Ángulos de un triángulo",
    "texto": "Dadas las coordenadas de tres vértices de un triángulo en un plano 2D, encuentre sus tres ángulos.\n- c^2 = a^2 + b^2 - 2(a)(b)(cos beta)\nLuego del despeje:\n- beta = acos( ( a^2 + b^2 - c^2 ) / (2ab) )\nEn trigonometría la ley del coseno cuenta que los largos de los lados de un triángulo con el coseno de uno de sus ángulos luego de un despeje nos da el ángulo.\nPrimero calculamos el largo de todos los lados, luego aplicamos la fórmula de arriba para obtener  todos los ángulos en radianes, luego convertimos de radianes a grados.\n",
    "complejidad_tiempo": null,
    "java": "/* Codigo JAVA para encontrar todos los angulos\nde un triángulos dadas las coordenadas\nde los tres vertices*/\nimport java.awt.Point;\nimport static java.lang.Math.PI;\nimport static java.lang.Math.sqrt;\nimport static java.lang.Math.acos;\n\npublic class TriangleAngles {   \n    // Regresa el cuadrado de la distancia b/w de dos puntos\n    static int lengthSquare(Point p1, Point p2) {\n        int xDiff = p1.x - p2.x;\n        int yDiff = p1.y - p2.y;\n        return xDiff * xDiff + yDiff * yDiff;\n    }\n\n    static void printAngle(Point A, Point B,\n            Point C) {\n        //Cuadrado de los tamaños de a2, b2, c2\n        int a2 = lengthSquare(B, C);\n        int b2 = lengthSquare(A, C);\n        int c2 = lengthSquare(A, B);\n        // Longitus de los lados de a, b, c \n        float a = (float) sqrt(a2);\n        float b = (float) sqrt(b2);\n        float c = (float) sqrt(c2);\n        // De la ley del coseno\n        float alfa = (float) acos((b2 + c2 - a2) / (2 * b * c));\n        float beta = (float) acos((a2 + c2 - b2) / (2 * a * c));\n        float gamma = (float) acos((a2 + b2 - c2) / (2 * a * b));\n        //Conversión a grados\n        alfa = (float) (alfa * 180 / PI);\n        beta = (float) (beta * 180 / PI);\n        gamma = (float) (gamma * 180 / PI);\n        //Imprimiendo los angulos\n        // printing all the angles \n        System.out.println(\"alfa : \" + alfa);\n        System.out.println(\"beta : \" + beta);\n        System.out.println(\"gamma : \" + gamma);\n    }\n\n    public static void main(String[] args) {\n        Point A = new Point(0, 0);\n        Point B = new Point(0, 1);\n        Point C = new Point(1, 0);\n        printAngle(A, B, C);\n    }\n} \n",
    "cpp": null,
    "py": null,
    "orden": 7,
    "suborden": 19,
    "fecha_creacion": "2020-12-04 23:04:31",
    "fecha_modificacion": "2020-12-06 20:25:49"
  },
  {
    "ID": 110,
    "supergrupo": "BitWise",
    "tema": "BitWise básico ",
    "texto": "Operaciones a nivel de bits.\nn & 1  -> Verifica si n es impar o no\nn & (1<<k) -> Verifica si el k-esimo bit esta encendido o no\nn | (1<<k) -> Enciende el k-esimo bit\nn & ~(1<<k) -> Apaga el k-esimo bit\nn ^ (1<<k) -> Invierte el k-esimo bit\n~n  -> Invierte todos los bits\nn & -n  -> Devuelve el bit encendido mas a la derecha\n~n & (n+1) -> Devuelve el bit apagado mas a la derecha\nn | (n+1) -> Enciende el bit apagado mas a la derecha\nn & (n-1) -> Apaga el bit encendido mas a la derecha\nOtras operaciones a nivel de bits.\n1) Borrar todos los bits desde el bit menos significativo (LSB) hasta el bit i\n• mask = ~((1 << i+1 ) - 1);\n• x &= mask;\nPara borrar todos los bits de LSB a i-ésimo bit, tenemos que AND X con la máscara que tiene LSB a i-ésimo bit 0. Para obtener dicha máscara, primero se desplaza a la izquierda 1 veces. Ahora, si sumamos 1 a partir de eso, todos los bits de 0 a i-1 se convierten en 1 y los bits restantes se convierten en 0. Ahora simplemente podemos tomar el complemento de máscara para obtener todos los primeros bits de i en 0 y permanecer en 1.\nEjemplo:\n• x = 29 (00011101) y queremos borrar LSB al 3er bit, total 4 bits\n• mask -> 1 << 4 -> 16(00010000)\n• mask -> 16 – 1 -> 15(00001111)\n• mask -> ~mask -> 11110000\n• x & mask -> 16 (00010000)\n2) Borrar todos los bits del bit más significativo (MSB) al bit i-ésimo \n• mask = (1 << i) - 1;\n• x &= mask;\nPara borrar todos los bits de MSB a i-ésimo bit, tenemos que AND x con la máscara que tiene MSB a i-ésimo bit 0. Para obtener dicha máscara, primero se desplaza a la izquierda 1 veces. Ahora, si menos 1 de eso, todos los bits de 0 a i-1 se convierten en 1 y los bits restantes se convierten en 0.\nEjemplo:\n• x = 215 (11010111) y queremos borrar MSB al 4to bit, total 4 bits\n• mask -> 1 << 4 -> 16(00010000)\n• mask -> 16 – 1 -> 15(00001111)\n• x & mask -> 7(00000111)\n3) Dividir por 2\n• x >>= 1;\nCuando hacemos un desplazamiento aritmético a la derecha, cada bit se desplaza a la derecha y la posición en blanco se sustituye con un bit de signo de número, 0 en caso de número positivo y 1 en caso de número negativo. Como cada bit es una potencia de 2, con cada cambio estamos reduciendo el valor de cada bit por un factor de 2 que es equivalente a la división de x por 2.\nEjemplo:\n• x = 18(00010010)\n• x >> 1 = 9 (00001001)\n4) Multiplicar por 2\n• x <<= 1;\nCuando hacemos desplazamiento aritmético a la izquierda, cada bit se desplaza a la izquierda y la posición en blanco se sustituye por 0. Como cada bit es una potencia de 2, con cada cambio aumentamos el valor de cada bit por un factor de 2 que es equivalente a la multiplicación de x por 2.\nEjemplo:\n• x = 18(00010010)\n• x << 1 = 36 (00100100)\n5) Mayusculas a minusculas en el alfabeto ingles\n• ch |= ' ';\nLa representación en bits de las letras en inglés en mayúsculas y minúsculas es:\nA -> 01000001          a -> 01100001\nB -> 01000010          b -> 01100010\nC -> 01000011          c -> 01100011\n  .                               .\n  .                               .\nZ -> 01011010          z -> 01111010\nComo podemos ver si establecemos el quinto bit de caracteres en mayúsculas, se convertirá en caracteres en minúsculas. Tenemos que preparar una máscara que tenga el quinto bit 1 y otro 0 (00100000). Esta máscara es una representación en bits del carácter de espacio (‘‘). El carácter \"ch\" luego OR con la máscara.\nEjemplo:\n• ch = ‘A’ (01000001)\n• mask = ‘ ‘ (00100000)\n• ch | mask = ‘a’ (01100001)\n6) Minusculas a mayusculas en el alfabeto ingles\n• ch &= '_’ ;\nLa representación en bits de las letras en inglés en mayúsculas y minúsculas es:\nA -> 01000001                a -> 01100001\nB -> 01000010                b -> 01100010\nC -> 01000011                c -> 01100011\n.                               .\n.                               .\nZ -> 01011010                z -> 01111010\nComo podemos ver si borramos el quinto bit de caracteres en minúsculas, se convertirá en caracteres en mayúsculas. Tenemos que preparar una máscara que tenga el quinto bit 0 y otro 1 (10111111). Esta máscara es una representación en bits del carácter de subrayado (‘_‘). El carácter \"ch\" luego AND con la máscara.\nEjemplo:\nch = ‘a’ (01100001)\nmask = ‘_ ‘ (11011111)\nch & mask = ‘A’ (01000001)\n7) Cuenta los bits establecidos en un entero \nint countSetBits(int x) {\n    int count = 0;\n    while (x) {\n        x &= (x - 1);\n        count++;\n    }\n    return count;\n}\nSe realiza esta operacion basado en el algoritmo de Brian Kernighan.\n8) Encuentra la log base 2 de un entero de 32 bits\nint log2(int x) {\n    int res = 0;\n    while (x >>= 1)\n        res++;\n    return res;\n}\nDesplazamos a la derecha x repetidamente hasta que se convierte en 0, mientras tanto, contamos con la operación de desplazamiento. Este valor de conteo es el log2 (x).\n9) Comprobando si un entero de 32 bits es una potencia de 2\nint isPowerof2(int x) {\n    return (x && !(x & x - 1));\n}\nToda la potencia de 2 tiene solo un bit establecido, p. 16 (00010000). Si menos 1 de esto, todos los bits de LSB para establecer el bit se alternan, es decir, 16-1 = 15 (00001111). Ahora si realizamos AND x con (x-1) y el resultado es 0, entonces podemos decir que x es una potencia de 2, de lo contrario no. Tenemos que tener mucho cuidado cuando x = 0.\nEjemplo:\n• x = 16(000100000)\n• x – 1 = 15(00001111)\n• x & (x-1) = 0\n• Entonces 16 es potencia de 2\n\n\n10) Cómo establecer un bit en el número \"num\":\nSi queremos establecer un bit en la enésima posición en el número \"num\", se puede hacer usando el operador \"OR\" (|).\n• Primero dejamos el desplazamiento \"1\" a la posición n a través de (1 << n)\n• Luego, use el operador \"OR\" para establecer el bit en esa posición. El operador \"OR\" se usa porque establecerá el bit incluso si el bit no se ha establecido previamente en la representación binaria del número \"num\".\nC++\n#include<iostream> \nusing namespace std;\n//num es el numero y pos es la posición \n//del bit que queremos activar\n\nvoid set(int & num, int pos) {\n    //Primer paso es correr '1',\n    //Segundo paso es realizar OR\n    num |= (1 << pos);\n}\n\nint main() {\n    int num = 4, pos = 1;\n    set(num, pos);\n    cout << (int) (num) << endl;\n    return 0;\n}\nSalida:\n6\n11)  Cómo desestablecer un bit en el número \"num\":\nSupongamos que queremos desarmar un poco en la enésima posición en el número \"num\", entonces tenemos que hacer esto con la ayuda del operador \"AND\" (&).\n• Primero dejamos el desplazamiento ‘1’ a la posición n mediante (1 << n) que usamos el operador NOT bit a bit ‘~’ para desactivar este desplazamiento sh 1 ’.\n• Ahora, después de despejar esta izquierda desplazada ‘1’, es decir, llegar a ‘0’, ‘AND '(&) con el número‘ num ’que desarmará el bit en la enésima posición.\nC++\n#include <iostream> \nusing namespace std;\n\nvoid unset(int &num, int pos) {\n    num &= (~(1 << pos));\n}\n\nint main() {\n    int num = 7;\n    int pos = 1;\n    unset(num, pos);\n    cout << num << endl;\n    return 0;\n}\nSalida:\n5\n12)  Alternar un bit en la enésima posición:\nAlternar significa activar el bit 'on' (1) si estaba 'off' (0) y desactivar '(0) si estaba' on '(1) anteriormente. Usaremos el operador' XOR 'aquí que es esto '^' La razón detrás del operador \"XOR\" se debe a sus propiedades.\n• Propiedades de operador XOR.\n• 1^1 = 0\n• 0^0 = 0\n• 1^0 = 1\n• 0^1 = 1\n• Si dos bits son diferentes, el operador \"XOR\" devuelve un bit establecido (1) de lo contrario, devuelve un bit no establecido (0).\n\nC++\n#include <iostream> \nusing namespace std;\n\nvoid toggle(int &num, int pos) {\n    num ^= (1 << pos);\n}\n\nint main() {\n    int num = 4;\n    int pos = 1;\n    toggle(num, pos);\n    cout << num << endl;\n    return 0;\n}\nSalida:\n6\n13) Comprobando si el bit en la enésima posición está activado o desactivado:\nEs bastante fácil de hacer con el operador \"AND\".\n• Desplazar a la izquierda '1' a la posición dada y luego 'Y' ('y').#include <iostream> \n• using namespace std; \nC++\nbool at_position(int num, int pos) {\n    bool bit = num & (1 << pos);\n    return bit;\n}\n\nint main() {\n    int num = 5;\n    int pos = 0;\n    bool bit = at_position(num, pos);\n    cout << bit << endl;\n    return 0;\n}\nSalida:\n1\nObserve que primero hemos dejado \"1\" desplazado y luego hemos usado el operador \"Y\" para obtener el bit en esa posición. Entonces, si hay '1' en la posición 'pos' en 'num', luego de 'AND' nuestra variable 'bit' almacenará '1' más si hay '0' en la posición 'pos' en el número 'num' que después de 'Y' nuestro bit variable almacenará '0'.\n14) Invertir cada bit de un numero a un numero con complement a 1\nSi queremos invertir cada bit de un número, es decir, cambiar el bit \"0\" a \"1\" y el bit \"1\" a \"0\". Podemos hacerlo con la ayuda del operador \"~\". Por ejemplo: si número es num = 00101100 (representación binaria), entonces ‘~ num’ será ‘11010011’.\nEste es también el \"complemento de número 1\".\nC++\n#include <iostream> \nusing namespace std;\n\nint main() {\n    int num = 4;\n    // Invertir cada bit del numero\n    cout << (~num);\n    return 0;\n}\nSalida:\n -5\n15) Complemento a dos del número\nEntonces, formalmente podemos tener el complemento de 2 al encontrar el complemento de 1 y agregar 1 al resultado, es decir (~ num + 1) o qué más podemos hacer es usar el operador ‘-‘.\n\nC++\n#include <iostream> \nusing namespace std;\n\nint main() {\n    int num = 4;\n    int twos_complement = -num;\n    cout << \"complemento a 2 \" << twos_complement << endl;\n    cout << \"Tambien complemento a 2  \" << (~num + 1) << endl;\n    return 0;\n}\nSalida:\nComplemento a 2 -4\nTambien complemento a 2 -4\n16) Eliminando el bit activo más bajo:\nEn muchas situaciones, queremos quitar el bit establecido más bajo, por ejemplo, en la estructura de datos de árbol indexado binario, contando el número de bit establecido en un número.\nHacemos algo como esto:\nX = X & (X-1)\nVeamos esto tomando un ejemplo, sea X = 1100. \n(X-1) invierte todos los bits hasta que encuentre el conjunto más bajo '1' y también invierte ese conjunto más bajo '1'.\nX-1 se convierte en 1011. Después de realizar 'AND' X con X-1 obtenemos el bit de ajuste más bajo despojado.\nC++\n#include <iostream> \nusing namespace std;\n\nvoid strip_last_set_bit(int &num) {\n    num = num & (num - 1);\n}\n\nint main() {\n    int num = 7;\n    strip_last_set_bit(num);\n    cout << num << endl;\n    return 0;\n}\nSalida:\n6\n17) Obtener el bit activo mas bajo de un numero:\nEsto se hace usando la expresión 'X & (- X)'. Veamos esto tomando un ejemplo: Sea X = 00101100. Entonces ~ X (complemento de 1) será '11010011' y el complemento de 2 será (~ X + 1 o -X), es decir, '11010100'. Entonces, si 'AND' el número original 'X' con su complemento de dos que es '-X', obtenemos el bit de ajuste más bajo.\n00101100\n& 11010100\n-----------\n00000100\n\nC++\n#include <iostream> \nusing namespace std;\n\nint lowest_set_bit(int num) {\n    int ret = num & (-num);\n    return ret;\n}\n\nint main() {\n    int num = 10;\n    int ans = lowest_set_bit(num);\n    cout << ans << endl;\n    return 0;\n}\nSalida:\n2\n\n",
    "complejidad_tiempo": null,
    "java": null,
    "cpp": null,
    "py": null,
    "orden": 4,
    "suborden": 0,
    "fecha_creacion": "2020-12-04 23:04:32",
    "fecha_modificacion": "2020-12-06 20:11:13"
  },
  {
    "ID": 111,
    "supergrupo": "BitWise",
    "tema": "Suma uno",
    "texto": "Sume uno a un número dado, el uso de los operadores como ‘+’, ‘-‘,’*’,’/’,’++’,’—‘…. Entre otros no está permitido.\nLa respuesta se consigue con algo de magia de bits.\nPara agregar 1 a un número x(como 0011000111), voltee todos los bits luego del cero de más a la derecha (bit 0) (obtenemos 0011000000) finalmente, voltee el cero de más a la derecha también (obtenemos 0011001000) para obtener la respuesta.\n",
    "complejidad_tiempo": "Mejor caso :    O(1)  Peor caso : O(1)  Promedio: O(1) ",
    "java": "// Programa Java en donde se agrega uno a\n// un número dado\n\npublic class AddOne {\n\n    static int addOne(int x) {\n        return -(~x);\n    }\n\n    public static void main(String[] args) {\n        System.out.println(addOne(13));\n    }\n}\n",
    "cpp": "#include <iostream>\nusing namespace std;\n\nstring decToBin(int n) {\n    if (n == 0)\n        return \"0\";\n    string bin = \"\";\n    int ayuda = n;\n    n = abs(n);\n    while (n > 0) {\n        bin = ((n & 1) == 0 ? '0' : '1') + bin;\n        n >>= 1;\n    }\n\n    return (ayuda < 0 ? bin = '-' + bin : bin);\n}\n\nint addOne(int x) {\n    return (-(~x));\n}\n\nint main() {\n    int a = 13;\n    cout << a << \" --> \" << decToBin(a) << endl;\n    a = addOne(a);\n    cout << a << \" --> \" << decToBin(a) << endl;\n    return 0;\n}\n",
    "py": "from sys import stdin, stdout\nrl = stdin.readline\nwr = stdout.write\n\ndef addOne(n):\n    wr(f'{n} -> {bin(n)[2:]}\\n')\n    n = (-(~n))\n    wr(f'{n} -> {bin(n)[2:]}\\n')\n\nn = int(rl())\naddOne(n)\n",
    "orden": 4,
    "suborden": 1,
    "fecha_creacion": "2020-12-04 23:04:32",
    "fecha_modificacion": "2020-12-06 20:11:13"
  },
  {
    "ID": 112,
    "supergrupo": "BitWise",
    "tema": "Comparación de signos",
    "texto": "Dado dos enteros con signo, retorne true si los signos de los enteros dados son diferentes, de otra forma retorne falso, por ejemplo la función debe retornar true en -1 y +100, y debe retornar falso para -200 y -100. La función no debe usar ningún operador aritmético.\nDejaremos los enteros dados ser x y y, el bit de signo es 1 en números negativos, y 0 en números positivos, El XOR de x y y puede tener el bit de signo en 1 si ellos tiene signos opuestos, en otras palabras, XOR de x y y será un número negativo si x y y tienen signos opuestos.\n",
    "complejidad_tiempo": "Mejor caso :    O(1)  Peor caso : O(1)  Promedio: O(1) ",
    "java": "//Programa Java para detectar si dos enteros\n//tienen signos opuestos\n\npublic class OppositeSigns {\n\n    static boolean oppositeSigns(int x, int y) {\n        return ((x ^ y) < 0);\n    }\n\n    public static void main(String[] args) {\n        int x = 100, y = -100;\n        if (oppositeSigns(x, y) == true) {\n            System.out.println(\"Signos opuestos\");\n        } else {\n            System.out.println(\"Signos no opuestos\");\n        }\n        x = 100;\n        y = 100;\n        if (oppositeSigns(x, y) == true) {\n            System.out.println(\"Signos son opuestos\");\n        } else {\n            System.out.println(\"Signos no son opuestos\");\n        }\n    }\n}\n",
    "cpp": "#include <iostream>\n\nusing namespace std;\n\nbool opposite(int a, int b) {\n    return (a ^ b) < 0;\n}\n\nint main() {\n    int a = 123;\n    int b = -123;\n    if (opposite(a, b)) {\n        cout << \"Distintos signos\" << endl;\n    } else {\n        cout << \"Iguales signos\" << endl;\n    }\n    return 0;\n}\n",
    "py": "from sys import stdin, stdout\nrl = stdin.readline\nwr = stdout.write\n\ndef opposite(n, m):\n    res = (n ^ m) < 0\n    if res:\n        wr(f'Distintos\\n')\n    else:\n        wr(f'Iguales\\n')\n\nn = 30\nm = -100\nopposite(n, m)\n",
    "orden": 4,
    "suborden": 2,
    "fecha_creacion": "2020-12-04 23:04:32",
    "fecha_modificacion": "2020-12-06 20:11:14"
  },
  {
    "ID": 113,
    "supergrupo": "BitWise",
    "tema": "Multiplicación básica",
    "texto": "Podemos multiplicar un número por 7 usando operadores BitWise, primero hacemos corrimiento izquierdo del número de 3 bits (Se obtendrá 8n) luego se resta la forma original del número corrido y se retorna la diferencia (8n-n).\nComplejidad de tiempo: O(1).\nFunciona solo para enteros positivos.\nEl mismo concepto puede ser usado para  multiplicación rápida por 9 u otros números cambiando la formula bitwise.\nPor ejemplo:\n• (n << 1)  = x2\n• ((n << 1) + n) = x3\n• (n << 2) = x4\n• ((n << 2) + n) = x5\n• ((n << 3) - (n << 1)) = x6\n• ((n << 3) - n) = x7\n• (n << 3) = x8\n• ((n << 3)+n) = x9\n• (n << 3)+(n<<1) = x10\n",
    "complejidad_tiempo": "Mejor caso :    O(1)  Peor caso : O(1)  Promedio: O(1) ",
    "java": "public class Multiply_2_to_10 {\n\n    public static void main(String[] args) {\n        int a = 18;\n        System.out.println(multiplyByTwo(a));\n        System.out.println(multiplyByThree(a));\n        System.out.println(multiplyByFour(a));\n        System.out.println(multiplyByFive(a));\n        System.out.println(multiplyBySix(a));\n        System.out.println(multiplyBySeven(a));\n        System.out.println(multiplyByEight(a));\n        System.out.println(multiplyByNine(a));\n        System.out.println(multiplyByTen(a));\n    }\n\n    static int multiplyByTwo(int n) {\n        return (n << 1);\n    }\n\n    static int multiplyByThree(int n) {\n        return ((n << 1) + n);\n    }\n\n    static int multiplyByFour(int n) {\n        return (n << 2);\n    }\n\n    static int multiplyByFive(int n) {\n        return ((n << 2) + n);\n    }\n\n    static int multiplyBySix(int n) {\n        return ((n << 3) - (n << 1));\n    }\n\n    static int multiplyBySeven(int n) {\n        return ((n << 3) - n);\n    }\n\n    static int multiplyByEight(int n) {\n        return (n << 3);\n    }\n\n    static int multiplyByNine(int n) {\n        return ((n << 3) + n);\n    }\n\n    static int multiplyByTen(int n) {\n        return (n << 3) + (n << 1);\n    }\n}\n",
    "cpp": "#include <iostream>\n//-------------//\n#define FAST ios_base::sync_with_stdio(false);cout.tie(NULL);\n\nusing namespace std;\n\nint multiplyByTwo(int n) {\n    return (n << 1);\n}\n\nint multiplyByThree(int n) {\n    return ((n << 1) + n);\n}\n\nint multiplyByFour(int n) {\n    return (n << 2);\n}\n\nint multiplyByFive(int n) {\n    return ((n << 2) + n);\n}\n\nint multiplyBySix(int n) {\n    return ((n << 3) - (n << 1));\n}\n\nint multiplyBySeven(int n) {\n    return ((n << 3) - n);\n}\n\nint multiplyByEight(int n) {\n    return (n << 3);\n}\n\nint multiplyByNine(int n) {\n    return ((n << 3) + n);\n}\n\nint multiplyByTen(int n) {\n    return (n << 3) + (n << 1);\n}\n\nint main() {\n    FAST;\n    int a = 9;\n    cout << multiplyByTwo(a) << endl;\n    cout << multiplyByThree(a) << endl;\n    cout << multiplyByFour(a) << endl;\n    cout << multiplyByFive(a) << endl;\n    cout << multiplyBySix(a) << endl;\n    cout << multiplyBySeven(a) << endl;\n    cout << multiplyByEight(a) << endl;\n    cout << multiplyByNine(a) << endl;\n    cout << multiplyByTen(a) << endl;\n    return 0;\n}\n",
    "py": "from sys import stdin, stdout\nrl = stdin.readline\nwr = stdout.write\n\ndef multiplyZero(n):\n    res = (n << 0) - n\n    wr(f'{n} x 0 = {res}\\n')\n\ndef multiplyOne(n):\n    res = (n << 1) - n\n    wr(f'{n} x 1 = {res}\\n')\n\ndef multiplyTwo(n):\n    res = (n << 1)\n    wr(f'{n} x 2 = {res}\\n')\n\ndef multiplyThree(n):\n    res = (n << 1)+n\n    wr(f'{n} x 3 = {res}\\n')\n\ndef multiplyFour(n):\n    res = (n << 2)\n    wr(f'{n} x 4 = {res}\\n')\n\ndef multiplyFive(n):\n    res = (n << 2)+n\n    wr(f'{n} x 5 = {res}\\n')\n\ndef multiplySix(n):\n    res = (n << 3)-(n << 1)\n    wr(f'{n} x 6 = {res}\\n')\n\ndef multiplySeven(n):\n    res = (n << 3)-n\n    wr(f'{n} x 7 = {res}\\n')\n\ndef multiplyEight(n):\n    res = (n << 3)\n    wr(f'{n} x 8 = {res}\\n')\n\ndef multiplyNine(n):\n    res = (n << 3)+n\n    wr(f'{n} x 9 = {res}\\n')\n\ndef multiplyTen(n):\n    res = (n << 3)+(n << 1)\n    wr(f'{n} x 10 = {res}\\n')\n\nn = int(rl())\nmultiplyZero(n)\nmultiplyOne(n)\nmultiplyTwo(n)\nmultiplyThree(n)\nmultiplyFour(n)\nmultiplyFive(n)\nmultiplySix(n)\nmultiplySeven(n)\nmultiplyEight(n)\nmultiplyNine(n)\nmultiplyTen(n)\n",
    "orden": 4,
    "suborden": 3,
    "fecha_creacion": "2020-12-04 23:04:33",
    "fecha_modificacion": "2020-12-06 20:11:15"
  },
  {
    "ID": 114,
    "supergrupo": "BitWise",
    "tema": "Cuadrado de N sin usar pow",
    "texto": "Dado un entero n, calcular el cuadrado de un número sin usar *,/ y pow().\nPodemos hacerlo en tiempo O(Logn) usando operadores de BitWise, la idea está basada en el siguiente hecho:\n- square(n) = 0 if n == 0\n  Si n es par \n-   square(n) = 4*square(n/2) \n  Si n es impar\n-    square(n) = 4*square(floor(n/2)) + 4*floor(n/2) + 1 \nPor ejemplo:\n- square(6) = 4*square(3)\n- square(3) = 4*(square(1)) + 4*1 + 1 = 9\n- square(7) = 4*square(3) + 4*3 + 1 = 4*9 + 4*3 + 1 = 49\nSi n es par, puede ser escrito como:\n-   n = 2*x \n-   n^2 = (2*x)2 = 4*x2\nSi n es impar, puede ser escrito como: \n- n = 2*x + 1\n-  n^2 = (2*x + 1)2 = 4*x2 + 4*x + 1\nfloor(n/2)  puede ser calculado usando el operados de BitWise corrimiento derecho.\n",
    "complejidad_tiempo": "Mejor caso :    O(1)  Peor caso : O(1)  Promedio: O(1) ",
    "java": "// Programa en java para calcular el cuadrado\n// Sin usar * ni Pow()\n\npublic class NSquareNoPow {\n\n    static int square(int n) {\n        // Caso base\n        if (n == 0) {\n            return 0;\n        }\n        if (n < 0) {\n            n = -n;\n        }\n        // Obtener floor(n/2) usando\n        // right shift \n        int x = n >> 1;\n        // si n es par\n        ;\n        if (n % 2 != 0) {\n            return ((square(x) << 2)\n                    + (x << 2) + 1);\n        } else// si n es impar\n        {\n            return (square(x) << 2);\n        }\n    }\n\n    public static void main(String args[]) {\n        for (int n = 1; n <= 5; n++) {\n            System.out.println(\"n = \" + n\n                    + \" n^2 = \"\n                    + square(n));\n        }\n    }\n}\n",
    "cpp": "#include<bits/stdc++.h>\n#include<cstdlib>\n#define c(x) cout<<x<<endl;\n#define cn(x) cout<<x;\n#define l(c) cin>>t;\nusing namespace std;\nint square(int n){\n    if(n==0){\n        return 0;\n    }\n    if(n<0){\n        n=-n;\n    }\n    int x=n>>1;\n    if((n&1)>0){\n        return ((square(x)<<2)+(x<<2)+1);\n    }else{\n        return (square(x)<<2);\n    }\n}\nint main() {\n    for(int i=0;i<10;i++){\n        c(square(i));\n    }\n}\n\n",
    "py": "from sys import stdin\nfrom sys import stdout\nrl = stdin.readline\nwr = stdout.write\n\ndef square(n):\n    if n == 0:\n        return 0\n    if n < 0:\n        n = -n\n    x = n >> 1\n    if n & 1:\n        return (square(x) << 2) + (x << 2) + 1\n    else:\n        return (square(x) << 2)\n\nfor i in range(11):\n    wr(f'{i} -> {square(i)}\\n')\n",
    "orden": 4,
    "suborden": 4,
    "fecha_creacion": "2020-12-04 23:04:33",
    "fecha_modificacion": "2020-12-06 20:11:15"
  },
  {
    "ID": 115,
    "supergrupo": "BitWise",
    "tema": "Palíndromo binario",
    "texto": "Encuentre el número cuya representación binaria es un palíndromo. No se consideran los ceros iniciales, Mientras se considera la representación binaria, considere el primer número cuya representación binaria es palíndroma como 1, en vez de 0.\nUna aproximación ingenua puede ser atravesar a través de todos los enteros desde 1 hasta 2^31-1 e incrementar el conteo palíndromo, si el número es palíndromo, cuando el conteo palíndromo alcanza el n requerido, rompe el ciclo y retorna el actual entero.\nLa complejidad de tiempo de esta solución es O(x) donde x es el número resultado. Note que el valor de x es generalmente más grande que n.\n",
    "complejidad_tiempo": "Mejor caso :    O(x)  Peor caso : O(x)  Promedio: O(x) ",
    "java": "/* Programa Java para buscar el Nesimo número el cual\nsu binario es un palíndromo*/\npublic class BinaryPalindromeN {\n\n    static int INT_MAX = 2147483647;\n    /*Busca si el kesimo bit esta \n    puesto en la representación binaria*/\n    static int isKthBitSet(int x, int k) {\n        return ((x & (1\n                << (k - 1))) > 0) ? 1 : 0;\n    }\n\n    /*Retorna la posicion de más a la izquierda\n    el set de bits en la representacion binaria*/\n    static int leftmostSetBit(int x) {\n        int count = 0;\n        while (x > 0) {\n            count++;\n            x = x >> 1;\n        }\n        return count;\n    }\n\n    /*Encuentra cuales sean los enteros en binario\n    siendo plindromos o no*/\n    static int isBinPalindrome(int x) {\n        int l = leftmostSetBit(x);\n        int r = 1;\n        //Uno a uno se comparan los bits\n        while (l > r) {\n        //Comprara bits de izquierda y derecha\n        // y converge \n            if (isKthBitSet(x, l)\n                    != isKthBitSet(x, r)) {\n                return 0;\n            }\n            l--;\n            r++;\n        }\n        return 1;\n    }\n\n    static int findNthPalindrome(int n) {\n        int pal_count = 0;\n        /*Comienza desde 1, atravieza por todos los\n        enteros*/\n        int i = 0;\n        for (i = 1; i <= INT_MAX; i++) {\n            if (isBinPalindrome(i) > 0) {\n                pal_count++;\n            }\n            /*Si nosotros llegamos n \n            rompe el ciclo*/\n            if (pal_count == n) {\n                break;\n            }\n        }\n        return i;\n    }\n\n    public static void main(String[] args) {\n        int n = 9;\n        System.out.println(findNthPalindrome(n));\n    }\n} \n",
    "cpp": null,
    "py": "from sys import maxsize\nfrom sys import stdin\nfrom sys import stdout\nrl = stdin.readline\nwr = stdout.write\n\ndef iskthBitSet(x, k):\n    return 1 if (x & (1 << (k-1))) > 0 else 0\n\ndef leftMostSetBit(x):\n    cont = 0\n    while x > 0:\n        cont += 1\n        x = x >> 1\n    return cont\n\ndef isBinPal(x):\n    l = leftMostSetBit(x)\n    r = 1\n    while l > r:\n        if iskthBitSet(x, 1) != iskthBitSet(x, r):\n            return 0\n        l -= 1\n        r += 1\n    return 1\n\ndef findNthPal(n):\n    pal_cont = 0\n    i = 0\n    for i in range(maxsize):\n        if isBinPal(i) > 0:\n            pal_cont += 1\n        if pal_cont == n:\n            break\n    return i\n\nstring = rl()\nn = int(string, 16)\nres = findNthPal(n)\nwr(f'{res} -> {bin(res)[2:]}')\n",
    "orden": 4,
    "suborden": 5,
    "fecha_creacion": "2020-12-04 23:04:33",
    "fecha_modificacion": "2020-12-06 20:11:16"
  },
  {
    "ID": 116,
    "supergrupo": "BitWise",
    "tema": "Número más cercano con los mismos bits",
    "texto": "Dado un entero positivo n, imprimir el siguiente más pequeño y el previo más largo que tiene el mismo número de bits 1 en su representación binaria.\nAproximación por fuerza bruta:\nUna simple aproximación es contar el número de 1 en n, y luego incrementar o decrementar hasta que encontremos un número con el mismo número de 1.\nAproximación optimizada:\nVamos a inicial con el código de getNext, y luego nos movemos a getPrev.\nAproximación de manipulación de bits para obtención del siguiente número:\nSi pensamos acerca cual será el siguiente número, podemos observar lo siguiente, dado el número 13948, su representación binaria es:\n1   1   0   1   1  0  0  1  1  1  1  1  0  0\n13  12  11  10  9  8  7  6  5  4  3  2  1  0\nBuscamos hacer este número más grande, pero no muy grande, también necesitamos mantener el mismo número de unos.\nNota: Dado un número N y dos localizaciones de bits i y j, suponga que volteamos bit i desde 1 a 0, y bit j desde 0 a 1, si i>j, entonces n podrá decrementarse, si i<j entonces n podrá incrementarse.\nSabemos lo siguiente:\n- Si volteamos un cero a un uno, debemos voltear un uno a un cero.\n- El número (Luego de dos volteretas) podría ser más grande si y solo si el bit cero a uno fue el izquierdo del bit uno a cero.\nNosotros queremos hacer el número más grande, pero no necesariamente más grande, por lo tanto necesitamos voltear el cero de más a la derecha el cual tiene unos en el derecho de él.\nPara pone resto en una forma diferente, nosotros estamos volteando el cero no final de más a la derecho, esto es usando el ejemplo de abajo, los ceros finales son en la primera y cero posición. El cero no final de más a la derecha es un bit 7, vamos a llamar esta posición p.\n- p -> posición de más a la derecha que no sea cero final.\nPaso 1: volteamos el cero más a la derecha no final.\n- 1    1   0   1  1  0  1  1  1  1  1  1  0  0\n- 13  12  11  10  9  8  7  6  5  4  3  2  1  0\nCon este cambio, hemos incrementado el número de unos en n, podemos encojer el número reordenando todos los bits de la derecha del bit p tales que los ceros están en la izquierda y los unos están a la derecha, cuando se hace esto, se busca reemplazar uno  de los unos con cero.\nUna forma relativamente fácil de hacer esto es contando cuantos unos están a la derecha de p, despejar todos los bits desde 0 hasta p, y luego agregar de nuevo en c1-1 unos. Dejar c1 ser el número de unos de la derecha de p y c0 el número de ceros de la derecha de p.\nVamos a verificar esto con un ejemplo:\n- c1-> Número de unos de la derecho de p\n- c0-> Número de ceros de la derecho de p\n- p = c0 + c1\nPaso 2: despejar los bits de la derecha de p, como antes c0 = 2. c1 = 5. p = 7.\n- 1    1   0   1  1  0  1  0  0  0  0  0  0  0\n- 13  12  11  10  9  8  7  6  5  4  3  2  1  0\nPara despejar estos bits, necesitamos crear una máscara que sea una secuencia de unos, seguido por p ceros, podemos hacer esto de la siguiente forma:\nTodos los ceros excepto por un 1 en la posición p.\n- a = 1 << p; \nTodos los ceros, seguidos por p unos. \n- b = a - 1;                       \nTodos los unos, seguidos por p ceros.\n- mask = ~b;                       \nDespeja los p bits de más a la derecha.\n- n = n & mask;                \nO más concisamente, hacemos: \n- n &= ~ ((1 << p) - 1).\nPaso 3: Agrega un c1=1 unos.\n- 1   1   0   1   1  0  1  0  0  0  1  1  1  1\n- 13  12  11  10  9  8  7  6  5  4  3  2  1  0\nPara insertar c1-1 unos a la derecha, se realiza:\nCeros con un uno en la posición c1– 1\n- a = 1 << (c1 - 1);    \nCeros con unos en posiciones cero a través de c1-1\n- b = a - 1;                \nInserta unos en las posiciones 0 a través de c1-1\n- n = n | b;                \nO más concisamente:\n- n | = (1 << (c1 - 1)) - 1;  \n",
    "complejidad_tiempo": "Mejor caso :    O(n)  Peor caso : O(n)  Promedio: O(n) ",
    "java": "/* Programa JAVA de busqueda del siguiente número con \nla misma cantidad de 1 que algun anterior*/\npublic class ClosestNumbersSamebits {\n\n    static int getNext(int n) {\n        // Computa c0 y c1\n        int c = n;\n        int c0 = 0;\n        int c1 = 0;\n        while (((c & 1) == 0)\n                && (c != 0)) {\n            c0++;\n            c >>= 1;\n        }\n        while ((c & 1) == 1) {\n            c1++;\n            c >>= 1;\n        }\n        /*Si no hay número más grande \n        con el número de 1 buscado*/\n        if (c0 + c1 == 31\n                || c0 + c1 == 0) {\n            return -1;\n        }\n        //Posicion de el más derecho cero \n        int p = c0 + c1;\n        //Voltea el zero más derecho\n        n |= (1 << p);\n        // Despeja todos los bits de la derecha de p\n        n &= ~((1 << p) - 1);\n        //Inserta los (c1-1) a la derecha\n        n |= (1 << (c1 - 1)) - 1;\n        return n;\n    }\n\n    static int getPrev(int n) {\n        int temp = n;\n        int c0 = 0;\n        int c1 = 0;\n        while ((temp & 1) == 1) {\n            c1++;\n            temp = temp >> 1;\n        }\n        if (temp == 0) {\n            return -1;\n        }\n        while (((temp & 1) == 0)\n                && (temp != 0)) {\n            c0++;\n            temp = temp >> 1;\n        }\n        // posicion de el cero no final de \n        // mas a la derecha\n        int p = c0 + c1;\n        //limpia del bit c hacia adelante \n        n = n & ((~0) << (p + 1));\n        // Secuencia de (c1+1) unos\n        int mask = (1 << (c1 + 1)) - 1;\n        n = n | mask << (c0 - 1);\n        return n;\n    }\n\n    public static void main(String[] args) {\n        int n = 5;\n        System.out.println(n + \"->\" + Integer.toString(n, 2) + \" \" + getNext(n));\n\n        System.out.println(n + \"->\" + Integer.toString(n, 2) + \" \" + getPrev(n));\n    }\n}\n",
    "cpp": "#include<bits/stdc++.h>\n#include<cstdlib>\n//---------------//\nusing namespace std;\nint getNext(int n){\n    int c=n;\n    int c0=0;\n    int c1=0;\n    while((c&1)==0 && (c!=0)){\n        c0++;\n        c >>=1;\n    }\n    while((c&1)==1){\n        c1++;\n        c >>=1;\n    }\n    if(c0+c1 ==31 || c0+c1==0){\n        return -1;\n    }\n    int p=c0+c1;\n    n|=(1<<p);\n    n&=~((1<<p)-1);\n    n|=(1<<(c1-1))-1;\n    return n;\n}\n\nint getPrev(int n){\n    int temp=n;\n    int c0=0;\n    int c1=0;\n    while((temp&1)==1){\n        c1++;\n        temp >>=1;\n    }\n    if(temp==0){\n        return -1;\n    }\n    while(((temp&1)==0) && (temp!=0)){\n        c0++;\n        temp >>=1;\n    }\n    int p=c0+c1;\n    n&=((~0)<<(p+1));\n    int mask=(1<<(c1+1))-1;\n    n|=mask<<(c0-1);\n    return n;\n}\nint main() {\n    int n=5;\n    cout<<(getNext(n))<<endl;\n    n=5;\n    cout<<(getPrev(n))<<endl;\n}\n",
    "py": "from sys import stdin, stdout\nrl = stdin.readline\nwr = stdout.write\n\n\ndef getNext(n):\n    c = n\n    c0 = 0\n    c1 = 0\n    while (c & 1 == 0) and (c != 0):\n        c0 += 1\n        c >>= 1\n    while (c & 1) == 1:\n        c1 += 1\n        c >>= 1\n    if (c0 + c1 == 31) or (c0 + c1 == 0):\n        return -1\n    p = c0 + c1\n    # Mascaras de Bits\n    n |= (1 << p)\n    n &= ~((1 << p)-1)\n    n |= (1 << (c1-1))-1\n    return n\n\n\ndef getPrev(n):\n    temp = n\n    c0 = 0\n    c1 = 0\n    while (temp & 1) == 1:\n        c1 += 1\n        temp = temp >> 1\n    if temp == 0:\n        return -1\n    while (temp & 1 == 0) and (temp != 0):\n        c0 += 1\n        temp = temp >> 1\n    p = c0 + c1\n    n &= ((~0) << (p + 1))\n    mask = (1 << (c1 + 1)) - 1\n    n |= mask << (c0 - 1)\n    return n\n\n\nn = int(rl())\nwr(f'{n} -> {bin(n)[2:]}\\n')\nwr(f'{getNext(n)} -> {bin(getNext(n))[2:]}\\n')\nwr(f'{getPrev(n)} -> {bin(getPrev(n))[2:]}')\n",
    "orden": 4,
    "suborden": 6,
    "fecha_creacion": "2020-12-04 23:04:34",
    "fecha_modificacion": "2020-12-06 20:11:16"
  },
  {
    "ID": 117,
    "supergrupo": "BitWise",
    "tema": "Códigos de Gray a Binario e inversos",
    "texto": "Números binarios es la forma por defecto para almacenar números, pero en muchas aplicaciones los números binarios son difíciles de usar y una variación de los números binarios es necesaria, aquí es cuando los códigos de Gray son muy útiles.\nEl código de gray tiene una propiedad, dos números sucesivos difieren en un solo bit porque esta propiedad permite tener ciclo a través de varios estados con un esfuerzo mínimo y son usados en mapas k, también permiten corrección de errores, comunicación entre  muchas cosas más.\n¿Cómo generar códigos de Gray de n bits?\nLa siguiente es la secuencia de dos bits (n=2)\n-   00 01 11 10\nLa siguiente es la secuencia de 3 bits (n = 3)\n- 000 001 011 010 110 111 101 100\nY la siguiente es la secuencia de 4 bits (n = 4)\n- 0000 0001 0011 0010 0110 0111 0101 0100 1100 1101 1111 1110 1010 1011 1001 1000\nLos códigos de Gray de n bits pueden ser generados de la lista de (n-1) códigos de Gray con los siguientes pasos.\n- Dejar la lista de (n-1)bits ser L1, crear otra lista L2 la cual es la reversa de L1\n- Modificar la lista L1 usando prefijo ‘0’ en todos los códigos de L1\n- Concatene L1 y L2. La lista concatenada es la lista requerida de los códigos de Gray de n bits\nEn ciencias de la computación muchas veces necesitamos convertir de código binario a código de Gray y viceversa, esta conversion puede ser realizada bajo las siguientes reglas:\nConversión de binario a Gray:\nEl bit más significante (MSB most significant bit) del código de gray es siempre igual a el MSB del código binario dado.\nOtros bits de la salida del código de gray pueden ser obtenidos realizando XOR al bit del código binario en ese índice y en el índice anterior.\nConversión de Gray a binario: \nEl MSB del código binario es siempre igual al MSB del código de Gray.\nLos otros bits de la salida del código binario pueden ser obtenidos verificando el bit del código Gray en ese incide, si el bit actual es 0, entonces copia el anterior bit del código binario, si no copia el inverso del anterior bit del código binario.\n",
    "complejidad_tiempo": "Mejor caso :    O(n2)  Peor caso : O(n2)  Promedio: O(n2) ",
    "java": "// Programa en java para coversion binario - Gray e inverso\n\nimport java.io.*;\n\npublic class CodeConversionGrayToBinary {\n\n    public static void main(String args[]) throws IOException {\n\n        String binary = \"01001\";\n        System.out.println(\"Codigo gray de \" + binary + \" is \" + binarytoGray(binary));\n\n        String gray = \"01101\";\n        System.out.println(\"Codigo Binaruo de \" + gray + \" is \" + graytoBinary(gray));\n    }\n\n    static char xor_c(char a, char b) {\n        return (a == b) ? '0' : '1';\n    }\n    //Funcion para voltear el bit \n\n    static char flip(char c) {\n        return (c == '0') ? '1' : '0';\n    }\n    //Funcion binario a gray\n\n    static String binarytoGray(String binary) {\n        String gray = \"\";\n        gray += binary.charAt(0);\n        // Coomputa bits restantes, siguiente bit es conmutado haciendole\n        // XOR del previo con el actual en binario\n        for (int i = 1; i < binary.length(); i++) {\n            /*Comcatena XOR del bit anterior con el actual*/\n            gray += xor_c(binary.charAt(i - 1),\n                    binary.charAt(i));\n        }\n        return gray;\n    }\n    //Funcion gray a binario\n    static String graytoBinary(String gray) {\n        String binary = \"\";\n        binary += gray.charAt(0);\n        // Computa bits restantes,\n        for (int i = 1; i < gray.length(); i++) {\n            //Si el bit actual es 0, concatena el bit anterior\n            if (gray.charAt(i) == '0') {\n                binary += binary.charAt(i - 1);\n            } //Sino, concatena invertidamente el bit anterior\n            else {\n                binary += flip(binary.charAt(i - 1));\n            }\n        }\n        return binary;\n    }\n}\n",
    "cpp": "#include<bits/stdc++.h>\n#include<cstdlib>\n//---------------//\nusing namespace std;\nchar xor_c(char a,char b){\n    return (a==b)?'0':'1';\n}\nchar flip(char c){\n    return (c==0)?'1':'0';\n}\nstring grayToBinary(string gray){\n    string binary = \"\";\n    int tam = gray.size();\n    binary += gray[0];\n    for(int i = 1; i < tam; i++){\n        if(gray[i] == '0'){\n            binary += binary[i - 1];\n        }else{\n            binary += flip(binary[i - 1]);\n        }\n    }\n    return binary;\n}\nstring binaryToGrey(string binary){\n    string grey=\"\";\n    grey+=binary[0];\n    for(int i=1;i<binary.size();i++){\n        grey+=xor_c((binary[i-1]),(binary[i]));\n    }\n    return grey;\n}\nint main() {\n    string n=\"01001\";\n    cout<<(binaryToGrey(n))<<endl;\n    n=\"01001\";\n    cout<<(grayToBinary(n))<<endl;\n}\n",
    "py": "from sys import stdin, stdout\nrl = stdin.readline\nwr = stdout.write\n\ndef binarytoGray(binary):\n    gray = ''\n    gray += binary[0]\n    for i in range(1, len(binary)):\n        gray += xor_c(binary[i-1], binary[i])\n    return gray\n\ndef xor_c(a, b):\n    return '0' if a == b else '1'\n\ndef flip(c):\n    return '1' if c == '0' else '0'\n\ndef graytoBinary(gray):\n    binary = ''\n    binary += gray[0]\n    for i in range(1, len(gray)):\n        if gray[i] == '0':\n            binary += binary[i-1]\n        else:\n            binary += flip(binary[i-1])\n    return binary\n\nb1 = '01001'\nres = binarytoGray(b1)\nwr(f'{b1} -> {res}\\n')\nres2 = graytoBinary(res)\nwr(f'{res} -> {res2}')\n",
    "orden": 4,
    "suborden": 7,
    "fecha_creacion": "2020-12-04 23:04:34",
    "fecha_modificacion": "2020-12-06 20:11:17"
  },
  {
    "ID": 118,
    "supergrupo": "BitWise",
    "tema": "Códigos de Gray de N bits",
    "texto": "Dado un número n, generar los patrones de bits de 0 a 2^n-1 de los cuales cada patrón sucesivo difiera en uno solo bit.\nLos códigos de Gray de n bits pueden ser generados de la lista de (n-1) códigos de Gray con los siguientes pasos.\n- Dejar la lista de (n-1)bits ser L1, crear otra lista L2 la cual es la reversa de L1\n- Modificar la lista L1 usando prefijo ‘0’ en todos los códigos de L1\n- Concatene L1 y L2. La lista concatenada es la lista requerida de los códigos de Gray de n bits\nPor ejemplo, los siguientes son los pasos para generar el código de Gray de 3 bits desde la lista de códigos de Gray de 2 bits.\n- L1 = {00, 01, 11, 10} (Lista de Gray de dos bits)\n- L2 = {10, 11, 01, 00} (Reversa de  L1)\n- Agrega prefijo a todas las entradas de L1 con ‘0’, L1 se convierte en {000, 001, 011, 010}\n- Agrega prefijo a todas las entradas de L2 con ‘1’, L2 se convierte en {110, 111, 101, 100}\n- Concatena L1 y L2, obtenemos {000, 001, 011, 010, 110, 111, 101, 100}\nPara generar los códigos de Gray de n bits, empezamos desde la lista de Grays de un solo bit, la cual es {0,1}, repetimos los pasos de arriba para general la lista de 2 bits a partir de la de 1 solo bit, luego generamos la de 3 bits a partir de la de 2 bits, y así hasta que el número de bits sea igual a n.\n",
    "complejidad_tiempo": "Mejor caso :    O(nlog(n))  Peor caso : O(nlog(n))  Promedio: O(nlog(n)) ",
    "java": "//Programa Java para generar codigos de Gray Nesimos  \n\nimport java.util.ArrayList;\n\npublic class GrayCodesOfN {\n\n    static void generateGrayarr(int n) {\n        // Caso base\n        if (n <= 0) {\n            return;\n        }\n        // 'arr' podria almacenar todos los codigos generados \n        ArrayList<String> arr = new ArrayList<String>();\n        // Comienza con un patron de un bit \n        arr.add(\"0\");\n        arr.add(\"1\");\n        /* Cada iteracion de este ciclo genera 2*i codigos desde los \n        i codigos generados previamente*/\n        int i, j;\n        for (i = 2; i < (1 << n); i = i << 1) {\n            /*Entra los previamente generados codigos de nuevo a arr[]\n                en orden reverso, arr[] tiene el doble de número de codigos*/\n            for (j = i - 1; j >= 0; j--) {\n                arr.add(arr.get(j));\n            }\n            // Concatena 0 a la primera mitad\n            for (j = 0; j < i; j++) {\n                arr.set(j, \"0\" + arr.get(j));\n            }\n            // Concatena 1 a la segunda mitad\n            for (j = i; j < 2 * i; j++) {\n                arr.set(j, \"1\" + arr.get(j));\n            }\n        }\n        // Imprime el contenido de arr\n        for (i = 0; i < arr.size(); i++) {\n            System.out.println(arr.get(i));\n        }\n    }\n\n    public static void main(String[] args) {\n        generateGrayarr(3);\n    }\n}\n",
    "cpp": "#include<bits/stdc++.h>\n#include<cstdlib>\n//---------------//\nusing namespace std;\nvoid generateGray(int n){\n    if(n<=0){\n        return;\n    }\n    vector<string>arr;\n    arr.push_back(\"0\");\n    arr.push_back(\"1\");\n    for(int i=2;i<(1<<n);i <<=1){\n        for(int j = i-1;j>=0;j--){\n            arr.push_back(arr[j]);\n        }\n        for(int j=0;j<i;j++){\n            arr[j]=\"0\"+arr[j];\n        }\n        for(int j=i;j<2*i;j++){\n            arr[j]=\"1\"+arr[j];\n        }\n    }\n    for(int i=0;i<arr.size();i++){\n        cout<<arr[i]<<endl;\n    }\n}\nint main(){\n    generateGray(5);\n}\n",
    "py": "from sys import stdin, stdout\nrl = stdin.readline\nwr = stdout.write\n\ndef generateGray(n):\n    if n <= 0:\n        return\n    arr = []\n    arr.append('0')\n    arr.append('1')\n    i = 2\n    j = 0\n    while i < (1 << n):\n        for j in range(i-1, -1, -1):\n            arr.append(arr[j])\n        for j in range(0, i):\n            arr[j] = '0' + arr[j]\n        for j in range(i, 2*i):\n            arr[j] = '1' + arr[j]\n        i = i << 1\n    for i in range(len(arr)):\n        wr(f'{arr[i]}\\n')\n\ngenerateGray(5)\n",
    "orden": 4,
    "suborden": 8,
    "fecha_creacion": "2020-12-04 23:04:34",
    "fecha_modificacion": "2020-12-06 20:11:18"
  },
  {
    "ID": 119,
    "supergrupo": "BitWise",
    "tema": "Conteo de bits a activar para que  A sea B",
    "texto": "Dados dos números ‘a’ y ‘b’, contar el número de bits necesarios a voltear para convertir ‘a’ en ‘b’.\n1) Calcular el XOR de A y B:  a_xor_b = A ^ B\n2) Contar los bits encendidos de lo de arriba\nResultado:\n        countSetBits(a_xor_b)\nXOR de dos números tendrá bits encendidos solo en esos lugares donde A difiera de B\n",
    "complejidad_tiempo": "Mejor caso :    O(bits)  Peor caso : O(bits)  Promedio: O(bits) ",
    "java": "//Contar el número de bits que van a ser volteados para convertir A en B  \n\npublic class CountAtoB {\n\n    public static int countSetBits(int n) {\n        int count = 0;\n        while (n != 0) {\n            count += n & 1;\n            n >>= 1;\n        }\n        return count;\n    }\n\n    public static int FlippedCount(int a, int b) {\n        //Retorna el conteo del set de bits en a XOR b \n        return countSetBits(a ^ b);\n    }\n\n    public static void main(String[] args) {\n        int a = 10;\n        int b = 20;\n        System.out.print(FlippedCount(a, b));\n    }\n}\n",
    "cpp": "#include<bits/stdc++.h>\n#include<cstdlib>\n//---------------//\nusing namespace std;\nint countSetBits(int n){\n    int cont=0;\n    while(n!=0){\n        cont+=n&1;\n        n>>=1;\n    }\n    return cont;\n}\nint flippedCount(int a,int b){\n    return countSetBits(a^b);\n}\nstring toBinary(int n){\n    string r;\n    while(n!=0) {r=(n%2==0 ?\"0\":\"1\")+r; n/=2;}\n    return r;\n}\nint main(){\n    int a=5;\n    int b=100;\n    cout<<a<<\"->\"<<toBinary(a)<<endl;\n    cout<<b<<\"->\"<<toBinary(b)<<endl;\n    cout<<flippedCount(a,b)<<endl;\n}\n\n",
    "py": "from sys import stdin, stdout\nrl = stdin.readline\nwr = stdout.write\n\ndef countSetBits(n):\n    count = 0\n    while n != 0:\n        count += n & 1\n        n >>= 1\n    return count\n\ndef flipperCount(a, b):\n    return countSetBits(a ^ b)\n\na = 50\nb = 100\nwr(f'{a} -> {bin(a)[2:]}\\n')\nwr(f'{b} -> {bin(b)[2:]}\\n')\nwr(f'{flipperCount(a,b)}')\n",
    "orden": 4,
    "suborden": 9,
    "fecha_creacion": "2020-12-04 23:04:35",
    "fecha_modificacion": "2020-12-06 20:11:18"
  },
  {
    "ID": 120,
    "supergrupo": "BitWise",
    "tema": "Conteo de bits activos ",
    "texto": "Dado un entero positivo n, cuente el número total de bits encendidos en representación binaria de todos los números de 1 a n.\nUna solución simple es correr un ciclo desde 1 hasta n y sumar el conteo de todos los números de 1 a n.\n",
    "complejidad_tiempo": "Mejor caso :    O(n)  Peor caso : O(n)  Promedio: O(n) ",
    "java": "//Un programa simpre que cuenta los bits set (Encendidos)\n//en todos los números de 1 a n.\n\npublic class CountSetBits {\n\n    static int countSetBits(int n) {\n        int bitCount = 0;\n        for (int i = 1; i <= n; i++) {\n            bitCount += countSetBitsUtil(i);\n        }\n        return bitCount;\n    }\n   \n    static int countSetBitsUtil(int x) {\n        if (x <= 0) {\n            return 0;\n        }\n        return (x % 2 == 0 ? 0 : 1)\n                + countSetBitsUtil(x / 2);\n    }\n\n    public static void main(String[] args) {\n        int n = 4;\n        System.out.print(\"Conteo total del set de bits es \");\n        System.out.print(countSetBits(n));\n    }\n}\n",
    "cpp": "#include<bits/stdc++.h>\n#include<cstdlib>\n//---------------//\nusing namespace std;\nstring toBinary(int n){\n    string r;\n    while(n!=0) {r=(n%2==0 ?\"0\":\"1\")+r; n/=2;}\n    return r;\n}\nint countSetBitUtil(int x){\n    if(x<=0){\n        return 0;\n    }\n    return (x%2==0?0:1)+countSetBitUtil(x/2);\n}\nint countBitSetBits(int n){\n    int bitCount=0;\n    for(int i=1;i<=n;i++){\n        cout<<i<<\"->\"<<toBinary(i)<<endl;\n        bitCount+=countSetBitUtil(i);\n    }\n    return bitCount;\n}\nint main(){\n    int n=4;\n    cout<<countBitSetBits(n)<<endl;\n}\n\n",
    "py": "from sys import stdin, stdout\nrl = stdin.readline\nwr = stdout.write\n\ndef countSetBit(n):\n    bitcount = 0\n    for i in range(1, n+1):\n        wr(f'{i} -> {bin(i)[2:]}\\n')\n        bitcount += countSetBitsUtil(i)\n    return bitcount\n\ndef countSetBitsUtil(x):\n    if x <= 0:\n        return 0\n    return (0 if (x & 1 == 0) else 1) + countSetBitsUtil(x//2)\n\nn = 5\nwr(f'{countSetBit(n)}')\n",
    "orden": 4,
    "suborden": 10,
    "fecha_creacion": "2020-12-04 23:04:35",
    "fecha_modificacion": "2020-12-06 20:11:19"
  },
  {
    "ID": 121,
    "supergrupo": "BitWise",
    "tema": "Euclides sin modulo ni división",
    "texto": "El algoritmo de Euclides es usado para encontrar el GCD de dos números.\nLa idea es usar operaciones de BitWise, podemos encontrar x/2 usando x>>1. Podemos verificar si x es par o impar usando x&1.\n- gcd(a, b) = 2*gcd(a/2, b/2) si ambos a y b son pares.\n- gcd(a, b) = gcd(a/2, b)  si a es par y b es impar.\n- gcd(a, b) = gcd(a, b/2) si a es impar y b es par.\n",
    "complejidad_tiempo": "Mejor caso :    O(log(n))  Peor caso : O(log(n))  Promedio: O(log(n)) ",
    "java": "//Programa Java eficiente para realizar maximo comun divisor sin % y /\n\npublic class EuclidNoModAndDivide {\n\n    public static void main(String[] args) {\n        System.out.println(gcd(8, 9));\n    }\n\n    static int gcd(int a, int b) {\n        // Casos base\n        if (b == 0 || a == b) {\n            return a;\n        }\n        if (a == 0) {\n            return b;\n        }\n        /*Si ambos a y b son pares, divide ambos por 2\n        y multiplica el resultado con 2*/\n        if ((a & 1) == 0 && (b & 1) == 0) {\n            return gcd(a >> 1, b >> 1) << 1;\n        }\n        //Si a es par, y b es impar, divide a por 2\n        if ((a & 1) == 0 && (b & 1) != 0) {\n            return gcd(a >> 1, b);\n        }\n        //Si a es impar y b es par, divide b por 2\n        if ((a & 1) != 0 && (b & 1) == 0) {\n            return gcd(a, b >> 1);\n        }\n        /*Si ambos son impares, entonces aplica el algoritmode \n        resta normal, notese que el casp impar-impar siempre \n        convierte casos impar-par  luego de una recursion*/\n        return (a > b) ? gcd(a - b, b) : gcd(a, b - a);\n    }\n}\n",
    "cpp": "#include<bits/stdc++.h>\n#include<cstdlib>\n//---------------//\nusing namespace std;\nint gcd(int a,int b){\n    if (b == 0 || a == 0) {\n        return a;\n    }\n    if (a == 0) {\n        return b;\n    }\n    if ((a & 1) == 0 && (b & 1) == 0) {\n        return gcd(a >> 1, b >> 1) << 1;\n    }\n    if ((a & 1) == 0 && (b & 1) != 0) {\n        return gcd(a >> 1, b);\n    }\n    if ((a & 1) != 0 && (b & 1) == 0) {\n        return gcd(a, b >> 1);\n    }\n    return (a > b) ? gcd(a - b, b) : gcd(a, b - a);\n}\nint main(){\n    cout<<gcd(50,30)<<endl;\n}\n",
    "py": "from sys import stdin, stdout\nrl = stdin.readline\nwr = stdout.write\n\ndef gcd(a, b):\n    if b == 0 or a == 0:\n        return a\n    if a == 0:\n        return b\n    if (a & 1 == 0) and (b & 1 == 0):\n        return gcd(a >> 1, b >> 1) << 1\n    if (a & 1 == 0) and (b & 1 != 0):\n        return gcd(a >> 1, b)\n    if (a & 1 != 0) and (b & 1 == 0):\n        return gcd(a, b >> 1)\n    return gcd(a - b, b) if a > b else gcd(a, b - a)\n\nwr(f'{gcd(50,10)}')\n",
    "orden": 4,
    "suborden": 11,
    "fecha_creacion": "2020-12-04 23:04:35",
    "fecha_modificacion": "2020-12-06 20:11:19"
  },
  {
    "ID": 122,
    "supergrupo": "BitWise",
    "tema": "Buscar duplicados usando un arreglo de bits",
    "texto": "Se tiene un arreglo de N números, donde n es al menos 32000, el array puede tener entradas duplicadas y no se sabe que N es.\nCon solo 4 kilobytes de memoria disponible, ¿cómo podría imprimir todos los elementos duplicados en el array?\nTenemos 4 kilobytes de memoria lo cual significa que podemos direccionar hasta 8*4*210 bits, note que 32*210 es más grande que 32000, podemos crear un array de bits con 32000 bits, donde cada bit representa un entero.\nSi se necesita crear un array de bit con más de 32000 bits entonces se puede crear fácilmente más y más de 32000.\nUsando este vector de bits, podemos entonces iterar a través del arreglo, marcando cada elemento v poniendo el bit v en 1, cuando pasemos por un elemento duplicado, los imprimimos.\n",
    "complejidad_tiempo": "Mejor caso :    O(n)  Peor caso : O(n)  Promedio: O(n) ",
    "java": "//Programa Java para imprimir todos los duplicados en un arreglo\n\npublic class FindDuplicatesBitArray {\n\n    static class BitArray {\n\n        int[] arr;\n        // Constructor \n        public BitArray(int n) {\n            /*Divide por 32, para almacenar n bits, nosotros necesitamos\n            n/32 +1 enteros (Asumiendo int esta almacenado usando 32 bits*/\n            arr = new int[(n >> 5) + 1];\n        }\n        // Obtener el valor de un bit en una posicion dada\n        boolean get(int pos) {\n            //Divide por 32 para encontrar la posicion del entero\n            int index = (pos >> 5);\n            //Ahora encuentra el bumero de bits en arr[index]\n            int bitNo = (pos & 0x1F);\n            //Encuentra el valor dado un número bit en arr[index]\n            return (arr[index] & (1 << bitNo)) != 0;\n        }\n        // Acomoda un bit en una posicion dada\n        void set(int pos) {\n            // Encuentra indice de una posicion de un bit\n            int index = (pos >> 5);\n            //Acomoda un número bot es arr[index] \n            int bitNo = (pos & 0x1F);\n            arr[index] |= (1 << bitNo);\n        }\n        // Funcion de impresion de los duplicados\n        static void checkDuplicates(int[] arr) {\n            // Crea un bit con 320000 bits\n            BitArray ba = new BitArray(320000);\n            // Arreglo transverso de los elementos\n            for (int i = 0; i < arr.length; i++) {\n                // Indice de un arreglo de bits \n                int num = arr[i] - 1;\n                //Si número ya se encuentra presente en el arreglo de bits\n                if (ba.get(num)) {\n                    System.out.print((num + 1) + \" \");\n                } // Si no inserte el número\n                else {\n                    ba.set(num);\n                }\n            }\n        }\n    }\n\n    public static void main(String[] args) {\n        int[] arr = {10, 10, 1, 1, 2, 2, 3, 3};\n        BitArray.checkDuplicates(arr);\n    }\n}\n",
    "cpp": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nstruct BitArray {\n    vector <int> arr;\n\n    BitArray(int n) {\n        arr.resize((n >> 5) + 1);\n    }\n\n    bool get(int pos) {\n        int index = (pos >> 5);\n        int bitNo = (pos & 0x1F);\n        return (arr[index] & (1 << bitNo)) != 0;\n    }\n\n    void setPos(int pos) {\n        int index = (pos >> 5);\n        int bitNo = (pos & 0x1F);\n        arr[index] |= (1 << bitNo);\n    }\n\n    void checkDuplicates(vector <int>& arr, BitArray ba) {\n        for (int i = 0; i < arr.size(); i++) {\n            int num = arr[i] - 1;\n            if (ba.get(num)) {\n                cout << (num + 1) << \" \";\n            } else {\n                ba.setPos(num);\n            }\n        }\n    }\n};\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n    cout.tie(NULL);\n    vector <int> arr{10, -10, -10, 8, 8, 5, 3, 4, 4, 3, 7, 9, -9, -8, -9};\n    BitArray ba(32000);\n    ba.checkDuplicates(arr, ba);\n    return 0;\n}\n",
    "py": "from sys import stdin, stdout\nrl = stdin.readline\nwr = stdout.write\n\nclass BitArray:\n    arr = []\n    def __init__(self, n):\n        self.arr = [0 for x in range((n >> 5)+1)]\n\n    def get(self, pos):\n        self.index = (pos >> 5)\n        self.bitNo = (pos & 0x1f)\n        return (self.arr[self.index] & (1 << self.bitNo)) != 0\n\n    def set(self, pos):\n        self.index = (pos >> 5)\n        self.bitNo = (pos & 0x1f)\n        self.arr[self.index] |= (1 << self.bitNo)\n\n    def checkDuplicates(self, arr):\n        for i in range(len(arr)):\n            num = arr[i]-1\n            if ba.get(num):\n                wr(f'{num+1} ')\n            else:\n                ba.set(num)\n\narr = [10, 10, 10, 5, 58, 8, 1, 5, 3, 2, 16, 4, 4]\nba = BitArray(32000)\nba.checkDuplicates(arr)\n",
    "orden": 4,
    "suborden": 12,
    "fecha_creacion": "2020-12-04 23:04:35",
    "fecha_modificacion": "2020-12-06 20:11:20"
  },
  {
    "ID": 123,
    "supergrupo": "BitWise",
    "tema": "Máximo de unos consecutivos",
    "texto": "Dado un entero n, pudiendo voltear exactamente un bit, encuentre la longitud de la secuencia más larga de 1 que se pueda crear.\nUna solución eficiente es andar a través de los bits en representación binaria del número dado, mantenemos rastreo de la longitud de la secuencia actual de unos, de la longitud de la secuencia de unos previa, cuando veamos un cero, actualizamos la longitud anterior:\n- Si el siguiente bit es un 1, la longitud anterior deberá ser ahora la longitud actual.\n- Si el siguiente bit es un 0, entonces no podemos unir esas secuencias juntas, entonces la longitud previa es 0.\nActualizamos la longitud máxima comparando las dos siguientes cosas:\n- Valor actual de max_lenght\n- Current-lenght+previos-length\nEntonces\n- result = return max-length+1 (// Agrega 1 para el Contador de bits volteados )\n",
    "complejidad_tiempo": "Mejor caso :    O(n)  Peor caso : O(n)  Promedio: O(n) ",
    "java": "//Programa java para buscar el subset de 1 más largo\n\npublic class MaxConsecutiveOne {\n\n    static int flipBit(int a) {\n        /*Si todos los bits son 1, la representacion de 'a'\n        tiene todos los unos*/\n        if (~a == 0) {\n            return 8 * sizeof();\n        }\n        int currLen = 0, prevLen = 0, maxLen = 0;\n        while (a != 0) {\n            /*Si el bit actual es un 1\n            entonces incrementa currLen++*/\n            if ((a & 1) == 1) {\n                currLen++;\n            } /*Si el bit actual es un 0\n            revisa el siguiente bit de a*/ else if ((a & 1) == 0) {\n                /*Actualiza prevLan a 0 (Si el siguiente bit es 0)\n                o currLen (Si el siguiente bit es 1)*/\n                prevLen = (a & 2) == 0 ? 0 : currLen;\n                /*Si dos bits consecutivos son 0\n                entonces currLen tambien sera 0*/\n                currLen = 0;\n            }\n            // Actualiza maxLen si es requerido \n            maxLen = Math.max(prevLen + currLen, maxLen);\n            //Remueve el ultimo digito (Right shift) \n            a >>= 1;\n        }\n        /*Nosotros siempre podremos tener un secuencia de \n        al menos un 1, este es un bit volteado*/\n        return maxLen + 1;\n    }\n\n    static byte sizeof() {\n        byte sizeOfInteger = 8;\n        return sizeOfInteger;\n    }\n\n    public static void main(String[] args) {\n        System.out.println(flipBit(13));\n        System.out.println(flipBit(1775));\n        System.out.println(flipBit(15));\n    }\n}\n",
    "cpp": "#include<bits/stdc++.h>\n#include<cstdlib>\n//---------------//\nusing namespace std;\nint SIZE(){\n    int sizeOfInteger=8;\n    return sizeOfInteger;\n}\nint flipBit(int a){\n    if(~a==0){\n        return 8*SIZE();\n    }\n    int currentlen=0,prevlen=0,maxlen=0;\n    while(a!=0){\n        if((a&1)==1){\n            currentlen++;\n        }\n        else if((a&1)==0){\n            prevlen=(a&2==0)?0:currentlen;\n            currentlen=0;\n        }\n        maxlen=std::max(prevlen+currentlen,maxlen);\n        a>>=1;\n    }\n    return maxlen+1;\n}\nstring toBinary(int n){\n    string r;\n    while(n!=0) {r=(n%2==0 ?\"0\":\"1\")+r; n/=2;}\n    return r;\n}\nint main(){\n    int a=654321;\n    cout<<a<<\"->\"<<toBinary(a)<<\" : \"<<flipBit(a)<<endl;\n\n}\n",
    "py": "from sys import stdin, stdout\nrl = stdin.readline\nwr = stdout.write\n\ndef flipBit(a):\n    if ~a == 0:\n        return 8 * sizeof()\n    currlen, prevlen, maxlen = 0, 0, 0\n    while a != 0:\n        if a & 1 == 1:  # Cambiar a 0\n            currlen += 1\n        elif a & 1 == 0:  # Cambiar a 1\n            prevlen = 0 if ((a & 2) == 0) else currlen\n            currlen = 0\n        maxlen = max(prevlen + currlen, maxlen)\n        a >>= 1\n    return maxlen + 1\n\ndef sizeof():\n    sizeOfInteger = 8\n    return sizeOfInteger\n\na = int(rl())\nwr(f'{a} -> {bin(a)[2:]}\\n')\nwr(f'{flipBit(a)}')\n",
    "orden": 4,
    "suborden": 13,
    "fecha_creacion": "2020-12-04 23:04:36",
    "fecha_modificacion": "2020-12-06 20:11:21"
  },
  {
    "ID": 124,
    "supergrupo": "BitWise",
    "tema": "Máximo XOR Subarray",
    "texto": "Dado un array de enteros, encontrar el valor máximo del Subarray XOR en el array dado. Una solución simple es usar dos ciclos para encontrar el XOR de todos los subarrays y retornar el máximo.",
    "complejidad_tiempo": "Mejor caso :    O(n2)  Peor caso : O(n2)  Promedio: O(n2) ",
    "java": "// Programa en JAVA para buscar el maximo subarreglo XOR  \n\npublic class MaxSubarrayXOR {\n\n    static int maxSubarrayXOR(int arr[], int n) {\n        int ans = Integer.MIN_VALUE; // Inicializar resultado \n        // Escogiendo puntos de inicio para los subarreglos\n        for (int i = 0; i < n; i++) {\n            // para guardar XOR del actual subarreglo\n            int curr_xor = 0;\n            // Escojiendo puntos finales de subarreglos empezando por i\n            for (int j = i; j < n; j++) {\n                curr_xor = curr_xor ^ arr[j];\n                ans = Math.max(ans, curr_xor);\n            }\n        }\n        return ans;\n    }\n\n    public static void main(String args[]) {\n        int arr[] = {8, 1, 2, 12};\n        int n = arr.length;\n        System.out.println(\"Maximo subarray XOR es \"\n                + maxSubarrayXOR(arr, n));\n    }\n}\n",
    "cpp": "#include<bits/stdc++.h>\n#include<cstdlib>\n//---------------//\nusing namespace std;\nint maxSubArrayXOR(int arr[],int n){\n    int ans=INT_MIN;\n    for(int i=0;i<n;i++){\n        int curr_xor=0;\n        for(int j=i;j<n;j++){\n            curr_xor = curr_xor ^ arr[j];\n            ans = std::max(ans, curr_xor);\n        }\n    }\n    return ans;\n}\nint main(){\n    int arr[] = {8, 1, 2, 12};\n    int n = sizeof (arr)/sizeof (arr[0]);\n    cout<<\"Maximo subarray XOR es \"<<maxSubArrayXOR(arr,n)<<endl;\n} \n",
    "py": null,
    "orden": 4,
    "suborden": 14,
    "fecha_creacion": "2020-12-04 23:04:36",
    "fecha_modificacion": "2020-12-06 20:11:21"
  },
  {
    "ID": 125,
    "supergrupo": "BitWise",
    "tema": "N número mágico",
    "texto": "Un número mágico es definido como un número el cual puede ser expresado como una potencia de 5 o la suma de potencias únicas de 5, algunos números mágicos son 5, 25, 30(5 + 25), 125, 130(125 + 5), ….\nSi revisamos cuidadosamente los números mágicos, pueden ser representados como 001, 010, 011, 100, 101, 110, entre otros, donde 001 es 0*pow(5,3)+0*pow(5,2)+1*pow(5,1), entonces básicamente necesitamos agregar potencias de 5 por cada bit dado en el entero dado n.\n",
    "complejidad_tiempo": "Mejor caso :    O(log(n))  Peor caso : O(log(n))  Promedio: O(log(n)) ",
    "java": "// Programa en java para buscar el Nsimo\n// número magico, un número magico esta definido como un número el cual puede ser expresado como\n// una potencia de 5 o suma de potencias unicas de 5\n// Algunos primeros número magicos son: 5, 25, 30(5 + 25), 125, 130(125 + 5), … en adelante\n\npublic class NMagicNumber {\n\n    static int nthMagicNo(int n) {\n        int pow = 1, answer = 0;\n        // Ir a traves de cada bit de n\n        while (n != 0) {\n            pow = pow * 5;\n            // Si el untimo bit de n esta puesto\n            if ((n & 1) == 1) {\n                answer += pow;\n            }\n            //Proceder con el siguiente bit \n            // 0 n= n/2 \n            n >>= 1;\n        }\n        return answer;\n    }\n\n    public static void main(String[] args) {\n        int n = 5;\n        System.out.println(\"Enesimo número\"\n                + \" magico es \" + nthMagicNo(n));\n    }\n} \n",
    "cpp": null,
    "py": null,
    "orden": 4,
    "suborden": 15,
    "fecha_creacion": "2020-12-04 23:04:37",
    "fecha_modificacion": "2020-12-06 20:11:22"
  },
  {
    "ID": 126,
    "supergrupo": "BitWise",
    "tema": "Intercambio de pares e impares",
    "texto": "Dado un entero sin signo, intercambia todos los bits pares con impares, por ejemplo si el número dado es 23 (00010111), puede ser convertido en 43 (00101011). Cada posición de bit par es intercambiada con el bit adyacente del lado de derecho, y cada posición impar es cambiada con el adyacente del lado izquierdo. \nSi realizamos una revisión en el ejemplo, podemos observar que básicamente necesitamos el corrimiento derecho (>>) de todos los bits pares por 1, entonces se convierten en bits impares, y corrimiento izquierdo (<<)  todos los bits impares por 1 entonces se convierten en pares, la siguiente solución está basada en estas ideas, se asume que el número de entrada está almacenado usando 32 bits.\nDejemos la entrada ser x.\n1) Obtener todos los bits pares de x realizando BitWise, y or de x con 0xAAAAAAAA, el número 0xAAAAAAAA es un entero de 32 bit con todos los bits pares ubicados en 1, y todos los impares en 0.\n2) Obtener todos los bits impares usando BitWise, y or de x con 0x55555555, el número 0x55555555 es un número entero de 32 bits con todos los bits impares en 1 y los pares en 0.\n3) Corrimiento derecho de todos los bits pares\n4) Corrimiento izquierdo de todos los bits impares\n5) Combina los nuevos pares e impares y retorna\n",
    "complejidad_tiempo": "Mejor caso :    O(1)  Peor caso : O(1)  Promedio: O(1) ",
    "java": "// Programa java para invertir bits pares  \n// e impares de un número dado\n\npublic class OddEvenSwap {\n\n    static int swapBits(int x) {\n        // Obtener todos los bits par de x \n        int even_bits = x & 0xAAAAAAAA;\n        //Obtener todos los bits impar de x \n        int odd_bits = x & 0x55555555;\n        //  Movimiento derecho de bits pares\n        even_bits >>= 1;\n        // Movimiento izquierdo de bits impares \n        odd_bits <<= 1;\n        // combinar pares e impares\n        return (even_bits | odd_bits);\n    }\n\n    public static void main(String[] args) {\n        int x = 23; // 00010111 \n        // La salida es 43 (00101011) \n        System.out.println(swapBits(x));\n    }\n}\n",
    "cpp": "#include<bits/stdc++.h>\n#include<cstdlib>\n//---------------//\nusing namespace std;\nint swapBits(int x){\n    int even_bits=x & 0xAAAAAAAA;\n    int oddbits=x & 0x55555555;\n    even_bits>>=1;\n    oddbits<<=1;\n    return (even_bits|oddbits);\n}\nstring toBinary(int n){\n    string r;\n    while(n!=0) {r=(n%2==0 ?\"0\":\"1\")+r; n/=2;}\n    return r;\n}\nint main(){\n   int x=7;\n   cout<<x<<\"->\"<<toBinary(x)<<endl;\n   int y=swapBits(x);\n   cout<<swapBits(x)<<\"->\"<<toBinary(y)<<endl;\n\n} \n\n",
    "py": null,
    "orden": 4,
    "suborden": 16,
    "fecha_creacion": "2020-12-04 23:04:37",
    "fecha_modificacion": "2020-12-06 20:11:23"
  },
  {
    "ID": 127,
    "supergrupo": "BitWise",
    "tema": "Ocurrencia impar",
    "texto": "Dado un array de enteros positivos, todos los números  ocurren número par de veces excepto un número el cual ocurre impar veces, encuentre el número en O(n) tiempo y espacio constante.\nUna solución simple es correr dos ciclos anidados, el ciclo externo toma todos los elementos uno por uno y el ciclo interno cuenta el número de las ocurrencias del elemento tomado en el ciclo externo, la complejidad de tiempo de esta solución es O(n^2).\nLa mejor solución es hacer XOR bit a bit de todos los elementos. Un XOR de todos los elementos nos muestra cuales elementos son impares. Tenga en cuenta que XOR de dos elementos es 0 si ambos elementos son iguales y XOR de un número x con 0 es x.\n",
    "complejidad_tiempo": "Mejor caso :    O(n)  Peor caso : O(n)  Promedio: O(n) ",
    "java": "//Programa JAVA para buscar la ocurrencia de un elemento\n// número impar de veces\n\npublic class OddOccurence {\n\n    static int getOddOccurrence(int ar[], int ar_size) {\n        int i;\n        int res = 0;\n        for (i = 0; i < ar_size; i++) {\n            res = res ^ ar[i];\n        }\n        return res;\n    }\n\n    public static void main(String[] args) {\n        int ar[] = new int[]{2, 3, 5, 4, 5, 2, 4, 3, 5, 2, 4, 4, 2};\n        int n = ar.length;\n        System.out.println(getOddOccurrence(ar, n));\n    }\n} \n",
    "cpp": null,
    "py": null,
    "orden": 4,
    "suborden": 17,
    "fecha_creacion": "2020-12-04 23:04:37",
    "fecha_modificacion": "2020-12-06 20:11:23"
  },
  {
    "ID": 128,
    "supergrupo": "BitWise",
    "tema": "Multiplicación Russian Peasant",
    "texto": "Dados dos enteros, multiplicar sin usar el operador de multiplicación.\nUna forma interesante es usar el algoritmo de la campesina rusa, la idea es duplicar el primer número y dividir en dos el segundo número repetidamente mientras el segundo número no se convierta en 1, en el proceso cuando el segundo número se vuelta impar, añadimos el primer número al resultado, el cual esta inicializado en 0.\nEl valor de a*b es el mismo que (a*2)*(b/2), si b es par, de otra forma el valor es el mismo de ((a*2)*(b/2) + a), en el ciclo while, seguimos multiplicando ‘a’ con dos y seguimos dividiendo ‘b’ por 2, si ‘b’ se convierte en impar en el ciclo, agregamos ‘a’ a ‘res’ cuando el valor de ‘b’ se convierta en 1, el valor de ‘res’ + ‘a’ nos da el resultado.\nNote que cuando ‘b’ es una potencia de 2, el ‘res’ puede mantenerse en 0 y ‘a’ puede ser la multiplicación.\n",
    "complejidad_tiempo": "Mejor caso :    O(n)  Peor caso : O(n)  Promedio: O(n) ",
    "java": "// Programa en java para multiplicar usando el algoritmo de  Russian Peasant  \n\npublic class RussianPeasantMultiply {\n    // Funcion para multiplicar dos números \n    static int russianPeasant(int a, int b) {\n        // Inicializar resultado\n        int res = 0;\n        //Mientras el segundo no se convierta en 1\n        while (b > 0) {\n            // Si el segundo número es  impar, \n            // añade el primer número al resultado \n            if ((b & 1) != 0) {\n                res = res + a;\n            }\n            // El doble del primer número\n            // y la mitad del segundo número \n            a = a << 1;\n            b = b >> 1;\n        }\n        return res;\n    }\n\n    public static void main(String[] args) {\n        System.out.println(russianPeasant(18, 1));\n        System.out.println(russianPeasant(20, 12));\n    }\n}\n",
    "cpp": "#include<bits/stdc++.h>\n#include<cstdlib>\n//---------------//\nusing namespace std;\n\nint RP(int a, int b) {\n    int res = 0;\n    while (b > 0) {\n        if ((b & 1) != 0) {\n            res += a;\n        }\n        a <<= 1;\n        b >>= 1;\n    }\n    return res;\n}\n\nint main() {\n    cout << (RP(2, 18)) << endl;\n}\n",
    "py": "from sys import stdin, stdout\nrl = stdin.readline\nwr = stdout.write\n\ndef RP(a, b):\n    res = 0\n    while b > 0:\n        if b & 1 != 0:\n            res += a\n        a <<= 1\n        b >>= 1\n    return res\n\na, b = int(rl()), int(rl())\nwr(f'{RP(a, b)}')\n",
    "orden": 4,
    "suborden": 18,
    "fecha_creacion": "2020-12-04 23:04:37",
    "fecha_modificacion": "2020-12-06 20:11:24"
  },
  {
    "ID": 129,
    "supergrupo": "BitWise",
    "tema": "Multiplicación de Karatsuba",
    "texto": "Dados dos strings binarios (bigIntegers) que representan el valor de dos enteros, encuentre el producto de los dos strings, por ejemplo, si el primer string de bits es “1100” y el segundo string de bits es “1010” la salida debe ser 120.\nPor simplicidad, dejaremos la longitud de ambos strings ser igual y ser n.\n- x=5678 y=1234 \n- a=56,b=78\n- c=12,d=34\nPaso 0 = m = n/2 + n%2\nPaso 1 = a*c\nPaso 2 = b*d\nPaso 3 = (a + b)*(c + d)\nPaso 4 = 3) - 2) - 1)\nPaso 5 = 1)*pow(10, m*2) + 2) + 4)*pow(10, m)\n",
    "complejidad_tiempo": "Mejor caso :    O(1)  Peor caso : O(1)  Promedio: O(1) ",
    "java": "//Programa JAVA que realiza multiplicaciones\n//Por medio del algoritmo de Karatsuba\n\nimport java.math.BigInteger;\nimport java.util.Scanner;\n\npublic class KaratsubaMultiply {\n\n    public static void main(String[] args) {\n        BigInteger x, y;\n        Scanner sc = new Scanner(System.in);\n        x = sc.nextBigInteger();\n        y = sc.nextBigInteger();\n\n        BigInteger result = karatsuba(x, y);\n        long result2 = karatsuba(x.longValue(), y.longValue());\n        System.out.println(result);\n        System.out.println(result2);\n    }\n\n    private static long karatsuba(long x, long y) {\n        if (x < 10 && y < 10) {\n            return x * y;\n        }\n        int n = Math.max(Long.valueOf(x).toString().length(), \n                (Long.valueOf(y).toString().length()));\n        int m = n / 2 + n % 2;\n        long a = x / (long) Math.pow(10, m);\n        long b = x % (long) Math.pow(10, m);\n        long c = y / (long) Math.pow(10, m);\n        long d = y % (long) Math.pow(10, m);\n        long step1 = karatsuba(a, c);\n        long step2 = karatsuba(b, d);\n        long step3 = karatsuba(a + b, c + d);\n        long step4 = step3 - step2 - step1;\n        long step5 = step1 * (long) Math.pow(10, m * 2) + step2 + step4 * \n                (long) Math.pow(10, m);\n        return step5;\n    }\n\n    private static BigInteger karatsuba(BigInteger x, BigInteger y) {\n        if (x.compareTo(BigInteger.valueOf(10)) < 0 && \n                y.compareTo(BigInteger.valueOf(10)) < 0) {\n            return x.multiply(y);\n        }\n        int n = Math.max(x.toString().length(), y.toString().length());\n        int m = n / 2 + n % 2;\n        BigInteger[] a_b = x.divideAndRemainder(BigInteger.valueOf(10).pow(m));\n        BigInteger a = a_b[0];\n        BigInteger b = a_b[1];\n        BigInteger[] c_d = y.divideAndRemainder(BigInteger.valueOf(10).pow(m));\n        BigInteger c = c_d[0];\n        BigInteger d = c_d[1];\n        BigInteger step1 = karatsuba(a, c);\n        BigInteger step2 = karatsuba(b, d);\n        BigInteger step3 = karatsuba(a.add(b), c.add(d));\n        BigInteger step4 = step3.subtract(step2).subtract(step1);\n        BigInteger step5 = \n                step1.multiply(BigInteger.valueOf(10).pow(m * 2)).add(step2)\n                .add(step4.multiply(BigInteger.valueOf(10).pow(m)));\n        return step5;\n    }\n}\n",
    "cpp": "#include<bits/stdc++.h>\n#include<cstdlib>\n//---------------//\nusing namespace std;\ntypedef long long int ll;\nll makeEqualLength(string &str1, string &str2) {\n    ll len1 = str1.size();\n    ll len2 = str2.size();\n    if (len1 < len2) {\n        for (ll i = 0 ; i < len2 - len1 ; i++)\n            str1 = '0' + str1;\n        return len2;\n    }\n    else if (len1 > len2) {\n        for (ll i = 0 ; i < len1 - len2 ; i++)\n            str2 = '0' + str2;\n    }\n    return len1;\n}\nstring addBitStrings( string first, string second ) {\n    string result;\n    ll length = makeEqualLength(first, second);\n    ll carry = 0;\n    for (ll i = length-1 ; i >= 0 ; i--) {\n        ll firstBit = first.at(i) - '0';\n        ll secondBit = second.at(i) - '0';\n        ll sum = (firstBit ^ secondBit ^ carry)+'0';\n        result = (char)sum + result;\n        carry = (firstBit&secondBit) | (secondBit&carry) | (firstBit&carry);\n    }\n    if (carry){\n        result = '1' + result;\n    }\n    return result;\n}\nll multiplyiSingleBit(string a, string b) {\n     return (a[0] - '0')*(b[0] - '0');\n}\nll karatsuba(string X, string Y) {\n    ll n = makeEqualLength(X, Y);\n    if (n == 0) return 0;\n    if (n == 1) return multiplyiSingleBit(X, Y);\n    ll fh = n/2;\n    ll sh = (n-fh);\n    string Xl = X.substr(0, fh);\n    string Xr = X.substr(fh, sh);\n    string Yl = Y.substr(0, fh);\n    string Yr = Y.substr(fh, sh);\n    ll P1 = karatsuba(Xl, Yl);\n    ll P2 = karatsuba(Xr, Yr);\n    ll P3 = karatsuba(addBitStrings(Xl, Xr), addBitStrings(Yl, Yr));\n    return P1*(1<<(2*sh)) + (P3 - P1 - P2)*(1<<sh) + P2;\n}\nstring toBinary(ll n){\n    string r;\n    while(n!=0) {r=(n%2==0 ?\"0\":\"1\")+r; n/=2;}\n    return r;\n}\nint main(){\n    ll a;\n    ll b;\n    cin>>a;\n    cin>>b;\n    string x=toBinary(a);\n    string y=toBinary(b);\n    cout<<karatsuba(x,y)<<endl;\n} \n",
    "py": null,
    "orden": 4,
    "suborden": 19,
    "fecha_creacion": "2020-12-04 23:04:38",
    "fecha_modificacion": "2020-12-06 20:11:24"
  },
  {
    "ID": 130,
    "supergrupo": "Grafos ",
    "tema": "Matriz de adyacencia",
    "texto": "La matriz de adyacencia es una matriz cuadrada que se utiliza como una forma de representar relaciones binarias, Se crea una matriz cero, cuyas columnas y filas representan los nodos del grafo. \n1) Por cada arista que une a dos nodos, se suma 1 al valor que hay actualmente en la ubicación correspondiente de la matriz.\n2) Si tal arista es un bucle y el grafo es no dirigido, entonces se suma 2 en vez de 1.\n3) Finalmente, se obtiene una matriz que representa el número de aristas (relaciones) entre cada par de nodos (elementos).\nExiste una matriz de adyacencia única para cada grafo (sin considerar las permutaciones de filas o columnas), y viceversa.\n- Para un grafo no dirigido la matriz de adyacencia es simétrica.\n- El número de caminos Ci,j(k), atravesando k aristas desde el nodo i al nodo j, viene dado por un elemento de la potencia k-ésima de la matriz de adyacencia: -\n- Ci,j(k)=[A^K]ij\nExisten otras formas de representar relaciones binarias, como por ejemplo los pares ordenados o los grafos.\n",
    "complejidad_tiempo": "Mejor caso :    O(n)  Peor caso : O(n)  Promedio: O(n) ",
    "java": "//Notacion java de una matriz de adyacencia\n\nimport java.util.Scanner;\n\npublic class AdyacencyMatrix {\n    //matriz del grafo\n    static int[][] G;\n    static Scanner sc = new Scanner(System.in);\n    public static void main(String[] args) {\n        //Vertices y caminos\n        int V = 4, E = 8;\n        G = new int[V][V];\n        for (int i = 0; i < V; i++) {\n            //desde hasta peso\n            int aux1, aux2, aux3;\n            aux1 = sc.nextInt();\n            aux2 = sc.nextInt();\n            aux3 = sc.nextInt();\n            // solo este si es dirigido\n            G[aux1][aux2] = aux3;\n            // inverso si es no dirigido\n            G[aux2][aux1] = aux3;\n        }\n        print(V);\n    }\n    //Función que imprime la matriz de adyacencia\n    static void print(int V) {\n        for (int i = 0; i < V; i++) {\n            for (int j = 0; j < V; j++) {\n                System.out.print(G[i][j] + \" \");\n            }\n            System.out.println(\"\");\n        }\n    }\n}\n",
    "cpp": "#include <bits/stdc++.h>\n#define MAX_V 101\nusing namespace std;\nstatic int G[MAX_V][MAX_V];\n\nint main() {\n    memset(G, 0, sizeof G);\n    int V, E;\n    cin >> V>>E;\n    memset(G, NULL, MAX_V);\n    for (int i = 0; i < E; ++i) {\n        int desde, hasta, peso;\n        cin >> desde>>hasta;\n        cin>>peso;\n        G[desde][hasta] = peso;\n        G[hasta][desde] = peso;\n    }\n    for (int i = 0; i < V; ++i) {\n        for (int j = 0; j < V; ++j) {\n            cout << G[i][j] << \"\\t\";\n        }\n        cout << endl;\n    }\n    return 0;\n}\n",
    "py": "from sys import stdin, stdout\nrl = stdin.readline\nwr = stdout.write\n\nV, E = rl().strip().split()\nV, E = int(V), int(E)\n\nG = [[-1 for x in range(V)] for x in range(V)]\nfor i in range(V):\n    G[i][i] = 0\n\nfor i in range(E):\n    desde, hasta, peso = rl().strip().split()\n    desde, hasta, peso = int(desde), int(hasta), int(peso)\n    G[desde][hasta] = peso\n    G[hasta][desde] = peso\n\nfor i in range(V):\n    for j in range(V):\n        if G[i][j] == -1:\n            wr(f'inf\\t')\n        else:\n            wr(f'{G[i][j]}\\t')\n    wr('\\n')\n",
    "orden": 8,
    "suborden": 0,
    "fecha_creacion": "2020-12-05 00:45:45",
    "fecha_modificacion": "2020-12-06 20:30:43"
  },
  {
    "ID": 131,
    "supergrupo": "Grafos ",
    "tema": "Lista de adyacencia",
    "texto": "En teoría de grafos, una lista de adyacencia es una representación de todas las aristas o arcos de un grafo mediante una lista.\nSi el grafo es no dirigido, cada entrada es un conjunto o multiconjunto de dos vértices conteniendo los dos extremos de la arista correspondiente. Si el grafo es dirigido, cada entrada es una tupla de dos nodos, uno denotando el nodo fuente y el otro denotando el nodo destino del arco correspondiente.\nTípicamente, las listas de adyacentes no son ordenadas.\n",
    "complejidad_tiempo": "Mejor caso :    O(n)  Peor caso : O(n)  Promedio: O(n) ",
    "java": "//Implementación java de una lista de adyacencia\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Scanner;\n\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Scanner;\n\npublic class Main {\n    static Vertex[] G;\n    static Scanner sc = new Scanner(System.in);\n\n    public static void main(String[] args) {\n        int V = sc.nextInt(), E = sc.nextInt();\n        G = new Vertex[V];\n        for (int i = 0; i < V; i++) {\n            G[i] = new Vertex();\n            G[i].adj = new ArrayList<>();\n        }\n        for (int i = 0; i < E; i++) {\n            int aux1, aux2, aux3;\n            aux1 = sc.nextInt();\n            aux2 = sc.nextInt();\n            aux3 = sc.nextInt();\n            //Dirigido\n            G[aux1].adj.add(new Edge(aux2, aux3));\n            //Descomentar para no dirigido\n            //G[aux2].adj.add(new Edge(aux1, aux3));\n        }\n        for (int i = 0; i < G.length; i++) {\n            System.out.print(i+\"->\" );\n            for (Edge e : G[i].adj) {\n                System.out.print(e.to + \" \" + e.w+\"|\");\n            }\n            System.out.println(\"\");\n        }\n    }\n\n    static class Vertex {\n        List<Edge> adj;\n        public Vertex() {\n            adj = new ArrayList<>();\n        }\n    }\n\n    static class Edge {\n        int to, w;\n        public Edge(int to, int w) {\n            this.to = to;\n            this.w = w;\n        }\n    }\n}\n",
    "cpp": "#include<bits/stdc++.h>\n#include<cstdlib>\n#define MAX_V 101\n\nusing namespace std;\n\nstruct Edge {\n    int to = 0, w = 0;\n\n    Edge(int _to, int _w) {\n        to = _to;\n        w = _w;\n    }\n};\n\nstruct Vertex {\n    list <Edge> adj;\n};\n\nstatic Vertex G[MAX_V];\n\nint main(int argc, char *argv[]) {\n    memset(G, 0, sizeof G);\n    int V, E;\n    scanf(\"%i %i\", &V, &E);\n    Vertex G [V];\n    for (int i = 0; i < V; i++) {\n        G[i] = Vertex();\n        G[i].adj;\n    }\n    for (int i = 0; i < E; i++) {\n        int desde, hasta, peso;\n        scanf(\"%i %i %i\", &desde, &hasta, &peso);\n        G[desde].adj.push_back(Edge(hasta, peso));\n        G[hasta].adj.push_back(Edge(desde, hasta));\n    }\n    int size = sizeof (G) / sizeof (G[0]);\n    for (int i = 0; i < size; i++) {\n        cout << i << \"-> \";\n        for (Edge e : G[i].adj) {\n            cout << e.to << \" \" << e.w << \"|\";\n        }\n        cout << \"\" << endl;\n    }\n    return 0;\n}\n",
    "py": null,
    "orden": 8,
    "suborden": 1,
    "fecha_creacion": "2020-12-05 00:45:45",
    "fecha_modificacion": "2020-12-06 20:30:44"
  },
  {
    "ID": 132,
    "supergrupo": "Grafos ",
    "tema": "DFS (Depth First Search)",
    "texto": "Una Búsqueda en profundidad (en inglés DFS o Depth First Search) es un algoritmo de búsqueda no informada utilizado para recorrer todos los nodos de un grafo o árbol (teoría de grafos) de manera ordenada, pero no uniforme. Su funcionamiento consiste en ir expandiendo todos y cada uno de los nodos que va localizando, de forma recurrente, en un camino concreto. Cuando ya no quedan más nodos que visitar en dicho camino, regresa (Backtracking), de modo que repite el mismo proceso con cada uno de los hermanos del nodo ya procesado.\nCompletitud: DFS es completo si y solo si usamos búsqueda basada en grafos en espacios de estado finitos, pues todos los nodos serán expandidos.\nOptimalidad: DFS en ningún caso asegura la optimalidad, pues puede encontrar una solución más profunda que otra en una rama que todavía no ha sido expandida.\nComplejidad temporal: en el peor caso, O(b^m) siendo b el factor de ramificación (número promedio de ramificaciones por nodo) y m la máxima profundidad del espacio de estados.\nComplejidad espacial: O(b^d) siendo b el factor de ramificación y d la profundidad de la solución menos costosa, pues cada nodo generado permanece en memoria, almacenándose la mayor cantidad de nodos en el nivel meta.\n",
    "complejidad_tiempo": "Mejor caso :    O(|v|+|e|)  Peor caso : O(|v|+|e|)  Promedio: O(|v|+|e|) ",
    "java": "// Programa java que imprime DFS transverso en un grafo\n\nimport java.util.*;\n\npublic class DFS {\n\n    public static void main(String args[]) {\n        Graph g = new Graph(4);\n        g.addEdge(0, 1);\n        g.addEdge(0, 2);\n        g.addEdge(1, 2);\n        g.addEdge(2, 0);\n        g.addEdge(2, 3);\n        g.addEdge(3, 3);\n        System.out.println(\"Siguiendo la primera busqueda en profundidad \"\n                + \"(iniciando desde vertice  2)\");\n        g.DFS(2);\n    }\n\n    static class Graph {\n        private int V;  // número de vertices \n        // Array de listas de adyacencia\n        private LinkedList<Integer> adj[];\n        Graph(int v) {\n            V = v;\n            adj = new LinkedList[v];\n            for (int i = 0; i < v; ++i) {\n                adj[i] = new LinkedList();\n            }\n        }\n        //Agregando caminos\n        void addEdge(int v, int w) {\n            adj[v].add(w);\n        }\n        void DFSUtil(int v, boolean visited[]) {\n            // Marca el nodo actual como visitado y lo imprime\n            visited[v] = true;\n            System.out.print(v + \" \");\n            // Recorre todos los vertices adyacentes a este vertice\n            Iterator<Integer> i = adj[v].listIterator();\n            while (i.hasNext()) {\n                int n = i.next();\n                if (!visited[n]) {\n                    DFSUtil(n, visited);\n                }\n            }\n        }\n        void DFS(int v) {\n            //Marca todos los vertices como no visitados (Falso)\n            boolean visited[] = new boolean[V];\n            DFSUtil(v, visited);\n        }\n\n    }\n}\n",
    "cpp": null,
    "py": "class Grafo:\n    V = 0\n    adj = [[], [], [], [], [], []]\n    def addEdge(self, v, w):\n        self.adj[v].append(w)\n    def DFSUtil(self, v, visited=[]):\n        visited[v] = True\n        print(v, \" \")\n        for i in range(len(self.adj[v])):\n            n = self.adj[v][i]\n            if not visited[n]:\n                self.DFSUtil(n, visited)\n    def DFS(self, v):\n        visited = [False, False, False, False, False, False]\n        self.DFSUtil(v, visited)\n\ng = Grafo()\ng.V = 4\ng.addEdge(0, 1)\ng.addEdge(0, 2)\ng.addEdge(1, 2)\ng.addEdge(2, 0)\ng.addEdge(2, 3)\ng.addEdge(3, 3)\ninicial = 0\nprint(\"Nodo inicial\" + str(inicial))\ng.DFS(inicial)\n",
    "orden": 8,
    "suborden": 2,
    "fecha_creacion": "2020-12-05 00:45:46",
    "fecha_modificacion": "2020-12-06 20:30:44"
  },
  {
    "ID": 133,
    "supergrupo": "Grafos ",
    "tema": "BFS (Breath First Search)",
    "texto": "Búsqueda en anchura (en inglés BFS - Breadth First Search) es un algoritmo de búsqueda no informada utilizado para recorrer o buscar elementos en un grafo (usado frecuentemente sobre árboles). Intuitivamente, se comienza en la raíz (eligiendo algún nodo como elemento raíz en el caso de un grafo) y se exploran todos los vecinos de este nodo. A continuación para cada uno de los vecinos se exploran sus respectivos vecinos adyacentes, y así hasta que se recorra todo el árbol.\nFormalmente, BFS es un algoritmo de búsqueda sin información, que expande y examina todos los nodos de un árbol sistemáticamente para buscar una solución. El algoritmo no usa ninguna estrategia heurística.\n- Dado un vértice fuente s, Breadth-first search sistemáticamente explora los vértices de G para “descubrir” todos los vértices alcanzables desde s.\n- Calcula la distancia (menor número de vértices) desde s a todos los vértices alcanzables.\n- Después produce un árbol BF con raíz en s y que contiene a todos los vértices alcanzables.\n- El camino desde dt a cada vértice en este recorrido contiene el mínimo número de vértices. Es el camino más corto medido en número de vértices.\n- Su nombre se debe a que expande uniformemente la frontera entre lo descubierto y lo no descubierto. Llega a los nodos de distancia k, sólo tras haber llegado a todos los nodos a distancia k-1.\n",
    "complejidad_tiempo": "Mejor caso :    O(|v|+|e|)  Peor caso : O(|v|+|e|)  Promedio: O(|v|+|e|) ",
    "java": "// Programa java que imprime BFS (Busqueda en anchura) transverso\n// desde un vertice (nodo) dado como inicio\n// BFS(int s) atraviesa vertices alcanzables desde s \n\nimport java.util.*;\n//Esta clase representa un grafo dirigido usando listas de adyacencia\n\npublic class BFS {\n\n    public static void main(String args[]) {\n        Graph g = new Graph(4);\n        g.addEdge(0, 1);\n        g.addEdge(0, 2);\n        g.addEdge(1, 2);\n        g.addEdge(2, 0);\n        g.addEdge(2, 3);\n        g.addEdge(3, 3);\n        System.out.println(\"Siguiendo su primera busqueda en anchura transverso\"\n                + \"(iniciando desde el vertice 2)\");\n        //Vertice de inicio\n        g.BFS(2);\n    }\n\n    static class Graph {\n        private final int V;   // número de vertices\n        private LinkedList<Integer> adj[]; //lista de ayacencia\n        // Constructor\n        Graph(int v) {\n            V = v;\n            adj = new LinkedList[v];\n            for (int i = 0; i < v; ++i) {\n                adj[i] = new LinkedList();\n            }\n        }\n        // funcion que agrega un camino al grafo\n        void addEdge(int v, int w) {\n            adj[v].add(w);\n        }\n        void BFS(int s) {\n            //Marka todos los verticoes como no visitados (Falso)\n            boolean visited[] = new boolean[V];\n            //Crea una cola para la BFS\n            // Create a queue for BFS \n            LinkedList<Integer> queue = new LinkedList<>();\n            //Marca el nodo actual como vistiado y lo encola\n            visited[s] = true;\n            queue.add(s);\n            while (!queue.isEmpty()) {\n                //Desencola un vertice de la cola y lo imprime\n                s = queue.poll();\n                System.out.print(s + \" \");\n                /* Obtiene todos los vertices adyacentes del \n                vertice desencolado, si un adyacente no ha \n                sido visitado, lo marca lo visita y lo encola*/\n                Iterator<Integer> i = adj[s].listIterator();\n                while (i.hasNext()) {\n                    int n = i.next();\n                    if (!visited[n]) {\n                        visited[n] = true;\n                        queue.add(n);\n                    }\n                }\n            }\n        }\n    }\n}\n",
    "cpp": "#include <bits/stdc++.h>\n#define MAX_V 101\nusing namespace std;\nvector<int> adj[MAX_V];\nvector<int>que;\n\nstruct Graph {\n    int V;\n\n    void addEdge(int v, int w) {\n        adj[v].push_back(w);\n    }\n\n    void BFS(int s) {\n        bool visited[V];\n        visited[s] = true;\n        que.push_back(s);\n        while (!que.empty()) {\n            s = que.front();\n            que.erase(que.begin());\n            cout << s << \" \";\n            for (int i = 0; i < adj[s].size(); ++i) {\n                int n = adj[s][i];\n                if (!visited[n]) {\n                    visited[n] = true;\n                    que.push_back(n);\n                }\n            }\n        }\n    }\n};\n\nint main() {\n    Graph gra;\n    gra.V = 4;\n    gra.addEdge(0, 1);\n    gra.addEdge(0, 2);\n    gra.addEdge(1, 2);\n    gra.addEdge(2, 0);\n    gra.addEdge(2, 3);\n    gra.addEdge(3, 3);\n    int initial = 0;\n    gra.BFS(initial);\n    return 0;\n}\n",
    "py": "def add_edge(v, w):\n    ady[v].append(w)\ndef bfs(s):\n    visited = [[] for i in range (V)]\n    queue = []\n    visited[s] = True;\n    queue.append(s)\n    while len(queue) > 0:\n        s = queue[0]\n        queue = queue[1:]\n        print(str(s) + \" \")\n        aux = ady[s]\n        for j in range (len(aux)):\n            n = aux[j]\n            if(visited[n] != True):\n                visited[n] = True\n                queue.append(n)\nV = 4\nady = [[] for i in range (V)]\nadd_edge(0, 1)\nadd_edge(0, 2)\nadd_edge(1, 2)\nadd_edge(2, 0)\nadd_edge(2, 3)\nadd_edge(3, 3)\nprint(ady)\nbfs(0)\n\n",
    "orden": 8,
    "suborden": 3,
    "fecha_creacion": "2020-12-05 00:45:46",
    "fecha_modificacion": "2020-12-06 20:30:45"
  },
  {
    "ID": 134,
    "supergrupo": "Grafos ",
    "tema": "BFS todos los caminos",
    "texto": "Utilizando el algoritmo de búsqueda en anchura, y modificándolo se puede realizar la búsqueda de todos los caminos existentes desde un origen hasta un destino, permitiendo también que se impriman los recorridos de estos caminos.",
    "complejidad_tiempo": "Mejor caso :    O(|v|+|e|)  Peor caso : O(|v|+|e|)  Promedio: O(|v|+|e|) ",
    "java": "//Programa java que imprime todos los caminos\n// desde un inicio hasta un destino usando BFS\n\nimport java.util.ArrayList;\nimport java.util.List;\n//Un grafo dirigido usando lista de adyacencia\n\npublic class BFSAllPaths {\n    // Número de vertices\n    static int v;\n    // lista de adyacencia\n    static ArrayList<Integer>[] adjList;\n    static void initGraph(int vertices) {\n        //Inicializa número de vertices\n        v = vertices;\n        // inicializa lista de adyacencia\n        initAdjList();\n    }\n\n    static void initAdjList() {\n        adjList = new ArrayList[v];\n        for (int i = 0; i < v; i++) {\n            adjList[i] = new ArrayList<>();\n        }\n    }\n    //Agrega camino de u a v\n    static void addEdge(int u, int v) {\n        // Agrega v a la lista de u\n        adjList[u].add(v);\n    }\n    //Imrpime todos los caminos de \n    // 's' a 'd' \n    static void printAllPaths(int s, int d) {\n        boolean[] isVisited = new boolean[v];\n        ArrayList<Integer> pathList = new ArrayList<>();\n        //Agrega origen al path[]\n        pathList.add(s);\n        printAllPathsUtil(s, d, isVisited, pathList);\n    }\n    /*Función recursiva que imprime \n    Todos los caminos de u a d.\n    isVisited[] mantiene rastro de\n    los vertices en el camino actual\n    localPathList<> almacena vertices actuales\n    en el camino actual*/\n    static void printAllPathsUtil(Integer u, Integer d,\n            boolean[] isVisited,\n            List<Integer> localPathList) {\n        // Marca el nodo actual\n        isVisited[u] = true;\n        if (u.equals(d)) {\n            System.out.println(localPathList);\n            // Si coincidencia encontrada entonces\n            // no se necesita atravesar más profundo\n            isVisited[u] = false;\n            return;\n        }\n        // Recorre todos los vertices \n        //adyacentes al actual vertice \n        for (Integer i : adjList[u]) {\n            if (!isVisited[i]) {\n                // Almacena el nodo actual\n                // en path[]\n                localPathList.add(i);\n                printAllPathsUtil(i, d, isVisited, localPathList);\n                localPathList.remove(i);\n            }\n        }\n        // Marca el nodo actual\n        isVisited[u] = false;\n    }\n\n    public static void main(String[] args) {\n        //Crea el grafo\n        initGraph(4);\n        //camino desde hasta\n        addEdge(0, 1);\n        addEdge(0, 2);\n        addEdge(0, 3);\n        addEdge(2, 0);\n        addEdge(2, 1);\n        addEdge(1, 3);\n        // inicio arbitrario\n        int s = 0;\n        // destino arbitrario\n        int d = 3;\n        System.out.println(\"Los siguientes son todos los diferentes\"\n                + \"caminos de \" + s + \" a \" + d);\n        printAllPaths(s, d);\n    }\n}\n",
    "cpp": "#include <bits/stdc++.h>\nusing namespace std;\n\n// función de utilidad para impresion\n// encontrando todos los caminos\nvoid printpath(vector<int>& path) {\n    int size = path.size();\n    for (int i = 0; i < size; i++)\n        cout << path[i] << \" \";\n    cout << endl;\n}\n// Funcion para revisar si el vertice actual\n// ya se encuentra presente en el camino\nint isNotVisited(int x, vector<int>& path) {\n    int size = path.size();\n    for (int i = 0; i < size; i++)\n        if (path[i] == x)\n            return 0;\n    return 1;\n}\n// Funcion de utilidad para encontrar los caminos dentro de un grafo\n// desde el inicio hasta el fin dado\nvoid findpaths(vector<vector<int>> &g, int inicio, int destino, int v) {\n    // Crear una cola que almacena los caminos\n    queue<vector<int>> q;\n    // vector de caminos que almacena el camino actual\n    vector<int> path;\n    path.push_back(inicio);\n    q.push(path);\n    while (!q.empty()) {\n        path = q.front();\n        q.pop();\n        int last = path[path.size() - 1];\n        // Si el ultimo vertice es el destino deseado\n        // entonces se imprime el camino\n        if (last == destino)\n            printpath(path);\n        // Atravesar a todos los nodos conectados al vÃ©rtice actual\n        // y empujar una nueva ruta a la cola\n        for (int i = 0; i < g[last].size(); i++) {\n            if (isNotVisited(g[last][i], path)) {\n                vector<int> newpath(path);\n                newpath.push_back(g[last][i]);\n                q.push(newpath);\n            }\n        }\n    }\n}\n\nint main() {\n    vector<vector<int>> g;\n    // Numero de vertices\n    int v = 4;\n    g.resize(4);\n    // Contruccion del grafo\n    g[0].push_back(3);\n    g[0].push_back(1);\n    g[0].push_back(2);\n    g[1].push_back(3);\n    g[2].push_back(0);\n    g[2].push_back(1);\n    //inicio y destino\n    int inicio = 2, destino = 3;\n    cout << \"Los caminos desde \" << inicio\n            << \" hasta \" << destino << \" son \\n\";\n    // Llamada a la funcion que permitirá¡ encontrar los caminos\n    // recibiendo como parametros la matriz de caminos, el inicio, el\n    // y la cantidad de vertices\n    findpaths(g, inicio, destino, v);\n    return 0;\n}\n",
    "py": "from collections import defaultdict\n \nclass Graph: \n    def __init__(self, vertices): \n        self.V = vertices  \n        self.graph = defaultdict(list)   \n    def addEdge(self, u, v): \n        self.graph[u].append(v) \n    def printAllPathsUtil(self, u, d, visited, path): \n        visited[u] = True\n        path.append(u)  \n        if u == d: \n            print path \n        else: \n            for i in self.graph[u]: \n                if visited[i] == False: \n                    self.printAllPathsUtil(i, d, visited, path) \n        path.pop() \n        visited[u] = False\n\n    def printAllPaths(self, s, d): \n        visited = [False] * (self.V)  \n        path = [] \n        self.printAllPathsUtil(s, d, visited, path) \ng = Graph(4) \ng.addEdge(0, 1) \ng.addEdge(0, 2) \ng.addEdge(0, 3) \ng.addEdge(2, 0) \ng.addEdge(2, 1) \ng.addEdge(1, 3) \ns = 2 ; d = 3\nprint (\"Siguiendo los diferentes caminos desde %d a %d :\" %(s, d)) \ng.printAllPaths(s, d) \n",
    "orden": 8,
    "suborden": 4,
    "fecha_creacion": "2020-12-05 00:45:46",
    "fecha_modificacion": "2020-12-06 20:30:46"
  },
  {
    "ID": 135,
    "supergrupo": "Grafos ",
    "tema": "Domino DFS",
    "texto": "El efecto dominó o reacción en cadena es el efecto acumulativo producido cuando un acontecimiento origina una cadena de otros acontecimientos similares.\nSe produce cuando un pequeño cambio origina un cambio similar a su lado, que a su vez causa otro similar, y así sucesivamente en una secuencia lineal. Recibe este nombre, por analogía con la caída de una hilera de fichas de dominó colocadas en posición vertical. El efecto dominó también puede hacer referencia a una cadena de acontecimientos no materiales.\nEl término, en sus distintos usos, se ha hecho popular por su analogía al efecto mecánico, una fila de fichas de dominó al caer una ficha detrás de otra, aunque típicamente se refiere a una secuencia enlazada de acontecimientos donde el tiempo entre acontecimientos sucesivos es relativamente pequeño. \n",
    "complejidad_tiempo": "Mejor caso :    O(|v|+|e|)  Peor caso : O(|v|+|e|)  Promedio: O(|v|+|e|) ",
    "java": "//Programa java que usando DFS busca cuantos dominos\n// caen desde un origen\n\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Scanner;\n\n/* EJEMPLO DE INGRESO\n9 6 3\n1 2\n2 5\n5 3\n4 3\n6 7\n7 8\n1\n6\n4*/\npublic class DominoDFS {\n    static final int MAX = 10001;\n    static ArrayList<ArrayList<Integer>> ady\n            = new ArrayList<ArrayList<Integer>>(MAX);\n    static Scanner sc = new Scanner(System.in);\n    //la cantidad total de dominos que caerán\n    static int total;\n    //arreglo de domino caido\n    static boolean visitado[] = new boolean[MAX];\n\n    public static void main(String[] args) {\n        //número de dominos, cantidad de enlaces, consultas\n        int V, M, Q, x, y, origen;\n        V = sc.nextInt();\n        M = sc.nextInt();\n        Q = sc.nextInt();\n        for (int i = 0; i < V; i++) {\n            ady.add(new ArrayList<>());\n        }\n        while (M > 0) {\n            //domino x hace caer a domino y\n            x = sc.nextInt();\n            y = sc.nextInt();\n            ady.get(x).add(y);\n            M--;\n        }\n        while (Q > 0) {\n            //domino origen\n            origen = sc.nextInt();\n            total = 0;\n            Arrays.fill(visitado, false);\n            dfs(origen);\n            System.out.printf(\"%d\\n\", total);\n            Q--;\n        }\n\n    }\n\n    static void dfs(int u) { //domino origen\n        //aumento en mi respuesta la caida de un domino\n        total++;\n        //domino \"u\" cayo\n        visitado[u] = true;\n        //verifico los demás posibles \n        //domino que caeran si impulso \"u\"\n        for (int v = 0; v < ady.get(u).size(); ++v) {\n            //si el domino adyacente no \n            //cayó entonces es elsiguiente a evaluar\n            if (!visitado[ady.get(u).get(v)]) {\n                //recursivamente veo que dominos \n                //caeran a partir del adyacente de \"u\"\n                dfs(ady.get(u).get(v));\n            }\n        }\n    }\n}\n",
    "cpp": "#include<bits/stdc++.h>\n#define MAX 10001\nusing namespace std;\nvector <vector<int> >ady(MAX);\nint total = 0;\nbool visited[MAX];\n\nvoid DFS(int u) {\n    total++;\n    visited[u] = true;\n    for (int v = 0; v < ady[u].size(); v++) {\n        if (!visited[ady[u][v]]) {\n            DFS(ady[u][v]);\n        }\n    }\n}\n\nint main() {\n    int dominos, caminos, Búsquedas, desde, hasta, origen;\n    cin>>dominos;\n    cin>>caminos;\n    cin>>Búsquedas;\n    while (caminos > 0) {\n        cin >> desde>>hasta;\n        ady[desde].push_back(hasta);\n        caminos--;\n    }\n    while (Búsquedas) {\n        cin>>origen;\n        total = 0;\n        memset(visited, 0, sizeof visited);\n        DFS(origen);\n        cout << \"Dominos tumbados : \" << total << endl;\n        Búsquedas--;\n    }\n    return 0;\n}\n",
    "py": null,
    "orden": 8,
    "suborden": 5,
    "fecha_creacion": "2020-12-05 00:45:47",
    "fecha_modificacion": "2020-12-06 20:30:46"
  },
  {
    "ID": 136,
    "supergrupo": "Grafos ",
    "tema": "Laberintos BFS",
    "texto": "Un laberinto es un pasatiempo gráfico consistente en trazar una línea desde un punto de origen situado en el exterior de un laberinto a uno de destino situado generalmente en el centro o bien en el lado opuesto. La dificultad consiste en encontrar un camino directo hasta el lugar deseado. El laberinto, por su propia configuración, contiene diferentes vías sin salida (de mayor o menor longitud) y solo un recorrido correcto.",
    "complejidad_tiempo": "Mejor caso :    O(|v|+|e|)  Peor caso : O(|v|+|e|)  Promedio: O(|v|+|e|) ",
    "java": "// Programa java que realiza laberintos con BFS\n\nimport java.util.Arrays;\nimport java.util.LinkedList;\nimport java.util.Queue;\nimport java.util.Scanner;\n\npublic class ExitTheMazeBFS {\n\n    /* Ejemplo de ingreso\n8 8\n.......I\n.#######\n.#......\n.#.S...S\n.###.#.#\n.#...#.#\n.#.###.#\n........\n     */\n    //máximo número de filas y columnas del laberinto\n    static final int MAX = 100;\n    static Scanner sc = new Scanner(System.in);\n    //laberinto\n    static char ady[][] = new char[MAX][MAX];\n    //arreglo de estados visitados\n    static boolean visitado[][] = new boolean[MAX][MAX];\n    //incremento en coordenada x\n    static int dx[] = {0, 0, 1, -1};\n    //incremento en coordanada y\n    static int dy[] = {1, -1, 0, 0};\n    //altura y ancho del laberinto\n    static int h, w;\n    //Arreglo para mostrar la ruta que se siguio\n    static Estado prev[][] = new Estado[MAX][MAX];\n\n    static class Estado {\n        int x; // Fila del estado\n        int y; // Columna del estado\n        int d; // Distancia del estado\n        // Constructor\n        Estado(int x1, int y1, int d1) {\n            this.x = x1;\n            this.y = y1;\n            this.d = d1;\n        }\n\n        Estado() {\n        }\n    }\n\n    public static void main(String[] args) {\n        int x = 0, y = 0;\n        System.out.println(\"Ingrese altura del laberinto: \");\n        h = sc.nextInt();\n        System.out.println(\"Ingrese ancho del laberinto: \");\n        w = sc.nextInt();\n        sc.nextLine();\n        System.out.printf(\"\\nIngrese el laberinto, con un solo \"\n                + \"valor inicial I, valor final sera S: \\n\");\n        for (int i = 0; i < h; ++i) {\n            String aux = sc.nextLine();\n            for (int j = 0; j < w; ++j) {\n                ady[i][j] = aux.charAt(j);\n                //obtengo coordenada de valor inicial\n                if (ady[i][j] == 'I') {\n                    x = i;\n                    y = j;\n                }\n            }\n        }\n        //MOSTRAMOS LABERINTO\n        for (int i = 0; i < h; ++i) {\n            for (int j = 0; j < w; ++j) {\n                System.out.printf(\"%c\", ady[i][j]);\n            }\n            System.out.printf(\"\\n\");\n        }\n        int min = BFS(x, y, h, w);\n        if (min != -1) {\n            System.out.printf(\"Menor número de pasos: %d\\n\", min);\n        } else {\n            System.out.println(\"No se pudo llegar al destino\");\n        }\n\n    }\n    //Funcion para imprimir la ruta encontrada\n    //Ingresan las coordenadas del nodo final\n    static void print(int x, int y) {\n        //El arreglo prev posee las coordenadas del nodo \n        //anterior, por ello empezamos desde el final\n        //El proceso termina al momento de preguntar \n        //por el anterior del nodo inicial, como pusimos -1\n        //Preguntamos hasta que nuestro anterior sea diferente de -1\n        for (int i = x, j = y; prev[i][j].d != -1; i\n                = prev[x][y].x, j = prev[x][y].y) {\n            ady[i][j] = '*';\n            x = i;\n            y = j;\n        }\n\n        System.out.printf(\"Camino con menor número de pasos\\n\");\n        for (int i = 0; i < h; ++i) {\n            for (int j = 0; j < w; ++j) {\n                System.out.printf(\"%c\", ady[i][j]);\n            }\n            System.out.printf(\"\\n\");\n        }\n    }\n    //coordenadas de inicial \"I\" y dimensiones de laberinto\n    static int BFS(int x, int y, int h, int w) {\n        //Estado inicial, distancia = 0\n        Estado inicial = new Estado(x, y, 0);\n        //Cola de todos los posibles Estados por\n        //los que se pase para llegar al destino\n        Queue<Estado> Q = new LinkedList<>();\n        //Insertamos el estado inicial en la Cola.\n        //marcamos como no visitado\n        Q.offer(inicial);\n        for (int i = 0; i < MAX; i++) {\n            Arrays.fill(visitado[i], false);\n        }\n        //el inicial no tiene una ruta anterior puesto que es  primero\n        prev[x][y] = new Estado(-1, -1, -1);\n        //Mientras cola no este vacia\n        while (!Q.isEmpty()) {\n            //Obtengo de la cola el estado actual, \n            //en un comienzo será el inicial\n            Estado actual = Q.peek();\n            //Saco el elemento de la cola\n            Q.poll();\n            //Si se llego al destino (punto final)\n            if (ady[actual.x][actual.y] == 'S') {\n                //imprimo la ruta del camino más corto\n                print(actual.x, actual.y);\n                //Retornamos distancia recorrida hasta ese momento\n                return actual.d;\n            }\n            //Marco como visitado dicho estado para no volver a recorrerlo\n            visitado[actual.x][actual.y] = true;\n            //Recorremos hasta 4 porque tenemos 4 posibles adyacentes\n            for (int i = 0; i < 4; ++i) {\n                //nx y ny tendran la coordenada adyacente\n                int nx = dx[i] + actual.x;\n                //ejemplo en i=0 y actual \n                //(3,4) -> 3+dx[0]=3+0=3, \n                //4+dy[0]=4+1=5, nueva coordenada (3,5)\n                int ny = dy[i] + actual.y;\n                //aqui comprobamos que la coordenada \n                //adyacente no sobrepase las dimensiones del laberinto\n                //además comprobamos que no sea \n                //pared \"#\" y no este visitado\n                if (nx >= 0 && nx < h && ny >= 0\n                        && ny < w && ady[nx][ny] != '#' && !visitado[nx][ny]) {\n                    //Creamos estado adyacente aumento en \n                    //1 la distancia recorrida\n                    Estado adyacente = new Estado(nx, ny, actual.d + 1);\n                    //Agregamos adyacente a la cola\n                    Q.offer(adyacente);\n                    //El previo del nuevo nodo es el actual.\n                    prev[nx][ny] = actual;\n                }\n            }\n        }\n        return -1;\n    }\n}\n",
    "cpp": "#include<bits/stdc++.h>\n#define MAX 100\nusing namespace std;\n\nstruct Estado {\n    int x;\n    int y;\n    int d;\n};\nchar ady[MAX][MAX];\nbool visited[MAX][MAX];\nint dx[] = {0, 0, 1, -1};\nint dy[] = {1, -1, 0, 0};\nint h, w;\nEstado prev[MAX][MAX];\n\nvoid print(int x, int y) {\n    for (int i = x, j = y; prev[i][j].d != -1; i = prev[x][y].x, j = prev[x][y].y) {\n        ady[i][j] = '*';\n        x = i;\n        y = j;\n    }\n    cout << \"camino con menor pasos\" << endl;\n    for (int i = 0; i < h; i++) {\n        for (int j = 0; j < w; j++) {\n            cout << ady[i][j];\n        }\n        cout << endl;\n    }\n}\n\nint BFS(int x, int y, int h, int w) {\n    Estado inicial;\n    inicial.x = x;\n    inicial.y = y;\n    inicial.d = 0;\n    queue<Estado> Q;\n    Q.push(inicial);\n    for (int i = 0; i < MAX; ++i) {\n        memset(visited[i], false, sizeof visited[i]);\n    }\n    Estado nuevo;\n    nuevo.x = -1;\n    nuevo.y = -1;\n    nuevo.d = -1;\n    prev[x][y] = nuevo;\n    while (!Q.empty()) {\n        Estado actual = Q.front();\n        Q.pop();\n        if (ady[actual.x][actual.y] == 'S') {\n            print(actual.x, actual.y);\n            return actual.d;\n        }\n        visited[actual.x][actual.y] = true;\n        for (int i = 0; i < 4; i++) {\n            int nx = dx[i] + actual.x;\n            int ny = dy[i] + actual.y;\n            if (nx >= 0 && nx < h && ny >= 0 && ny < w && ady[nx][ny] != '#' && !visited[nx][ny]) {\n                Estado adyacente;\n                adyacente.x = nx;\n                adyacente.y = ny;\n                adyacente.d = actual.d + 1;\n                Q.push(adyacente);\n                prev[nx][ny] = actual;\n            }\n        }\n    }\n    return -1;\n}\n\nint main() {\n    int x = 0;\n    int y = 0;\n    cout << \"altura\\n\";\n    cin>>h;\n    cout << \"ancho\\n\";\n    cin>>w;\n    cin.ignore();\n    for (int i = 0; i < h; i++) {\n        string aux;\n        getline(cin, aux);\n        for (int j = 0; j < w; j++) {\n            ady[i][j] = aux[j];\n            if (ady[i][j] == 'I') {\n                x = i;\n                y = j;\n            }\n        }\n    }\n    for (int i = 0; i < h; i++) {\n        for (int j = 0; j < w; j++) {\n            cout << ady[i][j];\n        }\n        cout << endl;\n    }\n    int mini = BFS(x, y, h, w);\n    if (mini != -1) {\n        cout << \"El menor numero de pasos es \" << mini;\n    } else {\n        cout << \"No se pudo llegar\";\n    }\n    return 0;\n}\n",
    "py": null,
    "orden": 8,
    "suborden": 6,
    "fecha_creacion": "2020-12-05 00:45:47",
    "fecha_modificacion": "2020-12-06 20:30:47"
  },
  {
    "ID": 137,
    "supergrupo": "Grafos ",
    "tema": "15.8) Conteo de caminos DFS",
    "texto": "Cuente el número total de caminos o vías que existen entre dos vértices en un grafo dirigido, estos caminos no contienen un ciclo, la simple razón de esto es que un ciclo contiene infinito número de caminos y esto crea problema.\nEl problema puede ser resuelto usando backtracking, esto es si tomamos un camino y empezamos a andar por él, si nos lleva al vértice de destino entonces contamos el camino y nos devolvemos a tomar otro camino, si el camino no nos lleva al vértice destino, descartamos este camino.\n",
    "complejidad_tiempo": "Mejor caso :    O(|v|+|e|)  Peor caso : O(|v|+|e|)  Promedio: O(|v|+|e|) ",
    "java": "// Programa java que cuenta todos los caminos de un\n// inicio a un destino. \n\nimport java.util.Arrays;\nimport java.util.Iterator;\nimport java.util.LinkedList;\n\npublic class CountAllPaths {\n\n    public static void main(String args[]) {\n        Graph g = new Graph(4);\n        g.addEdge(0, 1);\n        g.addEdge(0, 2);\n        g.addEdge(0, 3);\n        g.addEdge(2, 0);\n        g.addEdge(2, 1);\n        g.addEdge(1, 3);\n         //Origen - destino\n        int s = 2, d = 3;\n        System.out.println(g.countPaths(s, d));\n    }\n\n    static class Graph {\n        // Número de vertices\n        private int V;\n        // array de listas de adyacencia\n        private LinkedList<Integer> adj[];\n        Graph(int v) {\n            V = v;\n            adj = new LinkedList[v];\n            for (int i = 0; i < v; ++i) {\n                adj[i] = new LinkedList<>();\n            }\n        }\n        //agrgar caminos en un grafo\n        void addEdge(int v, int w) {\n            //agrega w a las listas de v\n            adj[v].add(w);\n        }\n        // Un metodo recursivo que cuenta\n        // todos los caminos de u a d \n        int countPathsUtil(int u, int d,\n                boolean visited[],\n                int pathCount) {\n            //Marca el nodo actual como visitado\n            //y lo imprime\n            visited[u] = true;\n            // Si el vertice actual es igual\n            // al destino, incrementa el conteo\n            if (u == d) {\n                pathCount++;\n            } // Recore todos los vertices  \n            // adyacentes a este vertice\n            else {\n                Iterator<Integer> i = adj[u].listIterator();\n                while (i.hasNext()) {\n                    int n = i.next();\n                    if (!visited[n]) {\n                        pathCount = countPathsUtil(n, d,\n                                visited,\n                                pathCount);\n                    }\n                }\n            }\n            visited[u] = false;\n            return pathCount;\n        }\n        // Retorna conteo de caminos desde s a d\n        int countPaths(int s, int d) {\n            //Marca todos los vertices como no visitados\n            boolean visited[] = new boolean[V];\n            Arrays.fill(visited, false);\n            int pathCount = 0;\n            pathCount = countPathsUtil(s, d,\n                    visited,\n                    pathCount);\n            return pathCount;\n        }\n    }\n}\n",
    "cpp": "#include<bits/stdc++.h>\n#define MAX 101\nusing namespace std;\nvector<int> adj[MAX];\n\nstruct Graph {\n    int V;\n\n    void addEdge(int v, int w) {\n        adj[v].push_back(w);\n    }\n\n    int countPathsUtil(int u, int d, bool visited[], int pathCount) {\n        visited[u] = true;\n        if (u == d) {\n            pathCount++;\n        } else {\n            for (int i = 0; i < adj[u].size(); i++) {\n                int n = adj[u][i];\n                if (!visited[n]) {\n                    pathCount = countPathsUtil(n, d, visited, pathCount);\n                }\n            }\n        }\n        visited[u] = false;\n        return pathCount;\n    }\n\n    int countPaths(int s, int d) {\n        bool visited[V];\n        memset(visited, false, sizeof visited);\n        int pathcount = 0;\n        pathcount = countPathsUtil(s, d, visited, pathcount);\n        return pathcount;\n    }\n};\n\nint main() {\n    Graph g;\n    g.V = 4;\n    g.addEdge(0, 1);\n    g.addEdge(0, 2);\n    g.addEdge(0, 3);\n    g.addEdge(2, 0);\n    g.addEdge(2, 1);\n    g.addEdge(1, 3);\n    int s = 2, d = 3;\n    cout << g.countPaths(s, d);\n    return 0;\n}\n",
    "py": null,
    "orden": 8,
    "suborden": 7,
    "fecha_creacion": "2020-12-05 00:45:47",
    "fecha_modificacion": "2020-12-06 20:30:48"
  },
  {
    "ID": 138,
    "supergrupo": "Grafos ",
    "tema": "Ciclo en un grafo dirigido",
    "texto": "Dado un grafo dirigido, verificar si el grafo contiene un ciclo o no, la función debe retornar true si el grafo dado contiene al menos un ciclo, de lo contrario retorne false.\nDFS puede ser usado para detectar un ciclo en un grafo, DFS para un grafo conectado produce un árbol, hay un ciclo en un grafo solo si hay un camino de regreso presente en el grafo. Un camino de regreso es un camino de un nodo a sí mismo, o uno de sus antecesores en el árbol producido por el DFS.\nPara un grafo desconexo, tenemos el bosque DFS como salida, para detectar un ciclo, podemos verificar los arboles individuales en búsqueda de caminos de regreso.\nPara detectar un camino de regreso, podemos rastrear los vértices actuales en una pila de recursión de la función de DFS transverso, si llegamos a un vértice que ya está en la pila de recursión entonces hay un ciclo en el árbol, el camino que conecta el vértice actual a un vértice en la pila recursión es el camino de regreso, Usamos recStack[] para mantener rastreado los vértices de la pila de recursión.\nLa complejidad de tiempo de este método es la misma complejidad de tiempo de un DFS transverso la cual es  O(V+E) siendo V la cantidad de vértices y E la cantidad de caminos.\n",
    "complejidad_tiempo": "Mejor caso :    O(|v|+|e|)  Peor caso : O(|v|+|e|)  Promedio: O(|v|+|e|) ",
    "java": "// Programa java que detecta ciclo en un grafo\n\nimport java.util.ArrayList;\nimport java.util.LinkedList;\nimport java.util.List;\n\npublic class CycleInADirectedGraph {\n\n    static class Graph {\n        private final int V;\n        private final List<List<Integer>> adj;\n        public Graph(int V) {\n            this.V = V;\n            adj = new ArrayList<>(V);\n            for (int i = 0; i < V; i++) {\n                adj.add(new LinkedList<>());\n            }\n        }\n        private boolean isCyclicUtil(int i, boolean[] visited,\n                boolean[] recStack) {\n            /* Marca el nodo actual como visitado \n            y parte de la pila de recursión*/\n            if (recStack[i]) {\n                return true;\n            }\n            if (visited[i]) {\n                return false;\n            }\n            visited[i] = true;\n            recStack[i] = true;\n            List<Integer> children = adj.get(i);\n//funcion lambda\nif (children.stream().anyMatch((c) -> (isCyclicUtil(c, visited, recStack)))) {\n                return true;\n            }\n//  for (Integer c: children) \n//  if (isCyclicUtil(c, visited, recStack)) \n//  return true;             recStack[i] = false;\n            return false;\n        }\n        private void addEdge(int source, int dest) {\n            adj.get(source).add(dest);\n        }\n        /* Retorna true si el grafo tiene un ciclo, si no falso*/\n        private boolean isCyclic() {\n            //Marca todos los vetices como no visitados\n            // y no parte de la pila de recursión\n            boolean[] visited = new boolean[V];\n            boolean[] recStack = new boolean[V];\n            for (int i = 0; i < V; i++) {\n                if (isCyclicUtil(i, visited, recStack)) {\n                    return true;\n                }\n            }\n            return false;\n        }\n\n        public static void main(String[] args) {\n            Graph graph = new Graph(4);\n            graph.addEdge(0, 1);\n            graph.addEdge(0, 2);\n            graph.addEdge(1, 2);\n            graph.addEdge(2, 0);\n            graph.addEdge(2, 3);\n            graph.addEdge(3, 3);\n            if (graph.isCyclic()) {\n                System.out.println(\"El grafo contiene un ciclo\");\n            } else {\n                System.out.println(\"El grafo no contiene\"\n                        + \"un ciclo\");\n            }\n        }\n    }\n}\n",
    "cpp": "#include<bits/stdc++.h>\n#define MAX 101\nusing namespace std;\nvector<vector<int> > adj(MAX);\n\nstruct Graph {\n    int V;\n\n    void addEdge(int source, int dest) {\n        adj[source].push_back(dest);\n    }\n\n    bool isCycleUtil(int i, bool visited[], bool recStack[]) {\n        if (recStack[i]) {\n            return true;\n        }\n        if (visited[i]) {\n            return false;\n        }\n        visited[i] = true;\n        recStack[i] = true;\n        vector<int> children = adj[i];\n        for (int c = 0; c < children.size(); c++) {\n            if (isCycleUtil(children[c], visited, recStack)) {\n                return true;\n            }\n        }\n        recStack[i] = false;\n        return false;\n    }\n\n    bool iscyclic() {\n        bool visit[V];\n        bool recStack[V];\n        memset(visit, false, sizeof visit);\n        memset(recStack, false, sizeof recStack);\n        for (int i = 0; i < V; i++) {\n            if (isCycleUtil(i, visit, recStack)) {\n                return true;\n            }\n        }\n        return false;\n    }\n};\n\nint main() {\n    Graph g;\n    g.V = 4;\n    g.addEdge(0, 1);\n    g.addEdge(0, 2);\n    g.addEdge(1, 2);\n    g.addEdge(2, 0);\n    g.addEdge(2, 3);\n    g.addEdge(3, 3);\n    if (g.iscyclic()) {\n        cout << \"el grafo SI tiene un ciclo\";\n    } else {\n        cout << \"el grafo NO tiene un ciclo\";\n    }\n    return 0;\n}\n",
    "py": null,
    "orden": 8,
    "suborden": 8,
    "fecha_creacion": "2020-12-05 00:45:48",
    "fecha_modificacion": "2020-12-06 20:30:48"
  },
  {
    "ID": 139,
    "supergrupo": "Grafos ",
    "tema": "DFS Cerramiento transitivo",
    "texto": "Dado un grafo dirigido, encontrar si un vértice v es alcanzable desde otro vértice u para todos los pares de vértices (u,v) en el grafo dado, aquí alcanzable significa que existe un camino desde el vértice u a v, la matriz de habilidad de alcance es llamada cerramiento transitivo de un grafo.\nLa solución está basada en el algoritmo de Floyd Warshall, \nLos pasos abstractos de este algoritmo son:\n- Crear una matriz tc[V][V] que pueda tener finalmente el cerramiento transitivo de un grafo dado, inicializar todas sus entradas como 0.\n- Llamar DFS por cada nodo del grado para marcar vértices alcanzables en tc[][]. En llamadas recursivas de DFS no podemos llamar DFS para un vértice adyacente si este ya fue marcado como alcanzable en tc[].\nEl código usa listas de adyacencia para el grafo de entrada y construye una matriz tc[V][V] tal que tc[u][v] será true si v es alcanzable desde u.\n",
    "complejidad_tiempo": "Mejor caso :    O(|v|+|e|)  Peor caso : O(|v|+|e|)  Promedio: O(|v|+|e|) ",
    "java": "//Programa java que imprime el cerramiento transitivo de un grafo\n\nimport java.util.ArrayList;\nimport java.util.Arrays;\n\npublic class DFSTransitiveClosure {\n\n    public static void main(String[] args) {\n        Graph g = new Graph(4);\n        g.addEdge(0, 1);\n        g.addEdge(0, 2);\n        g.addEdge(1, 2);\n        g.addEdge(2, 0);\n        g.addEdge(2, 3);\n        g.addEdge(3, 3);\n        System.out.println(\"Matriz de cerramiento transitivo es \");\n        g.transitiveClosure();\n    }\n\n    static class Graph {\n        // número de vertices\n        private int vertices;\n        // lista de adyacencia \n        private ArrayList<Integer>[] adjList;\n        // para almacenar el cerramiento transitivo\n        private int[][] tc;\n        // Constructor \n        public Graph(int vertices) {\n            // inicializa el conteo de vertices\n            this.vertices = vertices;\n            this.tc = new int[this.vertices][this.vertices];\n            // initializa lista de adyacencia\n            initAdjList();\n        }\n        private void initAdjList() {\n            adjList = new ArrayList[vertices];\n            for (int i = 0; i < vertices; i++) {\n                adjList[i] = new ArrayList<>();\n            }\n        }\n        // Agregar caminos\n        public void addEdge(int u, int v) {\n            adjList[u].add(v);\n        }\n        // buscando cerramiento transitivo\n        public void transitiveClosure() {\n            for (int i = 0; i < vertices; i++) {\n                dfsUtil(i, i);\n            }\n            for (int i = 0; i < vertices; i++) {\n                System.out.println(Arrays.toString(tc[i]));\n            }\n        }\n\n        private void dfsUtil(int s, int v) {\n            // Marca alcance desde s a v como true\n            tc[s][v] = 1;\n            // Encuentra todos los vertices alcanzables \n            // atraves de v\n            for (int adj : adjList[v]) {\n                if (tc[s][adj] == 0) {\n                    dfsUtil(s, adj);\n                }\n            }\n        }\n    }\n}\n",
    "cpp": null,
    "py": null,
    "orden": 8,
    "suborden": 9,
    "fecha_creacion": "2020-12-05 00:45:48",
    "fecha_modificacion": "2020-12-06 20:30:49"
  },
  {
    "ID": 140,
    "supergrupo": "Grafos ",
    "tema": "BFS para grafos desconexos",
    "texto": "Por ejemplo asumamos que todos los vértices son alcanzables desde un vértice inicial, pero en el caso de un grafo desconexo o que cualquier vértice es inalcanzable desde todos los vértices, un BFS normal no nos da la salida deseada, por lo que se utiliza esta modificación del BFS.",
    "complejidad_tiempo": "Mejor caso :    O(|v|+|e|)  Peor caso : O(|v|+|e|)  Promedio: O(|v|+|e|) ",
    "java": "// Implementación de BFS modificado\n\nimport java.util.*;\n\npublic class DisconnectedGraphBFS {\n    // Implementando grafo usando HashMap \n    static HashMap<Integer, LinkedList<Integer>> graph = new HashMap<>();\n    // Agregar caminos al grafo\n    public static void addEdge(int a, int b) {\n        if (graph.containsKey(a)) {\n            LinkedList<Integer> l = graph.get(a);\n            l.add(b);\n            graph.put(a, l);\n        } else {\n            LinkedList<Integer> l = new LinkedList<>();\n            l.add(b);\n            graph.put(a, l);\n        }\n    }\n\n    public static void bfshelp(int s, ArrayList<Boolean> visited) {\n        // Crea una cola para el BFS\n        LinkedList<Integer> q = new LinkedList<>();\n        //Marca el nodo actual como visitado y lo encola\n        q.add(s);\n        visited.set(s, true);\n        while (!q.isEmpty()) {\n            // Desencola un vertice de la cola y la imprime\n            int f = q.poll();\n            System.out.print(f + \" \");\n            // Verifica cuando el nodo actual esta conectado\n            // a otro nodo o no\n            if (graph.containsKey(f)) {\n                Iterator<Integer> i = graph.get(f).listIterator();\n                // Obtiene todos los nodos adyacentes \n                // del nodo desencolado f, si no ha sido visitado\n                // lo marca y lo encola\n                while (i.hasNext()) {\n                    int n = i.next();\n                    if (!visited.get(n)) {\n                        visited.set(n, true);\n                        q.add(n);\n                    }\n                }\n            }\n        }\n    }\n\n    //Fución BFS que verifica cada nodo\n    public static void bfs(int vertex) {\n        ArrayList<Boolean> visited = new ArrayList<>();\n        //Marcando cada nodo como no visitado\n        for (int i = 0; i < vertex; i++) {\n            visited.add(i, false);\n        }\n        for (int i = 0; i < vertex; i++) {\n            //Verificando cuantos nodos no han sido visitados\n            if (!visited.get(i)) {\n                bfshelp(i, visited);\n            }\n        }\n    }\n\n    public static void main(String[] args) {\n        int v = 5;\n        addEdge(0, 4);\n        addEdge(1, 2);\n        addEdge(1, 3);\n        addEdge(1, 4);\n        addEdge(2, 3);\n        addEdge(3, 4);\n        bfs(v);\n    }\n}\n",
    "cpp": null,
    "py": null,
    "orden": 8,
    "suborden": 10,
    "fecha_creacion": "2020-12-05 00:45:48",
    "fecha_modificacion": "2020-12-06 20:30:49"
  },
  {
    "ID": 141,
    "supergrupo": "Grafos ",
    "tema": "Ciclo de Euler en un grafo dirigido",
    "texto": "Un camino de Euler es un camino en un grafo que visita cada camino exactamente una vez, el circuito de Euler es un camino de Euler que empieza y termina en el mismo vértice.\nUn grafo es euleriano si tiene un ciclo de Euler.\nUn grafo dirigido tiene un ciclo de Euler si las siguientes condiciones son verdad:\n1) Todos los vértices con grado no cero pertenecen a una sola componente fuertemente conectada.\n2) En los grados, el grado de entrada es igual al grado de salida\nPodemos detectar componentes fuertemente conectadas usando el DFS de Kosaraju.\nPara comparar los grados de entrada y salida, necesitamos almacenar los grados de entrada y salida de cada vértice, el grado de salida puede ser obtenido por el tamaño de la lista de adyacencia, en grado de entrada puede ser almacenado creando un array de igual tamaño al número de vértices.\nLa complejidad de tiempo de esta implementación es de O(V+E), luego de correr el algoritmo de Kosaraju, atravesamos todos los vértices y comparamos los grados de salida y entrada, esto toma O(V) tiempo.\n",
    "complejidad_tiempo": "Mejor caso :    O(|v|+|e|)  Peor caso : O(|v|+|e|)  Promedio: O(|v|+|e|) ",
    "java": "// Programa java que verifica si un grafo es Euleriano\n\nimport java.util.*;\nimport java.util.LinkedList;\n\npublic class EulerianCycleDirectedGraph {\n\n    public static void main(String[] args) throws java.lang.Exception {\n        Graph g = new Graph(5);\n        g.addEdge(1, 0);\n        g.addEdge(0, 2);\n        g.addEdge(2, 1);\n        g.addEdge(0, 3);\n        g.addEdge(3, 4);\n        g.addEdge(4, 0);\n        if (g.isEulerianCycle()) {\n            System.out.println(\"El grafo dado es euleriano \");\n        } else {\n            System.out.println(\"El grafo dado no es euleriano \");\n        }\n    }\n\n    static class Graph {\n        private int V;   // Número de vertices\n        private LinkedList<Integer> adj[];//Lista de adyacencia\n        private int in[];            //Manteniendo los grados\n        //Constructor \n        Graph(int v) {\n            V = v;\n            adj = new LinkedList[v];\n            in = new int[V];\n            for (int i = 0; i < v; ++i) {\n                adj[i] = new LinkedList();\n                in[i] = 0;\n            }\n        }\n        //Agregar caminos \n        void addEdge(int v, int w) {\n            adj[v].add(w);\n            in[w]++;\n        }\n\n        void DFSUtil(int v, Boolean visited[]) {\n            // Marca nodo actual como visitado\n            visited[v] = true;\n            int n;\n            //  recorre todos los nodos adyacentes a este vertice \n            Iterator<Integer> i = adj[v].iterator();\n            while (i.hasNext()) {\n                n = i.next();\n                if (!visited[n]) {\n                    DFSUtil(n, visited);\n                }\n            }\n        }\n        // Retornar el transpuesto de este grafo \n        Graph getTranspose() {\n            Graph g = new Graph(V);\n            for (int v = 0; v < V; v++) {\n                Iterator<Integer> i = adj[v].listIterator();\n                while (i.hasNext()) {\n                    g.adj[i.next()].add(v);\n                    (g.in[v])++;\n                }\n            }\n            return g;\n        }\n        // Verifica si el grafo esta fuertemente conectado\n        Boolean isSC() {\n            /*Paso 1: Marca todos los vertices como \n            no visitados (Primer DFS)*/\n            Boolean visited[] = new Boolean[V];\n            for (int i = 0; i < V; i++) {\n                visited[i] = false;\n            }\n            /* Paso 2: Hace DFS transverso \n            iniciando del primer vertice*/\n            DFSUtil(0, visited);\n            //  Si DFS no visita todos los nodos, retorna falso \n            for (int i = 0; i < V; i++) {\n                if (visited[i] == false) {\n                    return false;\n                }\n            }\n            /* Paso 3: Crea un grafo reversado*/\n            Graph gr = getTranspose();\n            /* Paso 4: marca todos los vertices \n            como no visitados (Segundo dfs)*/\n            for (int i = 0; i < V; i++) {\n                visited[i] = false;\n            }\n            /* Paso 5: hacer DFS para el grafo reverso \n            iniciando desde el vertice primero\n            debe ser el mismo que el primer DFS*/\n            gr.DFSUtil(0, visited);\n            // Si todos los vertices no son visitados en el segund\n            // DFS retorna falso\n            for (int i = 0; i < V; i++) {\n                if (visited[i] == false) {\n                    return false;\n                }\n            }\n            return true;\n        }\n\n        /* Esta función retorna true si encuentra un \n        ciclo de euler, falso si no*/\n        Boolean isEulerianCycle() {\n            // verifica si todos los vertices con grado no cero\n            // viendo si estan conectados\n            if (isSC() == false) {\n                return false;\n            }\n            // Verifica si en grado de entrada y \n            // salida cada vertice es igual \n            for (int i = 0; i < V; i++) {\n                if (adj[i].size() != in[i]) {\n                    return false;\n                }\n            }\n            return true;\n        }\n    }\n}\n",
    "cpp": "#include <bits/stdc++.h>\n#define FAST ios_base::sync_with_stdio(false);cin.tie(NULL);\n\nusing namespace std;\n\nconst int MAX_V = 90;\n\nstruct Graph {\n    int V;\n    vector<int> adj[MAX_V];\n    int in[MAX_V];\n\n    Graph(int v) {\n        V = v;\n        for (int i = 0; i < V; i++) {\n            in[i] = 0;\n        }\n    }\n\n    void addEdge(int source, int destiny) {\n        adj[source].push_back(destiny);\n        in[destiny]++;\n    }\n\n    void DFSUtil(int v, bool visited[]) {\n        visited[v] = true;\n        int n;\n        for (int i = 0; i < adj[v].size(); ++i) {\n            n = adj[v][i];\n            if (!visited[n]) {\n                DFSUtil(n, visited);\n            }\n        }\n    }\n\n    Graph getTranspose() {\n        Graph ge(V);\n        for (int v = 0; v < V; v++) {\n            for (int i : adj[v]) {\n                ge.adj[i].push_back(v);\n                ge.in[v]++;\n            }\n        }\n        return ge;\n    }\n\n    bool isSC() {\n        bool visited[V];\n        memset(visited, false, V);\n        DFSUtil(0, visited);\n        for (int i = 0; i < V; i++) {\n            if (visited[i] == false) {\n                return false;\n            }\n        }\n        Graph gr = getTranspose();\n        memset(visited, false, sizeof visited);\n        gr.DFSUtil(0, visited);\n        for (int i = 0; i < V; i++) {\n            if (visited[i] == false) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    bool isEulerian() {\n        if (isSC() == false) {\n            return false;\n        }\n        for (int i = 0; i < V; i++) {\n            if (adj[i].size() != in[i]) {\n                return false;\n            }\n        }\n        return true;\n    }\n};\n\nint main() {\n    FAST\n            int vertices, caminos;\n    cin >> vertices >> caminos;\n    Graph g(vertices);\n    for (int i = 0; i < caminos; i++) {\n        int inicio, destino;\n        cin >> inicio >> destino;\n        g.addEdge(inicio, destino);\n    }\n    if (g.isEulerian()) {\n        cout << \"El grafo dado es Euleriano\" << endl;\n    } else {\n        cout << \"El grafo dado no es Euleriano\" << endl;\n    }\n    return 0;\n}\n",
    "py": null,
    "orden": 8,
    "suborden": 11,
    "fecha_creacion": "2020-12-05 00:45:49",
    "fecha_modificacion": "2020-12-06 20:30:50"
  },
  {
    "ID": 142,
    "supergrupo": "Grafos ",
    "tema": "Camino de Euler en un grafo no dirigido ",
    "texto": "¿Es possible dibujar un grafo dado sin levantar el lápiz del papel y sin pasar por los caminos más de una vez?\nUn grafo es llamado euleriano si tiene un ciclo de Euler y es llamado semi-euleriano si tiene un camino de Euler, el problema es similar al camino Hamiltoniano, podemos verificar si un grafo es euleriano o no en tiempo polinómico, de O(V+E).\nLas siguientes son propiedades interesantes de los grafos no dirigidos con un camino euleriano y ciclo, podemos usar esta propiedades para encontrar si un grafo es euleriano o no.\nCiclo euleriano\nUn grafo no dirigido tiene un ciclo de Euler si las siguientes dos condiciones son ciertas:\n- Todos los vértices con grado no cero estan conectados, no nos importa los vértices con grado cero porque no pertenecen a el ciclo de Euler o el camino, solo estamos considerando los caminos.\n- Todos los vértices tienen grado par.\nCamino euleriano\nUn grafo no dirigido tiene un camino euleriano si las dos siguientes condiciones se cumplen:\n- La misma primera condición de un ciclo de Euler\n- Si dos vértices tienen grado impar y todos los demás vértices tienen grado par, note que solo un vértice con grado impar no es posible en un grafo no dirigido, la suma de todos los grados es siempre par en un grafo no dirigido.\nNote que un grafo sin caminos se considera euleriano porque no hay caminos que atravesar.\nEn el camino euleriano, cada vez que visitamos un vértice v, nosotros caminamos a través de dos caminos no visitados, con un punto de fin como v, por lo tanto todos los vértices medios en el camino euleriano deben tener grado par, para el ciclo euleriano cualquier vértice puede ser vértice medio, sin embargo todos los vértices deben tener grado par.\n",
    "complejidad_tiempo": "Mejor caso :    O(|v|+|e|)  Peor caso : O(|v|+|e|)  Promedio: O(|v|+|e|) ",
    "java": "// Programa java que busca camino euleriano\n// de un grafo\n\nimport java.util.*;\nimport java.util.LinkedList;\n\npublic class EulerianPathUndirectedGraph {\n\n    public static void main(String args[]) {\n        // Creamos varios ejemplos de grafos para probar\n        Graph g1 = new Graph(5);\n        g1.addEdge(1, 0);\n        g1.addEdge(0, 2);\n        g1.addEdge(2, 1);\n        g1.addEdge(0, 3);\n        g1.addEdge(3, 4);\n        g1.test();\n        Graph g2 = new Graph(5);\n        g2.addEdge(1, 0);\n        g2.addEdge(0, 2);\n        g2.addEdge(2, 1);\n        g2.addEdge(0, 3);\n        g2.addEdge(3, 4);\n        g2.addEdge(4, 0);\n        g2.test();\n        Graph g3 = new Graph(5);\n        g3.addEdge(1, 0);\n        g3.addEdge(0, 2);\n        g3.addEdge(2, 1);\n        g3.addEdge(0, 3);\n        g3.addEdge(3, 4);\n        g3.addEdge(1, 3);\n        g3.test();\n        /* Crearemos un grafo con tres vertices\n        conectados en forma de ciclo*/\n        Graph g4 = new Graph(3);\n        g4.addEdge(0, 1);\n        g4.addEdge(1, 2);\n        g4.addEdge(2, 0);\n        g4.test();\n        /* Creamos un grafo con vertices con grado cero*/\n        Graph g5 = new Graph(3);\n        g5.test();\n    }\n\n    static class Graph {\n\n        private int V;\n        private LinkedList<Integer> adj[];\n        // Constructor \n        Graph(int v) {\n            V = v;\n            adj = new LinkedList[v];\n            for (int i = 0; i < v; ++i) {\n                adj[i] = new LinkedList();\n            }\n        }\n        //Agregar caminos\n        void addEdge(int v, int w) {\n            adj[v].add(w);\n            adj[w].add(v); //El grafo es no dirigido\n        }\n\n        void DFSUtil(int v, boolean visited[]) {\n            visited[v] = true;\n            Iterator<Integer> i = adj[v].listIterator();\n            while (i.hasNext()) {\n                int n = i.next();\n                if (!visited[n]) {\n                    DFSUtil(n, visited);\n                }\n            }\n        }\n\n        boolean isConnected() {\n            boolean visited[] = new boolean[V];\n            int i;\n            for (i = 0; i < V; i++) {\n                visited[i] = false;\n            }\n            for (i = 0; i < V; i++) {\n                if (!adj[i].isEmpty()) {\n                    break;\n                }\n            }\n            //Si no hay caminos en el grafo, retorna true\n            if (i == V) {\n                return true;\n            }\n            DFSUtil(i, visited);\n            for (i = 0; i < V; i++) {\n                if (visited[i] == false && adj[i].size() > 0) {\n                    return false;\n                }\n            }\n            return true;\n        }\n\n        int isEulerian() {\n            if (isConnected() == false) {\n                return 0;\n            }\n            // Cuenta vertices con grado impar \n            int odd = 0;\n            for (int i = 0; i < V; i++) {\n                if (adj[i].size() % 2 != 0) {\n                    odd++;\n                }\n            }\n            // Si cuenta es más de 2, el grafo no es euleriano\n            if (odd > 2) {\n                return 0;\n            }\n            //si odd es 2, es semieuleriano\n            //Si odd es 0, es eulerian0 \n            return (odd == 2) ? 1 : 2;\n        }\n        void test() {\n            int res = isEulerian();\n            switch (res) {\n                case 0:\n                    System.out.println(\"Grafo no es euleriano\");\n                    break;\n                case 1:\n                    System.out.println(\"Grafo tiene un camino de euler\");\n                    break;\n                default:\n                    System.out.println(\"Grafo tiene ciclo de euler\");\n                    break;\n            }\n        }\n    }\n}\n",
    "cpp": "#include <bits/stdc++.h>\n#define MAX 101\nusing namespace std;\nvector<vector<int> >adj(MAX);\nint in[MAX];\n\nvoid clean() {\n    adj.clear();\n    adj.erase(adj.begin(), adj.begin() + adj.size());\n    memset(in, 0, sizeof in);\n}\n\nstruct Graph {\n    int V;\n\n    void addEdge(int v, int w) {\n        adj[v].push_back(w);\n        adj[w].push_back(v);\n    }\n\n    void DFSUtil(int v, bool visited[]) {\n        visited[v] = true;\n        int n;\n        for (int i = 0; i < adj[v].size(); ++i) {\n            n = adj[v][i];\n            if (!visited[n]) {\n                DFSUtil(n, visited);\n            }\n        }\n    }\n\n    bool isConnected() {\n        bool visited[V];\n        int i;\n        memset(visited, false, sizeof visited);\n        for (i = 0; i < V; i++) {\n            if (!adj[i].empty()) {\n                break;\n            }\n        }\n        if (i == V) {\n            return true;\n        }\n        DFSUtil(i, visited);\n        for (i = 0; i < V; i++) {\n            if (visited[i] == false && adj[i].size() > 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    int isEulerian() {\n        if (isConnected() == false) {\n            return 0;\n        }\n        int odd = 0;\n        for (int i = 0; i < V; i++) {\n            if (adj[i].size() % 2 != 0) {\n                odd++;\n            }\n        }\n        if (odd > 2) {\n            return 0;\n        }\n        return (odd == 2) ? 1 : 2;\n    }\n\n    void test() {\n        int res = isEulerian();\n        switch (res) {\n            case 0:\n                cout << \"Grafo no euleriano\" << endl;\n                break;\n            case 1:\n                cout << \"Grafo tiene camino de euler\" << endl;\n                break;\n            case 2:\n                cout << \"Grafo tiene ciclo de euler\" << endl;\n                break;\n        }\n    }\n\n    void init() {\n        adj.clear();\n        memset(in, 0, sizeof in);\n    }\n\n};\n\nint main() {\n    /*\n    Graph g1;\n    g1.init();\n    g1.V=5;\n    g1.addEdge(1, 0);\n    g1.addEdge(0, 2);\n    g1.addEdge(2, 1);\n    g1.addEdge(0, 3);\n    g1.addEdge(3, 4);\n    g1.test();\n    Graph g2;\n    g2.init();\n    g2.V=5;\n    g2.addEdge(1, 0);\n    g2.addEdge(0, 2);\n    g2.addEdge(2, 1);\n    g2.addEdge(0, 3);\n    g2.addEdge(3, 4);\n    g2.addEdge(4, 0);\n    g2.test();\n     */\n    Graph g3;\n    g3.init();\n    g3.V = 5;\n    g3.addEdge(1, 0);\n    g3.addEdge(0, 2);\n    g3.addEdge(2, 1);\n    g3.addEdge(0, 3);\n    g3.addEdge(3, 4);\n    g3.addEdge(1, 3);\n    g3.test();\n    /*\n    Graph g4;\n    g4.init();\n    g4.V=3;\n    g4.addEdge(0, 1);\n    g4.addEdge(1, 2);\n    g4.addEdge(2, 0);\n    g4.test();\n    Graph g5;\n    g5.init();\n    g5.V=3;\n    g5.test();\n     */\n\n}\n",
    "py": null,
    "orden": 8,
    "suborden": 12,
    "fecha_creacion": "2020-12-05 00:45:49",
    "fecha_modificacion": "2020-12-06 20:30:51"
  },
  {
    "ID": 143,
    "supergrupo": "Grafos ",
    "tema": "Ciclo Hamiltoniano",
    "texto": "El camino Hamiltoniano de un grafo no dirigido es un camino que visita cada vértice exactamente una vez, un ciclo Hamiltoniano es un camino Hamiltoniano que tiene un camino desde el último vértice al primer vértice del camino Hamiltoniano, debemos determinar si un grafo tiene ciclo Hamiltoniano o no, si lo contiene imprimir el camino.\nNuestra entrada será un array graph[v][v] donde v es el número de vértices en el grafo y graph[][] es la matriz de adyacencia representando el grafo, un valor graph[i][j] es 1 si existe un camino directo de I a j, de lo contrario será 0.\nNuestra salida será un array path[v] que deberá contener el camino Hamiltoniano, path[i] puede representar el iesimo vértice en el camino Hamiltoniano. El código debe también retornar si no existe ciclo Hamiltoniano en el grafo.\nSe crea un array de camino vacío y se le agrega el vértice 0 a él, se agregan los otros vértices iniciando desde el vértice 1, antes de añadir un vértice, se verifica por cual es el adyacente del anterior añadido y si no se ha añadido ya, si encontramos tal vértice, añadimos el vértice como parte de la solución, si no lo encontramos retornamos false.\nNote que el código siempre imprime el ciclo iniciando de 0, el punto de inicio no importa ya que el ciclo puede empezar de cualquier punto, si se quiere cambiar el punto de inicio, se deben hacer dos cambios al código de abajo.\nCambie  “path[0] = 0;” por “path[0] = s;” donde s es el nuevo punto de inicio, también cambie el ciclo “for (int v = 1; v < V; v++)\" en hamCycleUtil() por \"for (int v = 0; v < V; v++)\".\n",
    "complejidad_tiempo": "Mejor caso :    O(|v|+|e|)  Peor caso : O(|v|+|e|)  Promedio: O(|v|+|e|) ",
    "java": "/* Programa java que soluciona el ciclo de Hamilton\nusando backtracking*/\n\npublic class HamiltonianCycle {\n\n    static final int V = 5;\n    static int path[];\n\n    /* Una función de utilidad para comprobar si el vértice v puede ser\n       añadido en el índice 'pos'en el ciclo hamiltoniano\n       construido hasta ahora (almacenado en 'path[]')*/\n    static boolean isSafe(int v, int graph[][], int path[], int pos) {\n        /*Verifica si este vertice es adyacente del \n        anterior vertice */\n        if (graph[path[pos - 1]][v] == 0) {\n            return false;\n        }\n        /* Verifica si el vertice ya esta incluido*/\n        for (int i = 0; i < pos; i++) {\n            if (path[i] == v) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    static boolean hamCycleUtil(int graph[][], int path[], int pos) {\n        /* Caso base:Si todos los vertices estan incluidos en  \n           el ciclo hamiltoniano*/\n        if (pos == V) {\n            // Y si hay un camino de el ultimo al primer vertice\n            return graph[path[pos - 1]][path[0]] == 1;\n        }\n        /*Prueba diferentes vértices como próximo candidato\n        en el ciclo hamiltoniano. No intentamos con 0, \n        ya que incluimos 0 como punto de partida en hamCycle ()*/\n        for (int v = 1; v < V; v++) {\n            /* Verifica si este vertice puede ser añadido al\n            ciclo hamiltoniano*/\n            if (isSafe(v, graph, path, pos)) {\n                path[pos] = v;\n                /* Recorre hasta construir el camino*/\n                if (hamCycleUtil(graph, path, pos + 1) == true) {\n                    return true;\n                }\n                path[pos] = -1;\n            }\n        }\n        /* Si no hay vertice para añadir al ciclo\n        retorna falso*/\n        return false;\n    }\n\n    /* Esta función resuelve el problema del ciclo hamiltoniano usando\n       backtracking. Utiliza principalmente hamCycleUtil () para resolver el\n       problema. Devuelve falso si no hay ciclo hamiltoniano.\n       posible, de lo contrario devuelve verdadero e imprime la ruta.\n       Tenga en cuenta que puede haber más de una solución,\n       Esta función imprime una de las soluciones factibles.*/\n    static int hamCycle(int graph[][]) {\n        path = new int[V];\n        for (int i = 0; i < V; i++) {\n            path[i] = -1;\n        }\n        /* Pongamos el vértice 0 como el primer vértice en el camino.\n           Si hay un ciclo hamiltoniano, entonces el camino puede ser\n           Comenzó desde cualquier punto del ciclo ya que la gráfica es\n           no dirigido*/\n        path[0] = 0;\n        if (hamCycleUtil(graph, path, 1) == false) {\n            System.out.println(\"\\nNo existe solución\");\n            return 0;\n        }\n        printSolution(path);\n        return 1;\n    }\n\n    // Imprimir solución\n    static void printSolution(int path[]) {\n        System.out.println(\"Solución existe: Este\"\n                + \" es uno de los ciclos hamiltoniano\");\n        for (int i = 0; i < V; i++) {\n            System.out.print(\" \" + path[i] + \" \");\n        }\n        System.out.println(\" \" + path[0] + \" \");\n    }\n\n    public static void main(String args[]) {\n        /*Tenemos el siguiente grafo \n           (0)--(1)--(2) \n            |   / \\   | \n            |  /   \\  | \n            | /     \\ | \n           (3)-------(4)    */\n        int graph1[][] = {{0, 1, 0, 1, 0},\n        {1, 0, 1, 1, 1},\n        {0, 1, 0, 0, 1},\n        {1, 1, 0, 0, 1},\n        {0, 1, 1, 1, 0},};\n        // Imprimir solución\n        hamCycle(graph1);\n        /*Tenemos el siguiente grafo \n           (0)--(1)--(2) \n            |   / \\   | \n            |  /   \\  | \n            | /     \\ | \n           (3)       (4)    */\n        int graph2[][] = {{0, 1, 0, 1, 0},\n        {1, 0, 1, 1, 1},\n        {0, 1, 0, 0, 1},\n        {1, 1, 0, 0, 0},\n        {0, 1, 1, 0, 0},};\n        // Imprimir solución\n        hamCycle(graph2);\n    }\n}\n",
    "cpp": "#include<bits/stdc++.h>\n#include<cstdlib>\n#define MAX 256\nusing namespace std;\nconst int V = 5;\nint path[MAX];\n\nbool isSafe(int v, int graph[V][V], int path[], int pos) {\n    if (graph[path[pos - 1]][v] == 0)return false;\n    for (int i = 0; i < pos; i++) {\n        if (path[i] == v)return false;\n    }\n    return true;\n}\n\nbool hamCycleUtil(int graph[V][V], int path[], int pos) {\n    if (pos == V)return graph[path[pos - 1]][path[0]] == 1;\n    for (int v = 1; v < V; v++) {\n        if (isSafe(v, graph, path, pos)) {\n            path[pos] = v;\n            if (hamCycleUtil(graph, path, pos + 1) == true)return true;\n        }\n        path[pos] = -1;\n    }\n    return false;\n}\n\nvoid printSolution(int path[]) {\n    cout << \"Solucion existente\" << endl;\n    for (int i = 0; i < V; i++) {\n        cout << path[i] << \" \";\n    }\n    cout << endl;\n}\n\nint hamCycle(int graph[V][V]) {\n    path[V];\n    memset(path, -1, sizeof path);\n    path[0] = 0;\n    if (hamCycleUtil(graph, path, 1) == false) {\n        cout << \"NO existe ciclo hamiltoniano\" << endl;\n        return 0;\n    }\n    printSolution(path);\n    return 1;\n}\n\nint main() {\n    int graph1[V][V] = {\n        {0, 1, 0, 1, 0},\n        {1, 0, 1, 1, 1},\n        {0, 1, 0, 0, 1},\n        {1, 1, 0, 0, 1},\n        {0, 1, 1, 1, 0},};\n    // Imprimir soluciÃ³n\n    hamCycle(graph1);\n    int graph2[V][V] = {\n        {0, 1, 0, 1, 0},\n        {1, 0, 1, 1, 1},\n        {0, 1, 0, 0, 1},\n        {1, 1, 0, 0, 0},\n        {0, 1, 1, 0, 0},};\n    // Imprimir soluciÃ³n\n    hamCycle(graph2);\n}\n",
    "py": null,
    "orden": 8,
    "suborden": 13,
    "fecha_creacion": "2020-12-05 00:45:49",
    "fecha_modificacion": "2020-12-06 20:30:51"
  },
  {
    "ID": 144,
    "supergrupo": "Grafos ",
    "tema": "El tour del caballo de ajedrez ",
    "texto": "El backtracking es un paradigma algorítmico que intenta diferentes soluciones hasta que encuentra una solución que “Funciona”. Problemas los cuales son típicamente resueltos con técnicas de backtracking tienen una propiedad en común, estos problemas puede solo ser resueltos intentando cada posible configuración y cada configuración es intentada una sola vez, una solución ingenua para estos problemas es intentar todas las configuraciones e imprimir una configuración que siga las restricciones dadas por el problema. Backtracking funciona en forma incremental y es una optimización sobre las soluciones ingenuas donde todas las posibles configuraciones son generadas e intentadas.\n\nBacktracking funciona de forma incremental para atacar problemas, típicamente iniciamos desde un vector de solución vacío, y uno por uno vamos agregando ítems, cuando agregamos un ítem podemos verificar si agregando el siguiente ítem violamos alguna de las restricciones del problema, si lo hace eliminamos ese elemento e intentamos otras alternativas. Si ninguna de las alternativas funciona entonces volvemos a la fase previa y removemos el ítem anterior dado en la fase anterior. Si alcanzamos la fase inicial entonces decimos que no existe solución, si agregamos un valor que no viola alguna restricción entonces recursivamente agregamos ítems uno por uno, si el vector de solución se completa imprimimos la solución.\n\nEl siguiente es el backtracking del problema del tour del caballo en el tablero de ajedrez.\n- Si todos los cuadrados son visitados imprima la solución\n- Si no \na) Agregue uno de los siguientes movimientos posibles al vector de solución y recursivamente verifique si este movimiento lleva a una solución (Un caballo puede hacer máximo 8 movimientos, aquí escogemos alguno de esos 8 movimientos).\nb) Si el movimiento escogido arriba no lleva a una solución entonces removemos este movimiento del vector de solución e intentamos otros movimientos alternativos.\nc) Si ninguna de las alternativas funciona, retornamos falso (Retornando falso podemos remover el anterior ítem agregado en recursión y si el falso es retornado a la recursión inicial entonces no existe solución.\n",
    "complejidad_tiempo": "Mejor caso :    O(|v|+|e|)  Peor caso : O(|v|+|e|)  Promedio: O(|v|+|e|) ",
    "java": "// Programa java para el problema del tour del caballo\npublic class KnightTourBacktracking {\n\n    static int N = 8;\n\n    /* Una función que verifica si i.j es\n    indice valido para un tablero n*n*/\n    static boolean isSafe(int x, int y, int sol[][]) {\n        return (x >= 0 && x < N && y >= 0\n                && y < N && sol[x][y] == -1);\n    }\n\n    /* Imprimir la solución*/\n    static void printSolution(int sol[][]) {\n        for (int x = 0; x < N; x++) {\n            for (int y = 0; y < N; y++) {\n                System.out.print(sol[x][y] + \"\\t\");\n            }\n            System.out.println();\n        }\n    }\n        /*Esta función resuelve el problema de Knight Tour.\n       utilizando Backtracking. Esta función principalmente\n       utiliza solveKTUtil () para resolver el problema. Eso\n       devuelve falso si no es posible realizar un recorrido completo,\n       De lo contrario, devuelve true e imprime el recorrido.\n       Tenga en cuenta que puede haber más de una\n       soluciones, esta función imprime una de las\n       soluciones viables.*/\n    static boolean solveKT() {\n        int sol[][] = new int[N][N];\n        /* Inicializando la matriz de solución*/\n        for (int x = 0; x < N; x++) {\n            for (int y = 0; y < N; y++) {\n                sol[x][y] = -1;\n            }\n        }\n        /* xMove[] y yMove[] define el siguiente movimiento del caballo \n          xMove[] para siguiente valor en x\n          yMove[] para siguiente valor en y */\n        int xMove[] = {2, 1, -1, -2, -2, -1, 1, 2};\n        int yMove[] = {1, 2, 2, 1, -1, -2, -2, -1};\n        //Desde que el caballero inicie en el primer bloque\n        sol[0][0] = 0;\n        if (!solveKTUtil(0, 0, 1, sol, xMove, yMove)) {\n            System.out.println(\"No existe la solución\");\n            return false;\n        } else {\n            printSolution(sol);\n        }\n        return true;\n    }\n\n    static boolean solveKTUtil(int x, int y, int movei,\n            int sol[][], int xMove[],\n            int yMove[]) {\n        int k, next_x, next_y;\n        if (movei == N * N) {\n            return true;\n        }\n        /* Intenta todos los movimientos desde la coordenada\n        x  y y*/\n        for (k = 0; k < 8; k++) {\n            next_x = x + xMove[k];\n            next_y = y + yMove[k];\n            if (isSafe(next_x, next_y, sol)) {\n                sol[next_x][next_y] = movei;\n                if (solveKTUtil(next_x, next_y, movei + 1,\n                        sol, xMove, yMove)) {\n                    return true;\n                } else {\n                    sol[next_x][next_y] = -1;// backtracking \n                }\n            }\n        }\n        return false;\n    }\n    public static void main(String args[]) {\n        solveKT();\n    }\n}\n",
    "cpp": "#include <bits/stdc++.h>\n#define tablero 101\nusing namespace std;\nint N = 12;\n\nbool isSafe(int x, int y, int sol[tablero][tablero]) {\n    return (x >= 0 && x < N && y >= 0 && y < N && sol[x][y] == -1);\n}\n\nvoid printSolution(int sol[tablero][tablero]) {\n    for (int x = 0; x < N; x++) {\n        for (int y = 0; y < N; y++) {\n            cout << sol[x][y] << \"\\t\";\n        }\n        cout << endl;\n    }\n}\n\nbool solveKUtil(int x, int y, int movei, int sol[tablero][tablero], int xMove[tablero], int yMove[tablero]) {\n    int k, next_x, next_y;\n    if (movei == N * N) {\n        return true;\n    }\n    for (k = 0; k < N; k++) {\n        next_x = x + xMove[k];\n        next_y = y + yMove[k];\n        if (isSafe(next_x, next_y, sol)) {\n            sol[next_x][next_y] = movei;\n            if (solveKUtil(next_x, next_y, movei + 1, sol, xMove, yMove)) {\n                return true;\n            } else {\n                sol[next_x][next_y] = -1;\n            }\n        }\n    }\n    return false;\n}\n\nbool solveKT() {\n    int sol[tablero][tablero];\n    for (int x = 0; x < N; x++) {\n        for (int y = 0; y < N; y++) {\n            sol[x][y] = -1;\n        }\n    }\n    int xMove[8] = {2, 1, -1, -2, -2, -1, 1, 2};\n    int yMove[8] = {1, 2, 2, 1, -1, -2, -2, -1};\n    sol[0][0] = 0;\n    if (!solveKUtil(0, 0, 1, sol, xMove, yMove)) {\n        cout << \"No existe la solucion\" << endl;\n        return false;\n    } else {\n        printSolution(sol);\n    }\n    return true;\n}\n\nint main() {\n    solveKT();\n}\n",
    "py": null,
    "orden": 8,
    "suborden": 14,
    "fecha_creacion": "2020-12-05 00:45:50",
    "fecha_modificacion": "2022-03-08 14:36:15"
  },
  {
    "ID": 145,
    "supergrupo": "Grafos ",
    "tema": "15.16) Kosaraju DFS  Componentes fuertemente conexas ",
    "texto": "Dado un grafo dirigido, encontrar si el grafo se encuentra fuertemente conectado o no, un grado es fuertemente conectado si hay un camino entre cualquier par de vértices.\nEsto es fácil para un grafo no dirigido, solo tenemos que hacer BFS y DFS comenzando desde cualquier vértice, si BFS o DFS visita todos los vértices, entonces el grado no dirigido dado está conectado, esta aproximación no funciona con un grafo dirigido.\nUna simple idea es usar un algoritmo de todos los caminos más cortos entre todos los pares como Floyd Warshall o encontrar el cerramiento transitivo del grafo, la complejidad de tiempo de este método es de O (v^3).\nPodemos también hacer DFS V veces iniciando desde cada vértice, si alguno de los DFS no visita todos los vértices entonces el grafo no es fuertemente conectado. Este algoritmo toma O (V*(V+E)) en complejidad de tiempo, el cual puede ser el mismo del cerramiento transitivo para un grafo denso.\nUna mayor idea puede ser el algoritmo de componentes fuertemente conectadas (SCC), podemos encontrar todos los SCC en O (V+E) tiempo, si el número de SCC es 1, entonces el grafo es fuertemente conectado, el algoritmo de SCC hace trabajo extra cuando busca todos los SCC.\nEl siguiente es un algoritmo simple basado en el DFS de Kosaraju el cual realiza dos DFS transversos en el grafo.\n1) Inicializa todos los vértices como no visitados.\n2) Hace un DFS transverso del grado iniciando desde cualquier vértice v, si este DFS transverso no visita todos los vértices, entonces retorna falso.\n3) Reversa todos los arcos (O encuentra transpuesta o reversa de grafo)\n4) Marque todos los vértices como no visitados en el grafo reverso\n5) Hacer un DFS transverso del grafo reversado iniciando desde el mismo vértice v, si el DFS transverso no visita todos los vértices entonces retorna falso, de otro modo retorna true.\nLa idea es, si cada nodo puede ser alcanzado de un vértice v, y cada nodo puede alcanzar v, entonces el grafo es fuertemente conectado. En el paso dos podemos verificar si todos los vértices son alcanzables desde v, en el paso 4 verificamos si todos los vértices puede alcanzar v (En el grafo reverso, si todos los vértices son alcanzables desde v entonces todos los vértices pueden alcanzar v en el grafo original).\nLa complejidad de tiempo de esta implementaciones es la misma de DFS, el cual es O (V+E) si el grafo está representado usando listas de adyacencia.\n",
    "complejidad_tiempo": "Mejor caso :    O(|v|+|e|)  Peor caso : O(|v|+|e|)  Promedio: O(|v|+|e|) ",
    "java": "// Programa java que verifica si un grafo es \n// fuertemente conectado\n\nimport java.util.*;\nimport java.util.LinkedList;\n\npublic class KosarajuDFSStronglyConnected {\n\n    public static void main(String args[]) {\n        Graph g1 = new Graph(5);\n        g1.addEdge(0, 1);\n        g1.addEdge(1, 2);\n        g1.addEdge(2, 3);\n        g1.addEdge(3, 0);\n        g1.addEdge(2, 4);\n        g1.addEdge(4, 2);\n        if (g1.isSC()) {\n            System.out.println(\"Si\");\n        } else {\n            System.out.println(\"No\");\n        }\n        Graph g2 = new Graph(4);\n        g2.addEdge(0, 1);\n        g2.addEdge(1, 2);\n        g2.addEdge(2, 3);\n        if (g2.isSC()) {\n            System.out.println(\"Si\");\n        } else {\n            System.out.println(\"No\");\n        }\n    }\n\n    static class Graph {\n        private int V;\n        private LinkedList<Integer> adj[];\n        Graph(int v) {\n            V = v;\n            adj = new LinkedList[v];\n            for (int i = 0; i < v; ++i) {\n                adj[i] = new LinkedList();\n            }\n        }\n        void addEdge(int v, int w) {\n            adj[v].add(w);\n        }\n\n        void DFSUtil(int v, Boolean visited[]) {\n            visited[v] = true;\n            int n;\n            Iterator<Integer> i = adj[v].iterator();\n            while (i.hasNext()) {\n                n = i.next();\n                if (!visited[n]) {\n                    DFSUtil(n, visited);\n                }\n            }\n        }\n        // Obtiene el transpuesto de un grafo\n        Graph getTranspose() {\n            Graph g = new Graph(V);\n            for (int v = 0; v < V; v++) {\n                Iterator<Integer> i = adj[v].listIterator();\n                while (i.hasNext()) {\n                    g.adj[i.next()].add(v);\n                }\n            }\n            return g;\n        }\n        //Verifica si el grafo esta fuertemente conectado\n        Boolean isSC() {\n            /*Paso 1: marcar todos los vertices como no visitados\n            (primer DFS)*/\n            Boolean visited[] = new Boolean[V];\n            for (int i = 0; i < V; i++) {\n                visited[i] = false;\n            }\n            //Paso 2: DFS transverso desde el primer vertice\n            DFSUtil(0, visited);\n            // si no visita todos, retorna falso\n            for (int i = 0; i < V; i++) {\n                if (visited[i] == false) {\n                    return false;\n                }\n            }\n            // Paso 3: crear grafo transpuesto\n            Graph gr = getTranspose();\n            // Paso 4: marcar todos los vertices como no visitados\n            // (Segundo DFS)\n            for (int i = 0; i < V; i++) {\n                visited[i] = false;\n            }\n            /* Paso 5: hacer DFS en el grafo reversado*/\n            gr.DFSUtil(0, visited);\n            /* Si todos los vertices no son visitados, retorne falso*/\n            for (int i = 0; i < V; i++) {\n                if (visited[i] == false) {\n                    return false;\n                }\n            }\n            return true;\n        }\n    }\n}\n",
    "cpp": null,
    "py": null,
    "orden": 8,
    "suborden": 15,
    "fecha_creacion": "2020-12-05 00:45:50",
    "fecha_modificacion": "2020-12-06 20:30:53"
  },
  {
    "ID": 146,
    "supergrupo": "Grafos ",
    "tema": "Mínimo de movimientos de un caballo de ajedrez ",
    "texto": "Dado una mesa de ajedrez cuadrada de tamaño NxN, la posición de un caballo y la posición objetivo, necesitamos encontrar la mínima cantidad de pasos que un caballo toma para llegar a la posición objetivo.\nEste problema puede verse como el camino más corto en un grafo sin pesos, sin embargo usamos BFS ´para resolver este problema, intentamos todos las 8 posibles posiciones donde un caballo puede llegar desde su posición, si la posición alcanzable no ha sido visitada ya y está dentro del tablero, agregamos este estado dentro de la cola con una distancia de 1 más que su estado padre, finalmente retornamos la distancia de la posición objetivo cuando sale de la cola.\nEl siguiente código implementa BFS para la búsqueda a través de las celdas, donde cada celda contiene sus coordenadas y distancias desde el nodo inicial, en el peor de los casos el código visita todas las celdas del tablero, haciendo que el la complejidad del peor de los casos sea O(n^2).\n",
    "complejidad_tiempo": "Mejor caso :    O(|v|+|e|)  Peor caso : O(v2)  Promedio: O(|v|+|e|) ",
    "java": "//Programa java que encuentra la minima cantidad de pasos\n// para alcanzar una celda especifica con un caballo\n\nimport java.util.Vector;\n\npublic class MinimumMovesKnight {\n\n    /*Clase que almacena los datos de una celda*/\n    static class cell {\n\n        int x, y;\n        int dis;\n\n        public cell(int x, int y, int dis) {\n            this.x = x;\n            this.y = y;\n            this.dis = dis;\n        }\n    }\n\n    /* Utilidad que retorna s (x,y) yace dentro del tablero*/\n    static boolean isInside(int x, int y, int N) {\n        return x >= 1 && x <= N && y >= 1 && y <= N;\n    }\n\n    /* Retorna los minimos pasos para llegar al objetivo*/\n    static int minStepToReachTarget(int knightPos[], int targetPos[],\n            int N) {\n        // dirección x y y, donde el caballo puede llegar \n        int dx[] = {-2, -1, 1, 2, -2, -1, 1, 2};\n        int dy[] = {-1, -2, -2, -1, 1, 2, 2, 1};\n        // Vector para almacenar los estados del caballo\n        Vector<cell> q = new Vector<>();\n        // Agrega la posicion inicial con distancia 0\n        q.add(new cell(knightPos[0], knightPos[1], 0));\n        cell t;\n        int x, y;\n        boolean visit[][] = new boolean[N + 1][N + 1];\n        //Hacer todas las celdas sin visitar\n        for (int i = 1; i <= N; i++) {\n            for (int j = 1; j <= N; j++) {\n                visit[i][j] = false;\n            }\n        }\n\n        // visitar estado inicial\n        visit[knightPos[0]][knightPos[1]] = true;\n        // ciclo hasta que quede solo un valor \n        while (!q.isEmpty()) {\n            t = q.firstElement();\n            q.remove(0);\n            /* Si la celda actual es igual al objetivo\n            retorne su distancia*/\n            if (t.x == targetPos[0] && t.y == targetPos[1]) {\n                return t.dis;\n            }\n            // Ciclo de todos los estados alcancables\n            for (int i = 0; i < 8; i++) {\n                x = t.x + dx[i];\n                y = t.y + dy[i];\n                if (isInside(x, y, N) && !visit[x][y]) {\n                    visit[x][y] = true;\n                    q.add(new cell(x, y, t.dis + 1));\n                }\n            }\n        }\n        return Integer.MAX_VALUE;\n    }\n\n    public static void main(String[] args) {\n        int N = 30;\n        int knightPos[] = {1, 1};\n        int targetPos[] = {30, 30};\n        System.out.println(minStepToReachTarget(knightPos, targetPos, N));\n    }\n}\n",
    "cpp": null,
    "py": null,
    "orden": 8,
    "suborden": 16,
    "fecha_creacion": "2020-12-05 00:45:50",
    "fecha_modificacion": "2020-12-06 20:30:53"
  },
  {
    "ID": 147,
    "supergrupo": "Grafos ",
    "tema": "El problema de las N reinas",
    "texto": "El problema de las N reinas es aquel en donde se colocan N reinas en un tablero de NxN de tal manera que dos reinas no puedan atacarse una con otra.\nLa idea es colocar reinas una por una en diferentes columnas, iniciando desde la columna de más a la izquierda, cuando colocamos una reina en una columna, verificamos por colisiones con las reinas ya colocadas, en la columna actual, si encontramos una fila en la cual no hay colisión marcamos esta columna y fila como parte de la solución, si nosotros no encontramos tal fila en donde haya colisión entonces se retrocede y se retorna falso.\n1) Iniciar desde la columna de más a la izquierda.\n2) Si todas las reinas han sido colocadas, retornar true\n3) Intentar todas las filas de la  columna actual\nRealizar lo siguiente para cada columna intentada\na) si la reina puede ser colocada seguramente en esta fila entonces marcar esta [fila, columna] como parte de la solución y recursivamente verificar si colocando una reina aquí se llega a la solución.\nb) Si colocando una reina en [fila,columa] se llega a una solución, entonces retorne true.\nc) Si colocando una reina no se llega a la solución entonces desmarque esta fila y columna (Paso atrás) y vaya al paso A para intentar otras filas.\n4) Si todas las filas han sido probadas y ninguna funciona retorne falso para activar el backtracking.\n",
    "complejidad_tiempo": "Mejor caso :    O(v3)  Peor caso : O(v3) Promedio: O(v3) ",
    "java": "/* Programa JAVA que resuelve el problema de las N reinas\nusando backtracking*/\npublic class NQueenProblem {\n    final int N = 4;\n\n    void printSolution(int board[][]) {\n        for (int i = 0; i < N; i++) {\n            for (int j = 0; j < N; j++) {\n                System.out.print(\" \" + board[i][j]\n                        + \" \");\n            }\n            System.out.println();\n        }\n    }\n/*Una función de utilidad para comprobar si una reina puede\n       colocarse en board[row][col]. Tenga en cuenta que \n       La función se llama cuando \"col\" reinas ya están\n       Colocadas en columnas de 0 a col -1. Así que necesitamos\n       para comprobar sólo el lado izquierdo para las reinas atacantes*/\n    boolean isSafe(int board[][], int row, int col) {\n        int i, j;\n        /*Verifica esta fila en el lado izquierdo*/\n        for (i = 0; i < col; i++) {\n            if (board[row][i] == 1) {\n                return false;\n            }\n        }\n        /*Verifica la diagonal superior de la izquierda*/\n        for (i = row, j = col; i >= 0 && j >= 0; i--, j--) {\n            if (board[i][j] == 1) {\n                return false;\n            }\n        }\n        /*Diagonal baja desde la izquierda*/\n        for (i = row, j = col; j >= 0 && i < N; i++, j--) {\n            if (board[i][j] == 1) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    boolean solveNQUtil(int board[][], int col) {\n        /* Caso base: Si todas las reinas estan\n        puestas, retorne true*/\n        if (col >= N) {\n            return true;\n        }\n        /*Considere esta columna e intente colocando esta \n        reina en todas las filas una por una*/\n        for (int i = 0; i < N; i++) {\n            /* Verifica si la reina puede ser puesta\n            en board[i][col] */\n            if (isSafe(board, i, col)) {\n                board[i][col] = 1;\n                /*Recursivamente pone todas las reinas*/\n                if (solveNQUtil(board, col + 1) == true) {\n                    return true;\n                }\n                board[i][col] = 0; // BACKTRACK \n            }\n        }\n        /*Si la reina no puede ser puesta en \n        ninguna fila en esta columna,r retorna falso*/\n        return false;\n    }\n\n    /*Esta función resuelve el problema de N Queen usando\n    Backtracking. Utiliza principalmente solveNQUtil() \n    para resolver el problema. Devuelve false si no se \n    pueden colocar las reinas; de lo contrario, devuelve \n    true e imprime la ubicación de las reinas en forma de \n    1s. Tenga en cuenta que puede haber más de una solución,\n    esta función imprime una de las soluciones posibles.*/\n    boolean solveNQ() {\n        int board[][] = {{0, 0, 0, 0},\n        {0, 0, 0, 0},\n        {0, 0, 0, 0},\n        {0, 0, 0, 0}\n        };\n        if (solveNQUtil(board, 0) == false) {\n            System.out.print(\"Solución no existe\");\n            return false;\n        }\n        printSolution(board);\n        return true;\n    }\n\n    public static void main(String args[]) {\n        NQueenProblem Queen = new NQueenProblem();\n        Queen.solveNQ();\n    }\n}\n",
    "cpp": null,
    "py": null,
    "orden": 8,
    "suborden": 17,
    "fecha_creacion": "2020-12-05 00:45:50",
    "fecha_modificacion": "2020-12-06 20:30:54"
  },
  {
    "ID": 148,
    "supergrupo": "Grafos ",
    "tema": "Ordenamiento topológico",
    "texto": "Ordenamiento topológico de un grafo dirigido aciclico (DAG) es un ordenamiento lineal de vértices tales que por cada camino dirigido uv, el vértice u venga antes de v en el orden, si el grafo no es DAG no es posible el ordenamiento topológico.\nEn DFS imprimimos un vértice y luego recursivamente llamamos DFS para los vértices adyacentes, en el ordenamiento topológico necesitamos imprimir un vértice antes de sus vértices adyacentes.\n",
    "complejidad_tiempo": "Mejor caso :    O(|v|+|e|)  Peor caso : O(|v|+|e|)  Promedio: O(|v|+|e|) ",
    "java": "// Programa java que imprime el ordenamiendo topologico\n// de un grafo dirigido\n\nimport java.util.*;\n\npublic class TopologicalSorting {\n    public static void main(String args[]) {\n        Graph g = new Graph(6);\n        g.addEdge(5, 2);\n        g.addEdge(5, 0);\n        g.addEdge(4, 0);\n        g.addEdge(4, 1);\n        g.addEdge(2, 3);\n        g.addEdge(3, 1);\n        System.out.println(\"Siguiendo el ordenamiento topologico \"\n                + \"del grafo dado \");\n        g.topologicalSort();\n    }\n\n    static class Graph {\n        private int V;\n        private LinkedList<Integer> adj[];\n        Graph(int v) {\n            V = v;\n            adj = new LinkedList[v];\n            for (int i = 0; i < v; ++i) {\n                adj[i] = new LinkedList();\n            }\n        }\n\n        void addEdge(int v, int w) {\n            adj[v].add(w);\n        }\n\n        void topologicalSortUtil(int v, boolean visited[],\n                Stack stack) {\n            visited[v] = true;\n            Integer i;\n            Iterator<Integer> it = adj[v].iterator();\n            while (it.hasNext()) {\n                i = it.next();\n                if (!visited[i]) {\n                    topologicalSortUtil(i, visited, stack);\n                }\n            }\n            stack.push(new Integer(v));\n        }\n        void topologicalSort() {\n            Stack stack = new Stack();\n            boolean visited[] = new boolean[V];\n            for (int i = 0; i < V; i++) {\n                visited[i] = false;\n            }\n            for (int i = 0; i < V; i++) {\n                if (visited[i] == false) {\n                    topologicalSortUtil(i, visited, stack);\n                }\n            }\n            // Imprime el contenido de la pila\n            while (stack.empty() == false) {\n                System.out.print(stack.pop() + \" \");\n            }\n        }\n    }\n}\n",
    "cpp": null,
    "py": null,
    "orden": 8,
    "suborden": 18,
    "fecha_creacion": "2020-12-05 00:45:51",
    "fecha_modificacion": "2020-12-06 20:30:54"
  },
  {
    "ID": 149,
    "supergrupo": "Grafos ",
    "tema": "Algoritmo de Kahn para ordenamiento topológico ",
    "texto": "Ordenamiento topológico para un grafo dirigido aciclico (DAG) es un ordenamiento lineal de vértices el cual por cada camino dirigido UV, el vértice U viene antes de V en el ordenamiento, el ordenamiento topológico no es posible si el grafo no es un DAG.\nLos pasos de este algoritmo son los siguientes:\n1) Calcule los grados de entrada de cada vértice en el DAG presente e inicialice el conteo de los nodos visitados como 0.\n2) Tome todos los vértices con grado de entrada como o y agréguelos en una cola\n3) Remueva un vértice de la cola y entonces incremente el conteo de nodos visitados por 1\n4) Decremente el grado de entrada en 1 en todos los nodos vecinos, si el grado de entrada de los nodos vecinos es cero, agréguelos a la cola.\n5) Repita el paso 3 hasta que la cola este vacía.\n6) Si el conteo de nodos visitados no es igual al número de notos en el grado entonces el ordenamiento topológico no es posible en este grafo.\n¿Cómo encontrar el grado de entrada en cada nodo?\nExisten dos vías  para encontrar el grado de entrada de  cada nodo.\nTomaremos un array de grado de entrada para mantener rastreo de estos.\n1) Atraviese el array de nodos y simplemente incremente el conteo del nodo de destino en 1-\nfor each node in Nodes\n    indegree[node] = 0;\nfor each edge(src,dest) in Edges\n    indegree[dest]++\n2) Atraviese la lista de cada nodo e incremente el grado de entrada de todos los nodos conectados con él en 1\nfor each node in Nodes\n        If (list[node].size()!=0) then\n        for each dest in list\n            indegree[dest]++;\nLa complejidad de tiempo se da por: el ciclo externo será ejecutado V número de veces y el interno será ejecutado E número de veces, la complejidad resultante será de O(V+E).\n",
    "complejidad_tiempo": "Mejor caso :    O(|v|+|e|)  Peor caso : O(|v|+|e|)  Promedio: O(|v|+|e|) ",
    "java": "// Programa java que imprime el ordenamiento topologico\n// de un grafo  \n\nimport java.util.*;\n\npublic class KahnAlgorithmTopologicalSorting {\n\n    public static void main(String args[]) {\n        Graph g = new Graph(6);\n        g.addEdge(5, 2);\n        g.addEdge(5, 0);\n        g.addEdge(4, 0);\n        g.addEdge(4, 1);\n        g.addEdge(2, 3);\n        g.addEdge(3, 1);\n        System.out.println(\"Siguiendo su ordenamiento topologico \");\n        g.topologicalSort();\n    }\n\n    static class Graph {\n        int V;\n        List<Integer> adj[];\n        public Graph(int V)// Constructor \n        {\n            this.V = V;\n            adj = new ArrayList[V];\n            for (int i = 0; i < V; i++) {\n                adj[i] = new ArrayList<>();\n            }\n        }\n        // Agregar caminos\n        public void addEdge(int u, int v) {\n            adj[u].add(v);\n        }\n\n        public void topologicalSort() {\n            // Crea un array para almaccenar los indegrees\n            // de todos los vertices e inicializa en 0\n            int indegree[] = new int[V];\n            // Atraviesa las listas de adyacencia para llenar\n            // grados de los vertices       \n            for (int i = 0; i < V; i++) {\n                ArrayList<Integer> temp = (ArrayList<Integer>) adj[i];\n                temp.forEach((node) -> {\n                    indegree[node]++;\n                });\n            }\n            /* Crea una cola y encola todos los vertices\n            con grado 0*/\n            Queue<Integer> q = new LinkedList<>();\n            for (int i = 0; i < V; i++) {\n                if (indegree[i] == 0) {\n                    q.add(i);\n                }\n            }\n            // Inicializa el conteo de vertices visitados\n            int cnt = 0;\n            // Crea un vector que almacena el resultado\n            ArrayList<Integer> topOrder = new ArrayList<Integer>();\n            while (!q.isEmpty()) {\n                int u = q.poll();\n                topOrder.add(u);\n  //Funcion lamba Reemplazable con un for\n                adj[u].stream().filter((node) -> (--indegree[node] == 0)).forEachOrdered((node) -> {\n                    q.add(node);\n                });\n                cnt++;\n            }\n            // Verifica si hay ciclo       \n            if (cnt != V) {\n                System.out.println(\"There exists a cycle in the graph\");\n                return;\n            }\n            //Imprime el ordenamiento topologico             \n            for (int i : topOrder) {\n                System.out.print(i + \" \");\n            }\n        }\n    }\n}\n",
    "cpp": null,
    "py": null,
    "orden": 8,
    "suborden": 19,
    "fecha_creacion": "2020-12-05 00:45:51",
    "fecha_modificacion": "2020-12-06 20:30:55"
  },
  {
    "ID": 150,
    "supergrupo": "Grafos ",
    "tema": "Caminos más cortos mediante Dijkstra",
    "texto": "Dado un grafo y un vértice origen en el grafo, encuentre los caminos más cortos del origen a todos los vértices en el grafo dado.\n\nLa complejidad de tiempo de esta implementación es de O (V*E) si el grafo de entrada está representado usando una lista de adyacencia. Tener en cuenta que Dijkstra no procesa pesos negativos y no detecta ciclos negativos.\n",
    "complejidad_tiempo": "Mejor caso :    O(v*e)  Peor caso : O(v2)  Promedio: O(v*e) ",
    "java": "// Implementación java del algoritmo de Dijkstra que\n// busca el camino más corto de un nodo al resto\n/*\n EJEMPLO DE INPUT\n 5 9\n 1 2 7\n 1 4 2\n 2 3 1\n 2 4 2\n 3 5 4\n 4 2 3\n 4 3 8\n 4 5 5\n 5 3 5\n 1\n */\nimport java.util.*;\n\npublic class DijkstraSP {\n\n    //similar a los defines de C++\n    static final int MAX = 10005; //maximo número de vértices\n    static final int INF = 1 << 30; //definimos un valor \n    //grande que represente la distancia infinita\n    //inicial, basta conque sea superior al maximo \n    //valor del peso en alguna de las aristas\n    //En el caso de java usamos una clase que \n    //representara el pair de C++\n\n    static class Node implements Comparable<Node> {\n\n        int first, second;\n\n        Node(int d, int p) { //constructor\n            this.first = d;\n            this.second = p;\n        }\n\n        @Override\n        public int compareTo(Node other) { //es necesario \n            //definir un comparador para el\n            //correcto funcionamiento del PriorityQueue\n            if (second > other.second) {\n                return 1;\n            }\n            if (second == other.second) {\n                return 0;\n            }\n            return -1;\n        }\n    };\n\n    static Scanner sc = new Scanner(System.in); //para lectura de datos\n    static List< List< Node>> ady = new ArrayList< List< Node>>(); //lista de adyacencia\n    static int distancia[] = new int[MAX]; // distancia de vértice inicial\n    //vértice con ID = u\n    static boolean visitado[] = new boolean[MAX]; //para vértices visitados\n    static PriorityQueue< Node> Q = new PriorityQueue<Node>();\n    //usamos el comparador definido para \n    //que el de menor valor este en el tope\n    static int V; //número de vertices\n    static int previo[] = new int[MAX]; //para la impresion de caminos\n\n    //función de inicialización\n    static void init() {\n        for (int i = 0; i <= V; ++i) {\n            distancia[i] = INF; //inicializamos todas \n            //las distancias con valor infinito\n            visitado[i] = false; //inicializamos todos \n            //los vértices como no visitados\n            previo[i] = -1; //inicializamos el previo \n            //del vertice i con -1\n        }\n    }\n\n    //Paso de relajacion\n    static void relajacion(int actual, int adyacente, int peso) {\n        //Si la distancia del origen al vertice actual + \n        //peso de su arista es menor a la distancia del\n        //origen al vertice adyacente\n        if (distancia[actual] + peso < distancia[adyacente]) {\n            //relajamos el vertice actualizando la distancia\n            distancia[adyacente] = distancia[actual] + peso;\n            //a su vez actualizamos el vértice previo\n            previo[adyacente] = actual;\n            //agregamos adyacente a la cola de prioridad\n            Q.add(new Node(adyacente, distancia[adyacente]));\n        }\n    }\n    //Impresion del camino más corto desde el vertice inicial y final ingresados\n    static void print(int destino) {\n        if (previo[destino] != -1) //si aun poseo un vertice previo\n        {\n            print(previo[destino]); //recursivamente sigo explorando\n        }\n        //terminada la recursion imprimo los vertices\n        //recorridos\n        System.out.printf(\"%d \", destino);\n    }\n\n    static void dijkstra(int inicial) {\n        init(); //inicializamos nuestros arreglos\n        //Insertamos el vértice inicial en la Cola de Prioridad\n        Q.add(new Node(inicial, 0));\n        //Este paso es importante, inicializamos la distancia del\n        //inicial como 0\n        distancia[inicial] = 0;\n        int actual, adyacente, peso;\n        while (!Q.isEmpty()) { //Mientras cola no este vacia\n            //Obtengo de la cola el nodo con menor peso, en un\n            //comienzo será el inicial\n            actual = Q.element().first;\n            Q.remove(); //Sacamos el elemento de la cola\n            if (visitado[actual]) {\n                continue; //Si el vértice actual ya fue visitado entonces sigo\n            }//sacando elementos de la cola\n            visitado[actual] = true; //Marco como visitado el vértice actual\n            //reviso sus adyacentes del\n            //vertice actual\n            for (int i = 0; i < ady.get(actual).size(); ++i) {\n                adyacente = ady.get(actual).get(i).first; //id del vertice adyacente\n                //peso de la arista que une actual\n                //con adyacente ( actual , adyacente )\n                peso = ady.get(actual).get(i).second;\n                //si el vertice adyacente no fue visitado\n                if (!visitado[adyacente]) {\n                    //realizamos el paso de relajacion\n                    relajacion(actual, adyacente, peso);\n                }\n            }\n        }\n\n        System.out.printf(\"Distancias más cortas iniciando en vertice %d\\n\", inicial);\n        for (int i = 1; i <= V; ++i) {\n            System.out.printf(\"Vertice %d , distancia más corta = %d\\n\", i, distancia[i]);\n        }\n\n        System.out.println(\"\\n**************Impresion de camino más corto**************\");\n        System.out.printf(\"Ingrese vertice destino: \");\n        int destino;\n        destino = sc.nextInt();\n        print(destino);\n        System.out.printf(\"\\n\");\n    }\n\n    public static void main(String[] args) {\n        int E, origen, destino, peso, inicial;\n\n        V = sc.nextInt();\n        E = sc.nextInt();\n        for (int i = 0; i <= V; ++i) {\n            ady.add(new ArrayList<Node>()); //inicializamos lista de\n        }//adyacencia\n        for (int i = 0; i < E; ++i) {\n            origen = sc.nextInt();\n            destino = sc.nextInt();\n            peso = sc.nextInt();\n            ady.get(origen).add(new Node(destino, peso)); //grafo dirigido\n            //ady.get( destino ).add( new Node( origen , peso ) ); //no dirigido\n        }\n        System.out.print(\"Ingrese el vertice inicial: \");\n        inicial = sc.nextInt();\n        dijkstra(inicial);\n    }\n}\n",
    "cpp": "#include<bits/stdc++.h>\n#include<cstdlib>\n//---------------//\n#define MAX 10005\nconst int INF = 1 << 30;\n//---------------// \nusing namespace std;\n\nstruct Node {\n    int destino, peso;\n\n    Node(int _destino, int _peso) : destino(_destino), peso(_peso) {\n    }\n\n    Node() : destino(-1), peso(-1) {\n    }\n};\n\nstruct State {\n    int destino;\n    int peso;\n\n    State(int _destino, int _peso) : destino(_destino), peso(_peso) {\n    }\n\n    bool operator<(const State &b) const {\n        return peso > b.peso;\n    }\n};\nvector <vector<Node> >ady(MAX);\nint distancia[MAX];\nbool visited[MAX];\npriority_queue<State> Q;\nint previo[MAX];\n\nvoid init(int V) {\n    for (int i = 1; i <= V; i++) {\n        distancia[i] = INF;\n    }\n}\n\nvoid relajacion(int actual, int adyacente, int peso) {\n    if (distancia[actual] + peso < distancia[adyacente]) {\n        distancia[adyacente] = distancia[actual] + peso;\n        previo[adyacente] = actual;\n        Q.push(State{adyacente, distancia[adyacente]});\n    }\n}\n\nvoid print(int destino) {\n    if (previo[destino] != -1) {\n        print(previo[destino]);\n    }\n    cout << destino << \" \";\n}\n\nvoid dijkstra(int inicial, int V) {\n    init(V);\n    Q.push(State{inicial, 0});\n    distancia[inicial] = 0;\n    int actual, adyacente, peso;\n    while (!Q.empty()) {\n        actual = Q.top().destino;\n        Q.pop();\n        if (visited[actual]) {\n            continue;\n        }\n        visited[actual] = true;\n        for (int i = 0; i < ady[actual].size(); i++) {\n            adyacente = ady[actual][i].destino;\n            peso = ady[actual][i].peso;\n            if (!visited[adyacente]) {\n                relajacion(actual, adyacente, peso);\n            }\n        }\n    }\n    cout << \"distancia mas corta iniciada desde \" << inicial << endl;\n    for (int i = 1; i <= V; i++) {\n        cout << \"vertice \" << i << \" distancia mas corta = \" << distancia[i] << endl;\n    }\n    cout << \"impresion del camino mas corto\" << endl;\n    int destino;\n    cin>>destino;\n    print(destino);\n    cout << endl;\n}\n\nint main() {\n    memset(previo, -1, sizeof previo);\n    int V, E, origen, destino, peso, inicial;\n    cin >> V>>E;\n    for (int i = 0; i < E; i++) {\n        cin >> origen >> destino>>peso;\n        ady[origen].push_back(Node{destino, peso}); //dirigido\n        //ady[destino].push_back(Node{origen,peso});// no dirigido\n    }\n    cout << \"Inserte el verice inicial\" << endl;\n    cin>>inicial;\n    dijkstra(inicial, V);\n}\n",
    "py": null,
    "orden": 8,
    "suborden": 20,
    "fecha_creacion": "2020-12-05 00:45:51",
    "fecha_modificacion": "2020-12-06 20:30:56"
  },
  {
    "ID": 151,
    "supergrupo": "Grafos ",
    "tema": "15.22) Caminos más cortos mediante Bellman-Ford ",
    "texto": "Dado un grafo y un vértice de origen src en el grafo, encontrar los caminos más cortos desde src a todos los vértices en el grafo dado, el grafo puede contener caminos con pesos negativos. Si hay un ciclo de peso negativo, entonces las distancias más cortas no son calculadas, se reporta el ciclo negativo.\n1) Este paso inicializa las distancias desde el origen de todos los vértices como infinito y la distancia al origen en si como 0, crea un array dist[] de tamaño V con todos los valores como infinito excepto dist[src] donde src es el vértice origen.\n2) Este paso calcula las distancias más cortas, esto se realiza V-1 veces.\n3) si dist[v] > dist[u] + peso del camino uv, entonces actualice dist[] en dist[v] = dist[u] + weight of edge uv\n4) Este paso verifica si hay un ciclo negativo en el grafo, se realiza lo siguiente:\n5) si dist[v] > dist[u] + peso del camino uv, entonces “El grafo contiene un ciclo negativo”\nLa idea del paso 3 es, el paso 2 garantiza las distancias más cortas si el grafo no contiene un ciclo de peso negativo, si iteramos a través de todos los caminos una vez más y obtenemos un camino más corto para cualquier vértice, entonces  ahí hay un ciclo negativo.\nComo en otros problemas de programación dinámica, el algoritmo calcula los caminos más cortos de manera del atrás hacia adelante, primero calcula las distancias más cortas las cuales tienen  al menos una arista en el camino, luego calcula los caminos más cortos con al menos dos aristas, y así en adelante, luego de la iesima iteración del ciclo exterior, los caminos más cortos con al menos i aristas son calculados, ahí puede haber un máximo de V-1 aristas en un camino simple, por eso el ciclo externo se corre V-1 veces, la idea es, asumiendo que ahí no hay ciclo negativo, si calculamos los caminos más cortos con al menos i aristas, entonces una interacción sobre todos las aristas garantiza darnos el camino más corto con al menos i+1 artistas.\nEjemplo basado en la imagen anterior:\n\nDado el vértice origen 0, inicializamos todas las distancias como infinito, excepto la distancia al origen mismo, el número total de vértices en el grafo es 5 y todos los caminos deben ser procesados 4 veces.\nTodos las aristas son procesadas en el siguiente orden, (B, E), (D, B), (B, D), (A, B), (A, C), (D, C), (B, C), (E, D). Tenemos las siguientes distancias cuando todos las aristas son procesadas por primera vez, la primera fila \nLa primera iteración garantiza darnos todos los caminos más cortos los cuales tienen un largo de una arista, obtenemos las distancias siguientes cuando todos las aristas son procesadas por segunda vez.\nLa segunda iteración garantiza darnos todos los caminos más cortos que sean de 2 aristas más larga, el algoritmo procesa los caminos 2 veces más, las distancias son minimizadas luego de la segunda iteración, y la tercera y cuarta no actualiza distancias...\n1) Pesos negativos son encontrados en varias aplicaciones de grafos, por ejemplo en vez de pagar el costo por un camino, podemos obtener ventaja si seguimos el camino.\n2) Bellman-Ford trabaja mejor que Dijkstra para sistemas distribuidos, a diferencia de Dijkstra en donde necesitamos encontrar el valor menor de todos los vértices, en Bellman-Ford necesitamos considerar uno por uno.\n",
    "complejidad_tiempo": "Mejor caso :    O(v2*e)  Peor caso : O(v3)  Promedio: O(v2*e) ",
    "java": "// Implementación java del algoritmo de BellmanFord\n// para la busqueda del camino más corto de un vertice al\n// resto y con capacidad de detección de ciclo negativo\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Scanner;\n\npublic class BellmanFordSP {\n\n    static final int MAX = 105;\n    static final int INF = 1 << 30;\n    static int[] previo = new int[MAX];\n    static int[] distancia = new int[MAX];\n    static int vertices;\n    static List<List<Node>> adyacencia = new ArrayList<List<Node>>();\n    static Scanner sc = new Scanner(System.in);\n\n    static void inicializacion() {\n        for (int i = 0; i <= vertices; i++) {\n            distancia[i] = INF;\n            previo[i] = -1;\n        }\n    }\n\n    static class Node {\n        int first, second;\n        public Node(int destino, int peso) {\n            this.first = destino;\n            this.second = peso;\n        }\n    }\n\n    static void print(int destino) {\n        if (previo[destino] != -1) {\n            print(previo[destino]);\n        }\n        System.out.printf(\"%d \", destino);\n    }\n\n    static boolean relajacion(int actual, int adyacente, int peso) {\n        if (distancia[actual] + peso < distancia[adyacente]) {\n            distancia[adyacente] = distancia[actual] + peso;\n            previo[adyacente] = actual;\n            return true;\n        }\n        return false;\n    }\n\n    static void bellmanFord(int inicial) {\n        inicializacion();\n        distancia[inicial] = 0;\n        for (int i = 0; i < vertices - 1; i++) {\n            for (int actual = 0; actual < vertices; actual++) {\n                for (int j = 0; j < adyacencia.get(actual).size(); j++) {\n                    int adyacente = adyacencia.get(actual).get(j).first;\n                    int peso = adyacencia.get(actual).get(j).second;\n                    relajacion(actual, adyacente, peso);\n                }\n            }\n        }\n        for (int actual = 0; actual < vertices; actual++) {\n            for (int j = 0; j < adyacencia.get(actual).size(); j++) {\n                int adyacente = adyacencia.get(actual).get(j).first;\n                int peso = adyacencia.get(actual).get(j).second;\n                if (relajacion(actual, adyacente, peso)) {\n                    System.out.println(\"Existe ciclo negativo\");\n                    return;\n                }\n            }\n        }\n        System.out.println(\"No existe ciclo negativo\");\n        System.out.printf(\"Distancias más corteas iniciando en el nodo %d\\n\", inicial);\n        for (int i = 0; i < vertices; i++) {\n            System.out.printf(\"Nodo %d , distancia más corta = %d\\n\", i, distancia[i]);\n        }\n        System.out.println(\"\\n ________Camino más corto____\");\n        System.out.println(\"Ingrese vertice destino: \");\n        int destino = sc.nextInt();\n        print(destino);\n        System.out.println(\"\");\n    }\n\n    public static void main(String[] args) {\n        int E, origen, destino, peso, inicial;\n        vertices = sc.nextInt();\n        E = sc.nextInt();\n        for (int i = 0; i < 10; i++) {\n            adyacencia.add(new ArrayList<>());\n        }\n        for (int i = 0; i < E; i++) {\n            origen = sc.nextInt();\n            destino = sc.nextInt();\n            peso = sc.nextInt();\n            adyacencia.get(origen).add(new Node(destino, peso));\n        }\n        System.out.printf(\"Ingrese el nodo inicial: \");\n        inicial = sc.nextInt();\n        bellmanFord(inicial);\n    }\n}\n",
    "cpp": "#include<bits/stdc++.h>\n#include<cstdlib>\n//---------------//\n#define MAX 105\nusing namespace std;\nint previo[MAX];\nint distancia[MAX];\n\nvoid init(int vertices) {\n    for (int i = 0; i <= vertices; i++) {\n        distancia[i] = INT_MAX;\n        previo[i] = -1;\n    }\n}\n\nvoid printPath(int destino) {\n    if (previo[destino] != -1)printPath(previo[destino]);\n    printf(\"%d \", destino);\n}\n\nbool relajacion(int actual, int adyacente, int peso) {\n    if (distancia[actual] + peso < distancia[adyacente]) {\n        distancia[adyacente] = distancia[actual] + peso;\n        previo[adyacente] = actual;\n        return true;\n    }\n    return false;\n}\nvector<vector<pair <int, int> > >ady(MAX);\n\nvoid BellmanFord(int inicial, int vertices) {\n    init(vertices);\n    distancia[inicial] = 0;\n    for (int i = 0; i < vertices; i++) {\n        for (int actual = 0; actual < vertices; actual++) {\n            for (int j = 0; j < ady[actual].size(); j++) {\n                int adyacente = ady[actual][j].first;\n                int peso = ady[actual][j].second;\n                relajacion(actual, adyacente, peso);\n            }\n        }\n    }\n    for (int actual = 0; actual < vertices; actual++) {\n        for (int j = 0; j < ady[actual].size(); j++) {\n            int adyacente = ady[actual][j].first;\n            int peso = ady[actual][j].second;\n            if (relajacion(actual, adyacente, peso)) {\n                printf(\"Existe ciclo negativo\\n\");\n                return;\n            }\n        }\n    }\n    printf(\"No existe ciclo negativo\\ndistancias mas corta desde el nodo %d\", inicial);\n    for (int i = 0; i <= vertices; i++) {\n        printf(\"nodo %d distancia mas corta = %d\\n\", i, distancia[i]);\n    }\n    printf(\"camino mas corto hasta un destino\\n\");\n    int destino;\n    cin>>destino;\n    printPath(destino);\n    cout << endl;\n}\n\nint main() {\n    int E, origen, destino, peso, inicial, vertices;\n    cin >> vertices>>E;\n    for (int i = 0; i < E; i++) {\n        cin >> origen >> destino>>peso;\n        ady[origen].push_back(make_pair(destino, peso)); //dirigido\n        //ady[destino].push_back(make_pair{origen,peso});//NO dirigido\n    }\n    printf(\"Nodo inicial : \");\n    cin>>inicial;\n    BellmanFord(inicial, vertices);\n}\n",
    "py": null,
    "orden": 8,
    "suborden": 21,
    "fecha_creacion": "2020-12-05 00:45:52",
    "fecha_modificacion": "2020-12-06 20:30:56"
  },
  {
    "ID": 152,
    "supergrupo": "Grafos ",
    "tema": "Caminos más cortos entre todos los nodos Floyd-Warshall",
    "texto": "El algoritmo de Floyd Warshall se usa para la resolución de todos los caminos más cortos de todos los pares, el problema es encontrar las distancias más pequeñas entre cada par de vértices dado un grafo de caminos con pesos.\nInicializamos la matriz de la solución igual que la matriz de entrada del grafo en el primer paso, luego actualizamos la matriz de solución considerando todos los vértices en un vértice intermedio, la idea es uno por uno tomar todos los vértices y actualizar todos los caminos más cortos los cuales incluyen el vértice seleccionado como el vértice intermedio en el camino más corto. Cuando tomamos el vértice de número k como un vértice intermedio ya estamos considerando vértices {0,1,2…k-1} como intermedios, para cada par (i,j) del origen al destino respetivamente existen dos posibles casos.\n1) k no es un vértice intermedio en el camino más corto de i a j, mantenemos el valor de dist[i][j] como esta.\n2) K es un vértice intermedio en el camino más corto de i a j, actualizamos el valor de dist[i][j] como dist[i][k] + dist[k][j] if dist[i][j] > dist[i][k] + dist[k][j]\nLa complejidad de tiempo es: O(V^3) o O(N^3).\nEl programa solo imprime las distancias más cortas, podemos modificar la solución para imprimir el camino más corto ordenando la información del predecesor en una matriz separada.\nEl valor de INF puede ser tomado de INT_MAX o Integer.MAX_VALUE, lo que nos permite manejar el los valores máximos posibles.\n",
    "complejidad_tiempo": "Mejor caso :    O(v3  Peor caso : O(v3)  Promedio: O(v3) ",
    "java": "// Programa java que busca todos los caminos más cortos\n// en un grafo\n\nimport java.util.ArrayList;\nimport java.util.Scanner;\n\npublic class Main {\n\n    static int INF = 9999;\n    static int V = 0;\n    //grafo en matriz fija\n    static int[][] graph;\n    //matriz que almacena el camino recorrido\n    static int[][] next;\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        V = sc.nextInt();\n        graph = new int[V][V];\n        next = new int[V][V];\n        int E = sc.nextInt();\n        //Inicializa todo en infinito\n        for (int i = 0; i < V; i++) {\n            for (int j = 0; j < V; j++) {\n                graph[i][j] = INF;\n            }\n        }\n        // De un nodo al mismo nodo es 0\n        for (int i = 0; i < V; i++) {\n            graph[i][i] = 0;\n        }\n        for (int i = 0; i < E; i++) {\n            graph[sc.nextInt()][sc.nextInt()] = sc.nextInt();\n        }\n        floydWarshall(graph);\n        ArrayList<Integer> path;\n        System.out.println(\"El camino mas corto desde 0 a 3: \");\n        //Construit camino\n        path = constructPath(0, 3);\n        //imprimir camino\n        printPath(path);\n    }\n\n    static void floydWarshall(int graph[][]) {\n        int dist[][] = new int[V][V];\n        int i, j, k;\n        /*Inicialice la matriz de solución igual que \n            la matriz del gráfico de entrada. O podemos \n            decir que los valores iniciales de las distancias \n            más cortas se basan en las rutas más cortas, \n            considerando que no hay vértice intermedio. */\n        for (i = 0; i < V; i++) {\n            for (j = 0; j < V; j++) {\n                dist[i][j] = graph[i][j];\n                // Si no hay camino entre i y j\n                if (graph[i][j] == INF) {\n                    next[i][j] = -1;\n                } else {\n                    next[i][j] = j;\n                }\n            }\n        }\n\n            /*Agregue todos los vértices uno por uno al conjunto \n            de vértices intermedios.\n            ---> Antes del inicio de una iteración, tenemos \n            distancias más cortas entre todos los pares de vértices, \n            de modo que las distancias más cortas consideran solo\n            los vértices en el conjunto {0, 1, 2, .. k-1} como \n            vértices intermedios.\n            ----> Después del final de una iteración, el vértice \n            número k se agrega al conjunto de vértices intermedios \n            y el conjunto se convierte en {0, 1, 2, ... k} */\n        for (k = 0; k < V; k++) {\n            //Toma todos los vertices como inicio uno por uno\n            for (i = 0; i < V; i++) {\n                /* Toma todos los vertices como destino del\n                    incio del origen seleccionado*/\n                for (j = 0; j < V; j++) {\n                    // Si vertice k esa en el camino más corto\n                    // desde i a j, actualiza el valor de dist[i][j]\n                    // No podemos viajar por un camino si no existe\n                    if (dist[i][k] == INF|| dist[k][j] == INF) {\n                        continue;\n                    }\n                    if (dist[i][j] > dist[i][k]+ dist[k][j]) {\n                        dist[i][j] = dist[i][k]+ dist[k][j];\n                        next[i][j] = next[i][k];\n                    }\n                }\n            }\n        }\n        //Imprime la matriz de distancias cortas\n        printSolution(dist);\n    }\n\n    static ArrayList<Integer> constructPath(int u, int v) {\n        // si no hay camino devuelve una lista vacia\n        if (next[u][v] == -1) {\n            return new ArrayList<>();\n        }\n        // Almacenando el camino en el vector\n        ArrayList<Integer> path = new ArrayList<>();\n        path.add(u);\n        while (u != v) {\n            u = next[u][v];\n            path.add(u);\n        }\n        return path;\n    }\n\n    static void printPath(ArrayList<Integer> path) {\n        int n = path.size();\n        for (int i = 0; i < n - 1; i++) {\n            System.out.print(path.get(i) + \" -> \");\n        }\n        System.out.println(path.get(n - 1) + \" -> \");\n    }\n\n    static void printSolution(int dist[][]) {\n        System.out.println(\"La siguiente matriz muestra las distancias \"\n                + \"más cortas entre cada par de vertices\");\n        for (int i = 0; i < V; ++i) {\n            for (int j = 0; j < V; ++j) {\n                if (dist[i][j] == Main.INF) {\n                    System.out.print(\"INF \");\n                } else {\n                    System.out.print(dist[i][j] + \" \");\n                }\n            }\n            System.out.println();\n        }\n    }\n}\n",
    "cpp": "#include<bits/stdc++.h>\n#include<cstdlib>\n//--------------//\n#define INF 9999\n#define MAX 256\nusing namespace std;\nconst int V = 4;\nint next[V][V];\n\nvoid printPath(vector<int> path) {\n    int n = path.size() - 1;\n    for (int i = 0; i < n - 1; i++) {\n        cout << path[i] << \" -> \";\n    }\n    cout << path[n - 1] << \" -> \" << endl;\n}\n\nint constructPath(int u, int v) {\n    if (next[u][v] == -1) {\n        return 0;\n    }\n    vector<int>path;\n    path.push_back(u);\n    while (u != v) {\n        u = next[u][v];\n        path.push_back(u);\n    }\n    printPath(path);\n    return 1;\n}\n\nvoid printSolution(int dist[V][V]) {\n    cout << \"La siguiente matriz muestra las distancias mas cortas entre cada par de vertices\\n\";\n    for (int i = 0; i < V; ++i) {\n        for (int j = 0; j < V; ++j) {\n            if (dist[i][j] == INF) {\n                cout << \"INF \\t\";\n            } else {\n                cout << dist[i][j] << \"\\t\";\n            }\n        }\n        cout << endl;\n    }\n}\n\nvoid floydWarshall(int graph[V][V]) {\n    int dist[V][V];\n    int i, j, k;\n    for (i = 0; i < V; i++) {\n        for (j = 0; j < V; j++) {\n            dist[i][j] = graph[i][j];\n            if (graph[i][j] == INF) {\n                next[i][j] = -1;\n            } else {\n                next[i][j] = j;\n            }\n        }\n    }\n    for (k = 0; k < V; k++) {\n        for (i = 0; i < V; i++) {\n            for (j = 0; j < V; j++) {\n                if (dist[i][k] == INF || dist[k][j] == INF) {\n                    continue;\n                }\n                if (dist[i][k] + dist[k][j] < dist[i][j]) {\n                    dist[i][j] = dist[i][k] + dist[k][j];\n                    next[i][j] = next[i][k];\n                }\n            }\n        }\n    }\n    printSolution(dist);\n}\n\nint main() {\n    int E, a, b, c;\n    cin>>E;\n    int graph[V][V];\n    for (int i = 0; i < V; i++) {\n        for (int j = 0; j < V; j++) {\n            graph[i][j] = INF;\n        }\n    }\n    for (int i = 0; i < V; i++) {\n        graph[i][i] = 0;\n    }\n    for (int i = 0; i < E; i++) {\n        cin >> a >> b>>c;\n        graph[a][b] = c;\n    }\n    floydWarshall(graph);\n    constructPath(0, 3);\n}\n",
    "py": null,
    "orden": 8,
    "suborden": 22,
    "fecha_creacion": "2020-12-05 00:45:52",
    "fecha_modificacion": "2020-12-06 20:30:57"
  },
  {
    "ID": 153,
    "supergrupo": "Grafos ",
    "tema": "Caminos más cortos en un grafo binario",
    "texto": "Dado un grafo donde cada camino tiene un peso de 0 o 1, un vértice inicial también es dado, encuentre el camino más corto desde el origen hasta cualquier otro vértice.\nEn el BFS normal de un grafo, todos los caminos son de igual peso, pero en BFS 0-1 ALGUNOS caminos pueden tener peso 0 y algunos 1, en este no podemos usar un array de booleanos para marcar los nodos visitados pero en cada paso podemos verificar la condición de distancia optima, usamos una cola de doble fin para almacenar el nodo, mientras realizamos BFS si un camino es encontrado con peso 0 el nodo es empujado al frente de la doble cola y si el camino tiene peso 1 es empujado atrás en la doble cola.\nEsta aproximación es similar a Dijkstra en que si la distancia más corta a un nodo es relajada por el nodo anterior entonces solo será empujada en la cola.\nLa idea de arriba trabaja en todos los casos, cuando sacamos un vértice, es el vértice de mínimo peso de todos los vértices restantes, si hay un vértice de peso 0 adyacente a el entonces este adyacente tiene la misma distancia, si hay un adyacente de peso 1, entonces este adyacente tiene la máxima distancia de todos los vértices en la cola doble, (Porque todos los otros vértices son adyacentes de actual eliminado vértice o adyacente de los anteriores eliminados).\nEste problema puede ser resuelto con Dijkstra pero el tiempo de complejidad seria de O(E + V Log V) donde por BFS puede ser de O(V+E).\n",
    "complejidad_tiempo": "Mejor caso :    O(v+e)  Peor caso : O(v+e)  Promedio: O(v+e) ",
    "java": "//Programa java que implementa el camino más corto\n// en un grafo binario\n\nimport java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Deque;\n\npublic class BinaryGraphShortestPath {\n    //Número de vertices\n    static int V = 9;\n    // Lista de listas que almacena los caminos\n    static ArrayList<ArrayList<node>> edges = new ArrayList<ArrayList<node>>();\n    public static void main(String[] args) {\n        for (int i = 0; i < V; i++) {\n            edges.add(new ArrayList<>());\n        }\n        addEdge(0, 1, 0);\n        addEdge(0, 7, 1);\n        addEdge(1, 7, 1);\n        addEdge(1, 2, 1);\n        addEdge(2, 3, 0);\n        addEdge(2, 5, 0);\n        addEdge(2, 8, 1);\n        addEdge(3, 4, 1);\n        addEdge(3, 5, 1);\n        addEdge(4, 5, 1);\n        addEdge(5, 6, 1);\n        addEdge(6, 7, 1);\n        addEdge(7, 8, 1);\n        int src = 0;//Nodo inicial\n        zeroOneBFS(src);\n    }\n\n    static void zeroOneBFS(int src) {\n        // Inicializa las distancias desde el nodo inicial\n        int dist[] = new int[V];\n        for (int i = 0; i < V; i++) {\n            dist[i] = Integer.MAX_VALUE;\n        }\n        //cola doble para el BFS. \n        Deque<Integer> Q = new ArrayDeque<>();\n        dist[src] = 0;\n        Q.add(src);\n        while (!Q.isEmpty()) {\n            int v = Q.getFirst();\n            Q.removeFirst();\n            for (int i = 0; i < edges.get(v).size(); i++) {\n                //Busca la distancia optima\n                if (dist[edges.get(v).get(i).to] > dist[v] + edges.get(v).get(i).weight) {\n                    dist[edges.get(v).get(i).to] = dist[v] + edges.get(v).get(i).weight;\n                    /* pone peso caminos de peso 0 al frente y 1 atras para \n                    que los vertices puedan ser procesados en orden ascendente\n                    por sus pesos*/\n                    if (edges.get(v).get(i).weight == 0) {\n                        Q.addFirst(edges.get(v).get(i).to);\n                    } else {\n                        Q.addLast(edges.get(v).get(i).to);\n                    }\n                }\n            }\n        }\n        //imprimiendo los caminos más cortos\n        for (int i = 0; i < V; i++) {\n            System.out.print(dist[i] + \" \");\n        }\n        System.out.println(\"\");\n    }\n    static void addEdge(int u, int v, int wt) {\n        edges.get(u).add(new node(v, wt));\n        edges.get(v).add(new node(u, wt));\n    }\n    // una estructura que representa los caminos\n    static class node {\n        // Dos variables, una denora el nodo\n        // destino y otra el peso\n        int to, weight;\n        public node(int to, int weight) {\n            this.to = to;\n            this.weight = weight;\n        }\n    }\n}\n",
    "cpp": null,
    "py": null,
    "orden": 8,
    "suborden": 23,
    "fecha_creacion": "2020-12-05 00:45:52",
    "fecha_modificacion": "2020-12-06 20:30:57"
  },
  {
    "ID": 154,
    "supergrupo": "Grafos ",
    "tema": "Grafo bipartito",
    "texto": "Un grafo bipartito es un grafo cuyos vértices pueden ser divididos en dos sets independientes, U y V en donde cada arista (u, v) conecta un vértice de U a V o un vértice de V a U. En otras palabras para cada arista (u,v) u pertenece a U y v pertenece a V, o viceversa, también podemos decir que no hay aristas que conecte vértices del mismo set.\nUn grafo bipartito es posible si el coloramiento del grafo es posible usando dos colores los cuales los vértices de un set son coloreados del mismo color.\nUna aproximación para verificar si un grafo es bipartito es verificar si el grafo es coloreable o no usando backtracking.\nEl siguiente es un algoritmo simple de verificación de bipartito usando  BFS.\n1) Asigna el color ROJO al vértice origen (Poniéndolo en el set U)\n2) Colorea todos los vecinos con color AZUL (poniéndolos en el set V)\n3) Colorear todos los vecinos del vecino anterior de color ROJO (Poniéndolos en U)\n4) De esta forma se asigna color a todos los vértices los cuales satisfacen todas las restricciones del coloramiento.\n5) Mientras asignamos colores, si encontramos un vecino que esta coloreado del mismo color del actual vértice entonces el grafo no puede ser coloreado, es decir no es bipartito.\nEl algoritmo solo funciona si el grafo es fuertemente conectado, en el código siempre empezamos desde el origen 0 y asumimos que los vértices son visitados desde el, una observación importante es un  grafo sin aristas es también bipartito, \nLa complejidad de tiempo de esta aproximación es la misma del BFS, O(V^2) si el grafo es representado con listas de adyacencia, se convierte en O(V+E).\n",
    "complejidad_tiempo": "Mejor caso :    O(v+e)  Peor caso : O(v+e)  Promedio: O(v+e) ",
    "java": "//Programa java que encuentra si un grafo es \n//bipartito o no\n\nimport java.util.*;\n\npublic class BipartiteGraph {\n\n    final static int V = 4;\n\n    static boolean isBipartite(int G[][], int src) {\n        /*Crear una matriz de colores para almacenar los \n        colores asignados a todas las verificaciones. \n        El número de vértice se utiliza como índice en \n        esta matriz. El valor '-1' de colorArr [i] se \n        usa para indicar que no se asigna ningún color \n        al vértice 'i'. El valor 1 se utiliza para indicar \n        que el primer color está asignado y el valor 0 \n        indica que el segundo color está asignado.*/\n        int colorArr[] = new int[V];\n        for (int i = 0; i < V; ++i) {\n            colorArr[i] = -1;\n        }\n        //Asigna primer color al origen\n        colorArr[src] = 1;\n        //Crea una cola de número de vertices\n        // y encola el vertice origen \n        LinkedList<Integer> q = new LinkedList<>();\n        q.add(src);\n        while (!q.isEmpty()) {\n            // Descola un vertice de la cola\n            int u = q.poll();\n            //Retorna falso si hay un autociclo\n            if (G[u][u] == 1) {\n                return false;\n            }\n            //Encuentra todos los vertoces adyacentes sin color \n            for (int v = 0; v < V; ++v) {\n                // Un camino de u a v existe\n                // y destino v no esta coloreado\n                if (G[u][v] == 1 && colorArr[v] == -1) {\n                    //Asigna color alternativo para esta adyacencia\n                    colorArr[v] = 1 - colorArr[u];\n                    q.add(v);\n                } /*Un camino de u a v existe y el destino \n                esta del mismo color que u*/ \n                else if (G[u][v] == 1 && colorArr[v] == colorArr[u]) {\n                    return false;\n                }\n            }\n        }\n        // Si llegamos aqui, todos los vertoces adyacentes pueden\n        // ser coloreados con color alternativo\n        return true;\n    }\n\n    public static void main(String[] args) {\n        int G[][] = {{0, 1, 0, 1},\n        {1, 0, 1, 0},\n        {0, 1, 0, 1},\n        {1, 0, 1, 0}\n        };\n        if (isBipartite(G, 0)) {\n            System.out.println(\"Si\");\n        } else {\n            System.out.println(\"No\");\n        }\n    }\n}\n",
    "cpp": "#include<bits/stdc++.h>\n#include<cstdlib>\nusing namespace std;\nconst int V = 4;\n\nbool isBipartite(int G[V][V], int src) {\n    int colorArr[V];\n    memset(colorArr, -1, sizeof colorArr);\n    colorArr[src] = 1;\n    vector<int>q;\n    q.push_back(src);\n    while (!q.empty()) {\n        int u = q.front();\n        q.erase(q.begin());\n        if (G[u][u] == 1) {\n            return false;\n        }\n        for (int v = 0; v < V; v++) {\n            if (G[u][v] == 1 && colorArr[v] == 1) {\n                colorArr[v] = 1 - colorArr[u];\n                q.push_back(v);\n            } else if (G[u][v] == 1 && colorArr[v] == colorArr[u]) {\n                return false;\n            }\n        }\n    }\n    return true;\n}\n\nint main() {\n    int G[V][V] = {\n        {0, 1, 0, 1},\n        {1, 0, 1, 0},\n        {0, 1, 0, 1},\n        {1, 0, 1, 0}};\n    if (isBipartite(G, 0)) {\n        cout << \"Es bipartito\" << endl;\n    } else {\n        cout << \"NO Es bipartito\" << endl;\n    }\n}\n",
    "py": "V = 4\n\ndef isBipartite(G, src):\n    global V\n    colorarr = [-1 for x in range(V)]\n    colorarr[src] = 1\n    q = []\n    q.append(src)\n    while not len(q) == 0:\n        u = q.pop()\n        if G[u][u] == 1:\n            return False\n    for v in range(V):\n        if G[u][v] == 1 and colorarr[v] == -1:\n            colorarr[v] = 1 - colorarr[u]\n            q.append(v)\n        elif G[u][v] and colorarr[v] == colorarr[u]:\n            return False\n    return True\n\nG = [[0, 1, 0, 1], [1, 0, 1, 0], [0, 1, 0, 1], [1, 0, 1, 0]]\nif isBipartite(G, 0):\n    print(\"Es bipartitio\")\nelse:\n    print(\"No es bipartitio\")\n\n",
    "orden": 8,
    "suborden": 24,
    "fecha_creacion": "2020-12-05 00:45:53",
    "fecha_modificacion": "2020-12-06 20:30:58"
  },
  {
    "ID": 155,
    "supergrupo": "Grafos ",
    "tema": "Union Find",
    "texto": "Una estructura de datos para conjuntos disjuntos, es una estructura de datos que mantiene un conjunto de elementos particionados en un número de conjuntos disjuntos no se solapan los conjuntos). Un algoritmo Unión-Buscar es un algoritmo que realiza dos importantes operaciones en esta estructura de datos:\nBuscar: Determina a cual subconjunto pertenece un elemento. Esta operación puede usarse para verificar si dos elementos están en el mismo conjunto.\nUnion: Une dos subconjuntos en uno solo.\nLa otra operación importante CrearConjunto es generalmente trivial, esta crea un conjunto con un elemento dado. Con estas tres operaciones, muchos problemas prácticos de particionamiento pueden ser resueltos.\nCon el fin de definir estas operaciones más precisamente, es necesario representar los conjuntos de alguna manera. Una aproximación común es seleccionar un elemento fijo de cada conjunto, llamado el representativo, para representar el conjunto como un todo. Entonces Buscar(x) retorna el elemento representativo del conjunto al cual x pertenece, y Unión toma como argumento dos elementos representativos de dos conjuntos respectivamente.\n",
    "complejidad_tiempo": "Mejor caso :    O(v+e)  Peor caso : O(v+e)  Promedio: O(v+e) ",
    "java": "//Programa java que usa el algoritmo UNION FIND \n// para verificar componentes conexas\n/*\nINPUT\n9 7\n2 0\n7 0\n3 1\n1 0\n6 4\n8 5\n4 5\n */\nimport java.util.*;\n\npublic class UnionFind {\n\n    static final int MAX = 10005; //maximo número de vértices\n    static int padre[] = new int[MAX]; //Este arreglo contiene el padre del i-esimo nodo\n    static int rango[] = new int[MAX]; //profundidad de cada vértice\n\n    //Método de inicialización\n    static void MakeSet(int n) {\n        for (int i = 0; i < n; ++i) {\n            padre[i] = i; //Inicialmente el padre de cada vértice es el mismo vértice\n            rango[i] = 0; //Altura o rango de cada vértice es 0\n        }\n    }   \n    //Método para encontrar la raiz del vértice actual X\n    static int Find(int x) {\n        if (x == padre[x]) { //Si estoy en la raiz\n            return x; //Retorno la raiz\n        } //else return Find( padre[ x ] ); //De otro modo busco el padre del vértice actual, hasta llegar a la raiz.\n        else {\n            return padre[x] = Find(padre[x]); //Compresion de caminos\n        }\n    }\n    //Método para unir 2 componentes conexas\n    static void Union(int x, int y) {\n        int xRoot = Find(x); //Obtengo la raiz de la componente del vértice X\n        int yRoot = Find(y); //Obtengo la raiz de la componente del vértice Y\n        padre[xRoot] = yRoot; //Mezclo ambos arboles o conjuntos, actualizando su padre de alguno de ellos como la raiz de otro\n    }\n\n    //Método para unir 2 componentes conexas usando sus alturas (rangos)\n    static void UnionbyRank(int x, int y) {\n        int xRoot = Find(x); //Obtengo la raiz de la componente del vértice X\n        int yRoot = Find(y); //Obtengo la raiz de la componente del vértice Y\n        if (rango[xRoot] > rango[yRoot]) { //en este caso la altura de la componente del vértice X es\n            //mayor que la altura de la componente del vértice Y.\n            padre[yRoot] = xRoot; //el padre de ambas componentes será el de mayor altura\n        } else { //en este caso la altura de la componente del vértice Y es mayor o igual que la de X\n            padre[xRoot] = yRoot; //el padre de ambas componentes será el de mayor altura\n            if (rango[xRoot] == rango[yRoot]) { //si poseen la misma altura\n                rango[yRoot]++; //incremento el rango de la nueva raíz\n            }\n        }\n    }\n\n    static int root[] = new int[MAX]; //tendra las raices de las componentes conexas luego de aplicar el método\n    static int numComponentes; //variable para el número total de componentes conexas\n    //Método para obtener el número de componentes conexas luego de realizar las conexiones respectivas\n\n    static int getNumberConnectedComponents(int n) {\n        numComponentes = 0;\n        for (int i = 0; i < n; ++i) {\n            if (padre[i] == i) { //Si el padre del vértice i es el mismo vértice entonces es raíz\n                //if( Find( i ) == i ){ //podemos usamos find para el mismo proposito y\n                //para que se realice compresion de caminos\n                root[numComponentes++] = i; //almaceno la raiz de cada nueva componente\n                // numComponentes++;\n            }\n        }\n        return numComponentes;\n    }\n\n    static int numVertices[] = new int[MAX]; //almacenara la cantidad de vértices para la i-esima raiz.\n    //Método para obtener la raiz y el número de vértices de cada componente conexa\n    //será necesario primero tener la cantidad de componentes conexas\n    //podemos llamar 1ero al metodo getNumberConnectedComponents o incluir porcion de su codigo en este\n\n    static void getNumberNodes(int n) {\n        Arrays.fill(numVertices, 0); //inicializo mi contador de vértices\n        for (int i = 0; i < n; ++i) {\n            numVertices[Find(i)]++; //incremento la raíz del vértice i\n        }\n        for (int i = 0; i < numComponentes; ++i) {\n            System.out.printf(\"Componente %d: Raiz = %d , Nro nodos = %d.\\n\", i + 1, root[i], numVertices[root[i]]);\n        }\n    }\n\n    //Método que me determina si 2 vértices estan o no en la misma componente conexa\n    static boolean sameComponent(int x, int y) {\n        if (Find(x) == Find(y)) {\n            return true; //si poseen la misma raíz\n        }\n        return false;\n    }\n\n    public static void main(String[] args) {\n        int V, E, origen, destino;\n        Scanner sc = new Scanner(System.in);\n        V = sc.nextInt();\n        E = sc.nextInt(); //tengamos número de vertices y aristas\n        MakeSet(V); //inicializamos los conjuntos\n        for (int i = 0; i < E; ++i) {\n            origen = sc.nextInt();\n            destino = sc.nextInt();\n            UnionbyRank(origen, destino); //union de elementos\n        }\n        System.out.printf(\"El número de componentes conexas es: %d\\n\", getNumberConnectedComponents(V));\n        getNumberNodes(V);\n\n    }\n\n}\n",
    "cpp": null,
    "py": null,
    "orden": 8,
    "suborden": 25,
    "fecha_creacion": "2020-12-05 00:45:53",
    "fecha_modificacion": "2020-12-06 20:30:59"
  },
  {
    "ID": 156,
    "supergrupo": "Grafos ",
    "tema": "Árbol de expansión mínima de Kruskal",
    "texto": "Dado un grafo conexo y no dirigido, un árbol de expansión del grafo es el subgrafo que es el árbol que conecta todos los vértices juntos, un solo grafo puede tener muchos árboles de expansión diferentes, un árbol de expansión mínima (MST) o árbol de expansión de peso mínimo para un grafo ponderado, conexo y no dirigido es el árbol de expansión con el peso menor o igual a cualquier otro árbol de expansión. El peso de un árbol de expansión es la suma de los pesos dados en cada camino del árbol de expansión.\n¿Cuantos caminos tiene un árbol de expansión mínima?\nUn MST tiene (V-1) caminos donde V es el número de vértices en el grafo dado.\nLos siguientes son los pasos para encontrar el MST con el algoritmo de Kruskal.\n1) ordene todos los caminos en orden incremental dado su peso.\n2) Tome el camino más pequeño, verifique si forma un ciclo con el árbol formado hasta ahora, si el ciclo no es formado, incluya este camino, si no descártelo\n3) Repita el paso 2 hasta que haya (V-1) caminos en el árbol de expansión.\nEl paso 2 usa el algoritmo Union-Find para detectar ciclos.\nEl algoritmo es un algoritmo voraz, la voracidad escogida es tomar el camino de tamaño más pequeño lo que no causa un ciclo en el MST construido hasta ese punto\nLa complejidad de tiempo de este algoritmo es de O(ElogE) or O(ElogV). Ordenar los caminos toma O(ELogE) tiempo, luego de ordenar iteramos a través de todos los caminos y aplicamos el algoritmo Union-Find, Las operaciones de unir y encontrar puede tomar al menos O(LogV) tiempo, entonces la complejidad completa es O(ELogE + ELogV) tiempo. El valor de W puede ser al menos O (V^2) entonces O (LogV) son O (LogE) iguales. \n",
    "complejidad_tiempo": "Mejor caso :    O(eLog(e)+ eLog(v))  Peor caso : O(eLog(e)+ eLog(v)) \nPromedio: O(eLog(e)+ eLog(v)) \n",
    "java": "//Implementación java de busqueda del \n// arbol de expansión minima usando el algoritmo de Kruskal\n/*\n EJEMPLO DE INPUT\n 9 14\n 1 2 4\n 1 8 9\n 2 3 9\n 2 8 11\n 3 4 7\n 3 9 2\n 3 6 4\n 4 5 10\n 4 6 15\n 5 6 11\n 6 7 2\n 7 8 1\n 7 9 6\n 8 9 7\n\n EJEMPLO VERIFICACION DE MST\n9 11\n 1 2 4\n 1 8 9\n 2 3 9\n 2 8 11\n 3 9 2\n 7 8 1\n 7 9 6\n 8 9 7\n 4 5 10\n 4 6 15\n 5 6 11\n */\nimport java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.Scanner;\n\npublic class KruskalMST {\n\n    static final int MAX = 1005; //maximo número de vértices\n    //UNION-FIND\n    static int padre[] = new int[MAX]; //Este arreglo contiene el padre del i-esimo nodo\n    //Método de inicialización\n    static void MakeSet(int n) {\n        for (int i = 1; i <= n; ++i) {\n            padre[i] = i;\n        }\n    }\n    //Método para encontrar la raiz del vértice actual X\n    static int Find(int x) {\n        return (x == padre[x]) ? x : (padre[x] = Find(padre[x]));\n    }\n    //Método para unir 2 componentes conexas\n    static void Union(int x, int y) {\n        padre[Find(x)] = Find(y);\n    }\n    //Método que me determina si 2 vértices estan o no en la misma componente conexa\n    static boolean sameComponent(int x, int y) {\n        if (Find(x) == Find(y)) {\n            return true;\n        }\n        return false;\n    }\n    ///FIN UNION-FIND\n    static int V, E; //número de vertices y aristas\n    //Estructura arista( edge )\n\n    static class Edge implements Comparator<Edge> {\n        int origen; //Vértice origen\n        int destino; //Vértice destino\n        int peso; //Peso entre el vértice origen y destino\n        Edge() {\n        }\n        //Comparador por peso, me servira al momento de ordenar lo realizara en orden ascendente\n        //Ordenar de forma descendente para obtener el arbol de expansion maxima\n        @Override\n        public int compare(Edge e1, Edge e2) {\n            //return e2.peso - e1.peso; //Arbol de expansion maxima\n            return e1.peso - e2.peso; //Arbol de expansion minima\n        }\n    };\n\n    static Edge arista[] = new Edge[MAX]; //Arreglo de aristas para el uso en kruskal\n    static Edge MST[] = new Edge[MAX]; //Arreglo de aristas del MST encontrado\n    static void KruskalMST() {\n        int origen, destino, peso;\n        int total = 0; //Peso total del MST\n        int numAristas = 0; //Número de Aristas del MST\n        MakeSet(V); //Inicializamos cada componente\n        Arrays.sort(arista, 0, E, new Edge()); //Ordenamos las aristas por su comparador\n        for (int i = 0; i < E; ++i) {\n            origen = arista[i].origen; //Vértice origen de la arista actual\n            destino = arista[i].destino; //Vértice destino de la arista actual\n            peso = arista[i].peso; //Peso de la arista actual\n            //Verificamos si estan o no en la misma componente conexa\n            if (!sameComponent(origen, destino)) { //Evito ciclos\n                total += peso; //Incremento el peso total del MST\n                MST[numAristas++] = arista[i]; //Agrego al MST la arista actual\n                Union(origen, destino); //Union de ambas componentes en una sola\n            }\n        }\n\n        //Si el MST encontrado no posee todos los vértices mostramos mensaje de error\n        //Para saber si contiene o no todos los vértices basta con que el número\n        //de aristas sea igual al número de vertices - 1\n        if (V - 1 != numAristas) {\n            System.out.println(\"No existe MST valido para el grafo ingresado, el grafo debe ser conexo.\");\n            return;\n        }\n        System.out.println(\"-----El MST encontrado contiene las siguientes aristas-----\");\n        for (int i = 0; i < numAristas; ++i) {\n            System.out.printf(\"( %d , %d ) : %d\\n\", MST[i].origen, MST[i].destino, MST[i].peso);\n        }\n        System.out.printf(\"El costo minimo de todas las aristas del MST es : %d\\n\", total);\n    }\n\n    //( vertice u , vertice v ) : peso\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in); //para lectura de datos\n        V = sc.nextInt();\n        E = sc.nextInt();\n        //Realizamos el ingreso del grafo, almacenando las aristas en un arreglo con los datos respectivos\n        for (int i = 0; i < E; ++i) {\n            arista[i] = new Edge();\n            arista[i].origen = sc.nextInt();\n            arista[i].destino = sc.nextInt();\n            arista[i].peso = sc.nextInt();\n            //arista[ i ] = new Arista( sc.nextInt() , );\n        }\n        KruskalMST();\n    }\n}\n",
    "cpp": "#include <bits/stdc++.h>\n#define MAX 1005\nusing namespace std;\nint padre[MAX];\n\nstruct Edge {\n    int origen, destino, peso;\n\n    bool operator<(const Edge &t) {\n        return peso < t.peso;\n    }\n};\n//set de nodos para indicar cuales son sus padre e hijos\n\nvoid makeSet(int n) {\n    for (int i = 0; i <= n; i++) {\n        padre[i] = i;\n    }\n}\n\nint find(int x) {\n    return (x == padre[x] ? x : (padre[x] = find(padre[x])));\n}\n\nvoid Union(int x, int y) {\n    padre[find(x)] = find(y);\n}\n\nbool sameComponent(int x, int y) {\n    if (find(x) == find(y)) {\n        return true;\n    }\n    return false;\n}\nEdge aristas[MAX];\nEdge MST[MAX];\nvector<Edge>vec;\n\nvoid KruskalMST(int V, int E) {\n    int origen, destino, peso;\n    int total = 0;\n    int numAristas = 0;\n    makeSet(V);\n    sort(vec.begin(), vec.end());\n    for (int i = 0; i < E; i++) {\n        origen = vec[i].origen;\n        destino = vec[i].destino;\n        peso = vec[i].peso;\n        if (!sameComponent(origen, destino)) {\n            total += peso;\n            MST[numAristas++] = vec[i];\n            Union(origen, destino);\n        }\n    }\n    if (V - 1 != numAristas) {\n        cout << \"No existe MST valido para el grafo ingresado este debe ser conexo\" << endl;\n        return;\n    }\n    cout << \"MST encontrado contiene las siguientes aristas\" << endl;\n    for (int i = 0; i < numAristas; i++) {\n        cout << MST[i].origen << \",\" << MST[i].destino << \":\" << MST[i].peso << endl;\n    }\n    cout << \"el costo minimo de todas las aristas de MST es : \" << total << endl;\n}\n\nint main() {\n    int V, E;\n    cin >> V>>E;\n    for (int i = 0; i < E; i++) {\n        Edge aristas[i];\n        cin >> aristas[i].origen;\n        cin >> aristas[i].destino;\n        cin >> aristas[i].peso;\n        vec.push_back(aristas[i]);\n    }\n    KruskalMST(V, E);\n}\n",
    "py": null,
    "orden": 8,
    "suborden": 26,
    "fecha_creacion": "2020-12-05 00:45:53",
    "fecha_modificacion": "2020-12-06 20:30:59"
  },
  {
    "ID": 157,
    "supergrupo": "Grafos ",
    "tema": "Árbol de expansión mínima de Prim",
    "texto": "El algoritmo de Prim es también un algoritmo voraz, comienza con un árbol de expansión vacío, la idea es mantener dos conjuntos de vértices, el primero contiene los vértices ya incluidos en el MST, la otra contiene los vértices que no han sido incluidos aun, en cada paso, se considera todos los caminos que conectan dos sets, y toma el camino con mínimo peso de esos caminos, luego de tomar el camino, se mueve el otro punto final del camino al set conteniendo el MST.\nUn grupo de caminos que conectan dos sets de vértices en un grafo es llamado corte en la teoría de grafos, entonces en cada paso del algoritmo de Prim, nosotros buscamos un corte (de dos conjuntos, uno contiene los vértices ya en el MST y el otro el resto de vértices), tome el camino de mínimo peso del corte e incluye este vértice al conjunto MST. \n\nLa idea detrás del algoritmo de Prim es simple, un árbol de expansión significa que todos los vértices deben estar conectados, entonces los dos conjuntos disjuntos de vértices deben estar conectados para hacer un árbol de expansión. Y ellos deben estar conectados con el camino de peso mínimo para realizar un árbol de expansión mínima.\n1) Crear un set mstSet que mantenga rastro de los vértices ya incluidos en el MST.\n2) Asignar un valor key a todos los vértices en el grafo de entrada, inicializar los valores key como INFINITO, asignar el valor key como 0 para el primer vértice entonces este es tomado primero.\n3) Mientras mstSet no incluya todos los vértices.\na) Tomar un vértice u el cual no esté en el mstSet y tenga el valor key mínimo\nb) Incluir u al mstSet\nc) Actualizar el valor key de todos los vértices adyacentes de u, para actualizar los valores key, se itera a través de todos los vértices adyacentes v, si el peso del camino u-v es menos que el valor key anterior de v, actualice el valor key como peso de u-v.\nLa idea de usar valores key es tomar el camino de mínimo peso como el corte, los valores key son usados únicamente por los vértices que no han sido incluidos en el MST, el valor key de estos vértices indican los caminos de peso mínimo conectándolos con el set de vértices incluidos en el MST.\nPor ejemplo:\n\n- El set mstSet esta inicialmente vacío y los keys asignados a los vértices son {0, INF, INF, INF, INF, INF, INF, INF} donde INF indica infinito, ahora tomamos el vértices con el valor key menor el vértice 0 es tomado, se incluye en el mstSetm entonces mstSet se convierte en {0}, luego de incluir al mstSet, se actualizan los valores key de los vértices adyacentes, los vértices adyacentes  de 0 son 1 y 7, los valores key de 1 y 7 son actualizados como 4 y 8.\n- Se toma el vértice con el menor valor key y no incluido ya en el MST, (no en mstSet), el vértice 1 es tomado y añadido al mstSet por lo que se convierte en {0,1}, se actualiza los valores key de los vértices adyacentes de 1, el valor key del vértice 2 se convierte en 8.\n- Se toma el vértice con el valor key mínimo y no incluido en MST, podemos tomar el vértice 7 o 2, tomaremos el 7, entonces el mstSet es {0,1,7}, actualizamos los valores key de los vértices adyacentes de 7, el valor key del vértice 6 y 8 se convierten en finitos, en 1 y 7.\n- Tome el vértice con el valor key mínimo, y no incluido ya en MST, el vértice 6 es tomado entonces el mstSet se convierte en {0,1,7,6}, se actualizan los valores key y los vértices adyacentes de 6m el valor de 5 y 8 es actualizado.\n- Repetimos los pasos de arriba hasta que mstSet incluya todos los vértices del grafo dado.\n",
    "complejidad_tiempo": "Mejor caso :    O(v3) Peor caso : O(v3) Promedio: O(v3) ",
    "java": "//Programa java que calcula el MST de un grafo\n\nimport java.util.LinkedList;\nimport java.util.PriorityQueue;\nimport java.util.Comparator;\n\npublic class PrimMSTFULL {\n\n    public static void main(String[] args) {\n        int V = 9;\n        Graph graph = new Graph(V);\n        addEdge(graph, 0, 1, 4);\n        addEdge(graph, 0, 7, 8);\n        addEdge(graph, 1, 2, 8);\n        addEdge(graph, 1, 7, 11);\n        addEdge(graph, 2, 3, 7);\n        addEdge(graph, 2, 8, 2);\n        addEdge(graph, 2, 5, 4);\n        addEdge(graph, 3, 4, 9);\n        addEdge(graph, 3, 5, 14);\n        addEdge(graph, 4, 5, 10);\n        addEdge(graph, 5, 6, 2);\n        addEdge(graph, 6, 7, 1);\n        addEdge(graph, 6, 8, 6);\n        addEdge(graph, 7, 8, 7);\n        prims_mst(graph);\n    }\n\n    static class node1 {\n        int dest;\n        int weight;\n        node1(int a, int b) {\n            dest = a;\n            weight = b;\n        }\n    }\n\n    static class Graph {\n        int V;\n        LinkedList<node1>[] adj;\n        Graph(int e) {\n            V = e;\n            adj = new LinkedList[V];\n            for (int o = 0; o < V; o++) {\n                adj[o] = new LinkedList<>();\n            }\n        }\n    }\n\n    static class node {\n        int vertex;\n        int key;\n    }\n\n    /* Comparador de la priorityQueue\n     retorna 1 si node0.key > node1.key \n     retorna 0 si node0.key < node1.key y\n    retorna -1 otherwise */\n    static class comparator implements Comparator<node> {\n\n        @Override\n        public int compare(node node0, node node1) {\n            return node0.key - node1.key;\n        }\n    }\n    static void addEdge(Graph graph, int src, int dest, int weight) {\n        node1 node0 = new node1(dest, weight);\n        node1 node = new node1(src, weight);\n        graph.adj[src].addLast(node0);\n        graph.adj[dest].addLast(node);\n    }\n\n    // Buscar MST\n    static void prims_mst(Graph graph) {\n        Boolean[] mstset = new Boolean[graph.V];\n        node[] e = new node[graph.V];\n        int[] parent = new int[graph.V];\n        for (int o = 0; o < graph.V; o++) {\n            e[o] = new node();\n        }\n        for (int o = 0; o < graph.V; o++) {\n            //inicializar en falso\n            mstset[o] = false;\n            // Inicial valores key en infinito\n            e[o].key = Integer.MAX_VALUE;\n            e[o].vertex = o;\n            parent[o] = -1;\n        }\n        // incluir el vertice inicial en el MST\n        mstset[0] = true;\n        e[0].key = 0;\n        PriorityQueue<node> queue = new PriorityQueue<>(graph.V, new comparator());\n        for (int o = 0; o < graph.V; o++) {\n            queue.add(e[o]);\n        }\n        while (!queue.isEmpty()) {\n            node node0 = queue.poll();\n            mstset[node0.vertex] = true;\n            for (node1 iterator : graph.adj[node0.vertex]) {\n                if (mstset[iterator.dest] == false) {\n                    if (e[iterator.dest].key > iterator.weight) {\n                        queue.remove(e[iterator.dest]);\n                        e[iterator.dest].key = iterator.weight;\n                        queue.add(e[iterator.dest]);\n                        parent[iterator.dest] = node0.vertex;\n                    }\n                }\n            }\n        }\n        // Imprimir el par de vertices del mst \n        for (int o = 1; o < graph.V; o++) {\n            System.out.println(parent[o] + \" \"\n                    + \"-\"\n                    + \" \" + o);\n        }\n    }\n}\n\n//Version 2:\n//Programa java que busca el arbol de expansión \n// minima de minimo costo\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n\npublic class PrimMSTMinValue {\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        N = sc.nextInt();\n        G = new Vertex[N];\n        for (int i = 0; i < G.length; i++) {\n            G[i] = new Vertex();\n        }\n        E = sc.nextInt();\n        for (int i = 0; i < E; i++) {\n            int from, to, w;\n            from = sc.nextInt();\n            to = sc.nextInt();\n            w = sc.nextInt();\n            G[from].adj.add(new Edge(to, w));\n            G[to].adj.add(new Edge(from, w));\n        }\n        System.out.println(prim());\n\n    }\n\n    static PriorityQueue<QueueItem> Q;\n    static int E;\n    static boolean[] intree;\n    static int N;\n    static Vertex[] G;\n    \n    static class QueueItem implements Comparable<QueueItem> {\n        int v, w;\n        public QueueItem(int v, int w) {\n            this.v = v;\n            this.w = w;\n        }\n        @Override\n        public int compareTo(QueueItem q) {\n            if (this.w != q.w) {\n                return this.w - q.w;\n            }\n            return this.v - q.v;\n        }\n    }\n\n    static void process(int u) {\n        intree[u] = true;\n        G[u].adj.forEach((e) -> {\n            int v = e.to, w = e.w;\n            if (!intree[v]) {\n                Q.offer(new QueueItem(v, w));\n            }\n        });\n    }\n\n    static int prim() {\n        intree = new boolean[N];\n        Q = new PriorityQueue<>();\n        int cost = 0;\n        process(0);\n        while (!Q.isEmpty()) {\n            QueueItem qi = Q.poll();\n            int v = qi.v, w = qi.w;\n            if (!intree[v]) {\n                cost += w;\n                process(v);\n            }\n        }\n        return cost;\n    }\n\n    static class Vertex {\n        List<Edge> adj;\n        public Vertex() {\n            adj = new ArrayList<>();\n        }\n    }\n\n    static class Edge {\n        int to, w;\n        public Edge(int to, int w) {\n            this.to = to;\n            this.w = w;\n        }\n    }\n}\n",
    "cpp": null,
    "py": null,
    "orden": 8,
    "suborden": 27,
    "fecha_creacion": "2020-12-05 00:45:54",
    "fecha_modificacion": "2020-12-06 20:31:00"
  },
  {
    "ID": 158,
    "supergrupo": "DP",
    "tema": "Knapsack 0/1",
    "texto": "Dados pesos y valores de n ítems, ponga esos ítems en una mochila de capacidad W, para obtener el máximo valor total en la mochila, en otras palabras dados dos arrays de enteros val[0..n-1] y wt[0…-1] los cuales representan los valores y pesos asociados a los n ítems respectivamente. También dado un entero W el cual representa la capacidad de la mochila, encuentre el máximo valor subset de val[] tal que esa suma de los pesos de este subset es menor o igual a w, no se puede romper un ítem, se tiene que tomar o no tomar, (propiedad 0-1).\nUna simple solución es considerar todos los subsets de ítems y calcular el peso total y valor de todos los subsets, considere solo los subsets los cuales el peso total es menor a W, de todos los subsets tome el que tenga el máximo valor de peso.\nConsidere todos los subsets de ítems, puede haber dos casos para cada ítem:\n1) El ítem está incluido en el subset optimo\n2) El ítem no está incluido en el subset optimo\nCon esto, el máximo valor puede ser obtenido de n ítems es máximo siguiendo los dos siguientes valores,\n1) El máximo valor obtenido por n-1 ítems y peso W (Excluyendo el enésimo ítem)\n2) Valor del enésimo ítem más el máximo valor obtenido por n-1 ítems y W menos el peso del enésimo ítem (Incluyendo el enésimo ítem).\nSI el peso del enésimo ítem es mayor que W, entonces el enésimo ítem no puede ser incluido y el caso 1 es la única posibilidad.\nDesde que los subproblemas son evaluados de nuevo, este problema tiene la propiedad de sobreponer subproblemas. Entonces el problema de  la mochila 0-1 tiene ambas propiedades de un problema de programación dinámica, como otros problemas de programación dinámica, recomputaciones de subproblemas iguales pueden ser evadidos construyendo una matriz temporal desde el fondo, el código usa esta metodología.\nLa complejidad de tiempo de este algoritmo es de O(nW) donde n es el número de ítems y W el peso de la mochila.\n",
    "complejidad_tiempo": null,
    "java": "/*Implementación java del problema 0-1 Knapsack */\npublic class KnapsackRecursive {\n//Función de utilidad que retorna el mayor de dos números\n\n    static int max(int a, int b) {\n        return (a > b) ? a : b;\n    }\n    // Retorna el maximo valor que puede ser \n    //Puesto en una knapsack de capacidad w\n\n    static int knapSack(int W, int wt[], int val[], int n) {\n        // Caso base\n        if (n == 0 || W == 0) {\n            return 0;\n        }\n        /*Si el peso de el nesimo item es más\n        que la capacidad el knapsack, entonces\n        este item no puede ser icluido en una \n        solución optima*/\n        if (wt[n - 1] > W) {\n            return knapSack(W, wt, val, n - 1);\n        } // Retorna el maximo de dos casos:\n        //1) nesimo termino incluido\n        //2) no incluido\n        else {\n            return max(val[n - 1] + knapSack(W - wt[n - 1], wt, val, n - 1),\n                    knapSack(W, wt, val, n - 1));\n        }\n    }\n\n    public static void main(String args[]) {\n        int val[] = new int[]{60, 100, 120};\n        int wt[] = new int[]{10, 20, 30};\n        int W = 50;\n        int n = val.length;\n        System.out.println(knapSack(W, wt, val, n));\n    }\n}\n// Implementación java que usa programación dinamica\n// para solucionar el problema de 0-1 Knapsack\n\npublic class KnapsackDP {\n    //Función de utilidad que retorna el maximo de dos enteros\n    static int max(int a, int b) {\n        return (a > b) ? a : b;\n    }\n    // Retorna el maximo valor que puede ser puesto en un\n    //knapsack de capacidad w\n    static int knapSack(int W, int wt[], int val[], int n) {\n        int i, w;\n        int K[][] = new int[n + 1][W + 1];\n        // Construye la tabla K[][]de abajo hacia arriba\n        for (i = 0; i <= n; i++) {\n            for (w = 0; w <= W; w++) {\n                if (i == 0 || w == 0) {\n                    K[i][w] = 0;\n                } else if (wt[i - 1] <= w) {\n                    K[i][w] = max(val[i - 1]\n                            + K[i - 1][w - wt[i - 1]], K[i - 1][w]);\n                } else {\n                    K[i][w] = K[i - 1][w];\n                }\n            }\n        }\n\n        return K[n][W];\n    }\n\n    public static void main(String args[]) {\n        int val[] = new int[]{60, 100, 120};\n        int wt[] = new int[]{10, 20, 30};\n        int W = 50;\n        int n = val.length;\n        System.out.println(knapSack(W, wt, val, n));\n    }\n}\n",
    "cpp": null,
    "py": null,
    "orden": 9,
    "suborden": 0,
    "fecha_creacion": "2020-12-05 00:45:54",
    "fecha_modificacion": "2020-12-06 20:32:33"
  },
  {
    "ID": 159,
    "supergrupo": "DP",
    "tema": "Cambio de monedas",
    "texto": "Dado un valor N, si queremos hacer el cambio de N centavos y tenemos suministros infinitos de cada uno de las S = {S1, S2,.., Sm} monedas con valor, ¿de cuantas formas podemos hacer el cambio? El orden de las monedas no importa\nDado un valor N, queremos hacer el cambio por N centavos, y tenemos suministros de cada una, por  ejemplo, para N=4, y S={1,2,3}, existen 4 soluciones {1,1,1,1},{1,1,2},{2,2},{1,3}. Entonces la salida debe ser 4, para N=10, y S={2,5,3,6} existen 6 soluciones {2,2,2,2,2}, {2,2,3,3}, {2,2,6}, {2,3,5} y {5,5}. Entonces la salida debe ser 5.\nPara contar el total el números de soluciones podemos dividir todos los sets solución en dos sets.\n1) Soluciones que no contienen emesima moneda o Sm.\n2) Soluciones que al menos contienen una Sm.\nDejaremos ser count(S[],m,n) la función de conteo del número de soluciones, luego estas pueden ser escritas como suma de count(S[], m-1, n) y count(S[], m, n-Sm).\nPor lo tanto, el problema tiene una propiedad se subestructura optima haciendo que el problema pueda ser resuelto usando soluciones a subproblemas.\nComplejidad de tiempo: O(mn)\n",
    "complejidad_tiempo": null,
    "java": "// Programa java que resuelve el problema\n// del cambio de monedas\n\npublic class CoinExchange {\n\n    // Retorna el conteo de formás que podemos\n    // sumar S[0...m-1] monedas para obtener n \n    static int count(int S[], int m, int n) {\n        // Si n es 0 entonces 1 es la solución \n        // (No incluir ninguna moneda \n        if (n == 0) {\n            return 1;\n        }\n        // Si n es menos que 0 entonces no hay solución\n        if (n < 0) {\n            return 0;\n        }\n        /*Si no hay monedas y n es mayor que 0, no existe solución*/\n        if (m <= 0 && n >= 1) {\n            return 0;\n        }\n        // count es la suma de las soluciónes (i) \n        // incluyendo S[m-1] (ii) excluyendo S[m-1] \n        return count(S, m - 1, n)\n                + count(S, m, n - S[m - 1]);\n    }\n\n    public static void main(String[] args) {\n        int arr[] = {1, 2, 3};\n        int m = arr.length;\n        System.out.println(count(arr, m, 4));\n    }\n}\n",
    "cpp": null,
    "py": null,
    "orden": 9,
    "suborden": 1,
    "fecha_creacion": "2020-12-05 00:45:54",
    "fecha_modificacion": "2020-12-06 20:32:33"
  },
  {
    "ID": 160,
    "supergrupo": "DP",
    "tema": "Longest Increasing Subsequence",
    "texto": "El problema de la  secuencia incremental más larga (LIS), es encontrar la longitud de la subsecuencia más larga dada una secuencia la cual todos los elementos de la subsecuencia están ordenados en orden ascendente, por ejemplo la longitud de a LIS para {10, 22, 9, 33, 21, 50, 41, 60, 80} es 6 y LIS es {10, 22, 33, 50, 60, 80}.\nDejaremos arr [0...n-1] ser el array de entrada y L(i) ser la longitud de la LIS finalizando en el índice I tal que arr[i] es el último elemento de la LIS.\nEntonces L(i) puede ser recursivamente escrito como:\nL(i) = 1 + max( L(j) ) donde 0 < j < i y arr[j] < arr[i]; \no\nL(i) = 1, Si no existe tal j.\nPara encontrar la LIS de un array dado, necesitamos retornar max(L(i)) donde 0 < i < n.\nPor lo tanto vemos que el problema LIS satisface la propiedad de la subestructura óptima como el problema principal puede ser resuelto usando soluciones a subproblemas.\n\nNote que la complejidad de tiempo de esta programación dinámica es O(nLogn).\n",
    "complejidad_tiempo": null,
    "java": "\npublic class LongestIncreasingSubsequence {\n\n    static int max_ref;\n\n    /* Para hacer uso de llamadas recursivas, esta función debe devolver.\n   dos cosas:\n   1) Longitud de LIS que termina con el elemento arr [n-1]. Usamos\n      max_ending_here para este propósito\n   2) Máximo global ya que el LIS puede terminar con un elemento\n      antes de arr [n-1] max_ref se usa para este propósito.\n   El valor de LIS de la matriz completa de tamaño n se almacena en\n   * max_ref cual es nuestro resultado final*/\n    static int _lis(int arr[], int n) {\n        // Caso base\n        if (n == 1) {\n            return 1;\n        }\n        // 'max_ending_here' es el tamaño de LIS \n        // terminando con arr[n-1] \n        int res, max_ending_here = 1;\n        for (int i = 1; i < n; i++) {\n            res = _lis(arr, i);\n            if (arr[i - 1] < arr[n - 1] && res + 1 > max_ending_here) {\n                max_ending_here = res + 1;\n            }\n        }\n        if (max_ref < max_ending_here) {\n            max_ref = max_ending_here;\n        }\n        return max_ending_here;\n    }\n\n    static int lis(int arr[], int n) {\n        // Guarda el resultado \n        max_ref = 1;\n        //Almacena su resultado en max \n        _lis(arr, n);\n        //Retorna el maximo\n        return max_ref;\n    }\n\n    public static void main(String args[]) {\n        int arr[] = {10, 22, 9, 33, 21, 50, 41, 60};\n        int n = arr.length;\n        System.out.println(\"Tamaño de la subsecuencia incremental más larga\"\n                + \" es \" + lis(arr, n) + \"\\n\");\n    }\n}\n",
    "cpp": null,
    "py": null,
    "orden": 9,
    "suborden": 2,
    "fecha_creacion": "2020-12-05 00:45:55",
    "fecha_modificacion": "2020-12-06 20:32:34"
  },
  {
    "ID": 161,
    "supergrupo": "DP",
    "tema": "Longest Common SubString",
    "texto": "Dados dos strings X y Y encuentre el substring común más largo. Dejaremos que M y N sean las longitudes del primer y segundo string respectivamente.\nUna simple solución es uno por uno considerar todos los substrings del primer string y por cada substring verificar su es un substring en el segundo substring, mantenemos rastro del string de longitud máxima, ahí pueden haber O(m^2) substrings y podemos encontrar si un string es substring de otro string en tiempo O(n), entonces el tiempo general de este método será O(n * m2)\nProgramación dinámica puede ser usada para encontrar el string común más largo en O(n*m) tiempo, la idea es encontrar el sufijo común más largo para todos los substrings de ambos strings y almacena estas longitudes en la tabla.\nEl sufijo común más largo tiene propiedad de subestructura propia.\nSi el último carácter coincide, entonces reducimos ambas longitudes en 1.\n- LCSuff(X, Y, m, n) = LCSuff(X, Y, m-1, n-1) + 1 if X[m-1] = Y[n-1]\nSi el último carácter no coincide, entonces el resultado es 0, por ejemplo:\n- LCSuff(X, Y, m, n) = 0 if (X[m-1] != Y[n-1])\nAhora consideramos sufijos de diferentes substrings terminando en diferentes índices, el sufijo común más largo, su longitud es el substring común más largo.\n- LCSubStr(X, Y, m, n) = Max(LCSuff(X, Y, i, j)) donde 1 <= i <= m y 1 <= j <= n\nComplejidad de tiempo: O(m*n)\n",
    "complejidad_tiempo": null,
    "java": "/* Implementación java que encuentra el substring comun más \nlargo usando programación dinamica*/\npublic class LongestCommonSubString {\n\n    static int LCSubStr(char X[], char Y[], int m, int n) {\n\n        int LCStuff[][] = new int[m + 1][n + 1];\n        int result = 0;  //Para almacenar el tamaño del substring \n        for (int i = 0; i <= m; i++) {\n            for (int j = 0; j <= n; j++) {\n                if (i == 0 || j == 0) {\n                    LCStuff[i][j] = 0;\n                } else if (X[i - 1] == Y[j - 1]) {\n                    LCStuff[i][j] = LCStuff[i - 1][j - 1] + 1;\n                    result = Integer.max(result, LCStuff[i][j]);\n                } else {\n                    LCStuff[i][j] = 0;\n                }\n            }\n        }\n        return result;\n    }\n\n    public static void main(String[] args) {\n        String X = \"hola mundo\";\n        String Y = \"mundo\";\n        int m = X.length();\n        int n = Y.length();\n        System.out.println(\"El tamaño del substring cómun más largo es \"\n                + LCSubStr(X.toCharArray(), Y.toCharArray(), m, n));\n    }\n}\n\n",
    "cpp": null,
    "py": null,
    "orden": 9,
    "suborden": 3,
    "fecha_creacion": "2020-12-05 00:45:55",
    "fecha_modificacion": "2020-12-06 20:32:35"
  },
  {
    "ID": 162,
    "supergrupo": "DP",
    "tema": "Triángulo de Pascal",
    "texto": "El triángulo de Pascal es un triángulo de números enteros, infinito y simétrico Se empieza con un 1 en la primera fila, y en las filas siguientes se van colocando números de forma que cada uno de ellos sea la suma de los dos números que tiene encima. Se supone que los lugares fuera del triángulo contienen ceros, de forma que los bordes del triángulo están formados por unos.\n- Los números del triángulo de Pascal coinciden con los números combinatorios.\n- El número combinatorio Cm n (n sobre m) se encuentra en el triángulo en la fila n+1, en el lugar m+1. \n- El número combinatorio Cm n (n sobre m) que representa el número de grupos de m elementos que pueden hacerse de entre un conjunto de n (por ejemplo, (4 sobre 2) nos da el número de parejas distintas que podrían hacerse en un grupo de cuatro personas), se encuentra en el triángulo en la fila n+1, en el lugar m+1. \n- Podemos saber que el número de parejas posibles que decíamos antes es 6 si miramos el tercer número de la quinta fila. \nEsto hace que el triángulo sea útil como representación de estos números, y proporciona una buena forma de intuir sus propiedades.\n- La fórmula general del llamado Binomio de Newton (a + b)n está formada por unos coeficientes que coinciden con la línea número n+1 del triángulo de Pascal (la que empieza por 1 y n).\n- Si el primer elemento de una fila es un número primo, todos los números de esa fila serán divisibles por él (menos el 1, claro). Así, en la fila 7: (1 7 21 35 35 21 7 1), los números 7,21 y 35 son divisibles por 7.\n- La suma de los elementos de cualquier fila es el resultado de elevar 2 al número que define a esa fila. \n- La serie de Fibonacci puede ser encontrada también en el triángulo de Pascal. Dividiendo al mismo según las líneas que mostramos en el diagrama, los números atrapados entre ellas suman cada uno de los elementos de esta sucesión.\n",
    "complejidad_tiempo": null,
    "java": "//Código java que realiza el triángulo de Pascal\n\npublic class PascalTriangle {\n\n    static void printPascal(int n) {\n        /* Itera atraves de cada linea y la imprime\n        con sus entradas*/\n        for (int line = 0; line < n; line++) {\n            // Cada linea tiene u número de enteror\n            //igual al número de linea\n            for (int i = 0; i <= line; i++) {\n                System.out.print(binomialCoeff(line, i) + \" \");\n            }\n            System.out.println();\n        }\n    }\n\n    static int binomialCoeff(int n, int k) {\n        int res = 1;\n        if (k > n - k) {\n            k = n - k;\n        }\n        for (int i = 0; i < k; ++i) {\n            res *= (n - i);\n            res /= (i + 1);\n        }\n        return res;\n    }\n\n    public static void main(String args[]) {\n        int n = 7;\n        printPascal(n);\n    }\n}\n",
    "cpp": null,
    "py": null,
    "orden": 9,
    "suborden": 4,
    "fecha_creacion": "2020-12-05 00:45:55",
    "fecha_modificacion": "2020-12-06 20:32:35"
  },
  {
    "ID": 163,
    "supergrupo": "Archivos",
    "tema": "Lectura desde archivos",
    "texto": "Cada lenguaje tiene diferentes funciones que permiten realizar esto, aquí les presentamos varios ejemplos en los tres lenguajes, necesitaremos primero crear los siguientes archivos de texto en la misma carpeta en la que se encuentre el proyecto (Puede variar).",
    "complejidad_tiempo": "Archivos de entrada\nIO_in1.txt 3\n1 2\n5 7\n6 3\nIO_in2.txt 1 2\n5 7\n6 3\n0 0\n1 1\nIO_in3.txt 1 2\n5 7\n6 3\nIO_in4.txt 1 1\n2 3 4\n3 8 1 1\n4 7 2 9 3\n5 1 1 1 1 1\nIO_in5.txt 1\n3 4\n8 1 1\n7 2 9 3\n1 1 1 1 1\n",
    "java": "import java.util.*;\nimport java.io.*;\n\nclass IO {\n\n    public static void main(String[] args) throws Exception {\n        // Comente todas las líneas y solo descomente el código de \n        // demostración que le interese\n\n        // Detectar el directorio actual por si es necesario\n        // hay que diferencias entre URL relativa y URL absoluta\n        // se necesita determinar si es necesario  colocar la ruta completa\n        // dependiendo del sistema operativo\n        System.out.println(System.getProperty(\"user.dir\"));\n        Scanner sc = new Scanner(new File(System.getProperty(\"user.dir\")\n                + \"\\\\src\\\\ready\\\\IO_in1.txt\"));\n        int TC = sc.nextInt(); // número de casos de prueba\n        while (TC-- > 0) { // atajo para repetir hasta 0\n            int a = sc.nextInt(), b = sc.nextInt(); // calcular respuesta\n            System.out.println(a + b); // sobre la marcha\n        }\n\n//        Scanner sc = new Scanner(new File(\"IO_in2.txt\"));\n//        int a, b;\n//        // detenerse cuando ambos enteros sean 0\n//        while (true) {\n//            a = sc.nextInt();\n//            b = sc.nextInt();\n//            if ((a == 0) && (b == 0)) {\n//                break;\n//            }\n//            System.out.println(a + b);\n//        }\n//\n//        Scanner sc = new Scanner(new File(\"IO_in3.txt\"));\n//        // La clase de escáner tiene el método hasNext\n//        while (sc.hasNext()) {\n//            int a = sc.nextInt(), b = sc.nextInt();\n//            System.out.println(a + b);\n//        }\n//\n//        Scanner sc = new Scanner(new File(\"IO_in3.txt\")); // mismo archivo de \n//        // entrada que antes\n//        int c = 0;\n//        while (sc.hasNext()) {\n//            int a = sc.nextInt(), b = sc.nextInt();\n//            // observe los dos '\\ n', Java System.out también tiene printf\n//            System.out.printf(\"Case %d: %d\\n\\n\", ++c, a + b);\n//        }\n//\n//        Scanner sc = new Scanner(new File(\"IO_in3.txt\")); // mismo archivo \n//        // de entrada que antes\n//        int c = 0;\n//        while (sc.hasNext()) {\n//            int a = sc.nextInt(), b = sc.nextInt();\n//            if (c > 0) {\n//                System.out.println(); // 2do / más casos\n//            }\n//            System.out.printf(\"Case %d: %d\\n\", ++c, a + b);\n//        }\n//\n//        Scanner sc = new Scanner(new File(\"IO_in4.txt\"));\n//        while (sc.hasNext()) {\n//            int k = sc.nextInt();\n//            int ans = 0, v;\n//            while (k-- > 0) {\n//                v = sc.nextInt();\n//                ans += v;\n//            }\n//            System.out.println(ans);\n//        }\n//\n//        Scanner sc = new Scanner(new File(\"IO_in5.txt\"));\n//        while (sc.hasNext()) { // sigue en bucle\n//            String[] token = sc.nextLine().split(\" \");\n//            int ans = 0;\n//            for (int i = 0; i < token.length; ++i) {\n//                ans += Integer.parseInt(token[i]);\n//            }\n//            System.out.println(ans);\n//        }\n    }\n}\n",
    "cpp": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main() {\n    // Comente todas las líneas y solo descomente el código de demostración que le interese\n\n    freopen(\"IO_in1.txt\", \"r\", stdin);\n    int TC;\n    scanf(\"%d\", &TC); // número de casos de prueba\n    while (TC--) { // atajo para repetir hasta 0\n        int a, b;\n        scanf(\"%d %d\", &a, &b);\n        printf(\"%d\\n\", a + b); // calcular sobre la marcha\n    }\n\n    //   freopen(\"IO_in2.txt\", \"r\", stdin);\n    //   int a, b;\n    //   // detenerse cuando ambos enteros sean 0\n    //   while (scanf(\"%d %d\", &a, &b), (a || b))\n    //     printf(\"%d\\n\", a+b);\n    //\n    //   freopen(\"IO_in3.txt\", \"r\", stdin);\n    //   int a, b;\n    //   // scanf devuelve el número de elementos leídos\n    //   while (scanf(\"%d %d\", &a, &b) == 2)\n    //   // o puede verificar EOF, es decir\n    //   // while (scanf (\"% d% d\", & a, & b)! = EOF)\n    //     printf(\"%d\\n\", a+b);\n    //\n    //   freopen(\"IO_in3.txt\", \"r\", stdin); // mismo archivo de entrada que antes\n    //   int a, b, c = 0;\n    //   while (scanf(\"%d %d\", &a, &b) != EOF)\n    //     // note los dos '\\ n'\n    //     printf(\"Case %d: %d\\n\\n\", ++c, a+b);\n    //\n    //   freopen(\"IO_in3.txt\", \"r\", stdin); // mismo archivo de entrada que antes\n    //   int a, b, c = 0;\n    //   while (scanf(\"%d %d\", &a, &b) != EOF) {\n    //     if (c > 0) printf(\"\\n\"); // 2do / más casos\n    //     printf(\"Case %d: %d\\n\", ++c, a+b);\n    //   }\n    //\n    //   freopen(\"IO_in4.txt\", \"r\", stdin);\n    //   int k;\n    //   while (scanf(\"%d\", &k) != EOF) {\n    //     int ans = 0, v;\n    //     while (k--) { scanf(\"%d\", &v); ans += v; }\n    //     printf(\"%d\\n\", ans);\n    //   }\n    //\n    //   freopen(\"IO_in5.txt\", \"r\", stdin);\n    //   while (1) { // sigue en bucle\n    //     int ans = 0, v;\n    //     char dummy;\n    //     while (scanf(\"%d%c\", &v, &dummy) != EOF) {\n    //       ans += v;\n    //       if (dummy == '\\n') break; // prueba EOLN\n    //     }\n    //     if (feof(stdin)) break; // tprueba EOF\n    //     printf(\"%d\\n\", ans);\n    //   }\n\n    return 0;\n}\n\n",
    "py": "# Comente todas las líneas y solo descomente el código de \n# demostración que le interese\n\n# IO_in1.txt\nimport sys\ninputs = iter(sys.stdin.readlines())\nTC = int(next(inputs))\nfor _ in range(TC):\n    print(sum(map(int, next(inputs).split())))\n\n## IO_in2.txt\n#import sys\n#for line in sys.stdin.readlines():\n#    if line == '0 0\\n': break\n#    print(sum(map(int, line.split())))\n#\n## IO_in3.txt\n#import sys\n#for line in sys.stdin.readlines():\n#    print(sum(map(int, line.split())))\n#\n## IO_in3.txt, mismo archivo de entrada que antes\n#import sys\n#for c, line in enumerate(sys.stdin.readlines(), 1):\n#    print(\"Case %s: %s\\n\" % (c, sum(map(int, line.split()))))\n#\n## IO_in3.txt, mismo archivo de entrada que antes\n#import sys\n#for c, line in enumerate(sys.stdin.readlines(), 1):\n#    if c > 1: print()\n#    print(\"Case %s: %s\" % (c, sum(map(int, line.split()))))\n#\n## IO_in4.txt\n#import sys\n#for line in sys.stdin.readlines():\n#    print(sum(map(int, line.split()[1:]))) # skip the first integer\n#\n## IO_in5.txt\n#import sys\n#for line in sys.stdin.readlines():\n#    print(sum(map(int, line.split())))\n",
    "orden": 12,
    "suborden": 1,
    "fecha_creacion": "2020-12-05 01:56:08",
    "fecha_modificacion": "2020-12-06 20:36:17"
  },
  {
    "ID": 164,
    "supergrupo": "Archivos",
    "tema": "Escritura de archivos ",
    "texto": "",
    "complejidad_tiempo": null,
    "java": "// Creando un archivo de texto usando FileWriter\n\nimport java.io.FileWriter;\nimport java.io.IOException;\n\npublic class WriteFile {\n\n    public static void main(String[] args) throws IOException {\n        // Aceptar una cadena\n        String str = \"Programación competitiva\";\n        // adjuntar un archivo a FileWriter\n        FileWriter fw = new FileWriter(\"output.txt\");\n        // leer caracteres de la cadena y escribir en FileWriter\n        fw.write(str);\n        System.out.println(\"Writing successful\");\n        //close the file \n        fw.close();\n    }\n}\n",
    "cpp": "#include <bits/stdc++.h> \nusing namespace std;\n\nint main() {\n    // fstream es la clase Stream para leer y escribir desde / hacia archivos.\n    // file es objeto de la clase fstream\n    fstream file;\n\n    // abrir el archivo \"out.txt\" en el modo de salida (escritura)\n    // ios::out Abierto para operaciones de salida.\n    file.open(\"out.txt\", ios::out);\n\n    // Si no se crea ningún archivo, muestre el mensaje de error.\n    if (!file) {\n        cout << \"Error in creating file!!!\";\n        return 0;\n    }\n    file << \"programación competitiva\" << endl;\n\n    cout << \"File created successfully.\";\n    // cerrando el archivo.\n    // La razón por la que necesita llamar a close () al final del ciclo \n    // es que al intentar abrir un nuevo archivo sin cerrar \n    // el primer archivo fallará.\n    file.close();\n\n    return 0;\n}\n",
    "py": "# Abrir un archivo\nfile1 = open('myfile.txt', 'w') \nL = [\"Programación competitiva \\n\", \"artemis \\n\", \"NMA \\n\"] \ns = \"hola mundo\\n\"\n\n# Escribir una cadena en un archivo\nfile1.write(s) \n\n# Escribir varias cadenas a la vez\nfile1.writelines(L) \n\n# Archivo de cierre\nfile1.close() \n\n# Comprobando si los datos están escritos en un archivo o no\nfile1 = open('myfile.txt', 'r') \nprint(file1.read()) \nfile1.close() \n",
    "orden": 12,
    "suborden": 2,
    "fecha_creacion": "2020-12-05 01:56:08",
    "fecha_modificacion": "2022-03-08 11:38:01"
  },
  {
    "ID": 165,
    "supergrupo": "Matemática",
    "tema": "Test de primalidad AKS",
    "texto": "Hay varias pruebas de primalidad disponibles para verificar si el número es primo o no, como el teorema de Fermat, la prueba de primaria de Miller-Rabin y mucho más. Pero el problema con todos ellos es que todos son de naturaleza probabilística. Entonces, aquí viene otro método, es decir, la prueba de primalidad AKS (prueba de primalidad de Agrawal-Kayal-Saxena) y es determinísticamente correcto para cualquier número general.\nCaracterísticas de la prueba de primalidad de AKS:\n\n1. El algoritmo AKS se puede utilizar para verificar la primacía de cualquier número general dado.\n\n2. El tiempo máximo de ejecución del algoritmo se puede expresar como un polinomio sobre el número de dígitos del número objetivo.\n\n3. Se garantiza que el algoritmo distingue de forma determinista si el número objetivo es primo o compuesto.\n\n4. La exactitud de AKS no está condicionada a ninguna hipótesis subsidiaria no probada.\n\nEsta congruencia se puede verificar en tiempo polinomial cuando r es polinomial a los dígitos de n. El algoritmo AKS evalúa esta congruencia para un gran conjunto de valores a, cuyo tamaño es polinomial a los dígitos de n. La prueba de validez del algoritmo AKS muestra que uno puede encontrar r y un conjunto de valores a con las propiedades anteriores, de modo que si las congruencias se cumplen, entonces n es una potencia de un primo. El enfoque de fuerza bruta requeriría la expansión del polinomio (x - a) ^ n y una reducción (mod n) de los coeficientes n + 1 resultantes.\nComo debe ser coprimo a n. Entonces, para implementar este algoritmo podemos verificar tomando a = 1, pero para valores grandes de n debemos tomar valores grandes de a.\nEl algoritmo se basa en la condición de que si n es cualquier número, entonces es primo si:\n(x - 1) ^ n - (x ^ n - 1) es divisible por n.\nComprobando n = 3:\n(x-1) ^ 3 - (x ^ 3 - 1)\n= (x ^ 3 - 3x ^ 2 + 3x - 1) - (x ^ 3 - 1)\n= -3x ^ 2 + 3x\nComo todos los coeficientes son divisibles por n, es decir, 3, 3 (n) es primo.\nA medida que aumenta el número, aumenta el tamaño.\nEl código se basa en esta condición y puede verificar números primos hasta 64.\n",
    "complejidad_tiempo": null,
    "java": "/*Verifica si el número es primo, este programa demuestra el concepto detras del\nAlgoritmo AKS (solo funciona hasta n=64*/\npublic class AKSPrimalityTest {\n\n    // array usado para almacenar coeficientes\n    static long c[] = new long[100];\n\n    /*\n    Función que calcula los coeficientes de \n    (x - 1)^n - (x^n - 1) con ayuda del triangulo de pascal\n     */\n    static void coef(int n) {\n        c[0] = 1;\n        for (int i = 0; i < n; c[0] = -c[0], i++) {\n            c[1 + i] = 1;\n            for (int j = i; j > 0; j--) {\n                c[j] = c[j - 1] - c[j];\n            }\n        }\n    }\n\n    //función de verificación de un numero primo\n    static boolean isPrime(int n) {\n\n        //Calculando todos los coeficientes \n        //por la función coef y almacenando todos\n        //los coeficientes en en el array c.\n        coef(n);\n        //restando c [n] y sumando c [0] por 1\n        //como (x - 1) ^ n - (x ^ n - 1), aquí\n        //se resta c [n] por 1 y se suma\n        //1 en expresión.\n        c[0]++;\n        c[n]--;\n        //comprobando todos los coeficientes si\n        //son divisibles por n o no.\n        //si n no es primo, entonces el bucle se rompe\n        //y (i> 0).\n        int i = n;\n        while ((i--) > 0 && c[i] % n == 0);\n        // Retorna true si todos los coeficientes son divisibles por n\n        return i < 0;\n    }\n\n    public static void main(String[] args) {\n        int n = 37;\n        if (isPrime(n)) {\n            System.out.println(\"Prime\");\n        } else {\n            System.out.println(\"Not Prime\");\n        }\n    }\n}\n",
    "cpp": "#include <cstdlib>\n#include <bits/stdc++.h>\nusing namespace std;\nlong c[100];\n\nstatic void coef(int n) {\n    c[0] = 1;\n    for (int i = 0; i < n; c[0] = -c[0], i++) {\n        c[1 + i] = 1;\n        for (int j = i; j > 0; j--)\n            c[j] = c[j - 1] - c[j];\n    }\n}\n\nbool isPrime(int n) {\n    coef(n);\n    c[0]++;\n    c[n]--;\n    int i = n;\n    while ((i--) > 0 && c[i] % n == 0);\n    return i < 0;\n}\n\nint main() {\n    int n = 37;\n    if (isPrime(n))\n        cout << \"Primo\" << endl;\n    else\n        cout << \"No es primo\" << endl;\n}\n",
    "py": "c = [0] * 100 \ndef coef(n): \n    c[0] = 1 \n    for i in range(n): \n        c[1 + i] = 1 \n        for j in range(i, 0, -1): \n            c[j] = c[j - 1] - c[j] \n        c[0] = -c[0] \n                \ndef isPrime(n): \n    coef(n) \n    c[0] = c[0] + 1 \n    c[n] = c[n] - 1 \n    i = n \n    while (i > -1 and c[i] % n == 0): \n        i = i - 1 \n    return True if i < 0 else False \n\nn = 37; \nif (isPrime(n)): \n    print(\"Prime\") \nelse: \n    print(\"Not Prime\")\n",
    "orden": 6,
    "suborden": 58,
    "fecha_creacion": "2020-12-05 01:56:08",
    "fecha_modificacion": "2022-03-08 11:38:01"
  },
  {
    "ID": 166,
    "supergrupo": "Matemática",
    "tema": "Test de primalidad Miller-Rabin",
    "texto": "Dado un número n, compruebe si es primo o no.\nEste método es un método probabilístico (como Fermat), pero generalmente se prefiere al método de Fermat.\n\n¿Como funciona esto?\n1. El teorema de Fermat establece que, si n es un número primo, entonces para cada a, 1 <= a <n, an-1% n = 1\n2. Los casos base aseguran que n debe ser impar. Dado que n es impar, n-1 debe ser par. Y un número par se puede escribir como d * 2s donde d es un número impar y s> 0.\n3. A partir de los dos puntos anteriores, por cada número elegido al azar en el rango [2, n-2], el valor de ad * 2r% n debe ser 1.\n4. De acuerdo con el Lema de Euclides, si x2% n = 1 o (x2 - 1)% n = 0 o (x-1) (x + 1)% n = 0. Entonces, para que n sea primo, n divide (x-1) on divide (x + 1). Lo que significa x% n = 1 o x% n = -1.\n\nDe los puntos 2 y 3, podemos concluir\nFor n to be prime, either\n\tad % n = 1 \n        OR \n    ad*2i % n = -1 \n    for some i, where 0 <= i <= r-1.\n\n",
    "complejidad_tiempo": null,
    "java": "//La función de Miller-Rabin determina si un número \n//dado es o no un número primo. \n\npublic class MillerRabin {\n\n    static boolean isPrime(long p) {\n        if (p < 2 || (p != 2 && p % 2 == 0)) {\n            return false;\n        }\n        long s = p - 1;\n        while (s % 2 == 0) {\n            s /= 2;\n        }\n        for (int i = 0; i < 5; i++) {\n            long a = (long) (Math.random() * p) % (p - 1) + 1;\n            long temp = s;\n            long mod = modpow(a, temp, p);\n            while (temp != p - 1 && mod != 1 && mod != p - 1) {\n                mod = modmul(mod, mod, p);\n                temp *= 2;\n            }\n            if (mod != p - 1 && temp % 2 == 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    static long modpow(long a, long b, long mod) {\n        if (b == 0) {\n            return 1;\n        }\n        if (b % 2 == 0) {\n            long temp = modpow(a, b / 2, mod);\n            return (temp * temp) % mod;\n        } else {\n            long temp = modpow(a, b - 1, mod);\n            return (temp * a) % mod;\n        }\n    }\n\n    public static long modmul(long a, long b, long mod) {\n        long x = 0;\n        long y = a % mod;\n        while (b > 0) {\n            if (b % 2 == 1) {\n                x = (x + y) % mod;\n            }\n            y = (y << 1) % mod;\n            b >>= 1;\n        }\n        return x % mod;\n    }\n\n    public static void main(String[] args) {\n        for (int i = 0; i < 100; i++) {\n            System.out.println(i + \" \" + isPrime(i));\n        }\n    }\n}\n",
    "cpp": "#include <bits/stdc++.h> \nusing namespace std;\n\nlong modmul(long a, long b, long mod) {\n    long x = 0;\n    long y = a % mod;\n    while (b > 0) {\n        if (b % 2 == 1) {\n            x = (x + y) % mod;\n        }\n        y = (y << 1) % mod;\n        b >>= 1;\n    }\n    return x % mod;\n}\n\nlong modpow(long a, long b, long mod) {\n    if (b == 0) {\n        return 1;\n    }\n    if (b % 2 == 0) {\n        long temp = modpow(a, b / 2, mod);\n        return (temp * temp) % mod;\n    } else {\n        long temp = modpow(a, b - 1, mod);\n        return (temp * a) % mod;\n    }\n}\n\nbool isPrime(long p) {\n    if (p < 2 || (p != 2 && p % 2 == 0)) {\n        return false;\n    }\n    long s = p - 1;\n    while (s % 2 == 0) {\n        s /= 2;\n    }\n    for (int i = 0; i < 5; i++) {\n        long a = (long) (0.5 * p) % (p - 1) + 1;\n        long temp = s;\n        long mod = modpow(a, temp, p);\n        while (temp != p - 1 && mod != 1 && mod != p - 1) {\n            mod = modmul(mod, mod, p);\n            temp *= 2;\n        }\n        if (mod != p - 1 && temp % 2 == 0) {\n            return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    for (int i = 0; i < 100; i++) {\n        cout << i << \" \" << isPrime(i) << endl;\n    }\n}\n",
    "py": "def modmul(a, b, mod):\n    x = 0;\n    y = a % mod;\n    while (b > 0):\n        if (b % 2 == 1):\n            x = (x + y) % mod;\n        y = (y << 1) % mod\n        b >>= 1\n    return x % mod\n\n\ndef modpow(a, b, mod):\n    if (b == 0):\n        return 1\n    if (b % 2 == 0):\n        temp = modpow(a, b / 2, mod)\n        return (temp * temp) % mod\n    else:\n        temp = modpow(a, b - 1, mod)\n        return (temp * a) % mod;\n    \ndef isPrime(p):\n    if (p < 2 or (p != 2 and p % 2 == 0)):\n        return False\n    s = p - 1\n    while (s % 2 == 0):\n        s /= 2\n    for i in range (5):\n        a = int((0.5 * p) % (p - 1) + 1)\n        temp = s\n        mod = modpow(a, temp, p)\n        while (temp != p - 1 and mod != 1 and mod != p - 1):\n            mod = modmul(mod, mod, p)\n            temp *= 2\n        if (mod != p - 1 and temp % 2 == 0):\n            return False\n    return True\nfor i in range (100):\n    print(str(i) + \" \" + str(isPrime(i)))\n",
    "orden": 6,
    "suborden": 59,
    "fecha_creacion": "2020-12-05 01:56:09",
    "fecha_modificacion": "2022-03-08 11:40:32"
  },
  {
    "ID": 167,
    "supergrupo": "Matemática",
    "tema": "Criba de Sundaram",
    "texto": "Dado un número n, imprima todos los números primos menores o iguales an.\n1) En general la criba de Sundaram, produce primos menores que (2 * x +2) para un número dado x. Como queremos primos menores que n, reducimos n-1 a la mitad. Lo llamamos nNew, nNew = (n-1) / 2;\n    Por ejemplo, si n = 102, entonces nNew = 50.\n                 si n = 103, entonces nNew = 51\n2) Cree una array marked[n] que se utilizará para separar números de la forma i + j + 2ij de otros donde 1 <= i <= j\n\n3) Inicialice todas las entradas de marked[] como falsa.\n\n4) Marque todos los números de la forma i + j + 2ij como verdaderos donde 1 <= i <= j, ciclo para i = 1 a nNew\n\ta) j = i;\nb) Haga un ciclo mientras (i + j + 2 * i * j) 2, luego imprima 2 como primer primo.\n5) Los números primos restantes tienen la forma 2i + 1 donde i es el índice de números NO marcados. Entonces imprima 2i + 1 para todo i tal que marked[i] sea falso.\n\n\n\n¿Como funciona esto?\nCuando producimos nuestra salida final, producimos todos los enteros de la forma 2x + 1 (es decir, son impares) excepto 2 que se maneja por separado.\nSea q un número entero de la forma 2x + 1.\nq se excluye si y solo si x es de la forma i + j + 2ij. Eso significa:\nq = 2(i + j + 2ij) + 1\n  = (2i + 1)(2j + 1)\nEntonces, un entero impar se excluye de la lista final si y solo si tiene una factorización de la forma (2i + 1) (2j + 1) es decir, si tiene un factor impar no trivial.\n",
    "complejidad_tiempo": null,
    "java": "// Programa Java para imprimir primos menores que n usando la criba de Sundaram.\n\nimport java.util.Arrays;\n\npublic class SieveSundaram {\n\n    // Imprime todos los números primos más pequeños\n    static int SieveOfSundaram(int n) {\n\n        // En general la criba de Sundaram, produce números primos menores que \n        //(2 * x + 2) para un número dado x. Como queremos primos menores que n, \n        // reducimos n a la mitad\n        int nNew = (n - 1) / 2;\n\n        // Esta matriz se usa para separar números de la \n        // forma i + j + 2ij de otros donde 1 <= i <= j\n        boolean marked[] = new boolean[nNew + 1];\n\n        // Inicializar todos los elementos como no marcados\n        Arrays.fill(marked, false);\n\n        // Lógica principal de Sundaram. Marque todos los números \n        // de la forma i + j + 2ij como verdaderos donde 1 <= i <= j\n        for (int i = 1; i <= nNew; i++) {\n            for (int j = i; (i + j + 2 * i * j) <= nNew; j++) {\n                marked[i + j + 2 * i * j] = true;\n            }\n        }\n\n        // Dado que 2 es un número primo\n        if (n > 2) {\n            System.out.print(2 + \" \");\n        }\n\n        // Imprime otros primos. Los números primos restantes son de la \n        // forma 2 * i + 1, de modo que marcado [i] es falso. \n        for (int i = 1; i <= nNew; i++) {\n            if (marked[i] == false) {\n                System.out.print(2 * i + 1 + \" \");\n            }\n        }\n        return -1;\n    }\n\n\n    public static void main(String[] args) {\n        int n = 20;\n        SieveOfSundaram(n);\n    }\n}\n",
    "cpp": "#include <bits/stdc++.h> \nusing namespace std;\n\nint SieveOfSundaram(int n) {\n\n    int nNew = (n - 1) / 2;\n    bool marked[nNew + 1];\n    memset(marked, false, sizeof (marked));\n    for (int i = 1; i <= nNew; i++)\n        for (int j = i; (i + j + 2 * i * j) <= nNew; j++)\n            marked[i + j + 2 * i * j] = true;\n    if (n > 2)\n        cout << 2 << \" \";\n    for (int i = 1; i <= nNew; i++)\n        if (marked[i] == false)\n            cout << 2 * i + 1 << \" \";\n}\n\nint main(void) {\n    int n = 20;\n    SieveOfSundaram(n);\n    return 0;\n} \n",
    "py": "def SieveOfSundaram(n): \n    nNew = int((n - 1) / 2); \n    marked = [0] * (nNew + 1); \n    for i in range(1, nNew + 1): \n        j = i; \n        while((i + j + 2 * i * j) <= nNew): \n            marked[i + j + 2 * i * j] = 1; \n            j += 1; \n    if (n > 2): \n        print(2, end=\" \"); \n  \n    for i in range(1, nNew + 1): \n        if (marked[i] == 0): \n            print((2 * i + 1), end=\" \"); \n  \nn = 20; \nSieveOfSundaram(n); \n",
    "orden": 6,
    "suborden": 60,
    "fecha_creacion": "2020-12-05 01:56:09",
    "fecha_modificacion": "2022-03-08 11:40:32"
  },
  {
    "ID": 168,
    "supergrupo": "Matemática",
    "tema": "Criba de Atkin",
    "texto": "Dado un límite, imprima todos los números primos menores o iguales al límite dado.\nEl tamiz de Atkin es un algoritmo moderno para encontrar todos los números primos hasta un número entero especificado. Comparado con el antiguo Tamiz de Eratóstenes, que delimita múltiplos de primos, realiza un trabajo preliminar y luego marca múltiplos de cuadrados de primos, por eso tiene una mejor complejidad teórica asintótica, esta complejidad es Complejidad de (N / (log log N) ).\n\n1. Cree una lista de resultados, completa con 2, 3 y 5.\n2. Cree una lista tamiz con una entrada para cada entero positivo; todas las entradas de esta lista deben marcarse inicialmente como no principales.\n3. Para cada número de entrada n en la lista de tamices, con módulo sesenta resto r:\n1. Si r es 1, 13, 17, 29, 37, 41, 49 o 53, invierta la entrada para cada posible solución a 4x2 + y2 = n.\n\n2. Si r es 7, 19, 31 o 43, invierta la entrada para cada posible solución a 3x2 + y2 = n.\n\n3. Si r es 11, 23, 47 o 59, invierta la entrada para cada posible solución a 3x2 - y2 = n cuando x> y.\n\n4. Si r es otra cosa, ignórela por completo.\n\n4. Empiece con el número más bajo de la lista de tamiz.\n5. Tome el siguiente número en la lista tamiz aún marcado como principal.\n6. Incluya el número en la lista de resultados.\n7. Eleve al cuadrado el número y marque todos los múltiplos de ese cuadrado como no primos. Tenga en cuenta que los múltiplos que se pueden factorizar por 2, 3 o 5 no necesitan marcarse, ya que se ignorarán en la enumeración final de primos.\n8. Repita los pasos del cuatro al siete.\n\n¿Cómo funciona?\n1. El algoritmo trata 2, 3 y 5 como casos especiales y simplemente los agrega al conjunto de números primos para empezar.\n2. Como la criba de Eratóstenes, comenzamos con una lista de números que queremos investigar. Supongamos que queremos encontrar números primos <= 100, luego hacemos una lista para [5, 100]. Como se explica en (1), 2, 3 y 5 son casos especiales y 4 no es primo.\n3. El algoritmo habla en términos de residuos de módulo 60. .\n4. Todos los números con un resto de módulo sesenta 1, 13, 17, 29, 37, 41, 49 o 53 tienen un resto de módulo doce de 1 o 5. Estos números son primos si y solo si el número de soluciones a 4 × 2 + y2 = n es impar y el número no tiene cuadrados. Un cuadrado entero libre es aquel que no es divisible por ningún cuadrado perfecto distinto de 1.\n5. Todos los números con un resto módulo sesenta 7, 19, 31 o 43 tienen un resto módulo seis de 1. Estos números son primos si y solo si el número de soluciones de 3x2 + y2 = n es impar y el número es squarefree.\n6. Todos los números con un resto de módulo sesenta 11, 23, 47 o 59 tienen un resto de módulo doce de 11. Estos números son primos si y sólo si el número de soluciones de 3x2 - y2 = n es impar y el número es squarefree.\nVeamos cómo genera primos hasta 20:\n1    2    3    4    5    6    7    8    9    10\n11  12   13    14   15   16   17  18   19    20\nPaso 0:\nEl estado de todos los números al inicio es Falso. El número especial es 2, 3 y 5 que se sabe que son primos.\nPaso 1:\nGenere valores para las condiciones.\n \nPaso 2:\nCambiando el estado según la condición.\nLos valores anteriores de n en la tabla generada en el ciclo x, y se probarán para la condición de módulo.\n\nColumna 1: si (valor de la columna1)% 12 == 1 o 5\nluego invierta el estado del tamiz para ese número.\nEstamos tomando un mod con 12 en lugar de 60, esto se debe a que si tomamos el mod 60, tenemos que considerar muchos r como 1, 13, 17, 29, 37, 41, 49 o 53 y para todos estos r, mod 12 es 1 o 5. (hecho solo para reducir el tamaño de la expresión)\n\nColumna 2: si (valor de la columna2)% 12 == 7\nluego invierta el estado del tamiz para ese número.\n\nColumna 3: si (valor de la columna3)% 12 == 11\nluego invierta el estado del tamiz para ese número.\n\nPaso 3 :\nComprobación de estado libre de cuadrados: si algún número de nuestra lista está en el cuadrado de cualquier número, elimínelo.\n\nPaso 4 :\nCreando una matriz de números primos para los que el estado es verdadero.\nes decir, 2 3 5 7 11 13 17 19\nPaso 5:\nImprime la salida en la pantalla.\n",
    "complejidad_tiempo": null,
    "java": "// Programa Java para la implementación de la criba de Atkin\n\npublic class SieveAtkin {\n\n    static int SieveOfAtkin(int limit) {\n        // 2 y 3 son conocidos por ser primos\n        if (limit > 2) {\n            System.out.print(2 + \" \");\n        }\n\n        if (limit > 3) {\n            System.out.print(3 + \" \");\n        }\n\n        // Inicializar la matriz de tamices con valores falsos\n        boolean sieve[] = new boolean[limit];\n\n        for (int i = 0; i < limit; i++) {\n            sieve[i] = false;\n        }\n\n        /* Se marca sieve[n] es verdadero si uno de los\n         lo siguiente es cierto:\n         a) n = (4 * x * x) + (y * y) tiene un número impar de soluciones, \n         es decir, existe un número impar de pares distintos (x, y) que \n         satisfacen la ecuación y n% 12 = 1 o n% 12 = 5.\n         b) n = (3 * x * x) + (y * y) tiene un número impar de soluciones \n         yn% 12 = 7\n         c) n = (3 * x * x) - (y * y) tiene un número impar de soluciones, \n         x> y y n% 12 = 11 */\n        for (int x = 1; x * x < limit; x++) {\n            for (int y = 1; y * y < limit; y++) {\n\n                // Parte principal de la criba de Atkin\n                int n = (4 * x * x) + (y * y);\n                if (n <= limit && (n % 12 == 1 || n % 12 == 5)) {\n                    sieve[n] ^= true;\n                }\n\n                n = (3 * x * x) + (y * y);\n                if (n <= limit && n % 12 == 7) {\n                    sieve[n] ^= true;\n                }\n\n                n = (3 * x * x) - (y * y);\n                if (x > y && n <= limit && n % 12 == 11) {\n                    sieve[n] ^= true;\n                }\n            }\n        }\n\n        // Marcar todos los múltiplos de cuadrados como no primos\n        for (int r = 5; r * r < limit; r++) {\n            if (sieve[r]) {\n                for (int i = r * r; i < limit;\n                        i += r * r) {\n                    sieve[i] = false;\n                }\n            }\n        }\n\n        // Imprima primos usando sieve[] \n        for (int a = 5; a < limit; a++) {\n            if (sieve[a]) {\n                System.out.print(a + \" \");\n            }\n        }\n        return 0;\n    }\n\n    public static void main(String[] args) {\n        int limit = 20;\n        SieveOfAtkin(limit);\n    }\n}\n",
    "cpp": "#include <bits/stdc++.h> \nusing namespace std;\n\nint SieveOfAtkin(int limit) {\n    if (limit > 2)\n        cout << 2 << \" \";\n    if (limit > 3)\n        cout << 3 << \" \";\n\n    bool sieve[limit];\n    for (int i = 0; i < limit; i++)\n        sieve[i] = false;\n\n    for (int x = 1; x * x < limit; x++) {\n        for (int y = 1; y * y < limit; y++) {\n\n            int n = (4 * x * x) + (y * y);\n            if (n <= limit && (n % 12 == 1 || n % 12 == 5))\n                sieve[n] ^= true;\n\n            n = (3 * x * x) + (y * y);\n            if (n <= limit && n % 12 == 7)\n                sieve[n] ^= true;\n\n            n = (3 * x * x) - (y * y);\n            if (x > y && n <= limit && n % 12 == 11)\n                sieve[n] ^= true;\n        }\n    }\n\n    for (int r = 5; r * r < limit; r++) {\n        if (sieve[r]) {\n            for (int i = r * r; i < limit; i += r * r)\n                sieve[i] = false;\n        }\n    }\n\n    for (int a = 5; a < limit; a++)\n        if (sieve[a])\n            cout << a << \" \";\n}\n\nint main(void) {\n    int limit = 20;\n    SieveOfAtkin(limit);\n    return 0;\n} \n",
    "py": "def SieveOfAtkin(limit): \n    if (limit > 2): \n        print(2, end=\" \") \n    if (limit > 3): \n        print(3, end=\" \") \n    sieve = [False] * limit \n    for i in range(0, limit): \n        sieve[i] = False\n    x = 1\n    while(x * x < limit): \n        y = 1\n        while(y * y < limit): \n            n = (4 * x * x) + (y * y) \n            if (n <= limit and (n % 12 == 1 or \n                n % 12 == 5)): \n                sieve[n] ^= True\n            n = (3 * x * x) + (y * y) \n            if (n <= limit and n % 12 == 7): \n                sieve[n] ^= True\n  \n            n = (3 * x * x) - (y * y) \n            if (x > y and n <= limit and \n                n % 12 == 11): \n                sieve[n] ^= True\n            y += 1\n        x += 1\n    r = 5\n    while(r * r < limit): \n        if (sieve[r]): \n            for i in range(r * r, limit, r * r): \n                sieve[i] = False\n          \n    for a in range(5, limit): \n        if (sieve[a]): \n            print(a, end=\" \") \n  \nlimit = 20\nSieveOfAtkin(limit) \n",
    "orden": 6,
    "suborden": 61,
    "fecha_creacion": "2020-12-05 01:56:09",
    "fecha_modificacion": "2022-03-08 11:40:32"
  },
  {
    "ID": 169,
    "supergrupo": "Matemática",
    "tema": "Exponenciación binaria",
    "texto": "Dados tres números x, y y p, calcule (xy)% p.\nA continuación se muestra la propiedad modular fundamental que se utiliza para calcular de manera eficiente la potencia bajo aritmética modular.\n(ab) mod p = ( (a mod p) (b mod p) ) mod p \nPor ejemplo a = 50,  b = 100, p = 13\n50  mod 13  = 11\n100 mod 13  = 9\n(50 * 100) mod 13 = ( (50 mod 13) * (100 mod 13) ) mod 13 \nor (5000) mod 13 = ( 11 * 9 ) mod 13\nor 8 = 8\n",
    "complejidad_tiempo": null,
    "java": "// Computando iterativamente la potencia modular\n\npublic class BinaryExp {\n\n    //Función iterativa para calcular\n    //(x ^ y)% p en O (log y)\n    static int power(int x, int y, int p) {\n        // Inicializar resultado\n        int res = 1;\n        // Actualiza x si es más\n        // que o igual ap\n        x = x % p;\n        if (x == 0) {\n            return 0; //  en caso de que x sea divisible por p\n        }\n        while (y > 0) {\n            //si y es impar, multiplicar x con res \n            if ((y & 1) == 1) {\n                res = (res * x) % p;\n            }\n            // y debe ser par ahora \n            // y = y / 2 \n            y = y >> 1;\n            x = (x * x) % p;\n        }\n        return res;\n    }\n\n    public static void main(String args[]) {\n        int x = 2;\n        int y = 5;\n        int p = 13;\n        System.out.println(power(x, y, p));\n    }\n}\n",
    "cpp": "#include <cstdlib>\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint power(int x, int y, int p) {\n    int res = 1;\n    x = x % p;\n    if (x == 0) return 0;\n    while (y > 0) {\n        if ((y & 1) == 1)\n            res = (res * x) % p;\n        y = y >> 1;\n        x = (x * x) % p;\n    }\n    return res;\n}\n\nint main() {\n\n    cout << power(x, y, p) << endl;\n}\n",
    "py": "def power(x, y, p):\n    res = 1\n    x = x % p\n    if x == 0: \n        return 0\n    while y > 0:\n        if ((y & 1) == 1):\n            res = (res * x) % p\n        y = y >> 1\n        x = (x * x) % p\n    return res\nx = 2\ny = 5\np = 13\nprint(power(x, y, p))\n",
    "orden": 6,
    "suborden": 62,
    "fecha_creacion": "2020-12-05 01:56:10",
    "fecha_modificacion": "2022-03-08 11:40:51"
  },
  {
    "ID": 170,
    "supergrupo": "Matemática",
    "tema": "Conteo de digitos ",
    "texto": "Cuente el número de dígitos en un entero largo ingresado por un usuario.\nPodemos usar log10 (logaritmo de base 10) para contar el número de dígitos de números positivos (el logaritmo no está definido para números negativos).\nRecuento de dígitos de N = límite superior de log10 (N).\n",
    "complejidad_tiempo": null,
    "java": "// Código JAVA para contar el número de dígitos en un entero\n\npublic class CountDigit {\n\n    static int countDigit(long n) {\n        return (int) Math.floor(Math.log10(n) + 1);\n    }\n\n    public static void main(String[] args) {\n        long n = 345289467;\n        System.out.print(\"Number of digits : \" + countDigit(n));\n    }\n}\n",
    "cpp": "#include <bits/stdc++.h> \nusing namespace std;\n\nint countDigit(long long n) {\n    return floor(log10(n) + 1);\n}\n\nint main(void) {\n    long long n = 345289467;\n    cout << \"Number of digits : \" << countDigit(n);\n    return 0;\n}\n",
    "py": "import math \n\ndef countDigit(n): \n        return math.floor(math.log(n, 10)+1) \nn = 345289467\nprint (\"Number of digits : % d\"%(countDigit(n))) \n",
    "orden": 6,
    "suborden": 63,
    "fecha_creacion": "2020-12-05 01:56:10",
    "fecha_modificacion": "2022-03-08 11:44:37"
  },
  {
    "ID": 171,
    "supergrupo": "Matemática",
    "tema": "BigInteger Modular",
    "texto": "Dado un número grande \"num\" representado como una cadena y un entero x, encuentre el valor de \"num% x\" o \"num mod x\". La salida se espera como un número entero.\nEjemplos:\nEntrada: num = \"12316767678678\", a = 10\nSalida: num (mod a) = 8\nLa idea es procesar todos los dígitos uno por uno y usar la propiedad que xy (mod a) = ((x (mod a) * y) (mod a)). A continuación se muestra la implementación.\n",
    "complejidad_tiempo": null,
    "java": "//Calcula n % m. Utilizar cuando n es un número muy muy grande.\n\npublic class BigIntegerMod {\n\n    static int mod(String n, int m) {\n        int r = 0;\n        for (int i = 0; i < n.length(); i++) {\n            r = (r * 10 + (n.charAt(i) - '0')) % m;\n        }\n        return r;\n    }\n    public static void main(String[] args) {\n        System.out.println(mod(\"9564784542\", 10));\n    }\n}\n",
    "cpp": "#include <cstdlib>\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint mod(string n, int m) {\n    int r = 0;\n    for (int i = 0; i < n.size(); i++) {\n        r = (r * 10 + (n.at(i) - '0')) % m;\n    }\n    return r;\n}\n\nint main() {\n    cout<<(mod(\"9564784542\", 10))<<endl;\n}\n",
    "py": "def mod(num, a): \n    res = 0 \n    for i in range(0, len(num)): \n        res = (res * 10 + int(num[i])) % a; \n    return res \n\nnum = \"9564784542\"; \nprint(mod(num, 10)) \n",
    "orden": 6,
    "suborden": 64,
    "fecha_creacion": "2020-12-05 01:56:10",
    "fecha_modificacion": "2022-03-08 11:49:59"
  },
  {
    "ID": 172,
    "supergrupo": "Matemática",
    "tema": "Residuo Chino",
    "texto": "Se nos dan dos matrices num [0..k-1] y rem [0..k-1]. En num [0..k-1], cada par es coprime (mcd para cada par es 1). Necesitamos encontrar un número mínimo positivo x tal que:\n\n     x % num[0]    =  rem[0], \n     x % num[1]    =  rem[1], \n     .......................\n     x % num[k-1]  =  rem[k-1] \n\nBásicamente, se nos dan k números que son coprimos por pares, y se nos dan restos de estos números cuando se divide un número desconocido x por ellos. Necesitamos encontrar el valor mínimo posible de x que produce residuos dados.\nEjemplos:\nEntrada: num [] = {5, 7}, rem [] = {1, 3}\nSalida: 31\n\nExplicación:\n31 es el número más pequeño tal que:\n   (1) Cuando lo dividimos entre 5, obtenemos el resto 1.\n   (2) Cuando lo dividimos entre 7, obtenemos el resto 3.\n\nEntrada: num [] = {3, 4, 5}, rem [] = {2, 3, 1}\nSalida: 11\n\nExplicación:\n11 es el número más pequeño tal que:\n   (1) Cuando lo dividimos por 3, obtenemos el resto 2.\n   (2) Cuando lo dividimos entre 4, obtenemos el resto 3.\n   (3) Cuando lo dividimos entre 5, obtenemos el resto 1.\n\nEl teorema chino del resto establece que siempre existe una x que satisface las congruencias dadas. A continuación se muestra el enunciado del teorema adaptado de wikipedia.\nSean num [0], num [1],… num [k-1] enteros positivos que son coprimos por pares. Entonces, para cualquier secuencia dada de enteros rem [0], rem [1],… rem [k-1], existe un entero x que resuelve el siguiente sistema de congruencias simultáneas.\n\nLa primera parte es clara que existe una x. La segunda parte básicamente establece que todas las soluciones (incluida la mínima) producen el mismo resto cuando se dividen como subproducto de n [0], num [1], .. num [k-1]. En el ejemplo anterior, el producto es 3 * 4 * 5 = 60. Y 11 es una solución, otras soluciones son 71, 131, .. etc. Todas estas soluciones producen el mismo resto cuando se dividen por 60, es decir, son de forma 11 + m * 60 donde m> = 0.\n\nLa solución se basa en la siguiente fórmula.\nx =  ( ∑ (rem[i]*pp[i]*inv[i]) ) % prod\n   Where 0 <= i <= n-1\n\nrem[i] array de residuos\n\nprod es producto de todos los números dados\nprod = num[0] * num[1] * ... * num[k-1]\n\npp[i] es producto de todo dividido por num[i]\npp[i] = prod / num[i]\n\ninv[i] = Modular Multiplicativo Inverso de\n         pp[i] con respecto a num[i]\n\n",
    "complejidad_tiempo": null,
    "java": "//Programa Java para demostrar el\n//funcionamiento del teorema del resto chino\n\npublic class ChineseRemainder {\n\n    //Devuelve el módulo inverso de a con respecto a m \n    //utilizando el algoritmo de Euclides extendido.\n    static int inv(int a, int m) {\n        int m0 = m, t, q;\n        int x0 = 0, x1 = 1;\n\n        if (m == 1) {\n            return 0;\n        }\n        // Aplicando algoritmo de Euclides extendido\n        while (a > 1) {\n            // q es cociente\n            q = a / m;\n            t = m;\n            // m es el resto ahora, proceso igual que el algoritmo de euclides\n            m = a % m;\n            a = t;\n\n            t = x0;\n\n            x0 = x1 - q * x0;\n\n            x1 = t;\n        }\n        // Hacer x1 positivo\n        if (x1 < 0) {\n            x1 += m0;\n        }\n\n        return x1;\n    }\n\n    // k es el tamaño de num [] y rem [].\n    // Devuelve el número más pequeño\n    // x tal que:\n    // x% num [0] = rem [0],\n    // x% num [1] = rem [1],\n    // ..................\n    // x% num [k-2] = rem [k-1]\n    // Supuesto: los números en num [] son \n    // coprimos por pares (mcd para cada par es 1)\n    static int findMinX(int num[], int rem[], int k) {\n        // Calcular el producto de todos los números\n        int prod = 1;\n        for (int i = 0; i < k; i++) {\n            prod *= num[i];\n        }\n        int result = 0;\n        for (int i = 0; i < k; i++) {\n            int pp = prod / num[i];\n            result += rem[i] * inv(pp, num[i]) * pp;\n        }\n\n        return result % prod;\n    }\n\n    public static void main(String args[]) {\n        int num[] = {3, 4, 5};\n        int rem[] = {2, 3, 1};\n        int k = num.length;\n        System.out.println(\"x is \" + findMinX(num, rem, k));\n    }\n}\n",
    "cpp": "#include<bits/stdc++.h> \nusing namespace std;\n\nint inv(int a, int m) {\n    int m0 = m, t, q;\n    int x0 = 0, x1 = 1;\n    if (m == 1)\n        return 0;\n    while (a > 1) {\n        q = a / m;\n        t = m;\n        m = a % m, a = t;\n        t = x0;\n        x0 = x1 - q * x0;\n        x1 = t;\n    }\n    if (x1 < 0)\n        x1 += m0;\n    return x1;\n}\n\nint findMinX(int num[], int rem[], int k) {\n    int prod = 1;\n    for (int i = 0; i < k; i++)\n        prod *= num[i];\n    int result = 0;\n    for (int i = 0; i < k; i++) {\n        int pp = prod / num[i];\n        result += rem[i] * inv(pp, num[i]) * pp;\n    }\n    return result % prod;\n}\n\nint main(void) {\n    int num[] = {3, 4, 5};\n    int rem[] = {2, 3, 1};\n    int k = sizeof (num) / sizeof (num[0]);\n    cout << \"x is \" << findMinX(num, rem, k);\n    return 0;\n}\n",
    "py": "def inv(a, m): \n    m0 = m \n    x0 = 0\n    x1 = 1\n    if (m == 1): \n        return 0\n    while (a > 1): \n        q = a // m \n        t = m \n        m = a % m \n        a = t \n        t = x0 \n        x0 = x1 - q * x0 \n        x1 = t \n    if (x1 < 0): \n        x1 = x1 + m0 \n    return x1 \n\ndef findMinX(num, rem, k): \n    prod = 1\n    for i in range(0, k): \n        prod = prod * num[i] \n    result = 0\n    for i in range(0, k): \n        pp = prod // num[i] \n        result = result + rem[i] * inv(pp, num[i]) * pp \n    return result % prod \nnum = [3, 4, 5] \nrem = [2, 3, 1] \nk = len(num) \nprint(\"x is \", findMinX(num, rem, k)) \n",
    "orden": 6,
    "suborden": 65,
    "fecha_creacion": "2020-12-05 01:56:11",
    "fecha_modificacion": "2022-03-08 14:36:15"
  },
  {
    "ID": 173,
    "supergrupo": "Matemática",
    "tema": "Logaritmo discreto",
    "texto": "Dados tres números enteros a, b y m. Encuentre un número entero k tal que a ^ k≡b donde a y m son primos relativos. Si no es posible que ningún k satisfaga esta relación, imprima -1.",
    "complejidad_tiempo": null,
    "java": "// Programa Java para calcular logaritmos discretos\n\npublic class DiscreteLogarithm {\n\n    /* Función iterativa para calcular (x ^ y)% p en\n         O (log y) */\n    static int powmod(int x, int y, int p) {\n        int res = 1; // inicializar resultado\n\n        x = x % p; // Actualice x si es más de o\n        // igual a p\n        while (y > 0) {\n            // Si y es impar, multiplica x con el resultado\n            if ((y & 1) > 0) {\n                res = (res * x) % p;\n            }\n\n            // y debe ser par ahora \n            y = y >> 1; // y = y/2 \n            x = (x * x) % p;\n        }\n        return res;\n    }\n\n    // Función para calcular k para a, b, m dados\n    static int discreteLogarithm(int a, int b, int m) {\n\n        int n = (int) (Math.sqrt(m) + 1);\n\n        int[] value = new int[m];\n\n        // Almacene todos los valores de a ^ (n * i) de LHS\n        for (int i = n; i >= 1; --i) {\n            value[powmod(a, i * n, m)] = i;\n        }\n\n        for (int j = 0; j < n; ++j) {\n            // Calcule (a ^ j) * by compruebe si hay colisión\n            int cur = (powmod(a, j, m) * b) % m;\n            // Si ocurre una colisión, es decir, LHS = RHS\n            if (value[cur] > 0) {\n                int ans = value[cur] * n - j;\n                // Compruebe si y se encuentra por debajo de m o no\n                if (ans < m) {\n                    return ans;\n                }\n            }\n        }\n        return -1;\n    }\n\n    public static void main(String[] args) {\n        int a = 2, b = 3, m = 5;\n        System.out.println(discreteLogarithm(a, b, m));\n\n        a = 3;\n        b = 7;\n        m = 11;\n        System.out.println(discreteLogarithm(a, b, m));\n    }\n}\n",
    "cpp": "#include<bits/stdc++.h> \nusing namespace std;\n\nint discreteLogarithm(int a, int b, int m) {\n    int n = (int) sqrt(m) + 1;\n    int an = 1;\n    for (int i = 0; i < n; ++i)\n        an = (an * a) % m;\n    unordered_map<int, int> value;\n    for (int i = 1, cur = an; i <= n; ++i) {\n        if (!value[ cur ])\n            value[ cur ] = i;\n        cur = (cur * an) % m;\n    }\n    for (int i = 0, cur = b; i <= n; ++i) {\n        if (value[cur]) {\n            int ans = value[cur] * n - i;\n            if (ans < m)\n                return ans;\n        }\n        cur = (cur * a) % m;\n    }\n    return -1;\n}\n\nint main() {\n    int a = 2, b = 3, m = 5;\n    cout << discreteLogarithm(a, b, m) << endl;\n    a = 3, b = 7, m = 11;\n    cout << discreteLogarithm(a, b, m);\n}\n",
    "py": "import math\n\ndef powmod(x, y, p): \n    res = 1; \n    x = x % p;\n    while (y > 0):  \n        if (y & 1): \n            res = (res * x) % p; \n        y = y >> 1; # y = y/2 \n        x = (x * x) % p; \n    return res; \n\ndef discreteLogarithm(a, b, m): \n    n = int(math.sqrt(m) + 1); \n    value = [0] * m; \n    for i in range(n, 0, -1): \n        value[powmod (a, i * n, m)] = i; \n    for j in range(n): \n        cur = (powmod (a, j, m) * b) % m; \n        if (value[cur]): \n            ans = value[cur] * n - j; \n            if (ans < m): \n                return ans; \n    return -1; \n\na = 2; \nb = 3; \nm = 5; \nprint(discreteLogarithm(a, b, m)); \na = 3; \nb = 7; \nm = 11; \nprint(discreteLogarithm(a, b, m)); \n",
    "orden": 6,
    "suborden": 66,
    "fecha_creacion": "2020-12-05 01:56:11",
    "fecha_modificacion": "2022-03-08 11:58:23"
  },
  {
    "ID": 174,
    "supergrupo": "Matemática",
    "tema": "Eliminación Gaussiana",
    "texto": "Nos ocuparemos de una matriz de coeficientes. La eliminación gaussiana no funciona en matrices singulares (conducen a la división por cero).\nEntrada: para N incógnitas, la entrada es una matriz aumentada de tamaño N x (N + 1). Una columna adicional es para el lado derecho \n  mat[N][N+1] = {\n\t\t   {3.0, 2.0,-4.0, 3.0},\n                 {2.0, 3.0, 3.0, 15.0},\n                 {5.0, -3, 1.0, 14.0}\n                };\nResultado: La solución a las ecuaciones es:\n        3.000000\n        1.000000\n        2.000000\n\nExplicación:\nLa matriz dada representa las siguientes ecuaciones\n\n3.0X1 + 2.0X2 - 4.0X3 =  3.0\n2.0X1 + 3.0X2 + 3.0X3 = 15.0\n5.0X1 - 3.0X2 +    X3 = 14.0\n\nExiste una solución única para las ecuaciones dadas, las soluciones son:\nX1 = 3.0, X2 = 1.0, X3 = 2.0, \n\n\nForma escalonada de fila: se dice que la matriz está en r.e.f. si se cumplen las siguientes condiciones:\n \n1. El primer elemento distinto de cero en cada fila, llamado coeficiente principal, es 1.\n2. Cada coeficiente principal está en una columna a la derecha del coeficiente principal de la fila anterior.\n3. Las filas con todos ceros están debajo de las filas con al menos un elemento distinto de cero.\n\n \nForma escalonada de fila reducida: se dice que la matriz está en r.r.e.f. si se cumplen las siguientes condiciones:\n1. Todas las condiciones para r.e.f.\n2. El coeficiente principal de cada fila es la única entrada distinta de cero en su columna.\nEl algoritmo trata principalmente de realizar una secuencia de operaciones en las filas de la matriz. Lo que nos gustaría tener en cuenta al realizar estas operaciones es que queremos convertir la matriz en una matriz triangular superior en forma escalonada. Las operaciones pueden ser:\n1. Intercambio de dos filas\n2. Multiplicar una fila por un escalar distinto de cero\n3. Agregar a una fila un múltiplo de otra\n\nEl proceso:\n1. Eliminación hacia adelante: reducción a la forma escalonada de fila. Usándolo uno puede saber si no hay soluciones, o una solución única, o infinitas soluciones.\n2. Sustitución hacia atrás: reducción adicional a la forma escalonada de fila reducida.\n\nAlgoritmo:\n1. Pivote parcial: encuentre el k-ésimo pivote intercambiando filas, para mover la entrada con el valor absoluto más grande a la posición del pivote. Esto imparte estabilidad computacional al algoritmo.\n2. Para cada fila debajo del pivote, calcule el factor f que hace que la entrada k sea cero, y para cada elemento de la fila reste el quinto múltiplo del elemento correspondiente en la fila k.\n3. Repita los pasos anteriores para cada desconocido. Nos quedaremos con una r.e.f. parcial. matriz.\nComplejidad de tiempo: Dado que para cada pivote recorremos la parte a su derecha para cada fila debajo de él, O (n) * (O (n) * O (n)) = O (n3).\nTambién podemos aplicar la eliminación gaussiana para calcular:\n1. Rango de una matriz\n2. Determinante de una matriz\n3. Inversa de una matriz cuadrada invertible\n",
    "complejidad_tiempo": null,
    "java": "//Resuelve sistemas de ecuaciones lineales \n//por eliminación Gaussiana. matrix contiene los \n//valores de la matriz cuadrada y result los resultados de \n//las ecuaciones. Retorna un vector con el valor de las n \n//incongnitas. Los resultados pueden necesitar redondeo.\n\nimport java.util.ArrayList;\nimport java.util.Random;\n\npublic class GaussianElimination {\n\n    static int MAX = 100;\n    static int n = 3;\n    static double matrix[][] = new double[MAX][MAX];\n    static double result[] = new double[MAX];\n\n    static ArrayList<Double> gauss() {\n        ArrayList<Double> ans = new ArrayList<Double>();\n        for (int i = 0; i < n; i++) {\n            ans.add(0.0);\n        }\n        double temp;\n        for (int i = 0; i < n; i++) {\n            int pivot = i;\n            for (int j = i + 1; j < n; j++) {\n                temp = Math.abs(matrix[j][i]) - Math.abs(matrix[pivot][i]);\n                if (temp > 0.000001) {\n                    pivot = j;\n                }\n            }\n            double temp2[] = new double[n];\n            System.arraycopy(matrix[i], 0, temp2, 0, n);\n            System.arraycopy(matrix[pivot], 0, matrix[i], 0, n);\n            System.arraycopy(temp2, 0, matrix[pivot], 0, n);\n            temp = result[i];\n            result[i] = result[pivot];\n            result[pivot] = temp;\n            if (!(Math.abs(matrix[i][i]) < 0.000001)) {\n                for (int k = i + 1; k < n; k++) {\n                    temp = -matrix[k][i] / matrix[i][i];\n                    matrix[k][i] = 0;\n                    for (int l = i + 1; l < n; l++) {\n                        matrix[k][l] += matrix[i][l] * temp;\n                    }\n                    result[k] += result[i] * temp;\n                }\n            }\n        }\n        for (int m = n - 1; m >= 0; m--) {\n            temp = result[m];\n            for (int i = n - 1; i > m; i--) {\n                temp -= ans.get(i) * matrix[m][i];\n            }\n            ans.set(m, temp / matrix[m][m]);\n        }\n        return ans;\n    }\n\n    public static void main(String[] args) {\n        Random r = new Random();\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n; j++) {\n                matrix[i][j] = r.nextInt(20);\n            }\n        }\n        for (int i = 0; i < n; i++) {\n            result[i] = r.nextInt(10);\n        }\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n; j++) {\n                System.out.print(matrix[i][j] + \" \");\n            }\n            System.out.print(\"= \" + result[i]);\n            System.out.println(\"\");\n        }\n        ArrayList<Double> res = gauss();\n        for (Double re : res) {\n            System.out.print(re + \" \");\n        }\n    }\n}\n",
    "cpp": "#include <bits/stdc++.h>\n#include <cstdlib>\nusing namespace std;\nconst int MAX = 100;\nint n = 3;\ndouble matrix[MAX][MAX];\ndouble result[MAX];\n\nvector<double> gauss() {\n    vector<double> ans;\n    for (int i = 0; i < n; i++) {\n        ans.emplace_back(0.0);\n    }\n    double temp;\n    for (int i = 0; i < n; i++) {\n        int pivot = i;\n        for (int j = i + 1; j < n; j++) {\n            temp = abs(matrix[j][i]) - abs(matrix[pivot][i]);\n            if (temp > 0.000001) {\n                pivot = j;\n            }\n        }\n        double temp2[n];\n        copy(matrix[i], matrix[i] + n, temp2);\n        copy(matrix[pivot], matrix[pivot] + n, matrix[i]);\n        copy(temp2, temp2 + n, matrix[pivot]);\n        temp = result[i];\n        result[i] = result[pivot];\n        result[pivot] = temp;\n        if (!(abs(matrix[i][i]) < 0.000001)) {\n            for (int k = i + 1; k < n; k++) {\n                temp = -matrix[k][i] / matrix[i][i];\n                matrix[k][i] = 0;\n                for (int l = i + 1; l < n; l++) {\n                    matrix[k][l] += matrix[i][l] * temp;\n                }\n                result[k] += result[i] * temp;\n            }\n        }\n    }\n    for (int m = n - 1; m >= 0; m--) {\n        temp = result[m];\n        for (int i = n - 1; i > m; i--) {\n            temp -= ans.at(i) * matrix[m][i];\n        }\n        auto itPos = ans.begin() + m;\n        ans.insert(itPos, temp / matrix[m][m]);\n        itPos = ans.begin() + m + 1;\n        ans.erase(itPos);\n    }\n    return ans;\n}\n\nint main() {\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            matrix[i][j] = rand() % 100;\n        }\n    }\n    for (int i = 0; i < n; i++) {\n        result[i] = rand() % 100;\n    }\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            cout << matrix[i][j] << \" \";\n        }\n        cout << \"= \" << result[i];\n        cout << endl;\n    }\n    vector<double> res = gauss();\n    for (double re : res) {\n        cout << re << \" \";\n    }\n}\n",
    "py": "import math\nimport random as rand\nMAX = 100\nn = 3\nmatrix = [[0.0 for i in range (MAX)]for i in range (MAX)]\nresult = [0.0 for i in range (MAX)]\ndef gauss():\n    ans = [0.0 for i in range (n)]\n    for i in range (n):\n        pivot = i\n        for j in range (i + 1, n-1, -1):\n            temp = abs(matrix[j][i]) - abs(matrix[pivot][i])\n            if (temp > 0.000001):\n                pivot = j;\n        temp2 = [0.0 for k in range (n)]\n        temp2 = matrix[i]\n        matrix[i] = matrix[pivot]\n        matrix[pivot] = temp2\n        temp = result[i]\n        result[i] = result[pivot]\n        result[pivot] = temp\n        if (not(abs(matrix[i][i]) < 0.000001)):\n            for k in range (i + 1, n-1, -1):\n                temp = -matrix[k][i] / matrix[i][i]\n                matrix[k][i] = 0\n                for l in range (i + 1, n-1, -1):\n                    matrix[k][l] += matrix[i][l] * temp\n                result[k] += result[i] * temp;\n    for m in range (n-1, 0-1, -1):            \n        temp = result[m]\n        for i in range (n-1, m-1, -1):\n            temp -= ans[i] * matrix[m][i]\n        ans[m] = matrix[m][m]\n    return ans\n\nfor i in range (n):\n    for j in range (n):\n        matrix[i][j] = rand.randint(0, 100)\nfor i in range (n):\n    result[i] = rand.randint(0, 100)\nfor i in range (n):\n    print(matrix[i][0:3])\n    print(\"= \" + str(result[i]))\nres = gauss();\nprint(res)\n",
    "orden": 6,
    "suborden": 67,
    "fecha_creacion": "2020-12-05 01:56:11",
    "fecha_modificacion": "2022-03-08 11:58:23"
  },
  {
    "ID": 175,
    "supergrupo": "Matemática",
    "tema": "Últimos dos dígitos de una potencia de 2",
    "texto": "Dado un número n, necesitamos encontrar los dos últimos dígitos de 2n.\nEjemplos:\nEntrada: n = 7\nSalida: 28\n\nEntrada: n = 72\nSalida: 96\n2 ^ 72 = 4722366482869645213696\n\nLa forma eficiente es mantener solo 2 dígitos después de cada multiplicación. Esta idea es muy similar a la discutida en Exponenciación modular donde se discute una forma general de encontrar (a ^ b)% c, aquí en este caso c es 10 ^ 2 ya que los dos últimos dígitos solo son necesarios.\n",
    "complejidad_tiempo": null,
    "java": "// Código Java para encontrar los 2 últimos dígitos de 2 ^ n\n\npublic class LastTwoDigits2powN {\n\n    /* Función iterativa para calcular (x ^ y)% p en O (log y) */\n    static int power(long x, long y,\n            long p) {\n        int res = 1; // Inicializar resultado\n        x = x % p; // Actualiza x si es mayor o igual que p\n        while (y > 0) {\n            // Si y es impar, multiplica x con el resultado \n            long r = y & 1;\n            if (r == 1) {\n                res = (res * (int) x) % (int) p;\n            }\n            // y debe ser par ahora\n            y = y >> 1; // y = y/2 \n            x = (x * x) % p;\n        }\n        return res;\n    }\n\n    // función para calcular el número de dígitos en x\n    static int numberOfDigits(int x) {\n        int i = 0;\n        while (x != 0) {\n            x /= 10;\n            i++;\n        }\n        return i;\n    }\n\n    // Función Java para imprimir los últimos 2 dígitos de 2 ^ n\n    static void LastTwoDigit(int n) {\n        System.out.print(\"Last \" + 2\n                + \" digits of \" + 2 + \"^\");\n        System.out.print(n + \" = \");\n\n        // Generando 10 ^ 2\n        int temp = 1;\n        for (int i = 1; i <= 2; i++) {\n            temp *= 10;\n        }\n        // Llamar exponenciación modular\n        temp = power(2, n, temp);\n\n        // Imprimiendo ceros más a la izquierda. Dado que (2 ^ n)% 2 puede \n        // tener dígitos menores que 2. En ese caso, necesitamos imprimir ceros\n        for (int i = 0;\n                i < (2 - numberOfDigits(temp)); i++) {\n            System.out.print(0 + \" \");\n        }\n\n        // Si la temperatura no es cero, imprima la temperatura.\n        // Si la temperatura es cero, entonces ya está impreso\n        if (temp != 0) {\n            System.out.println(temp);\n        }\n    }\n\n    public static void main(String[] args) {\n        int n = 72;\n        LastTwoDigit(n);\n    }\n}\n",
    "cpp": "#include <cstdlib>\n#include <bits/stdc++.h> \nusing namespace std;\n\nint power(long x, long y, long p) {\n    int res = 1;\n    x = x % p;\n    while (y > 0) {\n        long r = y & 1;\n        if (r == 1) {\n            res = (res * (int) x) % (int) p;\n        }\n        y = y >> 1;\n        x = (x * x) % p;\n    }\n    return res;\n}\n\nint numberOfDigits(int x) {\n    int i = 0;\n    while (x != 0) {\n        x /= 10;\n        i++;\n    }\n    return i;\n}\n\nvoid LastTwoDigit(int n) {\n    cout << \"Last \" << 2 << \"digits of \" << 2 << \"^\";\n    cout << n << \" = \";\n    int temp = 1;\n    for (int i = 1; i <= 2; i++) {\n        temp *= 10;\n    }\n    temp = power(2, n, temp);\n    for (int i = 0;\n            i < (2 - numberOfDigits(temp)); i++) {\n        cout << 0 << \" \";\n    }\n    if (temp != 0) {\n        cout << temp << endl;\n    }\n}\n\nint main() {\n    int n = 72;\n    LastTwoDigit(n);\n}\n",
    "py": "def power(x, y, p):\n    res = 1\n    x = x % p\n    while (y > 0):\n        r = y & 1\n        if (r == 1):\n            res = (res * int (x)) % int(p)\n        y = y >> 1\n        x = (x * x) % p\n    return res\n\ndef numberOfDigits(x):\n    i = 0\n    while (x != 0):\n        x /= 10\n        i += 1\n    return i\n\ndef LastTwoDigit(n):\n    print(\"Last \" + str(2) + \"digits of \" + str(2) + \"^\" + str(n) + \" = \")\n    temp = 1\n    for i in range (1, 3):\n        temp *= 10\n    temp = power(2, n, temp)\n    aux = (2 - numberOfDigits(temp))\n    for i in range (aux):\n        print(str(0) + \" \")\n    if (temp != 0):\n        print(temp);\nn = 72\nLastTwoDigit(n)\n",
    "orden": 6,
    "suborden": 68,
    "fecha_creacion": "2020-12-05 01:56:12",
    "fecha_modificacion": "2022-03-08 11:58:23"
  },
  {
    "ID": 176,
    "supergrupo": "Matemática",
    "tema": "Ecuaciones lineales diofantinas",
    "texto": "Una ecuación diofántica es una ecuación polinomial, generalmente en dos o más incógnitas, de modo que solo se requieren las soluciones integrales. Una solución integral es una solución tal que todas las variables desconocidas toman solo valores enteros.\n\nDados tres números enteros a, b, c que representan una ecuación lineal de la forma: ax + by = c. Determina si la ecuación tiene una solución tal que xey son ambos valores integrales.\n\nEjemplos:\nEntrada: a = 3, b = 6, c = 9\nSalida: posible\nExplicación: La ecuación resulta ser,\n3x + 6y = 9 una solución integral sería\nx = 1, y = 1\n\nEntrada: a = 3, b = 6, c = 8\nSalida: no posible\nExplicación: o valores integrales de x e y\nexiste que puede satisfacer la ecuación 3x + 6y = 8\n\nEntrada: a = 2, b = 5, c = 1\nSalida: posible\nExplicación: Varias soluciones integrales\nposibles son, (-2,1), (3, -1) etc.\n\nPara las ecuaciones lineales de ecuaciones diofánticas, existen soluciones integrales si y solo si, el MCD de los coeficientes de las dos variables divide perfectamente el término constante. En otras palabras, la solución integral existe si, MCD (a, b) divide c.\nPor tanto, el algoritmo para determinar si una ecuación tiene una solución integral es bastante sencillo.\n\n• Encuentra MCD de a y b\n• Compruebe si c% GCD (a, b) == 0\n• Si es así, imprima Posible\n• Otra impresión no es posible\n",
    "complejidad_tiempo": null,
    "java": "// Programa Java para buscar soluciones de ecuaciones diofánticas\n\npublic class LinearDiophantineEquations {\n\n    // Función de utilidad para encontrar el GCD de dos números\n    static int gcd(int a, int b) {\n        return (a % b == 0)\n                ? Math.abs(b) : gcd(b, a % b);\n    }\n\n    // Esta función comprueba si son posibles soluciones enteras\n    static boolean isPossible(int a,\n            int b, int c) {\n        return (c % gcd(a, b) == 0);\n    }\n\n    public static void main(String[] args) {\n        int a = 3, b = 6, c = 9;\n        if (isPossible(a, b, c)) {\n            System.out.println(\"Possible\");\n        } else {\n            System.out.println(\"Not Possible\");\n        }\n        a = 3;\n        b = 6;\n        c = 8;\n        if (isPossible(a, b, c)) {\n            System.out.println(\"Possible\");\n        } else {\n            System.out.println(\"Not Possible\");\n        }\n        a = 2;\n        b = 5;\n        c = 1;\n        if (isPossible(a, b, c)) {\n            System.out.println(\"Possible\");\n        } else {\n            System.out.println(\"Not Possible\");\n        }\n    }\n}\n",
    "cpp": "#include <cstdlib>\n#include <bits/stdc++.h> \nusing namespace std;\n\nint gcd(int a, int b) {\n    return (a % b == 0) ? abs(b) : gcd(b, a % b);\n}\n\nbool isPossible(int a, int b, int c) {\n    return (c % gcd(a, b) == 0);\n}\n\nint main() {\n    int a = 3, b = 6, c = 9;\n    if (isPossible(a, b, c)) {\n        cout << \"Possible\" << endl;\n    } else {\n        cout << \"Not Possible\" << endl;\n    }\n    a = 3;\n    b = 6;\n    c = 8;\n    if (isPossible(a, b, c)) {\n        cout << \"Possible\" << endl;\n    } else {\n        cout << \"Not Possible\" << endl;\n    }\n    a = 2;\n    b = 5;\n    c = 1;\n    if (isPossible(a, b, c)) {\n        cout << \"Possible\" << endl;\n    } else {\n        cout << \"Not Possible\" << endl;\n    }\n}\n",
    "py": "def gcd(a, b):\n    if(a % b == 0):\n        return abs(b)\n    else:\n        return gcd(b, a % b)\n\ndef isPossible(a, b, c):\n    return (c % gcd(a, b) == 0)\na = 3\nb = 6\nc = 9\nif (isPossible(a, b, c)):\n    \n    print(\"Possible\")\nelse:\n    print(\"Not Possible\") \na = 3\nb = 6\nc = 8\nif (isPossible(a, b, c)):\n    print(\"Possible\")\nelse:\n    print(\"Not Possible\")\na = 2;\nb = 5;\nc = 1;\nif (isPossible(a, b, c)):\n    print(\"Possible\")\nelse:\n    print(\"Not Possible\")\n",
    "orden": 6,
    "suborden": 69,
    "fecha_creacion": "2020-12-05 01:56:12",
    "fecha_modificacion": "2022-03-08 12:01:48"
  },
  {
    "ID": 177,
    "supergrupo": "Matemática",
    "tema": "Exponenciación de matrices",
    "texto": "¿Cuál es la complejidad de tiempo mínima para encontrar el número n de Fibonacci?\nPodemos encontrar el número n de Fibonacci en el tiempo O (Log n) usando la exponenciación matricial.\n\nPara resolver la exponenciación matricial asumimos un ecuación de recurrencia lineal como a continuación:\nF (n) = a * F (n-1) + segundo * F (n-2) + c * F (n-3) para n> = 3\n. . . . . Ecuación (1) donde a, b y c son constantes.\n\nPara esta relación de recurrencia, depende de tres valores anteriores.\nAhora intentaremos representar la Ecuación (1) en términos de la matriz.\n\n[First Matrix] = [Second matrix] * [Third Matrix]\n| F(n)   |     =   Matrix 'C'    *  | F(n-1) |\n| F(n-1) |                          | F(n-2) |\n| F(n-2) |                          | F(n-3) |\n \nLa dimensión de la primera matriz es 3 x 1.\nLa dimensión de la tercera matriz también es 3 x 1.\n\nEntonces la dimensión de la segunda matriz debe ser 3 x 3\n[Para que se cumpla la regla de la multiplicación.]\n\nAhora necesitamos llenar la Matriz 'C'.\n\nEntonces de acuerdo con nuestra ecuación.\nF(n) = a*F(n-1) + b*F(n-2) + c*F(n-3)\nF(n-1) = F(n-1)\nF(n-2) = F(n-2)\n\nC = [a b c\n     1 0 0\n     0 1 0]\n\nAhora la relación entre la matriz se convierte en: \n[First Matrix]  [Second matrix]       [Third Matrix]\n| F(n)   |  =  | a b c |  *           | F(n-1) |\n| F(n-1) |     | 1 0 0 |              | F(n-2) |\n| F(n-2) |     | 0 1 0 |              | F(n-3) |\n\nSupongamos los valores iniciales para este caso: -\nF(0) = 0\nF(1) = 1\nF(2) = 1\n\nEntonces, necesitamos obtener F (n) en términos de estos valores.\n\nEntonces, para n = 3, la ecuación (1) cambia a\n| F(3) |  =  | a b c |  *           | F(2) |\n| F(2) |     | 1 0 0 |              | F(1) |\n| F(1) |     | 0 1 0 |              | F(0) |\n\nAhora de manera similar para n = 4\n| F(4) |  =  | a b c |  *           | F(3) |\n| F(3) |     | 1 0 0 |              | F(2) |\n| F(2) |     | 0 1 0 |              | F(1) |\n\n             - - - -  2 veces - - -\n| F(4) |  =  | a b c |  * | a b c | *       | F(2) |\n| F(3) |     | 1 0 0 |    | 1 0 0 |         | F(1) |\n| F(2) |     | 0 1 0 |    | 0 1 0 |         | F(0) |\n\nEntonces, para in, la Ecuación (1) cambia a\n\n                - - - - - - - - n -2 veces - - - -  -       \n| F(n)   |  =  | a b c | * | a b c | * ... * | a b c | * | F(2) |\n| F(n-1) |     | 1 0 0 |   | 1 0 0 |         | 1 0 0 |   | F(1) |\n| F(n-2) |     | 0 1 0 |   | 0 1 0 |         | 0 1 0 |   | F(0) |\n\n\n| F(n)   |  =  [ | a b c | ] ^ (n-2)   *  | F(2) |\n| F(n-1) |     [ | 1 0 0 | ]              | F(1) |\n| F(n-2) |     [ | 0 1 0 | ]              | F(0) |\n\nEntonces, simplemente podemos multiplicar nuestra Segunda matriz n-2 veces y luego multiplicarla con la tercera matriz para obtener el resultado. La multiplicación se puede hacer en (log n) tiempo usando el algoritmo Divide and Conquer para el poder.\n\nConsideremos el problema de encontrar el término n de una serie definida usando la siguiente recurrencia.\nenésimo término,\n     F (n) = F (n-1) + F (n-2) + F (n-3), n> = 3\nCasos base:\n     F (0) = 0, F (1) = 1, F (2) = 1\nPodemos encontrar el término n usando lo siguiente:\nPoniendo a = 1, b = 1 y c = 1 en la fórmula anterior\n\n| F(n)   |  =  [ | 1 1 1 | ] ^ (n-2)   *  | F(2) |\n| F(n-1) |     [ | 1 0 0 | ]              | F(1) |\n| F(n-2) |     [ | 0 1 0 | ]              | F(0) \nComplejidad temporal de esta solución: O (log n)\n",
    "complejidad_tiempo": null,
    "java": "// Programa JAVA para encontrar el valor de f (n) donde\n// f (n) se define como\n// F (n) = F (n-1) + F (n-2) + F (n-3), n> = 3\n// Casos base:\n// F (0) = 0, F (1) = 1, F (2) = 1\n\npublic class MatrixExponentiation {\n\n    // Una función de utilidad para multiplicar dos matrices a [][] y b [][]. \n    // El resultado de la multiplicación se almacena en b [][]\n    static void multiply(int a[][], int b[][]) {\n        // Crear una matriz auxiliar para almacenar elementos \n        // de la matriz de multiplicación.\n        int mul[][] = new int[3][3];\n        for (int i = 0; i < 3; i++) {\n            for (int j = 0; j < 3; j++) {\n                mul[i][j] = 0;\n                for (int k = 0; k < 3; k++) {\n                    mul[i][j] += a[i][k]\n                            * b[k][j];\n                }\n            }\n        }\n\n        // almacenar el resultado de la multiplicación en a [][]\n        for (int i = 0; i < 3; i++) {\n            for (int j = 0; j < 3; j++) // Actualizando nuestra matriz\n            {\n                a[i][j] = mul[i][j];\n            }\n        }\n    }\n\n    // Función para calcular F subir a potencia n-2.\n    static int power(int F[][], int n) {\n        int M[][] = {{1, 1, 1}, {1, 0, 0},\n        {0, 1, 0}};\n        // Multiplíquelo con valores iniciales, es decir, con F (0) = 0,\n        // F (1) = 1, F (2) = 1\n        if (n == 1) {\n            return F[0][0] + F[0][1];\n        }\n        power(F, n / 2);\n        multiply(F, F);\n        if (n % 2 != 0) {\n            multiply(F, M);\n        }\n        // Multiplíquelo con valores iniciales, es decir, \n        // con F (0) = 0, F (1) = 1, F (2) = 1\n        return F[0][0] + F[0][1];\n    }\n\n    // Devuelve el n-ésimo término de una serie definida\n    // usando la siguiente relación de recurrencia.\n    // f (n) se define como\n    // f (n) = f (n-1) + f (n-2) + f (n-3), n> = 3\n    // Casos base:\n    // f (0) = 0, f (1) = 1, f (2) = 1\n    static int findNthTerm(int n) {\n        int F[][] = {{1, 1, 1}, {1, 0, 0},\n        {0, 1, 0}};\n\n        return power(F, n - 2);\n    }\n\n    public static void main(String[] args) {\n        int n = 5;\n        System.out.println(\"F(5) is \" + findNthTerm(n));\n    }\n}\n",
    "cpp": "#include<bits/stdc++.h> \nusing namespace std;\n\nvoid multiply(int a[3][3], int b[3][3]) {\n    int mul[3][3];\n    for (int i = 0; i < 3; i++) {\n        for (int j = 0; j < 3; j++) {\n            mul[i][j] = 0;\n            for (int k = 0; k < 3; k++) {\n                mul[i][j] += a[i][k]\n                        * b[k][j];\n            }\n        }\n    }\n    for (int i = 0; i < 3; i++) {\n        for (int j = 0; j < 3; j++) {\n            a[i][j] = mul[i][j];\n        }\n    }\n}\n\nint power(int F[3][3], int n) {\n    int M[3][3] = {\n        {1, 1, 1},\n        {1, 0, 0},\n        {0, 1, 0}\n    };\n    if (n == 1) {\n        return F[0][0] + F[0][1];\n    }\n    power(F, n / 2);\n    multiply(F, F);\n    if (n % 2 != 0) {\n        multiply(F, M);\n    }\n    return F[0][0] + F[0][1];\n}\n\nint findNthTerm(int n) {\n    int F[3][3] = {\n        {1, 1, 1},\n        {1, 0, 0},\n        {0, 1, 0}\n    };\n\n    return power(F, n - 2);\n}\n\nint main() {\n    int n = 5;\n    cout << \"F(5) is \" << findNthTerm(n) << endl;\n}\n",
    "py": "def multiply(a, b):\n    mul = [[0 for i in range (3)]for j in range (3)]\n    for i in range (3):\n        for j in range(3):\n            mul[i][j] = 0\n            for k in range(3):\n                mul[i][j] += a[i][k] * b[k][j]\n    for i in range (3):\n        for j in range(3):\n            a[i][j] = mul[i][j]\n \ndef power(F, n):\n    M = [[1, 1, 1],\n        [1, 0, 0],\n        [0, 1, 0]]\n    if (n == 1):\n        return F[0][0] + F[0][1]\n    power(F, n / 2)\n    multiply(F, F)\n    if (n % 2 != 0):\n        multiply(F, M)\n    return F[0][0] + F[0][1]\n\ndef findNthTerm(n):\n    F = [[1, 1, 1],\n        [1, 0, 0],\n        [0, 1, 0]]\n    return power(F, n - 2)\n\nn = 5\nprint(\"F(5) is \" + str(findNthTerm(n)));\n",
    "orden": 6,
    "suborden": 70,
    "fecha_creacion": "2020-12-05 01:56:12",
    "fecha_modificacion": "2022-03-08 12:01:47"
  },
  {
    "ID": 178,
    "supergrupo": "Matemática",
    "tema": "Verificación de cuadrados mágicos",
    "texto": "Dada una matriz, comprueba si es un cuadrado mágico o no. Un cuadrado mágico es una matriz n x n de elementos distintos de 1 a n2 donde la suma de cualquier fila, columna o diagonal es siempre igual al mismo número.\nEjemplos:\nEntrada: n = 3\n 2   7   6\n  9   5   1\n  4   3   8\nSalida: matriz mágica\nExplicación: En la matriz, la suma de cada fila y cada columna y la suma diagonal es igual = 15.\n\nEntrada: n = 3\n  1   2   2 \n  2   2   1\n  2   1   2\nResultado: No es una matriz mágica\nExplicación: En la matriz, la suma de cada fila y cada columna y la suma de las diagonales no es la misma.\n\n1. Encuentre la suma de la diagonal principal y la diagonal secundaria.\n2. Calcule la suma de cada fila y columna.\n3. Si la suma de la diagonal principal y la diagonal secundaria es igual a la suma de cada fila y la suma de cada columna, entonces es una matriz mágica.\n",
    "complejidad_tiempo": null,
    "java": "// Programa JAVA para verificar si una matriz dada es matriz mágica o no\n\npublic class IsMagicSquare {\n\n    static int N = 3;\n\n    // Devuelve verdadero si mat [][] es un cuadrado mágico, de lo contrario devuelve falso.\n    static boolean isMagicSquare(int mat[][]) {\n\n        // calcular la suma de la diagonal prima\n        int sum = 0, sum2 = 0;\n        for (int i = 0; i < N; i++) {\n            sum = sum + mat[i][i];\n        }\n\n        // la diagonal secundaria\n        for (int i = 0; i < N; i++) {\n            sum2 = sum2 + mat[i][N - 1 - i];\n        }\n\n        if (sum != sum2) {\n            return false;\n        }\n\n        // Para sumas de filas\n        for (int i = 0; i < N; i++) {\n\n            int rowSum = 0;\n            for (int j = 0; j < N; j++) {\n                rowSum += mat[i][j];\n            }\n\n            // compruebe si la suma de cada fila es igual a la suma diagonal principal\n            if (rowSum != sum) {\n                return false;\n            }\n        }\n\n        // Para sumas de columnas\n        for (int i = 0; i < N; i++) {\n\n            int colSum = 0;\n            for (int j = 0; j < N; j++) {\n                colSum += mat[j][i];\n            }\n\n            // compruebe si la suma de cada columna es igual \n            // a la suma diagonal principal\n            if (sum != colSum) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n\n    public static void main(String[] args) {\n        int mat[][] = {{2, 7, 6},\n        {9, 5, 1},\n        {4, 3, 8}};\n\n        if (isMagicSquare(mat)) {\n            System.out.println(\"Magic Square\");\n        } else {\n            System.out.println(\"Not a magic\"\n                    + \" Square\");\n        }\n    }\n}\n",
    "cpp": "#include <bits/stdc++.h> \n\n#define N 3 \nusing namespace std;\n\nbool isMagicSquare(int mat[][N]) {\n\n    int sum = 0, sum2 = 0;\n    for (int i = 0; i < N; i++)\n        sum = sum + mat[i][i];\n    for (int i = 0; i < N; i++)\n        sum2 = sum2 + mat[i][N - 1 - i];\n\n    if (sum != sum2)\n        return false;\n\n    for (int i = 0; i < N; i++) {\n\n        int rowSum = 0;\n        for (int j = 0; j < N; j++)\n            rowSum += mat[i][j];\n\n        if (rowSum != sum)\n            return false;\n    }\n\n\n    for (int i = 0; i < N; i++) {\n\n        int colSum = 0;\n        for (int j = 0; j < N; j++)\n            colSum += mat[j][i];\n        if (sum != colSum)\n            return false;\n    }\n\n    return true;\n}\n\nint main() {\n    int mat[][N] = {\n        { 2, 7, 6},\n        { 9, 5, 1},\n        { 4, 3, 8}\n    };\n\n    if (isMagicSquare(mat))\n        cout << \"Magic Square\";\n    else\n        cout << \"Not a magic Square\";\n\n    return 0;\n} \n",
    "py": "N = 3\n\ndef isMagicSquare(mat): \n    s = 0 \n    for i in range(0, N): \n        s = s + mat[i][i] \n\n    s2 = 0\n    for i in range(0, N): \n        s2 = s2 + mat[i][N-i-1] \n  \n    if(s != s2): \n        return False\n \n    for i in range(0, N): \n        rowSum = 0;      \n        for j in range(0, N): \n            rowSum += mat[i][j] \n         \n        if (rowSum != s): \n            return False\n\n    for i in range(0, N): \n        colSum = 0\n        for j in range(0, N): \n            colSum += mat[j][i] \n        if (s != colSum): \n            return False\n  \n    return True\n   \nmat = [[2, 7, 6], \n    [9, 5, 1], \n    [4, 3, 8]] \n      \nif (isMagicSquare(mat)): \n    print(\"Magic Square\") \nelse: \n    print(\"Not a magic Square\") \n",
    "orden": 6,
    "suborden": 71,
    "fecha_creacion": "2020-12-05 01:56:13",
    "fecha_modificacion": "2022-03-08 12:01:48"
  },
  {
    "ID": 179,
    "supergrupo": "Matemática",
    "tema": "Búsqueda de datos faltantes en cuadrados mágicos ",
    "texto": "Dado un tapete de matriz de 3X3 con los elementos de la diagonal izquierda que faltan (establecido en 0), considerando que la suma de cada fila, columna y diagonal de la matriz original era igual, la tarea es encontrar los elementos diagonales que faltan e imprimir la matriz original.\nEjemplos:\nEntrada: mat[][] = {{0, 7, 6}, {9, 0, 1}, {4, 3, 0}}\nSalida:\n2 7 6\n9 5 1\n4 3 8\nSuma de filas = Suma de columnas = Suma diagonal = 15\nEntrada: mat[][] = {{0, 1, 1}, {1, 0, 1}, {1, 1, 0}}\nSalida:\n1 1 1\n1 1 1\n1 1 1\nEnfoque: Sea Sum la suma total excluyendo los elementos diagonales,\nSum = suma total de la matriz dada - diagonalSum\nSuma = (3 * rowSum) - diagonalSum\nSum = (2 * rowSum) [Dado que, columnSum = rowSum = diagonalSum]\nrowSum = Sum / 2\nPor lo tanto, podemos insertar un elemento en cada fila de modo que la suma de la fila sea rowSum\n",
    "complejidad_tiempo": null,
    "java": "// JPrograma Java para llenar espacios en blanco con números\n\npublic class MagicSquareMissing {\n\n    // Función para imprimir la matriz original\n    static int printFilledDiagonal(int sq[][]) {\n        // Calcular la suma de todos los elementos de la matriz\n        int sum = 0;\n        for (int i = 0; i < 3; i++) {\n            for (int j = 0; j < 3; j++) {\n                sum += sq[i][j];\n            }\n        }\n\n        // Suma requerida de cada fila (del enfoque)\n        sum /= 2;\n\n        for (int i = 0; i < 3; i++) {\n            // Suma de filas excluyendo el elemento diagonal\n            int rowSum = 0;\n            for (int j = 0; j < 3; j++) {\n                rowSum += sq[i][j];\n            }\n            // Elemento que debe insertarse en el \n            // elemento diagonal de la fila actual\n            sq[i][i] = sum - rowSum;\n        }\n\n        // Imprime la matriz actualizada\n        for (int i = 0; i < 3; i++) {\n            for (int j = 0; j < 3; j++) {\n                System.out.print(sq[i][j] + \" \");\n            }\n            System.out.println();\n        }\n        return 0;\n    }\n\n    public static void main(String[] args) {\n        int sq[][] = {\n            {0, 7, 6},\n            {9, 0, 1},\n            {4, 3, 0}\n        };\n\n        printFilledDiagonal(sq);\n    }\n\n}\n",
    "cpp": "#include <bits/stdc++.h> \nusing namespace std;\n\nint printFilledDiagonal(int sq[][3]) {\n\n    int sum = 0;\n    for (int i = 0; i < 3; i++)\n        for (int j = 0; j < 3; j++)\n            sum += sq[i][j];\n\n    sum /= 2;\n\n    for (int i = 0; i < 3; i++) {\n        int rowSum = 0;\n        for (int j = 0; j < 3; j++)\n            rowSum += sq[i][j];\n        sq[i][i] = sum - rowSum;\n    }\n\n    for (int i = 0; i < 3; i++) {\n        for (int j = 0; j < 3; j++)\n            cout << sq[i][j] << \" \";\n        cout << endl;\n    }\n}\n\nint main() {\n    int sq[3][3] = {\n        { 0, 7, 6},\n        { 9, 0, 1},\n        { 4, 3, 0}\n    };\n\n    printFilledDiagonal(sq);\n    return 0;\n} \n",
    "py": "def printFilledDiagonal(sq):  \n  \n    Sum = 0\n    for i in range(0, 3):  \n        for j in range(0, 3):  \n            Sum += sq[i][j]  \n \n    Sum = Sum // 2\n  \n    for i in range(0, 3):  \n        rowSum = 0\n        for j in range(0, 3):  \n            rowSum += sq[i][j]  \n \n        sq[i][i] = Sum - rowSum  \n      \n    for i in range(0, 3):  \n        for j in range(0, 3):  \n            print(sq[i][j], end=\" \")  \n        print() \n        \nsq = [[0, 7, 6], \n    [9, 0, 1], \n    [4, 3, 0]]  \n\nprintFilledDiagonal(sq)  \n      \n",
    "orden": 6,
    "suborden": 72,
    "fecha_creacion": "2020-12-05 01:56:13",
    "fecha_modificacion": "2022-03-08 12:01:47"
  },
  {
    "ID": 180,
    "supergrupo": "Matemática",
    "tema": "Intercambio mínimo entre esquinas",
    "texto": "Dado el número N de elementos, encuentre el número mínimo de intercambios requeridos para que el elemento máximo esté al principio y el elemento mínimo esté al final con la condición de que solo se permita el intercambio de elementos adyacentes.\n\nEjemplos:\nEntrada: a [] = {3, 1, 5, 3, 5, 5, 2}\nSalida: 6\nPaso 1: intercambie 5 con 1 para hacer el array como {3, 5, 1, 3, 5, 5, 2}\nPaso 2: intercambia 5 por 3 para hacer el array como {5, 3, 1, 3, 5, 5, 2}\nPaso 3: intercambia 1 con 3 a su derecha para hacer el array como {5, 3, 3, 1, 5, 5, 2}\nPaso 4: intercambie 1 con 5 a su derecha para hacer el array como {5, 3, 3, 5, 1, 5, 2}\nPaso 5: intercambia 1 con 5 a su derecha para hacer el array como {5, 3, 3, 5, 5, 1, 2}\nPaso 6: intercambie 1 con 2 a su derecha para hacer el array como {5, 3, 3, 5, 5, 2, 1}\nDespués de realizar 6 operaciones de intercambio, 5 está al principio y 1 al final\nEntrada: a [] = {5, 6, 1, 3}\nSalida: 2\n\nEl enfoque será encontrar el índice del elemento más grande (sea l). Encuentre el índice del elemento más grande más a la izquierda si el elemento más grande aparece en el array más de una vez. De manera similar, encuentre el índice del elemento más pequeño más a la derecha (sea r). Existen dos casos para solucionar este problema.\n1. Caso 1: Si l <r: Número de intercambios = l + (n-r-1)\n2. Caso 2: Si l> r: Número de intercambios = l + (n-r-2), ya que ya se realizó un intercambio mientras se intercambiaba el elemento más grande al frente\n",
    "complejidad_tiempo": null,
    "java": "// Programa Java para contar Número mínimo de intercambios para que el\n// elemento más grande esté al principio y el elemento más pequeño esté al final\n\nimport java.io.*;\n\npublic class MinimumAdjacentSwapsMaxMinCorners {\n\n    public static void minimumSwaps(int a[], int n) {\n        int maxx = -1, minn = a[0], l = 0, r = 0;\n        for (int i = 0; i < n; i++) {\n            // Índice del elemento más grande situado más a la izquierda\n            if (a[i] > maxx) {\n                maxx = a[i];\n                l = i;\n            }\n            // Índice del elemento más pequeño situado más a la derecha\n            if (a[i] <= minn) {\n                minn = a[i];\n                r = i;\n            }\n        }\n        if (r < l) {\n            System.out.println(l + (n - r - 2));\n        } else {\n            System.out.println(l + (n - r - 1));\n        }\n    }\n\n    public static void main(String args[]) throws IOException {\n        int a[] = {5, 6, 1, 3};\n        int n = a.length;\n        minimumSwaps(a, n);\n    }\n}\n",
    "cpp": null,
    "py": null,
    "orden": 6,
    "suborden": 73,
    "fecha_creacion": "2020-12-05 01:56:13",
    "fecha_modificacion": "2022-03-08 12:01:47"
  },
  {
    "ID": 181,
    "supergrupo": "Matemática",
    "tema": "Multiplicación modular",
    "texto": "Considere a continuación un método simple para multiplicar dos números.\nUna solución simple que causa un desbordamiento cuando el valor de (a% mod) * (b% mod) supera el valor máximo de long long int  \n\n#define ll long long\nll multiply(ll a, ll b, ll mod) \n{ \n   return ((a % mod) * (b % mod)) % mod; \n}\n\nLa función anterior funciona bien cuando la multiplicación no da como resultado un desbordamiento. Pero si los números de entrada son tales que el resultado de la multiplicación supera el límite máximo.\nPor ejemplo, el método anterior falla cuando mod = 1011, a = 9223372036854775807 (mayor largo int largo) yb = 9223372036854775807 (mayor int largo largo). Tenga en cuenta que puede haber valores más pequeños para los que puede fallar. Puede haber muchos más ejemplos de valores más pequeños. De hecho, cualquier conjunto de valores para los que la multiplicación puede generar un valor superior al límite máximo.\n\n¿Cómo evitar el desbordamiento?\nPodemos multiplicar de forma recursiva para superar la dificultad del desbordamiento. Para multiplicar a * b, primero calcula a * b / 2 y luego súmalo dos veces. Para calcular a * b / 2, calcule a * b / 4 y así sucesivamente (similar al algoritmo de exponenciación log n).\n\n// Computar (a * b) % mod\nmultiply(a,  b, mod)\n1)  ll res = 0; // Inicializar resultado\n2)  a = a % mod.\n3)  While (b > 0)\n        a) Si b es impar, agregue 'a' al resultado.\n               res = (res + a) % mod\n        b) Multiplica 'a' por 2\n           a = (a * 2) % mod\n        c) Dividir 'b' por 2\n           b = b/2  \n4)  Return res \n",
    "complejidad_tiempo": null,
    "java": "// Realiza la operación (a * b) % mod minimizando posibles desbordamientos.\n\npublic class ModMultiplication {\n\n    public static long modmul(long a, long b, long mod) {\n        long x = 0;\n        long y = a % mod;\n        while (b > 0) {\n            if (b % 2 == 1) {\n                x = (x + y) % mod;\n            }\n            y = (y << 1) % mod;\n            b >>= 1;\n        }\n        return x % mod;\n    }\n\n    public static void main(String[] args) {\n        System.out.println(modmul(2, 2, 2));\n    }\n}\n",
    "cpp": "#include <bits/stdc++.h> \nusing namespace std;\n\nlong modmul(long a, long b, long mod) {\n    long x = 0;\n    long y = a % mod;\n    while (b > 0) {\n        if (b % 2 == 1) {\n            x = (x + y) % mod;\n        }\n        y = (y << 1) % mod;\n        b >>= 1;\n    }\n    return x % mod;\n}\n\nint main() {\n    cout << modmul(2, 2, 2) << endl;\n}\n",
    "py": "def modmul(a, b, mod):\n    x = 0\n    y = a % mod\n    while (b > 0):\n        if (b % 2 == 1):\n            x = (x + y) % mod\n        y = (y << 1) % mod;\n        b >>= 1;\n    return x % mod;\nprint(modmul(2, 2, 2))\n",
    "orden": 6,
    "suborden": 74,
    "fecha_creacion": "2020-12-05 01:56:14",
    "fecha_modificacion": "2022-03-08 12:01:47"
  },
  {
    "ID": 182,
    "supergrupo": "Matemática",
    "tema": "Next Permutation",
    "texto": "Dada una matriz o cadena, la tarea es encontrar la siguiente permutación lexicográficamente mayor de la misma.\n\nEjemplos:\nEntrada: string = \"gfg\"\nSalida: ggf\n\nEntrada: arr [] = {1, 2, 3}\nSalida: {1, 3, 2}\n\nEn C ++, hay una función específica que nos ahorra mucho código. Está en el archivo de encabezado #include <algorithm>. La función es next_permutation (a.begin (), a.end ()). Se utiliza para reorganizar los elementos en el rango [primero, último) en la siguiente permutación lexicográficamente mayor. Una permutación es cada uno de los N! posibles disposiciones que pueden tomar los elementos (donde N es el número de elementos en el rango). Se pueden ordenar diferentes permutaciones según cómo se comparan lexicográficamente entre sí.\nAparentemente, Java no proporciona ningún método incorporado.\n\n\n1. Encuentre el sufijo no creciente más largo y encuentre el pivote.\n2. Si el sufijo es la matriz completa, entonces no hay permutación de orden superior para los datos.\n3. Encuentre el sucesor del pivote situado más a la derecha.\n4. Cambie el sucesor y el pivote.\n5. Invierta el sufijo.\n",
    "complejidad_tiempo": null,
    "java": "// Programa Java para implementar el método next_permutation\n\nimport java.util.Arrays;\n\npublic class NextPermutation {\n\n    // Función para intercambiar los datos presentes en los índices izquierdo y derecho\n    public static int[] swap(int data[], int left, int right) {\n\n        // Intercambiar los datos\n        int temp = data[left];\n        data[left] = data[right];\n        data[right] = temp;\n\n        // Devuelve la matriz actualizada\n        return data;\n    }\n\n    // Función para invertir la submatriz comenzando \n    // de izquierda a derecha ambos inclusive\n    public static int[] reverse(int data[], int left, int right) {\n\n        // Invertir la submatriz\n        while (left < right) {\n            int temp = data[left];\n            data[left++] = data[right];\n            data[right--] = temp;\n        }\n\n        // Devuelve la matriz actualizada\n        return data;\n    }\n\n    // Función para encontrar la siguiente permutación de la matriz de enteros dada\n    public static boolean findNextPermutation(int data[]) {\n\n        // Si el conjunto de datos dado está vacío o contiene solo \n        // un elemento next_permutation no es posible\n        if (data.length <= 1) {\n            return false;\n        }\n\n        int last = data.length - 2;\n\n        // encuentra el sufijo no creciente más largo y encuentra el pivote\n        while (last >= 0) {\n            if (data[last] < data[last + 1]) {\n                break;\n            }\n            last--;\n        }\n\n        // Si no hay un par creciente, no hay permutación de orden superior\n        if (last < 0) {\n            return false;\n        }\n\n        int nextGreater = data.length - 1;\n\n        // Encuentra el sucesor más a la derecha del pivote\n        for (int i = data.length - 1; i > last; i--) {\n            if (data[i] > data[last]) {\n                nextGreater = i;\n                break;\n            }\n        }\n\n        // Intercambiar el sucesor y el pivote\n        data = swap(data, nextGreater, last);\n\n        // Invertir el sufijo\n        data = reverse(data, last + 1, data.length - 1);\n\n        // Devuelve verdadero cuando se realiza next_permutation\n        return true;\n    }\n\n    public static void main(String args[]) {\n        int data[] = {1, 2, 3};\n        if (!findNextPermutation(data)) {\n            System.out.println(\"There is no higher\"\n                    + \" order permutation \"\n                    + \"for the given data.\");\n        } else {\n            System.out.println(Arrays.toString(data));\n        }\n    }\n}\n",
    "cpp": "#include <algorithm> \n#include <iostream> \nusing namespace std;\n\nint main() {\n    int arr[] = {1, 2, 3};\n    int n = sizeof (arr) / sizeof (arr[0]);\n\n    sort(arr, arr + n);\n\n    cout << \"The \" << n << \"! possible permutations with \" << n << \" elements:\\n\";\n    do {\n        cout << arr[0] << \" \" << arr[1] << \" \" << arr[2] << \"\\n\";\n    } while (next_permutation(arr, arr + 3));\n\n    cout << \"After loop: \" << arr[0] << ' '\n            << arr[1] << ' ' << arr[2] << '\\n';\n\n    return 0;\n}\n",
    "py": "def swap(data, left, right):\n    temp = data[left]\n    data[left] = data[right]\n    data[right] = temp\n    return data\n\ndef reverse(data, left, right):\n    while (left < right):\n        temp = data[left]\n        left += 1\n        data[left] = data[right]\n        right -= 1\n        data[right] = temp\n    return data;\n\ndef findNextPermutation(data):\n    if (len(data) <= 1):\n        return False;\n    last = len(data) - 2\n    while (last >= 0):\n        if (data[last] < data[last + 1]):\n            break\n        last -= 1\n    if (last < 0):\n        return False\n    nextGreater = len(data) - 1\n    for i in range (len(data)-1, last, -1):\n        if (data[i] > data[last]):\n            nextGreater = i\n            break\n    data = swap(data, nextGreater, last);\n    data = reverse(data, last + 1, len(data) - 1);\n    return True\n\n\ndata = [1, 2, 3]\nif (findNextPermutation(data) == False):\n    print(\"There is no higher\"\n          + \" order permutation \"\n          + \"for the given data.\")\nelse:\n    print(data)\n\n",
    "orden": 6,
    "suborden": 75,
    "fecha_creacion": "2020-12-05 01:56:14",
    "fecha_modificacion": "2022-03-08 12:01:47"
  },
  {
    "ID": 183,
    "supergrupo": "Matemática",
    "tema": "Prev Permutation",
    "texto": "Dada una palabra, encuentre una permutación lexicográficamente más pequeña de ella. Por ejemplo, la permutación lexicográficamente más pequeña de \"4321\" es \"4312\" y la siguiente permutación más pequeña de \"4312\" es \"4231\". Si la cadena está ordenada en orden ascendente, la siguiente permutación lexicográficamente más pequeña no existe.\nHemos discutido next_permutation () que modifica una cadena para que almacene permutación lexicográficamente más pequeña. STL también proporciona std :: prev_permutation. Devuelve \"verdadero\" si la función pudiera reorganizar el objeto como una permutación lexicográficamente más pequeña. De lo contrario, devuelve \"falso\".\n",
    "complejidad_tiempo": null,
    "java": "import java.util.Arrays;\n\npublic class PrevPermutation {\n\n    public static boolean prev_permutation(int[] arr) {\n        int len = arr.length;\n        int i = len - 1;\n        // 1. encuentra el mayor i donde arr [i - 1]> arr [i]\n        while (i > 0) {\n            if (arr[i - 1] > arr[i]) {\n                break;\n            }\n            i--;\n        }\n        if (i <= 0) {\n            return false;\n        }\n        // 2. encontrar el mayor j donde arr [i - 1]> arr [j] yj> = i\n        int j = len - 1;\n        while (j >= i) {\n            if (arr[i - 1] > arr[j]) {\n                break;\n            }\n            j--;\n        }\n        // 3. intercambiar elementos entre arr [i-1] y arr [j]\n        swap(i - 1, j, arr);\n        // 4. invertir elementos desde i hasta el final de la matriz\n        len--;\n        while (i < len) {\n            swap(i, len, arr);\n            len--;\n            i++;\n        }\n        return true;\n    }\n\n    public static void swap(int x, int y, int[] arr) {\n        int temp = arr[x];\n        arr[x] = arr[y];\n        arr[y] = temp;\n    }\n\n    public static void main(String[] args) {\n        int data[] = {3, 2, 1};\n        while (prev_permutation(data)) {\n            System.out.println(Arrays.toString(data));\n        }\n    }\n}\n\n",
    "cpp": "#include <algorithm> \n#include <iostream> \nusing namespace std;\n\nint main() {\n    int arr[] = {1, 2, 3};\n    int n = sizeof (arr) / sizeof (arr[0]);\n\n    sort(arr, arr + n);\n    reverse(arr, arr + n);\n\n    cout << \"The \" << n << \"! possible permutations with \" << n << \" elements:\\n\";\n    do {\n        cout << arr[0] << \" \" << arr[1] << \" \" << arr[2] << \"\\n\";\n    } while (prev_permutation(arr, arr + 3));\n\n    cout << \"After loop: \" << arr[0] << ' ' << arr[1]\n            << ' ' << arr[2] << '\\n';\n    return 0;\n}\n\n",
    "py": "def swap(x, y, arr):\n    temp = arr[x]\n    arr[x] = arr[y]\n    arr[y] = temp\n    \ndef prev_permutation(arr):\n    lenght = len(arr)\n    i = lenght - 1\n    while (i > 0):\n        if (arr[i - 1] > arr[i]):\n            break\n        i -= 1\n    if (i <= 0):\n        return False\n    j = lenght - 1\n    while (j >= i):\n        if (arr[i - 1] > arr[j]):\n            break\n        j -= 1\n    swap(i - 1, j, arr);\n    lenght -= 1\n    while (i < lenght):\n        swap(i, lenght, arr)\n        lenght -= 1\n        i += 1\n    return True;\ndata = [3, 2, 1]\nwhile (prev_permutation(data)):\n    print(data)\n",
    "orden": 6,
    "suborden": 76,
    "fecha_creacion": "2020-12-05 01:56:14",
    "fecha_modificacion": "2022-03-08 12:01:47"
  },
  {
    "ID": 184,
    "supergrupo": "Matemática",
    "tema": "Tripletas pitagóricas",
    "texto": "Un triplete pitagórico es un conjunto de tres enteros positivos a, b y c tales que a2 + b2 = c2. Dado un límite, genere todos los Triples pitagóricos con valores menores que el límite dado.\nEntrada: límite = 20\nSalida: 3 4 5\n        \t  8 6 10\n           5 12 13\n           15 8 17\n           12 16 20\nUna solución simple es generar estos tripletes más pequeños que el límite dado utilizando tres bucles anidados. Para cada triplete, verifique si la condición pitagórica es verdadera, si es verdadera, luego imprima el triplete. La complejidad temporal de esta solución es O (límite3) donde \"límite\" se da límite.\nUna solución eficiente puede imprimir todos los tripletes en el tiempo O (k) donde k es el número de tripletes impresos. La idea es usar la relación de suma cuadrada del triplete pitagórico, es decir, la suma de los cuadrados de a y b es igual al cuadrado de c, podemos escribir estos números en términos de m y n de manera que,\n\ta = m2 - n2\n       b = 2 * m * n\n       c  = m2 + n2\nporque,\n       a2 = m4 + n4 – 2 * m2 * n2\n       b2 = 4 * m2 * n2\n       c2 = m4 + n4 + 2* m2 * n2\nPodemos ver que a2 + b2 = c2, por lo que en lugar de iterar para a, b y c, podemos iterar para m y n y podemos generar estos tripletes.\n",
    "complejidad_tiempo": null,
    "java": "// Programa Java para generar tripletes pitagóricos \n// más pequeños que un límite dado\n\npublic class PythagoreanTriplets {\n\n    // Función para generar tripletes pitagóricos menores que el límite\n    static void pythagoreanTriplets(int limit) {\n\n        // triplete: a ^ 2 + b ^ 2 = c ^ 2\n        int a, b, c = 0;\n\n        // bucle de 2 a max_limit\n        int m = 2;\n\n        // Limitar c limitaría todo a, b y c\n        while (c < limit) {\n\n            // ahora bucle en j de 1 a i-1\n            for (int n = 1; n < m; ++n) {\n                // Evaluar e imprimir tripletes usando \n                // la relación entre a, by c\n                a = m * m - n * n;\n                b = 2 * m * n;\n                c = m * m + n * n;\n\n                if (c > limit) {\n                    break;\n                }\n\n                System.out.println(a + \" \" + b + \" \" + c);\n            }\n            m++;\n        }\n    }\n\n    public static void main(String args[]) {\n        int limit = 20;\n        pythagoreanTriplets(limit);\n    }\n}\n",
    "cpp": "#include <bits/stdc++.h> \n\nvoid pythagoreanTriplets(int limit) {\n\n    int a, b, c = 0;\n    int m = 2;\n\n    while (c < limit) {\n        for (int n = 1; n < m; ++n) {\n            a = m * m - n * n;\n            b = 2 * m * n;\n            c = m * m + n * n;\n            if (c > limit)\n                break;\n            printf(\"%d %d %d\\n\", a, b, c);\n        }\n        m++;\n    }\n}\n\nint main() {\n    int limit = 20;\n    pythagoreanTriplets(limit);\n    return 0;\n} \n",
    "py": "def pythagoreanTriplets(limits) : \n    c, m = 0, 2\n    while c < limits : \n        for n in range(1, m) : \n            a = m * m - n * n \n            b = 2 * m * n \n            c = m * m + n * n \n            if c > limits : \n                break\n  \n            print(a, b, c) \n  \n        m = m + 1\n        \nlimit = 20\npythagoreanTriplets(limit) \n",
    "orden": 6,
    "suborden": 77,
    "fecha_creacion": "2020-12-05 01:56:14",
    "fecha_modificacion": "2022-03-08 12:01:47"
  },
  {
    "ID": 185,
    "supergrupo": "Matemática",
    "tema": "Horas posibles",
    "texto": "Dada una temporización de uno o dos dígitos, calcule las posibilidades de ocurrencia de otras temporizaciones (incluida la que brilla intensamente) con respecto a los segmentos brillantes, asumiendo que algunos segmentos pueden no estar brillantes.\nLa visualización de los números se realiza mediante una pantalla de siete segmentos. Se garantiza que los palos que se muestran actualmente funcionan bien.\n \nExamples:\nEntrada: 78\nSalida: 5\n\nEntrada: 05\nSalida: 8\nExplicación:\nEjemplo 1: 7 se puede reemplazar por 5 números diferentes 9, 3, 8, 0 y 7 (si ninguno de los segmentos está roto) y 8 se puede reemplazar por solo 1 número, es decir, el 8 en sí mismo (si ninguno de los segmentos está roto) , por lo tanto, la respuesta es 5 * 1 = 5.\nEjemplo 2: 0 se puede reemplazar por 2 números, 8 y 0, mientras que 5 se puede reemplazar por 4 números diferentes. Entonces, la respuesta es 4 * 2 = 8.\n\nAproximación :\nCalcule para cada número del 0 al 9 qué dígitos son posibles sumando o\nquitando exactamente una varilla de la pantalla. Almacene esto en una matriz y la respuesta será el producto del valor de la matriz de ambos dígitos de la entrada.\n",
    "complejidad_tiempo": null,
    "java": "// Programa Java para calcular posibles tiempos.\n\npublic class PossibleTimings {\n    // Array que almacena diferentes números de dígitos, \n    // un dígito en particular se puede reemplazar con\n\n    static int num[] = {2, 7, 2, 3, 3, 4, 2, 5, 1, 2};\n\n    public static void possibleTimings(String n) {\n        System.out.println(num[(n.charAt(0) - '0')]\n                * num[n.charAt(1) - '0']);\n    }\n\n    public static void main(String args[]) {\n        String n = \"05\";\n        possibleTimings(n);\n    }\n}\n",
    "cpp": "#include \"bits/stdc++.h\" \nusing namespace std;\n\nint num[] = {2, 7, 2, 3, 3, 4, 2, 5, 1, 2};\n\nvoid possibleTimings(string n) {\n    cout << (num[(n.at(0) - '0')]\n            * num[n.at(1) - '0']) << endl;\n}\n\nint main() {\n    string n = \"05\";\n    possibleTimings(n);\n}\n",
    "py": "num = [2, 7, 2, 3, 3, 4, 2, 5, 1, 2]\ndef possibleTimings(n):\n    print(num[(ord(n[0]) - ord('0'))] * num[ord(n[1]) - ord('0')]) \n\nn = \"05\"\npossibleTimings(n)\n",
    "orden": 6,
    "suborden": 78,
    "fecha_creacion": "2020-12-05 01:56:15",
    "fecha_modificacion": "2022-03-08 12:01:47"
  },
  {
    "ID": 186,
    "supergrupo": "Matemática",
    "tema": "Factorización prima",
    "texto": "Podemos calcular la factorización prima de un número \"n\" en O (sqrt (n)). Pero el método O (sqrt n) se agota cuando necesitamos responder múltiples consultas sobre factorización prima.\n\nConcepto clave: Nuestra idea es almacenar el factor primo más pequeño (SPF) para cada número. Luego, para calcular la factorización prima del número dado dividiendo el número dado de forma recursiva con su factor primo más pequeño hasta que se convierta en 1.\n\nPara calcular el factor primo más pequeño de cada número, usaremos el tamiz de eratóstenes. En la criba original, cada vez que marcamos un número como no primo, almacenamos el factor primo más pequeño correspondiente para ese número.\n\nAhora, después de que hayamos terminado de calcular previamente el factor primo más pequeño para cada número, dividiremos nuestro número n (cuya factorización prima se calculará) por su factor primo más pequeño correspondiente hasta que n se convierta en 1.\nPseudocódigo para factorización prima asumiendo que los SPF se calculan:\n\nPrimeFactors [] // Para almacenar el resultado\n\ni = 0 // Índice en PrimeFactors\n\nmientras que n! = 1:\n\n    // SPF: factor primo más pequeño\n    PrimeFactors [i] = SPF [n]\n    yo ++\n    n = n / SPF [n]\n\nNota: El código anterior funciona bien para n hasta el orden de 10 ^ 7. Más allá de esto, enfrentaremos problemas de memoria.\nComplejidad de tiempo: el cálculo previo para el factor primo más pequeño se realiza en O (n log log n) utilizando un tamiz. Donde, como en el paso de cálculo, estamos dividiendo el número cada vez por el número primo más pequeño hasta que se convierte en 1. Entonces, consideremos el peor de los casos en el que cada vez el SPF es 2. Por lo tanto, tendrá log n pasos de división. Por tanto, podemos decir que nuestra Complejidad de Tiempo será O (log n) en el peor de los casos.\n",
    "complejidad_tiempo": null,
    "java": "//Guarda en factors la lista de factores primos de n de menor a \n//mayor. IMPORTANTE: Debe ejecutarse primero Sieve of Eratosthenes \n//(al menos hasta un numero mayor a la raiz cuadrada de n).\n\nimport java.util.ArrayList;\n\npublic class PrimeFactorization {\n\n    static int MAX = 1000000;\n    static int SQRT = 1000;\n    static ArrayList<Integer> primes = new ArrayList<>();\n    static boolean marked[] = new boolean[MAX + 1];\n    static ArrayList<Integer> factors = new ArrayList<>();\n\n    public static void primeFactors(int n) {\n        factors.clear();\n        for (int i = 0, p = primes.get(i); p * p <= n; p = primes.get(++i)) {\n            while (n % p == 0) {\n                factors.add(p);\n                n /= p;\n            }\n        }\n        if (n > 1) {\n            factors.add(n);\n        }\n    }\n\n    static void sieve() {\n        marked[1] = true;\n        int i = 2;\n        for (; i <= SQRT; ++i) {\n            if (!marked[i]) {\n                primes.add(i);\n                for (int j = i * i; j <= MAX; j += i) {\n                    marked[j] = true;\n                }\n            }\n        }\n        for (; i <= MAX; ++i) {\n            if (!marked[i]) {\n                primes.add(i);\n            }\n        }\n    }\n\n    public static void main(String[] args) {\n        sieve();\n        primeFactors(100);\n        for (Integer i : factors) {\n            System.out.print(i + \" \");\n        }\n        System.out.println(\"\");\n    }\n}\n",
    "cpp": "#include <bits/stdc++.h> \nusing namespace std;\nint const MAX = 1000000;\nint SQRT = 1000;\nvector<int> primes;\nbool marked[MAX + 1];\nvector<int> factors;\n\nvoid primeFactors(int n) {\n    factors.clear();\n    for (int i = 0, p = primes[i]; p * p <= n; p = primes[++i]) {\n        while (n % p == 0) {\n            factors.emplace_back(p);\n            n /= p;\n        }\n    }\n    if (n > 1) {\n        factors.emplace_back(n);\n    }\n}\n\nvoid sieve() {\n    marked[1] = true;\n    int i = 2;\n    for (; i <= SQRT; ++i) {\n        if (!marked[i]) {\n            primes.emplace_back(i);\n            for (int j = i * i; j <= MAX; j += i) {\n                marked[j] = true;\n            }\n        }\n    }\n    for (; i <= MAX; ++i) {\n        if (!marked[i]) {\n            primes.emplace_back(i);\n        }\n    }\n}\n\nint main() {\n    sieve();\n    primeFactors(100);\n    for (int i : factors) {\n        cout << i << \" \";\n    }\n    cout << endl;\n}\n",
    "py": "import math\n \n\ndef primeFactors(n): \n        \n    while n % 2 == 0: \n        print 2, \n        n = n / 2\n    for i in range(3, int(math.sqrt(n)) + 1, 2): \n        while n % i == 0: \n            print i, \n            n = n / i \n                        \n    if n > 2: \n        print n \n                \n\n\nn = 100\nprimeFactors(n) \n",
    "orden": 6,
    "suborden": 79,
    "fecha_creacion": "2020-12-05 01:56:15",
    "fecha_modificacion": "2022-03-08 12:01:47"
  },
  {
    "ID": 187,
    "supergrupo": "Matemática",
    "tema": "Raiz primitiva",
    "texto": "Dado un número primo n, la tarea consiste en encontrar su raíz primitiva en módulo n. La raíz primitiva de un número primo n es un entero r entre [1, n-1] tal que los valores de r ^ x (mod n) donde x está en el rango [0, n-2] son diferentes. Devuelve -1 si n es un número no primo.\nEjemplos:\nEntrada: 7\nResultado: raíz primitiva más pequeña = 3\nExplicación: n = 7\n3 ^ 0 (mod 7) = 1\n3 ^ 1 (mod 7) = 3\n3 ^ 2 (mod 7) = 2\n3 ^ 3 (mod 7) = 6\n3 ^ 4 (mod 7) = 4\n3 ^ 5 (mod 7) = 5\n\nEntrada: 761\nResultado: raíz primitiva más pequeña = 6\nUna solución simple es probar todos los números del 2 al n-1. Para cada número r, calcule los valores de r ^ x (mod n) donde x está en el rango [0, n-2]. Si todos estos valores son diferentes, devuelva r, de lo contrario continúe con el siguiente valor de r. Si se prueban todos los valores de r, devuelve -1.\n\nUna solución eficiente se basa en el siguiente hecho.\nSi el orden multiplicativo de un número r módulo n es igual a la Función Totient de Euler Φ (n) (Note que la Función Totient de Euler para un primo n es n-1), entonces es una raíz primitiva.\n\n1- Función Totient de Euler phi = n-1 [Suponiendo que n es primo]\n1- Encuentra todos los factores primos de phi.\n2- Calcule todas las potencias para seguir calculando\n   usando (phi / factores primos) uno por uno.\n3- Compruebe todos los numerados para todas las potencias de i = 2\n   a n-1 es decir (i ^ potencias) módulo n.\n4- Si es 1, entonces 'i' no es una raíz primitiva de n.\n5- Si nunca es 1, devuelve i ;.\n\nAunque puede haber múltiples raíces primitivas para un número primo, solo nos preocupa el más pequeño. Si desea encontrar todas las raíces, continúe el proceso hasta p-1 en lugar de dividir al encontrar la primera raíz primitiva.\n",
    "complejidad_tiempo": null,
    "java": "// Programa Java para encontrar la raíz primitiva de un número n dado\n\nimport java.util.*;\n\npublic class PrimitiveRoot {\n\n    // Devuelve verdadero si n es primo\n    static boolean isPrime(int n) {\n        // casos esquina\n        if (n <= 1) {\n            return false;\n        }\n        if (n <= 3) {\n            return true;\n        }\n        // Esto está marcado para que podamos omitir los cinco \n        // números del medio en el ciclo inferior\n        if (n % 2 == 0 || n % 3 == 0) {\n            return false;\n        }\n\n        for (int i = 5; i * i <= n; i = i + 6) {\n            if (n % i == 0 || n % (i + 2) == 0) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n\n    /* Función iterativa para calcular (x ^ n)% p en O (logy) */\n    static int power(int x, int y, int p) {\n        int res = 1;     // Inicializar resultado\n\n        x = x % p; // Actualiza x si es mayor o igual que p\n\n        while (y > 0) {\n            // Si y es impar, multiplica x con el resultado\n            if (y % 2 == 1) {\n                res = (res * x) % p;\n            }\n\n            // y debe ser par ahora\n            y = y >> 1; // y = y/2 \n            x = (x * x) % p;\n        }\n        return res;\n    }\n\n    // Función de utilidad para almacenar factores primos de un número\n    static void findPrimefactors(HashSet<Integer> s, int n) {\n        // Imprime el número de 2 que dividen n \n        while (n % 2 == 0) {\n            s.add(2);\n            n = n / 2;\n        }\n\n        // n debe ser extraño en este punto. Entonces podemos \n        // omitir un elemento (Note i = i +2)\n        for (int i = 3; i <= Math.sqrt(n); i = i + 2) {\n            // Mientras yo divide n, imprime i y divide n\n            while (n % i == 0) {\n                s.add(i);\n                n = n / i;\n            }\n        }\n        // Esta condición es para manejar el caso \n        // cuando n es un número primo mayor que 2\n        if (n > 2) {\n            s.add(n);\n        }\n    }\n\n    // Función para encontrar la raíz primitiva más pequeña de n\n    static int findPrimitive(int n) {\n        HashSet<Integer> s = new HashSet<>();\n\n        // Compruebe si n es primo o no\n        if (isPrime(n) == false) {\n            return -1;\n        }\n\n        // Encuentre el valor de la función Euler Totient de n \n        // Dado que n es un número primo, el valor de la función Euler \n        // Totient es n-1 ya que hay n-1 números primos relativos.\n        int phi = n - 1;\n        // Encuentra factores primos de phi y guárdalos en un conjunto \n        findPrimefactors(s, phi);\n        // Compruebe todos los números del 2 al phi\n        for (int r = 2; r <= phi; r++) {\n            // Repita todos los factores primos de phi. \n            // y verificamos si encontramos una potencia con valor 1\n            boolean flag = false;\n            for (Integer a : s) {\n                // Compruebe si r ^ ((phi) / primefactors) mod n es 1 o no\n                if (power(r, phi / (a), n) == 1) {\n                    flag = true;\n                    break;\n                }\n            }\n\n            // Si no hubiera potencia con valor 1.\n            if (flag == false) {\n                return r;\n            }\n        }\n\n        // Si no se encuentra raíz primitiva\n        return -1;\n    }\n\n    public static void main(String[] args) {\n        int n = 761;\n        System.out.println(\" Smallest primitive root of \" + n\n                + \" is \" + findPrimitive(n));\n    }\n}\n",
    "cpp": "#include<bits/stdc++.h> \nusing namespace std;\n\nbool isPrime(int n) {\n\n    if (n <= 1) return false;\n    if (n <= 3) return true;\n    if (n % 2 == 0 || n % 3 == 0) return false;\n    for (int i = 5; i * i <= n; i = i + 6)\n        if (n % i == 0 || n % (i + 2) == 0)\n            return false;\n    return true;\n}\n\nint power(int x, unsigned int y, int p) {\n    int res = 1;\n    x = x % p;\n    while (y > 0) {\n        if (y & 1)\n            res = (res * x) % p;\n        y = y >> 1;\n        x = (x * x) % p;\n    }\n    return res;\n}\n\nvoid findPrimefactors(unordered_set<int> &s, int n) {\n\n    while (n % 2 == 0) {\n        s.insert(2);\n        n = n / 2;\n    }\n\n    for (int i = 3; i <= sqrt(n); i = i + 2) {\n        while (n % i == 0) {\n            s.insert(i);\n            n = n / i;\n        }\n    }\n    if (n > 2)\n        s.insert(n);\n}\n\nint findPrimitive(int n) {\n    unordered_set<int> s;\n    if (isPrime(n) == false)\n        return -1;\n    int phi = n - 1;\n    findPrimefactors(s, phi);\n    for (int r = 2; r <= phi; r++) {\n        bool flag = false;\n        for (auto it = s.begin(); it != s.end(); it++) {\n            if (power(r, phi / (*it), n) == 1) {\n                flag = true;\n                break;\n            }\n        }\n        if (flag == false)\n            return r;\n    }\n    return -1;\n}\n\nint main() {\n    int n = 761;\n    cout << \" Smallest primitive root of \" << n\n            << \" is \" << findPrimitive(n);\n    return 0;\n}\n",
    "py": "from math import sqrt\n \ndef isPrime(n): \n    if (n <= 1): \n        return False\n    if (n <= 3): \n        return True\n    if (n % 2 == 0 or n % 3 == 0): \n        return False\n    i = 5\n    while(i * i <= n): \n        if (n % i == 0 or n % (i + 2) == 0): \n            return False\n        i = i + 6\n    return True\n\ndef power(x, y, p): \n    res = 1 \n    x = x % p \n    while (y > 0): \n        if (y & 1): \n            res = (res * x) % p \n        y = y >> 1 \n        x = (x * x) % p \n    return res \n\ndef findPrimefactors(s, n): \n    while (n % 2 == 0): \n        s.add(2) \n        n = n // 2\n    for i in range(3, int(sqrt(n)), 2): \n        while (n % i == 0): \n            s.add(i) \n            n = n // i \n    if (n > 2): \n        s.add(n) \n\ndef findPrimitive(n): \n    s = set() \n    if (isPrime(n) == False): \n        return -1 \n    phi = n - 1\n    findPrimefactors(s, phi) \n    for r in range(2, phi + 1): \n\n        flag = False\n        for it in s: \n\n            if (power(r, phi // it, n) == 1): \n\n                flag = True\n                break\n                         \n        if (flag == False): \n            return r \n\n    return -1\n\nn = 761\nprint(\"Smallest primitive root of\", \n      n, \"is\", findPrimitive(n)) \n",
    "orden": 6,
    "suborden": 80,
    "fecha_creacion": "2020-12-05 01:56:15",
    "fecha_modificacion": "2022-03-08 12:03:39"
  },
  {
    "ID": 188,
    "supergrupo": "Matemática",
    "tema": "Series geométricas bajo condiciones ",
    "texto": "Una progresión geométrica es una secuencia de enteros b1, b2, b3,…, donde para cada i> 1, el término respectivo satisface la condición bi = bi-1 * q, donde q se llama la razón común de la progresión.\nDada la progresión geométrica b definida por dos enteros b1 y q, y m enteros \"malos\" a1, a2, .., am, y un entero l, escribe todos los términos de progresión uno por uno (incluido el repetitivo) while condición | bi | <= l está satisfecho (| x | significa valor absoluto de x).\n\n\nCalcule cuántos números habrá en nuestra secuencia, o imprima \"inf\" en el caso de infinitos números enteros.\nNota: Si un término es igual a uno de los números enteros “malos”, omítalo y avanza al siguiente término.\nEjemplos:\nEntrada: b1 = 3, q = 2, l = 30,\n        m = 4\n        6 14 25 48\nSalida: 3\nLa progresión será 3 12 24.\n6 también estará allí, pero porque\nes un número entero malo, no lo incluiremos\n\nEntrada: b1 = 123, q = 1, l = 2143435\n        m = 4\n        123 11 -5453 141245\nSalida: 0\nComo el valor de q es 1, la progresión\nsiempre será 123 y se volvería infinito\npero como es un número entero malo,\nno lo incluirá y por lo tanto nuestro valor\nse convertirá en 0\n\nEntrada: b1 = 123, q = 1, l = 2143435\n        m = 4\n        5234 11-5453 141245\nSalida: inf\nEn este caso, el valor será infinito\nporque la serie siempre será 123 como\nq es 1 y 123 no es un número entero incorrecto.\n\nAproximación:\nPodemos dividir nuestra solución en diferentes casos:\nCaso 1: si el valor inicial de la serie es mayor que el límite dado, la salida es 0.\nCaso 2: Si el valor inicial de la serie oq es 0, hay tres casos más:\nCaso 2.a: Si no se da 0 como un número entero incorrecto, la respuesta se convertirá en inf.\nCaso 2.b: Si b1! = 0 pero q es 0 y b1 tampoco es un número entero incorrecto, la respuesta será 1.\nCaso 2.c: Si 0 se da como un número entero incorrecto y b1 = 0, la respuesta será 0.\nCaso 3: Si q = 1 comprobaremos si b1 se da como un entero incorrecto o no. Si es así, la respuesta será 0; de lo contrario, la respuesta será inf.\nCaso 4: Si q = -1, verifique si b1 y -b1 están presentes o no, si están presentes nuestra respuesta será 0, de lo contrario nuestra respuesta será inf.\nCaso 5: Si ninguno de los casos anteriores se cumple, simplemente ejecute un ciclo para b1 hasta l y calcule el número de elementos.\n",
    "complejidad_tiempo": null,
    "java": "// Programa Java para encontrar el número de términos en series geométricas\n\nimport java.util.*;\n\npublic class TermsGeometricSerieswithConditions {\n\n    // Un mapa para realizar un seguimiento de los números enteros incorrectos\n    static HashMap<Integer, Boolean> map = new HashMap<>();\n\n    // Función para calcular el No. de elementos de nuestra serie\n    static void progression(int b1, int q, int l,\n            int m, int[] bad) {\n\n        // Actualización del valor de nuestro mapa\n        for (int i = 0; i < m; i++) {\n            map.put(bad[i], true);\n        }\n        // si el valor inicial es mayor que nuestro límite dado \n        if (Math.abs(b1) > l) {\n            System.out.print(\"0\");\n        } // si q o el valor inicial es 0\n        else if (q == 0 || b1 == 0) {\n            // si 0 no es un número entero incorrecto, \n            // la respuesta se convierte en inf\n            if (!map.containsKey(0)) {\n                System.out.print(\"inf\");\n            } // si q es 0 y b1 no lo es y b1\n            // no es un número entero malo, la respuesta se convierte en 1\n            else if (map.get(0) == true && !map.containsKey(b1)) {\n                System.out.print(\"1\");\n            } // de lo contrario, si 0 es un número entero incorrecto y b1 \n            // también es un número incorrecto, la respuesta se convierte en 0\n            else {\n                System.out.print(\"0\");\n            }\n        } // si q es 1\n        else if (q == 1) {\n            // y b1 no es un número entero incorrecto, \n            // la respuesta se convierte en inf\n            if (!map.containsKey(b1)) {\n                System.out.print(\"inf\");\n            } // si no, la respuesta es 0\n            else {\n                System.out.print(\"0\");\n            }\n\n        } // si q es -1\n        else if (q == -1) {\n            // y b1 o -b1 no está presente la respuesta se convierte en inf\n            if (!map.containsKey(b1) || !map.containsKey(-1 * b1)) {\n                System.out.print(\"inf\");\n            } // si no, la respuesta se convierte en 0\n            else {\n                System.out.print(\"0\");\n            }\n\n        } // si ninguno de los casos anteriores es cierto, \n        // simplemente calcule el número de elementos en nuestra serie\n        else {\n            int co = 0;\n            while (Math.abs(b1) <= l) {\n                if (!map.containsKey(b1)) {\n                    co++;\n                }\n                b1 *= q;\n            }\n            System.out.print(co);\n        }\n    }\n\n    public static void main(String[] args) {\n        // valor inicial de la serie, número a multiplicar, límite dentro del\n        // cual nuestra serie, número de enteros incorrectos dado\n        int b1 = 3, q = 2, l = 30, m = 4;\n\n        // Enteros malos\n        int[] bad = {6, 14, 25, 48};\n\n        progression(b1, q, l, m, bad);\n    }\n}\n",
    "cpp": "#include <bits/stdc++.h> \nusing namespace std;\n\nmap<int, bool> mapp;\n\nvoid progression(int b1, int q, int l, int m, int bad[]) {\n\n    for (int i = 0; i < m; i++)\n        mapp[bad[i]] = 1;\n    if (abs(b1) > l)\n        cout << \"0\";\n\n    else if (q == 0 || b1 == 0) {\n        if (mapp[0] != 1)\n            cout << \"inf\";\n        else if (mapp[0] == 1 && mapp[b1] != 1)\n            cout << \"1\";\n\n        else\n            cout << \"0\";\n    } else if (q == 1) {\n\n        if (mapp[b1] != 1)\n            cout << \"inf\";\n        else\n            cout << \"0\";\n    } else if (q == -1) {\n\n        if (mapp[b1] != 1 || mapp[-1 * b1] != 1)\n            cout << \"inf\";\n        else\n            cout << \"0\";\n    } else {\n        int co = 0;\n        while (abs(b1) <= l) {\n            if (mapp[b1] != 1)\n                co++;\n            b1 *= 1LL * q;\n        }\n        cout << co;\n    }\n}\n\nint main() {\n    int b1 = 3, q = 2, l = 30, m = 4;\n    int bad[4] = {6, 14, 25, 48};\n    progression(b1, q, l, m, bad);\n    return 0;\n} \n",
    "py": "mpp = dict() \n  \ndef progression(b1, q, l, m, bad): \n    for i in range(m): \n        mpp[bad[i]] = 1\n    if (abs(b1) > l): \n        print(\"0\", end=\"\") \n    elif (q == 0 or b1 == 0): \n        if (0 not in mpp.keys()): \n            print(\"inf\", end=\"\") \n        elif (mpp[0] == 1 and b1 not in mpp.keys()): \n            print(\"1\", end=\"\") \n        else: \n            print(\"0\", end=\"\") \n    elif (q == 1): \n        if (b1 not in mpp.keys()): \n            print(\"inf\", end=\"\") \n        else: # else answer is 0 \n            print(\"0\", end=\"\") \n  \n    elif (q == -1): \n        if (b1 not in mpp.keys() or -1 * b1 not in mpp.keys()): \n            print(\"inf\", end=\"\") \n        else:\n            print(\"0\", end=\"\") \n    else:\n        co = 0\n        while (abs(b1) <= l): \n            if (b1 not in mpp.keys()): \n                co += 1\n            b1 *= q \n        print(co, end=\"\") \n  \n  \n\nb1 = 3\nq = 2\nl = 30\nm = 4\n  \nbad = [6, 14, 25, 48] \nprogression(b1, q, l, m, bad) \n",
    "orden": 6,
    "suborden": 81,
    "fecha_creacion": "2020-12-05 01:56:16",
    "fecha_modificacion": "2022-03-08 12:03:39"
  },
  {
    "ID": 189,
    "supergrupo": "Matemática",
    "tema": "Verificando si existe una progresión geométrica",
    "texto": "Una secuencia de números se llama progresión geométrica si la razón de dos términos consecutivos es siempre la misma. En términos simples, significa que el siguiente número de la serie se calcula multiplicando un número fijo por el número anterior de la serie. Por ejemplo, 2, 4, 8, 16 es un GP porque la proporción de dos términos consecutivos cualesquiera de la serie (diferencia común) es el mismo (4/2 = 8/4 = 16/8 = 2).\n \nHechos sobre la progresión geométrica:\n1. Término inicial: en una progresión geométrica, el primer número se llama término inicial.\n2. Razón común: la razón entre un término en la secuencia y el término anterior se denomina \"razón común\".\n3. El comportamiento de una secuencia geométrica depende del valor de la razón común. Si la razón común es:\n• Positiva, todos los términos tendrán el mismo signo que el término inicial.\n• Negativa, los términos se alternarán entre positivo y negativo.\n• Mayor que 1, habrá un crecimiento exponencial hacia el infinito positivo o negativo (según el signo del término inicial).\n• 1, la progresión es una secuencia constante.\n• Entre -1 y 1 pero no cero, habrá una caída exponencial hacia cero.\n• -1, la progresión es una secuencia alterna.\n• Menos de -1, para los valores absolutos hay un crecimiento exponencial hacia el infinito (sin signo), debido al signo alterno.\nFórmula del enésimo término de una progresión geométrica:\nSi \"a\" es el primer término y \"r\" es la razón común, la fórmula explícita es\n\n\n¿Cómo comprobamos si una serie es progresión geométrica o no?\nEncontremos la razón de los términos consecutivos, por lo que podemos decir que la razón de los términos consecutivos de las secuencias dadas es 13 o una constante. Entonces esta secuencia está formando una progresión geométrica.\n",
    "complejidad_tiempo": null,
    "java": "// Programa Java para verificar si una matriz \n// determinada puede formar una progresión geométrica\n\npublic class IsGeometricProgression {\n\n    // función para comprobar que la serie es progresión geométrica o no\n    static boolean is_geometric(int arr[], int n) {\n        if (n == 1) {\n            return true;\n        }\n\n        // Calcular la proporción\n        int ratio = arr[1] / (arr[0]);\n\n        //Compruebe la proporción de los restantes\n        for (int i = 1; i < n; i++) {\n            if ((arr[i] / (arr[i - 1])) != ratio) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    public static void main(String[] args) {\n        int arr[] = {2, 6, 18, 54};\n        int n = arr.length;\n\n        if (is_geometric(arr, n)) {\n            System.out.println(\"True\");\n        } else {\n            System.out.println(\"False\");\n        }\n    }\n}\n",
    "cpp": "#include <bits/stdc++.h> \nusing namespace std;\n\nbool is_geometric(int arr[], int n) {\n    if (n == 1)\n        return true;\n\n    int ratio = arr[1] / (arr[0]);\n\n    for (int i = 1; i < n; i++) {\n        if ((arr[i] / (arr[i - 1])) != ratio) {\n            return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    int arr[] = {2, 6, 18, 54};\n    int n = sizeof (arr) / sizeof (arr[0]);\n\n    (is_geometric(arr, n)) ? (cout << \"True\" << endl) : (cout << \"False\" << endl);\n\n    return 0;\n} \n",
    "py": "def is_geometric(li): \n    if len(li) <= 1: \n        return True\n    ratio = li[1]/float(li[0]) \n     \n    for i in range(1, len(li)): \n        if li[i]/float(li[i-1]) != ratio:  \n            return False\n    return True\n  \nprint(is_geometric([2, 6, 18, 54])) \n",
    "orden": 6,
    "suborden": 82,
    "fecha_creacion": "2020-12-05 01:56:16",
    "fecha_modificacion": "2022-03-08 12:03:39"
  },
  {
    "ID": 190,
    "supergrupo": "Matemática",
    "tema": "Subsecuencias únicas de tamaño k",
    "texto": "Dada un array de N números y un entero K. La tarea es imprimir el número de subsecuencias únicas posibles de longitud K.\nEjemplos:\nEntrada: a [] = {1, 2, 3, 4}, k = 3\nSalida: 4.\nLas subsecuencias únicas son:\n{1, 2, 3}, {1, 2, 4}, {1, 3, 4}, {2, 3, 4}\n\nEntrada: a [] = {1, 1, 1, 2, 2, 2}, k = 3\nSalida: 4\nLas subsecuencias únicas son\n{1, 1, 1}, {1, 1, 2}, {1, 2, 2}, {2, 2, 2}\n\nEnfoque: Existe una fórmula bien conocida de cuántas subsecuencias de longitud fija K se pueden elegir entre N objetos únicos. Pero el problema aquí tiene varias diferencias. Uno de ellos es que el orden en las subsecuencias es importante y debe conservarse como en la secuencia original. Para tal problema, no puede haber una fórmula combinatoria lista porque los resultados dependen del orden de la matriz original.\nLa idea principal es tratar de forma recurrente la longitud de la subsecuencia. En cada paso recurrente, muévase del final al principio y cuente las combinaciones únicas usando el recuento de combinaciones únicas más cortas del paso anterior. Más estrictamente en cada paso j, mantenemos un array de longitud N y cada elemento en el lugar p significa cuántas subsecuencias únicas con longitud j encontramos a la derecha del elemento en el lugar i, incluido el propio i.\n",
    "complejidad_tiempo": null,
    "java": "import java.util.*;\n\npublic class UniqueSubsequencesklength {\n\n// Function which returns the numbe of\n// unique subsequences of length K\n    static int solution(int[] A, int N, int k) {\n\n        // Bases cases\n        if (N < k || N < 1 || k < 1) {\n            return 0;\n        }\n        if (N == k) {\n            return 1;\n        }\n\n        // Prepare arrays for recursion\n        int[] v1 = new int[N];\n        int[] v2 = new int[N];\n        int[] v3 = new int[N];\n\n        // Initiate separately for k = 1\n        // intiate the last element\n        v2[N - 1] = 1;\n        v3[A[N - 1] - 1] = 1;\n\n        // Initiate all other elements of k = 1\n        for (int i = N - 2; i >= 0; i--) {\n\n            // Initialize the front element\n            // to vector v2\n            v2[i] = v2[i + 1];\n\n            // If element v[a[i]-1] is 0\n            // then increment it in vector v2\n            if (v3[A[i] - 1] == 0) {\n                v2[i]++;\n                v3[A[i] - 1] = 1;\n            }\n        }\n\n        // Iterate for all possible values of K\n        for (int j = 1; j < k; j++) {\n\n            // Fill the vectors with 0\n            Arrays.fill(v3, 0);\n\n            // Fill(v1.begin(), v1.end(), 0)\n            // the last must be 0 as from last\n            // no unique subarray can be formed\n            v1[N - 1] = 0;\n\n            // Iterate for all index from which \n            // unique subsequences can be formed\n            for (int i = N - 2; i >= 0; i--) {\n\n                // Add the number of subsequence \n                // formed from the next index\n                v1[i] = v1[i + 1];\n\n                // Start with combinations on the\n                // next index\n                v1[i] = v1[i] + v2[i + 1];\n\n                // Remove the elements which have\n                // already been counted\n                v1[i] = v1[i] - v3[A[i] - 1];\n\n                // Update the number used\n                v3[A[i] - 1] = v2[i + 1];\n            }\n        }\n\n        // Last answer is stored in v2\n        return v2[0];\n    }\n\n// Driver Code\n    public static void main(String[] args) {\n        int a[] = {1, 2, 3, 4};\n        int n = a.length;\n        int k = 3;\n\n        System.out.print(solution(a, n, k));\n    }\n}\n",
    "cpp": "#include <bits/stdc++.h> \nusing namespace std;\n\nint solution(vector<int>& A, int k) {\n    const int N = A.size();\n    if (N < k || N < 1 || k < 1)\n        return 0;\n    if (N == k)\n        return 1;\n\n    vector<int> v1(N, 0);\n    vector<int> v2(N, 0);\n    vector<int> v3(N, 0);\n\n    v2[N - 1] = 1;\n    v3[A[N - 1] - 1] = 1;\n\n    for (int i = N - 2; i >= 0; i--) {\n\n        v2[i] = v2[i + 1];\n        if (v3[A[i] - 1] == 0) {\n            v2[i]++;\n            v3[A[i] - 1] = 1;\n        }\n    }\n\n    for (int j = 1; j < k; j++) {\n\n        fill(v3.begin(), v3.end(), 0);\n        v1[N - 1] = 0;\n\n        for (int i = N - 2; i >= 0; i--) {\n\n            v1[i] = v1[i + 1];\n            v1[i] = v1[i] + v2[i + 1];\n            v1[i] = v1[i] - v3[A[i] - 1];\n            v3[A[i] - 1] = v2[i + 1];\n        }\n        v2 = v1;\n    }\n    return v2[0];\n}\n\nvoid solve(int a[], int n, int k) {\n    vector<int> v;\n    v.assign(a, a + n);\n    cout << solution(v, k);\n}\n\nint main() {\n    int a[] = {1, 2, 3, 4};\n    int n = sizeof (a) / sizeof (a[0]);\n    int k = 3;\n    solve(a, n, k);\n\n    return 0;\n} \n",
    "py": "def solution(A, k):\n\n    N = len(A)\n    if (N < k or N < 1 or k < 1):\n        return 0\n    if (N == k):\n        return 1\n    v1 = [0] * (N)\n    v2 = [0] * N\n    v3 = [0] * N\n    v2[N - 1] = 1\n    v3[A[N - 1] - 1] = 1\n\n    for i in range(N - 2, -1, -1):\n        v2[i] = v2[i + 1]\n        if (v3[A[i] - 1] == 0):\n            v2[i] += 1\n            v3[A[i] - 1] = 1\n                \n    for j in range(1, k):\n        v3 = [0] * N\n        v1[N - 1] = 0\n        for i in range(N - 2, -1, -1):\n            v1[i] = v1[i + 1]\n            v1[i] = v1[i] + v2[i + 1]\n            v1[i] = v1[i] - v3[A[i] - 1]\n            v3[A[i] - 1] = v2[i + 1]\n        \n        for i in range(len(v1)):\n            v2[i] = v1[i]\n        \n    return v2[0]\n\ndef solve(a, n, k):\n    v = a\n    print(solution(v, k))\n\n\na = [1, 2, 3, 4]\nn = len(a)\nk = 3\nsolve(a, n, k)\n",
    "orden": 6,
    "suborden": 83,
    "fecha_creacion": "2020-12-05 01:56:16",
    "fecha_modificacion": "2022-03-08 12:03:39"
  },
  {
    "ID": 191,
    "supergrupo": "Matemática",
    "tema": "Bisección",
    "texto": "* f (b) <0 yf (x) es continua en [a, b]. Aquí f (x) representa una ecuación algebraica o trascendental. Encuentre la raíz de la función en el intervalo [a, b] (O encuentre un valor de x tal que f (x) sea 0).\nEjemplo:\nEntrada: una función de x, por ejemplo x3 - x2 + 2.\n       Y dos valores: a = -200 yb = 300 tales que\n       f (a) * f (b) <0, es decir, f (a) yf (b) tienen\n       signos opuestos.\nSalida: El valor de la raíz es: -1,0025\n        O cualquier otro valor con permitido\n        desviación de la raíz.\n¿Qué son las funciones algebraicas y trascendentales?\nLa función algebraica es aquella que se puede representar en forma de polinomios como f (x) = a1x3 + a2x2 +… .. + e donde aa1, a2,… son constantes yx es una variable.\nLas funciones trascendentales son funciones no algebraicas, por ejemplo f (x) = sin (x) * x - 3 o f (x) = ex + x2 o f (x) = ln (x) + x….\n¿Qué es el método de bisección?\nEl método también se denomina método de reducción a la mitad del intervalo, método de búsqueda binaria o método de dicotomía. Este método se usa para encontrar la raíz de una ecuación en un intervalo dado que es el valor de \"x\" para el cual f (x) = 0.\nEl método se basa en el Teorema del valor intermedio que establece que si f (x) es una función continua y hay dos números reales ayb tales que f (a) * f (b) 0 yf (b) <0) , entonces se garantiza que tiene al menos una raíz entre ellos.\nSupuestos:\n\n1. f (x) es una función continua en el intervalo [a, b]\n2. f (a) * f (b) <0\nPasos:\n1. Encuentre el punto medio c = (a + b) / 2.\n2. Si f (c) == 0, entonces c es la raíz de la solución.\n3. De lo contrario, f (c)! = 0\n1. Si el valor f (a) * f (c) <0, la raíz se encuentra entre ay c. Entonces recurrimos para ayc\n2. De lo contrario Si f (b) * f (c) <0, entonces la raíz se encuentra entre by c. Entonces recurrimos by c.\n3. La otra función dada no sigue uno de los supuestos.\nDado que la raíz puede ser un número de punto flotante, repetimos los pasos anteriores mientras que la diferencia entre ayb es menor que un valor. (Un valor muy pequeño).\n \nComplejidad temporal: - La complejidad temporal de este método depende de los valores asumidos y de la función.\n¿Cuáles son los pros y los contras?\nLa ventaja del método de bisección es que se garantiza que convergerá. La desventaja del método de bisección es que no puede detectar múltiples raíces.\nEn general, el método de bisección se utiliza para obtener una aproximación inicial aproximada de la solución. Luego, se utilizan métodos convergentes más rápidos para encontrar la solución.\n",
    "complejidad_tiempo": null,
    "java": "// Programa Java para la implementación del método de \n// bisección para resolver ecuaciones\n\npublic class Bisection {\n\n    static final float EPSILON = (float) 0.01;\n\n    // Una función de ejemplo cuya solución se determina mediante el método de\n    // bisección. La función es x ^ 3 - x ^ 2 + 2\n    static double func(double x) {\n        return x * x * x - x * x + 2;\n    }\n\n    // Imprime la raíz de func (x) con error de EPSILON\n    static void bisection(double a, double b) {\n        if (func(a) * func(b) >= 0) {\n            System.out.println(\"You have not assumed\"\n                    + \" right a and b\");\n            return;\n        }\n        double c = a;\n        while ((b - a) >= EPSILON) {\n            // Encuentra el punto medio\n            c = (a + b) / 2;\n\n            // Compruebe si el punto medio es la raíz\n            if (func(c) == 0.0) {\n                break;\n            } // Decide el lado para repetir los pasos\n            else if (func(c) * func(a) < 0) {\n                b = c;\n            } else {\n                a = c;\n            }\n        }\n        //imprime el valor de c hasta 4 lugares decimales\n        System.out.printf(\"The value of root is : %.4f\",\n                c);\n    }\n\n    public static void main(String[] args) {\n        // Valores iniciales asumidos\n        double a = -200, b = 300;\n        bisection(a, b);\n    }\n}\n",
    "cpp": "#include<bits/stdc++.h> \nusing namespace std;\n#define EPSILON 0.01 \n\ndouble func(double x) {\n    return x * x * x - x * x + 2;\n}\n\nvoid bisection(double a, double b) {\n    if (func(a) * func(b) >= 0) {\n        cout << \"You have not assumed right a and b\\n\";\n        return;\n    }\n\n    double c = a;\n    while ((b - a) >= EPSILON) {\n        c = (a + b) / 2;\n\n        if (func(c) == 0.0)\n            break;\n\n        else if (func(c) * func(a) < 0)\n            b = c;\n        else\n            a = c;\n    }\n    cout << \"The value of root is : \" << c;\n}\n\nint main() {\n    double a = -200, b = 300;\n    bisection(a, b);\n    return 0;\n} \n",
    "py": "def func(x): \n    return x * x * x - x * x + 2\n   \ndef bisection(a, b): \n  \n    if (func(a) * func(b) >= 0): \n        print(\"You have not assumed right a and b\\n\") \n        return\n   \n    c = a \n    while ((b-a) >= 0.01): \n        c = (a + b) / 2\n        if (func(c) == 0.0): \n            break\n  \n        if (func(c) * func(a) < 0): \n            b = c \n        else: \n            a = c \n              \n    print(\"The value of root is : \", \"%.4f\" % c) \n      \n\na = -200\nb = 300\nbisection(a, b) \n",
    "orden": 6,
    "suborden": 84,
    "fecha_creacion": "2020-12-05 01:56:17",
    "fecha_modificacion": "2022-03-08 12:03:39"
  },
  {
    "ID": 192,
    "supergrupo": "Matemática",
    "tema": "Interpolación de LaGrange",
    "texto": "¿Qué es la interpolación?\nLa interpolación es un método para encontrar nuevos puntos de datos dentro del rango de un conjunto discreto de puntos de datos conocidos. En otras palabras, la interpolación es la técnica para estimar el valor de una función matemática, para cualquier valor intermedio de la variable independiente.\nPor ejemplo, en la tabla dada se nos dan 4 conjuntos de puntos de datos discretos, para una función desconocida f (x):\n \n¿Como encontrarlo?\nAquí podemos aplicar la fórmula de interpolación de Lagrange para obtener nuestra solución.\nLa fórmula de interpolación de Lagrange:\nSi, y = f (x) toma los valores y0, y1,…, yn correspondientes ax = x0, x1,…, xn entonces, \nEste método se prefiere sobre sus contrapartes como el método de Newton porque es aplicable incluso para valores de x desigualmente espaciados.\nPodemos usar técnicas de interpolación para encontrar un punto de datos intermedio, digamos en x = 3.\nComplejidad:\nLa complejidad temporal de la solución anterior es O (n2) y el espacio auxiliar es O (1).\n",
    "complejidad_tiempo": null,
    "java": "// Programa Java para la implementación de la interpolación de Lagrange\n\npublic class LagrangeInterpolation {\n\n    // Para representar un punto de datos correspondiente ax e y = f (x)\n    static class Data {\n\n        int x, y;\n\n        public Data(int x, int y) {\n            super();\n            this.x = x;\n            this.y = y;\n        }\n\n    };\n\n    // función para interpolar los puntos de datos dados utilizando \n    // la fórmula de Lagrange xi corresponde al nuevo punto de datos cuyo\n    // valor se va a obtener n representa el número de puntos de datos conocidos \n    static double interpolate(Data f[], int xi, int n) {\n        double result = 0; // Initialize result \n\n        for (int i = 0; i < n; i++) {\n            //Calcule los términos individuales de la fórmula anterior\n            double term = f[i].y;\n            for (int j = 0; j < n; j++) {\n                if (j != i) {\n                    term = term * (xi - f[j].x) / (f[i].x - f[j].x);\n                }\n            }\n\n            // Agregar término actual al resultado\n            result += term;\n        }\n\n        return result;\n    }\n\n    public static void main(String[] args) {\n        // Agregar término actual al resultado\n        Data f[] = {new Data(0, 2), new Data(1, 3),\n            new Data(2, 12), new Data(5, 147)};\n\n        // Usando la función de interpolación para \n        // obtener un punto de datos correspondiente ax = 3\n        System.out.print(\"Value of f(3) is : \"\n                + (int) interpolate(f, 3, 4));\n    }\n}\n",
    "cpp": "#include<bits/stdc++.h> \nusing namespace std;\n\nstruct Data {\n    int x, y;\n};\n\ndouble interpolate(Data f[], int xi, int n) {\n    double result = 0;\n    for (int i = 0; i < n; i++) {\n        double term = f[i].y;\n        for (int j = 0; j < n; j++) {\n            if (j != i)\n                term = term * (xi - f[j].x) / double(f[i].x - f[j].x);\n        }\n        result += term;\n    }\n\n    return result;\n}\n\nint main() {\n    Data f[] = {\n        {0, 2},\n        {1, 3},\n        {2, 12},\n        {5, 147}\n    };\n    cout << \"Value of f(3) is : \" << interpolate(f, 3, 5);\n    return 0;\n} \n",
    "py": "class Data: \n    def __init__(self, x, y): \n        self.x = x \n        self.y = y \n  \n\ndef interpolate(f, xi, n): \n    result = 0.0\n    for i in range(n): \n        term = f[i].y \n        for j in range(n): \n            if j != i: \n                term = term * (xi - f[j].x) / (f[i].x - f[j].x) \n        result += term \n  \n    return result \nf = [Data(0, 2), Data(1, 3), Data(2, 12), Data(5, 147)] \n\nprint(\"Value of f(3) is :\", interpolate(f, 3, 4))\n\n",
    "orden": 6,
    "suborden": 85,
    "fecha_creacion": "2020-12-05 01:56:17",
    "fecha_modificacion": "2022-03-08 12:05:45"
  },
  {
    "ID": 193,
    "supergrupo": "Matemática",
    "tema": "Interpolación inversa de LaGrange",
    "texto": "La tarea dada es encontrar el valor de x para una y dada de una función desconocida y = f (x) donde se dan los valores de algunos pares de puntos (x, y).\nEl proceso de encontrar el valor de la variable independiente x para un valor dado de y que se encuentra entre dos valores tabulados con la ayuda del conjunto dado de observación para una función desconocida se conoce como interpolación inversa.\nEsto se usa a menudo para verificar si la exactitud de la salida y para una función desconocida, es decir, cuánto argumento x para esta salida y difiere de la entrada original.\nEste método se puede utilizar incluso cuando los puntos están espaciados de forma desigual. Aquí x se expresa en función de y.\nEjemplos:\nEntrada: Encuentre el valor de x donde y = 4.5 y los puntos dados son \nSalida: 2.79501\nExplicación: Aquí el número de puntos de datos dados = 4 e y = 4.5\nEntonces, poniendo los valores de todo xey en la fórmula de interpolación inversa dada anteriormente obtenemos,\n\n \nDe aquí obtenemos,\nEl valor de x = 2.79501 donde el valor de y = 4.5\n \nAlgoritmo:\nAquí, los datos son una lista de puntos que consta de xey y n es el número de puntos de datos.\nPASO - 1: Inicializar el valor final x = 0\nPASO - 2: PARA i = 1 an do\n     PASO - 3: Inicializar xi = datos [i] .x\n     PASO - 4: PARA j = 1 an hacer\n         PASO - 5: SI i! = J hago\n             PASO - 6: Multiplica xi por (y - dato [j] .y) y divide por (dato [i] .y - dato [j] .y)\n         TERMINARA SI\n     ENDFOR\n     PASO - 7: Suma xi a x\nENDFOR\nPASO - 8: Devuelve el valor final de x\nPASO - 9: FIN\n",
    "complejidad_tiempo": null,
    "java": "// Código Java para resolver interpolación inversa\n\npublic class InvLagrangeInterpolation {\n\n    // Considere una estructura para mantener juntos cada par de xey\n    static class Data {\n\n        double x, y;\n\n        public Data(double x, double y) {\n            super();\n            this.x = x;\n            this.y = y;\n        }\n\n    };\n\n    // Función para calcular la interpolación inversa\n    static double inv_interpolate(Data[] d, int n, double y) {\n        // Inicializar x final\n        double x = 0;\n        int i, j;\n        for (i = 0; i < n; i++) {\n            // Calcula cada término de la fórmula dada\n            double xi = d[i].x;\n            for (j = 0; j < n; j++) {\n\n                if (j != i) {\n                    xi = xi * (y - d[j].y) / (d[i].y - d[j].y);\n                }\n            }\n\n            //Agregar término al resultado final\n            x += xi;\n        }\n        return x;\n    }\n\n    public static void main(String[] args) {\n\n        // Conjunto de datos de muestra de 4 \n        // puntos Aquí encontramos el valor de x cuando y = 4.5\n        Data[] d = {new Data(1.27, 2.3),\n            new Data(2.25, 2.95),\n            new Data(2.5, 3.5),\n            new Data(3.6, 5.1)};\n\n        // Tamaño del conjunto de datos\n        int n = 4;\n\n        // Valor de muestra y\n        double y = 4.5;\n\n        // Usar la función de interpolación inversa \n        // para encontrar el valor de x cuando y = 4.5\n        System.out.printf(\"Value of x at y = 4.5 : %.5f\",\n                inv_interpolate(d, n, y));\n    }\n}\n",
    "cpp": "#include <bits/stdc++.h> \nusing namespace std;\n\nstruct Data {\n    double x, y;\n};\n\ndouble inv_interpolate(Data d[], int n, double y) {\n    double x = 0;\n    int i, j;\n    for (i = 0; i < n; i++) {\n        double xi = d[i].x;\n        for (j = 0; j < n; j++) {\n            if (j != i) {\n                xi = xi * (y - d[j].y) / (d[i].y - d[j].y);\n            }\n        }\n        x += xi;\n    }\n\n    return x;\n}\n\nint main() {\n    Data d[] = {\n        { 1.27, 2.3},\n        { 2.25, 2.95},\n        { 2.5, 3.5},\n        { 3.6, 5.1}\n    };\n\n    int n = 4;\n    double y = 4.5;\n    cout << \"Value of x at y = 4.5 : \"\n            << inv_interpolate(d, n, y);\n    return 0;\n} \n",
    "py": "class Data: \n    def __init__(self, x, y): \n        self.x = x \n        self.y = y \n  \n\ndef inv_interpolate(d, n,  y) : \n    x = 0\n    for i in range(n): \n        xi = d[i].x \n        for j in range(n): \n            if j != i: \n                xi = (xi * (y - d[j].y) / \n                      (d[i].y - d[j].y)) \n        x += xi \n    return x \nd = [Data(1.27, 2.3),  \n     Data(2.25, 2.95),  \n     Data(2.5, 3.5),  \n     Data(3.6, 5.1)] \n\nn = 4\ny = 4.5\nprint(\"Value of x at y = 4.5 :\",  \n       round(inv_interpolate(d, n, y), 5)) \n",
    "orden": 6,
    "suborden": 86,
    "fecha_creacion": "2020-12-05 01:56:17",
    "fecha_modificacion": "2022-03-08 12:05:45"
  },
  {
    "ID": 194,
    "supergrupo": "Matemática",
    "tema": "Raiz mediante Newton",
    "texto": "Dado un número entero N y un nivel de tolerancia L, la tarea es encontrar la raíz cuadrada de ese número usando el método de Newton.\nEjemplos:\nEntrada: N = 16, L = 0.0001\nSalida: 4\n42 = 16\nEntrada: N = 327, L = 0.00001\nSalida: 18.0831\n\nMétodo de Newton:\nSea N cualquier número, entonces la raíz cuadrada de N puede estar dada por la fórmula:\n\nroot = 0.5 * (X + (N / X)) donde X es cualquier conjetura que se puede suponer que es N o 1.\n• En la fórmula anterior, X es cualquier raíz cuadrada asumida de N y raíz es la raíz cuadrada correcta de N.\n• El límite de tolerancia es la diferencia máxima entre X y la raíz permitida.\nEnfoque: se pueden seguir los siguientes pasos para calcular la respuesta:\n1. Asigne X a la propia N.\n2. Ahora, inicie un ciclo y siga calculando la raíz que seguramente se moverá hacia la raíz cuadrada correcta de N.\n3. Verifique la diferencia entre la X supuesta y la raíz calculada, si aún no está dentro de la tolerancia, actualice la raíz y continúe.\n4. Si la raíz calculada entra dentro de la tolerancia permitida, salga del ciclo.\n5. Imprima la raíz.\n",
    "complejidad_tiempo": null,
    "java": "// Implementación Java de la raíz cuadrada de Newton\n\npublic class NewtonSquareRoot {\n\n    // Función para devolver la raíz cuadrada de un número usando el método de Newton\n    static double squareRoot(double n, double l) {\n        // Suponiendo la sqrt de n como n solamente\n        double x = n;\n\n        // La conjetura cerrada se almacenará en la raíz.\n        double root;\n\n        // Para contar el número de iteraciones\n        int count = 0;\n\n        while (true) {\n            count++;\n\n            // Calcular más cerrado x\n            root = 0.5 * (x + (n / x));\n\n            // Compruebe la cercanía\n            if (Math.abs(root - x) < l) {\n                break;\n            }\n\n            // Actualizar root\n            x = root;\n        }\n\n        return root;\n    }\n\n    public static void main(String[] args) {\n        double n = 327;\n        double l = 0.00001;\n\n        System.out.println(squareRoot(n, l));\n    }\n}\n",
    "cpp": "#include <bits/stdc++.h> \nusing namespace std;\n\ndouble squareRoot(double n, float l) {\n    double x = n;\n    double root;\n    int count = 0;\n\n    while (1) {\n        count++;\n        root = 0.5 * (x + (n / x));\n        if (abs(root - x) < l)\n            break;\n        x = root;\n    }\n\n    return root;\n}\n\nint main() {\n    double n = 327;\n    float l = 0.00001;\n    cout << squareRoot(n, l);\n    return 0;\n} \n",
    "py": "def squareRoot(n, l):  \n    x = n  \n    count = 0 \n    while (1): \n        count += 1 \n        root = 0.5 * (x + (n / x))  \n        if (abs(root - x) < l): \n            break \n        x = root \n  \n    return root  \n  \nn = 327\nl = 0.00001 \nprint(squareRoot(n, l))  \n",
    "orden": 6,
    "suborden": 87,
    "fecha_creacion": "2020-12-05 01:56:18",
    "fecha_modificacion": "2022-03-08 12:05:45"
  },
  {
    "ID": 195,
    "supergrupo": "Matemática",
    "tema": "Raiz mediante Newton Raphson ",
    "texto": "Dada una función f (x) en un número flotante x y una estimación inicial de la raíz, encuentre la raíz de la función en el intervalo. Aquí f (x) representa una ecuación algebraica o trascendental.\nPara simplificar, hemos asumido que la derivada de la función también se proporciona como entrada.\nEjemplo:\nEntrada: una función de x (por ejemplo, x3 - x2 + 2),\n       función derivada de x (3x2 - 2x para el ejemplo anterior)\n       y una suposición inicial x0 = -20\nSalida: El valor de la raíz es: -1,00\n        O cualquier otro valor cercano a la raíz.\n\nEl método de bisección vs el método de posición falsa\nComparación con los dos métodos anteriores:\n\n1. En los métodos anteriores, se nos dio un intervalo. Aquí se requiere un valor aproximado inicial de raíz.\n2. Se garantiza que los dos métodos anteriores convergerán, Newton Rahhson puede no converger en algunos casos.\n3. El método de Newton Raphson requiere derivada. Algunas funciones pueden resultar difíciles de\nimposible de diferenciar.\n4. Para muchos problemas, el método de Newton Raphson converge más rápido que los dos métodos anteriores.\n5. Además, puede identificar raíces repetidas, ya que no busca cambios en el signo de f (x) explícitamente\nLa formula:\nA partir de la estimación inicial x1, el método de Newton Raphson utiliza la siguiente fórmula para encontrar el siguiente valor de x, es decir, xn + 1 del valor anterior xn.\n \nAlgoritmo:\nEntrada: x inicial, func (x), derivFunc (x)\nSalida: Raíz de Func ()\n1. Calcule los valores de func (x) y derivFunc (x) para una x inicial dada\n2. Calcule h: h = func (x) / derivFunc (x)\n3. Si bien h es mayor que el error permitido ε\n1. h = func (x) / derivFunc (x)\n2. x = x - h\n\n¿Como funciona esto?\nLa idea es dibujar una recta tangente af (x) en el punto x1. El punto donde la línea tangente cruza el eje x debería ser una mejor estimación de la raíz que x1. Llame a este punto x2. Calcula f (x2) y dibuja una recta tangente en x2.\n \nSabemos que la pendiente de la recta de (x1, f (x1)) a (x2, 0) es f '(x1)) donde f' representa la derivada de f.\nf '(x1) = (0 - f (x1)) / (x2 - x1)\n\nf '(x1) * (x2 - x1) = - f (x1)\n\nx2 = x1 - f (x1) / f '(x1)\n\nAl encontrar este punto 'x2', nos acercamos a la raíz.\nTenemos que seguir repitiendo el paso anterior hasta que nos acerquemos mucho a\nla raíz o la encontramos.\n\nEn general,\nxn + 1 = xn - f (xn) / f '(xn)\nExplicación alternativa usando la serie de Taylor:\nSea x1 la estimación inicial.\n\nPodemos escribir x2 de la siguiente manera:\n  xn + 1 = xn + h ------- (1)\nAquí h sería un valor pequeño que puede ser positivo o negativo.\n\nSegún la serie de Taylor,\nƒ (x) que es infinitamente diferenciable se puede escribir como se muestra a continuación\nf (xn + 1) = f (xn + h)\n       = f (xn) + h * f '(xn) + ((h * h) / 2!) * (f' '(xn)) + ...\n\nComo buscamos la raíz de la función, f (xn + 1) = 0\n\nf (xn) + h * f '(xn) + ((h * h) / 2!) * (f' '(xn)) + ... = 0\n\nAhora que h es pequeño, h * h sería muy pequeño.\nEntonces, si ignoramos los términos de orden superior, obtenemos\n\nf (xn) + h * f '(xn) = 0\n\nSustituyendo este valor de h = xn + 1 - xn de la ecuación (1) obtenemos,\nf (xn) + (xn + 1 - xn) * f '(xn) = 0\n\nxn + 1 = xn - f (xn) / f '(xn)\nNotas:\n1. Generalmente usamos este método para mejorar el resultado obtenido por el método de bisección o el método de falsa posición.\n2. El método babilónico para la raíz cuadrada se deriva del método de Newton-Raphson.\n",
    "complejidad_tiempo": null,
    "java": "// Programa Java para la implementación del Método \n// Newton Raphson para resolver ecuaciones\n\npublic class NewtonRaphsonRoot {\n\n    static final double EPSILON = 0.001;\n\n    // Una función de ejemplo cuya solución se determina mediante el \n    // método de bisección. La función es x ^ 3 - x ^ 2 + 2\n    static double func(double x) {\n        return x * x * x - x * x + 2;\n    }\n\n    // Derivada de la función anterior que es 3 * x ^ x - 2 * x\n    static double derivFunc(double x) {\n        return 3 * x * x - 2 * x;\n    }\n\n    // Función para encontrar la raíz\n    static void newtonRaphson(double x) {\n        double h = func(x) / derivFunc(x);\n        while (Math.abs(h) >= EPSILON) {\n            h = func(x) / derivFunc(x);\n            // x (yo + 1) = x (yo) - f (x) / f '(x)\n            x = x - h;\n        }\n\n        System.out.print(\"The value of the\"\n                + \" root is : \"\n                + Math.round(x * 100.0) / 100.0);\n    }\n\n    public static void main(String[] args) {\n\n        // Valores iniciales asumidos\n        double x0 = -20;\n        newtonRaphson(x0);\n    }\n}\n",
    "cpp": "#include<bits/stdc++.h> \n#define EPSILON 0.001 \nusing namespace std;\n\ndouble func(double x) {\n    return x * x * x - x * x + 2;\n}\n\ndouble derivFunc(double x) {\n    return 3 * x * x - 2 * x;\n}\n\nvoid newtonRaphson(double x) {\n    double h = func(x) / derivFunc(x);\n    while (abs(h) >= EPSILON) {\n        h = func(x) / derivFunc(x);\n\n        x = x - h;\n    }\n\n    cout << \"The value of the root is : \" << x;\n}\n\nint main() {\n    double x0 = -20;\n    newtonRaphson(x0);\n    return 0;\n} \n",
    "py": "def func(x): \n    return x * x * x - x * x + 2\n  \ndef derivFunc(x): \n    return 3 * x * x - 2 * x \n  \ndef newtonRaphson(x): \n    h = func(x) / derivFunc(x) \n    while abs(h) >= 0.0001: \n        h = func(x) / derivFunc(x) \n        x = x - h \n      \n    print(\"The value of the root is : \", \n          \"%.4f\" % x) \n  \nx0 = -20 \nnewtonRaphson(x0) \n",
    "orden": 6,
    "suborden": 88,
    "fecha_creacion": "2020-12-05 01:56:18",
    "fecha_modificacion": "2022-03-08 12:05:45"
  },
  {
    "ID": 196,
    "supergrupo": "Matemática",
    "tema": "Teorema de Lucas",
    "texto": "Usando el teorema de Lucas para nCr% p:\nEl teorema de Lucas básicamente sugiere que el valor de nCr se puede calcular multiplicando los resultados de niCri donde ni y ri son dígitos individuales en la misma posición en representaciones en base p de nyr respectivamente.\nLa idea es calcular niCri uno por uno para los dígitos individuales ni y ri en base p. Dado que estos dígitos están en base p, nunca necesitaríamos más de O (p) espacio y la complejidad temporal de estos cálculos individuales estaría limitada por O (p2).\n\nComplejidad temporal: La complejidad temporal de esta solución es O (p2 * Logp n). Hay dígitos O (Logp n) en la representación base p de n. Cada uno de estos dígitos es menor que p, por lo tanto, los cálculos para dígitos individuales toman O (p2). Tenga en cuenta que estos cálculos se realizan mediante el método DP que lleva O (n * r) tiempo.\nImplementación alternativa con tiempo O (p2 + Logp n) y espacio O (p2):\nLa idea es precalcular el triángulo de Pascal para el tamaño p x py almacenarlo en una matriz 2D. Todos los valores necesarios ahora tomarían O (1) tiempo. Por tanto, la complejidad del tiempo total se convierte en O (p2 + Logp n).\n",
    "complejidad_tiempo": null,
    "java": "// Una solución basada en el teorema de Lucas para calcular nCr% p\n\npublic class LucasTheorem {\n\n    // Devuelve nCr% p. En este programa basado en el Teorema de Lucas, \n    // esta función solo se llama para n <p y r <p. \n    static int nCrModpDP(int n, int r, int p) {\n        // La matriz C va a almacenar la última fila del triángulo pascal al \n        // final. Y la última entrada de la última fila es nCr\n        int[] C = new int[r + 1];\n        C[0] = 1; // Fila superior del triángulo de Pascal\n        // Uno por construye las filas restantes del Triángulo Pascal de arriba a abajo\n        for (int i = 1; i <= n; i++) {\n            // Llene las entradas de la fila actual utilizando \n            // los valores de la fila anterior\n            for (int j = Math.min(i, r); j > 0; j--) // nCj = (n-1)Cj + (n-1)C(j-1); \n            {\n                C[j] = (C[j] + C[j - 1]) % p;\n            }\n        }\n        return C[r];\n    }\n\n    // Función basada en el Teorema de Lucas que devuelve nCr% p Esta \n    // función funciona como una función recursiva de conversión \n    // decimal a binaria. Primero calculamos los últimos dígitos \n    // de nyr en base p, luego recurrimos para los dígitos restantes\n    static int nCrModpLucas(int n, int r, int p) {\n        // Caso base\n        if (r == 0) {\n            return 1;\n        }\n        // Calcule los últimos dígitos de nyr en base p\n        int ni = n % p;\n        int ri = r % p;\n\n        // Calcule el resultado de los últimos dígitos calculados \n        // anteriormente y de los dígitos restantes. Multiplica los \n        // dos resultados y calcula el resultado de la \n        // multiplicación en módulo p.\n        return (nCrModpLucas(n / p, r / p, p)\n                * // Últimos dígitos de nyr\n                nCrModpDP(ni, ri, p)) % p; // Dígitos restantes\n    }\n\n    public static void main(String[] args) {\n        int n = 1000, r = 900, p = 13;\n        System.out.println(\"Value of nCr % p is \" + nCrModpLucas(n, r, p));\n    }\n}\n",
    "cpp": "#include<bits/stdc++.h> \nusing namespace std;\n\nint nCrModpDP(int n, int r, int p) {\n\n    int C[r + 1];\n    memset(C, 0, sizeof (C));\n    C[0] = 1;\n\n    for (int i = 1; i <= n; i++) {\n\n        for (int j = min(i, r); j > 0; j--)\n            C[j] = (C[j] + C[j - 1]) % p;\n    }\n    return C[r];\n}\n\nint nCrModpLucas(int n, int r, int p) {\n\n    if (r == 0)\n        return 1;\n    int ni = n % p, ri = r % p;\n\n    return (nCrModpLucas(n / p, r / p, p) * nCrModpDP(ni, ri, p)) % p;\n}\n\nint main() {\n    int n = 1000, r = 900, p = 13;\n    cout << \"Value of nCr % p is \" << nCrModpLucas(n, r, p);\n    return 0;\n}\n",
    "py": "def nCrModpDP(n, r, p): \n    C = [0] * (n + 1);\n    C[0] = 1; \n    for i in range(1, (n + 1)): \n        j = min(i, r); \n        while(j > 0): \n            C[j] = (C[j] + C[j - 1]) % p; \n            j -= 1; \n    return C[r]; \n    \ndef nCrModpLucas(n, r, p): \n\n    if (r == 0): \n        return 1; \n    ni = int(n % p); \n    ri = int(r % p); \n    return (nCrModpLucas(int(n / p), int(r / p), p) *\n            nCrModpDP(ni, ri, p)) % p;  \nn = 1000; \nr = 900; \np = 13; \nprint(\"Value of nCr % p is\", \n      nCrModpLucas(n, r, p)); \n",
    "orden": 6,
    "suborden": 88,
    "fecha_creacion": "2020-12-05 01:56:18",
    "fecha_modificacion": "2022-03-08 12:05:45"
  },
  {
    "ID": 197,
    "supergrupo": "Geometría",
    "tema": "Ángulos",
    "texto": "Ángulo es un concepto de la Geometría para referirse al espacio comprendido entre la intersección de dos líneas que parten de un mismo punto o vértice, y que es medido en grados.",
    "complejidad_tiempo": null,
    "java": "//Dados 3 puntos A, B, y C, determina el valor del angulo ABC (origen en B) \n//en radianes. \n//Si se desea convertir a grados sexagesimales, \n//revisar degrees and radians.\n\nimport java.awt.Point;\n\npublic class Angle {\n\n    static double angle(Point a, Point b, Point c) {\n        Vec ba = toVector(b, a);\n        Vec bc = toVector(b, c);\n        return Math.acos((ba.x * bc.x + ba.y * bc.y) / Math.sqrt((ba.x * ba.x + ba.y * ba.y) * (bc.x * bc.x + bc.y * bc.y)));\n    }\n\n    static class Vec {\n\n        public double x, y;\n\n        public Vec(double _x, double _y) {\n            this.x = _x;\n            this.y = _y;\n        }\n    }\n\n    static Vec toVector(Point a, Point b) {\n        return new Vec(b.x - a.x, b.y - a.y);\n    }\n\n    static double DegToRad(double d) {\n        return d * Math.PI / 180.0;\n    }\n\n    static double RadToDeg(double r) {\n        return r * 180.0 / Math.PI;\n    }\n\n    public static void main(String[] args) {\n        Point[] puntos = new Point[]{new Point(0, 0),\n            new Point(1, 0), new Point(0, 1)};\n        double res = angle(puntos[0], puntos[1], puntos[2]);\n        System.out.println(res);\n        System.out.println(RadToDeg(res));\n    }\n\n",
    "cpp": "#include <cstdlib>\n#include <bits/stdc++.h>\nusing namespace std;\n#define PI  acos(-1.0)\n\nstruct Point {\n    double x, y;\n\n    Point() {\n        x = y = 0.0;\n    }\n\n    Point(double _x, double _y) : x(_x), y(_y) {\n    }\n\n    bool operator==(Point other) const {\n        return (fabs(x - other.x) < 1e-9 && (fabs(y - other.y) < 1e-9));\n    }\n};\n\nstruct Vec {\n    double x, y;\n\n    Vec(double _x, double _y) : x(_x), y(_y) {\n    }\n};\n\nVec toVector(Point a, Point b) {\n    return Vec(b.x - a.x, b.y - a.y);\n}\n\ndouble angle(Point a, Point b, Point c) {\n    Vec ba = toVector(b, a);\n    Vec bc = toVector(b, c);\n    return acos((ba.x * bc.x + ba.y * bc.y) / sqrt((ba.x * ba.x + ba.y * ba.y) * (bc.x * bc.x + bc.y * bc.y)));\n}\n\ndouble DegToRad(double d) {\n    return d * acos(-1.0) / 180.0;\n}\n\ndouble RadToDeg(double r) {\n    return r * 180.0 / acos(-1.0);\n}\n\nint main() {\n    vector<Point> puntos;\n    Point a = {0, -1};\n    Point b = {0, 0};\n    Point c = {0, 1};\n    puntos.emplace_back(a);\n    puntos.emplace_back(b);\n    puntos.emplace_back(c);\n    double res = angle(puntos.at(0), puntos.at(1), puntos.at(2));\n    cout << res << endl;\n    cout << RadToDeg(res) << endl;\n}\n",
    "py": "import math as math\nclass Point:\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n \n    def equals(self, other):\n        if (abs(self.x - other.x) < 1e-9 and (abs(self.y - other.y) < 1e-9)):\n            return True\n        return False\nclass Vec:\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\ndef toVector(a, b):\n    return Vec(b.x - a.x, b.y - a.y)\ndef angle(a, b, c):\n    ba = toVector(b, a)\n    bc = toVector(b, c)\n    return math.acos((ba.x * bc.x + ba.y * bc.y) / math.sqrt((ba.x * ba.x + ba.y * ba.y) * (bc.x * bc.x + bc.y * bc.y)))\n\n\ndef DegToRad (d):\n    return d * math.acos(-1.0) / 180.0\n\n\ndef RadToDeg(r): \n    return r * 180.0 / math.acos(-1.0)\npuntos = []\npuntos.append(Point(0, -1))\npuntos.append(Point(0, 0))\npuntos.append(Point(0, 1))\nres = angle(puntos[0], puntos[1], puntos[2]);\nprint(res)\nprint(RadToDeg(res))\n\n",
    "orden": 7,
    "suborden": 20,
    "fecha_creacion": "2020-12-06 19:51:35",
    "fecha_modificacion": "2022-03-08 12:13:57"
  },
  {
    "ID": 198,
    "supergrupo": "Geometría",
    "tema": "Puntos 2D",
    "texto": "El PUNTO es una «figura geométrica» adimensional: no tiene longitud, área, volumen, ni otro ángulo dimensional. No es un objeto físico. Describe una posición en el espacio, determinada respecto de un sistema de coordenadas preestablecido.\n\nA los puntos se les suele nombrar con una letra mayúscula: A, B, C, etc.\n\n \n\nEl concepto de punto, como ente geométrico, surge en la antigua concepción griega de la geometría, compilada en Alejandría por Euclides en su tratado Los Elementos, dando una definición de punto excluyente: «lo que no tiene ninguna parte». El punto, en la geometría clásica se basa en la idea de que era un concepto intuitivo, el ente geométrico «sin dimensiones», y sólo era necesario asumir la noción de punto.\n\nEsa cuestión fue analizada por A. N. Whitehead en: Una investigación sobre los principios naturales de conocimiento (An Inquiry Concerning the Principles of Natural Knowledge), y El concepto de la Naturaleza (The concept of Nature). En estos libros se expone la «relación de inclusión». En Proceso y Realidad (Process and Reality) Whitehead propone un nuevo enfoque basado en la «relación de conexión» topológica. También H. J. Schmidt plantea una visión totalmente distinta del punto geométrico.\n\n\nDeterminación geométrica\n\nUn punto puede determinarse con diversos sistemas de referencia:\n\nEn el sistema de coordenadas cartesianas, se determina mediante las distancias ortogonales a los ejes principales, que se indican con dos letras o números: (x, y) en el plano; y con tres en el espacio (x, y, z).\n\nEn coordenadas polares, mediante su distancia al centro y la medida angular respecto del eje de referencia: (r, θ).\n\nEn coordenadas esféricas, mediante su distancia al centro y la medida angular respecto de los ejes de referencia: (r, θ, φ).\n\nEn coordenadas cilíndricas, mediante coordenadas radial, acimutal y altura: (ρ, φ, z).\n\nTambién se pueden emplear sistemas de coordenadas elípticas, parabólicas, esferoidales, toridales, etc.\n\n\nSEGMENTO\n\nUn segmento, en geometría, es un fragmento de recta que está comprendido entre dos puntos.\n\nó también\n\nSegmento es la porción de recta limitada por dos puntos, llamados extremos.\n\nTipos de segmentos\n\nSegmento nulo: Un segmento es nulo cuando sus extremos coinciden.\n\n\nSegmentos consecutivos\n\nDos segmentos son consecutivos cuando tienen un extremo en común.\t \n\nSegún pertenezcan o no a la misma línea, se clasifican en:\n\nColineales\n\nNo colineales: Los segmentos consecutivos no colineales, llamados poligonal o quebrada, pueden ser abiertos o cerrados según tengan o no extremos comunes el primer y el último segmento que lo forman. Las poligonales cerradas forman polígonos.\n \nLA RECTA\n\nEn geometría euclidiana, la recta o línea recta, es el ente ideal que se extiende en una misma dirección, existe en una sola dimensión y contiene infinitos puntos; está compuesta de infinitos segmentos (el fragmento de línea más corto que une dos puntos). También se describe como la sucesión continua e indefinida de puntos en una sola dimensión, o sea, no posee principio ni fin.\n \nLa Recta se nombra con una letra Minúscula o dos Mayúsculas y se lee la recta AB, la recta HG y la recta m.\n \nLA SEMIRECTA\n\nLa Semirecta se nombra con dos Mayúsculas y se lee la Semirecta AB, la Semirecta HG.\n\nPLANO\n\nEn geometría, un plano es el ente ideal que sólo posee dos dimensiones, y contiene infinitos puntos y rectas; es uno de los entes geométricos fundamentales junto con el punto y la recta.\n\nSolamente puede ser definido o descrito en relación a otros elementos geométricos similares. Se suele describir apoyándose en los postulados característicos, que determinan las relaciones entre los entes geométricos fundamentales. .-Cuando se habla de un plano, se está haciendo referencia a la superficie geométrica que no posee volumen (es decir, que es sólo bidimensional) y que posee un número infinito de rectas y puntos que lo cruzan de un lado al otro. Sin embargo, cuando el término se utiliza en plural, se está hablando de aquel material que es elaborado como una representación gráfica de superficies de diferente tipo. Los planos son especialmente utilizados en ingeniería, arquitectura y diseño ya que sirven para diagramar en una superficie plana otras superficies que son regularmente tridimensionales.\n\nUn plano queda definido por los siguientes elementos geométricos:\n\nTres puntos no alineados.\nUna recta y un punto exterior a ella.\nDos rectas paralelas.\nDos rectas que se cortan\n\nLos planos suelen nombrarse con una letra del alfabeto griego: Alfa (α), Beta (β), Theta (θ), Fi (φ) entre otras\n\nSuele representarse gráficamente, para su mejor visualización, como una figura delimitada por bordes irregulares (para indicar que el dibujo es una parte de una superficie infinita).\n",
    "complejidad_tiempo": null,
    "java": "// La clase punto será la base sobre la cual se ejecuten otros algoritmos. \n\n public class PointClass {\n\n    static class Point {\n\n        public double x, y;\n\n        public Point() {\n            this.x = this.y = 0.0;\n        }\n\n        public Point(double _x, double _y) {\n            this.x = _x;\n            this.y = _y;\n        }\n\n        public boolean equals(Point other) {\n            if (Math.abs(this.x - other.x) < 1e-9 && (Math.abs(this.y - other.y) < 1e-9)) {\n                return true;\n            }\n            return false;\n        }\n\n    }\n    \n     public static void main(String[] args) {\n         //coordenadas en x y y\n         Point A= new Point(0, 0);\n     }\n}\n",
    "cpp": "#include \"bits/stdc++.h\" \nusing namespace std;\n\nstruct Point {\n    double x, y;\n\n    Point() {\n        x = y = 0.0;\n    }\n\n    Point(double _x, double _y) : x(_x), y(_y) {\n    }\n\n    bool operator==(Point other) const {\n        return (fabs(x - other.x) < 1e-9 && (fabs(y - other.y) < 1e-9));\n    }\n};\n\nint main() {\n    Point A = Point(0, 0);\n}\n",
    "py": "class Point:\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n \n    def compare(self, other):\n        if (abs(self.x - other.x) < 1e-9 and (abs(self.y - other.y) < 1e-9)):\n            return True\n        return False\n    \nA = Point(0, 0)\n",
    "orden": 7,
    "suborden": 21,
    "fecha_creacion": "2020-12-06 19:51:35",
    "fecha_modificacion": "2022-03-08 12:13:57"
  },
  {
    "ID": 199,
    "supergrupo": "Geometría",
    "tema": "Perímetro de un polígono",
    "texto": "El perímetro y el área son dos elementos fundamentales en matemáticas. Para cuantificar el espacio físico y también para proveer las bases de matemáticas más avanzadas como en el álgebra, trigonometría, y cálculo. El perímetro es una medida de la distancia alrededor de una figura y el área nos da una idea de qué tanta superficie cubre dicha figura.\n \n \nPerímetro\n \nEl perímetro de una figura de dos dimensiones es la distancia alrededor de la figura. Algunas personas encuentran útil pensar “peri-metro” donde peri es “periferia” y metro es “medida”.\n \nSi la figura es un polígono, entonces puede sumar todas las longitudes de sus lados para encontrar el perímetro. \n",
    "complejidad_tiempo": null,
    "java": "//Calcula el perímetro de un polígono representado \n//como un vector de puntos. \n//IMPORTANTE: Definir P[0] = P[n-1] para cerrar el polígono. \n//La estructura point debe estar definida, al igual que el\n//método euclideanDistance.\n\nimport java.util.ArrayList;\nimport java.awt.Point;\n\npublic class Perimeter {\n\n    public static double perimeter(ArrayList<Point> P) {\n        double result = 0.0;\n        for (int i = 0; i < P.size() - 1; i++) {\n            result += euclideanDistance(P.get(i), P.get(i + 1));\n        }\n        return result;\n    }\n\n    /*Trabajando con la clase Point*/\n    static double euclideanDistance(Point p1, Point p2) {\n        return Math.hypot(p1.x - p2.x, p1.y - p2.y);\n    }\n\n    /*Trabajando con los valores x y y de cada punto*/\n    static double euclideanDistance(double x1, double y1, double x2, double y2) {\n        return Math.hypot(x2 - x1, y2 - y1);\n    }\n\n    public static void main(String[] args) {\n        ArrayList<Point> polygon = new ArrayList<>();\n        polygon.add(new Point(0, 0));\n        polygon.add(new Point(1, 0));\n        polygon.add(new Point(1, 1));\n        polygon.add(new Point(0, 1));\n        polygon.add(new Point(0, 0));\n        System.out.println(perimeter(polygon));\n    }\n}\n",
    "cpp": "using namespace std;\n\nstruct Point {\n    double x, y;\n\n    Point() {\n        x = y = 0.0;\n    }\n\n    Point(double _x, double _y) : x(_x), y(_y) {\n    }\n\n};\n\ndouble euclideanDistance(Point p1, Point p2) {\n    return hypot(p1.x - p2.x, p1.y - p2.y);\n}\n\ndouble perimeter(vector<Point> P) {\n    double result = 0.0;\n    for (int i = 0; i < P.size() - 1; i++) {\n        result += euclideanDistance(P[i], P[i + 1]);\n    }\n    return result;\n}\n\ndouble euclideanDistance(double x1, double y1, double x2, double y2) {\n    return hypot(x2 - x1, y2 - y1);\n}\n\nint main() {\n    vector<Point> polygon;\n    polygon.emplace_back(Point(0, 0));\n    polygon.emplace_back(Point(1, 0));\n    polygon.emplace_back(Point(1, 1));\n    polygon.emplace_back(Point(0, 1));\n    polygon.emplace_back(Point(0, 0));\n    cout << perimeter(polygon) << endl;\n}\n",
    "py": "import math as math\nclass Point:\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n        \ndef euclideanDistance(p1, p2):\n    return math.hypot(p1.x - p2.x, p1.y - p2.y)\n\ndef perimeter(P):\n    result = 0.0\n    for i in range (len(P)-1):\n        result += euclideanDistance(P[i], P[i + 1])\n    return result;\n\npolygon = []\npolygon.append(Point(0, 0));\npolygon.append(Point(1, 0));\npolygon.append(Point(1, 1));\npolygon.append(Point(0, 1));\npolygon.append(Point(0, 0));\nprint(perimeter(polygon))\n",
    "orden": 7,
    "suborden": 22,
    "fecha_creacion": "2020-12-06 19:51:36",
    "fecha_modificacion": "2022-03-08 12:13:57"
  },
  {
    "ID": 200,
    "supergrupo": "Geometría",
    "tema": "Area de un  polígono",
    "texto": "Las fórmulas para calcular el área de un polígono son diferentes según si el polígono es regular o irregular:\nPolígono regular: es un polígono con todos los lados y ángulos iguales.\nPolígono irregular: polígono con con los lados y ángulos desiguales.\n \nMientras que el área del polígono regular se calcula a partir de un lado y la apotema, el área del polígono irregular requiere de métodos alternativos de cálculo de áreas: método de triangulación o determinante de Gauss.\nÁrea del polígono regular\nEl área de un polígono regular se calcula a partir de su perímetro y su apotema. Sea P el polígono regular con N lados, su área es:\n \nEn un polígono regular, el perímetro se puede determinar por el producto del número de lados por la longitud de uno de los lados, es decir, Perímetro=N·L. O sea:\n \nÁrea del polígono irregular\nEl cálculo del área de un polígono irregular requiere de métodos alternativos de cálculo de áreas. El método más común es dividir el polígono en N triángulos (siendo N el número de lados del polígono) y calcular la área como suma de las áreas de los triángulos. \n \nEl área del polígono irregular se puede calcular mediante dos procedimientos alternativos: el método de triangulación o el determinante de Gauss.\n",
    "complejidad_tiempo": null,
    "java": "//Calcula el area de un polígono representado como un \n//ArrayList de puntos. \n//IMPORTANTE: Definir P[0] = P[n-1] para cerrar el polígono. \n//El algorítmo utiliza el metodo de determinante \n//de la matriz de puntos de la figura. \n\nimport java.util.ArrayList;\nimport java.awt.Point;\n\npublic class Area {\n\n    public static double area(ArrayList<Point> P) {\n        double result = 0.0;\n        for (int i = 0; i < P.size() - 1; i++) {\n            result += ((P.get(i).x * P.get(i + 1).y) - (P.get(i + 1).x *            P.get(i).y));\n        }\n        return Math.abs(result) / 2.0;\n    }\n\n    public static void main(String[] args) {\n        ArrayList<Point> puntos = new ArrayList<>();\n        //los puntos deben ir en orden\n        puntos.add(new Point(0, 0));\n        puntos.add(new Point(0, 1));\n        puntos.add(new Point(1, 1));\n        puntos.add(new Point(1, 0));\n        //Definir el ultimo punto igual que el primero para cerrar el poligono\n        puntos.add(new Point(0, 0));\n        System.out.println(area(puntos));\n    }\n}\n",
    "cpp": "#include <cstdlib>\n#include <bits/stdc++.h>\nusing namespace std;\n\nstruct Point {\n    double x, y;\n\n    Point() {\n        x = y = 0.0;\n    }\n\n    Point(double _x, double _y) : x(_x), y(_y) {\n    }\n\n    bool operator==(Point other) const {\n        return (fabs(x - other.x) < 1e-9 && (fabs(y - other.y) < 1e-9));\n    }\n};\n\ndouble area(vector<Point> P) {\n    double result = 0.0;\n    for (int i = 0; i < P.size() - 1; i++) {\n        result += ((P.at(i).x * P.at(i + 1).y) - (P.at(i + 1).x * P.at(i).y));\n    }\n    return abs(result) / 2.0;\n}\n\nint main() {\n    vector<Point> puntos;\n    puntos.emplace_back(Point(0, 0));\n    puntos.emplace_back(Point(0, 1));\n    puntos.emplace_back(Point(1, 1));\n    puntos.emplace_back(Point(1, 0));\n    puntos.emplace_back(Point(0, 0));\n    cout << area(puntos) << endl;\n}\n",
    "py": "class Point:\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n \n    def equals(self, other):\n        if (abs(self.x - other.x) < 1e-9 and (abs(self.y - other.y) < 1e-9)):\n            return True\n        return False\ndef area(P):\n    result = 0.0\n    for i in range (len(P)-1):\n        result += ((P[i].x * P[i + 1].y) - (P[i + 1].x * P[i].y))\n    return abs(result) / 2.0;\npuntos = []\npuntos.append(Point(0, 0))\npuntos.append(Point(0, 1))\npuntos.append(Point(1, 1))\npuntos.append(Point(1, 0))\npuntos.append(Point(0, 0))\nprint(area(puntos))\n",
    "orden": 7,
    "suborden": 23,
    "fecha_creacion": "2020-12-06 19:51:36",
    "fecha_modificacion": "2022-03-08 12:13:57"
  },
  {
    "ID": 201,
    "supergrupo": "Geometría",
    "tema": "Intersección de círculos",
    "texto": "Hay dos círculos A y B con sus centros C1 (x1, y1) y C2 (x2, y2) y radio R1 y R2. La tarea es comprobar que ambos círculos A y B se toquen o no.\nEjemplos:\nEntrada: C1 = (3, 4)\n         C2 = (14, 18)\n         R1 = 5, R2 = 8\nResultado: Los círculos no se tocan entre sí.\n\nEntrada: C1 = (2, 3)\n         C2 = (15, 28)\n         R1 = 12, R2 = 10\nResultado: los círculos se cruzan entre sí.\n\nEntrada: C1 = (-10, 8)\n         C2 = (14, -24)\n         R1 = 30, R2 = 10\nEntrada: -10 8\n         14-24\n         30 10\nSalida: Círculos se tocan entre sí.\nLa distancia entre los centros C1 y C2 se calcula como\n  C1C2 = raíz cuadrada ((x1 - x2) 2 + (y1 - y2) 2).\nHay tres condiciones que surgen.\n1. Si C1C2 == R1 + R2\n      Los círculos A y B se tocan entre sí.\n2. Si C1C2> R1 + R2\n      Los círculos A y B no se tocan entre sí.\n3. Si C1C2 <R1 + R2\n       El círculo se cruza entre sí.\n",
    "complejidad_tiempo": null,
    "java": "// Programa Java para comprobar si dos círculos se tocan o no.\n\npublic class CircleIntersect {\n\n    static int circle(int x1, int y1, int x2,\n            int y2, int r1, int r2) {\n        int distSq = (x1 - x2) * (x1 - x2)\n                + (y1 - y2) * (y1 - y2);\n        int radSumSq = (r1 + r2) * (r1 + r2);\n        if (distSq == radSumSq) {\n            return 1;\n        } else if (distSq > radSumSq) {\n            return -1;\n        } else {\n            return 0;\n        }\n    }\n\n    public static void main(String[] args) {\n        int x1 = -10, y1 = 8;\n        int x2 = 14, y2 = -24;\n        int r1 = 30, r2 = 10;\n        int t = circle(x1, y1, x2,\n                y2, r1, r2);\n        if (t == 1) {\n            System.out.println(\"Circle touch to\"\n                    + \" each other.\");\n        } else if (t < 0) {\n            System.out.println(\"Circle not touch\"\n                    + \" to each other.\");\n        } else {\n            System.out.println(\"Circle intersect\"\n                    + \" to each other.\");\n        }\n    }\n}\n",
    "cpp": "#include<bits/stdc++.h> \n#include<cstdlib>\nusing namespace std;\n\nint circle(int x1, int y1, int x2,\n        int y2, int r1, int r2) {\n    int distSq = (x1 - x2) * (x1 - x2)\n            + (y1 - y2) * (y1 - y2);\n    int radSumSq = (r1 + r2) * (r1 + r2);\n    if (distSq == radSumSq) {\n        return 1;\n    } else if (distSq > radSumSq) {\n        return -1;\n    } else {\n        return 0;\n    }\n}\n\nint main() {\n    int x1 = -10, y1 = 8;\n    int x2 = 14, y2 = -24;\n    int r1 = 30, r2 = 10;\n    int t = circle(x1, y1, x2,\n            y2, r1, r2);\n    if (t == 1) {\n        cout << \"Circle touch to each other.\" << endl;\n    } else if (t < 0) {\n        cout << \"Circle not touch to each other.\" << endl;\n    } else {\n        cout << \"Circle intersect to each other.\" << endl;\n    }\n}\n",
    "py": "def circle(x1, y1, x2, y2, r1, r2):\n    distSq = (x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2)\n    radSumSq = (r1 + r2) * (r1 + r2)\n    if (distSq == radSumSq):\n        return 1\n    elif (distSq > radSumSq):\n        return -1\n    else: \n        return 0\n\nx1 = -10\ny1 = 8\nx2 = 14\ny2 = -24\nr1 = 30\nr2 = 10\nt = circle(x1, y1, x2, y2, r1, r2)\nif (t == 1):\n    print(\"Circle touch to each other.\")\nelif (t < 0):\n    print(\"Circle not touch to each other.\")\nelse:\n    print(\"Circle intersect to each other.\")\n",
    "orden": 7,
    "suborden": 24,
    "fecha_creacion": "2020-12-06 19:51:36",
    "fecha_modificacion": "2022-03-08 12:13:57"
  },
  {
    "ID": 202,
    "supergrupo": "Geometría",
    "tema": "Limpieza del cuarto",
    "texto": "Dada una habitación con cuadrículas cuadradas que tienen \"*\" y \".\" Que representan celdas normales y desordenadas respectivamente.\nDebe averiguar si la habitación se puede limpiar o no.\nHay una máquina que le ayuda en esta tarea, pero es capaz de limpiar solo la celda normal. Las celdas desordenadas no se pueden limpiar con la máquina hasta que haya limpiado la celda normal en su fila o columna. Ahora, verifique si la habitación se puede limpiar o no.\nLa entrada es la siguiente:\nLa primera línea contiene el tamaño de la habitación. Las siguientes n líneas contienen una descripción para cada fila en la que la fila [i] [j] es \"\" si está más desordenada que otras, de lo contrario, es \"\" si es una celda normal.\nEjemplos:\nEntrada: 3\n        . **\n        . **\n        . **\nResultado: Sí, la habitación se puede limpiar.\n        1 1\n        2 1\n        3 1\nEntrada: 4\n       ****\n       .. *.\n       .. *.\n       .. *.\nResultado: la casa no se puede limpiar.\nAproximación :\nEl número mínimo de celdas puede ser n. Es la única respuesta posible, ya que debe tener un elemento de tipo \"\" en cada fila y columna diferente. Si una columna determinada y una fila determinada contienen \"\" en todas las celdas, se sabe que la casa no se puede limpiar. Recorra cada fila y encuentre el \"\" que se puede utilizar para la máquina. Use este paso dos veces, verifique cada columna para cada fila y luego verifique cada fila para cada columna. Luego, verifique si alguno de los dos da una respuesta como n. Si es así, la casa se puede limpiar, de lo contrario no. Este enfoque nos dará la respuesta mínima requerida.\n\nEn el primer ejemplo, la máquina limpiará la celda (1, 1), (2, 1), (3, 1) para limpiar toda la habitación.\nEn el segundo ejemplo, cada celda de la fila tiene \"\" y cada celda de la columna contiene \"\", por lo que la casa no se puede limpiar. La fila no se puede limpiar de ninguna manera.\n",
    "complejidad_tiempo": null,
    "java": "// código java para encontrar si la casa se puede limpiar o no\n\nimport java.util.ArrayList;\n\npublic class CleaningRoom {\n\n    static class Pair {\n\n        int a, b;\n\n        public Pair(int a, int b) {\n            this.a = a;\n            this.b = b;\n        }\n    }\n    // El array A almacena el string\n    static int A[][] = new int[105][105];\n    // ans almacena el par de índices que la máquina va a limpiar\n    static ArrayList<Pair> ans = new ArrayList<>();\n\n    // Función para imprimir el vector de pares\n    static void print() {\n        System.out.println(\"Yes, the house can be cleaned.\");\n        for (int i = 0; i < ans.size(); i++) {\n            System.out.println((ans.get(i).a + \" \" + ans.get(i).b));\n        }\n    }\n\n    static void solve(int n) {\n        // inserta cada primera celda en cada fila que contenga '.'\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n; j++) {\n                if (A[i][j] == '.') {\n                    ans.add(new Pair(i + 1, j + 1));\n                    break;\n                }\n            }\n        }\n        // Si el número total de celdas es n, la casa se puede limpiar\n        if (ans.size() == n) {\n            print();\n            return;\n        }\n        ans = new ArrayList<>();\n        // inserta cada primera celda en cada columna que contenga '.'\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n; j++) {\n                if (A[i][j] == '.') {\n                    ans.add(new Pair(i + 1, j + 1));\n                    break;\n                }\n            }\n        }\n        // Si el número total de celdas es n, la casa se puede limpiar\n        if (ans.size() == n) {\n            print();\n            return;\n        }\n        System.out.println(\"house cannot be cleaned.\");\n    }\n\n    public static void main(String[] args) {\n        int n = 3;\n        String s = \"\";\n        s += \".**\";\n        s += \".**\";\n        s += \".**\";\n        int k = 0;\n        // Bucle para insertar letras de cadena en la matriz\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n; j++) {\n                A[i][j] = s.charAt(k);\n                k += 1;\n            }\n        }\n        solve(n);\n    }\n\n}\n",
    "cpp": "#include <bits/stdc++.h> \nusing namespace std;\nchar A[105][105];\nvector<pair<int, int> > ans;\n\nvoid print() {\n    cout << \"Yes, the house can be\"\n            << \" cleaned.\" << endl;\n\n    for (int i = 0; i < ans.size(); i++)\n        cout << ans[i].first << \" \"\n            << ans[i].second << endl;\n}\n\nint solve(int n) {\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            if (A[i][j] == '.') {\n                ans.push_back(make_pair(i + 1, j + 1));\n                break;\n            }\n        }\n    }\n    if (ans.size() == n) {\n        print();\n        return 0;\n    }\n\n    ans.clear();\n\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            if (A[j][i] == '.') {\n                ans.push_back(make_pair(i + 1, j + 1));\n                break;\n            }\n        }\n    }\n    if (ans.size() == n) {\n        print();\n        return 0;\n    }\n    cout << \"house cannot be cleaned.\" << endl;\n}\n\nint main() {\n    int n = 3;\n    string s = \"\";\n    s += \".**\";\n    s += \".**\";\n    s += \".**\";\n    int k = 0;\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++)\n            A[i][j] = s[k++];\n    }\n    solve(n);\n    return 0;\n}\n",
    "py": "A = [[0 for i in range(105)] for j in range(105)] \nans = [] \n\ndef printt(): \n      \n    print(\"Yes, the house can be cleaned.\") \n    for i in range(len(ans)): \n        print(ans[i][0], ans[i][1]) \n          \ndef solve(n): \n    global ans \n    for i in range(n): \n        for j in range(n): \n            if (A[i][j] == '.'): \n                ans.append([i + 1, j + 1]) \n                break\n    if (len(ans) == n): \n        printt() \n        return 0\n          \n    ans = [] \n\n    for i in range(n): \n        for j in range(n): \n            if (A[j][i] == '.'): \n                ans.append([i + 1, j + 1]) \n                break\n    if (len(ans) == n): \n        printt() \n        return 0\n    print(\"house cannot be cleaned.\") \n  \n\nn = 3\ns = \"\" \ns += \".**\"\ns += \".**\"\ns += \".**\"\nk = 0\nfor i in range(n): \n    for j in range(n): \n        A[i][j] = s[k] \n        k += 1\n  \nsolve(n) \n",
    "orden": 7,
    "suborden": 25,
    "fecha_creacion": "2020-12-06 19:51:37",
    "fecha_modificacion": "2022-03-08 12:13:57"
  },
  {
    "ID": 203,
    "supergrupo": "Geometría",
    "tema": "Distancia Euclidiana",
    "texto": "Se le dan dos coordenadas (x1, y1) y (x2, y2) de un gráfico bidimensional. Calcula la distancia entre ellos.\nEjemplos:\nEntrada: x1, y1 = (3, 4)\n         x2, y2 = (7, 7)\nSalida: 5\n\nEntrada: x1, y1 = (3, 4)\n         x2, y2 = (4, 3)\nSalida: 1.41421\n",
    "complejidad_tiempo": null,
    "java": "//Halla la distancia euclideana de 2 puntos en dos dimensiones (x,y). Para usar el primer método, debe definirse previamente la clase Point\n\nimport java.awt.Point;\n\npublic class EuclideanDistance {\n\n    /*Trabajando con la clase Point*/\n    static double euclideanDistance(Point p1, Point p2) {\n        return Math.hypot(p1.x - p2.x, p1.y - p2.y);\n    }\n\n    /*Trabajando con los valores x y y de cada punto*/\n    static double euclideanDistance(double x1, double y1, double x2, double y2) {\n        return Math.hypot(x2 - x1, y2 - y1);\n    }\n\n    public static void main(String[] args) {\n        System.out.println(euclideanDistance(new Point(0, 0), new Point(20, 20)));\n        System.out.println(euclideanDistance(0, 0, 20, 20));\n    }\n\n}\n",
    "cpp": "#include <cstdlib>\n#include <bits/stdc++.h>\nusing namespace std;\n\nstruct Point {\n    double x, y;\n\n    Point() {\n        x = y = 0.0;\n    }\n\n    Point(double _x, double _y) : x(_x), y(_y) {\n    }\n\n    bool operator==(Point other) const {\n        return (fabs(x - other.x) < 1e-9 && (fabs(y - other.y) < 1e-9));\n    }\n};\n\ndouble euclideanDistance(Point p1, Point p2) {\n    return hypot(p1.x - p2.x, p1.y - p2.y);\n}\n\ndouble euclideanDistance(double x1, double y1, double x2, double y2) {\n    return hypot(x2 - x1, y2 - y1);\n}\n\nint main() {\n    cout << euclideanDistance(Point(0, 0), Point(20, 20)) << endl;\n    cout << euclideanDistance(0, 0, 20, 20) << endl;\n\n}\n",
    "py": "import math\nclass Point:\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n \n    def equals(self, other):\n        if (abs(self.x - other.x) < 1e-9 and (abs(self.y - other.y) < 1e-9)):\n            return True\n        return False\ndef euclideanDistance1(p1, p2):\n    return math.hypot(p1.x - p2.x, p1.y - p2.y);\n\n\ndef euclideanDistance(x1, y1, x2, y2):\n    return math.hypot(x2 - x1, y2 - y1)\nprint(euclideanDistance1(Point(0, 0), Point(20, 20)))\nprint(euclideanDistance(0, 0, 20, 20))\n",
    "orden": 7,
    "suborden": 26,
    "fecha_creacion": "2020-12-06 19:51:37",
    "fecha_modificacion": "2022-03-08 12:13:57"
  },
  {
    "ID": 204,
    "supergrupo": "Geometría",
    "tema": "Vector geométrico",
    "texto": "Un vector director es un vector que da la dirección de una recta y también la orienta, es decir, le da un sentido determinado.\nEn el plano, en el espacio tridimensional o en cualquier espacio vectorial, una recta se puede definir con dos puntos o, de manera equivalente, con un punto y un vector director. En efecto, a partir de dos puntos distintos A y B se obtiene un punto, digamos A, y un vector director u = AB. Recíprocamente, con un punto A de la recta y un vector director u se construye un segundo punto de la misma, definido por AB = u. Esta recta se escribe (AB) o (A, u).\n",
    "complejidad_tiempo": null,
    "java": "import java.awt.Point;\n//Dados dos puntos A y B, crea el vector A->B. \n//Es llamado Vec para no confundirlo con vector \n//como colección de elementos.\n\npublic class GeometricVector {\n\n    static class Vec {\n\n        public double x, y;\n\n        public Vec(double _x, double _y) {\n            this.x = _x;\n            this.y = _y;\n        }\n    }\n\n    static Vec toVector(Point a, Point b) {\n        return new Vec(b.x - a.x, b.y - a.y);\n    }\n\n    public static void main(String[] args) {\n        Point a = new Point(0, 0);\n        Point b = new Point(5, 5);\n        Vec segmento = toVector(a, b);\n    }\n}\n",
    "cpp": "#include <bits/stdc++.h>\n#include <cstdlib>\nusing namespace std;\n\nstruct Point {\n    double x, y;\n\n    Point() {\n        x = y = 0.0;\n    }\n\n    Point(double _x, double _y) : x(_x), y(_y) {\n    }\n\n    bool operator==(Point other) const {\n        return (fabs(x - other.x) < 1e-9 && (fabs(y - other.y) < 1e-9));\n    }\n};\n\nstruct Vec {\n    double x, y;\n\n    Vec(double _x, double _y) : x(_x), y(_y) {\n    }\n};\n\nVec toVector(Point a, Point b) {\n    return Vec(b.x - a.x, b.y - a.y);\n}\n\nint main() {\n    Point a = {0, 0};\n    Point b = {5, 5};\n    Vec segmento = toVector(a, b);\n}\n",
    "py": "class Point:\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n \n    def equals(self, other):\n        if (abs(self.x - other.x) < 1e-9 and (abs(self.y - other.y) < 1e-9)):\n            return True\n        return False\nclass Vec:\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\ndef toVector(a, b):\n    return Vec(b.x - a.x, b.y - a.y)\ndef angle(a, b, c):\n    ba = toVector(b, a)\n    bc = toVector(b, c)\n    return math.acos((ba.x * bc.x + ba.y * bc.y) / math.sqrt((ba.x * ba.x + ba.y * ba.y) * (bc.x * bc.x + bc.y * bc.y)))\n\na = Point(0, 0)\nb = Point(5, 5)\nsegmento = toVector(a, b)\n",
    "orden": 7,
    "suborden": 27,
    "fecha_creacion": "2020-12-06 19:51:37",
    "fecha_modificacion": "2022-03-08 12:13:57"
  },
  {
    "ID": 205,
    "supergrupo": "Geometría",
    "tema": "Punto dentro de un polígono",
    "texto": "Dado un polígono y un punto \"p\", averigüe si \"p\" se encuentra dentro del polígono o no. Los puntos que se encuentran en el borde se consideran dentro\n\nA continuación se presenta una idea sencilla para comprobar si un punto está dentro o fuera.\n1) Dibuja una línea horizontal a la derecha de cada punto y extiéndela hasta el infinito\n\n1) Cuente el número de veces que la línea se cruza con los bordes del polígono.\n\n2) Un punto está dentro del polígono si el recuento de intersecciones es impar o\n    el punto se encuentra en un borde de polígono. Si ninguna de las condiciones es verdadera, entonces\n    el punto se encuentra afuera.\n \n¿Cómo manejar el punto \"g\" en la figura anterior?\nTenga en cuenta que debemos devolver verdadero si el punto se encuentra en la línea o igual que uno de los vértices del polígono dado. Para manejar esto, después de verificar si la línea desde \"p\" hasta el extremo se interseca, verificamos si \"p\" es colineal con los vértices de la línea actual del polígono. Si es coliear, entonces verificamos si el punto \"p\" se encuentra en el lado actual del polígono, si se encuentra, devolvemos verdadero, de lo contrario falso.\n",
    "complejidad_tiempo": null,
    "java": "//Determina si un punto pt se encuentra en el polígono \n//P. Este polígono se define como un vector de puntos, \n//donde el punto 0 y n-1 son el mismo. \nimport java.util.ArrayList;\nimport java.awt.Point;\n\npublic class PointtInPolygon {\n\n    static boolean ccw(Point p, Point q, Point r) {\n        return cross(toVector(p, q), toVector(p, r)) > 0;\n    }\n\n    static boolean inPolygon(Point pt, ArrayList<Point> P) {\n        if (P.isEmpty()) {\n            return false;\n        }\n        double sum = 0;\n        for (int i = 0; i < P.size() - 1; i++) {\n            if (ccw(pt, P.get(i), P.get(i + 1))) {\n                sum += angle(P.get(i), pt, P.get(i + 1));\n            } else {\n                sum -= angle(P.get(i), pt, P.get(i + 1));\n            }\n        }\n        if (Math.abs(Math.abs(sum) - 2 * Math.acos(-1.0)) < 1e-9) {\n            return true;\n        }\n        return false;\n    }\n\n    static double cross(Vec a, Vec b) {\n        return a.x * b.y - a.y * b.x;\n    }\n\n    static boolean collinear(Point p, Point q, Point r) {\n        return Math.abs(cross(toVector(p, q), toVector(p, r))) < 1e-9;\n    }\n\n    static double angle(Point a, Point b, Point c) {\n        Vec ba = toVector(b, a);\n        Vec bc = toVector(b, c);\n        return Math.acos((ba.x * bc.x + ba.y * bc.y) / Math.sqrt((ba.x * ba.x + ba.y * ba.y) * (bc.x * bc.x + bc.y * bc.y)));\n    }\n\n    static class Vec {\n\n        public double x, y;\n\n        public Vec(double _x, double _y) {\n            this.x = _x;\n            this.y = _y;\n        }\n    }\n\n    static Vec toVector(Point a, Point b) {\n        return new Vec(b.x - a.x, b.y - a.y);\n    }\n\n    public static void main(String[] args) {\n        ArrayList<Point> polygon = new ArrayList<>();\n        polygon.add(new Point(0, 0));\n        polygon.add(new Point(2, 0));\n        polygon.add(new Point(2, 2));\n        polygon.add(new Point(0, 2));\n        polygon.add(new Point(0, 0));\n        Point punto = new Point(1, 1);\n        if (inPolygon(punto, polygon)) {\n            System.out.println(\"Si\");\n        } else {\n            System.out.println(\"No\");\n        }\n    }\n}\n",
    "cpp": "#include \"bits/stdc++.h\" \nusing namespace std;\n\nstruct Point {\n    double x, y;\n\n    Point() {\n        x = y = 0.0;\n    }\n\n    Point(double _x, double _y) : x(_x), y(_y) {\n    }\n\n    bool operator==(Point other) const {\n        return (fabs(x - other.x) < 1e-9 && (fabs(y - other.y) < 1e-9));\n    }\n};\n\nstruct Vec {\n    double x, y;\n\n    Vec(double _x, double _y) {\n        x = _x;\n        y = _y;\n    }\n};\n\nstatic Vec toVector(Point a, Point b) {\n    return Vec(b.x - a.x, b.y - a.y);\n}\n\ndouble angle(Point a, Point b, Point c) {\n    Vec ba = toVector(b, a);\n    Vec bc = toVector(b, c);\n    return acos((ba.x * bc.x + ba.y * bc.y) / sqrt((ba.x * ba.x + ba.y * ba.y) * (bc.x * bc.x + bc.y * bc.y)));\n}\n\ndouble cross(Vec a, Vec b) {\n    return a.x * b.y - a.y * b.x;\n}\n\nbool ccw(Point p, Point q, Point r) {\n    return cross(toVector(p, q), toVector(p, r)) > 0;\n}\n\nbool inPolygon(Point pt, vector<Point> P) {\n    if (P.empty()) {\n        return false;\n    }\n    double sum = 0;\n    for (int i = 0; i < P.size() - 1; i++) {\n        if (ccw(pt, P[i], P[i + 1])) {\n            sum += angle(P[i], pt, P[i + 1]);\n        } else {\n            sum -= angle(P[i], pt, P[i + 1]);\n        }\n    }\n    if (abs(abs(sum) - 2 * acos(-1.0)) < 1e-9) {\n        return true;\n    }\n    return false;\n}\n\nbool collinear(Point p, Point q, Point r) {\n    return abs(cross(toVector(p, q), toVector(p, r))) < 1e-9;\n}\n\nint main() {\n    vector<Point> polygon;\n    polygon.emplace_back(Point(0, 0));\n    polygon.emplace_back(Point(2, 0));\n    polygon.emplace_back(Point(2, 2));\n    polygon.emplace_back(Point(0, 2));\n    polygon.emplace_back(Point(0, 0));\n    Point punto = Point(1, 1);\n    if (inPolygon(punto, polygon)) {\n        cout << \"Si\" << endl;\n    } else {\n        cout << \"No\" << endl;\n    }\n}\n",
    "py": "import math\n \nclass Point:\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n \n    def compare(self, other):\n        if (abs(self.x - other.x) < 1e-9 and (abs(self.y - other.y) < 1e-9)):\n            return True\n        return False\n    \nclass Vec:\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n   \ndef toVector(a, b):\n    return Vec(b.x - a.x, b.y - a.y)\n\ndef angle(a, b, c):\n    ba = toVector(b, a)\n    bc = toVector(b, c)\n    return math.acos((ba.x * bc.x + ba.y * bc.y) / math.sqrt((ba.x * ba.x + ba.y * ba.y) * (bc.x * bc.x + bc.y * bc.y)))\n\ndef cross(a, b):\n    return a.x * b.y - a.y * b.x\n\n\ndef ccw(p, q, r):\n    return cross(toVector(p, q), toVector(p, r)) > 0\n\ndef inPolygon(pt, P):\n    if (len(P) == 0):\n        return false;\n    sum = 0;\n    for i in range (len(P)-1):\n        if (ccw(pt, P[i], P[i + 1])):\n            sum += angle(P[i], pt, P[i + 1])\n        else:\n            sum -= angle(P[i], pt, P[i + 1])\n    if (abs(abs(sum) - 2 * math.acos(-1.0)) < 1e-9):\n        return True\n    return False\n\ndef collinear(p, q, r):\n    return abs(cross(toVector(p, q), toVector(p, r))) < 1e-9\n\npolygon = []\npolygon.append(Point(0, 0));\npolygon.append(Point(2, 0));\npolygon.append(Point(2, 2));\npolygon.append(Point(0, 2));\npolygon.append(Point(0, 0));\npunto = Point(1, 1)\nif (inPolygon(punto, polygon)):\n    print(\"Si\")\nelse:\n    print(\"No\")\n",
    "orden": 7,
    "suborden": 28,
    "fecha_creacion": "2020-12-06 19:51:38",
    "fecha_modificacion": "2022-03-08 12:13:57"
  },
  {
    "ID": 206,
    "supergrupo": "Geometría",
    "tema": "Algoritmo lazo de zapato para áreas de polígonos",
    "texto": "Dadas las coordenadas ordenadas de un polígono con n vértices. Encuentra el área del polígono. Aquí ordenados significa que las coordenadas se dan en sentido horario o antihorario desde el primer vértice hasta el último.\nEjemplos:\nEntrada: X [] = {0, 4, 4, 0}, Y [] = {0, 0, 4, 4};\nSalida: 16\n\nEntrada: X [] = {0, 4, 2}, Y [] = {0, 0, 4}\nSalida: 8\nPodemos calcular el área de un polígono usando la fórmula de Cordones.\nArea: \n = | 1/2 [(x1y2 + x2y3 + ... + xn-1yn + xny1) -\n           (x2y1 + x3y2 + ... + xnyn-1 + x1yn)] |\n¿Por qué se llama Fórmula de cordones de zapatos?\nLa fórmula se llama así por la forma en que la evaluamos.\nEjemplo:\nDeje que los vértices de entrada sean\n (0, 1), (2, 3) y (4, 7).\n\nEl procedimiento de evaluación coincide con el proceso de vinculación\ncordones de zapatos.\n\nEscribimos vértices como se muestra a continuación\n  0 1\n  2 3\n  4 7\n  0 1 [escrito dos veces]\n\nevaluamos términos positivos como se muestra a continuación\n  0 \\ 1\n  2 \\ 3\n  4 \\ 7\n  0 1\nes decir, 0 * 3 + 2 * 7 + 4 * 1 = 18\n\nevaluamos los términos negativos de la siguiente manera\n  0 1\n  2/3\n  4/7\n  0/1\nes decir, 0 * 7 + 4 * 3 + 2 * 1 = 14\n\nÁrea = 1/2 (18 - 14) = 2\n¿Como funciona esto?\nSiempre podemos dividir un polígono en triángulos. La fórmula del área se obtiene tomando cada arista AB y calculando el área (con signo) del triángulo ABO con un vértice en el origen O, tomando el producto cruzado (que da el área de un paralelogramo) y dividiéndolo por 2. Como uno envuelve el polígono, estos triángulos con área positiva y negativa se superpondrán, y las áreas entre el origen y el polígono se cancelarán y sumarán 0, mientras que solo queda el área dentro del triángulo de referencia.\n",
    "complejidad_tiempo": null,
    "java": "// Programa Java para evaluar el área de un polígono usando la fórmula del cordón\n\npublic class ShoelacePoly {\n\n    // (X [i], Y [i]) son coordenadas del i-ésimo punto.\n    public static double polygonArea(double X[], double Y[],\n            int n) {\n        // Inicializar área\n        double area = 0.0;\n\n        // Calcular el valor de la fórmula del cordón\n        int j = n - 1;\n        for (int i = 0; i < n; i++) {\n            area += (X[j] + X[i]) * (Y[j] - Y[i]);\n\n            // j es el vértice anterior a i\n            j = i;\n        }\n\n        // Return valor absoluto\n        return Math.abs(area / 2.0);\n    }\n\n    public static void main(String[] args) {\n        double X[] = {0, 2, 4};\n        double Y[] = {1, 3, 7};\n\n        int n = 3;\n        System.out.println(polygonArea(X, Y, n));\n    }\n\n}\n",
    "cpp": "#include <bits/stdc++.h> \nusing namespace std;\n\ndouble polygonArea(double X[], double Y[], int n) {\n    double area = 0.0;\n\n    int j = n - 1;\n    for (int i = 0; i < n; i++) {\n        area += (X[j] + X[i]) * (Y[j] - Y[i]);\n        j = i;\n    }\n    return abs(area / 2.0);\n}\n\nint main() {\n    double X[] = {0, 2, 4};\n    double Y[] = {1, 3, 7};\n\n    int n = sizeof (X) / sizeof (X[0]);\n\n    cout << polygonArea(X, Y, n);\n} \n",
    "py": "def polygonArea(X, Y, n): \n    area = 0.0\n    j = n - 1\n    for i in range(0, n): \n        area += (X[j] + X[i]) * (Y[j] - Y[i]) \n    return int(abs(area / 2.0)) \n  \nX = [0, 2, 4] \nY = [1, 3, 7] \nn = len(X) \nprint(polygonArea(X, Y, n)) \n",
    "orden": 7,
    "suborden": 29,
    "fecha_creacion": "2020-12-06 19:51:38",
    "fecha_modificacion": "2022-03-08 12:13:57"
  },
  {
    "ID": 207,
    "supergrupo": "Geometría",
    "tema": "Números de cuadrados en un rectángulo ",
    "texto": "Dado un rectángulo de m x n, ¿cuántos cuadrados tiene?\nEjemplos:\nEntrada: m = 2, n = 2\nSalida: 5\nHay 4 cuadrados de tamaño 1x1 +\n           1 cuadrado de tamaño 2x2.\n\nEntrada: m = 4, n = 3\nSalida: 20\nHay 12 cuadrados de tamaño 1x1 +\n           6 cuadrados de tamaño 2x2 +\n           2 cuadrados de tamaño 3x3.\n\nResolvamos primero este problema para m = n, es decir, para un cuadrado:\nPara m = n = 1, salida: 1\nPara m = n = 2, salida: 4 + 1 [4 de tamaño 1 × 1 + 1 de tamaño 2 × 2]\nPara m = n = 3, salida: 9 + 4 + 1 [9 de tamaño 1 × 1 + 4 de tamaño 2 × 2 + 1 de tamaño 3 × 3]\nPara m = n = 4, salida 16 + 9 + 4 + 1 [16 de tamaño 1 × 1 + 9 de tamaño 2 × 2 + 4 de tamaño 3 × 3 + 1 de tamaño 4 × 4]\nEn general, parece ser n ^ 2 + (n-1) ^ 2 +… 1 = n (n + 1) (2n + 1) / 6\n\nResolvamos este problema cuando m puede no ser igual an:\nSupongamos que m <= n\n\nDe la explicación anterior, sabemos que el número de cuadrados en una matriz de m x m es m (m + 1) (2m + 1) / 6\n¿Qué sucede cuando agregamos una columna, es decir, cuál es el número de cuadrados en la matriz m x (m + 1)?\nCuando agregamos una columna, el número de cuadrados aumentados es m + (m-1) +… + 3 + 2 + 1\n[m cuadrados de tamaño 1 × 1 + (m-1) cuadrados de tamaño 2 × 2 +… + 1 cuadrado de tamaño m x m]\nQue es igual a m (m + 1) / 2\nEntonces, cuando agregamos (n-m) columnas, el número total de cuadrados aumentados es (n-m) * m (m + 1) / 2.\nEntonces, el número total de cuadrados es m (m + 1) (2m + 1) / 6 + (n-m) * m (m + 1) / 2.\nUsando la misma lógica podemos probar cuando n <= m.\nEntonces, en general,\nNúmero total de cuadrados = m x (m + 1) x (2m + 1) / 6 +\n                          (n-m) x m x (m + 1) / 2\n\ncuando n es una dimensión mayor\nUsando la lógica anterior para el rectángulo, también podemos probar que el número de cuadrados en un cuadrado es n (n + 1) (2n + 1) / 6\n",
    "complejidad_tiempo": null,
    "java": "// Programa Java para contar cuadrados en un rectángulo de tamaño m x n\n\npublic class NumberSquaresRectangle {\n\n    // Devuelve el recuento de todos los cuadrados \n    // en un rectángulo de tamaño m x n\n    static int countSquares(int m,\n            int n) {\n        // Si n es menor, intercambie my n\n        if (n < m) {\n            // intercambio (m, n)\n            int temp = m;\n            m = n;\n            n = temp;\n        }\n        // Ahora n es una dimensión mayor, aplica la fórmula\n        return m * (m + 1) * (2 * m + 1)\n                / 6 + (n - m) * m * (m + 1) / 2;\n    }\n\n    public static void main(String[] args) {\n        int m = 4, n = 3;\n        System.out.println(\"Count of squares is \"\n                + countSquares(m, n));\n    }\n}\n",
    "cpp": "#include<iostream> \nusing namespace std;\n\nint countSquares(int m, int n) {\n    if (n < m)\n        swap(m, n);\n    return m * (m + 1) * (2 * m + 1) /\n            6 + (n - m) * m * (m + 1) / 2;\n}\n\nint main() {\n    int m = 4, n = 3;\n    cout << \"Count of squares is \"\n            << countSquares(m, n);\n} \n",
    "py": "def countSquares(m, n): \n    if(n < m): \n        temp = m \n        m = n \n        n = temp \n    return ((m * (m + 1) * (2 * m + 1) / \n            6 + (n - m) * m * (m + 1) / 2)) \n  \nm = 4 \nn = 3\nprint(\"Count of squares is \", countSquares(m, n)) \n",
    "orden": 7,
    "suborden": 30,
    "fecha_creacion": "2020-12-06 19:51:38",
    "fecha_modificacion": "2022-03-08 12:13:57"
  },
  {
    "ID": 208,
    "supergrupo": "Geometría",
    "tema": "Algoritmo de Jarvis para cascos convexos",
    "texto": "Dado un conjunto de puntos en el plano. el casco convexo del conjunto es el polígono convexo más pequeño que contiene todos los puntos del mismo.\n \n¿Cómo verificar si dos segmentos de línea dados se cruzan?\nLa idea del algoritmo de Jarvis es simple, comenzamos desde el punto más a la izquierda (o punto con el valor mínimo de la coordenada x) y seguimos envolviendo puntos en dirección contraria a las agujas del reloj. La gran pregunta es, dado un punto p como punto actual, ¿cómo encontrar el siguiente punto en la salida? La idea es utilizar la orientación () aquí. El siguiente punto se selecciona como el punto que vence a todos los demás puntos en la orientación en sentido antihorario, es decir, el siguiente punto es q si para cualquier otro punto r, tenemos \"orientación (p, q, r) = en sentido antihorario\". A continuación se muestra el algoritmo detallado.\n1) Inicialice p como punto más a la izquierda.\n2) Haga lo siguiente mientras no regresemos al primer punto (o al extremo izquierdo).\n… ..A) El siguiente punto q es el punto tal que el triplete (p, q, r) es en sentido antihorario para cualquier otro punto r.\n… ..B) siguiente [p] = q (Almacenar q como siguiente de p en el casco convexo de salida).\n… ..C) p = q (Establecer p como q para la siguiente iteración).\n\nComplejidad del tiempo: para cada punto del casco, examinamos todos los demás puntos para determinar el siguiente. La complejidad del tiempo es? (M * n) donde n es el número de puntos de entrada y m es el número de puntos de salida o de casco (m <= n). En el peor de los casos, la complejidad del tiempo es O (n 2). El peor caso ocurre cuando todos los puntos están en el casco (m = n)\n\n",
    "complejidad_tiempo": null,
    "java": "// Programa Java para encontrar el casco convexo de un conjunto de puntos.\n\nimport java.util.*;\n\nclass ConvexHullJarvis {\n\n    static class Point {\n\n        int x, y;\n\n        Point(int x, int y) {\n            this.x = x;\n            this.y = y;\n        }\n    }\n\n    // Encontrar la orientación del triplete ordenado (p, q, r). \n    // La función devuelve los siguientes valores\n    // 0 -> p, q y r son colineales\n    // 1 -> En sentido horario\n    // 2 -> en sentido antihorario\n    public static int orientation(Point p, Point q, Point r) {\n        int val = (q.y - p.y) * (r.x - q.x)\n                - (q.x - p.x) * (r.y - q.y);\n\n        if (val == 0) {\n            return 0;  // collinear \n        }\n        return (val > 0) ? 1 : 2; // reloj o en sentido antihorario\n    }\n\n    // Imprime el casco convexo de un conjunto de n puntos.\n    public static void convexHull(Point points[], int n) {\n        // Debe haber al menos 3 puntos\n        if (n < 3) {\n            return;\n        }\n\n        // Inicializar resultado\n        ArrayList<Point> hull = new ArrayList<>();\n\n        // Encuentra el punto más a la izquierda\n        int l = 0;\n        for (int i = 1; i < n; i++) {\n            if (points[i].x < points[l].x) {\n                l = i;\n            }\n        }\n\n        // Comience desde el punto más a la izquierda, continúe \n        // moviéndose en sentido antihorario hasta llegar al punto de \n        // inicio nuevamente. Este ciclo se ejecuta O (h) veces donde h \n        // es el número de puntos en el resultado o la salida. \n        int p = l, q;\n        do {\n            // Agregar el punto actual al resultado\n            hull.add(points[p]);\n\n            // Busque un punto 'q' tal que la orientación (p, x, q) sea \n            // en sentido antihorario para todos los puntos 'x'. La idea es \n            // realizar un seguimiento del último punto visitado más en sentido \n            // antihorario en q. Si algún punto 'i' está más en sentido \n            // contrario a las agujas del reloj que q, actualice q.\n            q = (p + 1) % n;\n\n            for (int i = 0; i < n; i++) {\n                // Si i está más en sentido antihorario que la q actual, actualice q\n                if (orientation(points[p], points[i], points[q])\n                        == 2) {\n                    q = i;\n                }\n            }\n\n            // Ahora q es el más en sentido antihorario con respecto a p.\n            // Establezca p como q para la próxima iteración, de modo que \n            // q se agregue al resultado 'casco'\n            p = q;\n\n        } while (p != l);  // Mientras no llegamos primer point \n\n        // Print Result \n        for (Point temp : hull) {\n            System.out.println(\"(\" + temp.x + \", \"\n                    + temp.y + \")\");\n        }\n    }\n\n    public static void main(String[] args) {\n        Point points[] = new Point[7];\n        points[0] = new Point(0, 3);\n        points[1] = new Point(2, 3);\n        points[2] = new Point(1, 1);\n        points[3] = new Point(2, 1);\n        points[4] = new Point(3, 0);\n        points[5] = new Point(0, 0);\n        points[6] = new Point(3, 3);\n        int n = points.length;\n        convexHull(points, n);\n    }\n}\n",
    "cpp": "#include <bits/stdc++.h> \nusing namespace std;\n\nstruct Point {\n    int x, y;\n};\n\nint orientation(Point p, Point q, Point r) {\n    int val = (q.y - p.y) * (r.x - q.x) -\n            (q.x - p.x) * (r.y - q.y);\n\n    if (val == 0) return 0;\n    return (val > 0) ? 1 : 2;\n}\n\nvoid convexHull(Point points[], int n) {\n\n    if (n < 3) return;\n    vector<Point> hull;\n    int l = 0;\n    for (int i = 1; i < n; i++)\n        if (points[i].x < points[l].x)\n            l = i;\n\n    int p = l, q;\n    do {\n\n        hull.push_back(points[p]);\n\n        q = (p + 1) % n;\n        for (int i = 0; i < n; i++) {\n            if (orientation(points[p], points[i], points[q]) == 2)\n                q = i;\n        }\n\n        p = q;\n\n    } while (p != l);\n\n    for (int i = 0; i < hull.size(); i++)\n        cout << \"(\" << hull[i].x << \", \"\n            << hull[i].y << \")\\n\";\n}\n\nint main() {\n    Point points[] = {\n        {0, 3},\n        {2, 2},\n        {1, 1},\n        {2, 1},\n        {3, 0},\n        {0, 0},\n        {3, 3}\n    };\n    int n = sizeof (points) / sizeof (points[0]);\n    convexHull(points, n);\n    return 0;\n} \n",
    "py": "class Point: \n    def __init__(self, x, y): \n        self.x = x \n        self.y = y \n  \ndef Left_index(points): \n      \n    minn = 0\n    for i in range(1, len(points)): \n        if points[i].x < points[minn].x: \n            minn = i \n        elif points[i].x == points[minn].x: \n            if points[i].y > points[minn].y: \n                minn = i \n    return minn \n  \ndef orientation(p, q, r): \n    val = (q.y - p.y) * (r.x - q.x) - \\ (q.x - p.x) * (r.y - q.y) \n    if val == 0: \n        return 0\n    elif val > 0: \n        return 1\n    else: \n        return 2\n  \ndef convexHull(points, n): \n    if n < 3: \n        return\n    l = Left_index(points) \n    hull = [] \n    p = l \n    q = 0\n    while(True): \n        hull.append(p) \n        q = (p + 1) % n \n        for i in range(n): \n            if(orientation(points[p], \n               points[i], points[q]) == 2): \n                q = i \n        p = q \n        if(p == l): \n            break\n \n    for each in hull: \n        print(points[each].x, points[each].y) \n  \npoints = [] \npoints.append(Point(0, 3)) \npoints.append(Point(2, 2)) \npoints.append(Point(1, 1)) \npoints.append(Point(2, 1)) \npoints.append(Point(3, 0)) \npoints.append(Point(0, 0)) \npoints.append(Point(3, 3)) \nconvexHull(points, len(points)) \n",
    "orden": 7,
    "suborden": 31,
    "fecha_creacion": "2020-12-06 19:51:38",
    "fecha_modificacion": "2022-03-08 14:36:15"
  },
  {
    "ID": 209,
    "supergrupo": "Strings",
    "tema": "Algoritmo Z",
    "texto": "Este algoritmo encuentra todas las apariciones de un patrón en un texto en tiempo lineal. Deje que la longitud del texto sea n y el patrón sea m, entonces el tiempo total tomado es O (m + n) con complejidad de espacio lineal. Ahora podemos ver que la complejidad del tiempo y el espacio es la misma que la del algoritmo KMP, pero este algoritmo es más simple de entender.\nEn este algoritmo, construimos una array Z.\n¿Qué es Z Array?\nPara una cadena str [0..n-1], la array Z tiene la misma longitud que la cadena. Un elemento Z [i] de la array Z almacena la longitud de la subcadena más larga a partir de str [i], que también es un prefijo de str [0..n-1]. La primera entrada de la array Z significa menos, ya que la cadena completa siempre es un prefijo de sí misma.\nEjemplo:\nÍndice 0 1 2 3 4 5 6 7 8 9 10 11\nTexto a a b c a a b x a a a z\nValores Z X 1 0 0 3 1 0 0 2 2 1 0\nMás ejemplos:\nstr = \"aaaaaa\"\nZ [] = {x, 5, 4, 3, 2, 1}\n\nstr = \"aabaacd\"\nZ [] = {x, 1, 0, 2, 1, 0, 0}\n\nstr = \"abababab\"\nZ [] = {x, 0, 6, 0, 4, 0, 2, 0}\n \n¿Cómo es útil la array Z en la búsqueda de patrones en tiempo lineal?\nLa idea es concatenar patrón y texto, y crear una cadena “P $ T” donde P es patrón, $ es un carácter especial que no debe estar presente en patrón y texto, y T es texto. Construya la array Z para cadenas concatenadas. En la array Z, si el valor Z en cualquier punto es igual a la longitud del patrón, entonces el patrón está presente en ese punto.\nEjemplo:\nPatrón P = \"aab\", Texto T = \"baabaa\"\n\nLa cadena concatenada es = \"aab $ baabaa\"\n\nLa array Z para la cadena concatenada anterior es {x, 1, 0, 0, 0,\n                                          3, 1, 0, 2, 1}.\nDado que la longitud del patrón es 3, el valor 3 en la array Z\nindica presencia de patrón.\n¿Cómo construir una array Z?\n     Una solución simple consiste en ejecutar dos bucles anidados, el bucle externo va a cada índice y el bucle interno encuentra la longitud del prefijo más largo que coincide con la subcadena que comienza en el índice actual. La complejidad temporal de esta solución es O (n2).\n\n      Podemos construir una array Z en tiempo lineal.\nLa idea es mantener un intervalo [L, R] que es el intervalo con el máximo R\ntal que [L, R] es una subcadena de prefijo (subcadena que también es prefijo).\n\nLos pasos para mantener este intervalo son los siguientes:\n\n1) Si i> R entonces no hay subcadena de prefijo que comience antes de i y\n   termina después de i, por lo que restablecemos L y R y calculamos nuevo [L, R] comparando\n   str [0 ..] a str [i ..] y obtener Z [i] (= R-L + 1).\n\n2) Si i <= R entonces sea K = i-L, ahora Z [i]> = min (Z [K], R-i + 1) porque\n   str [i ..] coincide con str [K ..] para al menos R-i + 1 caracteres (están en\n   [L, R] intervalo que sabemos que es una subcadena de prefijo).\n   Ahora surgen dos sub casos:\n      a) Si Z [K] <R-i + 1 entonces no hay una subcadena de prefijo que comience en\n         str [i] (de lo contrario Z [K] sería más grande) entonces Z [i] = Z [K] y\n         el intervalo [L, R] permanece igual.\n      b) Si Z [K]> = R-i + 1 entonces es posible extender el intervalo [L, R]\n         por lo tanto, estableceremos L como i y comenzaremos a emparejar desde str [R] en adelante y\n         obtener un nuevo R, entonces actualizaremos el intervalo [L, R] y calcularemos Z [i] (= R-L + 1).\nEl algoritmo se ejecuta en tiempo lineal porque nunca comparamos caracteres menores que R y con la coincidencia aumentamos R en uno para que haya como máximo comparaciones T. En el caso de desajuste, el desajuste ocurre solo una vez para cada i (debido a que R se detiene), esa es otra comparación como máximo de T que genera complejidad lineal general.\n",
    "complejidad_tiempo": null,
    "java": "// Un programa Java que implementa el algoritmo Z para la búsqueda de patrones\n\npublic class Zalgorithm {\n\n    // imprime todas las apariciones del patrón en el texto usando algo Z\n    public static void search(String text, String pattern) {\n        // Crear cadena concatenada \"P $ T\"\n        String concat = pattern + \"$\" + text;\n        int l = concat.length();\n\n        int Z[] = new int[l];\n        // Construir matriz Z\n        getZarr(concat, Z);\n\n        // ahora recorriendo la matriz Z para la condición coincidente\n        for (int i = 0; i < l; ++i) {\n            // si Z [i] (región coincidente) es igual al patrón\n            // longitud tenemos el patrón\n            if (Z[i] == pattern.length()) {\n                System.out.println(\"Pattern found at index \"\n                        + (i - pattern.length() - 1));\n            }\n        }\n    }\n\n    // Rellena la matriz Z para una cadena determinada str [] \n    private static void getZarr(String str, int[] Z) {\n\n        int n = str.length();\n\n        // [L, R] crea una ventana que coincida con el prefijo de s\n        int L = 0, R = 0;\n\n        for (int i = 1; i < n; ++i) {\n            // si i> R nada coincide, entonces calcularemos. Z [i] de manera ingenua.\n            if (i > R) {\n                L = R = i;\n                // R-L = 0 en el inicio, por lo que comenzará a verificar desde \n                // el índice 0. Por ejemplo, para \"ababab\" ei = 1, el valor de \n                // R sigue siendo 0 y Z [i] se convierte en 0. \n                // Para la cadena \"aaaaaa\" e i = 1, Z [i] y R se convierten en 5\n                while (R < n && str.charAt(R - L) == str.charAt(R)) {\n                    R++;\n                }\n\n                Z[i] = R - L;\n                R--;\n\n            } else {\n\n                // k = i-L entonces k corresponde al número que coincide en el intervalo [L, R].\n                int k = i - L;\n                // si Z [k] es menor que el intervalo restante, entonces Z [i] \n                // será igual a Z [k]. Por ejemplo, str = \"ababab\", \n                // i = 3, R = 5 y L = 2\n                if (Z[k] < R - i + 1) {\n                    Z[i] = Z[k];\n                } // Por ejemplo, str = \"aaaaaa\" e i = 2, R es 5,\n                // L es 0 \n                else {\n                    // de lo contrario, comience desde R y verifique manualmente\n                    L = i;\n                    while (R < n && str.charAt(R - L) == str.charAt(R)) {\n                        R++;\n                    }\n\n                    Z[i] = R - L;\n                    R--;\n                }\n            }\n        }\n    }\n\n    public static void main(String[] args) {\n        String text = \"GEEKS FOR GEEKS\";\n        String pattern = \"GEEK\";\n        search(text, pattern);\n    }\n}\n",
    "cpp": "#include<iostream> \nusing namespace std;\n\nvoid getZarr(string str, int Z[]);\n\nvoid search(string text, string pattern) {\n    string concat = pattern + \"$\" + text;\n    int l = concat.length();\n\n    int Z[l];\n    getZarr(concat, Z);\n\n    for (int i = 0; i < l; ++i) {\n        if (Z[i] == pattern.length())\n            cout << \"Pattern found at index \"\n                << i - pattern.length() - 1 << endl;\n    }\n}\n\nvoid getZarr(string str, int Z[]) {\n    int n = str.length();\n    int L, R, k;\n    L = R = 0;\n    for (int i = 1; i < n; ++i) {\n\n        if (i > R) {\n            L = R = i;\n            while (R < n && str[R - L] == str[R])\n                R++;\n            Z[i] = R - L;\n            R--;\n        } else {\n            k = i - L;\n            if (Z[k] < R - i + 1)\n                Z[i] = Z[k];\n            else {\n                L = i;\n                while (R < n && str[R - L] == str[R])\n                    R++;\n                Z[i] = R - L;\n                R--;\n            }\n        }\n    }\n}\n\nint main() {\n    string text = \"GEEKS FOR GEEKS\";\n    string pattern = \"GEEK\";\n    search(text, pattern);\n    return 0;\n}\n",
    "py": "def getZarr(string, z): \n    n = len(string) \n    l, r, k = 0, 0, 0\n    for i in range(1, n): \n        if i > r: \n            l, r = i, i \n            while r < n and string[r - l] == string[r]: \n                r += 1\n            z[i] = r - l \n            r -= 1\n        else: \n\n            k = i - l \n            if z[k] < r - i + 1: \n                z[i] = z[k] \n            else: \n                l = i \n                while r < n and string[r - l] == string[r]: \n                    r += 1\n                z[i] = r - l \n                r -= 1\n\ndef search(text, pattern): \n    concat = pattern + \"$\" + text \n    l = len(concat) \n    z = [0] * l \n    getZarr(concat, z) \n    for i in range(l): \n        if z[i] == len(pattern): \n            print(\"Pattern found at index\", \n                  i - len(pattern) - 1) \n\ntext = \"GEEKS FOR GEEKS\"\npattern = \"GEEK\"\nsearch(text, pattern) \n",
    "orden": 5,
    "suborden": 6,
    "fecha_creacion": "2020-12-06 19:51:39",
    "fecha_modificacion": "2022-03-08 12:17:06"
  },
  {
    "ID": 210,
    "supergrupo": "Strings",
    "tema": "Supersecuencia común más corta",
    "texto": "Dadas dos cadenas str1 y str2, la tarea es encontrar la longitud de la cadena más corta que tiene str1 y str2 como subsecuencias.\nEjemplos:\nEntrada: str1 = \"geek\", str2 = \"eke\"\nSalida: 5\nExplicación:\nLa cadena \"geeke\" tiene ambas cadenas \"geek\"\ny \"eke\" como subsecuencias.\n\nEntrada: str1 = \"AGGTAB\", str2 = \"GXTXAYB\"\nSalida: 9\nExplicación:\nLa cadena \"AGXGTXAYB\" tiene ambas cadenas\n\"AGGTAB\" y \"GXTXAYB\" como subsecuencias.\nEste problema está estrechamente relacionado con el problema de subsecuencia común más largo. A continuación se muestran los pasos.\n1) Encuentre la subsecuencia común más larga (lcs) de dos cadenas dadas. Por ejemplo, lcs de \"geek\" y \"eke\" es \"ek\".\n2) Inserte caracteres que no sean lcs (en su orden original en cadenas) en los lcs que se encuentran arriba y devuelva el resultado. Entonces \"ek\" se convierte en \"geeke\", que es la supersecuencia común más corta.\nConsideremos otro ejemplo, str1 = \"AGGTAB\" y str2 = \"GXTXAYB\". LCS de str1 y str2 es \"GTAB\". Una vez que encontramos LCS, insertamos caracteres de ambas cadenas en orden y obtenemos \"AGXGTXAYB\"\n\n¿Como funciona esto?\nNecesitamos encontrar una cadena que tenga ambas cadenas como subsecuencias y que sea la más corta. Si ambas cadenas tienen todos los caracteres diferentes, el resultado es la suma de longitudes de dos cadenas dadas. Si hay caracteres comunes, no los queremos varias veces, ya que la tarea es minimizar la longitud. Por lo tanto, primero encontramos la subsecuencia común más larga, tomamos una aparición de esta subsecuencia y agregamos caracteres adicionales.\nDuración de la supersecuencia más corta\n= (Suma de longitudes de dos cadenas dadas)\n- (Longitud de LCS de dos cadenas dadas)\n\nComplejidad temporal de la solución anterior exponencial O (2min (m, n)). Dado que hay subproblemas superpuestos, podemos resolver este problema recursivo de manera eficiente utilizando la programación dinámica. A continuación se muestra la implementación basada en programación dinámica. La complejidad temporal de esta solución es O (mn).\n",
    "complejidad_tiempo": null,
    "java": "// Un programa Java basado en programación dinámica para encontrar \n// la longitud de la supersecuencia más corta\n\npublic class ShortestCommonSupersequence {\n\n    // Devuelve la longitud de la supersecuencia más corta de X e Y\n    static int superSeq(String X, String Y,\n            int m, int n) {\n        int[][] dp = new int[m + 1][n + 1];\n\n        // Llene la tabla de abajo hacia arriba\n        for (int i = 0; i <= m; i++) {\n            for (int j = 0; j <= n; j++) {\n                // Los pasos siguientes siguen la recurrencia anterior\n                if (i == 0) {\n                    dp[i][j] = j;\n                } else if (j == 0) {\n                    dp[i][j] = i;\n                } else if (X.charAt(i - 1) == Y.charAt(j - 1)) {\n                    dp[i][j] = 1 + dp[i - 1][j - 1];\n                } else {\n                    dp[i][j] = 1 + Math.min(dp[i - 1][j],\n                            dp[i][j - 1]);\n                }\n            }\n        }\n\n        return dp[m][n];\n    }\n\n    public static void main(String args[]) {\n        String X = \"AGGTAB\";\n        String Y = \"GXTXAYB\";\n        System.out.println(\"Length of the shortest supersequence is \"\n                + superSeq(X, Y, X.length(), Y.length()));\n    }\n}\n",
    "cpp": "#include<bits/stdc++.h> \nusing namespace std;\n\nint superSeq(char* X, char* Y, int m, int n) {\n    int dp[m + 1][n + 1];\n    for (int i = 0; i <= m; i++) {\n        for (int j = 0; j <= n; j++) {\n            if (!i)\n                dp[i][j] = j;\n            else if (!j)\n                dp[i][j] = i;\n            else if (X[i - 1] == Y[j - 1])\n                dp[i][j] = 1 + dp[i - 1][j - 1];\n            else\n                dp[i][j] = 1 + min(dp[i - 1][j],\n                    dp[i][j - 1]);\n        }\n    }\n\n    return dp[m][n];\n}\n\nint main() {\n    char X[] = \"AGGTAB\";\n    char Y[] = \"GXTXAYB\";\n    cout << \"Length of the shortest supersequence is \"\n            << superSeq(X, Y, strlen(X), strlen(Y));\n    return 0;\n}\n",
    "py": "def superSeq(X, Y, m, n): \n    dp = [[0] * (n + 2) for i in range(m + 2)] \n    for i in range(m + 1): \n        for j in range(n + 1): \n            if (not i): dp[i][j] = j \n            elif (not j): dp[i][j] = i \n                        \n            elif (X[i - 1] == Y[j - 1]): \n                dp[i][j] = 1 + dp[i - 1][j - 1] \n                                \n            else: dp[i][j] = 1 + min(dp[i - 1][j], \n                                     dp[i][j - 1])              \n    return dp[m][n] \n\nX = \"AGGTAB\"\nY = \"GXTXAYB\"\nprint(\"Length of the shortest supersequence is %d\"\n      % superSeq(X, Y, len(X), len(Y))) \n",
    "orden": 5,
    "suborden": 7,
    "fecha_creacion": "2020-12-06 19:51:39",
    "fecha_modificacion": "2022-03-08 12:17:06"
  },
  {
    "ID": 211,
    "supergrupo": "Strings",
    "tema": "Trie",
    "texto": "Trie es una estructura de datos de recuperación de información eficiente. Con Trie, las complejidades de la búsqueda se pueden llevar al límite óptimo (longitud de la clave). Si almacenamos claves en un árbol de búsqueda binario, un BST bien balanceado necesitará un tiempo proporcional a M * log N, donde M es la longitud máxima de la cadena y N es el número de claves en el árbol. Usando Trie, podemos buscar la clave en tiempo O (M). Sin embargo, la penalización está en los requisitos de almacenamiento de Trie.\n \nCada nodo de Trie consta de múltiples ramas. Cada rama representa un posible carácter de claves. Necesitamos marcar el último nodo de cada clave como nodo de fin de palabra. Un campo de nodo Trie isEndOfWord se utiliza para distinguir el nodo como nodo de fin de palabra. Una estructura simple para representar nodos del alfabeto inglés puede ser la siguiente:\n\n// Trie nodo\nestructura TrieNode\n{\n     struct TrieNode * children [ALPHABET_SIZE];\n     // isEndOfWord es verdadero si el nodo\n     // representa el final de una palabra\n     bool isEndOfWord;\n};\nInsertar una llave en Trie es un enfoque simple. Cada carácter de la clave de entrada se inserta como un nodo Trie individual. Tenga en cuenta que los niños son una matriz de punteros (o referencias) a los nodos de prueba del siguiente nivel. El carácter clave actúa como un índice en los hijos de la matriz. Si la clave de entrada es nueva o una extensión de la clave existente, necesitamos construir nodos no existentes de la clave y marcar el final de la palabra para el último nodo. Si la clave de entrada es un prefijo de la clave existente en Trie, simplemente marcamos el último nodo de la clave como el final de una palabra. La longitud de la clave determina la profundidad de Trie.\n\nLa búsqueda de una clave es similar a la operación de inserción, sin embargo, solo comparamos los caracteres y nos movemos hacia abajo. La búsqueda puede terminar debido al final de una cadena o la falta de clave en el trie. En el primer caso, si el campo isEndofWord del último nodo es verdadero, entonces la clave existe en el trie. En el segundo caso, la búsqueda termina sin examinar todos los caracteres de la clave, ya que la clave no está presente en el trie.\nLa siguiente imagen explica la construcción de trie utilizando las claves que se dan en el ejemplo siguiente,\n                       raíz\n                    / \\ \\\n                    t a b\n                    | | |\n                    h n y\n                    | | \\ |\n                    e s y e\n                 / | |\n                 yo r w\n                 | | |\n                 r e e\n                        |\n                        r\nEn la imagen, cada carácter es de tipo trie_node_t. Por ejemplo, la raíz es de tipo trie_node_t, y sus hijos a, byt están llenos, todos los demás nodos de la raíz serán NULL. De manera similar, \"a\" en el siguiente nivel es tener un solo hijo (\"n\"), todos los demás hijos son NULL. Los nodos de las hojas están en azul.\nInsertar y buscar cuesta O (key_length), sin embargo, los requisitos de memoria de Trie es O (ALPHABET_SIZE * key_length * N) donde N es el número de claves en Trie. Hay una representación eficiente de los nodos trie (por ejemplo, trie comprimido, árbol de búsqueda ternario, etc.) para minimizar los requisitos de memoria de trie.\n\nTries es un árbol que almacena cuerdas. El número máximo de hijos de un nodo es igual al tamaño del alfabeto. Trie admite operaciones de búsqueda, inserción y eliminación en tiempo O (L) donde L es la longitud de la clave.\nHashing: - En hash, convertimos la clave a un valor pequeño y el valor se usa para indexar datos. El hash admite operaciones de búsqueda, inserción y eliminación en tiempo O (L) en promedio.\nBST autoequilibrado: la complejidad temporal de las operaciones de búsqueda, inserción y eliminación en un árbol de búsqueda binaria (BST) autoequilibrado (como árbol rojo-negro, árbol AVL, árbol de expansión, etc.) es O (L + Log n) donde n es el número total de palabras y L es la longitud de la palabra. La ventaja de los BST autoequilibrantes es que mantienen el orden, lo que hace que las operaciones como mínimo, máximo, más cercano (piso o techo) y k-ésimo sean más rápidas.\n\n¿Por qué Trie? : -\n1. Con Trie, podemos insertar y encontrar cadenas en tiempo O (L) donde L representa la longitud de una sola palabra. Obviamente, esto es más rápido que BST. Esto también es más rápido que Hashing debido a la forma en que se implementa. No necesitamos calcular ninguna función hash. No se requiere manejo de colisiones (como lo hacemos en direccionamiento abierto y encadenamiento separado)\n2. Otra ventaja de Trie es que podemos imprimir fácilmente todas las palabras en orden alfabético, lo que no es posible con hash.\n3. Podemos realizar búsquedas de prefijos (o autocompletar) de manera eficiente con Trie.\n\nProblemas con Trie: \nLa principal desventaja de los intentos es que necesitan mucha memoria para almacenar las cadenas. Para cada nodo tenemos demasiados punteros de nodo (igual al número de caracteres del alfabeto), si se trata de espacio, entonces el Árbol de búsqueda ternario puede ser preferido para implementaciones de diccionario. En Ternary Search Tree, la complejidad temporal de la operación de búsqueda es O (h) donde h es la altura del árbol. Ternary Search Trees también admite otras operaciones compatibles con Trie, como la búsqueda de prefijos, la impresión en orden alfabético y la búsqueda de vecinos más cercanos.\nLa conclusión final con respecto a la estructura de datos de los intentos es que son más rápidos pero requieren una gran memoria para almacenar las cadenas.\n",
    "complejidad_tiempo": null,
    "java": "// Implementación Java de operaciones de búsqueda e inserción en Trie \n\npublic class Trie {\n\n    // Tamaño del alfabeto (número de símbolos)\n    static final int ALPHABET_SIZE = 26;\n\n    // nodo trie\n    static class TrieNode {\n\n        TrieNode[] children = new TrieNode[ALPHABET_SIZE];\n\n        // isEndOfWord es verdadero si el nodo representa el final de una palabra\n        boolean isEndOfWord;\n\n        TrieNode() {\n            isEndOfWord = false;\n            for (int i = 0; i < ALPHABET_SIZE; i++) {\n                children[i] = null;\n            }\n        }\n    };\n\n    static TrieNode root;\n\n    // Si no está presente, inserta la clave en trie \n    // Si la clave es el prefijo del nodo trie, solo marca el nodo hoja\n    static void insert(String key) {\n        int level;\n        int length = key.length();\n        int index;\n\n        TrieNode pCrawl = root;\n\n        for (level = 0; level < length; level++) {\n            index = key.charAt(level) - 'a';\n            if (pCrawl.children[index] == null) {\n                pCrawl.children[index] = new TrieNode();\n            }\n\n            pCrawl = pCrawl.children[index];\n        }\n\n        // marcar el último nodo como hoja\n        pCrawl.isEndOfWord = true;\n    }\n\n    // // Devuelve verdadero si la clave está presente en verdadero, de lo contrario es falso\n    static boolean search(String key) {\n        int level;\n        int length = key.length();\n        int index;\n        TrieNode pCrawl = root;\n\n        for (level = 0; level < length; level++) {\n            index = key.charAt(level) - 'a';\n\n            if (pCrawl.children[index] == null) {\n                return false;\n            }\n\n            pCrawl = pCrawl.children[index];\n        }\n\n        return (pCrawl != null && pCrawl.isEndOfWord);\n    }\n\n    public static void main(String args[]) {\n        // Datos de entrada (use solo 'a' a 'z' y minúsculas)\n        String keys[] = {\"the\", \"a\", \"there\", \"answer\", \"any\",\n            \"by\", \"bye\", \"their\"};\n\n        String output[] = {\"Not present in trie\", \"Present in trie\"};\n\n        root = new TrieNode();\n\n        // Construir trie\n        int i;\n        for (i = 0; i < keys.length; i++) {\n            insert(keys[i]);\n        }\n\n        // Buscar diferentes claves \n        if (search(\"the\") == true) {\n            System.out.println(\"the --- \" + output[1]);\n        } else {\n            System.out.println(\"the --- \" + output[0]);\n        }\n\n        if (search(\"these\") == true) {\n            System.out.println(\"these --- \" + output[1]);\n        } else {\n            System.out.println(\"these --- \" + output[0]);\n        }\n\n        if (search(\"their\") == true) {\n            System.out.println(\"their --- \" + output[1]);\n        } else {\n            System.out.println(\"their --- \" + output[0]);\n        }\n\n        if (search(\"thaw\") == true) {\n            System.out.println(\"thaw --- \" + output[1]);\n        } else {\n            System.out.println(\"thaw --- \" + output[0]);\n        }\n\n    }\n}\n",
    "cpp": "#include <iostream> \n#include <memory> \n\nusing namespace std;\n#define ALPHABET_SIZE 26 \n\nclass TrieNode { \npublic:\n    shared_ptr<TrieNode> children[ALPHABET_SIZE];\n\n    bool isWord;\n\n    TrieNode() {\n        for (int i = 0; i < ALPHABET_SIZE; i++) {\n            children[i] = shared_ptr<TrieNode>();\n        }\n        isWord = false;\n    }\n};\n\n\n\n\nclass Trie  {     \n    shared_ptr<TrieNode> root;\n    int Total_words;\n\npublic:\n    Trie() {\n        root = shared_ptr<TrieNode>\n                (new TrieNode());\n        Total_words = 0;\n    }\n\n    ~Trie() {\n    }\n\n    int i2c(char c) {\n        return static_cast<int> (c - 'a');\n    }\n\n    void insertWord(string& trieString) {\n        shared_ptr<TrieNode> current = root;\n        for (int i = 0; i < trieString.size(); i++) {\n\n            if (current->children[i2c(trieString[i])] ==\n                    shared_ptr<TrieNode>(nullptr)) {\n                current->children[i2c(trieString[i])] =\n                        shared_ptr<TrieNode>(new TrieNode());\n            }\n            current = (current->children[i2c(trieString[i])]);\n        } \n        current->isWord = true;\n    }\n\n\n    bool searchWord(string& trieString) {\n        shared_ptr<TrieNode> current = root;\n\n        for (int i = 0; i < trieString.size(); i++) {\n\n            if (current->children[i2c(trieString[i])] ==\n                    shared_ptr<TrieNode>(nullptr))\n                return false;\n            current = current->children[i2c(trieString[i])];\n        }\n\n        if (current->isWord == true)\n            return true;\n\n        return false;\n    }\n\n    bool Partdelete(string& trieString, shared_ptr<TrieNode>&\n            checkout) {\n\n        if (checkout == nullptr)\n            return false;\n\n        if (trieString.size() == 0) {\n            if (checkout->isWord == true) {\n                checkout->isWord = false;\n                return true;\n            }\n            return false;\n        }\n\n        string part = trieString.substr(1);\n\n        if (Partdelete(part, checkout->\n                children[i2c(trieString[0])])) {\n\n            if (isEmptyNode(checkout->\n                    children[i2c(trieString[0])])) {\n                checkout->children[i2c(trieString[0])].\n                        reset();\n\n                checkout->children[i2c(trieString[0])] =\n                        nullptr;\n\n                return true;\n            }\n            else\n                return true;\n        }\n        else\n            return false;\n\n        return false;\n    }\n\n\n    bool deleteWord(string& trieString) {\n        if (Partdelete(trieString, root))\n            return true;\n        return false;\n    }\n\n    bool isEmptyNode(shared_ptr<TrieNode> check) const {\n        for (int i = 0; i < ALPHABET_SIZE; i++) {\n            if (check->children[i] != nullptr ||\n                    check->isWord == true)\n                return false;\n        }\n        return true;\n    }\n};\n\n\nint main() {\n    shared_ptr<Trie> myTrie(new Trie());\n\n    string word1 = \"geeksfor\";\n    string word2 = \"geeksforgeeks\";\n    string word3 = \"nothing\";\n\n    myTrie->insertWord(word1);\n\n    if (myTrie->searchWord(word1))\n        cout << word1 << \": Is Present\" << endl;\n    else\n        cout << word1 << \": Not Present\" << endl;\n\n    if (myTrie->searchWord(word3))\n        cout << word3 << \": Is Present\" << endl;\n    else\n        cout << word3 << \": Not Present\" << endl;\n\n    myTrie->insertWord(word2);\n\n    if (myTrie->deleteWord(word2))\n        cout << word2 << \": Successfully deleted\" << endl;\n    else\n        cout << word2 << \": Not Present\" << endl;\n\n    if (myTrie->searchWord(word2))\n        cout << word2 << \": Is Present\" << endl;\n    else\n        cout << word2 << \": Not Present\" << endl;\n\n}\n",
    "py": "class TrieNode: \n    def __init__(self): \n        self.children = [None] * 26\n\n        self.isEndOfWord = False\n\nclass Trie: \n    def __init__(self): \n        self.root = self.getNode() \n\n    def getNode(self): \n        return TrieNode() \n\n    def _charToIndex(self, ch): \n        return ord(ch)-ord('a') \n\n\n    def insert(self, key): \n                \n        pCrawl = self.root \n        length = len(key) \n        for level in range(length): \n            index = self._charToIndex(key[level]) \n\n            if not pCrawl.children[index]: \n                pCrawl.children[index] = self.getNode() \n            pCrawl = pCrawl.children[index] \n\n        pCrawl.isEndOfWord = True\n\n    def search(self, key): \n                 \n        pCrawl = self.root \n        length = len(key) \n        for level in range(length): \n            index = self._charToIndex(key[level]) \n            if not pCrawl.children[index]: \n                return False\n            pCrawl = pCrawl.children[index] \n\n        return pCrawl != None and pCrawl.isEndOfWord \n\ndef main(): \n\n    keys = [\"the\", \"a\", \"there\", \"anaswe\", \"any\", \n        \"by\", \"their\"] \n    output = [\"Not present in trie\", \n        \"Present in trie\"] \n    t = Trie() \n    for key in keys: \n        t.insert(key) \n    print(\"{} ---- {}\".format(\"the\", output[t.search(\"the\")])) \n    print(\"{} ---- {}\".format(\"these\", output[t.search(\"these\")])) \n    print(\"{} ---- {}\".format(\"their\", output[t.search(\"their\")])) \n    print(\"{} ---- {}\".format(\"thaw\", output[t.search(\"thaw\")])) \n\nmain() \n",
    "orden": 5,
    "suborden": 8,
    "fecha_creacion": "2020-12-06 19:51:39",
    "fecha_modificacion": "2022-03-08 12:17:06"
  },
  {
    "ID": 212,
    "supergrupo": "Strings",
    "tema": "Hash polinómico",
    "texto": "¿Qué es String-Hashing?\nEl hash de cadena es la forma de convertir una cadena en un número entero conocido como hash de esa cadena.\nUn hash ideal es aquel en el que existen mínimas posibilidades de colisión (es decir, 2 cadenas diferentes que tienen el mismo hash).\nFunción hash polinomial rodante\nEn esta técnica de hash, el hash de una cadena se calcula como: \nDonde P y M son algunos números positivos. Y s [0], s [1], s [2]… s [n-1] son los valores asignados a cada carácter en el alfabeto inglés (a-> 1, b-> 2,… z-> 26).\nValores apropiados para P y M\n\n• P: el valor de P puede ser cualquier número primo aproximadamente igual al número de caracteres diferentes utilizados.\nPor ejemplo: si la cadena de entrada contiene solo letras minúsculas del alfabeto inglés, entonces P = 31 es el valor apropiado de P.\nSi la cadena de entrada contiene letras mayúsculas y minúsculas, entonces P = 53 es una opción adecuada.\n• M: la probabilidad de que dos cadenas aleatorias choquen es inversamente proporcional am. Por lo tanto, m debería ser un número primo grande.\nM = 10 ^ 9 + 9 es una buena opción.\n",
    "complejidad_tiempo": null,
    "java": "// Implementación de Java de la función Polynomial Rolling Hash\n\npublic class PolynomialRollingHash {\n\n    // Función para calcular el hash de un String\n    static long polynomialRollingHash(String str) {\n\n        // P y M\n        int p = 31;\n        int m = (int) (1e9 + 9);\n        long power_of_p = 1;\n        long hash_val = 0;\n        // Bucle para calcular el valor hash \n        // iterando sobre los elementos de String\n        for (int i = 0; i < str.length(); i++) {\n            hash_val = (hash_val + (str.charAt(i)\n                    - 'a' + 1) * power_of_p) % m;\n            power_of_p = (power_of_p * p) % m;\n        }\n        return hash_val;\n    }\n\n    public static void main(String[] args) {\n        String str1 = \"holaholaholo\";\n        System.out.print(\"Hash of '\" + str1 + \"' = \"\n                + polynomialRollingHash(str1));\n    }\n}\n",
    "cpp": "#include <bits/stdc++.h>\nusing namespace std;\n\nlong long polynomialRollingHash(string const& str) {\n    int p = 31;\n    int m = 1e9 + 9;\n    long long power_of_p = 1;\n    long long hash_val = 0;\n    for (int i = 0; i < str.length(); i++) {\n        hash_val\n                = (hash_val\n                + (str[i] - 'a' + 1) * power_of_p)\n                % m;\n        power_of_p\n                = (power_of_p * p) % m;\n    }\n    return hash_val;\n}\n\nint main() {\n    string str1 = \"geeksforgeeks\";\n    string str2 = \"geeks\";\n\n    cout << \"Hash of '\" << str1 << \"' = \"\n            << polynomialRollingHash(str1);\n    cout << endl;\n}\n",
    "py": "def polynomialRollingHash(str):\n        \n    # P and M\n    p = 31\n    m = 1e9 + 9\n    power_of_p = 1\n    hash_val = 0\n    for i in range(len(str)):\n        hash_val = ((hash_val + (ord(str[i]) -\n                    ord('a') + 1) *\n                    power_of_p) % m)\n\n        power_of_p = (power_of_p * p) % m\n\n    return int(hash_val)\n\nstr1 = \"geeksforgeeks\"\n\nprint(\"Hash of '{}' = {}\".format(\n      str1, polynomialRollingHash(str1)))\n",
    "orden": 5,
    "suborden": 9,
    "fecha_creacion": "2020-12-06 19:51:40",
    "fecha_modificacion": "2022-03-08 12:17:06"
  },
  {
    "ID": 213,
    "supergrupo": "Strings",
    "tema": "El más pequeño lexicográficamente",
    "texto": "Escriba código para encontrar el mínimo lexicográfico en una matriz circular, p. Ej. para la matriz BCABDADAB, el mínimo lexicográfico es ABBCABDAD\nRestricción de entrada: 1 <n <1000\nEjemplos:\nEntrada: GEEKSQUIZ\nSalida: EEKSQUIZG\n\nEntrada: GFG\nSalida: FGG\n\nEntrada: CAPABCQ\nSalida: ABCQCAP\nAquí necesitamos encontrar el índice inicial de rotación mínima y luego imprimir la rotación.\n\n1) Asuma inicialmente que 0 es el mínimo actual\n    índice inicial.\n2) Haz un bucle a través de i = 1 hasta n-1.\n    a) Para cada comienzo de secuencia de comparación\n       en i con el índice inicial mínimo actual\n    b) Si la secuencia que comienza en i es lexicográficamente\n       más pequeño, actualizar el mínimo actual comenzando\n       índice.\nComplejidad del tiempo: O (n ^ 2)\nEspacio auxiliar: O (1)\n",
    "complejidad_tiempo": null,
    "java": "// Programa Java para encontrar la secuencia lexicográficamente más pequeña con rotaciones.\n\npublic class LexoSmallest {\n    // Función para comparar lexicográficamente dos secuencias con diferentes \n    // índices de inicio. Devuelve verdadero si la secuencia que comienza \n    // con y es lexicográficamente mayor.\n\n    static boolean compareSeq(char[] S, int x, int y, int n) {\n        for (int i = 0; i < n; i++) {\n            if (S[x] < S[y]) {\n                return false;\n            } else if (S[x] > S[y]) {\n                return true;\n            }\n            x = (x + 1) % n;\n            y = (y + 1) % n;\n        }\n        return true;\n    }\n\n    // Función para encontrar el índice inicial de la secuencia \n    // lexicográficamente más pequeña\n    static int smallestSequence(char[] S, int n) {\n        int index = 0;\n        for (int i = 1; i < n; i++) // si la nueva secuencia es más pequeña\n        {\n            if (compareSeq(S, index, i, n)) // cambiar el índice del mínimo actual\n            {\n                index = i;\n            }\n        }\n\n        return index;\n    }\n\n    // Función para imprimir la secuencia lexicográficamente más pequeña \n    static void printSmallestSequence(String str, int n) {\n        char[] S = str.toCharArray();\n        int starting_index = smallestSequence(S, n);\n        for (int i = 0; i < n; i++) {\n            System.out.print(S[(starting_index + i) % n]);\n        }\n    }\n\n    public static void main(String[] args) {\n        String S = \"DCACBCAA\";\n        int n = 8;\n        printSmallestSequence(S, n);\n    }\n}\n",
    "cpp": "#include <cstdlib>\n#include <bits/stdc++.h> \nusing namespace std;\n\nbool compareSeq(char S[], int x, int y, int n) {\n    for (int i = 0; i < n; i++) {\n        if (S[x] < S[y]) {\n            return false;\n        } else if (S[x] > S[y]) {\n            return true;\n        }\n        x = (x + 1) % n;\n        y = (y + 1) % n;\n    }\n    return true;\n}\n\nint smallestSequence(char S[], int n) {\n    int index = 0;\n    for (int i = 1; i < n; i++) {\n        if (compareSeq(S, index, i, n)) {\n            index = i;\n        }\n    }\n    return index;\n}\n\nvoid printSmallestSequence(string str, int n) {\n    char S[str.size() + 1];\n    strcpy(S, str.c_str());\n    int starting_index = smallestSequence(S, n);\n    for (int i = 0; i < n; i++) {\n        cout << S[(starting_index + i) % n];\n    }\n}\n\nint main() {\n    string S = \"DCACBCAA\";\n    int n = 8;\n    printSmallestSequence(S, n);\n}\n",
    "py": "def compareSeq(S, x, y, n):\n    for i in range (n):\n        if (S[x] < S[y]):\n            return False\n        elif (S[x] > S[y]):\n            return True\n        x = (x + 1) % n\n        y = (y + 1) % n\n    return True\n\n\ndef smallestSequence(S, n):\n    index = 0\n    for i in range (n):\n        if (compareSeq(S, index, i, n)):\n            index = i\n    return index\n\n\ndef printSmallestSequence(str, n):\n    starting_index = smallestSequence(S, n);\n    for i in range (n):\n        print(str[(starting_index + i) % n])\n    \nS = \"DCACBCAA\"\nn = 8\nprintSmallestSequence(S, n);\n",
    "orden": 5,
    "suborden": 10,
    "fecha_creacion": "2020-12-06 19:51:40",
    "fecha_modificacion": "2022-03-08 12:17:06"
  },
  {
    "ID": 214,
    "supergrupo": "Strings",
    "tema": "Convirtiendo una cadena dadas restricciones",
    "texto": "Dadas dos cadenas contiene tres caracteres, es decir, \"A\", \"B\" y \"#\" únicamente. Compruebe si es posible convertir la primera cadena en otra cadena realizando las siguientes operaciones en la cadena primero.\n1- \"A\" solo puede moverse hacia la izquierda\n2- \"B\" solo puede moverse hacia la derecha\n3- Ni 'A' ni 'B' se cruzan\nSi es posible, imprima \"Sí\"; de lo contrario, \"No\".\n\nEjemplos:\nEntrada: str1 = ”# A # B # B #“, str2 = ”A ### B # B”\nSalida: si\nExplicacion:\n'A' en str1 está a la derecha de la 'A' en str2 por lo que 'A' de str1 puede moverse fácilmente hacia la izquierda porque no hay 'B' en sus posiciones izquierdas y para la primera 'B' en str1 se deja a la ' B 'en str2 para que' B 'de str2 pueda moverse fácilmente hacia la derecha porque no hay' A 'en sus posiciones correctas y es lo mismo para la siguiente' B ', por lo que str1 se puede convertir fácilmente en str2.\nEntrada: str1 = \"# A # B #\", str2 = \"# B # A #\"\nSalida: No\nExplicacion:\nAquí, la primera \"A\" en str1 se deja a la \"A\" en str2 y, según la condición, \"A\" no puede moverse hacia la derecha. entonces str1 no se puede convertir en str2.\nMétodo:\n1-La longitud de ambas cuerdas debe ser la misma\n2-No. de A y B en ambas cadenas deben ser iguales\n3-El orden de A y B en ambas cadenas debe ser el mismo (por ejemplo: si \"A\" viene antes de \"B\" en la cadena en segundo lugar, la misma secuencia debe seguirse primero en la cadena)\n",
    "complejidad_tiempo": null,
    "java": "public class ConvertStringIntoAnotherGivenConstraints {\n\n    //Función para comprobar si es posible \n    //convertir la primera cadena en otra cadena o no.\n    static boolean isItPossible(char[] str1, char[] str2,\n            int m, int n) {\n        // Para comprobar que la longitud de ambas cadenas es igual o no\n        if (m != n) {\n            return false;\n        }\n        // Para comprobar La frecuencia de A y B es igual en ambas cadenas o no.\n        if (count(str1, 'A')\n                != count(str2, 'A')\n                || count(str1, 'B')\n                != count(str2, 'B')) {\n            return false;\n        }\n        // Empieza a atravesar\n        for (int i = 0; i < m; i++) {\n            if (str1[i] != '#') {\n                for (int j = 0; j < n; j++) {\n                    // Comprobar que no se crucen dos elementos.\n                    if ((str2[j] != str1[i]) && str2[j] != '#') {\n                        return false;\n                    }\n                    if (str2[j] == str1[i]) {\n                        str2[j] = '#';\n                        // Para comprobar si es posible moverse \n                        // hacia la izquierda o no.\n                        if (str1[i] == 'A' && i < j) {\n                            return false;\n                        }\n                        // Para comprobar si es posible \n                        // moverse hacia la derecha o no.\n                        if (str1[i] == 'B' && i > j) {\n                            return false;\n                        }\n\n                        break;\n                    }\n                }\n            }\n        }\n        return true;\n    }\n\n    private static int count(char[] str1, char c) {\n        int count = 0;\n        for (char temp : str1) {\n            if (c == temp) {\n                count++;\n            }\n        }\n        return count;\n    }\n\n    public static void main(String[] args) {\n        String str1 = \"A#B#\";\n        String str2 = \"A##B\";\n        int m = str1.length();\n        int n = str2.length();\n        System.out.print(isItPossible(str1.toCharArray(), str2.toCharArray(), m, n)\n                ? \"Yes\\n\" : \"No\\n\");\n    }\n}\n",
    "cpp": "#include <bits/stdc++.h> \nusing namespace std;\n\nbool isItPossible(string str1, string str2, int m, int n) {\n    if (m != n)\n        return false;\n    if (count(str1.begin(), str1.end(), 'A') !=\n            count(str2.begin(), str2.end(), 'A') ||\n            count(str1.begin(), str1.end(), 'B') !=\n            count(str2.begin(), str2.end(), 'B'))\n        return false;\n    for (int i = 0; i < m; i++) {\n        if (str1[i] != '#') {\n            for (int j = 0; j < n; j++) {\n                if ((str2[j] != str1[i]) && str2[j] != '#')\n                    return false;\n                if (str2[j] == str1[i]) {\n                    str2[j] = '#';\n                    if (str1[i] == 'A' && i < j)\n                        return false;\n                    if (str1[i] == 'B' && i > j)\n                        return false;\n                    break;\n                }\n            }\n        }\n    }\n    return true;\n}\n\nint main() {\n    string str1 = \"A#B#\";\n    string str2 = \"A##B\";\n    int m = str1.length();\n    int n = str2.length();\n    isItPossible(str1, str2, m, n) ? cout << \"Yes\\n\" : cout << \"No\\n\";\n    return 0;\n}\n",
    "py": "def isItPossible(str1, str2, m, n): \n    if (m != n): \n        return False\n    if str1.count('A') != str2.count('A') \\ or str1.count('B') != str2.count('B'): \n        return False\n    for i in range(m): \n        if (str1[i] != '#'): \n            for j in range(n): \n                if ((str2[j] != str1[i]) and str2[j] != '#'): \n                    return False\n                if (str2[j] == str1[i]): \n                    str2[j] = '#'\n                    if (str1[i] == 'A' and i < j): \n                        return False\n                    if (str1[i] == 'B' and i > j): \n                        return False\n                    break\n                                \n    return True\nstr1 = \"A#B#\"\nstr2 = \"A##B\"\nm = len(str1) \nn = len(str2) \nstr1 = list(str1) \nstr2 = list(str2) \nif(isItPossible(str1, str2, m, n)): \n    print(\"Yes\") \nelse: \n    print(\"No\") \n",
    "orden": 5,
    "suborden": 11,
    "fecha_creacion": "2020-12-06 19:51:40",
    "fecha_modificacion": "2022-03-08 12:17:06"
  },
  {
    "ID": 215,
    "supergrupo": "BitWise",
    "tema": "Encontrar dos números de sumandos XOR",
    "texto": "Dada la suma y xor de dos números X e Y s.t. suma y xor, necesitamos encontrar los números minimizando el valor de X.\nEjemplos:\nEntrada: S = 17\n        X = 13\nSalida: a = 2\n         b = 15\n\nEntrada: S = 1870807699\n        X = 259801747\nSalida: a = 805502976\n         b = 1065304723\n\nEntrada: S = 1639\n        X = 1176\nResultado: No existen tales números\nVariables utilizadas:\nX ==> XOR de dos números\nS ==> Suma de dos números\nX [i] ==> Valor del i-ésimo bit en X\nS [i] ==> Valor del i-ésimo bit en S\nUna solución simple es generar todos los pares posibles con un XOR dado. Para generar todos los pares, podemos seguir las siguientes reglas.\n1. Si X [i] es 1, entonces tanto a [i] como b [i] deberían ser diferentes, tenemos dos casos.\n2. Si X [i] es 0, entonces tanto a [i] como b [i] deberían ser iguales. tenemos dos casos.\nEntonces generamos 2 ^ n pares posibles donde n es el número de bits en X. Luego, para cada par, verificamos si su suma es S o no.\nUna solución eficiente se basa en el siguiente hecho.\nS = X + 2 * A\ndonde A = a Y b\nPodemos verificar el hecho anterior usando el proceso de suma. En resumen, siempre que vemos ambos bits 1 (es decir, Y es 1), hacemos el bit resultante 0 y agregamos 1 como acarreo, lo que significa que cada bit en Y se desplaza a la izquierda por 1 O el valor de Y se multiplica por 2 y se suma.\nEntonces podemos encontrar A = (S - X) / 2.\nUna vez que encontramos A, podemos encontrar todos los bits de \"a\" y \"b\" usando las siguientes reglas.\n1. Si X [i] = 0 y A [i] = 0, entonces a [i] = b [i] = 0. Sólo una posibilidad para este bit.\n2. Si X [i] = 0 y A [i] = 1, entonces a [i] = b [i] = 1. Sólo una posibilidad para este bit.\n3. Si X [i] = 1 y A [i] = 0, entonces (a [i] = 1 yb [i] = 0) o (a [i] = 0 y b [i] = 1), podemos elegir cualquiera de los dos.\n4. Si X [i] = 1 y A [i] = 1, el resultado no es posible (Nota X [i] = 1 significa bits diferentes)\nSea la sumatoria S y XOR sea X.\n",
    "complejidad_tiempo": null,
    "java": "// Java program to find two numbers with  \n// given Sum and XOR such that value of  \n// first number is minimum.  \n\npublic class FindTwoNumbersFromSumandXOR {\n\n// Function that takes in the sum and XOR  \n// of two numbers and generates the two  \n// numbers such that the value of X is  \n// minimized  \n    static void compute(long S, long X) {\n        long A = (S - X) / 2;\n        int a = 0, b = 0;\n        final int LONG_FIELD_SIZE = 8;\n\n        // Traverse through all bits  \n        for (int i = 0; i < 8 * LONG_FIELD_SIZE; i++) {\n            long Xi = (X & (1 << i));\n            long Ai = (A & (1 << i));\n            if (Xi == 0 && Ai == 0) {\n                // Let us leave bits as 0.  \n            } else if (Xi == 0 && Ai > 0) {\n                a = ((1 << i) | a);\n                b = ((1 << i) | b);\n            } else if (Xi > 0 && Ai == 0) {\n                a = ((1 << i) | a);\n\n                // We leave i-th bit of b as 0.  \n            } else // (Xi == 1 && Ai == 1)  \n            {\n                System.out.println(\"Not Possible\");\n                return;\n            }\n        }\n        System.out.println(\"a = \" + a + \"\\nb = \" + b);\n    }\n\n// Driver function  \n    public static void main(String[] args) {\n        long S = 17, X = 13;\n        compute(S, X);\n\n    }\n}\n",
    "cpp": "#include <bits/stdc++.h> \n#include <cstdlib>\nusing namespace std;\n\nvoid compute(long S, long X) {\n    long A = (S - X) / 2;\n    int a = 0, b = 0;\n    const int LONG_FIELD_SIZE = 8;\n    for (int i = 0; i < 8 * LONG_FIELD_SIZE; i++) {\n        long Xi = (X & (1 << i));\n        long Ai = (A & (1 << i));\n        if (Xi == 0 && Ai == 0) {\n        } else if (Xi == 0 && Ai > 0) {\n            a = ((1 << i) | a);\n            b = ((1 << i) | b);\n        } else if (Xi > 0 && Ai == 0) {\n            a = ((1 << i) | a);\n        } else {\n            cout << \"Not Possible\" << endl;\n            return;\n        }\n    }\n    cout << \"a = \" << a << \"\\nb = \" << b << endl;\n}\n\nint main() {\n    long S = 17, X = 13;\n    compute(S, X);\n}\n",
    "py": "def compute(S, X):\n    A = (S - X) / 2\n    a = 0\n    b = 0\n    LONG_FIELD_SIZE = 8\n    leng = 8 * LONG_FIELD_SIZE\n    for i in range (leng):\n        Xi = (X & (1 << i))\n        Ai = (A & (1 << i))\n        if (Xi == 0 and Ai == 0):\n            c = 0\n        elif (Xi == 0 and Ai > 0):\n            a = ((1 << i) | a)\n            b = ((1 << i) | b)\n        elif (Xi > 0 and Ai == 0):\n            a = ((1 << i) | a);\n        else:\n            cout << \"Not Possible\" << endl;\n            return;\n    print(\"a = \" + str(a) + \"\\nb = \" + str(b))\nS = 17\nX = 13\ncompute(S, X);\n",
    "orden": 4,
    "suborden": 20,
    "fecha_creacion": "2020-12-06 19:51:41",
    "fecha_modificacion": "2022-03-08 12:18:28"
  },
  {
    "ID": 216,
    "supergrupo": "BitWise",
    "tema": "Cantidad de formas para realizar XOR en dos números",
    "texto": "Dadas dos cadenas binarias s1 y s2. El XOR de ellos es X, la tarea es encontrar el número de formas de intercambiar posiciones de dos bits en la cadena s1 de manera que el XOR formado entre los nuevos s1 y s2 no sea lo mismo que X.\nEjemplos:\nEntrada: s1 = \"01011\", s2 = \"11001\"\nSalida: 4\nintercambiar bits de índice (basado en 1) (1, 4), (2, 3), (3, 4) o (3, 5) de modo que se cambie el valor XOR.\nEntrada: s1 = \"011000\", s2 = \"010011\"\nSalida: 6\n\nAproximación:\n1. Cuente el número de unos y ceros en s1.\n2. Recorra la cadena s1 y compruebe dos casos:\n• 0 y 0 en s1 [i] y s2 [i], al reemplazar 0 con 1, cambiará el valor XOR.\n• 1 y 0 en s1 [i] y s2 [i], ya que reemplazar 1 con 0 cambiará el valor XOR.\n3. Para el primer caso, el número de formas de reemplazo será el número de unos, unos ya utilizados.\n4. Para el segundo caso, el número de formas de reemplazo será el número de ceros, ceros ya usados.\n5. La suma de varias formas en ambos casos será la respuesta.\n",
    "complejidad_tiempo": null,
    "java": "// Programa Java para encontrar Número de formas de cambiar el \n// XOR de dos números intercambiando los bits\n\npublic class WaysToXORTwoNumbers {\n\n    // Función que devuelve el número de intercambios de bits de modo que xor es diferente\n    static int countWays(String s1,\n            String s2) {\n        int c1 = 0, c0 = 0;\n        int n = s1.length();\n\n        // atravesar y contar 1 y 0\n        for (int i = 0; i < n; i++) {\n            if (s1.charAt(i) == '1') {\n                c1++;\n            } else {\n                c0++;\n            }\n        }\n        int used1 = 0, used0 = 0;\n        int ways = 0;\n\n        // atravesar el string\n        for (int i = 0; i < n; i++) {\n\n            // si ambas posiciones son 0\n            if (s1.charAt(i) == '0'\n                    && s2.charAt(i) == '0') {\n                // agregue el número de unos, ya que cambiará el XOR\n                ways += c1;\n                // restar el número de los ya usados\n                ways -= used1;\n                // se han utilizado ceros\n                used0++;\n            } // cuando 1 y 0, para cambiar XOR, tenemos que reemplazar 1 por 0\n            else if (s1.charAt(i) == '1'\n                    && s2.charAt(i) == '0') {\n                // agregar el número de ceros\n                ways += c0;\n                // restar el número de ceros ya usados\n                ways -= used0;\n                // cuenta 1 se usa\n                used1++;\n            }\n        }\n        return ways;\n    }\n\n    public static void main(String[] args) {\n        String s1 = \"01011\";\n        String s2 = \"11001\";\n        System.out.println(countWays(s1, s2));\n    }\n}\n",
    "cpp": "#include <bits/stdc++.h> \nusing namespace std;\n\nint countWays(string s1, string s2) {\n    int c1 = 0, c0 = 0;\n    int n = s1.length();\n    for (int i = 0; i < n; i++) {\n        if (s1[i] == '1')\n            c1++;\n        else\n            c0++;\n    }\n    int used1 = 0, used0 = 0;\n    int ways = 0;\n\n    for (int i = 0; i < n; i++) {\n        if (s1[i] == '0' and s2[i] == '0') {\n            ways += c1;\n            ways -= used1;\n            used0++;\n        } else if (s1[i] == '1' and s2[i] == '0') {\n            ways += c0;\n            ways -= used0;\n            used1++;\n        }\n    }\n    return ways;\n}\n\nint main() {\n    string s1 = \"01011\";\n    string s2 = \"11001\";\n\n    cout << countWays(s1, s2);\n    return 0;\n}\n",
    "py": "def countWays(s1, s2): \n\n    c1 = 0\n    c0 = 0\n    n = len(s1) \n    for i in range(0, n): \n        if (s1[i] == '1'): \n            c1 += 1\n        else: \n            c0 += 1\n        \n    used1 = 0\n    used0 = 0\n    ways = 0\n\n    for i in range(0, n): \n        if (s1[i] == '0' and s2[i] == '0'): \n            ways += c1 \n            ways -= used1 \n            used0 += 1\n        elif (s1[i] == '1' and s2[i] == '0'): \n            ways += c0 \n            ways -= used0 \n            used1 += 1\n\n    return ways \ns1 = \"01011\"\ns2 = \"11001\"\nprint(countWays(s1, s2)) \n",
    "orden": 4,
    "suborden": 21,
    "fecha_creacion": "2020-12-06 19:51:41",
    "fecha_modificacion": "2022-03-08 12:18:28"
  },
  {
    "ID": 217,
    "supergrupo": "BitWise",
    "tema": "Ecuaciones BitWise para multiplicación de un numero por n",
    "texto": "En números enteros sin signo, el desplazamiento lógico hacia la izquierda equivale a una multiplicación por 2 y el desplazamiento lógico hacia la derecha equivale a una división por 2. En la división (desplazamiento hacia la derecha), se pierde el bit menos significativo, dando como resultado un truncamiento del resultado (redondeo hacia abajo, hacia menos infinito). Así, 6 / 2 es igual a 3, pero 7 / 2 es igual a 3,5, pero el 0,5 se pierde quedando el resultado en 3.\nLos programadores de lenguaje ensamblador usan esta propiedad para hacer multiplicaciones y divisiones rápidas, de enteros sin signo, por una potencia de 2, en donde n desplazamientos equivalen a multiplicar o dividir por 2n. También, si el procesador no tiene operaciones de multiplicación y división de enteros, o si éstas son muy lentas, se puede multiplicar o dividir usando desplazamientos y sumas para multiplicar y desplazamientos y restas para dividir.\n",
    "complejidad_tiempo": null,
    "java": "import java.util.ArrayList;\nimport java.util.TreeMap;\n\npublic class BitwiseMultiplication {\n\n    static boolean powerof2(int x) {\n        return x != 0 && ((x & (x - 1)) == 0);\n    }\n\n    static int suma(int n) {\n        return (~(-(1 << n))) << 1;\n    }\n\n    static int nith(int n) {\n        return (int) ((Math.log(n + 2) / Math.log(2)) - 1);\n    }\n\n    static String bitsum(ArrayList<Integer> arr, String n, int len) {\n        ArrayList<Integer> rev = new ArrayList<>();\n        TreeMap<String, Integer> counter = new TreeMap<>();\n        String serie = \"\";\n        for (int i : arr) {\n            for (int j = 1; j <= nith(i); ++j) {\n                rev.add(j);\n            }\n        }\n        for (int i : rev) {\n            int aux = 0;\n            for (int j : rev) {\n                if (j == i) {\n                    aux++;\n                }\n            }\n            counter.put(\"(\" + n + \"<<\" + i + \")\", aux);\n        }\n        for (String s : counter.keySet()) {\n            String key = s;\n            int value = counter.get(s);\n            if (powerof2(value) && value != 1) {\n                serie += \"(\" + key + \"<<\" + ((int) (Math.log(value) / Math.log(2))) + \") + \";\n                continue;\n            }\n            for (int j = 0; j < value; j++) {\n                serie += \" \" + key + \" + \";\n            }\n        }\n        if (arr.get(len - 1) == 1) { // si el n es impar se le añade el ultimo termino n como sumando; si es par no se le añade\n            return serie + \" \" + n;\n        }\n        return serie;\n    }\n\n    public static void main(String[] args) {\n        int n = 7; //numero al cual le quiero calcular la ecuación\n        int N = n; //una copia del numero\n        ArrayList<Integer> arr = new ArrayList<>();\n        while (suma(nith(n)) > 0) { //cálculos los términos de 2^n - 2 tales que su suma me da n (si n es impar siempre falta un 1) y los voy almacenando en un vector\n            arr.add(suma(nith(n)));\n            n -= suma(nith(n));\n        }\n        int sumarr = 0;\n        for (int i = 0; i < arr.size(); ++i) {\n            sumarr += arr.get(i);//sumo los termino del vector\n        }\n        if (sumarr < N) {//si la suma no me da mi N añado el 1 que me falta\n            arr.add(1);\n        }\n        System.out.println(\"x*\" + N + \" -> \" + bitsum(arr, \"x\", arr.size())); //imprime la ecuación\n    }\n\n}\n",
    "cpp": "#include<bits/stdc++.h>\n#include<cstdlib>\n#include <math.h>\n#include <iterator>\nusing namespace std;\n#define FAST ios_base::sync_with_stdio(false);cin.tie(NULL);cout.tie(0);\n\nbool powerof2(int x) {\n    return x != 0 & & ((x & (x - 1)) == 0);\n}\n\nint suma(int n) {\n    return ( ~(-(1 << n))) << 1;\n}\n\nint nith(int n) {\n    return (int) (log2(n + 2) - 1);\n}\n\nstring bitsum(vector < int > arr, string n, int len) {\n    vector < int > rev;\n    map < string, int > counter;\n    string serie = \"\";\n    for (int i : arr) {\n        for (int j = 1; j <= nith(i); + + j) {\n            rev.push_back(j);\n        }\n    }\n    for (int i : rev) {\n        int aux = 0;\n        for (int j : rev) {\n            if (j == i) {\n                aux + +;\n            }\n        }\n        string dat = \"(\" + n + \"<<\" + to_string(i) + \")\";\n        counter.insert(pair < string, int > (dat, aux));\n    }\n    map < string, int > ::iterator itr;\n    for (itr = counter.begin(); itr != counter.end(); + + itr) {\n        string key = itr - > first;\n        int value = itr - > second;\n        if (powerof2(value) & & value != 1) {\n            serie += \"(\" + key + \"<<\" + to_string(((int) (log2(value)))) + \") + \";\n            continue;\n        }\n        for (int j = 0; j < value; j + +) {\n            serie += \" \" + key + \" + \";\n        }\n    }\n    if (arr[len - 1] == 1) {\n        return serie + \" \" + n;\n    }\n    return serie;\n}\n\nint main() {\n    FAST;\n    int n = 7;\n    int N = n;\n    vector < int > arr;\n    while (suma(nith(n))) {\n        arr.push_back(suma(nith(n)));\n        n -= suma(nith(n));\n    }\n    int sumarr = 0;\n    for (int i = 0; i < arr.size(); + + i) {\n        sumarr += arr[i];\n    }\n    if (sumarr < N) {\n        arr.push_back(1);\n    }\n    cout << \"x*\" << N << \" -> \" << bitsum(arr, \"x\", arr.size()) << endl;\n}\n",
    "py": "from sys import stdin, stdout\nfrom collections import Counter\nfrom math import log2\n\nin_, out = stdin.readline, stdout.write\n\n\ndef powerof2(n):\n    x = n\n    y = not(n & (n - 1))\n    return x and y\n\nsuma = lambda n: (~(-(1 << n))) << 1\n\nnith = lambda n: int(log2(n + 2) - 1)\n\n\ndef bitsum(arr, n):\n    serie = str()\n    lista = []\n    for i in arr:\n        for j in range(1, nith(i) + 1):\n            lista.append(f\"({n}<<{j})\")\n    v = dict(Counter(lista))\n    for i in v:\n        if powerof2(v[i]) and v[i] != 1:\n            serie += f\"({i}<<{int(log2(v[i]))}) + \"\n            continue\n        for j in range(v[i]):\n            serie += f\"{i} + \"\n    if arr[-1] == 1:\n        return serie[:-3] + f\" + {n}\"\n    return serie[:-3]\n\nn = 7\nN = n\narr = []\n\nwhile suma(nith(n)):\n    arr.append(suma(nith(n)))\n    n -= suma(nith(n))\n\nif sum(arr) != N:\n    arr.append(1)\n\nout(f\"x*{N} -> {bitsum(arr,'x')}\\n\")\n",
    "orden": 4,
    "suborden": 22,
    "fecha_creacion": "2020-12-06 19:51:41",
    "fecha_modificacion": "2022-03-08 12:18:28"
  },
  {
    "ID": 218,
    "supergrupo": "BitWise",
    "tema": "Bitmasking (Parte 1)",
    "texto": "Considere la siguiente declaración de problema.\nHay 100 tipos diferentes de límites, cada uno con una identificación única de 1 a 100. Además, hay \"n\" personas, cada una con una colección de un número variable de límites. Un día todas estas personas deciden ir a una fiesta con gorra, pero para verse únicas decidieron que ninguna usaría el mismo tipo de gorra. Por lo tanto, cuente el número total de arreglos o formas en que ninguno de ellos use el mismo tipo de gorra.\nRestricciones: 1 <= n <= 10 Ejemplo:\nLa primera línea contiene el valor de n, las siguientes n líneas contienen colecciones\nde todas las n personas.\nEntrada:\n3\n5 100 1 // Recogida de la primera persona.\n2 // Recogida de la segunda persona.\n5 100 // Recogida de la tercera persona.\n\nSalida:\n4\nExplicación: Todas las formas posibles válidas son (5, 2, 100), (100, 2, 5),\n            (1, 2, 5) y (1, 2, 100)\nDado que, el número de formas podría ser grande, entonces el módulo de salida 1000000007\nLe recomendamos encarecidamente que minimice su navegador e intente esto usted mismo primero.\nUna solución simple es probar todas las combinaciones posibles. Comience eligiendo el primer elemento del primer conjunto, marcándolo como visitado y repita para los conjuntos restantes. Es básicamente una solución basada en Backtracking.\nUna mejor solución es utilizar Bitmasking y DP. Primero introduzcamos Bitmasking.\n\n\n\n¿Qué es la máscara de bits?\nSupongamos que tenemos una colección de elementos que están numerados de 1 a N. Si queremos representar un subconjunto de este conjunto, entonces puede ser codificado por una secuencia de N bits (usualmente llamamos a esta secuencia una “máscara”). En nuestro subconjunto elegido, el elemento i-ésimo le pertenece si y solo si el bit i-ésimo de la máscara está establecido, es decir, es igual a 1. Por ejemplo, la máscara 10000101 significa que el subconjunto del conjunto [1… 8 ] consta de los elementos 1, 3 y 8. Sabemos que para un conjunto de N elementos hay un total de 2N subconjuntos, por lo que son posibles 2N máscaras, una que representa cada subconjunto. Cada máscara es, de hecho, un número entero escrito en notación binaria.\nNuestra metodología principal es asignar un valor a cada máscara (y, por lo tanto, a cada subconjunto) y así calcular los valores para nuevas máscaras utilizando valores de las máscaras ya calculadas. Por lo general, nuestro objetivo principal es calcular el valor / solución para el conjunto completo, es decir, para la máscara 11111111. Normalmente, para encontrar el valor para un subconjunto X, eliminamos un elemento de todas las formas posibles y usamos valores para los subconjuntos obtenidos X'1, X ' 2…, X'k para calcular el valor / solución de X. Esto significa que los valores de X'i ya deben haberse calculado, por lo que debemos establecer un orden en el que se considerarán las máscaras. Es fácil ver que el orden natural funciona: revise las máscaras en orden creciente de los números correspondientes. Además, a veces, comenzamos con el subconjunto vacío X y agregamos elementos de todas las formas posibles y usamos los valores de los subconjuntos obtenidos X'1, X'2 ..., X'k para calcular el valor / solución para X.\n\nUsamos principalmente las siguientes notaciones / operaciones en máscaras:\nbit (i, mask) - el i-ésimo bit de máscara\n\ncount (máscara): el número de bits distintos de cero en la máscara\nprimero (máscara): el número del bit distinto de cero más bajo en la máscara\nset (i, mask) - establece el bit i en la máscara\n\ncheck (i, máscara) - comprobar el bit i en la máscara\n\n¿Cómo se resuelve este problema usando Bitmasking + DP?\n\nLa idea es aprovechar el hecho de que hay hasta 10 personas. Entonces podemos usar una variable entera como una máscara de bits para almacenar qué persona usa gorra y cuál no.\n\nSea i el número de límite actual (los límites de 1 a i-1 ya están\nprocesado). Dejemos que la máscara de variable entera indica que las personas w\norejas y no gorras. Si el bit i'th está configurado en máscara, entonces\ni'th persona lleva una gorra, de lo contrario no.\n\n             // considere el caso en el que no se incluye el tope\n                     // en el arreglo\ncountWays (máscara, i) = countWays (máscara, i + 1) +\n                    \n                    // cuando se incluye el tope en el arreglo\n                    // entonces, asigne este límite a todas las personas posibles\n                    // uno por uno y se repite para las personas restantes.\n                    ∑ countWays (máscara | (1 << j), i + 1)\n                       por cada persona j que pueda usar gorra i\n \nTenga en cuenta que la expresión \"máscara | (1 << j)\" establece j'th bit en máscara.\nY una persona puede usar gorra i si está en la lista de gorra de la persona\nproporcionado como entrada.\nSi dibujamos el árbol de recursividad completo, podemos observar que muchos subproblemas se resuelven una y otra vez. Entonces usamos Programación Dinámica. Se utiliza una tabla dp [] [] de modo que en cada entrada dp [i] [j], i es la máscara y j es el número de límite.\n\nComo queremos acceder a todas las personas que pueden usar una gorra determinada, utilizamos una matriz de vectores, capList [101]. Un valor capList [i] indica la lista de personas que pueden usar gorra i.\n",
    "complejidad_tiempo": null,
    "java": "// Usando bitmasking para resolver el problema del numero de formas de \n// usar sombrero\n\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\n\npublic class Bitmasking1 {\n\n    static final int MOD = 1000000007;\n\n    // Objecto lector \n    static BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\n    //capList[i]esimo vector contiene la lista de personas que \n    //tienen un sombrero con id i, id está entre 1 y 100, \n    //por lo que declaramos una array de 101 vectores ya \n    //que la indexación comienza desde 0.\n    static ArrayList<Integer> capList[] = new ArrayList[101];\n\n    //dp [2 ^ 10] [101] .. en dp [i] [j], i denota la máscara, \n    //es decir, indica cuántas personas y qué personas llevan sombrero. \n    //j denota el primer j sombrero utilizado. Entonces, dp [i] [j] \n    //indica el número de formas en que asignamos j sombreros para \n    //enmascarar i de tal manera que ninguno de ellos use el mismo gorro\n    static int dp[][] = new int[1025][101];\n\n    //Esto se usa para el caso base, tiene todos los N bits configurados, \n    //por lo que indica si todas las N personas están usando un sombrero.\n    static int allmask;\n\n    //Máscara es el conjunto de personas, i es cap-id \n    //(OR el número de sombreros procesados a partir del primer sombrero).\n    static long countWaysUtil(int mask, int i) {\n        //Si todas las personas están usando gorra, \n        //hemos terminado y esta es una forma, regrese 1\n        if (mask == allmask) {\n            return 1;\n        }\n\n        //Si no todo el mundo está usando una gorra y además no \n        //quedan más gorras para procesar, \n        //entonces no hay forma, entonces devuelve 0;\n        if (i > 100) {\n            return 0;\n        }\n\n        // Si ya hemos resuelto este subproblema, devolvemos la respuesta.\n        if (dp[mask][i] != -1) {\n            return dp[mask][i];\n        }\n\n        //Maneras en las que no incluimos este límite \n        //en nuestro arreglo o conjunto de soluciones.\n        long ways = countWaysUtil(mask, i + 1);\n\n        // size es el número total de personas que tienen un límite con la identificación i. \n        int size = capList[i].size();\n\n        //Por lo tanto, asigne uno a uno el sombrero iesimo a \n        //todas las personas posibles y repita para los sombreros restantes.\n        for (int j = 0; j < size; j++) {\n            //Si la persona capList [i] [j] ya está usando una gorra, \n            //continúe, ya que no podemos asignarle esta gorra.\n            if ((mask & (1 << capList[i].get(j))) != 0) {\n                continue;\n            }// De lo contrario, asígnele este sombrero y repita \n            //para los sombreros restantes con un nuevo vector de máscara actualizado\n            else {\n                ways += countWaysUtil(mask | (1 << capList[i].get(j)), i + 1);\n            }\n            ways %= MOD;\n        }\n        // Guarde el resultado y devuélvalo.\n        return dp[mask][i] = (int) ways;\n    }\n\n    // Lee n líneas de la entrada estándar para el caso de prueba actual\n    static void countWays(int n) throws Exception {\n        String str;\n        String split[];\n        int x;\n\n        for (int i = 0; i < n; i++) {\n            str = br.readLine();\n            split = str.split(\" \");\n\n            // mientras haya palabras en split[]\n            for (int j = 0; j < split.length; j++) {\n                // agregue la i-ésima persona en la lista de cap si con id x\n                x = Integer.parseInt(split[j]);\n                capList[x].add(i);\n            }\n\n        }\n        //Todas las máscaras se utilizan para comprobar si \n        //todas las personas están incluidas o no,\n        //establezca todos los n bits como 1\n        allmask = (1 << n) - 1;\n        // Inicializar todas las entradas en dp como -1\n        for (int[] is : dp) {\n            for (int i = 0; i < is.length; i++) {\n                is[i] = -1;\n            }\n        }\n        // Llamar a la función recursiva contar formas\n        System.out.println(countWaysUtil(0, 1));\n    }\n\n    public static void main(String args[]) throws Exception {\n        int n; //numero de personas en cada caso de prueba\n        // inicializando vector de listas\n        for (int i = 0; i < capList.length; i++) {\n            capList[i] = new ArrayList<>();\n        }\n        //3\n        //5 100 1\n        //2\n        //5 100\n        n = Integer.parseInt(br.readLine());\n        countWays(n);\n        // salida -> 4\n    }\n}\n",
    "cpp": "// C++ program to find number of ways to wear hats \n#include<bits/stdc++.h> \n#define MOD 1000000007 \nusing namespace std;\n\nvector<int> capList[101];\nint dp[1025][101];\nint allmask;\n\nlong long int countWaysUtil(int mask, int i) {\n    if (mask == allmask) return 1;\n    if (i > 100) return 0;\n    if (dp[mask][i] != -1) return dp[mask][i];\n    long long int ways = countWaysUtil(mask, i + 1);\n    int size = capList[i].size();\n    for (int j = 0; j < size; j++) {\n        if (mask & (1 << capList[i][j])) continue;\n        else ways += countWaysUtil(mask | (1 << capList[i][j]), i + 1);\n        ways %= MOD;\n    }\n    return dp[mask][i] = ways;\n}\n\nvoid countWays(int n) {\n    string temp, str;\n    int x;\n    getline(cin, str);\n    for (int i = 0; i < n; i++) {\n        getline(cin, str);\n        stringstream ss(str);\n        while (ss >> temp) {\n            stringstream s;\n            s << temp;\n            s >> x;\n            capList[x].push_back(i);\n        }\n    }\n    allmask = (1 << n) - 1;\n    memset(dp, -1, sizeof dp);\n    cout << countWaysUtil(0, 1) << endl;\n}\n\nint main() {\n    int n;\n    cin >> n;\n    countWays(n);\n    return 0;\n}\n",
    "py": "from collections import defaultdict\n \nclass AssignCap: \n    def __init__(self): \n        self.allmask = 0\n        self.total_caps = 100\n        self.caps = defaultdict(list) \n\n    def countWaysUtil(self, dp, mask, cap_no): \n        if mask == self.allmask: \n            return 1\n        if cap_no > self.total_caps: \n            return 0\n        if dp[mask][cap_no] != -1: \n            return dp[mask][cap_no] \n        ways = self.countWaysUtil(dp, mask, cap_no + 1)  \n        if cap_no in self.caps: \n            for ppl in self.caps[cap_no]: \n                if mask & (1 << ppl): continue\n                ways += self.countWaysUtil(dp, mask | (1 << ppl), cap_no + 1) \n                ways = ways % (10 ** 9 + 7)  \n        dp[mask][cap_no] = ways \n        return dp[mask][cap_no] \n    def countWays(self, N): \n        for ppl in range(N): \n            cap_possessed_by_person = map(int, raw_input().strip().split()) \n            for i in cap_possessed_by_person: \n                self.caps[i].append(ppl) \n        self.allmask = (1 << N) -1\n        dp = [[-1 for j in range(self.total_caps + 1)] for i in range(2 ** N)] \n        print self.countWaysUtil(dp, 0, 1,) \n\ndef main(): \n    No_of_people = input()  \n    AssignCap().countWays(No_of_people) \nmain() \n",
    "orden": 4,
    "suborden": 23,
    "fecha_creacion": "2020-12-06 19:51:42",
    "fecha_modificacion": "2022-03-08 12:18:28"
  },
  {
    "ID": 219,
    "supergrupo": "DP",
    "tema": "El problema de los globos y las monedas",
    "texto": "Se nos han dado N globos, cada uno con una cantidad de monedas asociadas. Al reventar un globo i, el número de monedas ganadas es igual a A [i-1] * A [i] * A [i + 1]. Además, los globos i-1 e i + 1 ahora se vuelven adyacentes. Encuentra la máxima ganancia posible obtenida después de reventar todos los globos. Suponga un 1 adicional en cada límite.\nEjemplos:\nEntrada: 5, 10\nSalida: 60\nExplicación - Primera ráfaga 5, monedas = 1 * 5 * 10\n              Luego revienta 10, monedas + = 1 * 10 * 1\n              Total = 60\n\nEntrada: 1, 2, 3, 4, 5\nSalida: 110\n\nPrimero, considere una submatriz de índices de izquierda a derecha (inclusive).\nSi asumimos que el globo en el índice Último es el último globo en reventar en este subarreglo, diríamos que la ganancia acuñada es-A [izquierda-1] * A [último] * A [derecha + 1].\nAdemás, la moneda total ganada sería este valor, más dp [izquierda] [último - 1] + dp [último + 1] [derecha], donde dp [i] [j] significa la moneda máxima ganada para la submatriz con índices yo, j.\nPor lo tanto, para cada valor de Izquierda y Derecha, necesitamos encontrar y elegir un valor de Último con la máxima moneda ganada y actualizar la matriz dp.\nNuestra respuesta es el valor en dp [1] [N].\n",
    "complejidad_tiempo": null,
    "java": "//Programa Java para ilustrar el problema del BurstBalloon\n\npublic class BurstBalloonMaximizeCoins {\n\n    public static int getMax(int[] A, int N) {\n\n        // Agregar globos de borde\n        int[] B = new int[N + 2];\n        B[0] = B[N + 1] = 1;\n\n        for (int i = 1; i <= N; i++) {\n            B[i] = A[i - 1];\n        }\n\n        // Declaración de array DP\n        int[][] dp = new int[N + 2][N + 2];\n\n        for (int length = 1;\n                length < N + 1; length++) {\n            for (int left = 1;\n                    left < N - length + 2; left++) {\n                int right = left + length - 1;\n\n                //Para una submatriz de índices a la izquierda, a la derecha. \n                //Este bucle más interno encuentra la última explosión del globo.\n                for (int last = left;\n                        last < right + 1; last++) {\n                    dp[left][right] = Math.max(\n                            dp[left][right],\n                            dp[left][last - 1]\n                            + B[left - 1] * B[last]\n                            * B[right + 1]\n                            + dp[last + 1][right]);\n                }\n            }\n        }\n        return dp[1][N];\n    }\n\n    public static void main(String args[]) {\n        int[] A = {1, 2, 3, 4, 5};\n        int N = A.length;\n        System.out.println(getMax(A, N));\n    }\n}\n",
    "cpp": "#include <bits/stdc++.h> \n#include <iostream> \nusing namespace std;\n\nint getMax(int A[], int N) {\n    int B[N + 2];\n    B[0] = 1;\n    B[N + 1] = 1;\n    for (int i = 1; i <= N; i++)\n        B[i] = A[i - 1];\n    int dp[N + 2][N + 2];\n    memset(dp, 0, sizeof (dp));\n\n    for (int length = 1; length < N + 1; length++) {\n        for (int left = 1; left < N - length + 2; left++) {\n            int right = left + length - 1;\n            for (int last = left; last < right + 1; last++) {\n                dp[left][right] = max(dp[left][right],\n                        dp[left][last - 1] +\n                        B[left - 1] * B[last] * B[right + 1] +\n                        dp[last + 1][right]);\n            }\n        }\n    }\n    return dp[1][N];\n}\n\nint main() {\n    int A[] = {1, 2, 3, 4, 5};\n    int N = sizeof (A) / sizeof (A[0]);\n    cout << getMax(A, N) << endl;\n}\n",
    "py": "def getMax(A): \n    N = len(A) \n    A = [1] + A + [1]\n    dp = [[0 for x in range(N + 2)] for y in range(N + 2)] \n      \n    for length in range(1, N + 1): \n        for left in range(1, N-length + 2): \n            right = left + length -1\n            for last in range(left, right + 1): \n                dp[left][right] = max(dp[left][right], \\ \n                                      dp[left][last-1] + \\ \n                                      A[left-1] * A[last] * A[right + 1] + \\ \n                                      dp[last + 1][right]) \n    return(dp[1][N]) \n  \nA = [1, 2, 3, 4, 5] \nprint(getMax(A)) \n",
    "orden": 9,
    "suborden": 5,
    "fecha_creacion": "2020-12-06 19:51:42",
    "fecha_modificacion": "2022-03-08 12:19:51"
  },
  {
    "ID": 220,
    "supergrupo": "DP",
    "tema": "El problema de apilamiento de cajas",
    "texto": "Se le da un conjunto de n tipos de cajas rectangulares en 3D, donde la i ^ ésima caja tiene altura h (i), ancho w (i) y profundidad d (i) (todos números reales). Desea crear una pila de cajas lo más alta posible, pero solo puede apilar una caja encima de otra caja si las dimensiones de la base 2-D de la caja inferior son estrictamente más grandes que las del 2- D base de la caja superior. Por supuesto, puede rotar una caja para que cualquier lado funcione como base. También está permitido utilizar varias instancias del mismo tipo de caja.\n \nEl problema de apilamiento de cajas es una variación del problema LIS (Longest increasing subsequence). Necesitamos construir una pila de altura máxima.\nLos siguientes son los puntos clave a tener en cuenta en el planteamiento del problema:\n1) Una caja puede colocarse encima de otra caja solo si tanto el ancho como la profundidad de la caja colocada en la parte superior son menores que el ancho y la profundidad de la caja inferior respectivamente.\n2) Podemos rotar cajas de manera que el ancho sea menor que la profundidad. Por ejemplo, si hay un cuadro con dimensiones {1x2x3} donde 1 es la altura, 2 × 3 es la base, entonces puede haber tres posibilidades, {1x2x3}, {2x1x3} y {3x1x2}\n3) Podemos utilizar varias instancias de cajas. Lo que significa es que podemos tener dos rotaciones diferentes de una caja como parte de nuestra pila de altura máxima.\nA continuación se muestra la solución basada en la solución DP del problema LIS.\n\n1) Genere las 3 rotaciones de todas las cajas. El tamaño de la matriz de rotación se convierte en 3 veces el tamaño de la matriz original. Por simplicidad, consideramos que el ancho es siempre menor o igual que la profundidad.\n2) Ordene los cuadros 3n generados anteriormente en orden decreciente de área base.\n3) Después de clasificar las cajas, el problema es el mismo que LIS con la siguiente propiedad de subestructura óptima.\nMSH (i) = Altura máxima posible de la pila con la caja i en la parte superior de la pila\nMSH (i) = {Max (MSH (j)) + altura (i)} donde j <i y ancho (j)> ancho (i) y profundidad (j)> profundidad (i).\nSi no existe tal j, entonces MSH (i) = altura (i)\n4) Para obtener la altura máxima general, devolvemos max (MSH (i)) donde 0 <i <n\n\nEn el programa, los cuadros de entrada dados son {4, 6, 7}, {1, 2, 3}, {4, 5, 6}, {10, 12, 32}. A continuación se muestran todas las rotaciones de las cajas en orden decreciente del área de la base.\n   10 x 12 x 32\n   12 x 10 x 32\n   32 x 10 x 12\n   4 x 6 x 7\n   4 x 5 x 6\n   6 x 4 x 7\n   5 x 4 x 6\n   7 x 4 x 6\n   6 x 4 x 5\n   1 x 2 x 3\n   2 x 1 x 3\n   3 x 1 x 2\nLa altura 60 se obtiene mediante cuadros {{3, 1, 2}, {1, 2, 3}, {6, 4, 5}, {4, 5, 6}, {4, 6, 7}, {32 , 10, 12}, {10, 12, 32}}\n",
    "complejidad_tiempo": null,
    "java": "/* Implementación de programación dinámica del problema de \n   apilamiento de cajas en Java*/\nimport java.util.*;\n\npublic class BoxStackingProblem {\n\n    /* Representación de una caja */\n    static class Box implements Comparable<Box> {\n\n        // h -> altura, w -> ancho,\n        // d -> profundidad\n        int h, w, d, area;\n\n        // para simplificar la solución, mantenga siempre w <= d\n        // Constructor para inicializar el objeto\n        public Box(int h, int w, int d) {\n            this.h = h;\n            this.w = w;\n            this.d = d;\n        }\n\n        // Para ordenar la matriz de cajas según el \n        // área en orden decreciente de área\n        @Override\n        public int compareTo(Box o) {\n            return o.area - this.area;\n        }\n    }\n\n    /* Devuelve la altura de la pila más alta que se puede \n    formar con un tipo de cajas determinado */\n    static int maxStackHeight(Box arr[], int n) {\n        Box[] rot = new Box[n * 3];\n        /* Se crea una nueva matriz de cajas, considerando las 3 posibles \n        rotaciones, con un ancho siempre mayor que igual al ancho */\n        for (int i = 0; i < n; i++) {\n            Box box = arr[i];\n\n            /* Caja original*/\n            rot[3 * i] = new Box(box.h, Math.max(box.w, box.d),\n                    Math.min(box.w, box.d));\n\n            /* Primera rotación de caja*/\n            rot[3 * i + 1] = new Box(box.w, Math.max(box.h, box.d),\n                    Math.min(box.h, box.d));\n\n            /* Segunda rotación de caja*/\n            rot[3 * i + 2] = new Box(box.d, Math.max(box.w, box.h),\n                    Math.min(box.w, box.h));\n        }\n\n        /* Cálculo del área base de\n        cada una de las cajas.*/\n        for (int i = 0; i < rot.length; i++) {\n            rot[i].area = rot[i].w * rot[i].d;\n        }\n\n        /* Clasificación de las cajas según el área en orden no creciente.*/\n        Arrays.sort(rot);\n        int count = 3 * n;\n        /* Inicializar los valores de msh para todos\n            índices\n        msh [i] -> Altura máxima de pila posible con \n        la casilla i en la parte superior */\n        int[] msh = new int[count];\n        for (int i = 0; i < count; i++) {\n            msh[i] = rot[i].h;\n        }\n\n        /* Calcular valores optimizados de msh [] de forma ascendente */\n        for (int i = 0; i < count; i++) {\n            msh[i] = 0;\n            Box box = rot[i];\n            int val = 0;\n\n            for (int j = 0; j < i; j++) {\n                Box prevBox = rot[j];\n                if (box.w < prevBox.w && box.d < prevBox.d) {\n                    val = Math.max(val, msh[j]);\n                }\n            }\n            msh[i] = val + box.h;\n        }\n\n        int max = -1;\n\n        /* Elija el máximo de todos los valores de msh */\n        for (int i = 0; i < count; i++) {\n            max = Math.max(max, msh[i]);\n        }\n\n        return max;\n    }\n\n    public static void main(String[] args) {\n        Box[] arr = new Box[4];\n        arr[0] = new Box(4, 6, 7);\n        arr[1] = new Box(1, 2, 3);\n        arr[2] = new Box(4, 5, 6);\n        arr[3] = new Box(10, 12, 32);\n\n        System.out.println(\"The maximum possible \"\n                + \"height of stack is \"\n                + maxStackHeight(arr, 4));\n    }\n}\n",
    "cpp": "#include<stdio.h> \n#include<stdlib.h> \n\nstruct Box {\n    int h, w, d;\n};\n\nint min(int x, int y) {\n    return (x < y) ? x : y;\n}\n\nint max(int x, int y) {\n    return (x > y) ? x : y;\n}\n\nint compare(const void *a, const void * b) {\n    return ( (*(Box *) b).d * (*(Box *) b).w) -\n            ((*(Box *) a).d * (*(Box *) a).w);\n}\n\nint maxStackHeight(Box arr[], int n) {\n\n    Box rot[3 * n];\n    int index = 0;\n    for (int i = 0; i < n; i++) {\n        rot[index].h = arr[i].h;\n        rot[index].d = max(arr[i].d, arr[i].w);\n        rot[index].w = min(arr[i].d, arr[i].w);\n        index++;\n\n        rot[index].h = arr[i].w;\n        rot[index].d = max(arr[i].h, arr[i].d);\n        rot[index].w = min(arr[i].h, arr[i].d);\n        index++;\n\n        rot[index].h = arr[i].d;\n        rot[index].d = max(arr[i].h, arr[i].w);\n        rot[index].w = min(arr[i].h, arr[i].w);\n        index++;\n    }\n\n    n = 3 * n;\n\n    qsort(rot, n, sizeof (rot[0]), compare);\n    //Uncomment following two lines to print all rotations \n    // for (int i = 0; i < n; i++ ) \n    // printf(\"%d x %d x %d\\n\", rot[i].h, rot[i].w, rot[i].d); \n    int msh[n];\n    for (int i = 0; i < n; i++)\n        msh[i] = rot[i].h;\n\n    for (int i = 1; i < n; i++)\n        for (int j = 0; j < i; j++)\n            if (rot[i].w < rot[j].w &&\n                    rot[i].d < rot[j].d &&\n                    msh[i] < msh[j] + rot[i].h\n                    ) {\n                msh[i] = msh[j] + rot[i].h;\n            }\n\n\n    int max = -1;\n    for (int i = 0; i < n; i++)\n        if (max < msh[i])\n            max = msh[i];\n\n    return max;\n}\n\nint main() {\n    Box arr[] = {\n        {4, 6, 7},\n        {1, 2, 3},\n        {4, 5, 6},\n        {10, 12, 32}\n    };\n    int n = sizeof (arr) / sizeof (arr[0]);\n\n    printf(\"The maximum possible height of stack is %d\\n\",\n            maxStackHeight(arr, n));\n\n    return 0;\n}\n",
    "py": "class Box: \n    def __init__(self, h, w, d): \n        self.h = h \n        self.w = w \n        self.d = d \n\n    def __lt__(self, other): \n        return self.d * self.w < other.d * other.w \n\ndef maxStackHeight(arr, n): \n    rot = [Box(0, 0, 0) for _ in range(3 * n)] \n    index = 0\n    for i in range(n): \n        rot[index].h = arr[i].h \n        rot[index].d = max(arr[i].d, arr[i].w) \n        rot[index].w = min(arr[i].d, arr[i].w) \n        index += 1\n        rot[index].h = arr[i].w \n        rot[index].d = max(arr[i].h, arr[i].d) \n        rot[index].w = min(arr[i].h, arr[i].d) \n        index += 1\n        rot[index].h = arr[i].d \n        rot[index].d = max(arr[i].h, arr[i].w) \n        rot[index].w = min(arr[i].h, arr[i].w) \n        index += 1\n    n *= 3\n    rot.sort(reverse=True) \n\n    # Uncomment following two lines to print \n    # all rotations \n    # for i in range(n): \n    #    print(rot[i].h, 'x', rot[i].w, 'x', rot[i].d) \n\n    msh = [0] * n \n\n    for i in range(n): \n        msh[i] = rot[i].h \n    for i in range(1, n): \n        for j in range(0, i): \n            if (rot[i].w < rot[j].w and\n                rot[i].d < rot[j].d): \n                if msh[i] < msh[j] + rot[i].h: \n                    msh[i] = msh[j] + rot[i].h \n\n    maxm = -1\n    for i in range(n): \n        maxm = max(maxm, msh[i]) \n\n    return maxm \n\n\narr = [Box(4, 6, 7), Box(1, 2, 3), \n    Box(4, 5, 6), Box(10, 12, 32)] \nn = len(arr) \nprint(\"The maximum possible height of stack is\", \n      maxStackHeight(arr, n)) \n",
    "orden": 9,
    "suborden": 6,
    "fecha_creacion": "2020-12-06 19:51:42",
    "fecha_modificacion": "2022-03-08 12:19:51"
  },
  {
    "ID": 221,
    "supergrupo": "DP",
    "tema": "Secuencia máxima de sumas incrementales desde prefijos",
    "texto": "Dada una matriz de n enteros positivos, escriba un programa para encontrar la suma máxima de subsecuencia creciente desde el prefijo hasta el índice i-ésimo y también incluya un elemento k-ésimo dado que está después de i, es decir, k> i.\nEjemplos:\n \nEntrada: arr [] = {1, 101, 2, 3, 100, 4, 5} i-ésimo índice = 4 (el elemento del cuarto índice es 100) K-ésimo índice = 6 (el elemento del sexto índice es 5.)\nSalida: 11\nExplicación:\nPor lo tanto, necesitamos calcular la suma máxima de la subsecuencia (1 101 2 3 100 5) de modo que 5 se incluya necesariamente en la subsecuencia, por lo que la respuesta es 11 por subsecuencia (1 2 3 5).\nEntrada: arr [] = {1, 101, 2, 3, 100, 4, 5} i-ésimo índice = 2 (el elemento en el segundo índice es 2) K-ésimo índice = 5 (el elemento en el quinto índice es 4.)\nSalida: 7\nExplicación:\nPor lo tanto, debemos calcular la suma máxima de la subsecuencia (1101 2 4) de modo que 4 se incluya necesariamente en la subsecuencia, por lo que la respuesta es 7 por subsecuencia (1 2 4).\n\nEnfoque ingenuo:\n \n1. Construya una nueva matriz que contenga elementos hasta el índice i y el elemento k.\n2. Calcule de forma recursiva todas las subsecuencias crecientes.\n3. Descarte todas las subsecuencias que no tengan el k-ésimo elemento incluido.\n4. Calcule la suma máxima de las subsecuencias restantes y visualícela.\n\nMejor enfoque: utilice un enfoque dinámico para mantener una tabla dp [] []. El valor de dp [i] [k] almacena la suma máxima de la subsecuencia creciente hasta el índice i y que contiene el elemento k.\n\nEnfoque eficiente: este problema consiste básicamente en encontrar que la suma máxima de la subsecuencia creciente hasta el índice i dado es que todos los elementos de la subsecuencia son menores que el elemento kth (índice) o arr [k]. Por lo tanto, encuentre la subsecuencia creciente de suma máxima.\n \nPor ejemplo: arr [] = {1, 101, 2, 3, 100, 4, 5}, index = 4; k = 6;\nAhora, necesitamos encontrar la subsecuencia de suma máxima desde la matriz hasta el índice 4 dado que todos los elementos de esa subsecuencia son menores que arr [k] que es 5. Ahora, iterando a través de la matriz.\nPara i = 0; como 1 <5; max subsecuencia creciente {1}, max = 1.\nPara i = 1; como 101> 5; omita esta entrada. Subsecuencia creciente máx. {1}, máx = 1.\nPara i = 2; como 2 <5; max subsecuencia creciente {1, 2}, max = 3.\nPara i = 3; como 3 <5; max subsecuencia creciente {1, 2, 3}, max = 6.\nPara i = 4; como 100> 5; omita esta entrada. Subsecuencia creciente máx. {1, 2, 3}, máx = 6.\ncomo índice = 4; por lo tanto, deténgase aquí y la respuesta será max + a [k] = 6 + 5 = 11.\n",
    "complejidad_tiempo": null,
    "java": "// Programa Java para encontrar la suma máxima que aumenta la subsecuencia \n// del índice i-ésimo e incluye el índice k-ésimo.\n\npublic class MaximumSumIncreasingSubsequenceFromPrefix {\n\n    static int pre_compute(int a[], int n,\n            int index, int k) {\n        int dp[][] = new int[n][n];\n\n        // Inicializando la primera fila del dp[][].\n        for (int i = 0; i < n; i++) {\n            if (a[i] > a[0]) {\n                dp[0][i] = a[i] + a[0];\n            } else {\n                dp[0][i] = a[i];\n            }\n        }\n\n        // Creando la matriz dp[][].\n        for (int i = 1; i < n; i++) {\n            for (int j = 0; j < n; j++) {\n                if (a[j] > a[i] && j > i) {\n                    if (dp[i - 1][i] + a[j]\n                            > dp[i - 1][j]) {\n                        dp[i][j] = dp[i - 1][i]\n                                + a[j];\n                    } else {\n                        dp[i][j] = dp[i - 1][j];\n                    }\n                } else {\n                    dp[i][j] = dp[i - 1][j];\n                }\n            }\n        }\n\n        // Calcular para i = 4 y k = 6.\n        return dp[index][k];\n    }\n\n    public static void main(String[] args) {\n        int a[] = {1, 101, 2, 3, 100, 4, 5};\n        int n = a.length;\n        int index = 4, k = 6;\n        System.out.println(\n                pre_compute(a, n, index, k));\n    }\n}\n",
    "cpp": "#include <bits/stdc++.h> \nusing namespace std;\n\nint pre_compute(int a[], int n, int index, int k) {\n    int dp[n][n];\n\n    for (int i = 0; i < n; i++) {\n        if (a[i] > a[0]) {\n            dp[0][i] = a[i] + a[0];\n        } else {\n            dp[0][i] = a[i];\n        }\n    }\n\n    for (int i = 1; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            if (a[j] > a[i] && j > i) {\n                if (dp[i - 1][i] + a[j]\n                        > dp[i - 1][j]) {\n                    dp[i][j] = dp[i - 1][i]\n                            + a[j];\n                } else {\n                    dp[i][j] = dp[i - 1][j];\n                }\n            } else {\n                dp[i][j] = dp[i - 1][j];\n            }\n        }\n    }\n\n    return dp[index][k];\n}\n\nint main() {\n    int a[] = {1, 101, 2, 3, 100, 4, 5};\n    int n = sizeof (a) / sizeof (a[0]);\n    int index = 4, k = 6;\n    cout << pre_compute(a, n, index, k) << endl;\n}\n",
    "py": "def pre_compute(a, n, index, k):\n    dp = [[0 for i in range(n)]for j in range(n)]\n    for i in range (n):\n        if (a[i] > a[0]):\n            dp[0][i] = a[i] + a[0]\n        else:\n            dp[0][i] = a[i]\n\n    for i in range (n):\n        for j in range (n):\n            if (a[j] > a[i] and j > i):\n                if (dp[i - 1][i] + a[j] > dp[i - 1][j]):\n                    dp[i][j] = dp[i - 1][i] + a[j];\n                else:\n                    dp[i][j] = dp[i - 1][j]\n            else:\n                dp[i][j] = dp[i - 1][j]\n    return dp[index][k];\n\na = [1, 101, 2, 3, 100, 4, 5]\nn = len(a)\nindex = 4\nk = 6\nprint(pre_compute(a, n, index, k) + 1)\n",
    "orden": 9,
    "suborden": 7,
    "fecha_creacion": "2020-12-06 19:51:43",
    "fecha_modificacion": "2022-03-08 12:19:51"
  },
  {
    "ID": 222,
    "supergrupo": "DP",
    "tema": "Minima suma en particiones ",
    "texto": "Dado un conjunto de números enteros, la tarea es dividirlo en dos conjuntos S1 y S2 de manera que la diferencia absoluta entre sus sumas sea mínima.\nSi hay un conjunto S con n elementos, entonces si asumimos que Subconjunto1 tiene m elementos, Subconjunto2 debe tener n-m elementos y el valor de abs (suma (Subconjunto1) - suma (Subconjunto2)) debe ser mínimo.\nEjemplo:\nEntrada: arr [] = {1, 6, 11, 5}\nSalida: 1\nExplicación:\nSubconjunto1 = {1, 5, 6}, suma de Subconjunto1 = 12\nSubconjunto2 = {11}, suma de Subconjunto2 = 11\n\nSolución recursiva\nEl enfoque recursivo consiste en generar todas las sumas posibles a partir de todos los valores de la matriz y comprobar qué solución es la más óptima.\nPara generar sumas, incluimos el elemento i en el conjunto 1 o no lo incluimos, es decir, lo incluimos en el conjunto 2.\n\nComplejidad del tiempo:\nTodas las sumas pueden ser generadas por\n(1) incluyendo ese elemento en el conjunto 1.\n(2) sin incluir ese elemento en el conjunto 1.\nEntonces las posibles combinaciones son: -\narr [0] (1 o 2) -> 2 valores\narr [1] (1 o 2) -> 2 valores\n.\n.\n.\narr [n] (2 o 2) -> 2 valores\nEntonces, la complejidad del tiempo será 2 * 2 * ..... * 2 (Para n veces),\neso es O (2 ^ n).\n\nProgramación dinámica\nEl problema se puede resolver mediante programación dinámica cuando la suma de los elementos no es demasiado grande. Podemos crear una matriz 2D dp [n + 1] [suma + 1] donde n es un número de elementos en un conjunto dado y suma es la suma de todos los elementos. Podemos construir la solución de forma ascendente.\n\n\n\nLa tarea consiste en dividir el conjunto en dos partes.\nConsideraremos los siguientes factores para dividirlo.\nDejar\n  dp [n + 1] [suma + 1] = {1 si algún subconjunto del 1 al i tiene una suma\n                      igual a j\n                   0 de lo contrario}\n    \n    i varía de {1..n}\n    j oscila entre {0 .. (suma de todos los elementos)}\n\nEntonces\n    dp [n + 1] [suma + 1] será 1 si\n    1) La suma j se logra incluyendo el ítem i.\n    2) La suma j se obtiene excluyendo el ítem i.\n\nSea la suma de todos los elementos S.\n\nPara encontrar la diferencia de suma mínima, w tenemos que encontrar j tales\nese Min {suma - j * 2: dp [n] [j] == 1}\n    donde j varía de 0 a suma / 2\n\nLa idea es que la suma de S1 es j y debería ser la más cercana\na sum / 2, es decir, 2 * j debe ser el más cercano a sum.\n\nComplejidad de tiempo = O (n * suma) donde n es el número de elementos y suma es la suma de todos los elementos.\n",
    "complejidad_tiempo": null,
    "java": "// Un programa Java recursivo para resolver el problema de partición de suma mínima.\n\npublic class MinimumSumPartition {\n    // Devuelve el valor mínimo de la diferencia de los dos conjuntos.\n\n    static int findMin(int arr[], int n) {\n        // Calcular la suma de todos los elementos\n        int sum = 0;\n        for (int i = 0; i < n; i++) {\n            sum += arr[i];\n        }\n\n        // Cree una matriz para almacenar los resultados de los subproblemas\n        boolean dp[][] = new boolean[n + 1][sum + 1];\n\n        // Inicialice la primera columna como verdadera. \n        // La suma 0 es posible con todos los elementos.\n        for (int i = 0; i <= n; i++) {\n            dp[i][0] = true;\n        }\n\n        // Inicialice la fila superior, excepto dp [0] [0], \n        // como falso. Con 0 elementos, no es posible ninguna otra suma excepto 0\n        for (int i = 1; i <= sum; i++) {\n            dp[0][i] = false;\n        }\n\n        // Llene la tabla de partición de abajo hacia arriba\n        for (int i = 1; i <= n; i++) {\n            for (int j = 1; j <= sum; j++) {\n                // Si se excluye el i-ésimo elemento\n                dp[i][j] = dp[i - 1][j];\n\n                // Si se incluye i'th elemento\n                if (arr[i - 1] <= j) {\n                    dp[i][j] |= dp[i - 1][j - arr[i - 1]];\n                }\n            }\n        }\n\n        // Inicialice la diferencia de dos sumas.\n        int diff = Integer.MAX_VALUE;\n\n        // Encuentre el j más grande tal que dp [n] [j] \n        // sea verdadero donde j hace un ciclo de suma / 2 t0 0\n        for (int j = sum / 2; j >= 0; j--) {\n            if (dp[n][j] == true) {\n                diff = sum - 2 * j;\n                break;\n            }\n        }\n        return diff;\n    }\n\n    public static void main(String[] args) {\n        int arr[] = {3, 1, 4, 2, 2, 1};\n        int n = arr.length;\n        System.out.println(\"The minimum difference between 2 sets is \"\n                + findMin(arr, n));\n    }\n}\n",
    "cpp": "#include <bits/stdc++.h> \nusing namespace std;\n\nint findMin(int arr[], int n) {\n\n    int sum = 0;\n    for (int i = 0; i < n; i++)\n        sum += arr[i];\n\n    bool dp[n + 1][sum + 1];\n\n    for (int i = 0; i <= n; i++)\n        dp[i][0] = true;\n\n    for (int i = 1; i <= sum; i++)\n        dp[0][i] = false;\n    for (int i = 1; i <= n; i++) {\n        for (int j = 1; j <= sum; j++) {\n            dp[i][j] = dp[i - 1][j];\n            if (arr[i - 1] <= j)\n                dp[i][j] |= dp[i - 1][j - arr[i - 1]];\n        }\n    }\n    int diff = INT_MAX;\n    for (int j = sum / 2; j >= 0; j--) {\n        if (dp[n][j] == true) {\n            diff = sum - 2 * j;\n            break;\n        }\n    }\n    return diff;\n}\n\nint main() {\n    int arr[] = {3, 1, 4, 2, 2, 1};\n    int n = sizeof (arr) / sizeof (arr[0]);\n    cout << \"The minimum difference between 2 sets is \"\n            << findMin(arr, n);\n    return 0;\n}\n",
    "py": "import sys\n \n\ndef findMin(a, n):      \n    su = 0\n    su = sum(a) \n    dp = [[0 for i in range(su + 1)] \n        for j in range(n + 1)] \n    for i in range(n + 1): \n        dp[i][0] = True\n    for j in range(1, su + 1): \n        dp[0][j] = False\n    for i in range(1, n + 1): \n        for j in range(1, su + 1): \n            dp[i][j] = dp[i - 1][j]  \n            if a[i - 1] <= j: \n                dp[i][j] |= dp[i - 1][j - a[i - 1]] \n    diff = sys.maxsize \n    for j in range(su // 2, -1, -1): \n        if dp[n][j] == True: \n            diff = su - (2 * j) \n            break\n                        \n    return diff \n        \na = [3, 1, 4, 2, 2, 1] \nn = len(a) \n        \nprint(\"The minimum difference between \"\n      \"2 sets is \", findMin(a, n)) \n",
    "orden": 9,
    "suborden": 8,
    "fecha_creacion": "2020-12-06 19:51:43",
    "fecha_modificacion": "2022-03-08 12:19:51"
  },
  {
    "ID": 223,
    "supergrupo": "DP",
    "tema": "Camino más largo en una matriz usando DP",
    "texto": "Dada una matriz n * n donde todos los números son distintos, encuentre la ruta de longitud máxima (comenzando desde cualquier celda) de modo que todas las celdas a lo largo de la ruta estén en orden creciente con una diferencia de 1.\nPodemos movernos en 4 direcciones desde una celda dada (i, j), es decir, podemos movernos a (i + 1, j) o (i, j + 1) o (i-1, j) o (i, j -1) con la condición de que las celdas adyacentes tengan una diferencia de 1.\nEjemplo:\nEntrada: mat [] [] = {{1, 2, 9}\n                   {5, 3, 8}\n                   {4, 6, 7}}\nSalida: 4\nEl camino más largo es 6-7-8-9.\nLa idea es simple, calculamos la ruta más larga comenzando con cada celda. Una vez que hemos calculado el máximo para todas las celdas, devolvemos el máximo de todas las rutas más largas. Una observación importante en este enfoque son muchos subproblemas superpuestos. Por lo tanto, este problema se puede resolver de manera óptima mediante la programación dinámica.\nA continuación se muestra una implementación basada en Programación dinámica que usa una tabla de búsqueda dp [] [] para verificar si un problema ya está resuelto o no.\nLa complejidad temporal de la solución es O (n2). Puede parecer más a primera vista. Si miramos más de cerca, podemos notar que todos los valores de dp [i] [j] se calculan solo una vez.\n",
    "complejidad_tiempo": null,
    "java": "// Programa Java para encontrar la ruta más larga en una matriz con restricciones dadas\n\npublic class DPLongestPath {\n\n    public static int n = 3;\n\n    // Función que devuelve la longitud de la ruta más larga que comienza con mat [i] [j]\n    // Esta función usa principalmente la tabla de búsqueda dp [n] [n]\n    static int findLongestFromACell(int i, int j, int mat[][], int dp[][]) {\n        // Base case \n        if (i < 0 || i >= n || j < 0 || j >= n) {\n            return 0;\n        }\n\n        // Si este subproblema ya está resuelto\n        if (dp[i][j] != -1) {\n            return dp[i][j];\n        }\n\n        // Para almacenar las longitudes de la ruta en las cuatro direcciones\n        int x = Integer.MIN_VALUE, y = Integer.MIN_VALUE, z = Integer.MIN_VALUE, w = Integer.MIN_VALUE;\n        // Dado que todos los números son únicos y están en el \n        // rango de 1 an * n, hay al menos una dirección posible desde cualquier celda\n        if (j < n - 1 && ((mat[i][j] + 1) == mat[i][j + 1])) {\n            x = dp[i][j] = 1 + findLongestFromACell(i, j + 1, mat, dp);\n        }\n\n        if (j > 0 && (mat[i][j] + 1 == mat[i][j - 1])) {\n            y = dp[i][j] = 1 + findLongestFromACell(i, j - 1, mat, dp);\n        }\n\n        if (i > 0 && (mat[i][j] + 1 == mat[i - 1][j])) {\n            z = dp[i][j] = 1 + findLongestFromACell(i - 1, j, mat, dp);\n        }\n\n        if (i < n - 1 && (mat[i][j] + 1 == mat[i + 1][j])) {\n            w = dp[i][j] = 1 + findLongestFromACell(i + 1, j, mat, dp);\n        }\n\n        // Si ninguno de los cuatro adyacentes es uno mayor, tomaremos 1; \n        // de lo contrario, elegiremos el máximo de las cuatro direcciones.\n        return dp[i][j] = Math.max(x, Math.max(y, Math.max(z, Math.max(w, 1))));\n    }\n\n    // Función que devuelve la longitud de la ruta más \n    // larga que comienza con cualquier celda\n    static int finLongestOverAll(int mat[][]) {\n        // Inicializar resultado\n        int result = 1;\n\n        // Cree una tabla de búsqueda y complete todas las entradas en ella como -1\n        int[][] dp = new int[n][n];\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n; j++) {\n                dp[i][j] = -1;\n            }\n        }\n\n        // Calcule la ruta más larga comenzando desde todas las celdas\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n; j++) {\n                if (dp[i][j] == -1) {\n                    findLongestFromACell(i, j, mat, dp);\n                }\n\n                // Actualizar el resultado si es necesario\n                result = Math.max(result, dp[i][j]);\n            }\n        }\n\n        return result;\n    }\n\n    public static void main(String[] args) {\n        int mat[][] = {{1, 2, 9},\n        {5, 3, 8},\n        {4, 6, 7}};\n        System.out.println(\"Length of the longest path is \" + finLongestOverAll(mat));\n    }\n}\n",
    "cpp": "#include <bits/stdc++.h> \n#define n 3 \nusing namespace std;\n\nint findLongestFromACell(int i, int j, int mat[n][n], int dp[n][n]) {\n    if (i < 0 || i >= n || j < 0 || j >= n)\n        return 0;\n    if (dp[i][j] != -1)\n        return dp[i][j];\n    int x = INT_MIN, y = INT_MIN, z = INT_MIN, w = INT_MIN;\n\n    if (j < n - 1 && ((mat[i][j] + 1) == mat[i][j + 1]))\n        x = 1 + findLongestFromACell(i, j + 1, mat, dp);\n\n    if (j > 0 && (mat[i][j] + 1 == mat[i][j - 1]))\n        y = 1 + findLongestFromACell(i, j - 1, mat, dp);\n\n    if (i > 0 && (mat[i][j] + 1 == mat[i - 1][j]))\n        z = 1 + findLongestFromACell(i - 1, j, mat, dp);\n\n    if (i < n - 1 && (mat[i][j] + 1 == mat[i + 1][j]))\n        w = 1 + findLongestFromACell(i + 1, j, mat, dp);\n\n    return dp[i][j] = max(x, max(y, max(z, max(w, 1))));\n}\n\nint finLongestOverAll(int mat[n][n]) {\n    int result = 1;\n    int dp[n][n];\n    memset(dp, -1, sizeof dp);\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            if (dp[i][j] == -1)\n                findLongestFromACell(i, j, mat, dp);\n            result = max(result, dp[i][j]);\n        }\n    }\n\n    return result;\n}\n\nint main() {\n    int mat[n][n] = {\n        { 1, 2, 9},\n        { 5, 3, 8},\n        { 4, 6, 7}\n    };\n    cout << \"Length of the longest path is \"\n            << finLongestOverAll(mat);\n    return 0;\n} \n",
    "py": "n = 3 \ndef findLongestFromACell(i, j, mat, dp): \n\n    if (i < 0 or i >= n or j < 0 or j >= n): \n        return 0\n\n    if (dp[i][j] != -1):  \n        return dp[i][j] \n    x, y, z, w = -1, -1, -1, -1\n    if (j < n-1 and ((mat[i][j] + 1) == mat[i][j + 1])): \n        x = 1 + findLongestFromACell(i, j + 1, mat, dp) \n  \n    if (j > 0 and (mat[i][j] + 1 == mat[i][j-1])):  \n        y = 1 + findLongestFromACell(i, j-1, mat, dp) \n  \n    if (i > 0 and (mat[i][j] + 1 == mat[i-1][j])): \n        z = 1 + findLongestFromACell(i-1, j, mat, dp) \n  \n    if (i < n-1 and (mat[i][j] + 1 == mat[i + 1][j])): \n        w = 1 + findLongestFromACell(i + 1, j, mat, dp) \n    dp[i][j] = max(x, max(y, max(z, max(w, 1)))) \n    return dp[i][j] \n  \ndef finLongestOverAll(mat): \n    result = 1 \n    dp = [[-1 for i in range(n)]for i in range(n)] \n    for i in range(n): \n        for j in range(n): \n            if (dp[i][j] == -1): \n                findLongestFromACell(i, j, mat, dp) \n            result = max(result, dp[i][j]);  \n    return result \n  \nmat = [[1, 2, 9], \n    [5, 3, 8], \n    [4, 6, 7]]  \nprint(\"Length of the longest path is \", finLongestOverAll(mat)) \n",
    "orden": 9,
    "suborden": 9,
    "fecha_creacion": "2020-12-06 19:51:43",
    "fecha_modificacion": "2022-03-08 12:19:51"
  },
  {
    "ID": 224,
    "supergrupo": "Grafos",
    "tema": "Puntos de articulación",
    "texto": "Un vértice en un gráfico conectado no dirigido es un punto de articulación (o vértice de corte) si al eliminarlo (y las aristas a través de él) se desconecta el gráfico. Los puntos de articulación representan vulnerabilidades en una red conectada: puntos únicos cuya falla dividiría la red en 2 o más componentes. Son útiles para diseñar redes confiables.\nPara un gráfico no dirigido desconectado, un punto de articulación es una eliminación de vértices que aumenta el número de componentes conectados.\nA continuación se muestran algunos ejemplos de gráficos con puntos de articulación rodeados de color rojo.\n\n¿Cómo encontrar todos los puntos de articulación en un gráfico dado?\nUn enfoque simple es eliminar uno por uno todos los vértices y ver si la eliminación de un vértice causa un gráfico desconectado. Los siguientes son pasos de enfoque simple para gráficos conectados.\n1) Para cada vértice v, haga lo siguiente\n… ..A) Eliminar v del gráfico\n..… b) Vea si el gráfico permanece conectado (podemos usar BFS o DFS)\n… ..C) Suma v de nuevo al gráfico\n\nLa complejidad del tiempo del método anterior es O (V * (V + E)) para un gráfico representado mediante una lista de adyacencia. ¿Podemos hacerlo mejor?\n\nUn algoritmo O (V + E) para encontrar todos los puntos de articulación (AP)\nLa idea es utilizar DFS (Depth First Search). En DFS, seguimos los vértices en forma de árbol llamados árbol DFS. En el árbol DFS, un vértice u es padre de otro vértice v, si v es descubierto por u (obviamente v es un adyacente de u en el gráfico). En el árbol DFS, un vértice u es un punto de articulación si se cumple una de las dos condiciones siguientes.\n1) u es la raíz del árbol DFS y tiene al menos dos hijos.\n2) u no es la raíz del árbol DFS y tiene un hijo v tal que ningún vértice en el subárbol enraizado con v tiene una arista posterior a uno de los antepasados (en el árbol DFS) de u.\n\nHacemos un recorrido DFS de un gráfico dado con código adicional para averiguar los puntos de articulación (AP). En el recorrido DFS, mantenemos una matriz padre [] donde padre [u] almacena padre del vértice u. Entre los dos casos mencionados anteriormente, el primer caso es fácil de detectar. Para cada vértice, cuente los niños. Si el vértice u actualmente visitado es raíz (el padre [u] es NULO) y tiene más de dos hijos, imprímalo.\n\n¿Cómo manejar el segundo caso? El segundo caso es más complicado. Mantenemos un disc de matriz [] para almacenar el tiempo de descubrimiento de los vértices. Para cada nodo u, necesitamos encontrar el vértice visitado más temprano (el vértice con el tiempo mínimo de descubrimiento) que se puede alcanzar desde el subárbol enraizado con u. Así que mantenemos una matriz adicional baja [] que se define de la siguiente manera.\n\nlow [u] = min (disc [u], disc [w])\ndonde w es un antepasado de u y hay una arista posterior de\nalgún descendiente de u a w.\n",
    "complejidad_tiempo": null,
    "java": "//Encontrando los puntos de articulación en un grafo no dirigido \n\nimport java.util.Iterator;\nimport java.util.LinkedList;\n\n\npublic class ArticulationBridges {\n    // Esta clase representa un gráfico no dirigido \n    // usando una lista de adyacencia\n    static class Graph {\n\n        private int V; // No. de vertices \n\n        // array de listas para la representación de la adyacencia\n        private LinkedList<Integer> adj[];\n        int time = 0;\n        static final int NIL = -1;\n        Graph(int v) {\n            V = v;\n            adj = new LinkedList[v];\n            for (int i = 0; i < v; ++i) {\n                adj[i] = new LinkedList();\n            }\n        }\n\n        //Agregar caminos en el grafo\n        void addEdge(int v, int w) {\n            adj[v].add(w); \n            adj[w].add(v); \n        }\n\n        //Una función recursiva que encuentra puntos de articulación usando DFS\n        //u -> El vértice a visitar a continuación\n        //visited [] -> mantiene un tramo de vértices visitados\n        //disc [] -> Almacena las veces de descubrimiento de los vértices visitados\n        //parent [] -> Almacena los vértices principales en el árbol DFS\n        //ap [] -> Almacenar puntos de articulación\n        void APUtil(int u, boolean visited[], int disc[],\n                int low[], int parent[], boolean ap[]) {\n\n            // conteo de hijos en el arbol de DFS\n            int children = 0;\n\n            // Marcando el nodo actual como visitado\n            visited[u] = true;\n\n            // Inicializar las veces de descubrimiento y el valor bajo\n            disc[u] = low[u] = ++time;\n\n            // Pasa por todos los vértices adyacentes a este\n            Iterator<Integer> i = adj[u].iterator();\n            while (i.hasNext()) {\n                int v = i.next(); // v es adyacente de u \n                //Si v aún no se ha visitado, conviértalo en hijo de u en el \n                //árbol DFS y recurse para él\n                if (!visited[v]) {\n                    children++;\n                    parent[v] = u;\n                    APUtil(v, visited, disc, low, parent, ap);\n\n                    //Compruebe si el subárbol enraizado con v \n                    //tiene una conexión con uno de los antepasados de u\n                    low[u] = Math.min(low[u], low[v]);\n\n                    //u es un punto de articulación en los siguientes casos\n                    //(1) u es la raíz del árbol DFS y tiene dos o más hijos.\n                    if (parent[u] == NIL && children > 1) {\n                        ap[u] = true;\n                    }\n\n                    //(2) Si u no es raíz y el valor bajo de uno de sus hijos es \n                    //mayor que el valor de descubrimiento de u.\n                    if (parent[u] != NIL && low[v] >= disc[u]) {\n                        ap[u] = true;\n                    }\n                } // Actualice el valor bajo de u para las llamadas a funciones \n                  // padre.\n                else if (v != parent[u]) {\n                    low[u] = Math.min(low[u], disc[v]);\n                }\n            }\n        }\n\n        // La función para hacer un recorrido DFS. Utiliza la función recursiva APUtil ()\n        void AP() {\n            boolean visited[] = new boolean[V];\n            int disc[] = new int[V];\n            int low[] = new int[V];\n            int parent[] = new int[V];\n            boolean ap[] = new boolean[V]; // para almacenar los puntos \n            //de articulación\n\n            // Inicializar matrices parent y \n            //visited, y ap (punto de articulación)\n            for (int i = 0; i < V; i++) {\n                parent[i] = NIL;\n                visited[i] = false;\n                ap[i] = false;\n            }\n            //Llame a la función auxiliar recursiva para encontrar puntos de \n            //articulación en el árbol DFS enraizado con el vértice 'i'\n            for (int i = 0; i < V; i++) {\n                if (visited[i] == false) {\n                    APUtil(i, visited, disc, low, parent, ap);\n                }\n            }\n\n            // Ahora ap [] contiene puntos de articulación, imprímalos\n            for (int i = 0; i < V; i++) {\n                if (ap[i] == true) {\n                    System.out.print(i + \" \");\n                }\n            }\n        }\n    }\n\n    public static void main(String args[]) {\n        System.out.println(\"Puntos de articulación en el grafo \");\n        Graph g1 = new Graph(5);\n        g1.addEdge(1, 0);\n        g1.addEdge(0, 2);\n        g1.addEdge(2, 1);\n        g1.addEdge(0, 3);\n        g1.addEdge(3, 4);\n        g1.AP();\n        System.out.println();\n\n        System.out.println(\"Puntos de articulación en el grafo\");\n        Graph g2 = new Graph(4);\n        g2.addEdge(0, 1);\n        g2.addEdge(1, 2);\n        g2.addEdge(2, 3);\n        g2.AP();\n        System.out.println();\n\n        System.out.println(\"Puntos de articulación en el grafo \");\n        Graph g3 = new Graph(7);\n        g3.addEdge(0, 1);\n        g3.addEdge(1, 2);\n        g3.addEdge(2, 0);\n        g3.addEdge(1, 3);\n        g3.addEdge(1, 4);\n        g3.addEdge(1, 6);\n        g3.addEdge(3, 5);\n        g3.addEdge(4, 5);\n        g3.AP();\n    }\n}\n",
    "cpp": "#include <cstdlib>\n#include <bits/stdc++.h>\n#define  MAX 105\nusing namespace std;\n\nstruct Graph {\n    int V;\n    vector<int> adj[MAX];\n    int time = 0;\n    int NIL = -1;\n\n    void addEdge(int v, int w) {\n        adj[v].emplace_back(w);\n        adj[w].emplace_back(v);\n    }\n\n    void APUtil(int u, bool visited[], int disc[],\n            int low[], int parent[], bool ap[]) {\n        static int time = 0;\n        int children = 0;\n        visited[u] = true;\n        disc[u] = low[u] = ++time;\n        for (int i = 0; i < adj[u].size(); i++) {\n            int v = adj[u].at(i);\n            if (!visited[v]) {\n                children++;\n                parent[v] = u;\n                APUtil(v, visited, disc, low, parent, ap);\n                low[u] = min(low[u], low[v]);\n                if (parent[u] == NIL && children > 1)\n                    ap[u] = true;\n                if (parent[u] != NIL && low[v] >= disc[u])\n                    ap[u] = true;\n            } else if (v != parent[u])\n                low[u] = min(low[u], disc[v]);\n        }\n    }\n\n    void AP() {\n        bool visited[V];\n        int disc[V];\n        int low [V];\n        int parent[V];\n        bool ap[V];\n        for (int i = 0; i < V; i++) {\n            parent[i] = NIL;\n            visited[i] = false;\n            ap[i] = false;\n        }\n        for (int i = 0; i < V; i++)\n            if (visited[i] == false)\n                APUtil(i, visited, disc, low, parent, ap);\n        for (int i = 0; i < V; i++)\n            if (ap[i] == true)\n                cout << i << \" \";\n    }\n\n\n};\n\nint main() {\n    // Create graphs given in above diagrams \n    cout << \"Puntos de articulación en el grafo\" << endl;\n    Graph g1;\n    g1.V = 5;\n    g1.addEdge(1, 0);\n    g1.addEdge(0, 2);\n    g1.addEdge(2, 1);\n    g1.addEdge(0, 3);\n    g1.addEdge(3, 4);\n    g1.AP();\n    cout << endl;\n\n    cout << \"Puntos de articulación en el grafo\" << endl;\n    Graph g2;\n    g2.V = 4;\n    g2.addEdge(0, 1);\n    g2.addEdge(1, 2);\n    g2.addEdge(2, 3);\n    g2.AP();\n    cout << endl;\n\n    cout << \"Puntos de articulación en el grafo\" << endl;\n    Graph g3;\n    g3.V=7;\n    g3.addEdge(0, 1);\n    g3.addEdge(1, 2);\n    g3.addEdge(2, 0);\n    g3.addEdge(1, 3);\n    g3.addEdge(1, 4);\n    g3.addEdge(1, 6);\n    g3.addEdge(3, 5);\n    g3.addEdge(4, 5);\n    g3.AP();\n}\n",
    "py": "from collections import defaultdict \n\nclass Graph: \n        def __init__(self,vertices): \n                self.V= vertices \n                self.graph = defaultdict(list)\n                self.Time = 0\n        def addEdge(self,u,v): \n                self.graph[u].append(v) \n                self.graph[v].append(u) \n        def APUtil(self,u, visited, ap, parent, low, disc): \n                children =0\n                visited[u]= True\n                disc[u] = self.Time \n                low[u] = self.Time \n                self.Time += 1\n                for v in self.graph[u]: \n                        if visited[v] == False : \n                                parent[v] = u \n                                children += 1\n                                self.APUtil(v, visited, ap, parent, low, disc) \n                                low[u] = min(low[u], low[v]) \n                                if parent[u] == -1 and children > 1: \n                                        ap[u] = True\n                                if parent[u] != -1 and low[v] >= disc[u]: \n                                        ap[u] = True                     \n                        elif v != parent[u]: \n                                low[u] = min(low[u], disc[v]) \n        def AP(self): \n                visited = [False] * (self.V) \n                disc = [float(\"Inf\")] * (self.V) \n                low = [float(\"Inf\")] * (self.V) \n                parent = [-1] * (self.V) \n                ap = [False] * (self.V) \n                for i in range(self.V): \n                        if visited[i] == False: \n                                self.APUtil(i, visited, ap, parent, low, disc) \n                for index, value in enumerate (ap): \n                        if value == True: print index, \ng1 = Graph(5) \ng1.addEdge(1, 0) \ng1.addEdge(0, 2) \ng1.addEdge(2, 1) \ng1.addEdge(0, 3) \ng1.addEdge(3, 4) \nprint \"Puntos de articulacion en el grafo \"\ng1.AP() \ng2 = Graph(4) \ng2.addEdge(0, 1) \ng2.addEdge(1, 2) \ng2.addEdge(2, 3) \nprint \"Puntos de articulacion en el grafo \"\ng2.AP() \ng3 = Graph (7) \ng3.addEdge(0, 1) \ng3.addEdge(1, 2) \ng3.addEdge(2, 0) \ng3.addEdge(1, 3) \ng3.addEdge(1, 4) \ng3.addEdge(1, 6) \ng3.addEdge(3, 5) \ng3.addEdge(4, 5) \nprint \"Puntos de articulacion en el grafo \"\ng3.AP() \n",
    "orden": 8,
    "suborden": 28,
    "fecha_creacion": "2020-12-06 19:51:44",
    "fecha_modificacion": "2022-03-08 12:28:52"
  },
  {
    "ID": 225,
    "supergrupo": "Grafos",
    "tema": "Puentes ",
    "texto": "Una arista en un gráfico conectado no dirigido es un puente si, al eliminarlo, se desconecta el gráfico. Para un gráfico desconectado no dirigido, la definición es similar, un puente es una eliminación de aristas que aumenta el número de componentes desconectados.\nAl igual que los puntos de articulación, los puentes representan vulnerabilidades en una red conectada y son útiles para diseñar redes confiables. Por ejemplo, en una red de computadoras cableada, un punto de articulación indica las computadoras críticas y un puente indica los cables o conexiones críticas.\nA continuación se muestran algunos gráficos de ejemplo con puentes resaltados en color rojo.\n\n¿Cómo encontrar todos los puentes en un gráfico dado?\nUn enfoque simple es eliminar uno por uno todos las aristas y ver si la eliminación de una arista provoca un gráfico desconectado. Los siguientes son pasos de enfoque simple para gráficos conectados.\n1) Para cada arista (u, v), haga lo siguiente\n… ..A) Eliminar (u, v) del gráfico\n..… b) Vea si el gráfico permanece conectado (podemos usar BFS o DFS)\n… ..C) Suma (u, v) de nuevo al gráfico.\n\nLa complejidad de tiempo del método anterior es O (E * (V + E)) para un gráfico representado usando una lista de adyacencia. ¿Podemos hacerlo mejor?\nUn algoritmo O (V + E) para encontrar todos los puentes\nLa idea es similar al algoritmo O (V + E) para los puntos de articulación. Hacemos un recorrido DFS del gráfico dado. En el árbol DFS, una arista (u, v) (u es el padre de v en el árbol DFS) es puente si no existe ninguna otra alternativa para llegar a u o un ancestro de u del subárbol enraizado con v, el valor low [v] indica el vértice visitado más temprano que se puede alcanzar desde el subárbol enraizado con v. La condición para que una arista (u, v) sea un puente es \"low [v]> disc [u]\".\n",
    "complejidad_tiempo": null,
    "java": "// buscando los puentes en un grafo\n\nimport java.util.Iterator;\nimport java.util.LinkedList;\n\npublic class BridgesInGraph {\n\n    static private int V; // No. de vertices \n\n    // Array de listas representando el grafo\n    static private LinkedList<Integer> adj[];\n    static int time = 0;\n    static final int NIL = -1;\n\n    static void init(int v) {\n        V = v;\n        adj = new LinkedList[v];\n        for (int i = 0; i < v; ++i) {\n            adj[i] = new LinkedList();\n        }\n    }\n\n    // Agregando caminos en el grafo\n    static void addEdge(int v, int w) {\n        adj[v].add(w);\n        adj[w].add(v);\n    }\n\n    // Una función recursiva que busca e imprime puentes\n    // usando DFS transversal\n    // u -> El vértice a visitar a continuación\n    // visited [] -> mantiene un tramo de vértices visitados\n    // disc [] -> Almacena las veces de descubrimiento de los vértices visitados\n    // parent [] -> Almacena los vértices padre en el árbol DFS\n    static void bridgeUtil(int u, boolean visited[], int disc[],\n            int low[], int parent[]) {\n        // Marcar nodo actual como visitado\n        visited[u] = true;\n        // Inicializar el tiempo de descubrimiento y el valor bajo\n        disc[u] = low[u] = ++time;\n\n        // Pasa por todos los vértices adyacentes a este\n        Iterator<Integer> i = adj[u].iterator();\n        while (i.hasNext()) {\n            int v = i.next(); // v es la corriente adyacente a u\n\n            // Si v aún no se ha visitado, conviértalo en hijo\n            // de u en el árbol DFS y recurra en el.\n            // Si v aún no se ha visitado, repita para ello\n            if (!visited[v]) {\n                parent[v] = u;\n                bridgeUtil(v, visited, disc, low, parent);\n\n                //Compruebe si el subárbol enraizado con v tiene \n                //una conexión con uno de los antepasados de u\n                low[u] = Math.min(low[u], low[v]);\n\n                //Si el vértice más bajo accesible desde el subárbol \n                //debajo de v está debajo de u en el árbol DFS, \n                //entonces u-v es un puente\n                if (low[v] > disc[u]) {\n                    System.out.println(u + \" \" + v);\n                }\n            } // Actualice el valor bajo de u para las llamadas a funciones principales. \n            else if (v != parent[u]) {\n                low[u] = Math.min(low[u], disc[v]);\n            }\n        }\n    }\n\n    // Función basada en DFS para encontrar todos los puentes. \n    // Utiliza la función recursiva bridgeUtil ()\n    static void bridge() {\n        // Marcar todos los vértices como no visitados\n        boolean visited[] = new boolean[V];\n        int disc[] = new int[V];\n        int low[] = new int[V];\n        int parent[] = new int[V];\n\n        // Inicializa parent, visited, y ap(articulation point)\n        for (int i = 0; i < V; i++) {\n            parent[i] = NIL;\n            visited[i] = false;\n        }\n\n        //Llame a la función auxiliar recursiva para encontrar \n        //puentes en el árbol DFS enraizado con el vértice 'i'\n        for (int i = 0; i < V; i++) {\n            if (visited[i] == false) {\n                bridgeUtil(i, visited, disc, low, parent);\n            }\n        }\n    }\n\n    public static void main(String args[]) {\n        System.out.println(\"Bridges in first graph \");\n        init(5);\n        addEdge(1, 0);\n        addEdge(0, 2);\n        addEdge(2, 1);\n        addEdge(0, 3);\n        addEdge(3, 4);\n        bridge();\n        System.out.println();\n        System.out.println(\"Bridges in second graph \");\n        init(4);\n        addEdge(0, 1);\n        addEdge(1, 2);\n        addEdge(2, 3);\n        bridge();\n        System.out.println();\n\n    }\n}\n",
    "cpp": "#include<iostream> \n#include <list> \n#define NIL -1 \n#define MAX 10000\nusing namespace std;\n\nstruct Graph {\n    int V;\n    list<int> adj[MAX];\n\n    void addEdge(int v, int w) {\n        adj[v].push_back(w);\n        adj[w].push_back(v);\n    }\n\n    void bridgeUtil(int u, bool visited[], int disc[],\n            int low[], int parent[]) {\n        static int time = 0;\n        visited[u] = true;\n        disc[u] = low[u] = ++time;\n        list<int>::iterator i;\n        for (i = adj[u].begin(); i != adj[u].end(); ++i) {\n            int v = *i;\n            if (!visited[v]) {\n                parent[v] = u;\n                bridgeUtil(v, visited, disc, low, parent);\n                low[u] = min(low[u], low[v]);\n                if (low[v] > disc[u])\n                    cout << u << \" \" << v << endl;\n            } else if (v != parent[u])\n                low[u] = min(low[u], disc[v]);\n        }\n    }\n\n    void bridge() {\n        bool visited[V];\n        int disc [V];\n        int low [V];\n        int parent[V];\n\n        for (int i = 0; i < V; i++) {\n            parent[i] = NIL;\n            visited[i] = false;\n        }\n        for (int i = 0; i < V; i++)\n            if (visited[i] == false)\n                bridgeUtil(i, visited, disc, low, parent);\n    }\n};\n\nint main() {\n    cout << \"\\nBridges in first graph \\n\";\n    Graph g1;\n    g1.V = 5;\n    g1.addEdge(1, 0);\n    g1.addEdge(0, 2);\n    g1.addEdge(2, 1);\n    g1.addEdge(0, 3);\n    g1.addEdge(3, 4);\n    g1.bridge();\n\n    cout << \"\\nBridges in second graph \\n\";\n    Graph g2;\n    g2.V = 2;\n    g2.addEdge(0, 1);\n    g2.addEdge(1, 2);\n    g2.addEdge(2, 3);\n    g2.bridge();\n}\n",
    "py": "from collections import defaultdict\n \nclass Graph: \n\n    def __init__(self, vertices): \n        self.V = vertices \n        self.graph = defaultdict(list) \n        self.Time = 0\n    def addEdge(self, u, v): \n        self.graph[u].append(v) \n        self.graph[v].append(u) \n\n    def bridgeUtil(self, u, visited, parent, low, disc): \n        visited[u] = True\n        disc[u] = self.Time \n        low[u] = self.Time \n        self.Time += 1\n        for v in self.graph[u]: \n            if visited[v] == False: \n                parent[v] = u \n                self.bridgeUtil(v, visited, parent, low, disc) \n                low[u] = min(low[u], low[v]) \n                if low[v] > disc[u]: \n                    print (\"%d %d\" % (u, v)) \n                \n            elif v != parent[u]: \n                low[u] = min(low[u], disc[v]) \n\n    def bridge(self): \n        visited = [False] * (self.V) \n        disc = [float(\"Inf\")] * (self.V) \n        low = [float(\"Inf\")] * (self.V) \n        parent = [-1] * (self.V) \n\n        for i in range(self.V): \n            if visited[i] == False: \n                self.bridgeUtil(i, visited, parent, low, disc) \n\ng1 = Graph(5) \ng1.addEdge(1, 0) \ng1.addEdge(0, 2) \ng1.addEdge(2, 1) \ng1.addEdge(0, 3) \ng1.addEdge(3, 4) \n\n\nprint \"Bridges in first graph \"\ng1.bridge() \n\ng2 = Graph(4) \ng2.addEdge(0, 1) \ng2.addEdge(1, 2) \ng2.addEdge(2, 3) \nprint \"\\nBridges in second graph \"\ng2.bridge() \n",
    "orden": 8,
    "suborden": 29,
    "fecha_creacion": "2020-12-06 19:51:44",
    "fecha_modificacion": "2022-03-08 12:28:52"
  },
  {
    "ID": 226,
    "supergrupo": "Grafos",
    "tema": "Combinatorias en arboles ordenados",
    "texto": "Un árbol ordenado es un árbol orientado en el que los hijos de un nodo están ordenados de alguna manera. Es un árbol enraizado en el que se especifica un orden para los hijos de cada vértice. A esto se le llama “árbol plano” porque ordenar los hijos equivale a incrustar el árbol en el plano, con la raíz en la parte superior y los hijos de cada vértice más abajo que ese vértice.\nEl árbol ordenado se puede especificar más como árbol ordenado etiquetado y árbol ordenado no etiquetado.\nÁrboles ordenados etiquetados: un árbol etiquetado es un árbol donde a cada vértice se le asigna un número único de 1 a n.\n \nSi T1 y T2 son árboles ordenados. Entonces, T1! = T2 de lo contrario T1 = T2.\n\nÁrboles ordenados sin etiquetar: un árbol sin etiquetar es un árbol en el que cada vértice no está etiquetado. A continuación se muestran los posibles árboles ordenados sin etiquetar que tienen 3 vértices.\n",
    "complejidad_tiempo": null,
    "java": "// código java para encontrar el número de \n//árboles ordenados con un número determinado \n//de bordes y hojas\n\npublic class CombinatoricsOnOrderedTrees {\n\n    // La función devuelve el valor del\n    // Coeficiente binomial C (n, k)\n    static int binomialCoeff(int n, int k) {\n        int[][] C = new int[n + 1][k + 1];\n        int i, j;\n        // Calculate value of Binomial \n        // Coefficient in bottom up manner \n        for (i = 0; i <= n; i++) {\n            for (j = 0; j <= Math.min(i, k); j++) {\n                if (j == 0 || j == i) {\n                    C[i][j] = 1;\n                } // Calcular valor usando valores previamente almacenados\n                else {\n                    C[i][j] = C[i - 1][j - 1]\n                            + C[i - 1][j];\n                }\n            }\n        }\n        return C[n][k];\n    }\n\n    // Función para calcular el número\n    // de árboles con exactamente k hojas.\n    static int k_Leaves(int n, int k) {\n        int ans = (binomialCoeff(n, k)\n                * binomialCoeff(n, k - 1)) / n;\n        System.out.println(\"Number of trees \"\n                + \"having 4 edges and exactly 2 \"\n                + \"leaves : \" + ans);\n        return 0;\n    }\n\n    // Función para calcular el número total de\n    // nodos de grado d en estos árboles.\n    static int numberOfNodes(int n, int d) {\n        int ans = binomialCoeff(2 * n - 1 - d,\n                n - 1);\n        System.out.println(\"Number of nodes \"\n                + \"of degree 1 in a tree having 4 \"\n                + \"edges : \" + ans);\n        return 0;\n    }\n\n    // Función para calcular el número de\n    // árboles en los que la raíz tiene grado r.\n    static int rootDegreeR(int n, int r) {\n        int ans = r * binomialCoeff(2 * n\n                - 1 - r, n - 1);\n        ans = ans / n;\n        System.out.println(\"Number of trees \"\n                + \"having 4 edges where root has\"\n                + \" degree 2 : \" + ans);\n        return 0;\n    }\n\n    public static void main(String[] args) {\n        // Número de árboles que tienen 3\n        // caminos y exactamente 2 hojas\n        k_Leaves(3, 2);\n        // Número de nodos de grado\n        // 3 en un árbol que tiene 4 caminos\n        numberOfNodes(3, 1);\n        // Número de árboles que tienen 3\n        // caminos donde la raíz tiene grado 2\n        rootDegreeR(3, 2);\n    }\n}\n",
    "cpp": "#include<bits/stdc++.h> \n#include<cstdlib>\nusing namespace std;\n\nint binomialCoeff(int n, int k) {\n    int C [n + 1][k + 1] = {0};\n    int i, j;\n    for (i = 0; i <= n; i++) {\n        for (j = 0; j <= min(i, k); j++) {\n            if (j == 0 || j == i) {\n                C[i][j] = 1;\n            } else {\n                C[i][j] = C[i - 1][j - 1] + C[i - 1][j];\n            }\n        }\n    }\n    return C[n][k];\n}\n\nstatic int k_Leaves(int n, int k) {\n    int ans = (binomialCoeff(n, k)\n            * binomialCoeff(n, k - 1)) / n;\n    cout << \"Number of trees having 4 edges and exactly 2 leaves : \"\n            << ans << endl;\n    return 0;\n}\n\nstatic int numberOfNodes(int n, int d) {\n    int ans = binomialCoeff(2 * n - 1 - d, n - 1);\n    cout << \"Number of nodes of degree 1 in a tree having 4 edges : \"\n            << ans << endl;\n    return 0;\n}\n\nstatic int rootDegreeR(int n, int r) {\n    int ans = r * binomialCoeff(2 * n\n            - 1 - r, n - 1);\n    ans = ans / n;\n    cout << \"Number of trees having 4 edges where root has degree 2 : \"\n            << ans << endl;\n    return 0;\n}\n\nint main() {\n    k_Leaves(3, 2);\n    numberOfNodes(3, 1);\n    rootDegreeR(3, 2);\n}\n",
    "py": "import math\ndef binomialCoeff(n, k):\n    C = [[0 for i in range(k + 1)] for i in range (n + 1)]\n    for i in range (n + 1):\n        aux = min(i, k)\n        for j in range (aux + 1):\n            if (j == 0 or j == i):\n                C[i][j] = 1\n            else:\n                C[i][j] = C[i - 1][j - 1] + C[i - 1][j];\n    return C[n][k];\n\ndef k_Leaves(n, k):\n    ans = (binomialCoeff(n, k) * binomialCoeff(n, k - 1)) / n\n    print(\"Number of trees having 4 edges and exactly 2 leaves : \" + str(ans))\n\ndef numberOfNodes(n, d):\n    ans = binomialCoeff(2 * n - 1 - d, n - 1);\n    print(\"Number of nodes of degree 1 in a tree having 4 edges : \" + str(ans))\n\ndef rootDegreeR(n, r):\n    ans = r * binomialCoeff(2 * n- 1 - r, n - 1)\n    ans = ans / n\n    print(\"Number of trees having 4 edges where root has degree 2 : \" + str(ans))\n\nk_Leaves(3, 2); \nnumberOfNodes(3, 1); \nrootDegreeR(3, 2);\n",
    "orden": 8,
    "suborden": 30,
    "fecha_creacion": "2020-12-06 19:51:44",
    "fecha_modificacion": "2022-03-08 12:28:52"
  },
  {
    "ID": 227,
    "supergrupo": "Grafos",
    "tema": "Conjuntos disjuntos",
    "texto": "Considere una situación con varias personas y las siguientes tareas que se realizarán en ellas.\n1. Agregue una nueva relación de amistad, es decir, una persona x se convierte en amiga de otra persona y.\n2. Encuentre si el individuo x es amigo del individuo y (amigo directo o indirecto)\nEjemplo:\nNos dan 10 personas que dicen:\na, b, c, d, e, f, g, h, yo, j\n\nA continuación se muestran las relaciones que se agregarán.\na <-> b\nb <-> d\nc <-> f\nc <-> i\nj <-> e\ng <-> j\nY dadas consultas como si a es amigo de d o no.\nBásicamente, necesitamos crear los siguientes 4 grupos y mantener una conexión de acceso rápido entre los elementos del grupo:\nG1 = {a, b, d}\nG2 = {c, f, i}\nG3 = {e, g, j}\nG4 = {h}\nProblema: Encontrar si xey pertenecen al mismo grupo o no, es decir, encontrar si xey son amigos directos / indirectos.\nSolución: dividir a los individuos en diferentes conjuntos de acuerdo con los grupos en los que se encuentran. Este método se conoce como estructura de datos de conjuntos disjuntos que mantiene la colección de conjuntos disjuntos y cada conjunto está representado por su representante, que es uno de sus miembros.\nAproximación:\n• ¿Cómo resolver conjuntos? Inicialmente, todos los elementos pertenecen a conjuntos diferentes. Después de trabajar en las relaciones dadas, seleccionamos a un miembro como representante. Puede haber muchas formas de seleccionar un representante, una simple es seleccionar con el índice más grande.\n• ¿Compruebe si hay 2 personas en el mismo grupo? Si los representantes de dos personas son iguales, se harán amigos.\n \nEstructuras de datos utilizadas:\nArray: una array de enteros, denominada padre []. Si estamos tratando con n elementos, el elemento i de la array representa el elemento i. Más precisamente, el i-ésimo elemento de la array es el padre del i-ésimo elemento. Estas relaciones crean uno o más árboles virtuales.\nÁrbol: es un conjunto disjunto. Si dos elementos están en el mismo árbol, entonces están en el mismo conjunto disjunto. El nodo raíz (o el nodo más alto) de cada árbol se denomina representante del conjunto. Siempre hay un único representante de cada conjunto. Una regla simple para identificar al representante es, si i es el representante de un conjunto, entonces padre [i] = i. Si yo no es el representante de su conjunto, entonces se puede encontrar viajando por el árbol hasta que encontremos al representante.\n \nOperaciones:\nBuscar: se puede implementar atravesando recursivamente la array principal hasta que lleguemos a un nodo que es padre de sí mismo.\n// Encuentra al representante del conjunto\n// que yo es un elemento de\nint encontrar (int i)\n{\n    // Si i es el padre de sí mismo\n    si (padre [i] == i)\n    {\n        // Entonces yo es el representante de\n        // este conjunto\n        volver i;\n    }\n    más\n    {\n        // De lo contrario, si yo no es el padre de\n        // en sí mismo, entonces yo no es el\n        // representante de su conjunto. Así que nosotros\n        // llama recursivamente Find en su padre\n        return find (padre [i]);\n    }\n}\nUnión: Toma como insumo dos elementos. Y encuentra los representantes de sus conjuntos usando la operación de búsqueda, y finalmente coloca uno de los árboles (que representa el conjunto) debajo del nodo raíz del otro árbol, fusionando efectivamente los árboles y los conjuntos.\n// Une el conjunto que incluye i\n// y el conjunto que incluye j\nunión vacía (int i, int j)\n{\n    // Encuentra los representantes\n    // (o los nodos raíz) para el conjunto\n    // eso incluye i\n    \n    int irep = this.Find (i),\n\n    // Y haz lo mismo con el set\n    // eso incluye j\n    int jrep = this.Find (j);\n\n    // Hacer el padre del representante de i\n    // ser el representante de j de forma eficaz\n    // moviendo todo el conjunto de i al conjunto de j)\n    this.Parent [irep] = jrep;\n}\nMejoras (unión por rango y compresión de ruta)\nLa eficiencia depende en gran medida de la altura del árbol. Necesitamos minimizar la altura del árbol para mejorar la eficiencia. Podemos usar Path Compression y Union por métodos de rango para hacerlo.\nCompresión de ruta (modificaciones para encontrar ()): acelera la estructura de datos al comprimir la altura de los árboles. Se puede lograr insertando un pequeño mecanismo de almacenamiento en caché en la operación de búsqueda. Eche un vistazo al código para obtener más detalles:\n// Encuentra el representante del conjunto que yo\n// es un elemento de.\nint encontrar (int i)\n{\n    // Si i es el padre de sí mismo\n    si (Padre [i] == i)\n    {\n        // Entonces yo soy el representante\n        volver i;\n    }\n    más\n    {\n        // Encontrar al representante de forma recursiva.\n        int resultado = buscar (Padre [i]);\n\n        // Almacenamos en caché el resultado moviendo el nodo i\n        // directamente bajo el representante de este\n        // establecer\n        Padre [i] = resultado;\n       \n        // Y luego devolvemos el resultado\n        devolver resultado;\n     }\n}\nUnión por rango: En primer lugar, necesitamos una nueva array de números enteros llamada rango []. El tamaño de esta array es el mismo que el de la array principal. Si i es un representante de un conjunto, el rango [i] es la altura del árbol que representa el conjunto.\n\nAhora recuerde que, en la operación Union, no importa cuál de los dos árboles se mueva debajo del otro (vea los dos últimos ejemplos de imágenes arriba). Ahora lo que queremos hacer es minimizar la altura del árbol resultante. Si estamos uniendo dos árboles (o conjuntos), llamémoslos izquierda y derecha, entonces todo depende del rango de la izquierda y el rango de la derecha.\n• Si el rango de la izquierda es menor que el rango de la derecha, entonces es mejor moverse hacia la izquierda debajo de la derecha, porque eso no cambiará el rango de la derecha (mientras que moverse hacia la derecha debajo de la izquierda aumentaría la altura). De la misma manera, si el rango de la derecha es menor que el rango de la izquierda, entonces debemos movernos a la derecha debajo de la izquierda.\n• Si los rangos son iguales, no importa qué árbol va debajo del otro, pero el rango del resultado siempre será uno mayor que el rango de los árboles.\n// Une el conjunto que incluye i y el conjunto\n// eso incluye j\nunión vacía (int i, int j)\n{\n    // Encuentra los representantes (o los nodos raíz)\n    // para el conjunto que incluye i\n    int irep = this.find (i);\n\n    // Y haz lo mismo con el conjunto que incluye j\n    int jrep = this.Find (j);\n\n    // Los elementos están en el mismo conjunto, no es necesario\n    // unir cualquier cosa.\n    si (irep == jrep)\n        regreso;\n\n    // Obtener el rango del árbol de i\n    irank = Rango [irep],\n\n    // Obtener el rango del árbol de j\n    jrank = Rango [jrep];\n\n    // Si el rango de i es menor que el rango de j\n    si (irank <bromeo)\n    {\n        // Luego mueve i debajo de j\n        this.parent [irep] = jrep;\n    }\n\n    // De lo contrario, si el rango de j es menor que el rango de i\n    más si (broma <irank)\n    {\n        // Luego mueve j debajo de i\n        this.Parent [jrep] = irep;\n    }\n\n    // De lo contrario, si sus rangos son los mismos\n    más\n    {\n\n        // Luego mueve i debajo de j (no importa\n        // cual va donde)\n        this.Parent [irep] = jrep;\n\n        // E incrementa el árbol de resultados\n        // clasificar por 1\n        Rango [jrep] ++;\n    }\n}\n",
    "complejidad_tiempo": null,
    "java": "//Estructura de datos para modelar \n//una colección de conjuntos disyuntos.\n//Permite determinar de manera eficiente \n//a que conjunto pertenece un elemento,\n//si dos elementos se encuentran en un mismo \n//conjunto y unir dos conjuntos disyuntos en un uno.\n\npublic class DisjointSet {\n\n    static class DisjointUnionSets {\n\n        int[] rank, parent;\n        int n;\n\n        public DisjointUnionSets(int n) {\n            rank = new int[n];\n            parent = new int[n];\n            this.n = n;\n            makeSet();\n        }\n\n        // Crea n conjuntos con un solo elemento en cada uno\n        void makeSet() {\n            for (int i = 0; i < n; i++) {\n                // Inicialmente, todos los elementos están en su propio conjunto.\n                parent[i] = i;\n            }\n        }\n\n        // Devuelve representativo del conjunto de x\n        int find(int x) {\n            // Encuentra el representante del conjunto del que x es un elemento de\n            if (parent[x] != x) {\n                // si x no es el padre de sí mismo Entonces \n                // x no es el representante de su conjunto,\n                parent[x] = find(parent[x]);\n                // entonces llamamos recursivamente Find en su padre y movemos \n                // el nodo de i directamente debajo del \n                // representante de este conjunto\n            }\n\n            return parent[x];\n        }\n\n        // Une el conjunto que incluye x y el conjunto que incluye x\n        void union(int x, int y) {\n            // Encuentra representantes de dos conjuntos\n            int xRoot = find(x), yRoot = find(y);\n            // Los elementos están en el mismo conjunto, no es necesario unir nada.\n            if (xRoot == yRoot) {\n                return;\n            }\n\n            // Si el rango de x es menor que el rango de y\n            if (rank[xRoot] < rank[yRoot]) // Luego mueva y debajo de x \n            //para que la profundidad del árbol permanezca menor\n            {\n                parent[xRoot] = yRoot;\n            } // De lo contrario, si el rango de y es menor que el rango de x\n            else if (rank[yRoot] < rank[xRoot]) // Luego mueva y debajo de x \n            //para que la profundidad del árbol permanezca menor\n            {\n                parent[yRoot] = xRoot;\n            } else // si los rangos son los mismos\n            {\n                // Luego mueva y debajo de x (no importa cuál vaya a dónde)\n                parent[yRoot] = xRoot;\n                // E incrementar el rango del árbol de resultados en 1\n                rank[xRoot] = rank[xRoot] + 1;\n            }\n        }\n    }\n\n    public static void main(String[] args) {\n        // Sea 5 personas con identificadores como 0, 1, 2, 3 y 4\n        int n = 5;\n        DisjointUnionSets dus\n                = new DisjointUnionSets(n);\n\n        // 0 es amigo de 2\n        dus.union(0, 2);\n\n        // 4 es amigo de 2\n        dus.union(4, 2);\n\n        // 3 es amigo de 1\n        dus.union(3, 1);\n\n        // Verifica si 4 es amigo de 0\n        if (dus.find(4) == dus.find(0)) {\n            System.out.println(\"Yes\");\n        } else {\n            System.out.println(\"No\");\n        }\n\n        // Verifica si 1 es amigo de 0\n        if (dus.find(1) == dus.find(0)) {\n            System.out.println(\"Yes\");\n        } else {\n            System.out.println(\"No\");\n        }\n    }\n}\n",
    "cpp": "#include <iostream> \n#define MAX 105\nusing namespace std;\n\nstruct DisjSet {\n    int rank[MAX], parent[MAX], n;\n\n    DisjSet(int n) {\n        this->n = n;\n        makeSet();\n    }\n\n    void makeSet() {\n        for (int i = 0; i < n; i++) {\n            parent[i] = i;\n        }\n    }\n\n    int find(int x) {\n        if (parent[x] != x) {\n            parent[x] = find(parent[x]);\n        }\n        return parent[x];\n    }\n\n    void Union(int x, int y) {\n        int xset = find(x);\n        int yset = find(y);\n        if (xset == yset)\n            return;\n        if (rank[xset] < rank[yset]) {\n            parent[xset] = yset;\n        } else if (rank[xset] > rank[yset]) {\n            parent[yset] = xset;\n        } else {\n            parent[yset] = xset;\n            rank[xset] = rank[xset] + 1;\n        }\n    }\n};\n\nint main() {\n    DisjSet obj(5);\n    obj.Union(0, 2);\n    obj.Union(4, 2);\n    obj.Union(3, 1);\n    if (obj.find(4) == obj.find(0))\n        cout << \"Yes\\n\";\n    else\n        cout << \"No\\n\";\n    if (obj.find(1) == obj.find(0))\n        cout << \"Yes\\n\";\n    else\n        cout << \"No\\n\";\n\n    return 0;\n}\n",
    "py": "class DisjSet: \n    def __init__(self, n): \n        self.rank = [1] * n \n        self.parent = [i for i in range(n)] \n    def find(self, x):  \n        if (self.parent[x] != x): \n            self.parent[x] = self.find(self.parent[x]) \n\n        return self.parent[x] \n    def Union(self, x, y): \n        xset = self.find(x) \n        yset = self.find(y) \n        if xset == yset: \n            return\n        if self.rank[xset] < self.rank[yset]: \n            self.parent[xset] = yset \n        elif self.rank[xset] > self.rank[yset]: \n            self.parent[yset] = xset \n        else: \n            self.parent[yset] = xset \n            self.rank[xset] = self.rank[xset] + 1\n\n\nobj = DisjSet(5) \nobj.Union(0, 2) \nobj.Union(4, 2) \nobj.Union(3, 1) \nif obj.find(4) == obj.find(0): \n    print('Yes') \nelse: \n    print('No') \nif obj.find(1) == obj.find(0): \n    print('Yes') \nelse: \n    print('No') \n",
    "orden": 8,
    "suborden": 31,
    "fecha_creacion": "2020-12-06 19:51:45",
    "fecha_modificacion": "2022-03-08 12:28:52"
  },
  {
    "ID": 228,
    "supergrupo": "Grafos",
    "tema": "Union de conjuntos disjuntos en un árbol ",
    "texto": "Dado un árbol y pesos de nodos. Los pesos son números enteros no negativos. La tarea consiste en encontrar el tamaño máximo de un subárbol de un árbol dado, de modo que todos los nodos tengan pesos iguales.\n\nEjemplos:\n \nEntrada: Número de nodos = 7\n        Pesos de los nodos = 1 2 6 4 2 0 3\n        aristas = (1, 2), (1, 3), (2, 4),\n                (2, 5), (4, 6), (6, 7)\nSalida: tamaño máximo del subárbol\ncon nodos ponderados pares = 4\nExplicacion:\nEl subárbol de nodos {2, 4, 5, 6} da el tamaño máximo.\n\nEntrada: Número de nodos = 6\n        Pesos de los nodos = 2 4 0 2 2 6\n        aristass = (1, 2), (2, 3), (3, 4),\n                (4, 5), (1, 6)\nSalida: tamaño máximo del subárbol\ncon nodos ponderados pares = 6\nExplicacion:\nEl árbol dado da el tamaño máximo.\n \nEnfoque: podemos encontrar una solución simplemente ejecutando DFS en el árbol. La solución DFS nos da la respuesta en O (n). Pero, ¿cómo podemos usar DSU para este problema? Primero iteramos a través de todos las aristas. Si ambos nodos son pares en pesos, hacemos una unión de ellos. El conjunto de nodos con tamaño máximo es la respuesta. Si usamos union-find con compresión de ruta, la complejidad del tiempo es O (n).\n",
    "complejidad_tiempo": null,
    "java": "// Código Java para encontrar el subárbol máximo de \n// modo que todos los nodos tengan un peso par\n\npublic class DisjoinSetUnionTree {\n\n    static final int N = 100010;\n\n    // Estructura para camino\n    static class Edge {\n\n        int u, v;\n\n        public Edge(int u, int v) {\n            this.u = u;\n            this.v = v;\n        }\n    }\n\n    /* 'id': almacena el padre de un nodo.\n     'sz': almacena el tamaño de un árbol DSU. */\n    static int[] id = new int[N];\n    static int[] sz = new int[N];\n\n    // Función para asignar root\n    static int Root(int idx) {\n        int i = idx;\n        while (i != id[i]) {\n            id[i] = id[id[i]];\n            i = id[i];\n        }\n        return i;\n    }\n\n    // Función para encontrar Unión\n    static void Union(int a, int b) {\n        int i = Root(a), j = Root(b);\n        if (i != j) {\n            if (sz[i] >= sz[j]) {\n                id[j] = i;\n                sz[i] += sz[j];\n                sz[j] = 0;\n            } else {\n                id[i] = j;\n                sz[j] += sz[i];\n                sz[i] = 0;\n            }\n        }\n    }\n\n    // Función de utilidad para Union\n    static void UnionUtil(Edge e[], int W[], int q) {\n        for (int i = 0; i < q; i++) {\n            // Camino entre 'u' y 'v'\n            int u, v;\n            u = e[i].u;\n            v = e[i].v;\n            u--;\n            v--;\n\n            // Si los pesos de 'u' y 'v' son pares, los unimos.\n            if (W[u] % 2 == 0 && W[v] % 2 == 0) {\n                Union(u, v);\n            }\n        }\n    }\n\n    // Función para encontrar el tamaño máximo del árbol DSU\n    static int findMax(int n, int W[]) {\n        int maxi = 0;\n        for (int i = 1; i < n; i++) {\n            if (W[i] % 2 == 0) {\n                maxi = Math.max(maxi, sz[i]);\n            }\n        }\n        return maxi;\n    }\n\n    public static void main(String[] args) {\n        /* \n        Los nodos están indexados en 0 en este código, \n        por lo que tenemos que hacer los cambios \n        necesarios mientras tomamos entradas\n         */\n        // Pesos de nodos\n        int W[] = {1, 2, 6, 4, 2, 0, 3};\n\n        // Número de nodos en un árbol\n        int n = W.length;\n\n        // Inicializando cada nodo como un árbol con un solo nodo.\n        for (int i = 0; i < n; i++) {\n            id[i] = i;\n            sz[i] = 1;\n        }\n\n        Edge e[] = {new Edge(1, 2), new Edge(1, 3),\n            new Edge(2, 4), new Edge(2, 5),\n            new Edge(4, 6), new Edge(6, 7)};\n\n        int q = e.length;\n        UnionUtil(e, W, q);\n        // Encuentre el tamaño máximo del árbol DSU.\n        int maxi = findMax(n, W);\n        System.out.printf(\"Maximum size of the subtree with \");\n        System.out.printf(\"even weighted nodes = %d\\n\", maxi);\n    }\n}\n",
    "cpp": "#include<bits/stdc++.h> \n\nusing namespace std;\n\n#define N 100010 \n\nstruct Edge {\n    int u, v;\n};\n\nint id[N], sz[N];\n\nint Root(int idx) {\n    int i = idx;\n    while (i != id[i])\n        id[i] = id[id[i]], i = id[i];\n    return i;\n}\n\nvoid Union(int a, int b) {\n    int i = Root(a), j = Root(b);\n    if (i != j) {\n        if (sz[i] >= sz[j]) {\n            id[j] = i, sz[i] += sz[j];\n            sz[j] = 0;\n        } else {\n            id[i] = j, sz[j] += sz[i];\n            sz[i] = 0;\n        }\n    }\n}\n\nvoid UnionUtil(struct Edge e[], int W[], int q) {\n    for (int i = 0; i < q; i++) {\n        int u, v;\n        u = e[i].u, v = e[i].v;\n        u--, v--;\n        if (W[u] % 2 == 0 && W[v] % 2 == 0)\n            Union(u, v);\n    }\n}\n\nint findMax(int n, int W[]) {\n    int maxi = 0;\n    for (int i = 1; i <= n; i++)\n        if (W[i] % 2 == 0)\n            maxi = max(maxi, sz[i]);\n\n    return maxi;\n}\n\nint main() {\n    int W[] = {1, 2, 6, 4, 2, 0, 3};\n    int n = sizeof (W) / sizeof (W[0]);\n    for (int i = 0; i < n; i++)\n        id[i] = i, sz[i] = 1;\n    Edge e[] = {\n        {1, 2},\n        {1, 3},\n        {2, 4},\n        {2, 5},\n        {4, 6},\n        {6, 7}\n    };\n    int q = sizeof (e) / sizeof (e[0]);\n    UnionUtil(e, W, q);\n    .\n    int maxi = findMax(n, W);\n    printf(\"Maximum size of the subtree with \");\n    printf(\"even weighted nodes = %d\\n\", maxi);\n\n    return 0;\n} \n",
    "py": "N = 100010\nclass Edge:\n    def __init__(self, u, v):\n        self.u = u\n        self.v = v\n\nid = [0 for i in range(N)]\nsz = [0 for i in range(N)]\n\ndef Root(idx):\n    i = idx\n    while (i != id[i]):\n        id[i] = id[id[i]]\n        i = id[i]\n    return i\n\ndef Union(a, b):\n    i = Root(a)\n    j = Root(b)\n    if (i != j):\n        if (sz[i] >= sz[j]):\n            id[j] = i\n            sz[i] += sz[j]\n            sz[j] = 0;\n        else:\n            id[i] = j\n            sz[j] += sz[i]\n            sz[i] = 0;\n \n\ndef UnionUtil(e, W, q):\n    for i in range (q):\n        u = e[i].u\n        v = e[i].v\n        u -= 1\n        v -= 1\n        if (W[u] % 2 == 0 and W[v] % 2 == 0):\n            Union(u, v)\n\ndef findMax(n, W):\n    maxi = 0\n    for i in range (1, n):\n        if (W[i] % 2 == 0):\n            maxi = max(maxi, sz[i])\n    return maxi;\n\n\nW = [1, 2, 6, 4, 2, 0, 3]\nn = len(W);\nfor i in range (n):\n    id[i] = i\n    sz[i] = 1\n\ne = [Edge(1, 2), Edge(1, 3),\n    Edge(2, 4), Edge(2, 5),\n    Edge(4, 6), Edge(6, 7)]\nq = len(e);\nUnionUtil(e, W, q);\nmaxi = findMax(n, W);\nprint(\"Maximum size of the subtree with \")\nprint(\"even weighted nodes = \", maxi);\n",
    "orden": 8,
    "suborden": 32,
    "fecha_creacion": "2020-12-06 19:51:45",
    "fecha_modificacion": "2022-03-08 12:28:52"
  },
  {
    "ID": 229,
    "supergrupo": "Grafos",
    "tema": "Llenado mediante inundaciones",
    "texto": "En MS-Paint, cuando llevamos el pincel a un píxel y hacemos clic, el color de la región de ese píxel se reemplaza con un nuevo color seleccionado. A continuación se muestra el enunciado del problema para realizar esta tarea.\nDada una pantalla 2D, la ubicación de un píxel en la pantalla y un color, reemplace el color del píxel dado y todos los píxeles adyacentes del mismo color con el color dado.\nEjemplo:\nEntrada:\npantalla [M] [N] = {\t {1, 1, 1, 1, 1, 1, 1, 1},\n              \t\t {1, 1, 1, 1, 1, 1, 0, 0},\n               \t\t {1, 0, 0, 1, 1, 0, 1, 1},\n              \t\t {1, 2, 2, 2, 2, 0, 1, 0},\n               \t\t {1, 1, 1, 2, 2, 0, 1, 0},\n              \t\t {1, 1, 1, 2, 2, 2, 2, 0},\n              \t\t {1, 1, 1, 1, 1, 2, 1, 1},\n               \t\t {1, 1, 1, 1, 1, 2, 2, 1},\n              \t\t\t };\n    x = 4, y = 4, nuevoColor = 3\nLos valores en la pantalla 2D dada\n  indicar los colores de los píxeles.\nxey son coordenadas del pincel,\n   newColor es el color que\ndebe reemplazar el color anterior en\n   pantalla [x] [y] y todos los alrededores\npíxeles con el mismo color.\n\nSalida:\nLa pantalla debe cambiarse a siguiente.\npantalla [M] [N] = {\t{1, 1, 1, 1, 1, 1, 1, 1},\n               \t\t{1, 1, 1, 1, 1, 1, 0, 0},\n              \t\t{1, 0, 0, 1, 1, 0, 1, 1},\n               \t\t{1, 3, 3, 3, 3, 0, 1, 0},\n               \t\t{1, 1, 1, 3, 3, 0, 1, 0},\n               \t\t{1, 1, 1, 3, 3, 3, 3, 0},\n              \t\t{1, 1, 1, 1, 1, 3, 1, 1},\n               \t\t{1, 1, 1, 1, 1, 3, 3, 1},\n              \t\t };\n \n\n1: - Uso de recursividad\nLa idea es simple, primero reemplazamos el color del píxel actual, luego repetimos para 4 puntos circundantes. El siguiente es un algoritmo detallado.\n// Una función recursiva para reemplazar\n// color anterior 'prevC' en '(x, y)'\n// y todos los píxeles circundantes de (x, y)\n// con nuevo color 'newC' y\nfloodFil (pantalla [M] [N], x, y, prevC, newC)\n1) Si xoy está fuera de la pantalla, regrese.\n2) Si el color de la pantalla [x] [y] no es el mismo que prevC, regrese\n3) Se repite para norte, sur, este y oeste.\n    floodFillUtil (pantalla, x + 1, y, prevC, newC);\n    floodFillUtil (pantalla, x-1, y, prevC, newC);\n    floodFillUtil (pantalla, x, y + 1, prevC, newC);\n    floodFillUtil (pantalla, x, y-1, prevC, newC);\n\nMétodo 2: usar el enfoque BFS\nAlgoritmo para el enfoque basado en BFS:\n1. Cree una cola de parejas.\n2. Inserte un índice inicial dado en la cola.\n3. Marque el índice inicial como visitado en vis [] [] matriz.\n4. Hasta que la cola no esté vacía, repita los pasos 3.1 a 3.6\n• Toma el elemento frontal de la cola\n• Salir de la cola\n• Almacene el valor / color actual en las coordenadas sacadas de la cola (precolor)\n• Actualizar el valor / color del índice actual que se saca de la cola\n• Verifique las 4 direcciones, es decir, (x + 1, y), (x-1, y), (x, y + 1), (x, y-1) es válido o no y si es válido, verifique ese valor en esa coordenada debe ser igual al precolor y el valor de esa coordenada en vis [] [] es 0.\n• Si toda la condición anterior es verdadera, empuje la coordenada correspondiente en la cola y marque como 1 en vis [] []\n5. Imprima la matriz.\n",
    "complejidad_tiempo": null,
    "java": "// Programa Java para implementar el algoritmo de relleno por inundación\n\npublic class FloodFill {\n\n// Dimensiones de la pantalla \n    static int M = 8;\n    static int N = 8;\n\n    // Una función recursiva para reemplazar el color anterior 'prevC' en \n    // '(x, y)' y todos los píxeles circundantes de (x, y) con el nuevo color 'newC' \n    static void floodFillUtil(int screen[][], int x, int y,\n            int prevC, int newC) {\n        if (x < 0 || x >= M || y < 0 || y >= N) {\n            return;\n        }\n        if (screen[x][y] != prevC) {\n            return;\n        }\n        // Reemplazar el color en (x, y)\n        screen[x][y] = newC;\n        // ir recursivamente para norte, este, sur y oeste\n        floodFillUtil(screen, x + 1, y, prevC, newC);\n        floodFillUtil(screen, x - 1, y, prevC, newC);\n        floodFillUtil(screen, x, y + 1, prevC, newC);\n        floodFillUtil(screen, x, y - 1, prevC, newC);\n    }\n\n    // se encuentra principalmente el color anterior en (x, y)\n    // y llama a floodFillUtil ()\n    static void floodFill(int screen[][], int x, int y, int newC) {\n        int prevC = screen[x][y];\n        floodFillUtil(screen, x, y, prevC, newC);\n    }\n\n    public static void main(String[] args) {\n        int screen[][] = {{1, 1, 1, 1, 1, 1, 1, 1},\n        {1, 1, 1, 1, 1, 1, 0, 0},\n        {1, 0, 0, 1, 1, 0, 1, 1},\n        {1, 2, 2, 2, 2, 0, 1, 0},\n        {1, 1, 1, 2, 2, 0, 1, 0},\n        {1, 1, 1, 2, 2, 2, 2, 0},\n        {1, 1, 1, 1, 1, 2, 1, 1},\n        {1, 1, 1, 1, 1, 2, 2, 1},};\n        int x = 4, y = 4, newC = 3;\n        floodFill(screen, x, y, newC);\n\n        System.out.println(\"Updated screen after call to floodFill: \");\n        for (int i = 0; i < M; i++) {\n            for (int j = 0; j < N; j++) {\n                System.out.print(screen[i][j] + \" \");\n            }\n            System.out.println();\n        }\n    }\n}\n",
    "cpp": "#include<iostream> \nusing namespace std;\n\n#define M 8 \n#define N 8 \n\nvoid floodFillUtil(int screen[][N], int x, int y, int prevC, int newC) {\n    if (x < 0 || x >= M || y < 0 || y >= N)\n        return;\n    if (screen[x][y] != prevC)\n        return;\n    if (screen[x][y] == newC)\n        return;\n    screen[x][y] = newC;\n    floodFillUtil(screen, x + 1, y, prevC, newC);\n    floodFillUtil(screen, x - 1, y, prevC, newC);\n    floodFillUtil(screen, x, y + 1, prevC, newC);\n    floodFillUtil(screen, x, y - 1, prevC, newC);\n}\n\nvoid floodFill(int screen[][N], int x, int y, int newC) {\n    int prevC = screen[x][y];\n    floodFillUtil(screen, x, y, prevC, newC);\n}\n\nint main() {\n    int screen[M][N] = {\n        {1, 1, 1, 1, 1, 1, 1, 1},\n        {1, 1, 1, 1, 1, 1, 0, 0},\n        {1, 0, 0, 1, 1, 0, 1, 1},\n        {1, 2, 2, 2, 2, 0, 1, 0},\n        {1, 1, 1, 2, 2, 0, 1, 0},\n        {1, 1, 1, 2, 2, 2, 2, 0},\n        {1, 1, 1, 1, 1, 2, 1, 1},\n        {1, 1, 1, 1, 1, 2, 2, 1},\n    };\n    int x = 4, y = 4, newC = 3;\n    floodFill(screen, x, y, newC);\n    cout << \"Updated screen after call to floodFill: \\n\";\n    for (int i = 0; i < M; i++) {\n        for (int j = 0; j < N; j++)\n            cout << screen[i][j] << \" \";\n        cout << endl;\n    }\n}\n",
    "py": "M = 8\nN = 8\ndef floodFillUtil(screen, x, y, prevC, newC): \n    if (x < 0 or x >= M or y < 0 or\n        y >= N or screen[x][y] != prevC or\n        screen[x][y] == newC): \n        return\n    screen[x][y] = newC \n    floodFillUtil(screen, x + 1, y, prevC, newC) \n    floodFillUtil(screen, x - 1, y, prevC, newC) \n    floodFillUtil(screen, x, y + 1, prevC, newC) \n    floodFillUtil(screen, x, y - 1, prevC, newC) \ndef floodFill(screen, x, y, newC): \n    prevC = screen[x][y] \n    floodFillUtil(screen, x, y, prevC, newC) \nscreen = [[1, 1, 1, 1, 1, 1, 1, 1], \n    [1, 1, 1, 1, 1, 1, 0, 0], \n    [1, 0, 0, 1, 1, 0, 1, 1], \n    [1, 2, 2, 2, 2, 0, 1, 0], \n    [1, 1, 1, 2, 2, 0, 1, 0], \n    [1, 1, 1, 2, 2, 2, 2, 0], \n    [1, 1, 1, 1, 1, 2, 1, 1], \n    [1, 1, 1, 1, 1, 2, 2, 1]] \n\nx = 4\ny = 4\nnewC = 3\nfloodFill(screen, x, y, newC) \nprint (\"Updated screen after call to floodFill:\") \nfor i in range(M): \n    print(screen[i]) \n\n",
    "orden": 8,
    "suborden": 33,
    "fecha_creacion": "2020-12-06 19:51:45",
    "fecha_modificacion": "2022-03-08 12:28:52"
  },
  {
    "ID": 230,
    "supergrupo": "Grafos",
    "tema": "Algoritmo de Ford-Fulkerson para máximos flujos",
    "texto": "Dado un gráfico que representa una red de flujo donde cada arista tiene una capacidad. También dados dos vértices fuente \"s\" y sumidero \"t\" en el gráfico, encuentre el flujo máximo posible de s a t con las siguientes restricciones:\n\na) El flujo en una arista no excede la capacidad dada del arista.\nb) El flujo entrante es igual al flujo saliente para cada vértice excepto s y t.\n \nLa siguiente es una idea simple del algoritmo Ford-Fulkerson:\n1) Comience con el flujo inicial como 0.\n2) Si bien hay un camino creciente desde la fuente hasta el sumidero.\nAgregue este flujo de ruta para fluir.\n3) Retorne el flujo.\n\nComplejidad de tiempo: La complejidad de tiempo del algoritmo anterior es O (max_flow * E). Ejecutamos un bucle mientras hay una ruta de aumento. En el peor de los casos, podemos agregar 1 unidad de flujo en cada iteración. Por tanto, la complejidad del tiempo se convierte en O (max_flow * E).\n¿Cómo implementar el algoritmo simple anterior?\nPrimero definamos el concepto de Gráfico Residual que se necesita para comprender la implementación.\n\nEl gráfico residual de una red de flujo es un gráfico que indica un flujo adicional posible. Si hay una ruta desde la fuente hasta el sumidero en el gráfico residual, entonces es posible agregar flujo. Cada arista de un gráfico residual tiene un valor llamado capacidad residual que es igual a la capacidad original de la arista menos el flujo de corriente. La capacidad residual es básicamente la capacidad actual de la arista.\n\nHablemos ahora de los detalles de implementación. La capacidad residual es 0 si no hay arista entre dos vértices del gráfico residual. Podemos inicializar el gráfico residual como gráfico original ya que no hay flujo inicial y la capacidad residual inicial es igual a la capacidad original. Para encontrar una ruta de aumento, podemos hacer un BFS o DFS del gráfico residual. Hemos utilizado BFS en la siguiente implementación. Usando BFS, podemos averiguar si hay una ruta desde la fuente hasta el sumidero. BFS también crea una matriz principal []. Usando la matriz principal [], atravesamos la ruta encontrada y encontramos el flujo posible a través de esta ruta al encontrar la capacidad residual mínima a lo largo de la ruta. Posteriormente agregamos el flujo de ruta encontrado al flujo general.\nLo importante es que necesitamos actualizar las capacidades residuales en el gráfico de residuos. Restamos el flujo de la ruta de todos las aristas a lo largo de la ruta y agregamos el flujo de la ruta a lo largo de las aristas inversos Necesitamos agregar el flujo de la ruta a lo largo de las aristas inversas porque más tarde es posible que necesitemos enviar el flujo en dirección inversa\n\nLa implementación anterior del algoritmo Ford Fulkerson se llama algoritmo Edmonds-Karp. La idea de Edmonds-Karp es utilizar BFS en la implementación de Ford Fulkerson, ya que BFS siempre elige un camino con un número mínimo de aristas. Cuando se utiliza BFS, la complejidad de tiempo del peor de los casos se puede reducir a O (VE2). La implementación anterior usa una representación de matriz de adyacencia, aunque donde BFS toma tiempo O (V2), la complejidad de tiempo de la implementación anterior es O (EV3).\n\nEste es un problema importante ya que surge en muchas situaciones prácticas. Los ejemplos incluyen, maximizar el transporte con límites de tráfico dados, maximizar el flujo de paquetes en las redes de computadoras.\n",
    "complejidad_tiempo": null,
    "java": "// Programa Java para la implementación del algoritmo Ford Fulkerson\n\nimport java.util.LinkedList;\n\npublic class FordFulkersonMaxFlow {\n\n    static final int V = 6; //Número de vértices en el gráfico\n\n    /* Devuelve verdadero si hay una ruta desde la fuente 's' hasta el sumidero \n    't' en el gráfico residual. También llena parent [] \n    para almacenar la ruta */\n    static boolean bfs(int rGraph[][], int s, int t, int parent[]) {\n        // Cree una matriz visitada y marque todos los vértices como no visitados\n        boolean visited[] = new boolean[V];\n        for (int i = 0; i < V; ++i) {\n            visited[i] = false;\n        }\n        // Cree una cola, ponga en cola el vértice de origen y \n        // marque el vértice de origen como visitado\n        LinkedList<Integer> queue = new LinkedList<>();\n        queue.add(s);\n        visited[s] = true;\n        parent[s] = -1;\n        // Bucle BFS estándar\n        while (!queue.isEmpty()) {\n            int u = queue.poll();\n            for (int v = 0; v < V; v++) {\n                if (visited[v] == false && rGraph[u][v] > 0) {\n                    queue.add(v);\n                    parent[v] = u;\n                    visited[v] = true;\n                }\n            }\n        }\n\n        // Si alcanzamos el sumidero en BFS a partir de la fuente, \n        // devolvemos verdadero, de lo contrario falso\n        return (visited[t] == true);\n    }\n\n    // Devuelve el caudal máximo de s - t en el gráfico dado\n    static int fordFulkerson(int graph[][], int s, int t) {\n        int u, v;\n\n        // Cree un grafo residual y llene el grafo residual con las capacidades \n        // dadas en el grafo original como capacidades residuales en el grafo \n        // residual donde rGraph [i] [j] indica la capacidad residual del \n        // borde de i a j (si hay un borde. If rGraph [i] [j] es 0,\n        // entonces no hay)\n        int rGraph[][] = new int[V][V];\n        for (u = 0; u < V; u++) {\n            for (v = 0; v < V; v++) {\n                rGraph[u][v] = graph[u][v];\n            }\n        }\n\n        // Esta matriz está llena de BFS y para almacenar la ruta\n        int parent[] = new int[V];\n        int max_flow = 0; // No hay flujo inicialmente\n\n        // Aumente el flujo mientras hay un camino desde la fuente hasta el sumidero\n        while (bfs(rGraph, s, t, parent)) {\n            // Encuentre la capacidad residual mínima de los bordes a lo largo \n            // del camino llenado por BFS. O podemos decir encontrar \n            // el flujo máximo a través del camino encontrado.\n            int path_flow = Integer.MAX_VALUE;\n            for (v = t; v != s; v = parent[v]) {\n                u = parent[v];\n                path_flow = Math.min(path_flow, rGraph[u][v]);\n            }\n            // actualizar las capacidades residuales de los bordes e invertir \n            // los bordes a lo largo del camino\n            for (v = t; v != s; v = parent[v]) {\n                u = parent[v];\n                rGraph[u][v] -= path_flow;\n                rGraph[v][u] += path_flow;\n            }\n\n            // Agregue el flujo de ruta al flujo general\n            max_flow += path_flow;\n        }\n\n        // Devuelve el flujo general\n        return max_flow;\n    }\n\n    public static void main(String[] args) throws java.lang.Exception {\n        int graph[][] = new int[][]{{0, 16, 13, 0, 0, 0},\n        {0, 0, 10, 12, 0, 0},\n        {0, 4, 0, 0, 14, 0},\n        {0, 0, 9, 0, 0, 20},\n        {0, 0, 0, 7, 0, 4},\n        {0, 0, 0, 0, 0, 0}\n        };\n        System.out.println(\"The maximum possible flow is \"\n                + fordFulkerson(graph, 0, 5));\n    }\n}\n",
    "cpp": "#include <iostream> \n#include <limits.h> \n#include <string.h> \n#include <queue> \nusing namespace std;\n\n#define V 6 \n\nbool bfs(int rGraph[V][V], int s, int t, int parent[]) {\n\n    bool visited[V];\n    memset(visited, 0, sizeof (visited));\n    queue <int> q;\n    q.push(s);\n    visited[s] = true;\n    parent[s] = -1;\n\n    while (!q.empty()) {\n        int u = q.front();\n        q.pop();\n        for (int v = 0; v < V; v++) {\n            if (visited[v] == false && rGraph[u][v] > 0) {\n                q.push(v);\n                parent[v] = u;\n                visited[v] = true;\n            }\n        }\n    }\n    return (visited[t] == true);\n}\n\nint fordFulkerson(int graph[V][V], int s, int t) {\n    int u, v;\n    int rGraph[V][V];\n    for (u = 0; u < V; u++)\n        for (v = 0; v < V; v++)\n            rGraph[u][v] = graph[u][v];\n    int parent[V];\n    int max_flow = 0;\n    while (bfs(rGraph, s, t, parent)) {\n        int path_flow = INT_MAX;\n        for (v = t; v != s; v = parent[v]) {\n            u = parent[v];\n            path_flow = min(path_flow, rGraph[u][v]);\n        }\n        for (v = t; v != s; v = parent[v]) {\n            u = parent[v];\n            rGraph[u][v] -= path_flow;\n            rGraph[v][u] += path_flow;\n        }\n        max_flow += path_flow;\n    }\n    return max_flow;\n}\n\nint main() {\n    int graph[V][V] = {\n        {0, 16, 13, 0, 0, 0},\n        {0, 0, 10, 12, 0, 0},\n        {0, 4, 0, 0, 14, 0},\n        {0, 0, 9, 0, 0, 20},\n        {0, 0, 0, 7, 0, 4},\n        {0, 0, 0, 0, 0, 0}\n    };\n    cout << \"The maximum possible flow is \" << fordFulkerson(graph, 0, 5);\n    return 0;\n}\n",
    "py": "class Graph: \n\n    def __init__(self, graph): \n        self.graph = graph \n        self. ROW = len(graph) \n        #self.COL = len(gr[0]) \n                \n    def BFS(self, s, t, parent): \n        visited = [False] * (self.ROW) \n        queue = [] \n        queue.append(s) \n        visited[s] = True\n        while queue: \n            u = queue.pop(0) \n            for ind, val in enumerate(self.graph[u]): \n                if visited[ind] == False and val > 0: \n                    queue.append(ind) \n                    visited[ind] = True\n                    parent[ind] = u \n        return True if visited[t] else False\n\n    def FordFulkerson(self, source, sink): \n        parent = [-1] * (self.ROW) \n        max_flow = 0 \n        while self.BFS(source, sink, parent):  \n            path_flow = float(\"Inf\") \n            s = sink \n            while(s != source): \n                path_flow = min (path_flow, self.graph[parent[s]][s]) \n                s = parent[s] \n\n            max_flow += path_flow \n            v = sink \n            while(v != source): \n                u = parent[v] \n                self.graph[u][v] -= path_flow \n                self.graph[v][u] += path_flow \n                v = parent[v] \n        return max_flow \n\ngraph = [[0, 16, 13, 0, 0, 0], \n    [0, 0, 10, 12, 0, 0], \n    [0, 4, 0, 0, 14, 0], \n    [0, 0, 9, 0, 0, 20], \n    [0, 0, 0, 7, 0, 4], \n    [0, 0, 0, 0, 0, 0]] \ng = Graph(graph) \nsource = 0; sink = 5\nprint (\"The maximum possible flow is %d \" % g.FordFulkerson(source, sink)) \n",
    "orden": 8,
    "suborden": 34,
    "fecha_creacion": "2020-12-06 19:51:46",
    "fecha_modificacion": "2022-03-08 12:28:52"
  },
  {
    "ID": 231,
    "supergrupo": "Grafos",
    "tema": "Antecesor común más bajo",
    "texto": "El ancestro común más bajo (ACB LCA) es un concepto dentro de la Teoría de grafos y Ciencias de la computación. Sea T un árbol con raíz y n nodos. El ancestro común más bajo entre dos nodos v y w se define como el nodo más bajo en T que tiene a v y w como descendientes (donde se permite a un nodo ser descendiente de él mismo).\nEl ACB de v y w en T es el ancestro compartido de v y w que está localizado más lejos de la raíz. El cómputo del ancestro común más bajo puede ser útil, por ejemplo, como parte de un procedimiento para determinar la distancia entre pares de nodos en un árbol: la distancia de v a w puede ser calculada como la distancia desde la raíz hasta v, sumada con la distancia desde la raíz hasta w, menos dos veces la distancia desde la raíz hasta su ancestro común más bajo.\nEn una estructura de datos árbol donde cada nodo referencia a su padre, el ancestro común más bajo puede ser determinado de forma muy simple encontrando la primera intersección de los caminos desde v and w hasta la raíz. En general, el tiempo computacional requerido por este algoritmo es O(h) donde h es la altura del árbol (longitud del camino más largo desde una hoja hasta la raíz). Sin embargo, existen muchos algoritmos para procesar árboles con los que el ancestro común más bajo puede ser encontrado de forma más rápida.\nSe puede buscar en tiempo constante por pregunta después de un preprocesamiento en tiempo lineal.\nSin preprocesamiento se puede mejorar el tiempo de cómputo del algoritmo ingenuo hasta O(log h) almacenando los caminos a través del árbol usando skew-binary random access lists, premitiendo aún al árbol ser extendido en tiempo constante\n \nEn el diagrama anterior, el LCA de 10 y 14 es 12 y el LCA de 10 y 12 es 12.\n  (1) Cree una matriz padre y almacene el padre del i-ésimo nodo en ella. El padre del nodo raíz debe ser -1.\n(2) Ahora, acceda a todos los nodos desde el nodo deseado \"m\" hasta el nodo raíz y márquelos como visitados.\n(3) Por último, acceda a todos los nodos desde el nodo deseado \"n\" hasta que llegue el primer nodo visitado.\n(4) Este nodo es el ancestro común más bajo\n",
    "complejidad_tiempo": null,
    "java": "import java.util.ArrayList;\n\npublic class LowestCommonAncestor {\n\n    static final int MAX = 100005; //Cantidad maxima de nodos\n    static final int LOG2 = 17; //log2(MAX)+1\n    //ArrayList<edge> g[] = new ArrayList[MAX]; //Lista de adyacencia\n    static ArrayList<Integer> g[] = new ArrayList[MAX]; //Lista de adyacencia\n    static int dep[] = new int[MAX]; //Almacena la profundidad de cada nodo\n    static int par[][] = new int[MAX][LOG2]; //Almacena los padres para responder las consultas\n    //int rmq[][] = new int[MAX][LOG2]; //Almacena los pesos para responder las consultas\n    static int nodos, aristas; //Cantidad de nodos y aristas \n\n    /*static class edge {\n    int v, w; \n    \n    edge(int _v, int _w){\n        v = _v;\n        w = _w;\n    }\n};*/\n    static int lca(int u, int v) {\n        //int ans = -1;\n        if (dep[u] < dep[v]) {\n            int aux = u;\n            u = v;\n            v = aux;\n        }\n        int diff = dep[u] - dep[v];\n        for (int i = LOG2 - 1; i >= 0; i--) {\n            if ((diff & (1 << i)) > 0) {\n                //ans = Math.max(ans, rmq[u][i]);\n                u = par[u][i];\n            }\n        }\n        //if (u == v) return ans;\n        if (u == v) {\n            return u;\n        }\n        for (int i = LOG2 - 1; i >= 0; i--) {\n            if (par[u][i] != par[v][i]) {\n                //ans = Math.max(ans, Math.max(rmq[u][i], rmq[v][i]));\n                u = par[u][i];\n                v = par[v][i];\n            }\n        }\n        //return Math.max(ans, Math.max(rmq[u][0], rmq[v][0]));\n        return par[u][0];\n    }\n\n    static void dfs(int u, int p, int d) {\n        dep[u] = d;\n        par[u][0] = p;\n        for (int v /* edge ed*/ : g[u]) {\n            //int v = ed.v;\n            if (v != p) {\n                //rmq[v][0] = ed.w;\n                dfs(v, u, d + 1);\n            }\n        }\n    }\n\n    static void build() {\n        for (int i = 0; i < nodos; i++) {\n            dep[i] = -1;\n        }\n        for (int i = 0; i < nodos; i++) {\n            if (dep[i] == -1) {\n                //rmq[i][0] = -1;\n                dfs(i, i, 0);\n            }\n        }\n        for (int j = 0; j < LOG2 - 1; j++) {\n            for (int i = 0; i < nodos; i++) {\n                par[i][j + 1] = par[par[i][j]][j];\n                //rmq[i][j+1] = Math.max(rmq[ par[i][j] ][j], rmq[i][j]);\n            }\n        }\n    }\n\n    static void init() {\n        for (int i = 0; i <= nodos; i++) {\n            g[i] = new ArrayList<>();\n        }\n    }\n\n    public static void main(String[] args) {\n        nodos = 5;\n        aristas = 4;\n        init();\n        g[0].add(1);\n        g[0].add(2);\n        g[2].add(3);\n        g[3].add(4);\n        build();\n        System.out.println(lca(2, 1));\n    }\n}\n",
    "cpp": "#include <cstdlib>\n#include <bits/stdc++.h> \nusing namespace std;\nconst int MAX = 100005;\nconst int LOG2 = 17;\n//vector<edge> g[MAX];\nvector<int> g[MAX];\nint dep[MAX];\nint par[MAX][LOG2];\nint rmq[MAX][LOG2];\nstatic int nodos, aristas;\n\nstruct edge {\n    int v, w;\n\n    edge(int _v, int _w) {\n        v = _v;\n        w = _w;\n    }\n};\n\nint lca(int u, int v) {\n    //int ans = -1;\n    if (dep[u] < dep[v]) {\n        int aux = u;\n        u = v;\n        v = aux;\n    }\n    int diff = dep[u] - dep[v];\n    for (int i = LOG2 - 1; i >= 0; i--) {\n        if ((diff & (1 << i)) > 0) {\n            //ans = max(ans, rmq[u][i]);\n            u = par[u][i];\n        }\n    }\n    //if (u == v) return ans;\n    if (u == v) {\n        return u;\n    }\n    for (int i = LOG2 - 1; i >= 0; i--) {\n        if (par[u][i] != par[v][i]) {\n            //ans = max(ans, max(rmq[u][i], rmq[v][i]));\n            u = par[u][i];\n            v = par[v][i];\n        }\n    }\n    //return max(ans, max(rmq[u][0], rmq[v][0]));\n    return par[u][0];\n}\n\nvoid dfs(int u, int p, int d) {\n    dep[u] = d;\n    par[u][0] = p;\n    for (int v /* edge ed*/ : g[u]) {\n        //int v = ed.v;\n        if (v != p) {\n            //rmq[v][0] = ed.w;\n            dfs(v, u, d + 1);\n        }\n    }\n}\n\nvoid build() {\n    for (int i = 0; i < nodos; i++) {\n        dep[i] = -1;\n    }\n    for (int i = 0; i < nodos; i++) {\n        if (dep[i] == -1) {\n            //rmq[i][0] = -1;\n            dfs(i, i, 0);\n        }\n    }\n    for (int j = 0; j < LOG2 - 1; j++) {\n        for (int i = 0; i < nodos; i++) {\n            par[i][j + 1] = par[par[i][j]][j];\n            //rmq[i][j+1] = max(rmq[ par[i][j] ][j], rmq[i][j]);\n        }\n    }\n}\n\nvoid init() {\n    for (int i = 0; i <= nodos; i++) {\n        //        g[i] = new ArrayList<>();\n    }\n}\n\nint main() {\n    nodos = 5;\n    aristas = 4;\n    init();\n    g[0].emplace_back(1);\n    g[0].emplace_back(2);\n    g[2].emplace_back(3);\n    g[3].emplace_back(4);\n    build();\n    cout << (lca(2, 1)) << endl;\n}\n",
    "py": "MAX = 100005\nLOG2 = 17\n#vector<edge> g[MAX];\ng = [[]for i in range (MAX)]\ndep = [0 for i in range (MAX)]\npar = [[0 for j in range (MAX)]for i in range (LOG2)]\nrmq = [[0 for j in range (MAX)]for i in range (LOG2)]\nclass edge:\n    def __init__(self, v, w):\n        self.v = v\n        self.w = w\n        \ndef lca(u, v):\n    #int ans = -1;\n    if (dep[u] < dep[v]):\n        aux = u;\n        u = v;\n        v = aux;\n    diff = dep[u] - dep[v];\n    for i in range (LOG2-1, -1, -1):\n        if ((diff & (1 << i)) > 0):\n            #ans = max(ans, rmq[u][i]);\n            u = par[u][i];\n    #if (u == v) return ans;\n    if (u == v):\n        return u\n    for i in range (LOG2-1, -1, -1):\n        if (par[u][i] != par[v][i]):\n            #ans = max(ans, max(rmq[u][i], rmq[v][i]));\n            u = par[u][i]\n            v = par[v][i]\n    \n    #return max(ans, max(rmq[u][0], rmq[v][0]));\n    return par[u][0]\n\ndef dfs(u, p, d):\n    dep[u] = d\n    par[u][0] = p\n    for v in g[u]:\n        #v = ed.v;\n        if (v != p):\n            #rmq[v][0] = ed.w\n            dfs(v, u, d + 1)\n \n\ndef build():\n    for i in range (nodos):\n        dep[i] = -1\n    for i in range (nodos): \n        if (dep[i] == -1):\n            #rmq[i][0] = -1;\n            dfs(i, i, 0);\n    for i in range (LOG2-1):\n        for j in range (nodos):\n            par[i][j + 1] = par[par[i][j]][j]\n            #rmq[i][j+1] = max(rmq[ par[i][j] ][j], rmq[i][j]);\n \n\ndef init():\n    g = [[]for i in range (MAX)]\n\nnodos = 5\naristas = 4\ninit()\ng[0].append(1)\ng[0].append(2)\ng[2].append(3)\ng[3].append(4)\nbuild();\nprint(lca(2, 1))\n",
    "orden": 8,
    "suborden": 35,
    "fecha_creacion": "2020-12-06 19:51:46",
    "fecha_modificacion": "2022-03-08 12:28:52"
  },
  {
    "ID": 232,
    "supergrupo": "Grafos",
    "tema": "Serpientes y escaleras",
    "texto": "Dado un tablero de serpiente y escalera, encuentre el número mínimo de lanzamientos de dados necesarios para llegar al destino o la última celda desde la fuente o la primera celda. Básicamente, el jugador tiene control total sobre el resultado del lanzamiento de dados y quiere averiguar el número mínimo de lanzamientos necesarios para llegar a la última celda.\nSi el jugador llega a una celda que es la base de una escalera, el jugador tiene que subir esa escalera y si llega a una celda que es la boca de la serpiente, tiene que bajar hasta la cola de la serpiente sin lanzar un dado.\n \nPor ejemplo, considere el tablero que se muestra, el número mínimo de lanzamientos de dados necesarios para llegar a la celda 30 desde la celda 1 es 3.\nLos siguientes son los pasos:\na) Primero lanza dos dados para llegar a la celda número 3 y luego escala para llegar a la 22\nb) Luego lanza 6 para llegar a 28.\nc) Finalmente a través del 2 para llegar a 30.\nTambién puede haber otras soluciones como (2, 2, 6), (2, 4, 4), (2, 3, 5) .. etc.\nLa idea es considerar el tablero de serpiente y escalera dado como un gráfico dirigido con un número de vértices igual al número de celdas del tablero. El problema se reduce a encontrar el camino más corto en un gráfico. Cada vértice del gráfico tiene una arista hasta los siguientes seis vértices si los siguientes 6 vértices no tienen una serpiente o una escalera. Si alguno de los siguientes seis vértices tiene una serpiente o una escalera, entonces la arista del vértice actual va a la parte superior de la escalera o la cola de la serpiente. Dado que todos las aristas tienen el mismo peso, podemos encontrar de manera eficiente la ruta más corta usando la búsqueda de amplitud primero del gráfico.\nA continuación se muestra la implementación de la idea anterior. La entrada está representada por dos cosas, primero es 'N' que es el número de celdas en el tablero dado, segundo es una matriz 'mover [0… N-1]' de tamaño N. Una entrada de movimiento [i] es -1 si no hay serpiente ni escalera desde i, de lo contrario, el movimiento [i] contiene el índice de la celda de destino para la serpiente o la escalera en i.\nLa complejidad de tiempo de la solución anterior es O (N) ya que cada celda se agrega y se elimina solo una vez de la cola. Y una operación típica de poner en cola o sacar de cola lleva O (1) tiempo.\n",
    "complejidad_tiempo": null,
    "java": "// Programa Java para encontrar el número mínimo de lanzamientos de dados \n// necesarios para llegar a la última celda de la primera celda de una \n// tabla de escalera y serpiente determinada\n\nimport java.util.LinkedList;\nimport java.util.Queue;\n\npublic class SnakesAndLadders {\n    // Una entrada en la cola utilizada en BFS\n\n    static class qentry {\n\n        int v;// Número de vértice\n        int dist;// Distancia de este vértice desde la fuente\n    }\n\n    // Esta función devuelve el número mínimo de lanzamientos de dados \n    // necesarios para llegar a la última celda desde la celda 0 en un juego \n    // de serpientes y escaleras. move[] es una matriz de tamaño N donde N es \n    // no. de celdas a bordo Si no hay una serpiente o escalera desde la \n    // celda i, entonces move[i] es -1 De lo contrario, el move[i] contiene \n    // la celda a la que lleva la serpiente o escalera en i.\n    static int getMinDiceThrows(int move[], int n) {\n        int visited[] = new int[n];\n        Queue<qentry> q = new LinkedList<>();\n        qentry qe = new qentry();\n        qe.v = 0;\n        qe.dist = 0;\n\n        // Marque el nodo 0 como visitado y colóquelo.\n        visited[0] = 1;\n        q.add(qe);\n\n        // Hacer un BFS comenzando desde el vértice en el índice 0\n        while (!q.isEmpty()) {\n            qe = q.remove();\n            int v = qe.v;\n\n            // Si el vértice frontal es el vértice de destino, hemos terminado.\n            if (v == n - 1) {\n                break;\n            }\n\n            // De lo contrario, quite de la cola del vértice frontal y ponga \n            // en cola sus vértices adyacentes (o números de celda \n            // accesibles a través de un lanzamiento de dados)\n            for (int j = v + 1; j <= (v + 6) && j < n; ++j) {\n                // Si esta celda ya está visitada, ignore\n                if (visited[j] == 0) {\n                    // De lo contrario, calcule su distancia y márquela como visitada.\n                    qentry a = new qentry();\n                    a.dist = (qe.dist + 1);\n                    visited[j] = 1;\n\n                    // Compruebe si hay una serpiente o una escalera en 'j', luego la cola de la serpiente o la parte superior de la escalera se convierte en el adyacente de 'i'\n                    if (move[j] != -1) {\n                        a.v = move[j];\n                    } else {\n                        a.v = j;\n                    }\n                    q.add(a);\n                }\n            }\n        }\n\n        // Llegamos aquí cuando 'qe' tiene el último vértice devuelve la distancia del vértice en 'qe'\n        return qe.dist;\n    }\n\n    public static void main(String[] args) {\n        // Construyamos el tablero dado en el diagrama anterior\n        int N = 30;\n        int moves[] = new int[N];\n        for (int i = 0; i < N; i++) {\n            moves[i] = -1;\n        }\n\n        // Escaleras\n        moves[2] = 21;\n        moves[4] = 7;\n        moves[10] = 25;\n        moves[19] = 28;\n\n        // Snakes\n        moves[26] = 0;\n        moves[20] = 8;\n        moves[16] = 3;\n        moves[18] = 6;\n\n        System.out.println(\"Min Dice throws required is \"\n                + getMinDiceThrows(moves, N));\n    }\n}\n",
    "cpp": "#include<iostream> \n#include <queue> \nusing namespace std;\n\nstruct queueEntry {\n    int v;\n    int dist;\n};\n\nint getMinDiceThrows(int move[], int N) {\n\n    bool *visited = new bool[N];\n    for (int i = 0; i < N; i++)\n        visited[i] = false;\n    queue<queueEntry> q;\n    visited[0] = true;\n    queueEntry s = {0, 0};\n    /\n    q.push(s);\n    queueEntry qe;\n    while (!q.empty()) {\n        qe = q.front();\n        int v = qe.v;\n        if (v == N - 1)\n            break;\n        q.pop();\n        for (int j = v + 1; j <= (v + 6) && j < N; ++j) {\n            if (!visited[j]) {\n\n                queueEntry a;\n                a.dist = (qe.dist + 1);\n                visited[j] = true;\n                if (move[j] != -1)\n                    a.v = move[j];\n                else\n                    a.v = j;\n                q.push(a);\n            }\n        }\n    }\n    return qe.dist;\n}\n\nint main() {\n    int N = 30;\n    int moves[N];\n    for (int i = 0; i < N; i++)\n        moves[i] = -1;\n\n    // Ladders \n    moves[2] = 21;\n    moves[4] = 7;\n    moves[10] = 25;\n    moves[19] = 28;\n\n    // Snakes \n    moves[26] = 0;\n    moves[20] = 8;\n    moves[16] = 3;\n    moves[18] = 6;\n\n    cout << \"Min Dice throws required is \" << getMinDiceThrows(moves, N);\n    return 0;\n}\n",
    "py": "class QueueEntry(object): \n    def __init__(self, v=0, dist=0): \n        self.v = v \n        self.dist = dist \ndef getMinDiceThrows(move, N): \n    visited = [False] * N \n    queue = [] \n    visited[0] = True\n    queue.append(QueueEntry(0, 0)) \n    qe = QueueEntry() \n    while queue: \n        qe = queue.pop(0) \n        v = qe.v \n        if v == N - 1: \n            break\n        j = v + 1\n        while j <= v + 6 and j < N: \n            if visited[j] is False: \n                a = QueueEntry() \n                a.dist = qe.dist + 1\n                visited[j] = True\n                a.v = move[j] if move[j] != -1 else j \n                queue.append(a) \n            j += 1\n    return qe.dist \nN = 30\nmoves = [-1] * N \n\n# Ladders \nmoves[2] = 21\nmoves[4] = 7\nmoves[10] = 25\nmoves[19] = 28\n\n# Snakes \nmoves[26] = 0\nmoves[20] = 8\nmoves[16] = 3\nmoves[18] = 6\n\nprint(\"Min Dice throws required is {0}\". \n      format(getMinDiceThrows(moves, N))) \n",
    "orden": 8,
    "suborden": 36,
    "fecha_creacion": "2020-12-06 19:51:46",
    "fecha_modificacion": "2022-03-08 12:28:52"
  },
  {
    "ID": 233,
    "supergrupo": "Grafos",
    "tema": "Camino más corto desde múltiples orígenes",
    "texto": "Suponga que hay n ciudades conectadas por m caminos bidireccionales. Entre ellos hay varios pueblos con una comisaría. Queremos saber la distancia de cada pueblo a la comisaría más cercana. Si el pueblo tiene uno, la distancia es 0.\nEjemplo:\nEntrada:\nNúmero de vértices = 6\nNúmero de aristas = 9\nLocalidades con Comisaría: 1, 5\nAristas:\n1 2\n1 6\n2 6\n2 3\n3 6\n5 4\n6 5\n3 4\n5 3\n\n \nSalida:\n1 0\n2 1\n3 1\n4 1\n5 0\n6 1\n \nEnfoque ingenuo: podemos recorrer los vértices y desde cada vértice ejecutar un BFS para encontrar la ciudad más cercana con la estación de policía de ese vértice. Esto tomará O (V.E).\n\nMétodo eficiente Un método mejor es utilizar el algoritmo de Djikstra de forma modificada. Consideremos una de las fuentes como la fuente original y las otras fuentes como vértices con 0 rutas de costo desde la fuente original. Por lo tanto, empujamos todas las fuentes a la cola de Djikstra con distancia = 0 y el resto de los vértices con distancia = infinito. La distancia mínima de cada vértice desde la fuente original ahora calculada usando el algoritmo de Dijkstra son ahora esencialmente las distancias desde la fuente más cercana.\n\nExplicación: La implementación utiliza un conjunto de pares (distancia desde la fuente, vértice) ordenados según la distancia desde la fuente. Inicialmente, el conjunto contiene las fuentes con distancia = 0 y todos los demás vértices con distancia = infinito.\nEn cada paso, iremos al vértice con distancia mínima (d) desde la fuente, es decir, el primer elemento del conjunto (la propia fuente en el primer paso con distancia = 0). Pasamos por todos sus vértices adyacentes y si la distancia de cualquier vértice es> d + 1 reemplazamos su entrada en el conjunto con la nueva distancia. Luego eliminamos el vértice actual del conjunto. Continuamos esto hasta que el conjunto esté vacío.\nLa idea es que no puede haber una ruta más corta al vértice en la parte delantera del conjunto que la actual, ya que cualquier otra ruta será la suma de una ruta más larga (> = su longitud) y una longitud de ruta no negativa (a menos que están considerando aristas negativos).\nDado que todas las fuentes tienen una distancia = 0, al principio, los vértices adyacentes que no son fuentes obtendrán una distancia = 1. Todos los vértices obtendrán distancia = distancia desde su fuente más cercana.\n\nEnfoque más eficiente: Un método aún mejor es usar el BFS de múltiples fuentes, que es una modificación de BFS. Pondremos todos los vértices de origen en la cola al principio en lugar de un solo vértice que era en el caso de BFS estándar. primero visitará todos los vértices de origen. Después de eso, visitará los vértices que están a una distancia de 1 de todos los vértices de origen, luego a una distancia de 2 de todos los vértices de origen, y así sucesivamente.\n\n",
    "complejidad_tiempo": null,
    "java": "// Programa para demostrar BFS de múltiples fuentes\n\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.LinkedList;\n\npublic class MultiSourceSPUnweighted {\n\n    static final int N = 1000000;\n    // Esta matriz almacena las distancias de los \n    // vértices desde la fuente más cercana.\n    static int dist[] = new int[N];\n    // Esta matriz booleana es verdadera si se visita el \n    // vértice actual; de lo contrario, es falsa\n    static boolean visited[] = new boolean[N];\n\n    static void addEdge(ArrayList<Integer> graph[], int u, int v) {\n        // Función para agregar 2 aristas en un gráfico no dirigido\n        graph[u].add(v);\n        graph[v].add(u);\n    }\n\n    // Función BFS de múltiples fuentes\n    static void Multisource_BFS(ArrayList<Integer> graph[], LinkedList<Integer> q) {\n        while (!q.isEmpty()) {\n            int k = q.getFirst();\n            q.pollFirst();\n            for (Integer i : graph[k]) {\n                if (!visited[i]) {\n                    // Empujar los vértices adyacentes no visitados con la \n                    // distancia de la fuente actual = la distancia de este vértice + 1\n                    q.push(i);\n                    dist[i] = dist[k] + 1;\n                    visited[i] = true;\n                }\n            }\n        }\n    }\n\n    // Esta función calcula la distancia de cada vértice desde la fuente más cercana\n    static void nearestTown(ArrayList<Integer> graph[], int n, int sources[], int s) {\n        // Crea una cola para BFS \n        LinkedList<Integer> q = new LinkedList<>();\n        // Marque todos los vértices de origen como visitados y colóquelos\n        for (int i = 0; i < s; i++) {\n            q.push(sources[i]);\n            visited[sources[i]] = true;\n        }\n        Multisource_BFS(graph, q);\n        // Imprimiendo las distancias\n        for (int i = 1; i <= n; i++) {\n            System.out.println(i + \" \" + dist[i]);\n        }\n    }\n\n    public static void main(String[] args) {\n        // Número de vértices\n        int n = 6;\n        ArrayList<Integer> graph[] = new ArrayList[n + 1];\n        Arrays.fill(graph, new ArrayList<>());\n        // Caminos \n        addEdge(graph, 1, 2);\n        addEdge(graph, 1, 6);\n        addEdge(graph, 2, 6);\n        addEdge(graph, 2, 3);\n        addEdge(graph, 3, 6);\n        addEdge(graph, 5, 4);\n        addEdge(graph, 6, 5);\n        addEdge(graph, 3, 4);\n        addEdge(graph, 5, 3);\n        // Origenes\n        int sources[] = {1, 5};\n        int S = sources.length;\n        nearestTown(graph, n, sources, S);\n    }\n}\n",
    "cpp": "#include<bits/stdc++.h> \nusing namespace std;\n#define N 1000000 \n\nint dist[N];\nbool visited[N];\n\nvoid addEdge(vector<int> graph[], int u, int v) {\n    graph[u].push_back(v);\n    graph[v].push_back(u);\n}\n\nvoid Multisource_BFS(vector<int> graph[], queue<int>q) {\n    while (!q.empty()) {\n        int k = q.front();\n        q.pop();\n\n        for (auto i : graph[k]) {\n            if (!visited[i]) {\n                q.push(i);\n                dist[i] = dist[k] + 1;\n                visited[i] = true;\n            }\n        }\n    }\n}\n\nvoid nearestTown(vector<int> graph[], int n, int sources[], int s) {\n    queue<int> q;\n    for (int i = 0; i < s; i++) {\n        q.push(sources[i]);\n        visited[sources[i]] = true;\n    }\n    Multisource_BFS(graph, q);\n    for (int i = 1; i <= n; i++) {\n        cout << i << \" \" << dist[i] << endl;\n    }\n\n}\n\nint main() {\n    int n = 6;\n    vector<int> graph[n + 1];\n    addEdge(graph, 1, 2);\n    addEdge(graph, 1, 6);\n    addEdge(graph, 2, 6);\n    addEdge(graph, 2, 3);\n    addEdge(graph, 3, 6);\n    addEdge(graph, 5, 4);\n    addEdge(graph, 6, 5);\n    addEdge(graph, 3, 4);\n    addEdge(graph, 5, 3);\n    int sources[] = {1, 5};\n    int S = sizeof (sources) / sizeof (sources[0]);\n    nearestTown(graph, n, sources, S);\n    return 0;\n}\n",
    "py": "N = 1000000\ndist = [0 for _ in range (N)]\nvisited = [0 for _ in range (N)]\n\ndef addEdge(graph, u, v):\n    graph[u].append(v)\n    graph[v].append(u)\n\ndef multisourceBFS(graph, q):\n    while (len(q) != 0):\n        k = q[0]\n        q = q[1:]\n        for i in graph[k]:\n            if (visited[i] == False):\n                q.append(i)\n                dist[i] = dist[k] + 1\n                visited[i] = True\n  \ndef nearestTown(graph, n, sources, s):\n    q = []\n    for i in range(s):\n        q.append(sources[i])\n        visited[sources[i]] = True\n    multisourceBFS(graph, q)\n    for i in range (1, n + 1):\n        print(str(i) + \" \" + str(dist[i]))\n        \n        \nn = 6\ngraph = [[] for _ in range (n + 1)]\naddEdge(graph, 1, 2);\naddEdge(graph, 1, 6);\naddEdge(graph, 2, 6);\naddEdge(graph, 2, 3);\naddEdge(graph, 3, 6);\naddEdge(graph, 5, 4);\naddEdge(graph, 6, 5);\naddEdge(graph, 3, 4);\naddEdge(graph, 5, 3);\nsources = [1, 5]\nS = len(sources)\nnearestTown(graph, n, sources, S);\n",
    "orden": 8,
    "suborden": 37,
    "fecha_creacion": "2020-12-06 19:51:46",
    "fecha_modificacion": "2022-03-08 12:28:52"
  },
  {
    "ID": 234,
    "supergrupo": "Grafos",
    "tema": "Camino más corto en un grafo multi etapas",
    "texto": "Un gráfico de etapas múltiples es un gráfico dirigido en el que los nodos se pueden dividir en un conjunto de etapas de modo que todos las aristas sean de una etapa a la siguiente solo (en otras palabras, no hay arista entre los vértices de la misma etapa y desde un vértice de la corriente etapa a etapa anterior).\nNos dan un gráfico de varias etapas, una fuente y un destino, necesitamos encontrar la ruta más corta desde la fuente hasta el destino. Por convención, consideramos el origen en la etapa 1 y el destino como última etapa.\nA continuación se muestra un gráfico de ejemplo\n \nAhora hay varias estrategias que podemos aplicar: -\n• El método de fuerza bruta para encontrar todos los caminos posibles entre el origen y el destino y luego encontrar el mínimo. Esa es la PEOR estrategia posible.\n• Algoritmo de Dijkstra de rutas más cortas de fuente única. Este método encontrará las rutas más cortas desde la fuente a todos los demás nodos, lo que no es necesario en este caso. Por lo tanto, llevará mucho tiempo y ni siquiera utiliza la función ESPECIAL que tiene este gráfico MULTI-ETAPA.\n• Método codicioso simple: en cada nodo, elija la ruta de salida más corta. Si aplicamos este enfoque al gráfico de ejemplo anterior, obtenemos la solución como 1 + 4 + 18 = 23. Pero un vistazo rápido al gráfico mostrará caminos mucho más cortos disponibles que 23. ¡Entonces el método codicioso falla!\n• La mejor opción es la Programación dinámica. Por lo tanto, debemos encontrar la subestructura óptima, las ecuaciones recursivas y los subproblemas superpuestos.\nSubestructura óptima y ecuación recursiva: -\n\nDefinimos la notación: - M (x, y) como el costo mínimo para T (nodo objetivo) de la Etapa x, Nodo y.\n\nDistancia más corta desde la etapa 1, nodo 0 a\ndestino, es decir, 7 es M (1, 0).\n\n// De 0, podemos pasar a 1 o 2 o 3 a\n// llegar a 7.\nM (1, 0) = mínimo (1 + M (2, 1),\n              2 + M (2, 2),\n              5 + M (2, 3))\nEsto significa que nuestro problema de 0 -> 7 ahora se subdivide en 3 subproblemas: -\nEntonces, si tenemos un total de 'n' etapas y el objetivo\ncomo T, entonces la condición de parada será: -\nM (n-1, yo) = yo ---> T + M (n, T) = yo ---> T\nÁrbol de recursividad y subproblemas superpuestos: -\nEntonces, la jerarquía de evaluaciones M (x, y) se verá así: -\nEn M (i, j), i es el número de etapa y\nj es el número de nodo\n\n                   M (1, 0)\n           / | \\\n          / | \\\n       M (2, 1) M (2, 2) M (2, 3)\n    / \\ / \\ / \\\nM (3, 4) M (3, 5) M (3, 4) M (3, 5) M (3, 6) M (3, 6)\n . . . . . .\n . . . . . .\n . . . . . .\nEntonces, aquí hemos dibujado una parte muy pequeña del árbol de recursividad y ya podemos ver subproblemas superpuestos. Podemos reducir en gran medida el número de evaluaciones M (x, y) mediante la programación dinámica.\nDetalles de implementacion:\nLa siguiente implementación asume que los nodos están numerados de 0 a N-1 desde la primera etapa (origen) hasta la última etapa (destino). También asumimos que el gráfico de entrada es de varias etapas.\n",
    "complejidad_tiempo": null,
    "java": "// Programa Java para encontrar la distancia más \n// corta en un gráfico de varias etapas.\n\npublic class MultiStageGraphSP {\n\n    static int N = 8;\n    static int INF = Integer.MAX_VALUE;\n\n    // Devuelve la distancia más corta de 0 a N-1.\n    public static int shortestDist(int[][] graph) {\n        // dist [i] va a almacenar la distancia más corta del nodo i al nodo N-1.\n        int[] dist = new int[N];\n        dist[N - 1] = 0;\n\n        // Calcular la ruta más corta para el resto de los nodos\n        for (int i = N - 2; i >= 0; i--) {\n\n            // Inicializar la distancia desde i hasta el destino (N-1)\n            dist[i] = INF;\n\n            // Compruebe todos los nodos de las siguientes etapas \n            // para encontrar la distancia más corta de i a N-1.\n            for (int j = i; j < N; j++) {\n                // Rechazar si no existe camino\n                if (graph[i][j] == INF) {\n                    continue;\n                }\n                // Aplicamos la ecuación recursiva a la distancia al objetivo a \n                // través de j. y compare con la distancia mínima hasta ahora.\n                dist[i] = Math.min(dist[i], graph[i][j]\n                        + dist[j]);\n            }\n        }\n\n        return dist[0];\n    }\n\n    public static void main(String[] args) {\n        // Gráfico almacenado en forma de matriz de adyacencia\n        int[][] graph = new int[][]{\n            {INF, 1, 2, 5, INF, INF, INF, INF},\n            {INF, INF, INF, INF, 4, 11, INF, INF},\n            {INF, INF, INF, INF, 9, 5, 16, INF},\n            {INF, INF, INF, INF, INF, INF, 2, INF},\n            {INF, INF, INF, INF, INF, INF, INF, 18},\n            {INF, INF, INF, INF, INF, INF, INF, 13},\n            {INF, INF, INF, INF, INF, INF, INF, 2}};\n\n        System.out.println(shortestDist(graph));\n    }\n}\n",
    "cpp": "#include<bits/stdc++.h> \nusing namespace std;\n#define N 8\n#define INF INT_MAX\n\nint shortestDist(int graph[7][8]) {\n    int dist [N];\n    dist[N - 1] = 0;\n\n    for (int i = N - 2; i >= 0; i--) {\n        dist[i] = INF;\n        for (int j = i; j < N; j++) {\n            if (graph[i][j] == INF) {\n                continue;\n            }\n            dist[i] = min(dist[i], graph[i][j]\n                    + dist[j]);\n        }\n    }\n    return dist[0];\n}\n\nint main() {\n    int graph[7][8] = {\n        {INF, 1, 2, 5, INF, INF, INF, INF},\n        {INF, INF, INF, INF, 4, 11, INF, INF},\n        {INF, INF, INF, INF, 9, 5, 16, INF},\n        {INF, INF, INF, INF, INF, INF, 2, INF},\n        {INF, INF, INF, INF, INF, INF, INF, 18},\n        {INF, INF, INF, INF, INF, INF, INF, 13},\n        {INF, INF, INF, INF, INF, INF, INF, 2}\n    };\n\n    cout << shortestDist(graph) << endl;\n    return 0;\n}\n",
    "py": "N=8\nINF=1<<32\ndef shortestDist(graph):\n    dist=[0 for i in range (N)]\n    dist[N - 1] = 0\n    for i in range (N-2,-1,-1):\n        dist[i] = INF\n        for j in range (N):\n            if (graph[i][j] == INF):\n                continue\n            dist[i] = min(dist[i], graph[i][j]+ dist[j])\n    return dist[0]\n\n\ngraph= [\n    [INF, 1, 2, 5, INF, INF, INF, INF],\n    [INF, INF, INF, INF, 4, 11, INF, INF],\n    [INF, INF, INF, INF, 9, 5, 16, INF],\n    [INF, INF, INF, INF, INF, INF, 2, INF],\n    [INF, INF, INF, INF, INF, INF, INF, 18],\n    [INF, INF, INF, INF, INF, INF, INF, 13],\n    [INF, INF, INF, INF, INF, INF, INF, 2]];\nprint(shortestDist(graph))\n",
    "orden": 8,
    "suborden": 38,
    "fecha_creacion": "2020-12-06 19:51:47",
    "fecha_modificacion": "2022-03-08 12:28:52"
  },
  {
    "ID": 235,
    "supergrupo": "Grafos",
    "tema": "Camino mas corto de k aristas",
    "texto": "Dada una dirección y dos vértices \"u\" y \"v\" en ella, encuentre la ruta más corta de \"u\" a \"v\" con exactamente k aristas en la ruta.\nEl gráfico se da como representación de matriz de adyacencia donde el valor del gráfico [i] [j] indica el peso de una arista desde el vértice i hasta el vértice j y un valor INF (infinito) indica que no hay arista de i a j.\n \nLa idea es navegar a través de todas las rutas de longitud k desde u hasta v utilizando el enfoque discutido en la publicación anterior y devolver el peso de la ruta más corta. Una solución simple es comenzar desde u, ir a todos los vértices adyacentes y repetir para los vértices adyacentes con k como k-1, origen como vértice adyacente y destino como v.\n\nLa complejidad de tiempo del peor caso de la función anterior es O (Vk) donde V es el número de vértices en el gráfico dado. Simplemente podemos analizar la complejidad del tiempo dibujando un árbol de recursividad. Lo peor ocurre para un gráfico completo. En el peor de los casos, cada nodo interno del árbol de recursividad tendría exactamente V hijos.\nPodemos optimizar la solución anterior mediante la programación dinámica. La idea es construir una tabla 3D donde la primera dimensión es la fuente, la segunda dimensión es el destino, la tercera dimensión es el número de aristas desde el origen hasta el destino y el valor es el recuento de paseos. Al igual que otros problemas de programación dinámica, llenamos la tabla 3D de abajo hacia arriba.\nLa complejidad temporal de la solución basada en DP anterior es O (V3K), que es mucho mejor que la solución ingenua.\n",
    "complejidad_tiempo": null,
    "java": "// Programa Java basado en programación dinámica para encontrar \n// la ruta más corta con exactamente k caminos\n\npublic class ShortestPathKEdges {\n    // Definir número de vértices en el gráfico y valor no finito\n\n    static final int V = 4;\n    static final int INF = Integer.MAX_VALUE;\n\n    // Una función recursiva ingenua para contar paseos de u a v con k aristas\n    static int shortestPath(int graph[][], int u, int v, int k) {\n        // Casos base\n        if (k == 0 && u == v) {\n            return 0;\n        }\n        if (k == 1 && graph[u][v] != INF) {\n            return graph[u][v];\n        }\n        if (k <= 0) {\n            return INF;\n        }\n\n        // Inicializar resultado\n        int res = INF;\n\n        // Ir a todos los adyacentes de u y repetir\n        for (int i = 0; i < V; i++) {\n            if (graph[u][i] != INF && u != i && v != i) {\n                int rec_res = shortestPath(graph, i, v, k - 1);\n                if (rec_res != INF) {\n                    res = Math.min(res, graph[u][i] + rec_res);\n                }\n            }\n        }\n        return res;\n    }\n\n    public static void main(String[] args) {\n        /* Creemos el grafo que se muestra en el diagrama anterior.*/\n        int graph[][] = new int[][]{{0, 10, 3, 2},\n        {INF, 0, INF, 7},\n        {INF, INF, 0, 6},\n        {INF, INF, INF, 0}\n        };\n        int u = 0, v = 3, k = 2;\n        System.out.println(\"Weight of the shortest path is \"\n                + shortestPath(graph, u, v, k));\n    }\n}\n",
    "cpp": "#include <bits/stdc++.h> \nusing namespace std;\n\n#define V 4 \n#define INF INT_MAX \n\nint shortestPath(int graph[][V], int u, int v, int k) {\n    if (k == 0 && u == v) return 0;\n    if (k == 1 && graph[u][v] != INF) return graph[u][v];\n    if (k <= 0) return INF;\n    int res = INF;\n    for (int i = 0; i < V; i++) {\n        if (graph[u][i] != INF && u != i && v != i) {\n            int rec_res = shortestPath(graph, i, v, k - 1);\n            if (rec_res != INF)\n                res = min(res, graph[u][i] + rec_res);\n        }\n    }\n    return res;\n}\n\nint main() {\n    int graph[V][V] = {\n        {0, 10, 3, 2},\n        {INF, 0, INF, 7},\n        {INF, INF, 0, 6},\n        {INF, INF, INF, 0}\n    };\n    int u = 0, v = 3, k = 2;\n    cout << \"Weight of the shortest path is \" <<\n            shortestPath(graph, u, v, k);\n    return 0;\n}\n",
    "py": "def shortestPath(graph, u, v, k): \n    V = 4\n    INF = 999999999999\n    if k == 0 and u == v: \n        return 0\n    if k == 1 and graph[u][v] != INF: \n        return graph[u][v] \n    if k <= 0: \n        return INF \n    res = INF \n    for i in range(V): \n        if graph[u][i] != INF and u != i and v != i: \n            rec_res = shortestPath(graph, i, v, k - 1) \n            if rec_res != INF: \n                res = min(res, graph[u][i] + rec_res) \n    return res \n\n\nINF = 999999999999\ngraph = [[0, 10, 3, 2], \n    [INF, 0, INF, 7], \n    [INF, INF, 0, 6], \n    [INF, INF, INF, 0]] \nu = 0\nv = 3\nk = 2\nprint(\"Weight of the shortest path is\", \n      shortestPath(graph, u, v, k)) \n",
    "orden": 8,
    "suborden": 39,
    "fecha_creacion": "2020-12-06 19:51:47",
    "fecha_modificacion": "2022-03-08 12:28:52"
  },
  {
    "ID": 236,
    "supergrupo": "Grafos",
    "tema": "Algoritmo de Trajano, componentes fuertemente conexas",
    "texto": "Un grafo dirigido está fuertemente conectado si hay una ruta entre todos los pares de vértices. Un componente fuertemente conectado (SCC strongly conected component) de un gráfico dirigido es un subgráfico máximo fuertemente conectado. Por ejemplo, hay 3 SCC en el siguiente gráfico.\n \nEl algoritmo de Kosaraju para componentes fuertemente conectados dos recorridos DFS de un gráfico, el algoritmo de Tarjan requiere solo un recorrido DFS.\nEl algoritmo de Tarjan se basa en los siguientes hechos:\n1. La búsqueda DFS produce un árbol / bosque DFS\n2. Los componentes fuertemente conectados forman subárboles del árbol DFS.\n3. Si podemos encontrar el encabezado de tales subárboles, podemos imprimir / almacenar todos los nodos en ese subárbol (incluido el encabezado) y ese será un SCC.\n4. No hay arista posterior de un SCC a otro (puede haber aristas transversales, pero las aristas transversales no se utilizarán al procesar el gráfico).\nPara encontrar la cabeza de un SCC, calculamos el disco y la matriz baja (como se hizo para el punto de articulación, puente, componente biconectado). Como se discutió en las publicaciones anteriores, bajo [u] indica el vértice visitado más temprano (el vértice con el tiempo mínimo de descubrimiento) que se puede alcanzar desde el subárbol enraizado con u. Un nodo u es cabeza si disc[u] = low[u].\n\nEl componente fuertemente conectado se relaciona solo con el gráfico dirigido, pero los valores de disc y low se relacionan con el gráfico dirigido y no dirigido, por lo que en la imagen anterior hemos tomado un gráfico no dirigido.\nEn la Figura anterior, hemos mostrado un gráfico y su árbol DFS (podría haber diferentes árboles DFS en el mismo gráfico dependiendo del orden en que se atraviesan las aristas).\nEn el árbol DFS, las flechas continuas son las aristas del árbol y las flechas punteadas son las aristas posteriores (DFS Tree Edges\nLos valores de disc y low se muestran en la Figura para cada nodo como (disc / low).\ndisc: este es el momento en que se visita un nodo por primera vez durante el recorrido DFS. Para los nodos A, B, C, .., J en el árbol DFS, los valores del disc son 1, 2, 3, .., 10.\nlow: en el árbol DFS, las aristas del árbol nos llevan hacia adelante, desde el nodo ancestro hasta uno de sus descendientes. Por ejemplo, desde el nodo C, las aristas del árbol pueden llevarnos al nodo G, al nodo I, etc. Las aristas posteriores nos llevan hacia atrás, desde un nodo descendiente a uno de sus antepasados. Por ejemplo, desde el nodo G, las aristas posteriores nos llevan a E o C. Si miramos el árbol y la arista posterior juntos, entonces podemos ver que si comenzamos el recorrido desde un nodo, podemos bajar por el árbol a través de las aristas del árbol y luego sube por las aristas traseras. \n\nPor ejemplo, desde el nodo E, podemos bajar a G y luego subir a C. De manera similar, desde E, podemos bajar a I o J y luego subir a F. El valor \"low\" de un nodo indica el nivel más alto alcanzable ancestro (con el valor de disc mínimo posible) a través del subárbol de ese nodo. Entonces, para cualquier nodo, el valor low es igual a su valor de disc de todos modos (un nodo es antepasado de sí mismo). Luego miramos en su subárbol y vemos si hay algún nodo que pueda llevarnos a alguno de sus ancestros. Si hay varias aristas posteriores en el subárbol que nos llevan a diferentes ancestros, entonces tomamos el que tiene el valor mínimo de disc (es decir, el más alto). Si miramos el nodo F, tiene dos subárboles. El subárbol con el nodo G, nos lleva a E y C. El otro subárbol nos lleva de regreso a F solamente. Aquí, el antepasado más alto es C, donde F puede alcanzar y, por lo tanto, el valor low de F es 3 (el valor del disc de C).\nCon base en la discusión anterior, debe quedar claro que los valores lows de B, C y D son 1 (ya que A es el nodo más alto al que pueden llegar B, C y D). De la misma manera, los valores lows de E, F, G son 3 y los valores lows de H, I, J son 6.\nPara cualquier nodo u, cuando se inicia DFS, Low se establecerá en su disc 1st.\nLuego, más adelante, DFS se realizará en cada uno de sus hijos v uno por uno, el valor low de u puede cambiarlo en dos casos:\nCaso1 (arista del árbol): Si el nodo v aún no se ha visitado, luego de que se complete la DFS de v, el mínimo de low [u] y low [v] se actualizará a low [u].\nlow [u] = min (low [u], low [v]);\nCaso 2 (arista posterior): cuando ya se ha visitado el niño v, el mínimo de low [u] y el disc [v] se actualizarán a low [u].\nlow [u] = min (low [u], disc [v]);\nEn el caso dos, ¿podemos tomar low [v] en lugar del disc [v]? . La respuesta es NO. Si puede pensar por qué la respuesta es NO, probablemente haya entendido el concepto Low and Disc.\n\nLos mismos valores Low y Disc ayudan a resolver otros problemas de gráficos como el punto de articulación, el puente y el componente biconectado.\nPara rastrear el subárbol enraizado en la cabecera, podemos usar una pila (siga presionando el nodo mientras visita). Cuando se encuentre un nodo principal, saque todos los nodos de la pila hasta que salga de la pila.\nPara asegurarnos, no consideramos las aristas cruzadas, cuando llegamos a un nodo que ya está visitado, debemos procesar el nodo visitado solo si está presente en la pila; de lo contrario, ignore el nodo.\n",
    "complejidad_tiempo": null,
    "java": "// Programa Java para encontrar componentes fuertemente conectados en un \n// grafo dirigido dado utilizando el algoritmo de Tarjan (DFS único)\n\nimport java.util.*;\n\npublic class TarjanStronglyConnectedComponents {\n\n    // Esta clase representa un gráfico dirigido \n    // utilizando la representación de lista de adyacencia. \n    static class Graph {\n\n        // No de vértices \n        private int V;\n\n        //Listas de adyacencia\n        private LinkedList<Integer> adj[];\n        private int Time;\n\n        Graph(int v) {\n            V = v;\n            adj = new LinkedList[v];\n\n            for (int i = 0; i < v; ++i) {\n                adj[i] = new LinkedList();\n            }\n\n            Time = 0;\n        }\n\n        // Función para agregar una arista al gráfico\n        void addEdge(int v, int w) {\n            adj[v].add(w);\n        }\n\n        // Una función recursiva que encuentra e imprime componentes \n        // fuertemente conectados usando DFS transversal\n        // u -> El vértice a visitar a continuación\n        // disc[] -> Almacena los tiempos de descubrimiento \n        // de los vértices visitados\n        // low[] - >> vértice visitado más temprano (el vértice con tiempo \n        // mínimo de descubrimiento) que se puede alcanzar desde el \n        // subárbol enraizado con el vértice actual\n        // st - >> Para almacenar todos los ancestros \n        // conectados (podría ser parte de SCC)\n        // stackMember [] -> matriz de bits / índices para \n        // comprobar más rápidamente si un nodo está en la pila\n        void SCCUtil(int u, int low[], int disc[],\n                boolean stackMember[],\n                Stack<Integer> st) {\n\n            // Inicializar el tiempo de descubrimiento y el valor bajo \n            disc[u] = Time;\n            low[u] = Time;\n            Time += 1;\n            stackMember[u] = true;\n            st.push(u);\n            int n;\n            // Pasa por todos los vértices adyacentes a este\n            Iterator<Integer> i = adj[u].iterator();\n            while (i.hasNext()) {\n                n = i.next();\n                if (disc[n] == -1) {\n                    SCCUtil(n, low, disc, stackMember, st);\n                    // Compruebe si el subárbol enraizado con v \n                    // tiene una conexión con uno de los antepasados de u\n                    // Caso 1 (según la discusión anterior sobre Disc y Low value)  \n                    low[u] = Math.min(low[u], low[n]);\n                } else if (stackMember[n] == true) {\n\n                    // Actualice el valor bajo de 'u' solo si 'v' todavía está \n                    // en la pila (es decir, es un borde posterior, \n                    // no un borde transversal).\n                    // Caso 2 (según la discusión anterior sobre Disc y Low value) \n                    low[u] = Math.min(low[u], disc[n]);\n                }\n            }\n\n            // nodo principal encontrado, saque la pila e imprima un \n            // SCC Para almacenar los vértices extraídos de la pila \n            int w = -1;\n            if (low[u] == disc[u]) {\n                while (w != u) {\n                    w = (int) st.pop();\n                    System.out.print(w + \" \");\n                    stackMember[w] = false;\n                }\n                System.out.println();\n            }\n        }\n\n        // La función para hacer un recorrido DFS. Utiliza SCCUtil ()\n        void SCC() {\n\n            // Marque todos los vértices como no visitados e Inicialice arrsys \n            // parent y visited, y ap (punto de articulación)\n            int disc[] = new int[V];\n            int low[] = new int[V];\n            for (int i = 0; i < V; i++) {\n                disc[i] = -1;\n                low[i] = -1;\n            }\n\n            boolean stackMember[] = new boolean[V];\n            Stack<Integer> st = new Stack<>();\n\n            // Llame a la función auxiliar recursiva para encontrar \n            // puntos de articulación en el árbol DFS enraizado \n            // con el vértice 'i'\n            for (int i = 0; i < V; i++) {\n                if (disc[i] == -1) {\n                    SCCUtil(i, low, disc,\n                            stackMember, st);\n                }\n            }\n        }\n\n    }\n\n    public static void main(String args[]) {\n        Graph g1 = new Graph(5);\n        g1.addEdge(1, 0);\n        g1.addEdge(0, 2);\n        g1.addEdge(2, 1);\n        g1.addEdge(0, 3);\n        g1.addEdge(3, 4);\n        System.out.println(\"SSC in first graph \");\n        g1.SCC();\n        Graph g2 = new Graph(4);\n        g2.addEdge(0, 1);\n        g2.addEdge(1, 2);\n        g2.addEdge(2, 3);\n        System.out.println(\"\\nSSC in second graph \");\n        g2.SCC();\n        Graph g3 = new Graph(7);\n        g3.addEdge(0, 1);\n        g3.addEdge(1, 2);\n        g3.addEdge(2, 0);\n        g3.addEdge(1, 3);\n        g3.addEdge(1, 4);\n        g3.addEdge(1, 6);\n        g3.addEdge(3, 5);\n        g3.addEdge(4, 5);\n        System.out.println(\"\\nSSC in third graph \");\n        g3.SCC();\n        Graph g4 = new Graph(11);\n        g4.addEdge(0, 1);\n        g4.addEdge(0, 3);\n        g4.addEdge(1, 2);\n        g4.addEdge(1, 4);\n        g4.addEdge(2, 0);\n        g4.addEdge(2, 6);\n        g4.addEdge(3, 2);\n        g4.addEdge(4, 5);\n        g4.addEdge(4, 6);\n        g4.addEdge(5, 6);\n        g4.addEdge(5, 7);\n        g4.addEdge(5, 8);\n        g4.addEdge(5, 9);\n        g4.addEdge(6, 4);\n        g4.addEdge(7, 9);\n        g4.addEdge(8, 9);\n        g4.addEdge(9, 8);\n        System.out.println(\"\\nSSC in fourth graph \");\n        g4.SCC();\n        Graph g5 = new Graph(5);\n        g5.addEdge(0, 1);\n        g5.addEdge(1, 2);\n        g5.addEdge(2, 3);\n        g5.addEdge(2, 4);\n        g5.addEdge(3, 0);\n        g5.addEdge(4, 2);\n        System.out.println(\"\\nSSC in fifth graph \");\n        g5.SCC();\n    }\n}\n",
    "cpp": "#include<bits/stdc++.h>\n#include <cstdlib>\n#define MAX 99999\n#define NIL -1\nusing namespace std;\nlist<int> adj[MAX];\n\nstruct Graph {\n    int V;\n\n    void initGraph(int v) {\n        for (int i = 0; i < v; i++) {\n            adj[i].clear();\n        }\n    }\n\n    void addEdge(int v, int w) {\n        adj[v].push_back(w);\n    }\n\n    void SCCUtil(int u, int disc[], int low[], stack<int>& st, bool stackMember[]) {\n        static int time = 0;\n        disc[u] = low[u] = ++time;\n        st.push(u);\n        stackMember[u] = true;\n        for (int i : adj[u]) {\n            int v = i;\n\n            if (disc[v] == -1) {\n                SCCUtil(v, disc, low, st, stackMember);\n\n\n                low[u] = min(low[u], low[v]);\n            }\n\n            else if (stackMember[v] == true) {\n                low[u] = min(low[u], disc[v]);\n            }\n        }\n        int w = 0;\n        if (low[u] == disc[u]) {\n            while (st.top() != u) {\n                w = (int) st.top();\n                cout << w << \" \";\n                stackMember[w] = false;\n                st.pop();\n            }\n            w = (int) st.top();\n            cout << w << \"\\n\";\n            stackMember[w] = false;\n            st.pop();\n        }\n    }\n\n    void SCC() {\n        int disc [V];\n        int low [V];\n        bool stackMember [V];\n        stack<int> st;\n\n        for (int i = 0; i < V; i++) {\n            disc[i] = NIL;\n            low[i] = NIL;\n            stackMember[i] = false;\n        }\n\n        for (int i = 0; i < V; i++) {\n            if (disc[i] == NIL) {\n                SCCUtil(i, disc, low, st, stackMember);\n            }\n        }\n    }\n\n};\n\nint main() {\n    cout << \"\\nSCCs in first graph \\n\";\n    Graph g1;\n    g1.V = 5;\n    g1.initGraph(5);\n    g1.addEdge(1, 0);\n    g1.addEdge(0, 2);\n    g1.addEdge(2, 1);\n    g1.addEdge(0, 3);\n    g1.addEdge(3, 4);\n    g1.SCC();\n\n    cout << \"\\nSCCs in second graph \\n\";\n    Graph g2;\n    g2.V = 4;\n    g2.initGraph(4);\n    g2.addEdge(0, 1);\n    g2.addEdge(1, 2);\n    g2.addEdge(2, 3);\n    g2.SCC();\n\n    cout << \"\\nSCCs in third graph \\n\";\n    Graph g3;\n    g3.V = 7;\n    g3.initGraph(7);\n    g3.addEdge(0, 1);\n    g3.addEdge(1, 2);\n    g3.addEdge(2, 0);\n    g3.addEdge(1, 3);\n    g3.addEdge(1, 4);\n    g3.addEdge(1, 6);\n    g3.addEdge(3, 5);\n    g3.addEdge(4, 5);\n    g3.SCC();\n\n    cout << \"\\nSCCs in fourth graph \\n\";\n    Graph g4;\n    g4.V = 11;\n    g4.initGraph(11);\n    g4.addEdge(0, 1);\n    g4.addEdge(0, 3);\n    g4.addEdge(1, 2);\n    g4.addEdge(1, 4);\n    g4.addEdge(2, 0);\n    g4.addEdge(2, 6);\n    g4.addEdge(3, 2);\n    g4.addEdge(4, 5);\n    g4.addEdge(4, 6);\n    g4.addEdge(5, 6);\n    g4.addEdge(5, 7);\n    g4.addEdge(5, 8);\n    g4.addEdge(5, 9);\n    g4.addEdge(6, 4);\n    g4.addEdge(7, 9);\n    g4.addEdge(8, 9);\n    g4.addEdge(9, 8);\n    g4.SCC();\n\n    cout << \"\\nSCCs in fifth graph \\n\";\n    Graph g5;\n    g5.V = 5;\n    g5.initGraph(5);\n    g5.addEdge(0, 1);\n    g5.addEdge(1, 2);\n    g5.addEdge(2, 3);\n    g5.addEdge(2, 4);\n    g5.addEdge(3, 0);\n    g5.addEdge(4, 2);\n    g5.SCC();\n\n    cout << \"\\nSCCs in sixth graph \\n\";\n    Graph g6;\n    g6.V = 5;\n    g6.initGraph(5);\n    g6.addEdge(2, 1);\n    g6.addEdge(0, 2);\n    g6.addEdge(1, 3);\n    g6.addEdge(1, 2);\n    g6.addEdge(2, 3);\n    g6.addEdge(4, 2);\n    g6.SCC();\n\n    cout << \"\\nSCCs in seventh graph \\n\";\n    Graph g7;\n    g7.V = 4;\n    g7.initGraph(4);\n    g7.addEdge(0, 1);\n    g7.addEdge(1, 2);\n    g7.addEdge(2, 3);\n    g7.addEdge(0, 3);\n    g7.addEdge(1, 0);\n    g7.SCC();\n\n\n    return 0;\n}\n",
    "py": "from collections import defaultdict\n \n   \nclass Graph: \n   \n    def __init__(self, vertices): \n        self.V = vertices  \n        self.graph = defaultdict(list)  \n        self.Time = 0\n  \n    def addEdge(self, u, v): \n        self.graph[u].append(v) \n          \n    def SCCUtil(self, u, low, disc, stackMember, st): \n  \n        disc[u] = self.Time \n        low[u] = self.Time \n        self.Time += 1\n        stackMember[u] = True\n        st.append(u) \n        for v in self.graph[u]: \n            if disc[v] == -1: \n              \n                self.SCCUtil(v, low, disc, stackMember, st) \n \n                low[u] = min(low[u], low[v]) \n            elif stackMember[v] == True:  \n                low[u] = min(low[u], disc[v]) \n  \n\n        w = -1 \n        if low[u] == disc[u]: \n            while w != u: \n                w = st.pop() \n                print w, \n                stackMember[w] = False\n                  \n            print\"\" \n              \n    def SCC(self): \n        disc = [-1] * (self.V) \n        low = [-1] * (self.V) \n        stackMember = [False] * (self.V) \n        st = [] \n        for i in range(self.V): \n            if disc[i] == -1: \n                self.SCCUtil(i, low, disc, stackMember, st) \n\ng1 = Graph(5) \ng1.addEdge(1, 0) \ng1.addEdge(0, 2) \ng1.addEdge(2, 1) \ng1.addEdge(0, 3) \ng1.addEdge(3, 4) \nprint \"SSC in first graph \"\ng1.SCC() \n  \ng2 = Graph(4) \ng2.addEdge(0, 1) \ng2.addEdge(1, 2) \ng2.addEdge(2, 3) \nprint \"nSSC in second graph \"\ng2.SCC() \n  \n   \ng3 = Graph(7) \ng3.addEdge(0, 1) \ng3.addEdge(1, 2) \ng3.addEdge(2, 0) \ng3.addEdge(1, 3) \ng3.addEdge(1, 4) \ng3.addEdge(1, 6) \ng3.addEdge(3, 5) \ng3.addEdge(4, 5) \nprint \"nSSC in third graph \"\ng3.SCC() \n  \ng4 = Graph(11) \ng4.addEdge(0, 1) \ng4.addEdge(0, 3) \ng4.addEdge(1, 2) \ng4.addEdge(1, 4) \ng4.addEdge(2, 0) \ng4.addEdge(2, 6) \ng4.addEdge(3, 2) \ng4.addEdge(4, 5) \ng4.addEdge(4, 6) \ng4.addEdge(5, 6) \ng4.addEdge(5, 7) \ng4.addEdge(5, 8) \ng4.addEdge(5, 9) \ng4.addEdge(6, 4) \ng4.addEdge(7, 9) \ng4.addEdge(8, 9) \ng4.addEdge(9, 8) \nprint \"nSSC in fourth graph \"\ng4.SCC(); \n  \n  \ng5 = Graph (5) \ng5.addEdge(0, 1) \ng5.addEdge(1, 2) \ng5.addEdge(2, 3) \ng5.addEdge(2, 4) \ng5.addEdge(3, 0) \ng5.addEdge(4, 2) \nprint \"nSSC in fifth graph \"\ng5.SCC();\n",
    "orden": 8,
    "suborden": 40,
    "fecha_creacion": "2020-12-06 19:51:47",
    "fecha_modificacion": "2022-03-08 12:28:52"
  },
  {
    "ID": 237,
    "supergrupo": "Grafos",
    "tema": "Máximo cotejamiento bipartito",
    "texto": "Una coincidencia en un gráfico bipartito es un conjunto de aristas elegidas de tal manera que no haya dos aristas que compartan un punto final. Una coincidencia máxima es una coincidencia de tamaño máximo (número máximo de aristas). En una coincidencia máxima, si se le agrega algúna arista, ya no es una coincidencia. Puede haber más de una coincidencia máxima para un gráfico bipartito determinado.\n\nHay muchos problemas del mundo real que pueden formarse como emparejamiento bipartito. Por ejemplo, considere el siguiente problema:\nHay M solicitantes de empleo y N trabajos. Cada solicitante tiene un subconjunto de trabajos que le interesan. Cada oferta de trabajo solo puede aceptar un solicitante y un solicitante de trabajo puede ser designado para un solo trabajo. Busque una asignación de puestos de trabajo a los solicitantes de manera que la mayor cantidad posible de solicitantes consiga trabajo.\n\nProblema de coincidencia máxima bipartita y flujo máximo\nEl problema de máxima coincidencia bipartita (MBP) se puede resolver convirtiéndolo en una red de flujo\nLos siguientes son los pasos.\n\n1) Construya una red de flujo\nDebe haber una fuente y un sumidero en una red de flujo. Entonces agregamos una fuente y agregamos aristas desde la fuente a todos los solicitantes. Del mismo modo, agregue aristas de todos los trabajos para hundirlos. La capacidad de cada arista está marcada como 1 unidad.\n\n2) Encuentre el flujo máximo.\nUsamos el algoritmo de Ford-Fulkerson para encontrar el flujo máximo en la red de flujo construida en el paso 1. El flujo máximo es en realidad el MBP que estamos buscando.\n\n¿Cómo implementar el enfoque anterior?\nPrimero definamos las formas de entrada y salida. La entrada tiene la forma de matriz de Edmonds, que es una matriz 2D \"bpGraph [M] [N]\" con M filas (para M solicitantes de empleo) y N columnas (para N empleos). El valor bpGraph [i] [j] es 1 si el i-ésimo solicitante está interesado en el j'th trabajo; de lo contrario, 0.\nLa salida es el número máximo de personas que pueden conseguir trabajo.\nUna forma sencilla de implementar esto es crear una matriz que represente la representación de la matriz de adyacencia de un gráfico dirigido con M + N + 2 vértices. Llame a fordFulkerson () para la matriz. Esta implementación requiere O ((M + N) * (M + N)) espacio extra.\nEl espacio adicional se puede reducir y el código se puede simplificar utilizando el hecho de que el gráfico es bipartito y la capacidad de cada arista es 0 o 1. La idea es utilizar el recorrido DFS para encontrar un trabajo para un solicitante (similar a aumentar la ruta en Ford-Fulkerson). Llamamos bpm () para cada solicitante, bpm () es la función basada en DFS que intenta todas las posibilidades para asignar un trabajo al solicitante.\n\nEn bpm (), probamos uno por uno todos los trabajos que le interesan a un solicitante \"u\" hasta que encontramos un trabajo, o todos los trabajos se prueban sin suerte. Para cada trabajo que intentamos, hacemos lo siguiente.\nSi un trabajo no se asigna a nadie, simplemente se lo asignamos al solicitante y devolvemos verdadero. Si se asigna un trabajo a otra persona, digamos x, entonces verificamos recursivamente si a x se le puede asignar algún otro trabajo. Para asegurarnos de que x no obtenga el mismo trabajo nuevamente, marcamos el trabajo \"v\" como se ve antes de hacer una llamada recursiva para x. Si x puede conseguir otro trabajo, cambiamos al solicitante del trabajo \"v\" y devolvemos verdadero. Usamos una matriz maxR [0..N-1] que almacena los solicitantes asignados a diferentes trabajos.\nSi bmp () devuelve verdadero, significa que hay una ruta de aumento en la red de flujo y se agrega 1 unidad de flujo al resultado en maxBPM ().\n",
    "complejidad_tiempo": null,
    "java": "// Un programa Java para encontrar la máxima coincidencia bipartita.\n\npublic class MaximumBipartiteMatching {\n\n    // M es el número de solicitantes y N es el número de trabajos\n    static final int M = 6;\n    static final int N = 6;\n\n    // Una función recursiva basada en DFS que devuelve verdadero si es posible una coincidencia para el vértice u\n    static boolean bpm(boolean bpGraph[][], int u,\n            boolean seen[], int matchR[]) {\n        // Prueba cada trabajo uno por uno\n        for (int v = 0; v < N; v++) {\n            // Si el solicitante u está interesado en el trabajo v y v no es visitado\n            if (bpGraph[u][v] && !seen[v]) {\n\n                // Marcar v como visitado\n                seen[v] = true;\n\n                // Si el trabajo 'v' no está asignado a un solicitante OR si \n                // el solicitante previamente asignado para el trabajo v \n                // (que es matchR [v]) tiene un trabajo alternativo disponible. \n                // Dado que v está marcado como visitado en la línea anterior, \n                // matchR [v] en la siguiente llamada recursiva no obtendrá el \n                // trabajo 'v' nuevamente\n                if (matchR[v] < 0 || bpm(bpGraph, matchR[v],\n                        seen, matchR)) {\n                    matchR[v] = u;\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n\n    // Marcar v como visitado Devuelve el número máximo de \n    // coincidencias de M a N\n    static int maxBPM(boolean bpGraph[][]) {\n        // Una matriz para realizar un seguimiento de los solicitantes \n        // asignados a los trabajos. El valor de matchR [i] es el número de \n        // solicitante asignado al trabajo i, el valor -1 indica \n        // que nadie está asignado.\n        int matchR[] = new int[N];\n\n        // Inicialmente todos los trabajos están disponibles\n        for (int i = 0; i < N; ++i) {\n            matchR[i] = -1;\n        }\n\n        // Recuento de trabajos asignados a los solicitantes\n        int result = 0;\n        for (int u = 0; u < M; u++) {\n            // Marque todos los trabajos como no se ven para el próximo solicitante.\n            boolean seen[] = new boolean[N];\n            for (int i = 0; i < N; ++i) {\n                seen[i] = false;\n            }\n            // Averigüe si el solicitante 'u' puede conseguir un trabajo\n            if (bpm(bpGraph, u, seen, matchR)) {\n                result++;\n            }\n        }\n        return result;\n    }\n\n    public static void main(String[] args)\n            throws java.lang.Exception {\n        // Creemos un bpGraph que se muestra en el ejemplo anterior\n        boolean bpGraph[][] = new boolean[][]{\n            {false, true, true,false, false, false},\n            {true, false, false,true, false, false},\n            {false, false, true, false, false, false},\n            {false, false, true, true, false, false},\n            {false, false, false, false, false, false},\n            {false, false, false, false, false, true}};\n        System.out.println(\"Maximum number of applicants that can\"\n                + \" get job is \" + maxBPM(bpGraph));\n    }\n}\n",
    "cpp": "#include <iostream> \n#include <string.h> \nusing namespace std;\n#define M 6 \n#define N 6 \n\nbool bpm(bool bpGraph[M][N], int u,\n        bool seen[], int matchR[]) {\n\n    for (int v = 0; v < N; v++) {\n\n        if (bpGraph[u][v] && !seen[v]) {\n\n            seen[v] = true;\n\n            if (matchR[v] < 0 || bpm(bpGraph, matchR[v],\n                    seen, matchR)) {\n                matchR[v] = u;\n                return true;\n            }\n        }\n    }\n    return false;\n}\n\nint maxBPM(bool bpGraph[M][N]) {\n\n    int matchR[N];\n    memset(matchR, -1, sizeof (matchR));\n\n    int result = 0;\n    for (int u = 0; u < M; u++) {\n        bool seen[N];\n        memset(seen, 0, sizeof (seen));\n        if (bpm(bpGraph, u, seen, matchR))\n            result++;\n    }\n    return result;\n}\n\nint main() {\n\n    bool bpGraph[M][N] = {\n        {0, 1, 1, 0, 0, 0},\n        {1, 0, 0, 1, 0, 0},\n        {0, 0, 1, 0, 0, 0},\n        {0, 0, 1, 1, 0, 0},\n        {0, 0, 0, 0, 0, 0},\n        {0, 0, 0, 0, 0, 1}\n    };\n\n    cout << \"Maximum number of applicants that can get job is \"\n            << maxBPM(bpGraph);\n\n    return 0;\n} \n",
    "py": "class MBM: \n    def __init__(self, graph): \n        self.graph = graph  \n        self.ppl = len(graph) \n        self.jobs = len(graph[0]) \n    def bpm(self, u, matchR, seen): \n        for v in range(self.jobs): \n            if self.graph[u][v] and seen[v] == False: \n                seen[v] = True \n                if matchR[v] == -1 or self.bpm(matchR[v], matchR, seen): \n                    matchR[v] = u \n                    return True\n        return False\n\n    def maxBPM(self): \n        matchR = [-1] * self.jobs \n        result = 0 \n        for i in range(self.ppl): \n            seen = [False] * self.jobs \n            if self.bpm(i, matchR, seen): \n                result += 1\n        return result \n  \n  \nbpGraph = [[0, 1, 1, 0, 0, 0], \n    [1, 0, 0, 1, 0, 0], \n    [0, 0, 1, 0, 0, 0], \n    [0, 0, 1, 1, 0, 0], \n    [0, 0, 0, 0, 0, 0], \n    [0, 0, 0, 0, 0, 1]] \n  \ng = MBM(bpGraph) \n  \nprint (\"Maximum number of applicants that can get job is %d \" % g.maxBPM()) \n",
    "orden": 8,
    "suborden": 41,
    "fecha_creacion": "2020-12-06 19:51:48",
    "fecha_modificacion": "2022-03-08 12:28:52"
  },
  {
    "ID": 238,
    "supergrupo": "Grafos",
    "tema": "Lazy Propagation",
    "texto": "Consideremos el siguiente problema para comprender los árboles de segmentos.\nTenemos una matriz arr [0. . . n-1]. Deberíamos poder\n1 Encuentre la suma de los elementos del índice la r donde 0 <= l <= r <= n-1\n2 Cambie el valor de un elemento especificado de la matriz a un nuevo valor x. Necesitamos hacer arr [i] = x donde 0 <= i <= n-1.\nUna solución simple es ejecutar un ciclo de la ry calcular la suma de elementos en el rango dado. Para actualizar un valor, simplemente haga arr [i] = x. La primera operación toma O (n) tiempo y la segunda operación toma O (1) tiempo.\nOtra solución es crear otra matriz y almacenar la suma desde el principio hasta la i en el índice i en esta matriz. La suma de un rango dado ahora se puede calcular en O (1) tiempo, pero la operación de actualización toma O (n) tiempo ahora. Esto funciona bien si el número de operaciones de consulta es grande y muy pocas actualizaciones.\n\n¿Qué pasa si el número de consultas y actualizaciones es igual? ¿Podemos realizar ambas operaciones en tiempo O (log n) una vez dada la matriz? Podemos usar un árbol de segmentos para realizar ambas operaciones en tiempo O (Logn).\nRepresentación de árboles de segmentos\n1. Los nodos hoja son los elementos de la matriz de entrada.\n2. Cada nodo interno representa alguna fusión de los nodos hoja. La combinación puede ser diferente para diferentes problemas. Para este problema, la fusión es la suma de hojas debajo de un nodo.\nSe utiliza una representación de matriz de árbol para representar árboles de segmento. Para cada nodo en el índice i, el hijo izquierdo está en el índice 2 * i + 1, el hijo derecho en 2 * i + 2 y el padre está en.\n \n¿Cómo se ve el árbol de segmentos anterior en la memoria?\nAl igual que Heap, el árbol de segmentos también se representa como una matriz. La diferencia aquí es que no es un árbol binario completo. Es más bien un árbol binario completo (cada nodo tiene 0 o 2 hijos) y todos los niveles están llenos excepto posiblemente el último nivel. A diferencia de Heap, el último nivel puede tener espacios entre los nodos. A continuación se muestran los valores en la matriz de árbol de segmentos para el diagrama anterior.\n\nA continuación se muestra la representación en memoria del árbol de segmentos para la matriz de entrada {1, 3, 5, 7, 9, 11}\nst [] = {36, 9, 27, 4, 5, 16, 11, 1, 3, DUMMY, DUMMY, 7, 9, DUMMY, DUMMY}\n\nLos valores ficticios nunca se acceden y no tienen uso. Este es un desperdicio de espacio debido a la simple representación de una matriz. Podemos optimizar este desperdicio usando algunas implementaciones inteligentes, pero el código para suma y actualización se vuelve más complejo.\nConstrucción del árbol de segmentos a partir de una matriz dada\nComenzamos con un segmento arr [0. . . n-1]. y cada vez que dividimos el segmento actual en dos mitades (si aún no se ha convertido en un segmento de longitud 1), y luego llamamos al mismo procedimiento en ambas mitades, y para cada segmento, almacenamos la suma en el nodo correspondiente.\nTodos los niveles del árbol de segmentos construido se llenarán por completo excepto el último nivel. Además, el árbol será un árbol binario completo porque siempre dividimos los segmentos en dos mitades en cada nivel. Dado que el árbol construido es siempre un árbol binario completo con n hojas, habrá n-1 nodos internos. Entonces, el número total de nodos será 2 * n - 1. Tenga en cuenta que esto no incluye los nodos ficticios.\n\n¿Cuál es el tamaño total de la matriz que representa el árbol de segmentos?\nSi n es una potencia de 2, entonces no hay nodos ficticios. Entonces, el tamaño del árbol de segmentos es 2n-1 (n nodos hoja y n-1) nodos internos. Si n no es una potencia de 2, entonces el tamaño del árbol será 2 * x - 1 donde x es la potencia más pequeña de 2 mayor que n. Por ejemplo, cuando n = 10, el tamaño de la matriz que representa el árbol de segmentos es 2 * 16-1 = 31.\nUna explicación alternativa para el tamaño se basa en la altura. La altura del árbol de segmentos será. Dado que el árbol se representa mediante una matriz y la relación entre los índices padre e hijo debe mantenerse, el tamaño de la memoria asignada para el árbol de segmentos será.\nConsulta de la suma del rango dado\nUna vez que se construye el árbol, cómo obtener la suma utilizando el árbol de segmentos construido. El siguiente es el algoritmo para obtener la suma de elementos.\nint getSum (nodo, l, r)\n{\n   si el rango del nodo está dentro de lyr\n        valor de retorno en el nodo\n   de lo contrario, si el rango del nodo está completamente fuera de lyr\n        volver 0\n   más\n    return getSum (hijo izquierdo del nodo, l, r) +\n           getSum (hijo derecho del nodo, l, r)\n}\nActualizar un valor\nAl igual que la construcción de árboles y las operaciones de consulta, la actualización también se puede realizar de forma recursiva. Se nos da un índice que debe actualizarse. Sea diff el valor a agregar. Comenzamos desde la raíz del árbol de segmentos y agregamos diff a todos los nodos que han dado índice en su rango. Si un nodo no tiene un índice determinado en su rango, no realizamos ningún cambio en ese nodo.\n\nPropagación diferida: una optimización para agilizar las actualizaciones de rango\nCuando hay muchas actualizaciones y se realizan actualizaciones en un rango, podemos posponer algunas actualizaciones (evitar llamadas recursivas en la actualización) y hacer esas actualizaciones solo cuando sea necesario.\nRecuerde que un nodo en el árbol de segmentos almacena o representa el resultado de una consulta para un rango de índices. Y si el rango de este nodo se encuentra dentro del rango de la operación de actualización, entonces todos los descendientes del nodo también deben actualizarse. Por ejemplo, considere el nodo con el valor 27 en el diagrama anterior, este nodo almacena la suma de los valores en los índices de 3 a 5. Si nuestra consulta de actualización es para el rango 2 a 5, entonces necesitamos actualizar este nodo y todos los descendientes de este nodo. Con la propagación diferida, actualizamos solo el nodo con valor 27 y posponemos las actualizaciones a sus hijos almacenando esta información de actualización en nodos separados llamados nodos o valores diferidos. Creamos una matriz lazy [] que representa el nodo perezoso. El tamaño de lazy [] es el mismo que el de la matriz que representa el árbol de segmentos, que es el árbol [] en el código siguiente.\nLa idea es inicializar todos los elementos de lazy [] como 0. Un valor 0 en lazy [i] indica que no hay actualizaciones pendientes en el nodo i en el árbol de segmentos. Un valor distinto de cero de lazy [i] significa que esta cantidad debe agregarse al nodo i en el árbol de segmentos antes de realizar cualquier consulta al nodo.\n\nA continuación se muestra el método de actualización modificado.\n// Para actualizar el árbol de segmentos para cambiar la matriz\n// valores en los índices de matriz de nosotros a ue.\nupdateRange (nosotros, ue)\n1) Si el nodo del árbol del segmento actual tiene algún pendiente\n   actualizar, luego primero agregue esa actualización pendiente a\n   nodo actual.\n2) Si el rango del nodo actual se encuentra completamente en\n   actualizar el rango de consultas.\n.... a) Actualizar el nodo actual\n.... b) Posponga las actualizaciones para los niños estableciendo\n       valor perezoso para los nodos secundarios.\n3) Si el rango del nodo actual se superpone con la actualización\n   rango, siga el mismo enfoque que el anterior simple\n   actualizar.\n... a) Recurrir para niños izquierdos y derechos.\n... b) Actualizar el nodo actual usando los resultados de left\n      y llamadas correctas.\n\n¿También hay algún cambio en la función de consulta?\nDado que hemos cambiado la actualización para posponer sus operaciones, puede haber problemas si se realiza una consulta a un nodo que aún no se ha actualizado. Por lo tanto, también debemos actualizar nuestro método de consulta, que es getSumUtil en la publicación anterior. GetSumUtil () ahora primero verifica si hay una actualización pendiente y si la hay, luego actualiza el nodo. Una vez que se asegura de que se realiza la actualización pendiente, funciona igual que el getSumUtil () anterior.\n",
    "complejidad_tiempo": null,
    "java": "// Programa Java para demostrar la propagación diferida en el árbol de segmentos\n\npublic class LazyPropagation {\n\n    static final int MAX = 1000;         // Tamaño máximo del árbol\n    static int tree[] = new int[MAX]; // Para almacenar el árbol de segmentos\n    static int lazy[] = new int[MAX]; // Para almacenar actualizaciones pendientes\n\n    /*  si -> índice del nodo actual en el árbol de \n        segmentos ss y se -> Índices inicial y final de \n        los elementos para los que los nodos actuales almacenan la suma.\n        us y eu -> índices de inicio y finalización de la consulta \n        de actualización\n        ue -> índice final de la consulta de actualización\n        diff -> que necesitamos agregar en el rango us to ue */\n    static void updateRangeUtil(int si, int ss, int se, int us,\n            int ue, int diff) {\n        // Si el valor diferido es distinto de cero para el nodo \n        // actual del árbol de segmentos, hay algunas actualizaciones \n        // pendientes. Por lo tanto, debemos asegurarnos de que las \n        // actualizaciones pendientes se realicen antes de realizar \n        // nuevas actualizaciones. Porque este valor puede ser \n        // utilizado por los padres después de llamadas recursivas \n        // (ver la última línea de esta función)\n        if (lazy[si] != 0) {\n            // Realice actualizaciones pendientes utilizando el \n            // valor almacenado en nodos perezosos\n            tree[si] += (se - ss + 1) * lazy[si];\n            // comprobando si no es un nodo hoja porque si \n            // es un nodo hoja entonces no podemos ir más lejos\n            if (ss != se) {\n                // Podemos posponer la actualización de los niños, \n                // no necesitamos sus nuevos valores ahora. Dado que \n                // aún no estamos actualizando los hijos de si,\n                // necesitamos establecer banderas perezosas para los hijos\n                lazy[si * 2 + 1] += lazy[si];\n                lazy[si * 2 + 2] += lazy[si];\n            }\n\n            // Establezca el valor diferido para el nodo actual en 0, ya que se ha actualizado\n            lazy[si] = 0;\n        }\n\n        // fuera de rango\n        if (ss > se || ss > ue || se < us) {\n            return;\n        }\n\n        // El segmento actual está completamente dentro del rango\n        if (ss >= us && se <= ue) {\n            // Agregar la diferencia al nodo actual\n            tree[si] += (se - ss + 1) * diff;\n            // misma lógica para verificar el nodo hoja o no\n            if (ss != se) {\n                // Aquí es donde almacenamos los valores en los nodos \n                // perezosos, en lugar de actualizar el árbol de segmentos \n                // en sí. Dado que no necesitamos estos valores actualizados \n                // ahora posponemos las actualizaciones almacenando \n                // los valores en lazy []\n                lazy[si * 2 + 1] += diff;\n                lazy[si * 2 + 2] += diff;\n            }\n            return;\n        }\n\n        // Si no está completamente en sonó, pero se superpone, repita para los niños,\n        int mid = (ss + se) / 2;\n        updateRangeUtil(si * 2 + 1, ss, mid, us, ue, diff);\n        updateRangeUtil(si * 2 + 2, mid + 1, se, us, ue, diff);\n\n        // Y use el resultado de las llamadas de los niños para actualizar este nodo\n        tree[si] = tree[si * 2 + 1] + tree[si * 2 + 2];\n    }\n\n    // Función para actualizar un rango de valores en el árbol de segmentos\n    /* us y eu -> índices de inicio y finalización de la consulta de actualización\n        ue -> índice final de la consulta de actualización\n        diff -> que necesitamos agregar en el rango us to ue */\n    static void updateRange(int n, int us, int ue, int diff) {\n        updateRangeUtil(0, 0, n - 1, us, ue, diff);\n    }\n\n    /* Una función recursiva para obtener la suma de valores en un rango dado\n       de la matriz. Los siguientes son parámetros para esta función.\n       si -> Índice del nodo actual en el árbol de segmentos. Inicialmente \n             se pasa 0 ya que la raíz siempre está en el 'índice 0\n       ss & se -> Índices de inicio y finalización del segmento \n                  representado por el nodo actual, es decir, árbol [si]\n       qs & qe -> Índices de inicio y finalización del rango de consulta */\n    static int getSumUtil(int ss, int se, int qs, int qe, int si) {\n        // Si se establece el indicador diferido para el nodo actual del \n        // árbol de segmentos, hay algunas actualizaciones pendientes. \n        // Por lo tanto, debemos asegurarnos de que las actualizaciones \n        // pendientes se realicen antes de procesar la consulta \n        // de suma secundaria.\n        if (lazy[si] != 0) {\n            // Realice actualizaciones pendientes en este nodo. Tenga en \n            // cuenta que este nodo representa la suma de elementos en \n            // arr [ss..se] y todos estos elementos deben \n            // aumentarse mediante lazy [si]\n            tree[si] += (se - ss + 1) * lazy[si];\n\n            // comprobando si no es un nodo hoja porque si es un \n            // nodo hoja entonces no podemos ir más lejos\n            if (ss != se) {\n                // Dado que todavía no estamos actualizando el sistema \n                // operativo de los niños, debemos establecer \n                // valores perezosos para los niños.\n                lazy[si * 2 + 1] += lazy[si];\n                lazy[si * 2 + 2] += lazy[si];\n            }\n\n            // anule el valor diferido para el nodo actual, \n            // ya que se ha actualizado\n            lazy[si] = 0;\n        }\n\n        // Fuera de rango\n        if (ss > se || ss > qe || se < qs) {\n            return 0;\n        }\n\n        // En este punto, seguro que se realizan las actualizaciones \n        // diferidas pendientes para el nodo actual. Entonces podemos \n        // devolver el valor (igual que para la consulta en nuestra \n        // publicación anterior) si este segmento se encuentra en el rango\n        if (ss >= qs && se <= qe) {\n            return tree[si];\n        }\n        // Si una parte de este segmento se superpone con el rango dado\n        int mid = (ss + se) / 2;\n        return getSumUtil(ss, mid, qs, qe, 2 * si + 1)\n                + getSumUtil(mid + 1, se, qs, qe, 2 * si + 2);\n    }\n\n    // Devuelve la suma de los elementos en el rango desde el índice qs \n    // (inicio de la consulta) hasta qe (final de la consulta). \n    // Utiliza principalmente getSumUtil ()\n    static int getSum(int n, int qs, int qe) {\n        // Compruebe si hay valores de entrada erróneos\n        if (qs < 0 || qe > n - 1 || qs > qe) {\n            System.out.println(\"Invalid Input\");\n            return -1;\n        }\n\n        return getSumUtil(0, n - 1, qs, qe, 0);\n    }\n\n    /* Una función recursiva que construye el árbol de segmentos para \n       la matriz [ss..se]. si es el índice del nodo actual en el \n       árbol de segmentos st. */\n    static void constructSTUtil(int arr[], int ss, int se, int si) {\n        // fuera de rango ya que ss nunca puede ser mayor que se\n        if (ss > se) {\n            return;\n        }\n        /* Si hay un elemento en la matriz, guárdelo en\n        nodo actual del árbol de segmentos y retorno */\n        if (ss == se) {\n            tree[si] = arr[ss];\n            return;\n        }\n\n        /* Si hay más de un elemento, repita para los \n        subárboles izquierdo y derecho y almacene la \n        suma de valores en este nodo */\n        int mid = (ss + se) / 2;\n        constructSTUtil(arr, ss, mid, si * 2 + 1);\n        constructSTUtil(arr, mid + 1, se, si * 2 + 2);\n\n        tree[si] = tree[si * 2 + 1] + tree[si * 2 + 2];\n    }\n\n    /* Función para construir un árbol de segmentos a partir de una matriz \n    dada. Esta función asigna memoria para el árbol de segmentos \n    y llama a constructSTUtil () para llenar la memoria asignada */\n    static void constructST(int arr[], int n) {\n        // Llenar la memoria asignada st\n        constructSTUtil(arr, 0, n - 1, 0);\n    }\n\n    public static void main(String args[]) {\n        int arr[] = {1, 3, 5, 7, 9, 11};\n        int n = arr.length;\n\n        // Construir un árbol de segmentos a partir de una matriz dada\n        constructST(arr, n);\n\n        // Imprimir la suma de valores en la matriz desde el índice 1 al 3\n        System.out.println(\"Sum of values in given range = \"\n                + getSum(n, 1, 3));\n\n        // Agregue 10 a todos los nodos en los índices del 1 al 5.\n        updateRange(n, 1, 5, 10);\n\n        // Encontrar la suma después de actualizar el valor\n        System.out.println(\"Updated sum of values in given range = \"\n                + getSum(n, 1, 3));\n    }\n}\n",
    "cpp": "#include <stdio.h> \n#include <math.h> \n#define MAX 1000 \n\nint tree[MAX] = {0};\nint lazy[MAX] = {0};\n\nvoid updateRangeUtil(int si, int ss, int se, int us,\n        int ue, int diff) {\n\n    if (lazy[si] != 0) {\n        tree[si] += (se - ss + 1) * lazy[si];\n        if (ss != se) {\n            lazy[si * 2 + 1] += lazy[si];\n            lazy[si * 2 + 2] += lazy[si];\n        }\n        lazy[si] = 0;\n    }\n\n    if (ss > se || ss > ue || se < us)\n        return;\n\n    if (ss >= us && se <= ue) {\n        tree[si] += (se - ss + 1) * diff;\n        if (ss != se) {\n            lazy[si * 2 + 1] += diff;\n            lazy[si * 2 + 2] += diff;\n        }\n        return;\n    }\n\n    int mid = (ss + se) / 2;\n    updateRangeUtil(si * 2 + 1, ss, mid, us, ue, diff);\n    updateRangeUtil(si * 2 + 2, mid + 1, se, us, ue, diff);\n    tree[si] = tree[si * 2 + 1] + tree[si * 2 + 2];\n}\n\nvoid updateRange(int n, int us, int ue, int diff) {\n    updateRangeUtil(0, 0, n - 1, us, ue, diff);\n}\n\nint getSumUtil(int ss, int se, int qs, int qe, int si) {\n\n    if (lazy[si] != 0) {\n        tree[si] += (se - ss + 1) * lazy[si];\n        if (ss != se) {\n            lazy[si * 2 + 1] += lazy[si];\n            lazy[si * 2 + 2] += lazy[si];\n        }\n        lazy[si] = 0;\n    }\n\n    if (ss > se || ss > qe || se < qs)\n        return 0;\n\n    if (ss >= qs && se <= qe)\n        return tree[si];\n\n    int mid = (ss + se) / 2;\n    return getSumUtil(ss, mid, qs, qe, 2 * si + 1) +\n            getSumUtil(mid + 1, se, qs, qe, 2 * si + 2);\n}\n\nint getSum(int n, int qs, int qe) {\n\n    if (qs < 0 || qe > n - 1 || qs > qe) {\n        printf(\"Invalid Input\");\n        return -1;\n    }\n\n    return getSumUtil(0, n - 1, qs, qe, 0);\n}\n\nvoid constructSTUtil(int arr[], int ss, int se, int si) {\n    if (ss > se)\n        return;\n    if (ss == se) {\n        tree[si] = arr[ss];\n        return;\n    }\n    int mid = (ss + se) / 2;\n    constructSTUtil(arr, ss, mid, si * 2 + 1);\n    constructSTUtil(arr, mid + 1, se, si * 2 + 2);\n\n    tree[si] = tree[si * 2 + 1] + tree[si * 2 + 2];\n}\n\nvoid constructST(int arr[], int n) {\n    constructSTUtil(arr, 0, n - 1, 0);\n}\n\nint main() {\n    int arr[] = {1, 3, 5, 7, 9, 11};\n    int n = sizeof (arr) / sizeof (arr[0]);\n    constructST(arr, n);\n    printf(\"Sum of values in given range = %d\\n\",\n            getSum(n, 1, 3));\n    updateRange(n, 1, 5, 10);\n    printf(\"Updated sum of values in given range = %d\\n\",\n            getSum(n, 1, 3));\n\n    return 0;\n}\n",
    "py": "MAX = 1000\ntree = [0] * MAX; \nlazy = [0] * MAX;\n\n\ndef updateRangeUtil(si, ss, se, us, ue, diff):  \n    if (lazy[si] != 0): \n        tree[si] += (se - ss + 1) * lazy[si]; \n        if (ss != se): \n            lazy[si * 2 + 1] += lazy[si]; \n            lazy[si * 2 + 2] += lazy[si]; \n        lazy[si] = 0; \n    if (ss > se or ss > ue or se < us): \n        return; \n    if (ss >= us and se <= ue): \n        tree[si] += (se - ss + 1) * diff; \n        if (ss != se): \n            lazy[si * 2 + 1] += diff; \n            lazy[si * 2 + 2] += diff; \n        return; \n    mid = (ss + se) // 2; \n    updateRangeUtil(si * 2 + 1, ss, \n                    mid, us, ue, diff); \n    updateRangeUtil(si * 2 + 2, mid + 1, \n                    se, us, ue, diff); \n    tree[si] = tree[si * 2 + 1] + \\ tree[si * 2 + 2]; \n\ndef updateRange(n, us, ue, diff): \n    updateRangeUtil(0, 0, n - 1, us, ue, diff); \n\ndef getSumUtil(ss, se, qs, qe, si): \n    if (lazy[si] != 0): \n        tree[si] += (se - ss + 1) * lazy[si]; \n        if (ss != se): \n            lazy[si * 2 + 1] += lazy[si]; \n            lazy[si * 2 + 2] += lazy[si]; \n        lazy[si] = 0; \n    if (ss > se or ss > qe or se < qs): \n        return 0; \n    if (ss >= qs and se <= qe): \n        return tree[si]; \n    mid = (ss + se) // 2; \n    return (getSumUtil(ss, mid, qs, qe, 2 * si + 1) +\n            getSumUtil(mid + 1, se, qs, qe, 2 * si + 2)); \ndef getSum(n, qs, qe): \n    if (qs < 0 or qe > n - 1 or qs > qe): \n        print(\"Invalid Input\"); \n        return -1; \n\n    return getSumUtil(0, n - 1, qs, qe, 0); \n\ndef constructSTUtil(arr, ss, se, si): \n    if (ss > se): \n        return; \n    if (ss == se): \n        \n        tree[si] = arr[ss]; \n        return; \n    mid = (ss + se) // 2; \n    constructSTUtil(arr, ss, mid, si * 2 + 1); \n    constructSTUtil(arr, mid + 1, se, si * 2 + 2); \n\n    tree[si] = tree[si * 2 + 1] + tree[si * 2 + 2]; \n\ndef constructST(arr, n): \n    constructSTUtil(arr, 0, n - 1, 0); \n\narr = [1, 3, 5, 7, 9, 11]; \nn = len(arr); \nconstructST(arr, n); \nprint(\"Sum of values in given range =\", getSum(n, 1, 3)); \nupdateRange(n, 1, 5, 10); \nprint(\"Updated sum of values in given range =\", getSum(n, 1, 3)); \n",
    "orden": 8,
    "suborden": 42,
    "fecha_creacion": "2020-12-06 19:51:48",
    "fecha_modificacion": "2022-03-08 12:28:52"
  },
  {
    "ID": 239,
    "supergrupo": "Grafos",
    "tema": "Componentes biconectados ",
    "texto": "Un componente biconectado es un subgrafo biconectado máximo.\nUn grafo no dirigido se llama Biconnectado si hay dos rutas de vértice disjunto entre dos vértices cualesquiera. En un gráfico biconectado, hay un ciclo simple a través de dos vértices cualesquiera.\nPor convención, dos nodos conectados por una arista forman un gráfico biconectado, pero esto no verifica las propiedades anteriores. Para un gráfico con más de dos vértices, las propiedades anteriores deben estar ahí para que esté Biconectado.\nO en otras palabras:\nSe dice que un gráfico está biconectado si:\n1) Está conectado, es decir, es posible llegar a cada vértice desde cualquier otro vértice, por un camino simple.\n2) Incluso después de eliminar cualquier vértice, el gráfico permanece conectado.\nA continuación se muestran algunos ejemplos. \n\nUn gráfico conectado está Biconectado si está conectado y no tiene ningún punto de articulación. Principalmente necesitamos verificar dos cosas en un gráfico.\n1) El gráfico está conectado.\n2) No hay punto de articulación en el gráfico.\nPartimos de cualquier vértice y hacemos un recorrido DFS. En el recorrido DFS, comprobamos si hay algún punto de articulación. Si no encontramos ningún punto de articulación, entonces el gráfico está Biconectado. Finalmente, debemos verificar si todos los vértices fueron accesibles en DFS o no. Si no todos los vértices fueran accesibles, entonces el gráfico ni siquiera está conectado.\n \nEl algoritmo se basa en el disco y los valores bajos que se describen en el artículo Componentes fuertemente conectados.\n\nLa idea es almacenar las aristas visitadas en una pila mientras DFS en un gráfico y seguir buscando puntos de articulación (resaltados en la figura anterior). Tan pronto como se encuentre un punto de articulación u, todos las aristas visitadas mientras DFS desde el nodo u en adelante formarán un componente biconectado. Cuando DFS se completa para un componente conectado, todas las aristas presentes en la pila formarán un componente biconectado.\nSi no hay un punto de articulación en el gráfico, entonces el gráfico está biconectado y, por lo tanto, habrá un componente biconectado que es el gráfico en sí.\n",
    "complejidad_tiempo": null,
    "java": "// Un programa Java para encontrar componentes biconectados \n// en un gráfico no dirigido dado\n\nimport java.util.*;\n\npublic class BiconnectedComponents {\n\n    // Esta clase representa un gráfico dirigido utilizando \n    // la representación de lista de adyacencia.\n    static class Graph {\n\n        private int V, E; // No. de vértices y aristas respectivamente\n        private LinkedList<Integer> adj[]; // Lista de adyacencia\n        // El recuento es el número de componentes biconectados. \n        // el tiempo se usa para encontrar tiempos de descubrimiento\n        static int count = 0, time = 0;\n\n        class Edge {\n\n            int u;\n            int v;\n\n            Edge(int u, int v) {\n                this.u = u;\n                this.v = v;\n            }\n        };\n\n        Graph(int v) {\n            V = v;\n            E = 0;\n            adj = new LinkedList[v];\n            for (int i = 0; i < v; ++i) {\n                adj[i] = new LinkedList();\n            }\n        }\n\n        // Función para agregar una arista al gráfico\n        void addEdge(int v, int w) {\n            adj[v].add(w);\n            E++;\n        }\n\n        // Una función recursiva que encuentra e imprime fuertemente conectados\n        // componentes que utilizan DFS transversal\n        // u -> El vértice a visitar a continuación\n        // disc[] -> Almacena los tiempos de descubrimiento de los vértices visitados\n        // low[] - >> vértice visitado más temprano (el vértice con mínimo\n        // tiempo de descubrimiento) que se puede alcanzar desde el subárbol\n        // arraigado con el vértice actual\n        // * st - >> Para almacenar los bordes visitados\n        void BCCUtil(int u, int disc[], int low[], LinkedList<Edge> st,\n                int parent[]) {\n\n            // Inicializar el tiempo de descubrimiento y el valor bajo\n            disc[u] = low[u] = ++time;\n            int children = 0;\n\n            // Pasa por todos los vértices adyacentes a este\n            Iterator<Integer> it = adj[u].iterator();\n            while (it.hasNext()) {\n                int v = it.next(); // v es actual adyacente a 'u'\n\n                // Si aún no se ha visitado v, recurra para el\n                if (disc[v] == -1) {\n                    children++;\n                    parent[v] = u;\n                    // almacenar el borde en la pila\n                    st.add(new Edge(u, v));\n                    BCCUtil(v, disc, low, st, parent);\n                    // Compruebe si el subárbol arraigado con 'v' tiene \n                    // una conexión con uno de los antepasados de 'u'\n                    // Caso 1: según el artículo sobre componentes \n                    //fuertemente conectados\n                    if (low[u] > low[v]) {\n                        low[u] = low[v];\n                    }\n\n                    // Si u es un punto de articulación, \n                    // saque todos los bordes de la pila hasta u - v\n                    if ((disc[u] == 1 && children > 1)\n                            || (disc[u] > 1 && low[v] >= disc[u])) {\n                        while (st.getLast().u != u\n                                || st.getLast().v != v) {\n                            System.out.print(st.getLast().u\n                                    + \"--\" + st.getLast().v + \" \");\n                            st.removeLast();\n                        }\n                        System.out.println(st.getLast().u + \"--\"\n                                + st.getLast().v + \" \");\n                        st.removeLast();\n\n                        count++;\n                    }\n                } // Actualice el valor bajo de 'u' solo si 'v' todavía \n                // está en la pila\n                // (es decir, es un borde posterior, no un borde transversal).\n                // Caso 2: según el artículo sobre componentes\n                // fuertemente conectados\n                else if (v != parent[u] && disc[v] < disc[u]) {\n                    if (low[u] > disc[v]) {\n                        low[u] = disc[v];\n                    }\n\n                    st.add(new Edge(u, v));\n                }\n            }\n        }\n\n        // La función para hacer un recorrido DFS. Utiliza BCCUtil ()\n        void BCC() {\n            int disc[] = new int[V];\n            int low[] = new int[V];\n            int parent[] = new int[V];\n            LinkedList<Edge> st = new LinkedList<Edge>();\n\n            // Inicializar matrices de discos y matrices bajas y principales\n            for (int i = 0; i < V; i++) {\n                disc[i] = -1;\n                low[i] = -1;\n                parent[i] = -1;\n            }\n\n            for (int i = 0; i < V; i++) {\n                if (disc[i] == -1) {\n                    BCCUtil(i, disc, low, st, parent);\n                }\n                int j = 0;\n                // Si la pila no está vacía, saque todos los bordes de la pila\n                while (st.size() > 0) {\n                    j = 1;\n                    System.out.print(st.getLast().u + \"--\"\n                            + st.getLast().v + \" \");\n                    st.removeLast();\n                }\n                if (j == 1) {\n                    System.out.println();\n                    count++;\n                }\n            }\n        }\n    }\n\n    public static void main(String args[]) {\n        Graph g = new Graph(12);\n        g.addEdge(0, 1);\n        g.addEdge(1, 0);\n        g.addEdge(1, 2);\n        g.addEdge(2, 1);\n        g.addEdge(1, 3);\n        g.addEdge(3, 1);\n        g.addEdge(2, 3);\n        g.addEdge(3, 2);\n        g.addEdge(2, 4);\n        g.addEdge(4, 2);\n        g.addEdge(3, 4);\n        g.addEdge(4, 3);\n        g.addEdge(1, 5);\n        g.addEdge(5, 1);\n        g.addEdge(0, 6);\n        g.addEdge(6, 0);\n        g.addEdge(5, 6);\n        g.addEdge(6, 5);\n        g.addEdge(5, 7);\n        g.addEdge(7, 5);\n        g.addEdge(5, 8);\n        g.addEdge(8, 5);\n        g.addEdge(7, 8);\n        g.addEdge(8, 7);\n        g.addEdge(8, 9);\n        g.addEdge(9, 8);\n        g.addEdge(10, 11);\n        g.addEdge(11, 10);\n        g.BCC();\n        System.out.println(\"Above are \" + g.count + \" biconnected components in graph\");\n    }\n}\n",
    "cpp": "#include <iostream> \n#include <list> \n#include <stack> \n#define NIL -1 \nusing namespace std;\nint count = 0;\n\nclass Edge {\npublic:\n    int u;\n    int v;\n    Edge(int u, int v);\n};\n\nEdge::Edge(int u, int v) {\n    this->u = u;\n    this->v = v;\n}\n\nclass Graph {\n    int V;\n    int E;\n    list<int>* adj;\n    void BCCUtil(int u, int disc[], int low[],\n            list<Edge>* st, int parent[]);\n\npublic:\n    Graph(int V);\n    void addEdge(int v, int w);\n    void BCC();\n};\n\nGraph::Graph(int V) {\n    this->V = V;\n    this->E = 0;\n    adj = new list<int>[V];\n}\n\nvoid Graph::addEdge(int v, int w) {\n    adj[v].push_back(w);\n    E++;\n}\n\nvoid Graph::BCCUtil(int u, int disc[], int low[], list<Edge>* st,\n        int parent[]) {\n    static int time = 0;\n    disc[u] = low[u] = ++time;\n    int children = 0;\n    list<int>::iterator i;\n    for (i = adj[u].begin(); i != adj[u].end(); ++i) {\n        int v = *i;\n        if (disc[v] == -1) {\n            children++;\n            parent[v] = u;\n            st->push_back(Edge(u, v));\n            BCCUtil(v, disc, low, st, parent);\n            low[u] = min(low[u], low[v]);\n            if ((disc[u] == 1 && children > 1) || (disc[u] > 1 && low[v] >= disc[u])) {\n                while (st->back().u != u || st->back().v != v) {\n                    cout << st->back().u << \"--\" << st->back().v << \" \";\n                    st->pop_back();\n                }\n                cout << st->back().u << \"--\" << st->back().v;\n                st->pop_back();\n                cout << endl;\n                count++;\n            }\n        } else if (v != parent[u]) {\n            low[u] = min(low[u], disc[v]);\n            if (disc[v] < disc[u]) {\n                st->push_back(Edge(u, v));\n            }\n        }\n    }\n}\n\nvoid Graph::BCC() {\n    int* disc = new int[V];\n    int* low = new int[V];\n    int* parent = new int[V];\n    list<Edge>* st = new list<Edge>[E];\n    for (int i = 0; i < V; i++) {\n        disc[i] = NIL;\n        low[i] = NIL;\n        parent[i] = NIL;\n    }\n\n    for (int i = 0; i < V; i++) {\n        if (disc[i] == NIL)\n            BCCUtil(i, disc, low, st, parent);\n\n        int j = 0;\n        while (st->size() > 0) {\n            j = 1;\n            cout << st->back().u << \"--\" << st->back().v << \" \";\n            st->pop_back();\n        }\n        if (j == 1) {\n            cout << endl;\n            count++;\n        }\n    }\n}\n\nint main() {\n    Graph g(12);\n    g.addEdge(0, 1);\n    g.addEdge(1, 0);\n    g.addEdge(1, 2);\n    g.addEdge(2, 1);\n    g.addEdge(1, 3);\n    g.addEdge(3, 1);\n    g.addEdge(2, 3);\n    g.addEdge(3, 2);\n    g.addEdge(2, 4);\n    g.addEdge(4, 2);\n    g.addEdge(3, 4);\n    g.addEdge(4, 3);\n    g.addEdge(1, 5);\n    g.addEdge(5, 1);\n    g.addEdge(0, 6);\n    g.addEdge(6, 0);\n    g.addEdge(5, 6);\n    g.addEdge(6, 5);\n    g.addEdge(5, 7);\n    g.addEdge(7, 5);\n    g.addEdge(5, 8);\n    g.addEdge(8, 5);\n    g.addEdge(7, 8);\n    g.addEdge(8, 7);\n    g.addEdge(8, 9);\n    g.addEdge(9, 8);\n    g.addEdge(10, 11);\n    g.addEdge(11, 10);\n    g.BCC();\n    cout << \"Above are \" << count << \" biconnected components in graph\";\n    return 0;\n}\n",
    "py": "from collections import defaultdict\n \nclass Graph: \n\n    def __init__(self, vertices): \n        self.V = vertices \n        self.graph = defaultdict(list) \n        self.Time = 0\n        self.count = 0\n\n    def addEdge(self, u, v): \n        self.graph[u].append(v) \n        self.graph[v].append(u) \n\n    def BCCUtil(self, u, parent, low, disc, st): \n        children = 0\n        disc[u] = self.Time \n        low[u] = self.Time \n        self.Time += 1\n        for v in self.graph[u]: \n            if disc[v] == -1: \n                parent[v] = u \n                children += 1\n                st.append((u, v)) \n                self.BCCUtil(v, parent, low, disc, st) \n                low[u] = min(low[u], low[v]) \n                if parent[u] == -1 and children > 1 or parent[u] != -1 and low[v] >= disc[u]: \n                    self.count += 1 \n                    w = -1\n                    while w != (u, v): \n                        w = st.pop() \n                        print w, \n                    print\"\" \n                        \n            elif v != parent[u] and low[u] > disc[v]: \n                low[u] = min(low [u], disc[v]) \n                st.append((u, v)) \n\n    def BCC(self): \n        disc = [-1] * (self.V) \n        low = [-1] * (self.V) \n        parent = [-1] * (self.V) \n        st = [] \n        for i in range(self.V): \n            if disc[i] == -1: \n                self.BCCUtil(i, parent, low, disc, st) \n            if st: \n                self.count = self.count + 1\n                while st: \n                    w = st.pop() \n                    print w, \n                print \"\" \n\ng = Graph(12) \ng.addEdge(0, 1) \ng.addEdge(1, 2) \ng.addEdge(1, 3) \ng.addEdge(2, 3) \ng.addEdge(2, 4) \ng.addEdge(3, 4) \ng.addEdge(1, 5) \ng.addEdge(0, 6) \ng.addEdge(5, 6) \ng.addEdge(5, 7) \ng.addEdge(5, 8) \ng.addEdge(7, 8) \ng.addEdge(8, 9) \ng.addEdge(10, 11) \n\ng.BCC(); \nprint (\"Above are % d biconnected components in graph\" % (g.count)); \n\n",
    "orden": 8,
    "suborden": 43,
    "fecha_creacion": "2020-12-06 19:51:48",
    "fecha_modificacion": "2022-03-08 14:36:15"
  },
  {
    "ID": 240,
    "supergrupo": "Estructuras",
    "tema": "Vector circular",
    "texto": "Range Minimum Query (RMQ)",
    "complejidad_tiempo": null,
    "java": "// Programa Java para demostrar el uso de una array circular utilizando \n// espacio de memoria adicional\n\npublic class CircularArray {\n\n    // función para imprimir una lista circular a partir del índice ind.\n    public static void print(char a[], int n,\n            int ind) {\n        // imprimir desde el índice ind-ésimo hasta el índice (n + i) ésimo.\n        for (int i = ind; i < n + ind; i++) {\n            System.out.print(a[(i % n)] + \" \");\n        }\n    }\n\n    public static void main(String argc[]) {\n        char[] a = new char[]{'A', 'B', 'C',\n            'D', 'E', 'F'};\n        int n = 6;\n        print(a, n, 3);\n    }\n}\n",
    "cpp": "#include <bits/stdc++.h> \nusing namespace std;\n\nvoid print(char a[], int n, int ind) {\n\n    for (int i = ind; i < n + ind; i++)\n        cout << a[(i % n)] << \" \";\n}\n\nint main() {\n    char a[] = {'A', 'B', 'C', 'D', 'E', 'F'};\n    int n = sizeof (a) / sizeof (a[0]);\n    print(a, n, 3);\n    return 0;\n}\n",
    "py": "def prints(a, n, ind): \n        i = ind \n        while i < n + ind : \n                print(a[(i % n)], end = \" \") \n                i = i + 1\na = ['A', 'B', 'C', 'D', 'E', 'F'] \nn = len(a); \nprints(a, n, 3); \n",
    "orden": 1,
    "suborden": 1,
    "fecha_creacion": "2020-12-06 19:51:49",
    "fecha_modificacion": "2022-03-08 14:26:59"
  },
  {
    "ID": 241,
    "supergrupo": "Estructuras",
    "tema": "Árbol de Fenwick",
    "texto": "Consideremos el siguiente problema para entender el árbol indexado binario.\nTenemos una matriz arr [0. . . n-1]. Nos gustaría\n1 Calcule la suma de los primeros i elementos.\n2 Modifique el valor de un elemento especificado de la matriz arr [i] = x donde 0 <= i <= n-1.\nUna solución simple es ejecutar un ciclo de 0 a i-1 y calcular la suma de los elementos. Para actualizar un valor, simplemente haga arr [i] = x. La primera operación toma O (n) tiempo y la segunda operación toma O (1) tiempo. Otra solución simple es crear una matriz adicional y almacenar la suma de los primeros elementos i-ésimo en el índice i-ésimo en esta nueva matriz. La suma de un rango dado ahora se puede calcular en O (1) tiempo, pero la operación de actualización toma O (n) tiempo ahora. Esto funciona bien si hay una gran cantidad de operaciones de consulta pero muy pocas operaciones de actualización.\n¿Podríamos realizar las operaciones de consulta y actualización en tiempo O (log n)?\nUna solución eficaz es utilizar Segment Tree que realiza ambas operaciones en tiempo O (Logn).\nUna solución alternativa es Binary Indexed Tree, que también logra una complejidad de tiempo O (Logn) para ambas operaciones. En comparación con el árbol de segmentos, el árbol indexado binario requiere menos espacio y es más fácil de implementar.\n\nRepresentación\nEl árbol indexado binario se representa como una matriz. Deje que la matriz sea BITree []. Cada nodo del árbol indexado binario almacena la suma de algunos elementos de la matriz de entrada. El tamaño del árbol indexado binario es igual al tamaño de la matriz de entrada, denotado como n. En el siguiente código, usamos un tamaño de n + 1 para facilitar la implementación.\nConstrucción\nInicializamos todos los valores en BITree [] como 0. Luego llamamos update () para todos los índices, la operación update () se analiza a continuación.\nOperaciones\ngetSum (x): Devuelve la suma de la submatriz arr [0,…, x]\n// Devuelve la suma del subarreglo arr [0,…, x] usando BITree [0..n], que se construye a partir de arr [0..n-1]\n1) Inicialice la suma de salida como 0, el índice actual como x + 1.\n2) Haga lo siguiente mientras el índice actual sea mayor que 0.\n… A) Agregue BITree [índice] a la suma\n… B) Vaya al padre de BITree [índice]. El padre se puede obtener eliminando\nel último bit establecido del índice actual, es decir, index = index - (index & (-index))\n3) Devolución de la suma.\n\nEl diagrama anterior proporciona un ejemplo de cómo funciona getSum (). Aquí hay algunas observaciones importantes.\nBITree [0] es un nodo ficticio.\nBITree [y] es el padre de BITree [x], si y solo si se puede obtener y eliminando el último bit establecido de la representación binaria de x, es decir y = x - (x & (-x)).\nEl nodo hijo BITree [x] del nodo BITree [y] almacena la suma de los elementos entre y (inclusive) yx (exclusivo): arr [y,…, x).\n\nupdate (x, val): actualiza el árbol indexado binario (BIT) realizando arr [index] + = val\n// Tenga en cuenta que la operación de actualización (x, val) no cambiará arr []. Solo realiza cambios en BITree []\n1) Inicialice el índice actual como x + 1.\n2) Haga lo siguiente mientras el índice actual sea menor o igual que n.\n… A) Agregue el valor a BITree [índice]\n… B) Vaya al padre de BITree [índice]. El padre se puede obtener incrementando el último bit establecido del índice actual, es decir, índice = índice + (índice & (-índice))\n \nLa función de actualización necesita asegurarse de que se actualicen todos los nodos BITree que contienen arr [i] dentro de sus rangos. Pasamos por encima de dichos nodos en BITree agregando repetidamente el número decimal correspondiente al último bit establecido del índice actual.\n\n¿Cómo funciona el árbol indexado binario?\nLa idea se basa en el hecho de que todos los enteros positivos se pueden representar como la suma de potencias de 2. Por ejemplo, 19 se puede representar como 16 + 2 + 1. Cada nodo del BITree almacena la suma de n elementos donde n es un potencia de 2. Por ejemplo, en el primer diagrama anterior (el diagrama para getSum ()), la suma de los primeros 12 elementos se puede obtener mediante la suma de los últimos 4 elementos (de 9 a 12) más la suma de 8 elementos (de 1 a 8). El número de bits establecidos en la representación binaria de un número n es O (Logn). Por lo tanto, recorremos como máximo los nodos O (Logn) en las operaciones getSum () y update (). La complejidad temporal de la construcción es O (nLogn), ya que llama a update () para todos los n elementos.\n",
    "complejidad_tiempo": null,
    "java": "//Estructura de datos que permite procesar \n//consultas por rangos y actualizaciones \n//individuales sobre un arreglo.\n\npublic class FenwickTree {\n\n    // Tamaño máximo del árbol\n    final static int MAX = 1000;\n    static int BITree[] = new int[MAX];\n\n    /* n -> No. de elementos presentes en el array de entrada.\n        BITree [0..n] -> array que representa el árbol indexado binario.\n        arr [0..n-1] -> array de entrada para la que se evalúa la suma \n        de prefijo. */\n    // Devuelve la suma de arr [0..index]. Esta función asume que el array está \n    // preprocesado y las sumas parciales de los elementos del array \n    // se almacenan en BITree [].\n    static int getSum(int index) {\n        int sum = 0; // Inicializar resultado\n        // el índice en BITree [] es 1 más que el índice en arr []\n        index = index + 1;\n        // Antepasados transversales de BITree [índice]\n        while (index > 0) {\n            // Agregar el elemento actual de BITree a la suma\n            sum += BITree[index];\n            // Mover el índice al nodo principal en la vista getSum\n            index -= index & (-index);\n        }\n        return sum;\n    }\n\n    // Actualiza un nodo en Binary Index Tree (BITree) en un índice \n    // dado en BITree. El valor dado 'val' se agrega a BITree [i] y \n    // todos sus ancestros en tree. \n    public static void updateBIT(int n, int index,\n            int val) {\n        // el índice en BITree [] es 1 más que el índice en arr []\n        index = index + 1;\n        // Atraviesa a todos los antepasados y agrega 'val'\n        while (index <= n) {\n            // Agregue 'val' al nodo actual del árbol\n            BITree[index] += val;\n            // Actualizar el índice al del padre en la vista de actualización\n            index += index & (-index);\n        }\n    }\n\n    /* Función para construir el árbol de fenwick a partir de un array dada.*/\n    static void constructBITree(int arr[], int n) {\n        // Inicializar BITree [] como 0\n        for (int i = 1; i <= n; i++) {\n            BITree[i] = 0;\n        }\n        // Almacene el valor actual en BITree [] usando update ()\n        for (int i = 0; i < n; i++) {\n            updateBIT(n, i, arr[i]);\n        }\n    }\n\n    public static void main(String args[]) {\n        int freq[] = {2, 1, 1, 3, 2, 3,\n            4, 5, 6, 7, 8, 9};\n        int n = freq.length;\n        // Construye el árbol fenwick a partir de una matriz dada\n        constructBITree(freq, n);\n        System.out.println(\"Sum of elements in arr[0..5]\"\n                + \" is \" + getSum(5));\n        freq[3] += 6;\n        // Actualizar BIT para el cambio anterior en arr []\n        updateBIT(n, 3, 6);\n        // Encontrar la suma después de actualizar el valor\n        System.out.println(\"Sum of elements in arr[0..5]\"\n                + \" after update is \" + getSum(5));\n    }\n}\n",
    "cpp": "#include <bits/stdc++.h> \n#include <cstdlib>\nusing namespace std;\nconst int MAX = 1000;\nint BITree[MAX];\n\nint getSum(int index) {\n    int sum = 0;\n    index = index + 1;\n    while (index > 0) {\n        sum += BITree[index];\n        index -= index & (-index);\n    }\n    return sum;\n}\n\nvoid updateBIT(int n, int index, int val) {\n    index = index + 1;\n    while (index <= n) {\n        BITree[index] += val;\n        index += index & (-index);\n    }\n}\n\nvoid constructBITree(int arr[], int n) {\n    for (int i = 1; i <= n; i++) {\n        BITree[i] = 0;\n    }\n    for (int i = 0; i < n; i++) {\n        updateBIT(n, i, arr[i]);\n    }\n}\n\nint main() {\n    int freq[] = {2, 1, 1, 3, 2, 3, 4, 5, 6, 7, 8, 9};\n    int n = sizeof (freq) / sizeof (freq[0]);\n    constructBITree(freq, n);\n    cout << \"Sum of elements in arr[0..5] is \" << getSum(5) << endl;\n    freq[3] += 6;\n    updateBIT(n, 3, 6);\n    cout << \"Sum of elements in arr[0..5] after update is \" << getSum(5)\n            << endl;\n}\n\n",
    "py": "BITree = [0 for x in range (1000)]\ndef getSum(index):\n    sum = 0\n    index = index + 1\n    while (index > 0):\n        sum += BITree[index]\n        index -= index & (-index)\n    return sum\n\ndef updateBIT(n, index, val):\n    index = index + 1\n    while (index <= n):\n        BITree[index] += val\n        index += index & (-index)\n\ndef constructBITree(arr, n):\n    for i in range (1, n + 1):\n        BITree[i] = 0\n    for i in range (n):\n        updateBIT(n, i, arr[i])\n\nfreq = [2, 1, 1, 3, 2, 3, 4, 5, 6, 7, 8, 9]\nn = len(freq)\nconstructBITree(freq, n);\nprint(\"Sum of elements in arr[0..5] is \" + str(getSum(5)))\nfreq[3] += 6\nupdateBIT(n, 3, 6);\nprint(\"Sum of elements in arr[0..5] after update is \" + str(getSum(5)))\n",
    "orden": 1,
    "suborden": 2,
    "fecha_creacion": "2020-12-06 19:51:49",
    "fecha_modificacion": "2022-03-08 14:26:59"
  },
  {
    "ID": 242,
    "supergrupo": "Estructuras",
    "tema": "Range Minimum Query (RMQ)",
    "texto": "Consideremos el siguiente problema para comprender los árboles de segmentos.\nTenemos una matriz arr [0. . . n-1]. Deberíamos poder\n1 Encuentre la suma de los elementos del índice la r donde 0 <= l <= r <= n-1\n2 Cambie el valor de un elemento especificado de la matriz a un nuevo valor x. Necesitamos hacer arr [i] = x donde 0 <= i <= n-1.\n\nUna solución simple es ejecutar un ciclo de la ry calcular la suma de elementos en el rango dado. Para actualizar un valor, simplemente haga arr [i] = x. La primera operación toma O (n) tiempo y la segunda operación toma O (1) tiempo.\nOtra solución es crear otra matriz y almacenar la suma desde el principio hasta la i en el índice i en esta matriz. La suma de un rango dado ahora se puede calcular en O (1) tiempo, pero la operación de actualización toma O (n) tiempo ahora. Esto funciona bien si el número de operaciones de consulta es grande y muy pocas actualizaciones.\n\n¿Qué pasa si el número de consultas y actualizaciones es igual? ¿Podemos realizar ambas operaciones en tiempo O (log n) una vez dada la matriz? Podemos usar un árbol de segmentos para realizar ambas operaciones en tiempo O (Logn).\nRepresentación de árboles de segmentos\n1. Los nodos hoja son los elementos de la matriz de entrada.\n2. Cada nodo interno representa alguna fusión de los nodos hoja. La combinación puede ser diferente para diferentes problemas. Para este problema, la fusión es la suma de hojas debajo de un nodo.\n \n¿Cómo se ve el árbol de segmentos anterior en la memoria?\nAl igual que Heap, el árbol de segmentos también se representa como una matriz. La diferencia aquí es que no es un árbol binario completo. Es más bien un árbol binario completo (cada nodo tiene 0 o 2 hijos) y todos los niveles están llenos excepto posiblemente el último nivel. A diferencia de Heap, el último nivel puede tener espacios entre los nodos. A continuación se muestran los valores en la matriz de árbol de segmentos para el diagrama anterior.\n\nA continuación se muestra la representación en memoria del árbol de segmentos para la matriz de entrada {1, 3, 5, 7, 9, 11}\n\nst [] = {36, 9, 27, 4, 5, 16, 11, 1, 3, DUMMY, DUMMY, 7, 9, DUMMY, DUMMY}\n\nLos valores ficticios nunca se acceden y no tienen uso. Este es un desperdicio de espacio debido a la simple representación de una matriz. Podemos optimizar este desperdicio usando algunas implementaciones inteligentes, pero el código para suma y actualización se vuelve más complejo.\nConstrucción del árbol de segmentos a partir de una matriz dada\nComenzamos con un segmento arr [0. . . n-1]. y cada vez que dividimos el segmento actual en dos mitades (si aún no se ha convertido en un segmento de longitud 1), y luego llamamos al mismo procedimiento en ambas mitades, y para cada segmento, almacenamos la suma en el nodo correspondiente.\nTodos los niveles del árbol de segmentos construido se llenarán por completo excepto el último nivel. Además, el árbol será un árbol binario completo porque siempre dividimos los segmentos en dos mitades en cada nivel. Dado que el árbol construido es siempre un árbol binario completo con n hojas, habrá n-1 nodos internos. Entonces, el número total de nodos será 2 * n - 1. Tenga en cuenta que esto no incluye los nodos ficticios.\n\n¿Cuál es el tamaño total de la matriz que representa el árbol de segmentos?\nSi n es una potencia de 2, entonces no hay nodos ficticios. Entonces, el tamaño del árbol de segmentos es 2n-1 (n nodos hoja y n-1) nodos internos. Si n no es una potencia de 2, entonces el tamaño del árbol será 2 * x - 1 donde x es la potencia más pequeña de 2 mayor que n. Por ejemplo, cuando n = 10, el tamaño de la matriz que representa el árbol de segmentos es 2 * 16-1 = 31.\nUna explicación alternativa para el tamaño se basa en la altura. La altura del árbol de segmentos será  . Dado que el árbol se representa mediante una matriz y la relación entre los índices padre e hijo debe mantenerse, el tamaño de la memoria asignada para el árbol de segmentos será  \n. \nConsulta de la suma del rango dado\nUna vez que se construye el árbol, cómo obtener la suma utilizando el árbol de segmentos construido. El siguiente es el algoritmo para obtener la suma de elementos.\nint getSum (nodo, l, r)\n{\n   si el rango del nodo está dentro de lyr\n        valor de retorno en el nodo\n   de lo contrario, si el rango del nodo está completamente fuera de lyr\n        volver 0\n   más\n    return getSum (hijo izquierdo del nodo, l, r) +\n           getSum (hijo derecho del nodo, l, r)\n}\n\nActualizar un valor\nAl igual que la construcción de árboles y las operaciones de consulta, la actualización también se puede realizar de forma recursiva. Se nos da un índice que debe actualizarse. Sea diff el valor a agregar. Comenzamos desde la raíz del árbol de segmentos y agregamos diff a todos los nodos que han dado índice en su rango. Si un nodo no tiene un índice determinado en su rango, no realizamos ningún cambio en ese nodo.\nImplementación:\nA continuación se muestra la implementación del árbol de segmentos. El programa implementa la construcción de un árbol de segmentos para cualquier arreglo. También implementa operaciones de consulta y actualización.\n\nTenemos una matriz arr [0. . . n-1]. Deberíamos poder encontrar de manera eficiente el valor mínimo desde el índice qs (inicio de la consulta) hasta qe (final de la consulta) donde 0 <= qs <= qe <= n-1.\n\nUna solución simple es ejecutar un ciclo de qs a qe y encontrar el elemento mínimo en un rango dado. Esta solución lleva O (n) tiempo en el peor de los casos.\nOtra solución es crear una matriz 2D donde una entrada [i, j] almacena el valor mínimo en el rango arr [i..j]. Ahora se puede calcular el mínimo de un rango dado en O (1) tiempo, pero el preprocesamiento toma O (n ^ 2) tiempo. Además, este enfoque necesita O (n ^ 2) espacio adicional que puede volverse enorme para matrices de entrada grandes.\n\nEl árbol de segmentos se puede utilizar para realizar preprocesamiento y consultas en un tiempo moderado. Con el árbol de segmentos, el tiempo de preprocesamiento es O (n) y el tiempo para la consulta mínima de rango es O (Logn). El espacio adicional requerido es O (n) para almacenar el árbol de segmentos.\n\nRepresentación de árboles de segmentos\n1. Los nodos hoja son los elementos de la matriz de entrada.\n2. Cada nodo interno representa el mínimo de todas las hojas debajo de él.\n \nConstrucción del árbol de segmentos a partir de una matriz dada\nComenzamos con un segmento arr [0. . . n-1]. y cada vez que dividimos el segmento actual en dos mitades (si aún no se ha convertido en un segmento de longitud 1), y luego llamamos al mismo procedimiento en ambas mitades, y para cada segmento, almacenamos el valor mínimo en un árbol de segmentos nodo.\nTodos los niveles del árbol de segmentos construido se llenarán por completo excepto el último nivel. Además, el árbol será un árbol binario completo porque siempre dividimos los segmentos en dos mitades en cada nivel. Dado que el árbol construido es siempre un árbol binario completo con n hojas, habrá n-1 nodos internos. Entonces, el número total de nodos será 2 * n - 1.\nLa altura del árbol de segmentos será. Dado que el árbol se representa mediante una matriz y la relación entre los índices padre e hijo debe mantenerse, el tamaño de la memoria asignada para el árbol de segmentos será  .\n\nConsultar el valor mínimo del rango dado\nUna vez que se construye el árbol, cómo hacer una consulta de rango mínimo usando el árbol de segmento construido. A continuación se muestra el algoritmo para obtener el mínimo.\n// qs -> índice de inicio de consulta, qe -> índice de fin de consulta\nint RMQ (nodo, qs, qe)\n{\n    si el rango del nodo está dentro de qs y qe\n         valor de retorno en el nodo\n    de lo contrario, si el rango del nodo está completamente fuera de qs y qe\n         volver INFINITO\n    más\n     return min (RMQ (hijo izquierdo del nodo, qs, qe), RMQ (hijo derecho del nodo, qs, qe))\n}",
    "complejidad_tiempo": null,
    "java": "// Programa Java para implementar árbol de segmentos iterativos.\n\npublic class RangeMinimumQuery {\n\n    static void construct_segment_tree(int[] segtree,\n            int[] a, int n) {\n\n        // asignar valores a las hojas del árbol de segmentos\n        for (int i = 0; i < n; i++) {\n            segtree[n + i] = a[i];\n        }\n\n        // asignar valores a los nodos internos para calcular el mínimo en un rango dado\n        for (int i = n - 1; i >= 1; i--) {\n            segtree[i] = Math.min(segtree[2 * i], segtree[2 * i + 1]);\n        }\n    }\n\n    static void update(int[] segtree, int pos, int value, int n) {\n\n        // cambie el índice al nodo hoja primero\n        pos += n;\n        // actualizar el valor en el nodo hoja en el índice exacto\n        segtree[pos] = value;\n        while (pos > 1) {\n            // subir un nivel a la vez en el árbol\n            pos >>= 1;\n            // actualizar los valores en los nodos en el siguiente nivel superior\n            segtree[pos] = Math.min(segtree[2 * pos],\n                    segtree[2 * pos + 1]);\n        }\n    }\n\n    static int range_query(int[] segtree, int left,\n            int right, int n) {\n\n        /* \n        Básicamente, los índices izquierdo y derecho se moverán\n         hacia derecha e izquierda respectivamente y con\n         cada cada siguiente nivel superior y calcular el\n         mínimo en cada altura.\n         */\n        // cambie el índice al nodo hoja primero\n        left += n;\n        right += n;\n        // inicializar mínimo a un valor muy alto\n        int mi = (int) 1e9;\n\n        while (left < right) {\n\n            // si se deja el índice en impar\n            if ((left & 1) == 1) {\n                mi = Math.min(mi, segtree[left]);\n\n                // hacer par índice izquierdo\n                left++;\n            }\n\n            // si el índice correcto es impar\n            if ((right & 1) == 1) {\n\n                // hacer par índice derecho\n                right--;\n\n                mi = Math.min(mi, segtree[right]);\n            }\n\n            // pasar al siguiente nivel superior\n            left /= 2;\n            right /= 2;\n        }\n        return mi;\n    }\n\n    public static void main(String[] args) {\n        int[] a = {2, 6, 10, 4, 7, 28, 9, 11, 6, 33};\n        int n = a.length;\n\n        /*  \n         Construya el árbol de segmentos asignando\n          los valores a los nodos internos\n         */\n        int[] segtree = new int[2 * n];\n        construct_segment_tree(segtree, a, n);\n\n        // calcular el mínimo en el rango de izquierda a derecha\n        int left = 0, right = 5;\n        System.out.printf(\"Minimum in range %d to %d is %d\\n\",\n                left, right, range_query(segtree,\n                        left, right + 1, n));\n\n        // actualizar el valor del índice 3 a 1\n        int index = 3, value = 1;\n\n        // a[3] = 1;  \n        // Contenido del array : {2, 6, 10, 1, 7, 28, 9, 11, 6, 33} \n        update(segtree, index, value, n); // actualización de puntos\n\n        // calcular el mínimo en el rango de izquierda a derecha \n        left = 2;\n        right = 6;\n        System.out.printf(\"Minimum in range %d to %d is %d\\n\",\n                left, right, range_query(segtree,\n                        left, right + 1, n));\n    }\n}\n",
    "cpp": "#include <bits/stdc++.h> \n#define ll long long \n\nusing namespace std;\n\nvoid construct_segment_tree(vector<int>& segtree,\n        vector<int> &a, int n) {\n    for (int i = 0; i < n; i++)\n        segtree[n + i] = a[i];\n    for (int i = n - 1; i >= 1; i--)\n        segtree[i] = min(segtree[2 * i],\n            segtree[2 * i + 1]);\n}\n\nvoid update(vector<int>& segtree, int pos, int value,\n        int n) {\n    pos += n;\n    segtree[pos] = value;\n    while (pos > 1) {\n        pos >>= 1;\n        segtree[pos] = min(segtree[2 * pos],\n                segtree[2 * pos + 1]);\n    }\n}\n\nint range_query(vector<int>& segtree, int left, int\n        right, int n) {\n    left += n;\n    right += n;\n    int mi = (int) 1e9;\n\n    while (left < right) {\n        if (left & 1) {\n            mi = min(mi, segtree[left]);\n            left++;\n        }\n        if (right & 1) {\n            right--;\n            mi = min(mi, segtree[right]);\n        }\n        left /= 2;\n        right /= 2;\n    }\n    return mi;\n}\n\nint main() {\n    vector<int> a = {2, 6, 10, 4, 7, 28, 9, 11, 6, 33};\n    int n = a.size();\n    vector<int> segtree(2 * n);\n    construct_segment_tree(segtree, a, n);\n    int left = 0, right = 5;\n    cout << \"Minimum in range \" << left << \" to \"\n            << right << \" is \" << range_query(segtree, left,\n            right + 1, n) << \"\\n\";\n\n    int index = 3, value = 1;\n    update(segtree, index, value, n);\n    left = 2, right = 6;\n    cout << \"Minimum in range \" << left << \" to \"\n            << right << \" is \" << range_query(segtree,\n            left, right + 1, n) << \"\\n\";\n\n    return 0;\n} \n",
    "py": "def construct_segment_tree(segtree, a, n):  \n    for i in range(n):  \n        segtree[n + i] = a[i];  \n    for i in range(n - 1, 0, -1):  \n        segtree[i] = min(segtree[2 * i], \n                         segtree[2 * i + 1])  \n                          \ndef range_query(segtree, left, right, n): \n    left += n  \n    right += n \n    mi = 1e9 \n    while (left < right): \n        if (left & 1): \n            mi = min(mi, segtree[left]) \n            left = left + 1\n        if (right & 1): \n            right -= 1\n            mi = min(mi, segtree[right]) \n        left = left // 2\n        right = right // 2\n    return mi \n  \ndef update(segtree, pos, value, n): \n    pos += n  \n    segtree[pos] = value  \n    while (pos > 1):  \n        pos >>= 1;  \n        segtree[pos] = min(segtree[2 * pos], \n                           segtree[2 * pos + 1])  \na = [2, 6, 10, 4, 7, 28, 9, 11, 6, 33] \nn = len(a)  \nsegtree = [0 for i in range(2 * n)]  \nconstruct_segment_tree(segtree, a, n); \nleft = 0\nright = 5 \nprint (\"Minimum in range\", left, \"to\", right, \"is\", \n       range_query(segtree, left, right + 1, n)) \n \nindex = 3 \nvalue = 1\nupdate(segtree, index, value, n); \nleft = 2\nright = 6 \nprint(\"Minimum in range\", left, \"to\", right, \"is\", \n      range_query(segtree, left, right + 1, n)) \n",
    "orden": 1,
    "suborden": 3,
    "fecha_creacion": "2020-12-06 19:51:49",
    "fecha_modificacion": "2022-03-08 14:26:59"
  },
  {
    "ID": 243,
    "supergrupo": "Estructuras",
    "tema": "Sparse Table",
    "texto": "El concepto de tabla dispersa se utiliza para consultas rápidas sobre un conjunto de datos estáticos (los elementos no cambian). Realiza un preprocesamiento para que las consultas se puedan responder de manera eficiente.\n \nProblema de ejemplo 1: consulta de rango mínimo\n\nTenemos una array arr [0. . . n-1]. Necesitamos encontrar de manera eficiente el valor mínimo desde el índice L (inicio de la consulta) hasta R (final de la consulta) donde 0 <= L <= R <= n-1. Considere una situación en la que hay muchas consultas de rango.\nEjemplo:\nEntrada: arr [] = {7, 2, 3, 0, 5, 10, 3, 12, 18};\n        consulta [] = [0, 4], [4, 7], [7, 8]\n\nSalida: el mínimo de [0, 4] es 0\n        El mínimo de [4, 7] es 3\n        El mínimo de [7, 8] es 12\nLa idea es precalcular el mínimo de todos los subarreglos de tamaño 2j donde j varía de 0 a Log n. Hacemos una búsqueda de tabla [i] [j] tal que la búsqueda [i] [j] contiene un rango mínimo a partir de i y de tamaño 2j. Por ejemplo, la búsqueda [0] [3] contiene un mínimo de rango [0, 7] (comenzando con 0 y de tamaño 23)\n¿Cómo llenar esta tabla de búsqueda o escasa?\nLa idea es simple, complete de forma ascendente utilizando valores previamente calculados. Calculamos rangos con una potencia actual de 2 utilizando valores de menor potencia de dos. Por ejemplo, para encontrar un mínimo de rango [0, 7] (el tamaño del rango es una potencia de 3), podemos usar el mínimo de los siguientes dos.\na) Mínimo de rango [0, 3] (el tamaño del rango es una potencia de 2)\nb) Mínimo de rango [4, 7] (el tamaño del rango es una potencia de 2)\nBasado en el ejemplo anterior, a continuación se muestra la fórmula,\n// El mínimo de subarreglos de un solo elemento es el mismo\n// como único elemento.\nbuscar [i] [0] = arr [i]\n\n// Si buscar [0] [2] <= buscar [4] [2],\n// luego buscar [0] [3] = buscar [0] [2]\nSi búsqueda [i] [j-1] <= búsqueda [i + 2j-1] [j-1]\n   buscar [i] [j] = buscar [i] [j-1]\n\n// Si buscar [0] [2]> buscar [4] [2],\n// luego buscar [0] [3] = buscar [4] [2]\nMás\n   buscar [i] [j] = buscar [i + 2j-1] [j-1]\n\n \nPara cualquier rango arbitrario [l, R], necesitamos usar rangos que estén en potencias de 2. La idea es usar la potencia más cercana de 2. Siempre necesitamos hacer como máximo una comparación (compare el mínimo de dos rangos que son potencias de 2). Un rango comienza con L y termina con \"L + potencia más cercana de 2\". El otro rango termina en R y comienza con “R - misma potencia más cercana de 2 + 1”. Por ejemplo, si el rango dado es (2, 10), comparamos el mínimo de dos rangos (2, 9) y (3, 10).\nBasado en el ejemplo anterior, a continuación se muestra la fórmula,\n\n\n// Para (2, 10), j = piso (Log2 (10-2 + 1)) = 3\nj = floor (Log (R-L + 1))\n\n// Si lookup [2] [3] <= lookup [3] [3],\n// luego min (2, 10) = lookup [2] [3]\nSi búsqueda [L] [j] <= búsqueda [R- (int) pow (2, j) +1] [j]\n   min (L, R) = buscar [L] [j]\n\n// Si lookup [2] [3]> arr [lookup [3] [3],\n// luego min (2, 10) = lookup [3] [3]\nMás\n   min (L, R) = búsqueda [R- (int) pow (2, j) +1] [j]\nDado que solo hacemos una comparación, la complejidad de tiempo de la consulta es O (1).\nProblema de ejemplo 2: Consulta GCD de rango\n\nTenemos una array arr [0. . . n-1]. Necesitamos encontrar el máximo común divisor en el rango L y R donde 0 <= L <= R <= n-1. Considere una situación en la que hay muchas querys de rango\nEjemplos:\nEntrada: arr [] = {2, 3, 5, 4, 6, 8}\n        querys [] = {(0, 2), (3, 5), (2, 3)}\nSalida: 1\n         2\n         1\nUsamos las siguientes propiedades de GCD:\n• La función GCD es asociativa [GCD (a, b, c) = GCD (GCD (a, b), c) = GCD (a, GCD (b, c))], podemos calcular GCD de un rango usando GCD de subrangos.\n• Si tomamos GCD de un rango superpuesto más de una vez, entonces no cambia la respuesta. Por ejemplo, GCD (a, b, c) = GCD (GCD (a, b), GCD (b, c)). Por lo tanto, como problema de consulta de rango mínimo, necesitamos hacer solo una comparación para encontrar GCD del rango dado.\nConstruimos una tabla dispersa usando la misma lógica que arriba. Después de construir la tabla dispersa, podemos encontrar todos los MCD rompiendo el rango dado en potencias de 2 y agregando el MCD de cada pieza a la respuesta actual.\n",
    "complejidad_tiempo": null,
    "java": "// Programa Java para realizar consultas de rango mínimo en O (1) \n// tiempo con O (n * n) espacio extra y O (n * n) tiempo de preprocesamiento.\n\npublic class SpaseTableSquareRootDecomposition {\n\n    static int MAX = 500;\n    // lookup [i] [j] va a almacenar el índice de valor mínimo en arr [i..j]\n    static int[][] lookup = new int[MAX][MAX];\n\n    // Estructura para representar un rango de consulta \n    static class Query {\n\n        int L, R;\n\n        public Query(int L, int R) {\n            this.L = L;\n            this.R = R;\n        }\n    };\n\n    // Llena la búsqueda de matriz de búsqueda [n] [n] para todos \n    // los valores posibles de los rangos de consulta\n    static void preprocess(int arr[], int n) {\n        // Inicialice la búsqueda [] [] para los intervalos con longitud 1\n        for (int i = 0; i < n; i++) {\n            lookup[i][i] = i;\n        }\n\n        // Complete el resto de las entradas de abajo hacia arriba\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) // Para encontrar un mínimo de [0,4],\n            // comparamos el mínimo de arr [lookup [0] [3]] con arr [4].\n            {\n                if (arr[lookup[i][j - 1]] < arr[j]) {\n                    lookup[i][j] = lookup[i][j - 1];\n                } else {\n                    lookup[i][j] = j;\n                }\n            }\n        }\n    }\n\n    // Imprime un mínimo de m rangos de consulta dados en arr [0..n-1]\n    static void RMQ(int arr[], int n,\n            Query q[], int m) {\n        // Llenar la tabla de búsqueda para todas las consultas de entrada posibles\n        preprocess(arr, n);\n\n        // Calcula una por una la suma de todas las consultas\n        for (int i = 0; i < m; i++) {\n            // Límites izquierdo y derecho del rango actual\n            int L = q[i].L, R = q[i].R;\n\n            // Imprimir la suma del rango de consulta actual\n            System.out.println(\"Minimum of [\" + L\n                    + \", \" + R + \"] is \"\n                    + arr[lookup[L][R]]);\n        }\n    }\n\n    public static void main(String[] args) {\n        int a[] = {7, 2, 3, 0, 5, 10, 3, 12, 18};\n        int n = a.length;\n        Query q[] = {new Query(0, 4),\n            new Query(4, 7),\n            new Query(7, 8)};\n        int m = q.length;\n        RMQ(a, n, q, m);\n    }\n}\n",
    "cpp": "#include<bits/stdc++.h> \nusing namespace std;\n#define MAX 500 \n\nint lookup[MAX][MAX];\n\nstruct Query {\n    int L, R;\n};\n\nvoid preprocess(int arr[], int n) {\n    for (int i = 0; i < n; i++)\n        lookup[i][0] = i;\n\n    for (int j = 1; (1 << j) <= n; j++) {\n        for (int i = 0; (i + (1 << j) - 1) < n; i++) {\n            if (arr[lookup[i][j - 1]] < arr[lookup[i + (1 << (j - 1))][j - 1]])\n                lookup[i][j] = lookup[i][j - 1];\n            else\n                lookup[i][j] = lookup[i + (1 << (j - 1))][j - 1];\n        }\n    }\n}\n\nint query(int arr[], int L, int R) {\n    int j = (int) log2(R - L + 1);\n    if (arr[lookup[L][j]] <= arr[lookup[R - (1 << j) + 1][j]])\n        return arr[lookup[L][j]];\n\n    else return arr[lookup[R - (1 << j) + 1][j]];\n}\n\nvoid RMQ(int arr[], int n, Query q[], int m) {\n    preprocess(arr, n);\n    for (int i = 0; i < m; i++) {\n        int L = q[i].L, R = q[i].R;\n        cout << \"Minimum of [\" << L << \", \"\n                << R << \"] is \" << query(arr, L, R) << endl;\n    }\n}\n\nint main() {\n    int a[] = {7, 2, 3, 0, 5, 10, 3, 12, 18};\n    int n = sizeof (a) / sizeof (a[0]);\n    Query q[] = {\n        {0, 4},\n        {4, 7},\n        {7, 8}\n    };\n    int m = sizeof (q) / sizeof (q[0]);\n    RMQ(a, n, q, m);\n    return 0;\n}\n",
    "py": "from math import log2\n \nMAX = 500\nlookup = [[0 for i in range(500)] \n    for j in range(500)] \n\n\nclass Query: \n    def __init__(self, l, r): \n        self.L = l \n        self.R = r \n\ndef preprocess(arr: list, n: int): \n    global lookup \n    for i in range(n): \n        lookup[i][0] = i \n    j = 1\n    while (1 << j) <= n: \n        i = 0\n        while i + (1 << j) - 1 < n: \n            if (arr[lookup[i][j - 1]] < \n                arr[lookup[i + (1 << (j - 1))][j - 1]]): \n                lookup[i][j] = lookup[i][j - 1] \n            else: \n                lookup[i][j] = lookup[i +\n                    (1 << (j - 1))][j - 1] \n\n            i += 1\n        j += 1\n\ndef query(arr: list, L: int, R: int): \n    global lookup \n    j = int(log2(R - L + 1)) \n    if (arr[lookup[L][j]] <=\n        arr[lookup[R - (1 << j) + 1][j]]): \n        return arr[lookup[L][j]] \n    else: \n        return arr[lookup[R - (1 << j) + 1][j]] \ndef RMQ(arr: list, n: int, q: list, m: int): \n    preprocess(arr, n) \n    for i in range(m): \n        L = q[i].L \n        R = q[i].R \n        print(\"Minimum of [%d, %d] is %d\" %\n              (L, R, query(arr, L, R))) \n\n\na = [7, 2, 3, 0, 5, 10, 3, 12, 18] \nn = len(a) \nq = [Query(0, 4), Query(4, 7), \n    Query(7, 8)] \nm = len(q) \nRMQ(a, n, q, m) \n",
    "orden": 1,
    "suborden": 4,
    "fecha_creacion": "2020-12-06 19:51:50",
    "fecha_modificacion": "2022-03-08 14:28:36"
  },
  {
    "ID": 244,
    "supergrupo": "Estructuras",
    "tema": "Heap Sort",
    "texto": "La clasificación de montón es una técnica de clasificación basada en comparación basada en la estructura de datos de montón binario. Es similar al ordenamiento por selección donde primero encontramos el elemento máximo y colocamos el elemento máximo al final. Repetimos el mismo proceso para el resto de elementos.\n\n¿Qué es el montón binario?\nPrimero definamos un árbol binario completo. Un árbol binario completo es un árbol binario en el que cada nivel, excepto posiblemente el último, está completamente lleno y todos los nodos están lo más a la izquierda posible.\nUn montón binario es un árbol binario completo donde los elementos se almacenan en un orden especial de modo que el valor en un nodo principal es mayor (o menor) que los valores en sus dos nodos secundarios. El primero se llama max heap y el último se llama min-heap. El montón se puede representar mediante un árbol o matriz binaria.\n\n¿Por qué la representación basada en matrices para Binary Heap?\nDado que un montón binario es un árbol binario completo, se puede representar fácilmente como una matriz y la representación basada en matriz es eficiente en el espacio. Si el nodo padre se almacena en el índice I, el hijo de la izquierda se puede calcular por 2 * I + 1 y el hijo de la derecha por 2 * I + 2 (asumiendo que la indexación comienza en 0).\n\nAlgoritmo de clasificación de montón para clasificar en orden creciente:\n1. Cree un montón máximo a partir de los datos de entrada.\n2. En este punto, el elemento más grande se almacena en la raíz del montón. Reemplácelo con el último elemento del montón y luego reduzca el tamaño del montón en 1. Finalmente, apile la raíz del árbol.\n3. Repita el paso 2 mientras el tamaño del montón sea mayor que 1.\n¿Cómo construir el montón?\nEl procedimiento Heapify se puede aplicar a un nodo solo si sus nodos secundarios están heapified. Por tanto, la heapificación debe realizarse en orden ascendente.\nEntendamos con la ayuda de un ejemplo:\n\nDatos de entrada: 4, 10, 3, 5, 1\n         4 (0)\n        / \\\n     10 (1) 3 (2)\n    / \\\n 5 (3) 1 (4)\n\nLos números entre paréntesis representan los índices de la matriz.\nrepresentación de datos.\n\nAplicar el procedimiento de heapify al índice 1:\n         4 (0)\n        / \\\n    10 (1) 3 (2)\n    / \\\n5 (3) 1 (4)\n\nAplicando el procedimiento de heapify al índice 0:\n        10 (0)\n        / \\\n     5 (1) 3 (2)\n    / \\\n 4 (3) 1 (4)\nEl procedimiento de heapify se llama a sí mismo de forma recursiva para construir el montón\n de arriba hacia abajo.\nNotas:\nLa ordenación de pila es un algoritmo in situ.\nSu implementación típica no es estable, pero puede estabilizarse\n\nAplicaciones de HeapSort\n1. Ordene una matriz casi ordenada (o ordenada por K)\n2. k elementos más grandes (o más pequeños) en una matriz\nEl algoritmo de ordenación de pila tiene usos limitados porque Quicksort y Mergesort son mejores en la práctica. Sin embargo, la estructura de datos de Heap en sí se utiliza enormemente. Instantáneas:\n",
    "complejidad_tiempo": null,
    "java": "// Programa Java para la implementación de Heap Sort\n\npublic class HeapSort {\n\n    public void sort(int arr[]) {\n        int n = arr.length;\n\n        // Construir montón (reorganizar la matriz)\n        for (int i = n / 2 - 1; i >= 0; i--) {\n            heapify(arr, n, i);\n        }\n\n        // Uno por uno extrae un elemento del montón\n        for (int i = n - 1; i > 0; i--) {\n            // Mover la raíz actual al final\n            int temp = arr[0];\n            arr[0] = arr[i];\n            arr[i] = temp;\n            // llamar a max heapify en el montón reducido\n            heapify(arr, i, 0);\n        }\n    }\n\n    // Para apilar un subárbol enraizado con el nodo i, \n    // que es un índice en arr []. n es el tamaño del montón\n    void heapify(int arr[], int n, int i) {\n        int largest = i; // Inicializar más grande como raíz\n        int l = 2 * i + 1; // left = 2*i + 1 \n        int r = 2 * i + 2; // right = 2*i + 2 \n\n        // Si el niño izquierdo es más grande que la raíz\n        if (l < n && arr[l] > arr[largest]) {\n            largest = l;\n        }\n\n        // Si el niño derecho es más grande que el más grande hasta ahora \n        if (r < n && arr[r] > arr[largest]) {\n            largest = r;\n        }\n\n        // Si el más grande no es raíz\n        if (largest != i) {\n            int swap = arr[i];\n            arr[i] = arr[largest];\n            arr[largest] = swap;\n\n            // Apila de forma recursiva el subárbol afectado\n            heapify(arr, n, largest);\n        }\n    }\n\n    /* Una función de utilidad para imprimir una matriz de tamaño n */\n    static void printArray(int arr[]) {\n        int n = arr.length;\n        for (int i = 0; i < n; ++i) {\n            System.out.print(arr[i] + \" \");\n        }\n        System.out.println();\n    }\n\n    public static void main(String args[]) {\n        int arr[] = {12, 11, 13, 5, 6, 7};\n        int n = arr.length;\n\n        HeapSort ob = new HeapSort();\n        ob.sort(arr);\n\n        System.out.println(\"Sorted array is\");\n        printArray(arr);\n    }\n}\n",
    "cpp": "#include <iostream> \n\nusing namespace std;\n\nvoid heapify(int arr[], int n, int i) {\n    int largest = i;\n    int l = 2 * i + 1;\n    int r = 2 * i + 2;\n    if (l < n && arr[l] > arr[largest])\n        largest = l;\n    if (r < n && arr[r] > arr[largest])\n        largest = r;\n    if (largest != i) {\n        swap(arr[i], arr[largest]);\n        heapify(arr, n, largest);\n    }\n}\n\nvoid heapSort(int arr[], int n) {\n    for (int i = n / 2 - 1; i >= 0; i--)\n        heapify(arr, n, i);\n\n    for (int i = n - 1; i > 0; i--) {\n        swap(arr[0], arr[i]);\n        heapify(arr, i, 0);\n    }\n}\n\nvoid printArray(int arr[], int n) {\n    for (int i = 0; i < n; ++i)\n        cout << arr[i] << \" \";\n    cout << \"\\n\";\n}\n\nint main() {\n    int arr[] = {12, 11, 13, 5, 6, 7};\n    int n = sizeof (arr) / sizeof (arr[0]);\n\n    heapSort(arr, n);\n\n    cout << \"Sorted array is \\n\";\n    printArray(arr, n);\n}\n",
    "py": "def heapify(arr, n, i): \n    largest = i \n    l = 2 * i + 1        \n    r = 2 * i + 2        \n    if l < n and arr[i] < arr[l]: \n        largest = l \n    if r < n and arr[largest] < arr[r]: \n        largest = r \n    if largest != i: \n        arr[i], arr[largest] = arr[largest], arr[i] # swap . \n        heapify(arr, n, largest) \n\ndef heapSort(arr): \n    n = len(arr)  \n    for i in range(n // 2 - 1, -1, -1): \n        heapify(arr, n, i) \n    for i in range(n-1, 0, -1): \n        arr[i], arr[0] = arr[0], arr[i] # swap \n        heapify(arr, i, 0) \n\narr = [12, 11, 13, 5, 6, 7] \nheapSort(arr) \nn = len(arr) \nprint (\"Sorted array is\") \nfor i in range(n): \n    print (\"%d\" % arr[i]), \n",
    "orden": 1,
    "suborden": 5,
    "fecha_creacion": "2020-12-06 19:51:50",
    "fecha_modificacion": "2022-03-08 14:28:36"
  },
  {
    "ID": 245,
    "supergrupo": "Estructuras",
    "tema": "QuickSelect",
    "texto": null,
    "complejidad_tiempo": null,
    "java": "import java.util.*;\n\nclass QuickSelect {\n\n    static int Partition(int A[], int l, int r) {\n        int p = A[l]; // p es el pivote\n        int m = l; // S1 y S2 están vacíos\n        int temp;\n        for (int k = l + 1; k <= r; ++k) { // explorar una región desconocida\n            if (A[k] < p) { // caso 2\n                m++;\n                temp = A[k];\n                A[k] = A[m];\n                A[m] = temp;\n            } // observe que no hacemos nada en el caso 1: a [k]> = p\n        }\n        temp = A[l];\n        A[l] = A[m];\n        A[m] = temp; // intercambiar pivote con una [m]\n        return m; // retorno de índice de pivote\n    }\n\n    static int RandPartition(int[] A, int l, int r) {\n        Random rnd = new Random();\n        int p = l + rnd.nextInt(r - l + 1); // seleccionar un pivote aleatorio\n        int temp = A[l];\n        A[l] = A[p];\n        A[p] = temp;   // intercambiar A [p] con A [l]\n        return Partition(A, l, r);\n    }\n\n    static int QuickSelect(int[] A, int l, int r, int k) {\n        if (l == r) {\n            return A[l];\n        }\n        int q = RandPartition(A, l, r);\n        if (q + 1 == k) {\n            return A[q];\n        } else if (q + 1 > k) {\n            return QuickSelect(A, l, q - 1, k);\n        } else {\n            return QuickSelect(A, q + 1, r, k);\n        }\n    }\n\n    public static void main(String[] args) {\n        int[] A = new int[]{2, 8, 7, 1, 5, 4, 6, 3}; // permutación de [1..8]\n\n        System.out.println(QuickSelect(A, 0, 7, 8)); // la salida debe ser 8\n        System.out.println(QuickSelect(A, 0, 7, 7)); // la salida debe ser 7\n        System.out.println(QuickSelect(A, 0, 7, 6)); // la salida debe ser 6\n        System.out.println(QuickSelect(A, 0, 7, 5)); // la salida debe ser 5\n        System.out.println(QuickSelect(A, 0, 7, 4)); // la salida debe ser 4\n        System.out.println(QuickSelect(A, 0, 7, 3)); // la salida debe ser 3\n        System.out.println(QuickSelect(A, 0, 7, 2)); // la salida debe ser 2\n        System.out.println(QuickSelect(A, 0, 7, 1)); // la salida debe ser 1\n    }\n}\n",
    "cpp": "#include <bits/stdc++.h>\nusing namespace std;\n\nint Partition(int A[], int l, int r) {\n    int p = A[l]; // p es el pivote\n    int m = l; // S1 y S2 están vacíos\n    for (int k = l + 1; k <= r; ++k) { // explorar una región desconocida\n        if (A[k] < p) { // case 2\n            ++m;\n            swap(A[k], A[m]);\n        } // observe que no hacemos nada en el caso 1: a [k]> = p\n    }\n    swap(A[l], A[m]); // intercambiar pivote con una [m]\n    return m; // retorno de índice de pivote\n}\n\nint RandPartition(int A[], int l, int r) {\n    int p = l + rand() % (r - l + 1); // seleccionar un pivote aleatorio\n    swap(A[l], A[p]); // intercambiar A [p] con A [l]\n    return Partition(A, l, r);\n}\n\nint QuickSelect(int A[], int l, int r, int k) { // esperado O (n)\n    if (l == r) return A[l];\n    int q = RandPartition(A, l, r); // O(n)\n    if (q + 1 == k)\n        return A[q];\n    else if (q + 1 > k)\n        return QuickSelect(A, l, q - 1, k);\n    else\n        return QuickSelect(A, q + 1, r, k);\n}\n\nint main() {\n    int A[] = {2, 8, 7, 1, 5, 4, 6, 3}; // permutación de [1..8]\n\n    printf(\"%d\\n\", QuickSelect(A, 0, 7, 8)); // la salida debe ser 8\n    printf(\"%d\\n\", QuickSelect(A, 0, 7, 7)); // la salida debe ser 7\n    printf(\"%d\\n\", QuickSelect(A, 0, 7, 6)); // la salida debe ser 6\n    printf(\"%d\\n\", QuickSelect(A, 0, 7, 5)); // la salida debe ser 5\n    printf(\"%d\\n\", QuickSelect(A, 0, 7, 4)); // la salida debe ser 4\n    printf(\"%d\\n\", QuickSelect(A, 0, 7, 3)); // la salida debe ser 3\n    printf(\"%d\\n\", QuickSelect(A, 0, 7, 2)); // la salida debe ser 2\n    printf(\"%d\\n\", QuickSelect(A, 0, 7, 1)); // la salida debe ser 1\n    return 0;\n}\n",
    "py": "import random\n\ndef swap(A, i, j): \n    A[i], A[j] = A[j], A[i] \n    return A\n\ndef Partition(A, l, r):\n    p = A[l] # p es el pivote\n    m = l   # S1 y S2 están vacíos\n    for k in range(l + 1, r + 1):  # explorar una región desconocida\n        if A[k] < p:   # caso 2\n            m += 1\n            swap(A, k, m)\n        # observe que no hacemos nada en el caso 1: a [k]> = p\n    swap(A, l, m)  # intercambiar pivote con una [m]\n    return m # retorno de índice de pivote\n\ndef RandPartition(A, l, r):\n    p = random.randint(l, r)# seleccionar un pivote aleatorio\n    swap(A, l, p)  # intercambiar A [p] con A [l]\n    return Partition(A, l, r)\n\ndef QuickSelect(A, l, r, k):# esperado O (n)\n    if l == r:\n        return A[l]\n    q = RandPartition(A, l, r) # O(n)\n    if q + 1 == k:\n        return A[q]\n    elif q + 1 > k:\n        return QuickSelect(A, l, q-1, k)\n    else:\n        return QuickSelect(A, q + 1, r, k)\n\ndef main():\n    A = [2, 8, 7, 1, 5, 4, 6, 3] # permutación de [1..8]\n\n    print(\"{}\".format(QuickSelect(A, 0, 7, 8)))  # la salida debe ser 8\n    print(\"{}\".format(QuickSelect(A, 0, 7, 7)))  # la salida debe ser 7\n    print(\"{}\".format(QuickSelect(A, 0, 7, 6)))  # la salida debe ser 6\n    print(\"{}\".format(QuickSelect(A, 0, 7, 5)))  # la salida debe ser 5\n    print(\"{}\".format(QuickSelect(A, 0, 7, 4)))  # la salida debe ser 4\n    print(\"{}\".format(QuickSelect(A, 0, 7, 3)))  # la salida debe ser 3\n    print(\"{}\".format(QuickSelect(A, 0, 7, 2)))  # la salida debe ser 2\n    print(\"{}\".format(QuickSelect(A, 0, 7, 1)))  # la salida debe ser 1\n\nmain()\n",
    "orden": 1,
    "suborden": 6,
    "fecha_creacion": "2020-12-06 19:51:50",
    "fecha_modificacion": "2020-12-06 21:01:17"
  },
  {
    "ID": 246,
    "supergrupo": "Formateos",
    "tema": "Formatear fechas y horas",
    "texto": null,
    "complejidad_tiempo": "No aplica",
    "java": "JAVA\nimport java.text.ParseException;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\n\npublic class DateFormatter {\n\n    public static void main(String args[]) throws ParseException {\n        // Formateo según el patrón dado en el argumento\n        SimpleDateFormat ft = new SimpleDateFormat(\"dd-MM-yyyy\");\n        String str = ft.format(new Date());\n        System.out.println(\"Formatted Date : \" + str);\n\n        // parseando una cadena determinada\n        str = \"02/18/1995\";\n        ft = new SimpleDateFormat(\"MM/dd/yyyy\");\n        Date date = ft.parse(str);\n\n        // esto imprimirá la fecha según la cadena parseada\n        System.out.println(\"Parsed Date : \" + date);\n    }\n}\n",
    "cpp": null,
    "py": null,
    "orden": 10,
    "suborden": 1,
    "fecha_creacion": "2020-12-06 19:51:51",
    "fecha_modificacion": "2020-12-06 20:33:40"
  },
  {
    "ID": 247,
    "supergrupo": "Formateos",
    "tema": "Formatear números decimales y enteros",
    "texto": null,
    "complejidad_tiempo": "No aplica",
    "java": "// Programa Java para demostrar el funcionamiento de DecimalFormat\n\nimport java.text.DecimalFormat;\n\npublic class JavaDecimalFormatter {\n\n    public static void main(String args[]) {\n        double num = 123.4567;\n\n        // imprime solo la parte numérica de un número flotante\n        DecimalFormat ft = new DecimalFormat(\"####\");\n        System.out.println(\"Without fraction part: num = \" + ft.format(num));\n\n        // esto lo imprimirá hasta 2 lugares decimales\n        ft = new DecimalFormat(\"#.##\");\n        System.out.println(\"Formatted to Give precison: num = \" + ft.format(num));\n\n        // agrega automáticamente cero a la parte más a la derecha del decimal \n        // en lugar de #, usamos el dígito 0\n        ft = new DecimalFormat(\"#.000000\");\n        System.out.println(\"appended zeroes to right: num = \" + ft.format(num));\n\n        // agrega automáticamente cero al extremo izquierdo del número decimal \n        // en lugar de #, usamos el dígito 0\n        ft = new DecimalFormat(\"00000.00\");\n        System.out.println(\"formatting Numeric part : num = \" + ft.format(num));\n\n        // formatear dinero en dólares\n        double income = 23456.789;\n        ft = new DecimalFormat(\"$###,###.##\");\n        System.out.println(\"your Formatted Dream Income : \" + ft.format(income));\n    }\n}\n",
    "cpp": null,
    "py": null,
    "orden": 10,
    "suborden": 2,
    "fecha_creacion": "2020-12-06 19:51:51",
    "fecha_modificacion": "2020-12-06 20:33:41"
  },
  {
    "ID": 248,
    "supergrupo": "Generadores",
    "tema": "Números aleatorios",
    "texto": null,
    "complejidad_tiempo": "No aplica",
    "java": "// Un programa Java para generar casos de prueba para números aleatorios\n\nimport java.io.*;\nimport java.util.Random;\n\npublic class TestCasesGeneratingRandomNumbers {\n\n    // el número de ejecuciones de los datos de prueba generados\n    static int requiredNumbers = 5;\n    // rango mínimo de números aleatorios\n    static int lowerBound = 0;\n    // rango máximo de números aleatorios\n    static int upperBound = 1000;\n\n    static void randomNumbers() {\n        Random random = new Random();\n        for (int i = 0; i < requiredNumbers; i++) {\n            int a = random.nextInt(upperBound - lowerBound)\n                    + lowerBound;\n            System.out.println(a);\n        }\n    }\n\n    public static void main(String[] args) throws IOException {\n        randomNumbers();\n    }\n}\n",
    "cpp": "#include <cstdlib>\n#include <bits/stdc++.h> \nusing namespace std;\n\nstatic int requiredNumbers = 5;\nstatic int lowerBound = 0;\nstatic int upperBound = 1000;\n\nvoid randomNumbers() {\n    for (int i = 0; i < requiredNumbers; i++) {\n        int a = (rand()) % upperBound;\n        cout << a << \" \";\n    }\n}\n\nint main() {\n    randomNumbers();\n}\n",
    "py": "import random as r\nrequiredNumbers = 5\nlowerBound = 0\nupperBound = 1000\n\ndef randomNumbers():\n    for i in range (requiredNumbers):\n        a = r.randint(lowerBound, upperBound)\n        print(a)\nrandomNumbers()\n",
    "orden": 11,
    "suborden": 0,
    "fecha_creacion": "2020-12-06 19:51:51",
    "fecha_modificacion": "2020-12-06 20:34:17"
  },
  {
    "ID": 249,
    "supergrupo": "Generadores",
    "tema": "Vectores numéricos aleatorios",
    "texto": null,
    "complejidad_tiempo": "No aplica",
    "java": "// Un programa Java para generar casos de prueba para \n// matrices llenas de números aleatorios\n\nimport java.io.*;\nimport java.util.Random;\n\npublic class TestCasesGeneratingRandomArrays {\n\n    static int RUN = 5;\n    // rango mínimo de números aleatorios\n    static int lowerBound = 0;\n    // rango máximo de números aleatorios\n    static int upperBound = 1000;\n    // tamaño mínimo de la matriz reqd\n    static int minSize = 10;\n    // tamaño máximo de la matriz reqd\n    static int maxSize = 20;\n\n    static void randomArray() {\n        Random random = new Random();\n        for (int i = 0; i < RUN; i++) {\n            int size = random.nextInt(maxSize - minSize)\n                    + minSize;\n            int[] array = new int[size];\n\n            System.out.println(size);\n\n            for (int j = 0; j < size; j++) {\n                int a = random.nextInt(upperBound - lowerBound)\n                        + lowerBound;\n                System.out.print(a + \" \");\n            }\n            System.out.println();\n        }\n    }\n\n    public static void main(String[] args) throws IOException {\n        randomArray();\n    }\n}\n",
    "cpp": "#include <cstdlib>\n#include <bits/stdc++.h> \nusing namespace std;\n\nint RUN = 5;\nint lowerBound = 0;\nint upperBound = 1000;\nint minSize = 10;\nint maxSize = 20;\n\nvoid randomArray() {\n    for (int i = 0; i < RUN; i++) {\n        int size = maxSize - (rand() % minSize);\n        int array[size];\n        cout << size << endl;\n        for (int j = 0; j < size; j++) {\n            int a = upperBound - (rand() % upperBound);\n            cout << a << \" \";\n        }\n        cout << endl;\n    }\n}\n\nint main() {\n    randomArray();\n}\n",
    "py": "import random as r\nRUN = 5;\nlowerBound = 0;\nupperBound = 1000;\nminSize = 10;\nmaxSize = 20;\ndef randomArray():\n    for i in range (RUN):\n        size = r.randint(minSize, maxSize)\n        array = [0 for j in range(size)]\n        print(size)\n        str1 = \"\"\n        for j in range (size):\n            a = r.randint(lowerBound, upperBound)\n            str1 += str(a) + \" \" \n        print(str1)\nrandomArray()        \n",
    "orden": 11,
    "suborden": 1,
    "fecha_creacion": "2020-12-06 19:51:52",
    "fecha_modificacion": "2020-12-06 20:34:18"
  },
  {
    "ID": 250,
    "supergrupo": "Generadores",
    "tema": "Matrices numéricas aleatorias",
    "texto": null,
    "complejidad_tiempo": "No aplica",
    "java": "// Un programa Java para generar casos de prueba para \n// matrices llenas de números aleatorios\n\nimport java.io.IOException;\nimport java.util.Random;\n\npublic class TestCasesGeneratingRandomMatrix {\n\n    // el número de ejecuciones de los datos de prueba generados\n    static int RUN = 5;\n    // rango mínimo de números aleatorios\n    static int lowerBound = 0;\n    // rango máximo de números aleatorios\n    static int upperBound = 1000;\n    // tamaño máximo de columna \n    static int maxColomn = 10;\n    // tamaño mínimo de columna\n    static int minColomn = 1;\n    // tamaño mínimo de fila\n    static int minRow = 1;\n    // tamaño máximo de fila\n    static int maxRow = 10;\n\n    static void randomArray() {\n        Random random = new Random();\n\n        for (int i = 0; i < RUN; i++) {\n            int row = random.nextInt(maxRow - minRow)\n                    + minRow;\n            int colomn = random.nextInt(maxColomn - minColomn)\n                    + minColomn;\n\n            int[][] matrix = new int[row][colomn];\n\n            System.out.println(row + \" \" + colomn);\n\n            for (int j = 0; j < row; j++) {\n                for (int k = 0; k < colomn; k++) {\n                    int a = random.nextInt(upperBound - lowerBound)\n                            + lowerBound;\n                    System.out.print(a + \" \");\n                }\n                System.out.println();\n            }\n            System.out.println();\n        }\n    }\n\n    public static void main(String[] args) throws IOException {\n        randomArray();\n    }\n}\n",
    "cpp": "#include <cstdlib>\n#include <bits/stdc++.h> \nusing namespace std;\n\nint RUN = 5;\nint lowerBound = 0;\nint upperBound = 1000;\nint maxColumn = 10;\nint minColumn = 1;\nint minRow = 1;\nint maxRow = 10;\n\nvoid randomMatrix() {\n    for (int i = 0; i < RUN; i++) {\n        int row = maxRow - (rand() % maxRow) - minRow;\n        int column = maxColumn - (rand() % maxColumn) - minColumn;\n        int matrix[row][column];\n        cout << row << \" \" << column << endl;\n        for (int j = 0; j < row; j++) {\n            for (int k = 0; k < column; k++) {\n                int a = upperBound - (rand() % upperBound);\n                cout << a << \" \";\n            }\n            cout << endl;\n        }\n        cout << endl;\n    }\n}\n\nint main() {\n    randomMatrix();\n}\n",
    "py": "import random as r\nRUN = 5;\nlowerBound = 0\nupperBound = 1000\nmaxColumn = 10\nminColumn = 1\nminRow = 1\nmaxRow = 10\ndef randomMatrix():\n    for _ in range (RUN):\n        row = r.randint(minRow,maxRow)\n        column = r.randint(minColumn,maxColumn)\n        matrix=[[0 for x in range(row)]for y in range (column)];\n        print(str(row) + \" \" + str(column))\n        str1=\"\"\n        for i in range (row):\n            for j in range (column):\n                a = r.randint(lowerBound,upperBound)\n                str1+=str(a)+\" \" \n            print(str1)\n            str1=\"\"\nrandomMatrix()\n",
    "orden": 11,
    "suborden": 2,
    "fecha_creacion": "2020-12-06 19:51:52",
    "fecha_modificacion": "2020-12-06 20:34:18"
  },
  {
    "ID": 251,
    "supergrupo": "Generadores",
    "tema": "Vectores numéricos ordenados aleatorios",
    "texto": null,
    "complejidad_tiempo": "No aplica",
    "java": "// Programa para generar casos de prueba para arrays llenos de números aleatorios\n\nimport java.util.Arrays;\nimport java.util.Random;\n\npublic class TestCasesRandomSortedArray {\n\n    // Define el número de corridas para los datos de prueba generados.\n    static int RUN = 5;\n    // Define el rango de los datos de prueba generados\n    static int MAX = 100000;\n    // Define el número máximo de elementos de la matriz\n    static int MAXNUM = 100;\n\n    static void randSortedArray() {\n        Random r = new Random();\n        int NUM; // Número de elementos de la matriz\n        for (int i = 1; i <= RUN; i++) {\n            NUM = 1 + r.nextInt(MAXNUM);\n            int[] arr = new int[NUM];\n            // Primero imprima el número de elementos de la matriz\n            System.out.printf(\"%d\\n\", NUM);\n            for (int j = 0; j < NUM; j++) {\n                arr[j] = r.nextInt(MAX);\n            }\n            // Ordenar la arrya aleatoria generada\n            Arrays.sort(arr);\n            // Imprime la array aleatoria ordenada\n            for (int j = 0; j < NUM; j++) {\n                System.out.printf(\"%d \", arr[j]);\n            }\n            System.out.printf(\"\\n\");\n        }\n    }\n\n    public static void main(String[] args) {\n        randSortedArray();\n    }\n}\n",
    "cpp": "#include<bits/stdc++.h> \nusing namespace std;\n\n#define RUN 5 \n#define MAX 100000 \n#define MAXNUM 100 \n\nvoid randSortedArray() {\n    srand(time(NULL));\n    int NUM; \n    for (int i = 1; i <= RUN; i++) {\n        NUM = 1 + rand() % MAXNUM;\n        int arr[NUM];\n        printf(\"%d\\n\", NUM);\n        for (int j = 0; j < NUM; j++)\n            arr[j] = rand() % MAX;\n        sort(arr, arr + NUM);\n        for (int j = 0; j < NUM; j++)\n            printf(\"%d \", arr[j]);\n\n        printf(\"\\n\");\n    }\n}\n\nint main() {\n    randSortedArray();\n}\n",
    "py": "import random as r\nRUN =5\nMAX=100000\nMAXNUM=100\n\ndef randSortedArray():\n    for i in range(RUN):\n        NUM=1+r.randint(0,MAXNUM)\n        arr=[]\n        print(NUM)\n        for j in range(NUM):\n            arr.append(r.randint(0,MAX))\n        arr.sort()\n        print(arr)\n        \nrandSortedArray()\n",
    "orden": 11,
    "suborden": 3,
    "fecha_creacion": "2020-12-06 19:51:52",
    "fecha_modificacion": "2020-12-06 20:34:19"
  },
  {
    "ID": 252,
    "supergrupo": "Generadores",
    "tema": "Caracteres aleatorios",
    "texto": null,
    "complejidad_tiempo": "No aplica",
    "java": "// Programa para generar casos de prueba para caracteres aleatorios\n\nimport java.util.Random;\n\npublic class TestCasesRandomChars {\n\n    // Definir el número de corridas para los datos de prueba generados.\n    static int RUN = 5;\n    // Defina el rango de los datos de prueba generados Aquí es de 'a' a 'z' \n    static int MAX = 25;\n\n    static void randomChars() {\n        Random r = new Random();\n        for (int i = 1; i <= RUN; i++) {\n            System.out.printf(\"%c\\n\", (char) ('a' + r.nextInt(25)));\n        }\n    }\n\n    public static void main(String[] args) {\n        randomChars();\n    }\n}\n",
    "cpp": "#include<bits/stdc++.h> \nusing namespace std;\n\n#define RUN 5 \n#define MAX 25 \n\nvoid randomChars() {\n    srand(time(NULL));\n    for (int i = 1; i <= RUN; i++)\n        printf(\"%c\\n\", 'a' + rand() % MAX);\n}\n\nint main() {\n    randomChars();\n}\n",
    "py": "import random as r\nRUN=5\nMAX=25\n\ndef randomChars():\n    for i in range(RUN):\n        print(chr(ord('a')+r.randint(0,MAX)))\n        \nrandomChars()\n",
    "orden": 11,
    "suborden": 4,
    "fecha_creacion": "2020-12-06 19:51:53",
    "fecha_modificacion": "2020-12-06 20:34:20"
  },
  {
    "ID": 253,
    "supergrupo": "Generadores",
    "tema": "Cadenas de caracteres aleatorias",
    "texto": null,
    "complejidad_tiempo": "No aplica",
    "java": "// Programa para generar casos de prueba para cadenas aleatorias\n\nimport java.util.Random;\npublic class TestCasesRandomStrings {\n\n    // Definir el número de corridas para los datos de prueba generados.\n    static int RUN = 5;\n    // Definir el rango de los datos de prueba generados\n    // Aquí está de 'a' a la 'z'\n    static int MAX = 25;\n    // Definir la longitud máxima de la cuerda\n    static int MAXLEN = 100;\n\n    static void randString() {\n        //Para valores aleatorios cada vez\n        Random r = new Random();\n        int LEN; // tamaño de la cadena\n        for (int i = 1; i <= RUN; i++) {\n            LEN = 1 + r.nextInt(MAXLEN);\n            // Primero imprime la longitud de la cadena\n            System.out.printf(\"%d\\n\", LEN);\n            // Luego imprime los caracteres de la cadena\n            for (int j = 1; j <= LEN; j++) {\n                System.out.printf(\"%c\", (char)('a' + r.nextInt(MAX)));\n            }\n            System.out.printf(\"\\n\");\n        }\n    }\n\n    public static void main(String[] args) {\n        randString();\n    }\n\n}\n",
    "cpp": "#include<bits/stdc++.h> \nusing namespace std;\n\n#define RUN 5\n#define MAX 25 \n#define MAXLEN 100 \n\nvoid randString() {\n    srand(time(NULL));\n    int LEN; \n    for (int i = 1; i <= RUN; i++) {\n        LEN = 1 + rand() % MAXLEN;\n        printf(\"%d\\n\", LEN);\n        for (int j = 1; j <= LEN; j++)\n            printf(\"%c\", 'a' + rand() % MAX);\n        printf(\"\\n\");\n    }\n}\n\nint main() {\n    randString();\n}\n",
    "py": "import random as r\nRUN=5\nMAX=25\nMAXLEN=100\ndef randString():\n    for i in range(RUN):\n        LEN=1+r.randint(0,MAXLEN)\n        print(LEN)\n        STR=\"\"\n        for j in range(LEN):\n            STR+=chr(ord('a') + r.randint(0,MAX))\n        print(STR)\n        \nrandString()\n",
    "orden": 11,
    "suborden": 5,
    "fecha_creacion": "2020-12-06 19:51:53",
    "fecha_modificacion": "2020-12-06 20:34:20"
  },
  {
    "ID": 254,
    "supergrupo": "Generadores",
    "tema": "Vectores de cadenas de caracteres aleatorias",
    "texto": null,
    "complejidad_tiempo": "No aplica",
    "java": "// Un programa java para generar casos de prueba para cadenas aleatorias\n\nimport java.util.Random;\npublic class TestCasesRandomArrayStrings {\n\n    // Define el número de corridas para los datos de prueba generados.\n    static int RUN = 1000;\n    // Define el rango de los datos de prueba generados Aquí es de 'a' a 'z'\n    static int MAX = 25;\n    // Definie el rango de número de cadenas en la matriz.\n    static int MAXNUM = 20;\n    // Define la longitud máxima de la cadena\n    static int MAXLEN = 20;\n\n    static void randomStrArr() {\n        Random r = new Random();\n        int NUM; // Número de cadenas en la matriz\n        int LEN; // Longitud de la cadena\n        for (int i = 1; i <= RUN; i++) {\n            NUM = 1 + r.nextInt(MAXNUM);\n            System.out.printf(\"%d\\n\", NUM);\n            for (int k = 1; k <= NUM; k++) {\n                LEN = 1 + r.nextInt(MAXLEN);;\n                // Luego imprime los caracteres de la cadena\n                for (int j = 1; j <= LEN; j++) {\n                    System.out.printf(\"%c\", 'a' + r.nextInt(MAX));\n                }\n                System.out.printf(\" \");\n            }\n            System.out.printf(\"\\n\");\n        }\n    }\n\n    public static void main(String[] args) {\n        randomStrArr();\n    }\n}\n",
    "cpp": "#include<bits/stdc++.h> \nusing namespace std;\n\n\n#define RUN 1000 \n#define MAX 25 \n#define MAXNUM 20\n#define MAXLEN 20 \n\nvoid randomStrArr() {\n    srand(time(NULL));\n    int NUM; \n    int LEN;\n    for (int i = 1; i <= RUN; i++) {\n        NUM = 1 + rand() % MAXNUM;\n        printf(\"%d\\n\", NUM);\n\n        for (int k = 1; k <= NUM; k++) {\n            LEN = 1 + rand() % MAXLEN;\n            for (int j = 1; j <= LEN; j++)\n                printf(\"%c\", 'a' + rand() % MAX);\n\n            printf(\" \");\n        }\n        printf(\"\\n\");\n    }\n}\n\nint main() {\n    randomStrArr();\n    return (0);\n}\n",
    "py": "import random as r\nRUN = 1000 \nMAX = 25 \nMAXNUM = 20\nMAXLEN =  20 \ndef randomStrArr():\n    for i in range (1,RUN+1):\n        NUM = r.randint(1,MAXNUM)\n        print(NUM)\n        for k in range (1,NUM):\n            LEN = r.randint(1,MAXLEN)\n            str1=\"\"\n            for J in range (1,LEN):\n                str1+=chr(ord('a')+r.randint(0,MAX))+\"\";\n            print (str1)\n            str1=\"\"\n\nrandomStrArr()\n",
    "orden": 11,
    "suborden": 6,
    "fecha_creacion": "2020-12-06 19:51:53",
    "fecha_modificacion": "2020-12-06 20:34:21"
  },
  {
    "ID": 255,
    "supergrupo": "Generadores",
    "tema": "Palíndromos aleatorios",
    "texto": null,
    "complejidad_tiempo": "No aplica",
    "java": "import java.util.LinkedList;\nimport java.util.Random;\n\npublic class TestCasesRandomPalindromes {\n\n    static int RUN = 5;\n    static int MAX = 25;\n    static int MAXLEN = 50;\n\n    static void randPalindrome() {\n        Random r = new Random();\n        // Un recipiente para almacenar los palíndromos. \n        LinkedList<Character> container = new LinkedList<>();\n        int LEN; // Longitud de la cadena\n        for (int i = 1; i <= RUN; i++) {\n            LEN = 1 + r.nextInt(MAXLEN);\n            // Primero imprime la longitud de la cadena\n            System.out.printf(\"%d\\n\", LEN);\n            // Si es un palíndromo de longitud impar\n            if (LEN % 2 == 1) {\n                container.addLast((char) ('a' + r.nextInt(MAX)));\n            }\n            // Luego imprime los caracteres de la cadena palindrómica\n            for (int j = 1; j <= LEN / 2; j++) {\n                char ch = (char) ('a' + r.nextInt(MAX));\n                container.addLast(ch);\n                container.addFirst(ch);\n            }\n            for (Character c : container) {\n                System.out.printf(\"%c\", c);\n            }\n            container.clear();\n            System.out.printf(\"\\n\");\n        }\n    }\n\n    public static void main(String[] args) {\n        randPalindrome();\n    }\n\n}\n",
    "cpp": "#include<bits/stdc++.h> \nusing namespace std;\n\n#define RUN 5 \n#define MAX 25 \n#define MAXLEN 50 \n\nvoid randPalindrome(){\n    srand(time(NULL));\n    deque<char> container;\n    deque<char>::iterator it;\n    int LEN; \n    for (int i = 1; i <= RUN; i++) {\n        LEN = 1 + rand() % MAXLEN;\n        printf(\"%d\\n\", LEN);\n        if (LEN % 2)\n            container.push_back('a' + rand() % MAX);\n\n        for (int j = 1; j <= LEN / 2; j++) {\n            char ch = 'a' + rand() % MAX;\n            container.push_back(ch);\n            container.push_front(ch);\n        }\n        for (it = container.begin(); it != container.end(); ++it)\n            printf(\"%c\", *it);\n\n        container.clear();\n        printf(\"\\n\");\n    } \n}\n\nint main() {\n    randPalindrome();\n}\n",
    "py": "import random as r\n\nRUN=5\nMAX=25\nMAXLEN=25\ndef randPalindrome():\n    container=[]\n    for i in range(RUN):\n        LEN=1+r.randint(0,MAXLEN)\n        print(LEN)\n        if LEN%2==1:\n            container.append(chr(ord('a')+r.randint(0,MAX)))\n        for j in range (1,LEN/2+1):\n            ch=chr(ord('a')+r.randint(0,MAX))\n            container.append(ch)\n            container.insert(0,ch)\n        palin=str(container)\n        palin=palin.replace(\"[\", \"\")\n        palin=palin.replace(\"]\", \"\")\n        palin=palin.replace(\"'\", \"\")\n        palin=palin.replace(\",\", \"\")\n        palin=palin.replace(\" \", \"\")\n        print(palin)\n        \nrandPalindrome()\n",
    "orden": 11,
    "suborden": 7,
    "fecha_creacion": "2020-12-06 19:51:54",
    "fecha_modificacion": "2020-12-06 20:34:22"
  },
  {
    "ID": 256,
    "supergrupo": "Generadores",
    "tema": "Grafos no ponderados aleatorios",
    "texto": null,
    "complejidad_tiempo": "No aplica",
    "java": "// Program to generate test cases for an unweighted directed graph \n\nimport java.util.HashSet;\nimport java.util.Random;\nimport java.util.Set;\n\npublic class TestCasesUnweightedDirectedGraph {\n\n    // Definir el número de corridas para los datos de prueba generados. \n    static int RUN = 5;\n    // Definir el número máximo de vértices del grafo.\n    static int MAX_VERTICES = 20;\n    // Definir el número máximo de aristas\n    static int MAX_EDGES = 20;\n\n    static class Pair {\n\n        int first, second;\n\n        public Pair(int first, int second) {\n            this.first = first;\n            this.second = second;\n        }\n\n    }\n\n    static int getIndex(Set<Pair> set, Pair value) {\n        int result = 0;\n        for (Object entry : set) {\n            if (entry.equals(value)) {\n                return result;\n            }\n            result++;\n        }\n        return set.size() + 1;\n    }\n\n    public static void main(String[] args) {\n        Set<Pair> container = new HashSet<>();\n        //Para valores aleatorios cada vez\n        Random r = new Random();\n\n        int VERTICES; // Número de vértices\n        int NUMEDGE; // Número de bordes\n\n        for (int i = 1; i <= RUN; i++) {\n            VERTICES = 1 + r.nextInt(MAX_VERTICES);\n            // Definir el número máximo de aristas del grafo Dado que el grafo \n            // más denso puede tener N * (N-1) / 2 aristas donde \n            // N = número de vértices en el gráfico\n            NUMEDGE = 1 + r.nextInt(MAX_EDGES);\n            while (NUMEDGE > VERTICES * (VERTICES - 1) / 2) {\n                NUMEDGE = 1 + r.nextInt(MAX_EDGES);\n            }\n            // Primero imprime el número de vértices y aristas\n            System.out.printf(\"%d %d\\n\", VERTICES, NUMEDGE);\n            // Luego imprima los bordes del formulario (a b) \n            // donde 'a' está conectado a 'b'\n            for (int j = 1; j <= NUMEDGE; j++) {\n                int a = 1 + r.nextInt(VERTICES);\n                int b = 1 + r.nextInt(VERTICES);\n                Pair p = new Pair(a, b);\n                // Busca una ventaja \"nueva\" aleatoria cada vez\n                // Nota: en un árbol, el borde (a, b) es el mismo que el borde (b, a)\n                while (getIndex(container, p) != container.size() + 1) {\n                    a = 1 + r.nextInt(VERTICES);\n                    b = 1 + r.nextInt(VERTICES);\n                    p = new Pair(a, b);\n                }\n                container.add(p);\n            }\n            for (Pair p : container) {\n                System.out.printf(\"%d %d\\n\", p.first - 1, p.second - 1);\n            }\n            container.clear();\n            System.out.printf(\"\\n\");\n        }\n\n    }\n}\n",
    "cpp": "#include<bits/stdc++.h> \nusing namespace std;\n\n#define RUN 5 \n#define MAX_VERTICES 20 \n#define MAX_EDGES 20 \n\nint main() {\n    set<pair<int, int>> container;\n    srand(time(NULL));\n    int VERTICES;\n    int NUMEDGE;\n    for (int i = 1; i <= RUN; i++) {\n        VERTICES = 1 + rand() % MAX_VERTICES;\n        NUMEDGE = 1 + rand() % MAX_EDGES;\n        while (NUMEDGE > VERTICES * (VERTICES - 1) / 2)\n            NUMEDGE = 1 + rand() % MAX_EDGES;\n        printf(\"%d %d\\n\", VERTICES, NUMEDGE);\n        for (int j = 1; j <= NUMEDGE; j++) {\n            int a = 1 + rand() % VERTICES;\n            int b = 1 + rand() % VERTICES;\n            pair<int, int> p = make_pair(a, b);\n            while (container.find(p) != container.end()) {\n                a = 1 + rand() % VERTICES;\n                b = 1 + rand() % VERTICES;\n                p = make_pair(a, b);\n            }\n            container.insert(p);\n        }\n        for (pair<int, int> p : container) {\n            printf(\"%d %d\\n\", p.first - 1, p.second - 1);\n        }\n        container.clear();\n        printf(\"\\n\");\n    }\n    return (0);\n}\n",
    "py": "import random as r\nRUN = 5\nMAX_VERTICES = 20\nMAX_EDGES = 20\nclass Pair:\n    def __init__(self, first, second):\n        self.first = first\n        self.second = second\n        \ndef getIndex(setin, value):\n    result = 0;\n    for entry in setin:\n        if (entry == value):\n            return result\n        result += 1;\n    return len(setin) + 1;\n    \ncontainer = {}\nfor i in range (RUN):\n    VERTICES = 1 + r.randint(0, MAX_VERTICES)\n    NUMEDGE = 1 + r.randint(0, MAX_EDGES)\n    while (NUMEDGE > VERTICES * (VERTICES - 1) / 2):\n        NUMEDGE = 1 + r.randint(0, MAX_EDGES)\n    print(str(VERTICES) + \" \" + str(NUMEDGE)) \n    for j in range (NUMEDGE):\n        a = 1 + r.randint(0, VERTICES);\n        b = 1 + r.randint(0, VERTICES);\n        p = Pair(a, b)\n        while (getIndex(container, p) != len(container) + 1):\n            a = 1 + r.randint(0, VERTICES)\n            b = 1 + r.randint(0, VERTICES)\n            p = Pair()\n            p.first = a\n            p.second = b\n        container[j] = p\n    for p in container:\n        print(str(container[p].first) + \" \" + str(container[p].second))\n    container.clear();\n    print(\"\")\n",
    "orden": 11,
    "suborden": 8,
    "fecha_creacion": "2020-12-06 19:51:54",
    "fecha_modificacion": "2020-12-06 20:34:22"
  },
  {
    "ID": 257,
    "supergrupo": "Generadores",
    "tema": "Grafos ponderados aleatorios",
    "texto": null,
    "complejidad_tiempo": "No aplica",
    "java": "// Programa para generar casos de prueba para un gráfico dirigido no ponderado \n\nimport java.util.HashSet;\nimport java.util.Random;\nimport java.util.Set;\n\npublic class TestCasesWeightedDirectedGraph {\n\n    // Definir el número de corridas para los datos de prueba generados.\n    static int RUN = 5;\n    // Definir el número máximo de vértices del gráfico.\n    static int MAX_VERTICES = 20;\n    // Definir el número máximo de aristas\n    static int MAX_EDGES = 20;\n    static int MAXWEIGHT = 200;\n\n    static class Pair {\n\n        int first, second;\n\n        public Pair(int first, int second) {\n            this.first = first;\n            this.second = second;\n        }\n\n    }\n\n    static int getIndex(Set<Pair> set, Pair value) {\n        int result = 0;\n        for (Object entry : set) {\n            if (entry.equals(value)) {\n                return result;\n            }\n            result++;\n        }\n        return set.size() + 1;\n    }\n\n    public static void main(String[] args) {\n        Set<Pair> container = new HashSet<>();\n        //Para valores aleatorios cada vez\n        Random r = new Random();\n\n        int VERTICES; // Número de vértices\n        int NUMEDGE; // Número de caminos\n\n        for (int i = 1; i <= RUN; i++) {\n            VERTICES = 1 + r.nextInt(MAX_VERTICES);\n            // Definir el número máximo de aristas del grafo Dado que el grafo \n            // más denso puede tener N * (N-1) / 2 aristas donde \n            // N = número de vértices en el grafo\n            NUMEDGE = 1 + r.nextInt(MAX_EDGES);\n            while (NUMEDGE > VERTICES * (VERTICES - 1) / 2) {\n                NUMEDGE = 1 + r.nextInt(MAX_EDGES);\n            }\n            // Primero imprime el número de vértices y aristas\n            System.out.printf(\"%d %d\\n\", VERTICES, NUMEDGE);\n            // Luego imprima los bordes del formulario (a b) donde 'a' está conectado a 'b'\n            for (int j = 1; j <= NUMEDGE; j++) {\n                int a = 1 + r.nextInt(VERTICES);\n                int b = 1 + r.nextInt(VERTICES);\n                Pair p = new Pair(a, b);\n                // Busque una ventaja \"nueva\" aleatoria cada vez\n                // Nota: en un árbol, el borde (a, b) es el mismo que el borde (b, a)\n                while (getIndex(container, p) != container.size() + 1) {\n                    a = 1 + r.nextInt(VERTICES);\n                    b = 1 + r.nextInt(VERTICES);\n                    p = new Pair(a, b);\n                }\n                container.add(p);\n            }\n            for (Pair p : container) {\n                int wt = 1 + r.nextInt(MAXWEIGHT);\n                System.out.printf(\"%d %d %d\\n\", p.first - 1, p.second - 1, wt);\n            }\n            container.clear();\n            System.out.printf(\"\\n\");\n        }\n\n    }\n}\n",
    "cpp": "#include<bits/stdc++.h> \nusing namespace std;\n\n#define RUN 5 \n#define MAX_VERTICES 20 \n#define MAX_EDGES 20 \n#define MAXWEIGHT 200 \n\nint main() {\n    set<pair<int, int>> container;\n    srand(time(NULL));\n    int VERTICES;\n    int NUMEDGE;\n    for (int i = 1; i <= RUN; i++) {\n        VERTICES = 1 + rand() % MAX_VERTICES;\n        NUMEDGE = 1 + rand() % MAX_EDGES;\n        while (NUMEDGE > VERTICES * (VERTICES - 1) / 2)\n            NUMEDGE = 1 + rand() % MAX_EDGES;\n        printf(\"%d %d\\n\", VERTICES, NUMEDGE);\n        for (int j = 1; j <= NUMEDGE; j++) {\n            int a = 1 + rand() % VERTICES;\n            int b = 1 + rand() % VERTICES;\n            pair<int, int> p = make_pair(a, b);\n            while (container.find(p) != container.end()) {\n                a = 1 + rand() % VERTICES;\n                b = 1 + rand() % VERTICES;\n                p = make_pair(a, b);\n            }\n            container.insert(p);\n        }\n\n        for (pair<int, int> p : container) {\n            int wt = 1 + rand() % MAXWEIGHT;\n            printf(\"%d %d %d\\n\", p.first - 1, p.second - 1, wt);\n        }\n        container.clear();\n        printf(\"\\n\");\n    }\n    return (0);\n}\n",
    "py": "import random as r\nRUN = 5\nMAX_VERTICES = 20\nMAX_EDGES = 20\nMAXWEIGHT = 200\nclass Pair:\n    def __init__(self, first, second):\n        self.first = first\n        self.second = second\n        \ndef getIndex(setin, value):\n    result = 0;\n    for entry in setin:\n        if (entry == value):\n            return result\n        result += 1;\n    return len(setin) + 1;\n    \ncontainer = {}\nfor i in range (RUN):\n    VERTICES = 1 + r.randint(0, MAX_VERTICES)\n    NUMEDGE = 1 + r.randint(0, MAX_EDGES)\n    while (NUMEDGE > VERTICES * (VERTICES - 1) / 2):\n        NUMEDGE = 1 + r.randint(0, MAX_EDGES)\n    print(str(VERTICES) + \" \" + str(NUMEDGE)) \n    for j in range (NUMEDGE):\n        a = 1 + r.randint(0, VERTICES);\n        b = 1 + r.randint(0, VERTICES);\n        p = Pair(a, b)\n        while (getIndex(container, p) != len(container) + 1):\n            a = 1 + r.randint(0, VERTICES)\n            b = 1 + r.randint(0, VERTICES)\n            p = Pair()\n            p.first = a\n            p.second = b\n        container[j] = p\n    for p in container:\n        wt = 1 + r.randint(0, MAXWEIGHT);\n        print(str(container[p].first) + \" \" + str(container[p].second) + \" \" + str(wt))\n    container.clear();\n    print(\"\")\n",
    "orden": 11,
    "suborden": 9,
    "fecha_creacion": "2020-12-06 19:51:54",
    "fecha_modificacion": "2020-12-06 20:34:23"
  },
  {
    "ID": 278,
    "supergrupo": "Estructuras",
    "tema": "Estructuras de datos básicas",
    "texto": "Una estructura de datos es una colección de valores, la relación que existe entre estos valores y las operaciones que podemos hacer sobre ellos se refieren a cómo los datos están organizados y cómo se pueden administrar. Una estructura de datos describe el formato en que los valores van a ser almacenados, cómo van a ser accedidos y modificados, pudiendo así existir una gran cantidad de estructuras de datos.\nLo habitual es que un vector tenga una cantidad fija de memoria asignada, aunque dependiendo del tipo de vector y del lenguaje de programación un vector podría tener una cantidad variable de datos. En este caso, se les denomina vectores dinámicos, en oposición, a los vectores con una cantidad fija de memoria asignada se los denomina vectores estáticos. El uso de vectores dinámicos requiere realizar una apropiada gestión de memoria dinámica. Un uso incorrecto de los vectores dinámicos, o mejor dicho, una mala gestión de la memoria dinámica, puede conducir a una fuga de memoria. Al utilizar vectores dinámicos siempre habrá que liberar la memoria utilizada cuando ésta ya no se vaya a seguir utilizando.\nLenguajes más modernos y de más alto nivel, cuentan con un mecanismo denominado recolector de basura que permiten que el programa decida si debe liberar el espacio basándose en si se va a utilizar en el futuro o no un determinado objeto.\n\nVector tamaño fijo (Array):\n \nSe le denomina vector o arreglo (en inglés Array) a una zona de almacenamiento contiguo que contiene una serie de elementos del mismo tipo, los elementos de la matriz. Desde el punto de vista lógico una matriz se puede ver como un conjunto de elementos ordenados en fila.\nEstas estructuras de datos son adecuadas para situaciones en las que el acceso a los datos se realice de forma aleatoria e impredecible. Por el contrario, si los elementos pueden estar ordenados y se va a utilizar acceso secuencial sería más adecuado utilizar una lista, ya que esta estructura puede cambiar de tamaño fácilmente durante la ejecución de un programa.\n\nVector tamaño dinámico o lista (ArrayList):\nEn programación, un arreglo dinámico o Array dinámico, es un Array de elementos que crece o mengua dinámicamente conforme los elementos se agregan o se eliminan. Se suministra como librerías estándar en muchos lenguajes modernos de programación.\n\nVector sin repetición (Set):\nEs una colección desordenada de objetos en la que no se pueden almacenar valores duplicados. \n\nMatriz (Matrix):\n \nEs una tabla bidimensional de números consistentes en cantidades abstractas con las que se pueden realizar diferentes operaciones, como por ejemplo la suma, multiplicación y descomposición de las mismas de varias formas, lo que también las hace un concepto clave en el campo del álgebra lineal. Las matrices se utilizan para describir sistema de ecuaciones lineales, realizar un seguimiento de los coeficientes de una aplicación lineal y registrar los datos que dependen de varios parámetros.\n\nDiccionario o mapa (HashMap, TreeMap o Map):\nLos mapas son contenedores asociativos que almacenan elementos de forma mapeada. Cada elemento tiene un valor clave y un valor asignado. No hay dos valores asignados que puedan tener los mismos valores clave.\n\nPila (Stack):\n \nEs una lista ordenada o estructura de datos que permite almacenar y recuperar datos, el modo de acceso a sus elementos es de tipo LIFO (del inglés Last In, First Out, «último en entrar, primero en salir»). Esta estructura se aplica en multitud de problemas en el área de informática debido a su simplicidad y capacidad de dar respuesta a numerosos procesos.\n\nCola (Queue):\n \nEs una estructura de datos, caracterizada por ser una secuencia de elementos en la que la operación de inserción push se realiza por un extremo y la operación de extracción pop por el otro. También se le llama estructura FIFO (del inglés First In First Out), debido a que el primer elemento en entrar será también el primero en salir.\n",
    "complejidad_tiempo": null,
    "java": "import java.util.*;\n\npublic class Main {\n\n    public static Random r = new Random();\n    public static int i, j;\n    public static void main(String args[]) {\n        Scanner sc = new Scanner(System.in);\n        System.out.println(\"Inserte cantidad de datos\");\n        int n = sc.nextInt();\n        System.out.println(\"Que estructura quiere utilizar? (Los números son aleatorios\");\n        System.out.println(\"1) Vector fijo \");\n        System.out.println(\"2) Vector dinámico\");\n        System.out.println(\"3) Vector sin repetición\");\n        System.out.println(\"4) Matriz\");\n        System.out.println(\"5) Diccionario\");\n        System.out.println(\"6) Pila\");\n        System.out.println(\"7) Cola\");\n        int aux = sc.nextInt();\n        switch (aux) {\n            case 1:\n                vectorfijo(n);\n                break;\n            case 2:\n                vectordinamico(n);\n                break;\n            case 3:\n                vectorsinrepeticion(n);\n                break;\n            case 4:\n                matriz(n);\n                break;\n            case 5:\n                Diccionario(n);\n                break;\n            case 6:\n                pila(n);\n                break;\n            case 7:\n                cola(n);\n                break;\n        }\n    }\n    public static void vectordinamico(int n) {\n        ArrayList<Integer> arreglo = new ArrayList<>();\n        for (i = 0; i < n; i++) {\n            arreglo.add(r.nextInt());\n        }\n        for (i = 0; i < n; i++) {\n            System.out.println(arreglo.get(i));\n        }\n    }\n    public static void vectorfijo(int n) {\n        int[] números = new int[n];\n        for (i = 0; i < n; i++) {\n            números[i] = r.nextInt();\n        }\n        for (i = 0; i < n; i++) {\n            System.out.println(números[i]);\n        }\n    }\n    public static void matriz(int n) {\n        int[][] matrix = new int[n][n];\n        for (i = 0; i < n; i++) {\n            for (j = 0; j < n; j++) {\n                matrix[i][j] = r.nextInt(50);\n            }\n        }\n        for (i = 0; i < n; i++) {\n            for (j = 0; j < n; j++) {\n                System.out.print(matrix[i][j] + \" \");\n            }\n            System.out.println(\"\");\n        }\n    }\n    public static void vectorsinrepeticion(int n) {\n        HashSet<Integer> sinrep = new HashSet<>();\n        for (i = 0; i < n; i++) {\n            sinrep.add(r.nextInt(50));\n        }\n        Iterator it = sinrep.iterator();\n        while (it.hasNext()) {\n            System.out.println(it.next());\n        }\n    }\n    public static void Diccionario(int n) {\n TreeMap<String, String> dicc = new TreeMap<>();\n        dicc.put(\"Programar\", \"Utilizacion de codigo para ejecutar un programa\");\n        dicc.put(\"Futbol\", \"Deporte con una pelota y arcos\");\n        dicc.put(\"helado\", \"crema helada\");\n        dicc.put(\"Sargento mayor Johnson\", \"Practicar con palos y piedras\");\n        for (String concepto : dicc.keySet()) {\n            String key = concepto;\n            String value = dicc.get(concepto);\n            System.out.println(key + \"->\" + value);\n        }\n    }\n    public static void pila(int n) {\n        Stack<Integer> mipila = new Stack<>();\n        for (i = 0; i < n; i++) {\n            mipila.push(r.nextInt(50));\n        }\n        while (!mipila.isEmpty()) {\n            System.out.println(mipila.pop());\n        }\n    }\n    public static void cola(int n) {\n        Queue<Integer> micola = new LinkedList<>();\n        for (i = 0; i < n; i++) {\n            micola.offer(r.nextInt(50));\n        }\n        while (!micola.isEmpty()) {\n            System.out.println(micola.poll());\n        }\n    }\n}\n",
    "cpp": "#include<bits/stdc++.h>\n#include<cstdlib>\nusing namespace std;\nint i, j;\nvoid vectordinamico(int n) {\n    vector<int> arreglo;\n    for (i = 0; i < n; i++) {\n        arreglo.push_back(rand() % 100);\n    }\n    for (i = 0; i < n; i++) {\n        cout << arreglo.at(i) << endl;\n    }\n\n}\n\nvoid vectorfijo(int n) {\n    int números[n];\n    for (i = 0; i < n; i++) {\n        números[i] = rand() % 100;\n    }\n    for (i = 0; i < n; i++) {\n        cout << números[i] << endl;\n    }\n}\n\nvoid matriz(int n) {\n    int matrix [n][n];\n    for (i = 0; i < n; i++) {\n        for (j = 0; j < n; j++) {\n            matrix[i][j] = rand() % 100;\n        }\n    }\n    for (i = 0; i < n; i++) {\n        for (j = 0; j < n; j++) {\n            cout << matrix[i][j] << \" \";\n        }\n        cout << endl;\n    }\n}\n\nvoid vectorsinrepeticion(int n) {\n    set<int> sinrep;\n    for (i = 0; i < n; i++) {\n        sinrep.insert(rand() % 100);\n    }\n    for (auto itr = sinrep.begin(); itr != sinrep.end(); ++itr) {\n        cout << *itr << endl;\n    }\n}\n\nvoid Diccionario(int n) {\n      map <string, int> mapa;\n    int cantidad;\n    cin>>cantidad;\n    for (int i = 0; i < cantidad; i++) {\n        string dato1;\n        int dato2;\n        cin >> dato1>>dato2;\n        mapa.insert(type_pair(dato1, dato2));\n    }\n    cout << endl;\n    for (type_pair j : mapa) {\n        cout << j.first << \" \" << j.second << endl;\n    }\n}\n\nvoid pila(int n) {\n    stack<int> mipila;\n\n    for (i = 0; i < n; i++) {\n        mipila.push(rand() % 100);\n    }\n    while (!mipila.empty()) {\n        cout << mipila.top() << endl;\n        mipila.pop();\n    }\n}\n\nvoid cola(int n) {\n    queue<int> micola;\n    for (i = 0; i < n; i++) {\n        micola.push(rand() % 100);\n    }\n    while (!micola.empty()) {\n        cout << micola.front() << endl;\n        micola.pop();\n    }\n}\n\nint main(int argc, char *argv[]) {\n    cout << \"Inserte cantidad de datos\" << endl;\n    int n;\n    cin>>n;\n    cout << \"Que estructura quiere utilizar? (Los números son aleatorios\" << endl;\n    cout << \"1) Vector fijo \" << endl;\n    cout << \"2) Vector dinamico\" << endl;\n    cout << \"3) Vector sin repeticion\" << endl;\n    cout << \"4) Matriz\" << endl;\n    cout << \"5) Diccionario\" << endl;\n    cout << \"6) Pila\" << endl;\n    cout << \"7) Cola\" << endl;\n    int aux;\n    cin>>aux;\n    switch (aux) {\n        case 1:\n            vectorfijo(n);\n            break;\n        case 2:\n            vectordinamico(n);\n            break;\n        case 3:\n            vectorsinrepeticion(n);\n            break;\n        case 4:\n            matriz(n);\n            break;\n        case 5:\n            Diccionario(n);\n            break;\n        case 6:\n            pila(n);\n            break;\n        case 7:\n            cola(n);\n            break;\n    }\n    return 0;\n}\n",
    "py": "from collections import deque\nimport random\ndef vector(n):\n    arreglo = []\n    for i in (0, n):\n        arreglo.append(random.randint(0, 100))\n        \n    for i in (arreglo):\n        print(i)\n\ndef matriz(n):\n    matrix = []\n    for i in range(n):\n        row = []\n        for j in range(n):\n            row.append(random.randint(0, 100))\n        matrix.append(row)\n    for i in range(n):\n        for j in range(n):\n            print(matrix[i][j]+\" \")\n        print()    \n\ndef vectorsinrepeticion(n):\n    sinrep = {0}\n    for i in range(n):\n        sinrep.add(random.randint(0, 100))\n    sinrep.remove(0)    \n    for i in sinrep:\n        print(i)\n\ndef Diccionario(n):\n    dicc = {}\n       dicc['Programar'] = 'Utilizacion de codigo para ejecutar un programa\ndicc['Futbol'] = 'Deporte con una pelota y arcos'\n\nfor concepto, definicion in dicc.items():\n    print(f'{concepto} -> {definicion}')\n        \ndef pila(n):\n    mipila = []\n    for i in range(n):\n        mipila.append(random.randint(0, 100))\n    while(len(mipila) != 0):\n        print(mipila.pop())\n\ndef cola(n): \n    micola = deque([])\n    for i in range(n):\n        micola.append(random.randint(0, 100))\n\n    while(len(micola) != 0):\n        print(micola.popleft())\nprint(\"Inserte cantidad de datos\")\nn = int(input())\n#No existe switch en python\nprint(\"Vector\")\nvector(n)\nprint(\"Vector sin repetición\")\nvectorsinrepeticion(n)\nprint(\"Diccionario\")\nDiccionario(n)\nprint(\"Pila\")\npila(n)\nprint(\"Cola\")\ncola(n);\nprint(\"Matriz\")\nmatriz(n)\n",
    "orden": 1,
    "suborden": 0,
    "fecha_creacion": "2020-12-06 20:56:45",
    "fecha_modificacion": "2022-03-08 14:36:15"
  }
]